/******/ ;(() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ 6870: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.formatNames = exports.fastFormats = exports.fullFormats = void 0
      function fmtDef(validate, compare) {
        return { validate, compare }
      }
      exports.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(time, compareTime),
        'date-time': fmtDef(date_time, compareDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration:
          /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri,
        'uri-reference':
          /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        'uri-template':
          /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email:
          /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname:
          /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        'json-pointer': /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        'json-pointer-uri-fragment':
          /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        'relative-json-pointer':
          /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: 'number', validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: 'number', validate: validateInt64 },
        // C-type float
        float: { type: 'number', validate: validateNumber },
        // C-type double
        double: { type: 'number', validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      }
      exports.fastFormats = {
        ...exports.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(
          /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
          compareTime
        ),
        'date-time': fmtDef(
          /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
          compareDateTime
        ),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        'uri-reference':
          /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email:
          /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      }
      exports.formatNames = Object.keys(exports.fullFormats)
      function isLeapYear(year) {
        // https://tools.ietf.org/html/rfc3339#appendix-C
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)
      }
      const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/
      const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      function date(str) {
        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
        const matches = DATE.exec(str)
        if (!matches) return false
        const year = +matches[1]
        const month = +matches[2]
        const day = +matches[3]
        return (
          month >= 1 &&
          month <= 12 &&
          day >= 1 &&
          day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])
        )
      }
      function compareDate(d1, d2) {
        if (!(d1 && d2)) return undefined
        if (d1 > d2) return 1
        if (d1 < d2) return -1
        return 0
      }
      const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i
      function time(str, withTimeZone) {
        const matches = TIME.exec(str)
        if (!matches) return false
        const hour = +matches[1]
        const minute = +matches[2]
        const second = +matches[3]
        const timeZone = matches[5]
        return (
          ((hour <= 23 && minute <= 59 && second <= 59) ||
            (hour === 23 && minute === 59 && second === 60)) &&
          (!withTimeZone || timeZone !== '')
        )
      }
      function compareTime(t1, t2) {
        if (!(t1 && t2)) return undefined
        const a1 = TIME.exec(t1)
        const a2 = TIME.exec(t2)
        if (!(a1 && a2)) return undefined
        t1 = a1[1] + a1[2] + a1[3] + (a1[4] || '')
        t2 = a2[1] + a2[2] + a2[3] + (a2[4] || '')
        if (t1 > t2) return 1
        if (t1 < t2) return -1
        return 0
      }
      const DATE_TIME_SEPARATOR = /t|\s/i
      function date_time(str) {
        // http://tools.ietf.org/html/rfc3339#section-5.6
        const dateTime = str.split(DATE_TIME_SEPARATOR)
        return (
          dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true)
        )
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2)) return undefined
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR)
        const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR)
        const res = compareDate(d1, d2)
        if (res === undefined) return undefined
        return res || compareTime(t1, t2)
      }
      const NOT_URI_FRAGMENT = /\/|:/
      const URI =
        /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i
      function uri(str) {
        // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
        return NOT_URI_FRAGMENT.test(str) && URI.test(str)
      }
      const BYTE =
        /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm
      function byte(str) {
        BYTE.lastIndex = 0
        return BYTE.test(str)
      }
      const MIN_INT32 = -(2 ** 31)
      const MAX_INT32 = 2 ** 31 - 1
      function validateInt32(value) {
        return (
          Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32
        )
      }
      function validateInt64(value) {
        // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
        return Number.isInteger(value)
      }
      function validateNumber() {
        return true
      }
      const Z_ANCHOR = /[^\\]\\Z/
      function regex(str) {
        if (Z_ANCHOR.test(str)) return false
        try {
          new RegExp(str)
          return true
        } catch (e) {
          return false
        }
      }
      //# sourceMappingURL=formats.js.map

      /***/
    },

    /***/ 5477: /***/ (module, exports, __webpack_require__) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const formats_1 = __webpack_require__(6870)
      const limit_1 = __webpack_require__(7963)
      const codegen_1 = __webpack_require__(3487)
      const fullName = new codegen_1.Name('fullFormats')
      const fastName = new codegen_1.Name('fastFormats')
      const formatsPlugin = (ajv, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats(ajv, opts, formats_1.fullFormats, fullName)
          return ajv
        }
        const [formats, exportName] =
          opts.mode === 'fast'
            ? [formats_1.fastFormats, fastName]
            : [formats_1.fullFormats, fullName]
        const list = opts.formats || formats_1.formatNames
        addFormats(ajv, list, formats, exportName)
        if (opts.keywords) limit_1.default(ajv)
        return ajv
      }
      formatsPlugin.get = (name, mode = 'full') => {
        const formats =
          mode === 'fast' ? formats_1.fastFormats : formats_1.fullFormats
        const f = formats[name]
        if (!f) throw new Error(`Unknown format "${name}"`)
        return f
      }
      function addFormats(ajv, list, fs, exportName) {
        var _a
        var _b
        ;(_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0
          ? _a
          : (_b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`)
        for (const f of list) ajv.addFormat(f, fs[f])
      }
      module.exports = exports = formatsPlugin
      Object.defineProperty(exports, '__esModule', { value: true })
      exports['default'] = formatsPlugin
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 7963: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.formatLimitDefinition = void 0
      const ajv_1 = __webpack_require__(1581)
      const codegen_1 = __webpack_require__(3487)
      const ops = codegen_1.operators
      const KWDs = {
        formatMaximum: { okStr: '<=', ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: '>=', ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: '<', ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: '>', ok: ops.GT, fail: ops.LTE }
      }
      const error = {
        message: ({ keyword, schemaCode }) =>
          codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) =>
          codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      }
      exports.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: 'string',
        schemaType: 'string',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword, it } = cxt
          const { opts, self } = it
          if (!opts.validateFormats) return
          const fCxt = new ajv_1.KeywordCxt(
            it,
            self.RULES.all.format.definition,
            'format'
          )
          if (fCxt.$data) validate$DataFormat()
          else validateFormat()
          function validate$DataFormat() {
            const fmts = gen.scopeValue('formats', {
              ref: self.formats,
              code: opts.code.formats
            })
            const fmt = gen.const(
              'fmt',
              codegen_1._`${fmts}[${fCxt.schemaCode}]`
            )
            cxt.fail$data(
              codegen_1.or(
                codegen_1._`typeof ${fmt} != "object"`,
                codegen_1._`${fmt} instanceof RegExp`,
                codegen_1._`typeof ${fmt}.compare != "function"`,
                compareCode(fmt)
              )
            )
          }
          function validateFormat() {
            const format = fCxt.schema
            const fmtDef = self.formats[format]
            if (!fmtDef || fmtDef === true) return
            if (
              typeof fmtDef != 'object' ||
              fmtDef instanceof RegExp ||
              typeof fmtDef.compare != 'function'
            ) {
              throw new Error(
                `"${keyword}": format "${format}" does not define "compare" function`
              )
            }
            const fmt = gen.scopeValue('formats', {
              key: format,
              ref: fmtDef,
              code: opts.code.formats
                ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(
                    format
                  )}`
                : undefined
            })
            cxt.fail$data(compareCode(fmt))
          }
          function compareCode(fmt) {
            return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`
          }
        },
        dependencies: ['format']
      }
      const formatLimitPlugin = (ajv) => {
        ajv.addKeyword(exports.formatLimitDefinition)
        return ajv
      }
      exports['default'] = formatLimitPlugin
      //# sourceMappingURL=limit.js.map

      /***/
    },

    /***/ 1581: /***/ (module, exports, __webpack_require__) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.CodeGen =
        exports.Name =
        exports.nil =
        exports.stringify =
        exports.str =
        exports._ =
        exports.KeywordCxt =
          void 0
      const core_1 = __webpack_require__(7159)
      const draft7_1 = __webpack_require__(3924)
      const discriminator_1 = __webpack_require__(1240)
      const draft7MetaSchema = __webpack_require__(98)
      const META_SUPPORT_DATA = ['/properties']
      const META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema'
      class Ajv extends core_1.default {
        _addVocabularies() {
          super._addVocabularies()
          draft7_1.default.forEach((v) => this.addVocabulary(v))
          if (this.opts.discriminator) this.addKeyword(discriminator_1.default)
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema()
          if (!this.opts.meta) return
          const metaSchema = this.opts.$data
            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
            : draft7MetaSchema
          this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)
          this.refs['http://json-schema.org/schema'] = META_SCHEMA_ID
        }
        defaultMeta() {
          return (this.opts.defaultMeta =
            super.defaultMeta() ||
            (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))
        }
      }
      module.exports = exports = Ajv
      Object.defineProperty(exports, '__esModule', { value: true })
      exports['default'] = Ajv
      var validate_1 = __webpack_require__(4815)
      Object.defineProperty(exports, 'KeywordCxt', {
        enumerable: true,
        get: function () {
          return validate_1.KeywordCxt
        }
      })
      var codegen_1 = __webpack_require__(3487)
      Object.defineProperty(exports, '_', {
        enumerable: true,
        get: function () {
          return codegen_1._
        }
      })
      Object.defineProperty(exports, 'str', {
        enumerable: true,
        get: function () {
          return codegen_1.str
        }
      })
      Object.defineProperty(exports, 'stringify', {
        enumerable: true,
        get: function () {
          return codegen_1.stringify
        }
      })
      Object.defineProperty(exports, 'nil', {
        enumerable: true,
        get: function () {
          return codegen_1.nil
        }
      })
      Object.defineProperty(exports, 'Name', {
        enumerable: true,
        get: function () {
          return codegen_1.Name
        }
      })
      Object.defineProperty(exports, 'CodeGen', {
        enumerable: true,
        get: function () {
          return codegen_1.CodeGen
        }
      })
      //# sourceMappingURL=ajv.js.map

      /***/
    },

    /***/ 7023: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.regexpCode =
        exports.getEsmExportName =
        exports.getProperty =
        exports.safeStringify =
        exports.stringify =
        exports.strConcat =
        exports.addCodeArg =
        exports.str =
        exports._ =
        exports.nil =
        exports._Code =
        exports.Name =
        exports.IDENTIFIER =
        exports._CodeOrName =
          void 0
      class _CodeOrName {}
      exports._CodeOrName = _CodeOrName
      exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i
      class Name extends _CodeOrName {
        constructor(s) {
          super()
          if (!exports.IDENTIFIER.test(s))
            throw new Error('CodeGen: name must be a valid identifier')
          this.str = s
        }
        toString() {
          return this.str
        }
        emptyStr() {
          return false
        }
        get names() {
          return { [this.str]: 1 }
        }
      }
      exports.Name = Name
      class _Code extends _CodeOrName {
        constructor(code) {
          super()
          this._items = typeof code === 'string' ? [code] : code
        }
        toString() {
          return this.str
        }
        emptyStr() {
          if (this._items.length > 1) return false
          const item = this._items[0]
          return item === '' || item === '""'
        }
        get str() {
          var _a
          return (_a = this._str) !== null && _a !== void 0
            ? _a
            : (this._str = this._items.reduce((s, c) => `${s}${c}`, ''))
        }
        get names() {
          var _a
          return (_a = this._names) !== null && _a !== void 0
            ? _a
            : (this._names = this._items.reduce((names, c) => {
                if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1
                return names
              }, {}))
        }
      }
      exports._Code = _Code
      exports.nil = new _Code('')
      function _(strs, ...args) {
        const code = [strs[0]]
        let i = 0
        while (i < args.length) {
          addCodeArg(code, args[i])
          code.push(strs[++i])
        }
        return new _Code(code)
      }
      exports._ = _
      const plus = new _Code('+')
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])]
        let i = 0
        while (i < args.length) {
          expr.push(plus)
          addCodeArg(expr, args[i])
          expr.push(plus, safeStringify(strs[++i]))
        }
        optimize(expr)
        return new _Code(expr)
      }
      exports.str = str
      function addCodeArg(code, arg) {
        if (arg instanceof _Code) code.push(...arg._items)
        else if (arg instanceof Name) code.push(arg)
        else code.push(interpolate(arg))
      }
      exports.addCodeArg = addCodeArg
      function optimize(expr) {
        let i = 1
        while (i < expr.length - 1) {
          if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1])
            if (res !== undefined) {
              expr.splice(i - 1, 3, res)
              continue
            }
            expr[i++] = '+'
          }
          i++
        }
      }
      function mergeExprItems(a, b) {
        if (b === '""') return a
        if (a === '""') return b
        if (typeof a == 'string') {
          if (b instanceof Name || a[a.length - 1] !== '"') return
          if (typeof b != 'string') return `${a.slice(0, -1)}${b}"`
          if (b[0] === '"') return a.slice(0, -1) + b.slice(1)
          return
        }
        if (typeof b == 'string' && b[0] === '"' && !(a instanceof Name))
          return `"${a}${b.slice(1)}`
        return
      }
      function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`
      }
      exports.strConcat = strConcat
      // TODO do not allow arrays here
      function interpolate(x) {
        return typeof x == 'number' || typeof x == 'boolean' || x === null
          ? x
          : safeStringify(Array.isArray(x) ? x.join(',') : x)
      }
      function stringify(x) {
        return new _Code(safeStringify(x))
      }
      exports.stringify = stringify
      function safeStringify(x) {
        return JSON.stringify(x)
          .replace(/\u2028/g, '\\u2028')
          .replace(/\u2029/g, '\\u2029')
      }
      exports.safeStringify = safeStringify
      function getProperty(key) {
        return typeof key == 'string' && exports.IDENTIFIER.test(key)
          ? new _Code(`.${key}`)
          : _`[${key}]`
      }
      exports.getProperty = getProperty
      //Does best effort to format the name properly
      function getEsmExportName(key) {
        if (typeof key == 'string' && exports.IDENTIFIER.test(key)) {
          return new _Code(`${key}`)
        }
        throw new Error(
          `CodeGen: invalid export name: ${key}, use explicit $id name mapping`
        )
      }
      exports.getEsmExportName = getEsmExportName
      function regexpCode(rx) {
        return new _Code(rx.toString())
      }
      exports.regexpCode = regexpCode
      //# sourceMappingURL=code.js.map

      /***/
    },

    /***/ 3487: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.or =
        exports.and =
        exports.not =
        exports.CodeGen =
        exports.operators =
        exports.varKinds =
        exports.ValueScopeName =
        exports.ValueScope =
        exports.Scope =
        exports.Name =
        exports.regexpCode =
        exports.stringify =
        exports.getProperty =
        exports.nil =
        exports.strConcat =
        exports.str =
        exports._ =
          void 0
      const code_1 = __webpack_require__(7023)
      const scope_1 = __webpack_require__(8490)
      var code_2 = __webpack_require__(7023)
      Object.defineProperty(exports, '_', {
        enumerable: true,
        get: function () {
          return code_2._
        }
      })
      Object.defineProperty(exports, 'str', {
        enumerable: true,
        get: function () {
          return code_2.str
        }
      })
      Object.defineProperty(exports, 'strConcat', {
        enumerable: true,
        get: function () {
          return code_2.strConcat
        }
      })
      Object.defineProperty(exports, 'nil', {
        enumerable: true,
        get: function () {
          return code_2.nil
        }
      })
      Object.defineProperty(exports, 'getProperty', {
        enumerable: true,
        get: function () {
          return code_2.getProperty
        }
      })
      Object.defineProperty(exports, 'stringify', {
        enumerable: true,
        get: function () {
          return code_2.stringify
        }
      })
      Object.defineProperty(exports, 'regexpCode', {
        enumerable: true,
        get: function () {
          return code_2.regexpCode
        }
      })
      Object.defineProperty(exports, 'Name', {
        enumerable: true,
        get: function () {
          return code_2.Name
        }
      })
      var scope_2 = __webpack_require__(8490)
      Object.defineProperty(exports, 'Scope', {
        enumerable: true,
        get: function () {
          return scope_2.Scope
        }
      })
      Object.defineProperty(exports, 'ValueScope', {
        enumerable: true,
        get: function () {
          return scope_2.ValueScope
        }
      })
      Object.defineProperty(exports, 'ValueScopeName', {
        enumerable: true,
        get: function () {
          return scope_2.ValueScopeName
        }
      })
      Object.defineProperty(exports, 'varKinds', {
        enumerable: true,
        get: function () {
          return scope_2.varKinds
        }
      })
      exports.operators = {
        GT: new code_1._Code('>'),
        GTE: new code_1._Code('>='),
        LT: new code_1._Code('<'),
        LTE: new code_1._Code('<='),
        EQ: new code_1._Code('==='),
        NEQ: new code_1._Code('!=='),
        NOT: new code_1._Code('!'),
        OR: new code_1._Code('||'),
        AND: new code_1._Code('&&'),
        ADD: new code_1._Code('+')
      }
      class Node {
        optimizeNodes() {
          return this
        }
        optimizeNames(_names, _constants) {
          return this
        }
      }
      class Def extends Node {
        constructor(varKind, name, rhs) {
          super()
          this.varKind = varKind
          this.name = name
          this.rhs = rhs
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind
          const rhs = this.rhs === undefined ? '' : ` = ${this.rhs}`
          return `${varKind} ${this.name}${rhs};` + _n
        }
        optimizeNames(names, constants) {
          if (!names[this.name.str]) return
          if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)
          return this
        }
        get names() {
          return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {}
        }
      }
      class Assign extends Node {
        constructor(lhs, rhs, sideEffects) {
          super()
          this.lhs = lhs
          this.rhs = rhs
          this.sideEffects = sideEffects
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n
        }
        optimizeNames(names, constants) {
          if (
            this.lhs instanceof code_1.Name &&
            !names[this.lhs.str] &&
            !this.sideEffects
          )
            return
          this.rhs = optimizeExpr(this.rhs, names, constants)
          return this
        }
        get names() {
          const names =
            this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names }
          return addExprNames(names, this.rhs)
        }
      }
      class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects)
          this.op = op
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n
        }
      }
      class Label extends Node {
        constructor(label) {
          super()
          this.label = label
          this.names = {}
        }
        render({ _n }) {
          return `${this.label}:` + _n
        }
      }
      class Break extends Node {
        constructor(label) {
          super()
          this.label = label
          this.names = {}
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : ''
          return `break${label};` + _n
        }
      }
      class Throw extends Node {
        constructor(error) {
          super()
          this.error = error
        }
        render({ _n }) {
          return `throw ${this.error};` + _n
        }
        get names() {
          return this.error.names
        }
      }
      class AnyCode extends Node {
        constructor(code) {
          super()
          this.code = code
        }
        render({ _n }) {
          return `${this.code};` + _n
        }
        optimizeNodes() {
          return `${this.code}` ? this : undefined
        }
        optimizeNames(names, constants) {
          this.code = optimizeExpr(this.code, names, constants)
          return this
        }
        get names() {
          return this.code instanceof code_1._CodeOrName ? this.code.names : {}
        }
      }
      class ParentNode extends Node {
        constructor(nodes = []) {
          super()
          this.nodes = nodes
        }
        render(opts) {
          return this.nodes.reduce((code, n) => code + n.render(opts), '')
        }
        optimizeNodes() {
          const { nodes } = this
          let i = nodes.length
          while (i--) {
            const n = nodes[i].optimizeNodes()
            if (Array.isArray(n)) nodes.splice(i, 1, ...n)
            else if (n) nodes[i] = n
            else nodes.splice(i, 1)
          }
          return nodes.length > 0 ? this : undefined
        }
        optimizeNames(names, constants) {
          const { nodes } = this
          let i = nodes.length
          while (i--) {
            // iterating backwards improves 1-pass optimization
            const n = nodes[i]
            if (n.optimizeNames(names, constants)) continue
            subtractNames(names, n.names)
            nodes.splice(i, 1)
          }
          return nodes.length > 0 ? this : undefined
        }
        get names() {
          return this.nodes.reduce((names, n) => addNames(names, n.names), {})
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return '{' + opts._n + super.render(opts) + '}' + opts._n
        }
      }
      class Root extends ParentNode {}
      class Else extends BlockNode {}
      Else.kind = 'else'
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes)
          this.condition = condition
        }
        render(opts) {
          let code = `if(${this.condition})` + super.render(opts)
          if (this.else) code += 'else ' + this.else.render(opts)
          return code
        }
        optimizeNodes() {
          super.optimizeNodes()
          const cond = this.condition
          if (cond === true) return this.nodes // else is ignored here
          let e = this.else
          if (e) {
            const ns = e.optimizeNodes()
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns
          }
          if (e) {
            if (cond === false) return e instanceof If ? e : e.nodes
            if (this.nodes.length) return this
            return new If(not(cond), e instanceof If ? [e] : e.nodes)
          }
          if (cond === false || !this.nodes.length) return undefined
          return this
        }
        optimizeNames(names, constants) {
          var _a
          this.else =
            (_a = this.else) === null || _a === void 0
              ? void 0
              : _a.optimizeNames(names, constants)
          if (!(super.optimizeNames(names, constants) || this.else)) return
          this.condition = optimizeExpr(this.condition, names, constants)
          return this
        }
        get names() {
          const names = super.names
          addExprNames(names, this.condition)
          if (this.else) addNames(names, this.else.names)
          return names
        }
      }
      If.kind = 'if'
      class For extends BlockNode {}
      For.kind = 'for'
      class ForLoop extends For {
        constructor(iteration) {
          super()
          this.iteration = iteration
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts)
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants)) return
          this.iteration = optimizeExpr(this.iteration, names, constants)
          return this
        }
        get names() {
          return addNames(super.names, this.iteration.names)
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from, to) {
          super()
          this.varKind = varKind
          this.name = name
          this.from = from
          this.to = to
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind
          const { name, from, to } = this
          return (
            `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` +
            super.render(opts)
          )
        }
        get names() {
          const names = addExprNames(super.names, this.from)
          return addExprNames(names, this.to)
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super()
          this.loop = loop
          this.varKind = varKind
          this.name = name
          this.iterable = iterable
        }
        render(opts) {
          return (
            `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
            super.render(opts)
          )
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants)) return
          this.iterable = optimizeExpr(this.iterable, names, constants)
          return this
        }
        get names() {
          return addNames(super.names, this.iterable.names)
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super()
          this.name = name
          this.args = args
          this.async = async
        }
        render(opts) {
          const _async = this.async ? 'async ' : ''
          return (
            `${_async}function ${this.name}(${this.args})` + super.render(opts)
          )
        }
      }
      Func.kind = 'func'
      class Return extends ParentNode {
        render(opts) {
          return 'return ' + super.render(opts)
        }
      }
      Return.kind = 'return'
      class Try extends BlockNode {
        render(opts) {
          let code = 'try' + super.render(opts)
          if (this.catch) code += this.catch.render(opts)
          if (this.finally) code += this.finally.render(opts)
          return code
        }
        optimizeNodes() {
          var _a, _b
          super.optimizeNodes()
          ;(_a = this.catch) === null || _a === void 0
            ? void 0
            : _a.optimizeNodes()
          ;(_b = this.finally) === null || _b === void 0
            ? void 0
            : _b.optimizeNodes()
          return this
        }
        optimizeNames(names, constants) {
          var _a, _b
          super.optimizeNames(names, constants)
          ;(_a = this.catch) === null || _a === void 0
            ? void 0
            : _a.optimizeNames(names, constants)
          ;(_b = this.finally) === null || _b === void 0
            ? void 0
            : _b.optimizeNames(names, constants)
          return this
        }
        get names() {
          const names = super.names
          if (this.catch) addNames(names, this.catch.names)
          if (this.finally) addNames(names, this.finally.names)
          return names
        }
      }
      class Catch extends BlockNode {
        constructor(error) {
          super()
          this.error = error
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts)
        }
      }
      Catch.kind = 'catch'
      class Finally extends BlockNode {
        render(opts) {
          return 'finally' + super.render(opts)
        }
      }
      Finally.kind = 'finally'
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {}
          this._blockStarts = []
          this._constants = {}
          this.opts = { ...opts, _n: opts.lines ? '\n' : '' }
          this._extScope = extScope
          this._scope = new scope_1.Scope({ parent: extScope })
          this._nodes = [new Root()]
        }
        toString() {
          return this._root.render(this.opts)
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix)
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix)
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value)
          const vs =
            this._values[name.prefix] || (this._values[name.prefix] = new Set())
          vs.add(name)
          return name
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef)
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values)
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values)
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix)
          if (rhs !== undefined && constant) this._constants[name.str] = rhs
          this._leafNode(new Def(varKind, name, rhs))
          return name
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant)
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant)
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant)
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects))
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs))
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
          if (typeof c == 'function') c()
          else if (c !== code_1.nil) this._leafNode(new AnyCode(c))
          return this
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
          const code = ['{']
          for (const [key, value] of keyValues) {
            if (code.length > 1) code.push(',')
            code.push(key)
            if (key !== value || this.opts.es5) {
              code.push(':')
              ;(0, code_1.addCodeArg)(code, value)
            }
          }
          code.push('}')
          return new code_1._Code(code)
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition))
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf()
          } else if (thenBody) {
            this.code(thenBody).endIf()
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body')
          }
          return this
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition))
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else())
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else)
        }
        _for(node, forBody) {
          this._blockNode(node)
          if (forBody) this.code(forBody).endFor()
          return this
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody)
        }
        // `for` statement for a range of values
        forRange(
          nameOrPrefix,
          from,
          to,
          forBody,
          varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let
        ) {
          const name = this._scope.toName(nameOrPrefix)
          return this._for(new ForRange(varKind, name, from, to), () =>
            forBody(name)
          )
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(
          nameOrPrefix,
          iterable,
          forBody,
          varKind = scope_1.varKinds.const
        ) {
          const name = this._scope.toName(nameOrPrefix)
          if (this.opts.es5) {
            const arr =
              iterable instanceof code_1.Name
                ? iterable
                : this.var('_arr', iterable)
            return this.forRange('_i', 0, (0, code_1._)`${arr}.length`, (i) => {
              this.var(name, (0, code_1._)`${arr}[${i}]`)
              forBody(name)
            })
          }
          return this._for(new ForIter('of', varKind, name, iterable), () =>
            forBody(name)
          )
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(
          nameOrPrefix,
          obj,
          forBody,
          varKind = this.opts.es5
            ? scope_1.varKinds.var
            : scope_1.varKinds.const
        ) {
          if (this.opts.ownProperties) {
            return this.forOf(
              nameOrPrefix,
              (0, code_1._)`Object.keys(${obj})`,
              forBody
            )
          }
          const name = this._scope.toName(nameOrPrefix)
          return this._for(new ForIter('in', varKind, name, obj), () =>
            forBody(name)
          )
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For)
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label(label))
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label))
        }
        // `return` statement
        return(value) {
          const node = new Return()
          this._blockNode(node)
          this.code(value)
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node')
          return this._endBlockNode(Return)
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"')
          const node = new Try()
          this._blockNode(node)
          this.code(tryBody)
          if (catchCode) {
            const error = this.name('e')
            this._currNode = node.catch = new Catch(error)
            catchCode(error)
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally()
            this.code(finallyCode)
          }
          return this._endBlockNode(Catch, Finally)
        }
        // `throw` statement
        throw(error) {
          return this._leafNode(new Throw(error))
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length)
          if (body) this.code(body).endBlock(nodeCount)
          return this
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop()
          if (len === undefined)
            throw new Error('CodeGen: not in self-balancing block')
          const toClose = this._nodes.length - len
          if (
            toClose < 0 ||
            (nodeCount !== undefined && toClose !== nodeCount)
          ) {
            throw new Error(
              `CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`
            )
          }
          this._nodes.length = len
          return this
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_1.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async))
          if (funcBody) this.code(funcBody).endFunc()
          return this
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func)
        }
        optimize(n = 1) {
          while (n-- > 0) {
            this._root.optimizeNodes()
            this._root.optimizeNames(this._root.names, this._constants)
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node)
          return this
        }
        _blockNode(node) {
          this._currNode.nodes.push(node)
          this._nodes.push(node)
        }
        _endBlockNode(N1, N2) {
          const n = this._currNode
          if (n instanceof N1 || (N2 && n instanceof N2)) {
            this._nodes.pop()
            return this
          }
          throw new Error(
            `CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`
          )
        }
        _elseNode(node) {
          const n = this._currNode
          if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"')
          }
          this._currNode = n.else = node
          return this
        }
        get _root() {
          return this._nodes[0]
        }
        get _currNode() {
          const ns = this._nodes
          return ns[ns.length - 1]
        }
        set _currNode(node) {
          const ns = this._nodes
          ns[ns.length - 1] = node
        }
      }
      exports.CodeGen = CodeGen
      function addNames(names, from) {
        for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)
        return names
      }
      function addExprNames(names, from) {
        return from instanceof code_1._CodeOrName
          ? addNames(names, from.names)
          : names
      }
      function optimizeExpr(expr, names, constants) {
        if (expr instanceof code_1.Name) return replaceName(expr)
        if (!canOptimize(expr)) return expr
        return new code_1._Code(
          expr._items.reduce((items, c) => {
            if (c instanceof code_1.Name) c = replaceName(c)
            if (c instanceof code_1._Code) items.push(...c._items)
            else items.push(c)
            return items
          }, [])
        )
        function replaceName(n) {
          const c = constants[n.str]
          if (c === undefined || names[n.str] !== 1) return n
          delete names[n.str]
          return c
        }
        function canOptimize(e) {
          return (
            e instanceof code_1._Code &&
            e._items.some(
              (c) =>
                c instanceof code_1.Name &&
                names[c.str] === 1 &&
                constants[c.str] !== undefined
            )
          )
        }
      }
      function subtractNames(names, from) {
        for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)
      }
      function not(x) {
        return typeof x == 'boolean' || typeof x == 'number' || x === null
          ? !x
          : (0, code_1._)`!${par(x)}`
      }
      exports.not = not
      const andCode = mappend(exports.operators.AND)
      // boolean AND (&&) expression with the passed arguments
      function and(...args) {
        return args.reduce(andCode)
      }
      exports.and = and
      const orCode = mappend(exports.operators.OR)
      // boolean OR (||) expression with the passed arguments
      function or(...args) {
        return args.reduce(orCode)
      }
      exports.or = or
      function mappend(op) {
        return (x, y) =>
          x === code_1.nil
            ? y
            : y === code_1.nil
            ? x
            : (0, code_1._)`${par(x)} ${op} ${par(y)}`
      }
      function par(x) {
        return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`
      }
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 8490: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.ValueScope =
        exports.ValueScopeName =
        exports.Scope =
        exports.varKinds =
        exports.UsedValueState =
          void 0
      const code_1 = __webpack_require__(7023)
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`)
          this.value = name.value
        }
      }
      var UsedValueState
      ;(function (UsedValueState) {
        UsedValueState[(UsedValueState['Started'] = 0)] = 'Started'
        UsedValueState[(UsedValueState['Completed'] = 1)] = 'Completed'
      })(
        (UsedValueState =
          exports.UsedValueState || (exports.UsedValueState = {}))
      )
      exports.varKinds = {
        const: new code_1.Name('const'),
        let: new code_1.Name('let'),
        var: new code_1.Name('var')
      }
      class Scope {
        constructor({ prefixes, parent } = {}) {
          this._names = {}
          this._prefixes = prefixes
          this._parent = parent
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_1.Name
            ? nameOrPrefix
            : this.name(nameOrPrefix)
        }
        name(prefix) {
          return new code_1.Name(this._newName(prefix))
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix)
          return `${prefix}${ng.index++}`
        }
        _nameGroup(prefix) {
          var _a, _b
          if (
            ((_b =
              (_a = this._parent) === null || _a === void 0
                ? void 0
                : _a._prefixes) === null || _b === void 0
              ? void 0
              : _b.has(prefix)) ||
            (this._prefixes && !this._prefixes.has(prefix))
          ) {
            throw new Error(
              `CodeGen: prefix "${prefix}" is not allowed in this scope`
            )
          }
          return (this._names[prefix] = { prefix, index: 0 })
        }
      }
      exports.Scope = Scope
      class ValueScopeName extends code_1.Name {
        constructor(prefix, nameStr) {
          super(nameStr)
          this.prefix = prefix
        }
        setValue(value, { property, itemIndex }) {
          this.value = value
          this.scopePath = (0, code_1._)`.${new code_1.Name(
            property
          )}[${itemIndex}]`
        }
      }
      exports.ValueScopeName = ValueScopeName
      const line = (0, code_1._)`\n`
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts)
          this._values = {}
          this._scope = opts.scope
          this.opts = { ...opts, _n: opts.lines ? line : code_1.nil }
        }
        get() {
          return this._scope
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix))
        }
        value(nameOrPrefix, value) {
          var _a
          if (value.ref === undefined)
            throw new Error('CodeGen: ref must be passed in value')
          const name = this.toName(nameOrPrefix)
          const { prefix } = name
          const valueKey =
            (_a = value.key) !== null && _a !== void 0 ? _a : value.ref
          let vs = this._values[prefix]
          if (vs) {
            const _name = vs.get(valueKey)
            if (_name) return _name
          } else {
            vs = this._values[prefix] = new Map()
          }
          vs.set(valueKey, name)
          const s = this._scope[prefix] || (this._scope[prefix] = [])
          const itemIndex = s.length
          s[itemIndex] = value.ref
          name.setValue(value, { property: prefix, itemIndex })
          return name
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix]
          if (!vs) return
          return vs.get(keyOrRef)
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === undefined)
              throw new Error(`CodeGen: name "${name}" has no value`)
            return (0, code_1._)`${scopeName}${name.scopePath}`
          })
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(
            values,
            (name) => {
              if (name.value === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`)
              return name.value.code
            },
            usedValues,
            getCode
          )
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code = code_1.nil
          for (const prefix in values) {
            const vs = values[prefix]
            if (!vs) continue
            const nameSet = (usedValues[prefix] =
              usedValues[prefix] || new Map())
            vs.forEach((name) => {
              if (nameSet.has(name)) return
              nameSet.set(name, UsedValueState.Started)
              let c = valueCode(name)
              if (c) {
                const def = this.opts.es5
                  ? exports.varKinds.var
                  : exports.varKinds.const
                code = (0,
                code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`
              } else if (
                (c =
                  getCode === null || getCode === void 0
                    ? void 0
                    : getCode(name))
              ) {
                code = (0, code_1._)`${code}${c}${this.opts._n}`
              } else {
                throw new ValueError(name)
              }
              nameSet.set(name, UsedValueState.Completed)
            })
          }
          return code
        }
      }
      exports.ValueScope = ValueScope
      //# sourceMappingURL=scope.js.map

      /***/
    },

    /***/ 4181: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.extendErrors =
        exports.resetErrorsCount =
        exports.reportExtraError =
        exports.reportError =
        exports.keyword$DataError =
        exports.keywordError =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const names_1 = __webpack_require__(2141)
      exports.keywordError = {
        message: ({ keyword }) =>
          (0, codegen_1.str)`must pass "${keyword}" keyword validation`
      }
      exports.keyword$DataError = {
        message: ({ keyword, schemaType }) =>
          schemaType
            ? (0,
              codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)`
            : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
      }
      function reportError(
        cxt,
        error = exports.keywordError,
        errorPaths,
        overrideAllErrors
      ) {
        const { it } = cxt
        const { gen, compositeRule, allErrors } = it
        const errObj = errorObjectCode(cxt, error, errorPaths)
        if (
          overrideAllErrors !== null && overrideAllErrors !== void 0
            ? overrideAllErrors
            : compositeRule || allErrors
        ) {
          addError(gen, errObj)
        } else {
          returnErrors(it, (0, codegen_1._)`[${errObj}]`)
        }
      }
      exports.reportError = reportError
      function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it } = cxt
        const { gen, compositeRule, allErrors } = it
        const errObj = errorObjectCode(cxt, error, errorPaths)
        addError(gen, errObj)
        if (!(compositeRule || allErrors)) {
          returnErrors(it, names_1.default.vErrors)
        }
      }
      exports.reportExtraError = reportExtraError
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount)
        gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () =>
          gen.if(
            errsCount,
            () =>
              gen.assign(
                (0, codegen_1._)`${names_1.default.vErrors}.length`,
                errsCount
              ),
            () => gen.assign(names_1.default.vErrors, null)
          )
        )
      }
      exports.resetErrorsCount = resetErrorsCount
      function extendErrors({
        gen,
        keyword,
        schemaValue,
        data,
        errsCount,
        it
      }) {
        /* istanbul ignore if */
        if (errsCount === undefined) throw new Error('ajv implementation error')
        const err = gen.name('err')
        gen.forRange('i', errsCount, names_1.default.errors, (i) => {
          gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`)
          gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () =>
            gen.assign(
              (0, codegen_1._)`${err}.instancePath`,
              (0, codegen_1.strConcat)(
                names_1.default.instancePath,
                it.errorPath
              )
            )
          )
          gen.assign(
            (0, codegen_1._)`${err}.schemaPath`,
            (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`
          )
          if (it.opts.verbose) {
            gen.assign((0, codegen_1._)`${err}.schema`, schemaValue)
            gen.assign((0, codegen_1._)`${err}.data`, data)
          }
        })
      }
      exports.extendErrors = extendErrors
      function addError(gen, errObj) {
        const err = gen.const('err', errObj)
        gen.if(
          (0, codegen_1._)`${names_1.default.vErrors} === null`,
          () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`),
          (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`
        )
        gen.code((0, codegen_1._)`${names_1.default.errors}++`)
      }
      function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it
        if (schemaEnv.$async) {
          gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`)
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, errs)
          gen.return(false)
        }
      }
      const E = {
        keyword: new codegen_1.Name('keyword'),
        schemaPath: new codegen_1.Name('schemaPath'),
        params: new codegen_1.Name('params'),
        propertyName: new codegen_1.Name('propertyName'),
        message: new codegen_1.Name('message'),
        schema: new codegen_1.Name('schema'),
        parentSchema: new codegen_1.Name('parentSchema')
      }
      function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it
        if (createErrors === false) return (0, codegen_1._)`{}`
        return errorObject(cxt, error, errorPaths)
      }
      function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt
        const keyValues = [
          errorInstancePath(it, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ]
        extraErrorProps(cxt, error, keyValues)
        return gen.object(...keyValues)
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath
          ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(
              instancePath,
              util_1.Type.Str
            )}`
          : errorPath
        return [
          names_1.default.instancePath,
          (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)
        ]
      }
      function errorSchemaPath(
        { keyword, it: { errSchemaPath } },
        { schemaPath, parentSchema }
      ) {
        let schPath = parentSchema
          ? errSchemaPath
          : (0, codegen_1.str)`${errSchemaPath}/${keyword}`
        if (schemaPath) {
          schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(
            schemaPath,
            util_1.Type.Str
          )}`
        }
        return [E.schemaPath, schPath]
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword, data, schemaValue, it } = cxt
        const { opts, propertyName, topSchemaRef, schemaPath } = it
        keyValues.push(
          [E.keyword, keyword],
          [
            E.params,
            typeof params == 'function'
              ? params(cxt)
              : params || (0, codegen_1._)`{}`
          ]
        )
        if (opts.messages) {
          keyValues.push([
            E.message,
            typeof message == 'function' ? message(cxt) : message
          ])
        }
        if (opts.verbose) {
          keyValues.push(
            [E.schema, schemaValue],
            [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`],
            [names_1.default.data, data]
          )
        }
        if (propertyName) keyValues.push([E.propertyName, propertyName])
      }
      //# sourceMappingURL=errors.js.map

      /***/
    },

    /***/ 5173: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.resolveSchema =
        exports.getCompilingSchema =
        exports.resolveRef =
        exports.compileSchema =
        exports.SchemaEnv =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const validation_error_1 = __webpack_require__(7426)
      const names_1 = __webpack_require__(2141)
      const resolve_1 = __webpack_require__(2531)
      const util_1 = __webpack_require__(6776)
      const validate_1 = __webpack_require__(4815)
      class SchemaEnv {
        constructor(env) {
          var _a
          this.refs = {}
          this.dynamicAnchors = {}
          let schema
          if (typeof env.schema == 'object') schema = env.schema
          this.schema = env.schema
          this.schemaId = env.schemaId
          this.root = env.root || this
          this.baseId =
            (_a = env.baseId) !== null && _a !== void 0
              ? _a
              : (0, resolve_1.normalizeId)(
                  schema === null || schema === void 0
                    ? void 0
                    : schema[env.schemaId || '$id']
                )
          this.schemaPath = env.schemaPath
          this.localRefs = env.localRefs
          this.meta = env.meta
          this.$async =
            schema === null || schema === void 0 ? void 0 : schema.$async
          this.refs = {}
        }
      }
      exports.SchemaEnv = SchemaEnv
      // let codeSize = 0
      // let nodeCount = 0
      // Compiles schema in SchemaEnv
      function compileSchema(sch) {
        // TODO refactor - remove compilations
        const _sch = getCompilingSchema.call(this, sch)
        if (_sch) return _sch
        const rootId = (0, resolve_1.getFullPath)(
          this.opts.uriResolver,
          sch.root.baseId
        ) // TODO if getFullPath removed 1 tests fails
        const { es5, lines } = this.opts.code
        const { ownProperties } = this.opts
        const gen = new codegen_1.CodeGen(this.scope, {
          es5,
          lines,
          ownProperties
        })
        let _ValidationError
        if (sch.$async) {
          _ValidationError = gen.scopeValue('Error', {
            ref: validation_error_1.default,
            code: (0,
            codegen_1._)`require("ajv/dist/runtime/validation_error").default`
          })
        }
        const validateName = gen.scopeName('validate')
        sch.validateName = validateName
        const schemaCxt = {
          gen,
          allErrors: this.opts.allErrors,
          data: names_1.default.data,
          parentData: names_1.default.parentData,
          parentDataProperty: names_1.default.parentDataProperty,
          dataNames: [names_1.default.data],
          dataPathArr: [codegen_1.nil],
          dataLevel: 0,
          dataTypes: [],
          definedProperties: new Set(),
          topSchemaRef: gen.scopeValue(
            'schema',
            this.opts.code.source === true
              ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
              : { ref: sch.schema }
          ),
          validateName,
          ValidationError: _ValidationError,
          schema: sch.schema,
          schemaEnv: sch,
          rootId,
          baseId: sch.baseId || rootId,
          schemaPath: codegen_1.nil,
          errSchemaPath: sch.schemaPath || (this.opts.jtd ? '' : '#'),
          errorPath: (0, codegen_1._)`""`,
          opts: this.opts,
          self: this
        }
        let sourceCode
        try {
          this._compilations.add(sch)
          ;(0, validate_1.validateFunctionCode)(schemaCxt)
          gen.optimize(this.opts.code.optimize)
          // gen.optimize(1)
          const validateCode = gen.toString()
          sourceCode = `${gen.scopeRefs(
            names_1.default.scope
          )}return ${validateCode}`
          // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
          if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch)
          // console.log("\n\n\n *** \n", sourceCode)
          const makeValidate = new Function(
            `${names_1.default.self}`,
            `${names_1.default.scope}`,
            sourceCode
          )
          const validate = makeValidate(this, this.scope.get())
          this.scope.value(validateName, { ref: validate })
          validate.errors = null
          validate.schema = sch.schema
          validate.schemaEnv = sch
          if (sch.$async) validate.$async = true
          if (this.opts.code.source === true) {
            validate.source = {
              validateName,
              validateCode,
              scopeValues: gen._values
            }
          }
          if (this.opts.unevaluated) {
            const { props, items } = schemaCxt
            validate.evaluated = {
              props: props instanceof codegen_1.Name ? undefined : props,
              items: items instanceof codegen_1.Name ? undefined : items,
              dynamicProps: props instanceof codegen_1.Name,
              dynamicItems: items instanceof codegen_1.Name
            }
            if (validate.source)
              validate.source.evaluated = (0, codegen_1.stringify)(
                validate.evaluated
              )
          }
          sch.validate = validate
          return sch
        } catch (e) {
          delete sch.validate
          delete sch.validateName
          if (sourceCode)
            this.logger.error(
              'Error compiling schema, function code:',
              sourceCode
            )
          // console.log("\n\n\n *** \n", sourceCode, this.opts)
          throw e
        } finally {
          this._compilations.delete(sch)
        }
      }
      exports.compileSchema = compileSchema
      function resolveRef(root, baseId, ref) {
        var _a
        ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref)
        const schOrFunc = root.refs[ref]
        if (schOrFunc) return schOrFunc
        let _sch = resolve.call(this, root, ref)
        if (_sch === undefined) {
          const schema =
            (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref] // TODO maybe localRefs should hold SchemaEnv
          const { schemaId } = this.opts
          if (schema) _sch = new SchemaEnv({ schema, schemaId, root, baseId })
        }
        if (_sch === undefined) return
        return (root.refs[ref] = inlineOrCompile.call(this, _sch))
      }
      exports.resolveRef = resolveRef
      function inlineOrCompile(sch) {
        if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
          return sch.schema
        return sch.validate ? sch : compileSchema.call(this, sch)
      }
      // Index of schema compilation in the currently compiled list
      function getCompilingSchema(schEnv) {
        for (const sch of this._compilations) {
          if (sameSchemaEnv(sch, schEnv)) return sch
        }
      }
      exports.getCompilingSchema = getCompilingSchema
      function sameSchemaEnv(s1, s2) {
        return (
          s1.schema === s2.schema &&
          s1.root === s2.root &&
          s1.baseId === s2.baseId
        )
      }
      // resolve and compile the references ($ref)
      // TODO returns AnySchemaObject (if the schema can be inlined) or validation function
      function resolve(
        root, // information about the root schema for the current schema
        ref // reference to resolve
      ) {
        let sch
        while (typeof (sch = this.refs[ref]) == 'string') ref = sch
        return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)
      }
      // Resolve schema, its root and baseId
      function resolveSchema(
        root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
        ref // reference to resolve
      ) {
        const p = this.opts.uriResolver.parse(ref)
        const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p)
        let baseId = (0, resolve_1.getFullPath)(
          this.opts.uriResolver,
          root.baseId,
          undefined
        )
        // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
          return getJsonPointer.call(this, p, root)
        }
        const id = (0, resolve_1.normalizeId)(refPath)
        const schOrRef = this.refs[id] || this.schemas[id]
        if (typeof schOrRef == 'string') {
          const sch = resolveSchema.call(this, root, schOrRef)
          if (
            typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !==
            'object'
          )
            return
          return getJsonPointer.call(this, p, sch)
        }
        if (
          typeof (schOrRef === null || schOrRef === void 0
            ? void 0
            : schOrRef.schema) !== 'object'
        )
          return
        if (!schOrRef.validate) compileSchema.call(this, schOrRef)
        if (id === (0, resolve_1.normalizeId)(ref)) {
          const { schema } = schOrRef
          const { schemaId } = this.opts
          const schId = schema[schemaId]
          if (schId)
            baseId = (0, resolve_1.resolveUrl)(
              this.opts.uriResolver,
              baseId,
              schId
            )
          return new SchemaEnv({ schema, schemaId, root, baseId })
        }
        return getJsonPointer.call(this, p, schOrRef)
      }
      exports.resolveSchema = resolveSchema
      const PREVENT_SCOPE_CHANGE = new Set([
        'properties',
        'patternProperties',
        'enum',
        'dependencies',
        'definitions'
      ])
      function getJsonPointer(parsedRef, { baseId, schema, root }) {
        var _a
        if (
          ((_a = parsedRef.fragment) === null || _a === void 0
            ? void 0
            : _a[0]) !== '/'
        )
          return
        for (const part of parsedRef.fragment.slice(1).split('/')) {
          if (typeof schema === 'boolean') return
          const partSchema = schema[(0, util_1.unescapeFragment)(part)]
          if (partSchema === undefined) return
          schema = partSchema
          // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
          const schId = typeof schema === 'object' && schema[this.opts.schemaId]
          if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(
              this.opts.uriResolver,
              baseId,
              schId
            )
          }
        }
        let env
        if (
          typeof schema != 'boolean' &&
          schema.$ref &&
          !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)
        ) {
          const $ref = (0, resolve_1.resolveUrl)(
            this.opts.uriResolver,
            baseId,
            schema.$ref
          )
          env = resolveSchema.call(this, root, $ref)
        }
        // even though resolution failed we need to return SchemaEnv to throw exception
        // so that compileAsync loads missing schema.
        const { schemaId } = this.opts
        env = env || new SchemaEnv({ schema, schemaId, root, baseId })
        if (env.schema !== env.root.schema) return env
        return undefined
      }
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 2141: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const names = {
        // validation function arguments
        data: new codegen_1.Name('data'),
        // args passed from referencing schema
        valCxt: new codegen_1.Name('valCxt'),
        instancePath: new codegen_1.Name('instancePath'),
        parentData: new codegen_1.Name('parentData'),
        parentDataProperty: new codegen_1.Name('parentDataProperty'),
        rootData: new codegen_1.Name('rootData'),
        dynamicAnchors: new codegen_1.Name('dynamicAnchors'),
        // function scoped variables
        vErrors: new codegen_1.Name('vErrors'),
        errors: new codegen_1.Name('errors'),
        this: new codegen_1.Name('this'),
        // "globals"
        self: new codegen_1.Name('self'),
        scope: new codegen_1.Name('scope'),
        // JTD serialize/parse name for JSON string and position
        json: new codegen_1.Name('json'),
        jsonPos: new codegen_1.Name('jsonPos'),
        jsonLen: new codegen_1.Name('jsonLen'),
        jsonPart: new codegen_1.Name('jsonPart')
      }
      exports['default'] = names
      //# sourceMappingURL=names.js.map

      /***/
    },

    /***/ 6646: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const resolve_1 = __webpack_require__(2531)
      class MissingRefError extends Error {
        constructor(resolver, baseId, ref, msg) {
          super(msg || `can't resolve reference ${ref} from id ${baseId}`)
          this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref)
          this.missingSchema = (0, resolve_1.normalizeId)(
            (0, resolve_1.getFullPath)(resolver, this.missingRef)
          )
        }
      }
      exports['default'] = MissingRefError
      //# sourceMappingURL=ref_error.js.map

      /***/
    },

    /***/ 2531: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.getSchemaRefs =
        exports.resolveUrl =
        exports.normalizeId =
        exports._getFullPath =
        exports.getFullPath =
        exports.inlineRef =
          void 0
      const util_1 = __webpack_require__(6776)
      const equal = __webpack_require__(4063)
      const traverse = __webpack_require__(9461)
      // TODO refactor to use keyword definitions
      const SIMPLE_INLINED = new Set([
        'type',
        'format',
        'pattern',
        'maxLength',
        'minLength',
        'maxProperties',
        'minProperties',
        'maxItems',
        'minItems',
        'maximum',
        'minimum',
        'uniqueItems',
        'multipleOf',
        'required',
        'enum',
        'const'
      ])
      function inlineRef(schema, limit = true) {
        if (typeof schema == 'boolean') return true
        if (limit === true) return !hasRef(schema)
        if (!limit) return false
        return countKeys(schema) <= limit
      }
      exports.inlineRef = inlineRef
      const REF_KEYWORDS = new Set([
        '$ref',
        '$recursiveRef',
        '$recursiveAnchor',
        '$dynamicRef',
        '$dynamicAnchor'
      ])
      function hasRef(schema) {
        for (const key in schema) {
          if (REF_KEYWORDS.has(key)) return true
          const sch = schema[key]
          if (Array.isArray(sch) && sch.some(hasRef)) return true
          if (typeof sch == 'object' && hasRef(sch)) return true
        }
        return false
      }
      function countKeys(schema) {
        let count = 0
        for (const key in schema) {
          if (key === '$ref') return Infinity
          count++
          if (SIMPLE_INLINED.has(key)) continue
          if (typeof schema[key] == 'object') {
            ;(0, util_1.eachItem)(
              schema[key],
              (sch) => (count += countKeys(sch))
            )
          }
          if (count === Infinity) return Infinity
        }
        return count
      }
      function getFullPath(resolver, id = '', normalize) {
        if (normalize !== false) id = normalizeId(id)
        const p = resolver.parse(id)
        return _getFullPath(resolver, p)
      }
      exports.getFullPath = getFullPath
      function _getFullPath(resolver, p) {
        const serialized = resolver.serialize(p)
        return serialized.split('#')[0] + '#'
      }
      exports._getFullPath = _getFullPath
      const TRAILING_SLASH_HASH = /#\/?$/
      function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, '') : ''
      }
      exports.normalizeId = normalizeId
      function resolveUrl(resolver, baseId, id) {
        id = normalizeId(id)
        return resolver.resolve(baseId, id)
      }
      exports.resolveUrl = resolveUrl
      const ANCHOR = /^[a-z_][-a-z0-9._]*$/i
      function getSchemaRefs(schema, baseId) {
        if (typeof schema == 'boolean') return {}
        const { schemaId, uriResolver } = this.opts
        const schId = normalizeId(schema[schemaId] || baseId)
        const baseIds = { '': schId }
        const pathPrefix = getFullPath(uriResolver, schId, false)
        const localRefs = {}
        const schemaRefs = new Set()
        traverse(
          schema,
          { allKeys: true },
          (sch, jsonPtr, _, parentJsonPtr) => {
            if (parentJsonPtr === undefined) return
            const fullPath = pathPrefix + jsonPtr
            let baseId = baseIds[parentJsonPtr]
            if (typeof sch[schemaId] == 'string')
              baseId = addRef.call(this, sch[schemaId])
            addAnchor.call(this, sch.$anchor)
            addAnchor.call(this, sch.$dynamicAnchor)
            baseIds[jsonPtr] = baseId
            function addRef(ref) {
              // eslint-disable-next-line @typescript-eslint/unbound-method
              const _resolve = this.opts.uriResolver.resolve
              ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)
              if (schemaRefs.has(ref)) throw ambiguos(ref)
              schemaRefs.add(ref)
              let schOrRef = this.refs[ref]
              if (typeof schOrRef == 'string') schOrRef = this.refs[schOrRef]
              if (typeof schOrRef == 'object') {
                checkAmbiguosRef(sch, schOrRef.schema, ref)
              } else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === '#') {
                  checkAmbiguosRef(sch, localRefs[ref], ref)
                  localRefs[ref] = sch
                } else {
                  this.refs[ref] = fullPath
                }
              }
              return ref
            }
            function addAnchor(anchor) {
              if (typeof anchor == 'string') {
                if (!ANCHOR.test(anchor))
                  throw new Error(`invalid anchor "${anchor}"`)
                addRef.call(this, `#${anchor}`)
              }
            }
          }
        )
        return localRefs
        function checkAmbiguosRef(sch1, sch2, ref) {
          if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)
        }
        function ambiguos(ref) {
          return new Error(
            `reference "${ref}" resolves to more than one schema`
          )
        }
      }
      exports.getSchemaRefs = getSchemaRefs
      //# sourceMappingURL=resolve.js.map

      /***/
    },

    /***/ 3141: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.getRules = exports.isJSONType = void 0
      const _jsonTypes = [
        'string',
        'number',
        'integer',
        'boolean',
        'null',
        'object',
        'array'
      ]
      const jsonTypes = new Set(_jsonTypes)
      function isJSONType(x) {
        return typeof x == 'string' && jsonTypes.has(x)
      }
      exports.isJSONType = isJSONType
      function getRules() {
        const groups = {
          number: { type: 'number', rules: [] },
          string: { type: 'string', rules: [] },
          array: { type: 'array', rules: [] },
          object: { type: 'object', rules: [] }
        }
        return {
          types: { ...groups, integer: true, boolean: true, null: true },
          rules: [
            { rules: [] },
            groups.number,
            groups.string,
            groups.array,
            groups.object
          ],
          post: { rules: [] },
          all: {},
          keywords: {}
        }
      }
      exports.getRules = getRules
      //# sourceMappingURL=rules.js.map

      /***/
    },

    /***/ 6776: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.checkStrictMode =
        exports.getErrorPath =
        exports.Type =
        exports.useFunc =
        exports.setEvaluated =
        exports.evaluatedPropsToName =
        exports.mergeEvaluated =
        exports.eachItem =
        exports.unescapeJsonPointer =
        exports.escapeJsonPointer =
        exports.escapeFragment =
        exports.unescapeFragment =
        exports.schemaRefOrVal =
        exports.schemaHasRulesButRef =
        exports.schemaHasRules =
        exports.checkUnknownRules =
        exports.alwaysValidSchema =
        exports.toHash =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const code_1 = __webpack_require__(7023)
      // TODO refactor to use Set
      function toHash(arr) {
        const hash = {}
        for (const item of arr) hash[item] = true
        return hash
      }
      exports.toHash = toHash
      function alwaysValidSchema(it, schema) {
        if (typeof schema == 'boolean') return schema
        if (Object.keys(schema).length === 0) return true
        checkUnknownRules(it, schema)
        return !schemaHasRules(schema, it.self.RULES.all)
      }
      exports.alwaysValidSchema = alwaysValidSchema
      function checkUnknownRules(it, schema = it.schema) {
        const { opts, self } = it
        if (!opts.strictSchema) return
        if (typeof schema === 'boolean') return
        const rules = self.RULES.keywords
        for (const key in schema) {
          if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`)
        }
      }
      exports.checkUnknownRules = checkUnknownRules
      function schemaHasRules(schema, rules) {
        if (typeof schema == 'boolean') return !schema
        for (const key in schema) if (rules[key]) return true
        return false
      }
      exports.schemaHasRules = schemaHasRules
      function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == 'boolean') return !schema
        for (const key in schema)
          if (key !== '$ref' && RULES.all[key]) return true
        return false
      }
      exports.schemaHasRulesButRef = schemaHasRulesButRef
      function schemaRefOrVal(
        { topSchemaRef, schemaPath },
        schema,
        keyword,
        $data
      ) {
        if (!$data) {
          if (typeof schema == 'number' || typeof schema == 'boolean')
            return schema
          if (typeof schema == 'string') return (0, codegen_1._)`${schema}`
        }
        return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0,
        codegen_1.getProperty)(keyword)}`
      }
      exports.schemaRefOrVal = schemaRefOrVal
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str))
      }
      exports.unescapeFragment = unescapeFragment
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str))
      }
      exports.escapeFragment = escapeFragment
      function escapeJsonPointer(str) {
        if (typeof str == 'number') return `${str}`
        return str.replace(/~/g, '~0').replace(/\//g, '~1')
      }
      exports.escapeJsonPointer = escapeJsonPointer
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, '/').replace(/~0/g, '~')
      }
      exports.unescapeJsonPointer = unescapeJsonPointer
      function eachItem(xs, f) {
        if (Array.isArray(xs)) {
          for (const x of xs) f(x)
        } else {
          f(xs)
        }
      }
      exports.eachItem = eachItem
      function makeMergeEvaluated({
        mergeNames,
        mergeToName,
        mergeValues,
        resultToName
      }) {
        return (gen, from, to, toName) => {
          const res =
            to === undefined
              ? from
              : to instanceof codegen_1.Name
              ? (from instanceof codegen_1.Name
                  ? mergeNames(gen, from, to)
                  : mergeToName(gen, from, to),
                to)
              : from instanceof codegen_1.Name
              ? (mergeToName(gen, to, from), from)
              : mergeValues(from, to)
          return toName === codegen_1.Name && !(res instanceof codegen_1.Name)
            ? resultToName(gen, res)
            : res
        }
      }
      exports.mergeEvaluated = {
        props: makeMergeEvaluated({
          mergeNames: (gen, from, to) =>
            gen.if(
              (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
              () => {
                gen.if(
                  (0, codegen_1._)`${from} === true`,
                  () => gen.assign(to, true),
                  () =>
                    gen
                      .assign(to, (0, codegen_1._)`${to} || {}`)
                      .code((0, codegen_1._)`Object.assign(${to}, ${from})`)
                )
              }
            ),
          mergeToName: (gen, from, to) =>
            gen.if((0, codegen_1._)`${to} !== true`, () => {
              if (from === true) {
                gen.assign(to, true)
              } else {
                gen.assign(to, (0, codegen_1._)`${to} || {}`)
                setEvaluated(gen, to, from)
              }
            }),
          mergeValues: (from, to) =>
            from === true ? true : { ...from, ...to },
          resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
          mergeNames: (gen, from, to) =>
            gen.if(
              (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
              () =>
                gen.assign(
                  to,
                  (0,
                  codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`
                )
            ),
          mergeToName: (gen, from, to) =>
            gen.if((0, codegen_1._)`${to} !== true`, () =>
              gen.assign(
                to,
                from === true
                  ? true
                  : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`
              )
            ),
          mergeValues: (from, to) =>
            from === true ? true : Math.max(from, to),
          resultToName: (gen, items) => gen.var('items', items)
        })
      }
      function evaluatedPropsToName(gen, ps) {
        if (ps === true) return gen.var('props', true)
        const props = gen.var('props', (0, codegen_1._)`{}`)
        if (ps !== undefined) setEvaluated(gen, props, ps)
        return props
      }
      exports.evaluatedPropsToName = evaluatedPropsToName
      function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p) =>
          gen.assign(
            (0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`,
            true
          )
        )
      }
      exports.setEvaluated = setEvaluated
      const snippets = {}
      function useFunc(gen, f) {
        return gen.scopeValue('func', {
          ref: f,
          code:
            snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
        })
      }
      exports.useFunc = useFunc
      var Type
      ;(function (Type) {
        Type[(Type['Num'] = 0)] = 'Num'
        Type[(Type['Str'] = 1)] = 'Str'
      })((Type = exports.Type || (exports.Type = {})))
      function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        // let path
        if (dataProp instanceof codegen_1.Name) {
          const isNumber = dataPropType === Type.Num
          return jsPropertySyntax
            ? isNumber
              ? (0, codegen_1._)`"[" + ${dataProp} + "]"`
              : (0, codegen_1._)`"['" + ${dataProp} + "']"`
            : isNumber
            ? (0, codegen_1._)`"/" + ${dataProp}`
            : (0,
              codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")` // TODO maybe use global escapePointer
        }
        return jsPropertySyntax
          ? (0, codegen_1.getProperty)(dataProp).toString()
          : '/' + escapeJsonPointer(dataProp)
      }
      exports.getErrorPath = getErrorPath
      function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode) return
        msg = `strict mode: ${msg}`
        if (mode === true) throw new Error(msg)
        it.self.logger.warn(msg)
      }
      exports.checkStrictMode = checkStrictMode
      //# sourceMappingURL=util.js.map

      /***/
    },

    /***/ 8876: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.shouldUseRule =
        exports.shouldUseGroup =
        exports.schemaHasRulesForType =
          void 0
      function schemaHasRulesForType({ schema, self }, type) {
        const group = self.RULES.types[type]
        return group && group !== true && shouldUseGroup(schema, group)
      }
      exports.schemaHasRulesForType = schemaHasRulesForType
      function shouldUseGroup(schema, group) {
        return group.rules.some((rule) => shouldUseRule(schema, rule))
      }
      exports.shouldUseGroup = shouldUseGroup
      function shouldUseRule(schema, rule) {
        var _a
        return (
          schema[rule.keyword] !== undefined ||
          ((_a = rule.definition.implements) === null || _a === void 0
            ? void 0
            : _a.some((kwd) => schema[kwd] !== undefined))
        )
      }
      exports.shouldUseRule = shouldUseRule
      //# sourceMappingURL=applicability.js.map

      /***/
    },

    /***/ 5667: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0
      const errors_1 = __webpack_require__(4181)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const boolError = {
        message: 'boolean schema is false'
      }
      function topBoolOrEmptySchema(it) {
        const { gen, schema, validateName } = it
        if (schema === false) {
          falseSchemaError(it, false)
        } else if (typeof schema == 'object' && schema.$async === true) {
          gen.return(names_1.default.data)
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, null)
          gen.return(true)
        }
      }
      exports.topBoolOrEmptySchema = topBoolOrEmptySchema
      function boolOrEmptySchema(it, valid) {
        const { gen, schema } = it
        if (schema === false) {
          gen.var(valid, false) // TODO var
          falseSchemaError(it)
        } else {
          gen.var(valid, true) // TODO var
        }
      }
      exports.boolOrEmptySchema = boolOrEmptySchema
      function falseSchemaError(it, overrideAllErrors) {
        const { gen, data } = it
        // TODO maybe some other interface should be used for non-keyword validation errors...
        const cxt = {
          gen,
          keyword: 'false schema',
          data,
          schema: false,
          schemaCode: false,
          schemaValue: false,
          params: {},
          it
        }
        ;(0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors)
      }
      //# sourceMappingURL=boolSchema.js.map

      /***/
    },

    /***/ 453: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.reportTypeError =
        exports.checkDataTypes =
        exports.checkDataType =
        exports.coerceAndCheckDataType =
        exports.getJSONTypes =
        exports.getSchemaTypes =
        exports.DataType =
          void 0
      const rules_1 = __webpack_require__(3141)
      const applicability_1 = __webpack_require__(8876)
      const errors_1 = __webpack_require__(4181)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      var DataType
      ;(function (DataType) {
        DataType[(DataType['Correct'] = 0)] = 'Correct'
        DataType[(DataType['Wrong'] = 1)] = 'Wrong'
      })((DataType = exports.DataType || (exports.DataType = {})))
      function getSchemaTypes(schema) {
        const types = getJSONTypes(schema.type)
        const hasNull = types.includes('null')
        if (hasNull) {
          if (schema.nullable === false)
            throw new Error('type: null contradicts nullable: false')
        } else {
          if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"')
          }
          if (schema.nullable === true) types.push('null')
        }
        return types
      }
      exports.getSchemaTypes = getSchemaTypes
      function getJSONTypes(ts) {
        const types = Array.isArray(ts) ? ts : ts ? [ts] : []
        if (types.every(rules_1.isJSONType)) return types
        throw new Error(
          'type must be JSONType or JSONType[]: ' + types.join(',')
        )
      }
      exports.getJSONTypes = getJSONTypes
      function coerceAndCheckDataType(it, types) {
        const { gen, data, opts } = it
        const coerceTo = coerceToTypes(types, opts.coerceTypes)
        const checkTypes =
          types.length > 0 &&
          !(
            coerceTo.length === 0 &&
            types.length === 1 &&
            (0, applicability_1.schemaHasRulesForType)(it, types[0])
          )
        if (checkTypes) {
          const wrongType = checkDataTypes(
            types,
            data,
            opts.strictNumbers,
            DataType.Wrong
          )
          gen.if(wrongType, () => {
            if (coerceTo.length) coerceData(it, types, coerceTo)
            else reportTypeError(it)
          })
        }
        return checkTypes
      }
      exports.coerceAndCheckDataType = coerceAndCheckDataType
      const COERCIBLE = new Set([
        'string',
        'number',
        'integer',
        'boolean',
        'null'
      ])
      function coerceToTypes(types, coerceTypes) {
        return coerceTypes
          ? types.filter(
              (t) =>
                COERCIBLE.has(t) || (coerceTypes === 'array' && t === 'array')
            )
          : []
      }
      function coerceData(it, types, coerceTo) {
        const { gen, data, opts } = it
        const dataType = gen.let('dataType', (0, codegen_1._)`typeof ${data}`)
        const coerced = gen.let('coerced', (0, codegen_1._)`undefined`)
        if (opts.coerceTypes === 'array') {
          gen.if(
            (0,
            codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`,
            () =>
              gen
                .assign(data, (0, codegen_1._)`${data}[0]`)
                .assign(dataType, (0, codegen_1._)`typeof ${data}`)
                .if(checkDataTypes(types, data, opts.strictNumbers), () =>
                  gen.assign(coerced, data)
                )
          )
        }
        gen.if((0, codegen_1._)`${coerced} !== undefined`)
        for (const t of coerceTo) {
          if (
            COERCIBLE.has(t) ||
            (t === 'array' && opts.coerceTypes === 'array')
          ) {
            coerceSpecificType(t)
          }
        }
        gen.else()
        reportTypeError(it)
        gen.endIf()
        gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
          gen.assign(data, coerced)
          assignParentData(it, coerced)
        })
        function coerceSpecificType(t) {
          switch (t) {
            case 'string':
              gen
                .elseIf(
                  (0,
                  codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`
                )
                .assign(coerced, (0, codegen_1._)`"" + ${data}`)
                .elseIf((0, codegen_1._)`${data} === null`)
                .assign(coerced, (0, codegen_1._)`""`)
              return
            case 'number':
              gen
                .elseIf(
                  (0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`
                )
                .assign(coerced, (0, codegen_1._)`+${data}`)
              return
            case 'integer':
              gen
                .elseIf(
                  (0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`
                )
                .assign(coerced, (0, codegen_1._)`+${data}`)
              return
            case 'boolean':
              gen
                .elseIf(
                  (0,
                  codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`
                )
                .assign(coerced, false)
                .elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`)
                .assign(coerced, true)
              return
            case 'null':
              gen.elseIf(
                (0,
                codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`
              )
              gen.assign(coerced, null)
              return
            case 'array':
              gen
                .elseIf(
                  (0,
                  codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`
                )
                .assign(coerced, (0, codegen_1._)`[${data}]`)
          }
        }
      }
      function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        // TODO use gen.property
        gen.if((0, codegen_1._)`${parentData} !== undefined`, () =>
          gen.assign(
            (0, codegen_1._)`${parentData}[${parentDataProperty}]`,
            expr
          )
        )
      }
      function checkDataType(
        dataType,
        data,
        strictNums,
        correct = DataType.Correct
      ) {
        const EQ =
          correct === DataType.Correct
            ? codegen_1.operators.EQ
            : codegen_1.operators.NEQ
        let cond
        switch (dataType) {
          case 'null':
            return (0, codegen_1._)`${data} ${EQ} null`
          case 'array':
            cond = (0, codegen_1._)`Array.isArray(${data})`
            break
          case 'object':
            cond = (0,
            codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`
            break
          case 'integer':
            cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`)
            break
          case 'number':
            cond = numCond()
            break
          default:
            return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`
        }
        return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond)
        function numCond(_cond = codegen_1.nil) {
          return (0, codegen_1.and)(
            (0, codegen_1._)`typeof ${data} == "number"`,
            _cond,
            strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil
          )
        }
      }
      exports.checkDataType = checkDataType
      function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
          return checkDataType(dataTypes[0], data, strictNums, correct)
        }
        let cond
        const types = (0, util_1.toHash)(dataTypes)
        if (types.array && types.object) {
          const notObj = (0, codegen_1._)`typeof ${data} != "object"`
          cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`
          delete types.null
          delete types.array
          delete types.object
        } else {
          cond = codegen_1.nil
        }
        if (types.number) delete types.integer
        for (const t in types)
          cond = (0, codegen_1.and)(
            cond,
            checkDataType(t, data, strictNums, correct)
          )
        return cond
      }
      exports.checkDataTypes = checkDataTypes
      const typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) =>
          typeof schema == 'string'
            ? (0, codegen_1._)`{type: ${schema}}`
            : (0, codegen_1._)`{type: ${schemaValue}}`
      }
      function reportTypeError(it) {
        const cxt = getTypeErrorContext(it)
        ;(0, errors_1.reportError)(cxt, typeError)
      }
      exports.reportTypeError = reportTypeError
      function getTypeErrorContext(it) {
        const { gen, data, schema } = it
        const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, 'type')
        return {
          gen,
          keyword: 'type',
          data,
          schema: schema.type,
          schemaCode,
          schemaValue: schemaCode,
          parentSchema: schema,
          params: {},
          it
        }
      }
      //# sourceMappingURL=dataType.js.map

      /***/
    },

    /***/ 313: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.assignDefaults = void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      function assignDefaults(it, ty) {
        const { properties, items } = it.schema
        if (ty === 'object' && properties) {
          for (const key in properties) {
            assignDefault(it, key, properties[key].default)
          }
        } else if (ty === 'array' && Array.isArray(items)) {
          items.forEach((sch, i) => assignDefault(it, i, sch.default))
        }
      }
      exports.assignDefaults = assignDefaults
      function assignDefault(it, prop, defaultValue) {
        const { gen, compositeRule, data, opts } = it
        if (defaultValue === undefined) return
        const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
          prop
        )}`
        if (compositeRule) {
          ;(0, util_1.checkStrictMode)(
            it,
            `default is ignored for: ${childData}`
          )
          return
        }
        let condition = (0, codegen_1._)`${childData} === undefined`
        if (opts.useDefaults === 'empty') {
          condition = (0,
          codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`
        }
        // `${childData} === undefined` +
        // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
        gen.if(
          condition,
          (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(
            defaultValue
          )}`
        )
      }
      //# sourceMappingURL=defaults.js.map

      /***/
    },

    /***/ 4815: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.getData =
        exports.KeywordCxt =
        exports.validateFunctionCode =
          void 0
      const boolSchema_1 = __webpack_require__(5667)
      const dataType_1 = __webpack_require__(453)
      const applicability_1 = __webpack_require__(8876)
      const dataType_2 = __webpack_require__(453)
      const defaults_1 = __webpack_require__(313)
      const keyword_1 = __webpack_require__(5005)
      const subschema_1 = __webpack_require__(3099)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const resolve_1 = __webpack_require__(2531)
      const util_1 = __webpack_require__(6776)
      const errors_1 = __webpack_require__(4181)
      // schema compilation - generates validation function, subschemaCode (below) is used for subschemas
      function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
          checkKeywords(it)
          if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it)
            return
          }
        }
        validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it))
      }
      exports.validateFunctionCode = validateFunctionCode
      function validateFunction(
        { gen, validateName, schema, schemaEnv, opts },
        body
      ) {
        if (opts.code.es5) {
          gen.func(
            validateName,
            (0,
            codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`,
            schemaEnv.$async,
            () => {
              gen.code(
                (0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`
              )
              destructureValCxtES5(gen, opts)
              gen.code(body)
            }
          )
        } else {
          gen.func(
            validateName,
            (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(
              opts
            )}`,
            schemaEnv.$async,
            () => gen.code(funcSourceUrl(schema, opts)).code(body)
          )
        }
      }
      function destructureValCxt(opts) {
        return (0, codegen_1._)`{${names_1.default.instancePath}="", ${
          names_1.default.parentData
        }, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${
          names_1.default.data
        }${
          opts.dynamicRef
            ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}`
            : codegen_1.nil
        }}={}`
      }
      function destructureValCxtES5(gen, opts) {
        gen.if(
          names_1.default.valCxt,
          () => {
            gen.var(
              names_1.default.instancePath,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`
            )
            gen.var(
              names_1.default.parentData,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`
            )
            gen.var(
              names_1.default.parentDataProperty,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`
            )
            gen.var(
              names_1.default.rootData,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`
            )
            if (opts.dynamicRef)
              gen.var(
                names_1.default.dynamicAnchors,
                (0,
                codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`
              )
          },
          () => {
            gen.var(names_1.default.instancePath, (0, codegen_1._)`""`)
            gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`)
            gen.var(
              names_1.default.parentDataProperty,
              (0, codegen_1._)`undefined`
            )
            gen.var(names_1.default.rootData, names_1.default.data)
            if (opts.dynamicRef)
              gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`)
          }
        )
      }
      function topSchemaObjCode(it) {
        const { schema, opts, gen } = it
        validateFunction(it, () => {
          if (opts.$comment && schema.$comment) commentKeyword(it)
          checkNoDefault(it)
          gen.let(names_1.default.vErrors, null)
          gen.let(names_1.default.errors, 0)
          if (opts.unevaluated) resetEvaluated(it)
          typeAndKeywords(it)
          returnResults(it)
        })
        return
      }
      function resetEvaluated(it) {
        // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
        const { gen, validateName } = it
        it.evaluated = gen.const(
          'evaluated',
          (0, codegen_1._)`${validateName}.evaluated`
        )
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () =>
          gen.assign(
            (0, codegen_1._)`${it.evaluated}.props`,
            (0, codegen_1._)`undefined`
          )
        )
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () =>
          gen.assign(
            (0, codegen_1._)`${it.evaluated}.items`,
            (0, codegen_1._)`undefined`
          )
        )
      }
      function funcSourceUrl(schema, opts) {
        const schId = typeof schema == 'object' && schema[opts.schemaId]
        return schId && (opts.code.source || opts.code.process)
          ? (0, codegen_1._)`/*# sourceURL=${schId} */`
          : codegen_1.nil
      }
      // schema compilation - this function is used recursively to generate code for sub-schemas
      function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
          checkKeywords(it)
          if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid)
            return
          }
        }
        ;(0, boolSchema_1.boolOrEmptySchema)(it, valid)
      }
      function schemaCxtHasRules({ schema, self }) {
        if (typeof schema == 'boolean') return !schema
        for (const key in schema) if (self.RULES.all[key]) return true
        return false
      }
      function isSchemaObj(it) {
        return typeof it.schema != 'boolean'
      }
      function subSchemaObjCode(it, valid) {
        const { schema, gen, opts } = it
        if (opts.$comment && schema.$comment) commentKeyword(it)
        updateContext(it)
        checkAsyncSchema(it)
        const errsCount = gen.const('_errs', names_1.default.errors)
        typeAndKeywords(it, errsCount)
        // TODO var
        gen.var(
          valid,
          (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`
        )
      }
      function checkKeywords(it) {
        ;(0, util_1.checkUnknownRules)(it)
        checkRefsAndKeywords(it)
      }
      function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)
        const types = (0, dataType_1.getSchemaTypes)(it.schema)
        const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types)
        schemaKeywords(it, types, !checkedTypes, errsCount)
      }
      function checkRefsAndKeywords(it) {
        const { schema, errSchemaPath, opts, self } = it
        if (
          schema.$ref &&
          opts.ignoreKeywordsWithRef &&
          (0, util_1.schemaHasRulesButRef)(schema, self.RULES)
        ) {
          self.logger.warn(
            `$ref: keywords ignored in schema at path "${errSchemaPath}"`
          )
        }
      }
      function checkNoDefault(it) {
        const { schema, opts } = it
        if (
          schema.default !== undefined &&
          opts.useDefaults &&
          opts.strictSchema
        ) {
          ;(0, util_1.checkStrictMode)(
            it,
            'default is ignored in the schema root'
          )
        }
      }
      function updateContext(it) {
        const schId = it.schema[it.opts.schemaId]
        if (schId)
          it.baseId = (0, resolve_1.resolveUrl)(
            it.opts.uriResolver,
            it.baseId,
            schId
          )
      }
      function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
          throw new Error('async schema in sync schema')
      }
      function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
        const msg = schema.$comment
        if (opts.$comment === true) {
          gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`)
        } else if (typeof opts.$comment == 'function') {
          const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`
          const rootName = gen.scopeValue('root', { ref: schemaEnv.root })
          gen.code(
            (0,
            codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`
          )
        }
      }
      function returnResults(it) {
        const { gen, schemaEnv, validateName, ValidationError, opts } = it
        if (schemaEnv.$async) {
          // TODO assign unevaluated
          gen.if(
            (0, codegen_1._)`${names_1.default.errors} === 0`,
            () => gen.return(names_1.default.data),
            () =>
              gen.throw(
                (0,
                codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`
              )
          )
        } else {
          gen.assign(
            (0, codegen_1._)`${validateName}.errors`,
            names_1.default.vErrors
          )
          if (opts.unevaluated) assignEvaluated(it)
          gen.return((0, codegen_1._)`${names_1.default.errors} === 0`)
        }
      }
      function assignEvaluated({ gen, evaluated, props, items }) {
        if (props instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.props`, props)
        if (items instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.items`, items)
      }
      function schemaKeywords(it, types, typeErrors, errsCount) {
        const { gen, schema, data, allErrors, opts, self } = it
        const { RULES } = self
        if (
          schema.$ref &&
          (opts.ignoreKeywordsWithRef ||
            !(0, util_1.schemaHasRulesButRef)(schema, RULES))
        ) {
          gen.block(() => keywordCode(it, '$ref', RULES.all.$ref.definition)) // TODO typecast
          return
        }
        if (!opts.jtd) checkStrictTypes(it, types)
        gen.block(() => {
          for (const group of RULES.rules) groupKeywords(group)
          groupKeywords(RULES.post)
        })
        function groupKeywords(group) {
          if (!(0, applicability_1.shouldUseGroup)(schema, group)) return
          if (group.type) {
            gen.if(
              (0, dataType_2.checkDataType)(
                group.type,
                data,
                opts.strictNumbers
              )
            )
            iterateKeywords(it, group)
            if (types.length === 1 && types[0] === group.type && typeErrors) {
              gen.else()
              ;(0, dataType_2.reportTypeError)(it)
            }
            gen.endIf()
          } else {
            iterateKeywords(it, group)
          }
          // TODO make it "ok" call?
          if (!allErrors)
            gen.if(
              (0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`
            )
        }
      }
      function iterateKeywords(it, group) {
        const {
          gen,
          schema,
          opts: { useDefaults }
        } = it
        if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type)
        gen.block(() => {
          for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
              keywordCode(it, rule.keyword, rule.definition, group.type)
            }
          }
        })
      }
      function checkStrictTypes(it, types) {
        if (it.schemaEnv.meta || !it.opts.strictTypes) return
        checkContextTypes(it, types)
        if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)
        checkKeywordTypes(it, it.dataTypes)
      }
      function checkContextTypes(it, types) {
        if (!types.length) return
        if (!it.dataTypes.length) {
          it.dataTypes = types
          return
        }
        types.forEach((t) => {
          if (!includesType(it.dataTypes, t)) {
            strictTypesError(
              it,
              `type "${t}" not allowed by context "${it.dataTypes.join(',')}"`
            )
          }
        })
        it.dataTypes = it.dataTypes.filter((t) => includesType(types, t))
      }
      function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes('null'))) {
          strictTypesError(
            it,
            'use allowUnionTypes to allow union type keyword'
          )
        }
      }
      function checkKeywordTypes(it, ts) {
        const rules = it.self.RULES.all
        for (const keyword in rules) {
          const rule = rules[keyword]
          if (
            typeof rule == 'object' &&
            (0, applicability_1.shouldUseRule)(it.schema, rule)
          ) {
            const { type } = rule.definition
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
              strictTypesError(
                it,
                `missing type "${type.join(',')}" for keyword "${keyword}"`
              )
            }
          }
        }
      }
      function hasApplicableType(schTs, kwdT) {
        return (
          schTs.includes(kwdT) ||
          (kwdT === 'number' && schTs.includes('integer'))
        )
      }
      function includesType(ts, t) {
        return ts.includes(t) || (t === 'integer' && ts.includes('number'))
      }
      function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath
        msg += ` at "${schemaPath}" (strictTypes)`
        ;(0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes)
      }
      class KeywordCxt {
        constructor(it, def, keyword) {
          ;(0, keyword_1.validateKeywordUsage)(it, def, keyword)
          this.gen = it.gen
          this.allErrors = it.allErrors
          this.keyword = keyword
          this.data = it.data
          this.schema = it.schema[keyword]
          this.$data =
            def.$data && it.opts.$data && this.schema && this.schema.$data
          this.schemaValue = (0, util_1.schemaRefOrVal)(
            it,
            this.schema,
            keyword,
            this.$data
          )
          this.schemaType = def.schemaType
          this.parentSchema = it.schema
          this.params = {}
          this.it = it
          this.def = def
          if (this.$data) {
            this.schemaCode = it.gen.const('vSchema', getData(this.$data, it))
          } else {
            this.schemaCode = this.schemaValue
            if (
              !(0, keyword_1.validSchemaType)(
                this.schema,
                def.schemaType,
                def.allowUndefined
              )
            ) {
              throw new Error(
                `${keyword} value must be ${JSON.stringify(def.schemaType)}`
              )
            }
          }
          if ('code' in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const('_errs', names_1.default.errors)
          }
        }
        result(condition, successAction, failAction) {
          this.failResult(
            (0, codegen_1.not)(condition),
            successAction,
            failAction
          )
        }
        failResult(condition, successAction, failAction) {
          this.gen.if(condition)
          if (failAction) failAction()
          else this.error()
          if (successAction) {
            this.gen.else()
            successAction()
            if (this.allErrors) this.gen.endIf()
          } else {
            if (this.allErrors) this.gen.endIf()
            else this.gen.else()
          }
        }
        pass(condition, failAction) {
          this.failResult((0, codegen_1.not)(condition), undefined, failAction)
        }
        fail(condition) {
          if (condition === undefined) {
            this.error()
            if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize
            return
          }
          this.gen.if(condition)
          this.error()
          if (this.allErrors) this.gen.endIf()
          else this.gen.else()
        }
        fail$data(condition) {
          if (!this.$data) return this.fail(condition)
          const { schemaCode } = this
          this.fail(
            (0, codegen_1._)`${schemaCode} !== undefined && (${(0,
            codegen_1.or)(this.invalid$data(), condition)})`
          )
        }
        error(append, errorParams, errorPaths) {
          if (errorParams) {
            this.setParams(errorParams)
            this._error(append, errorPaths)
            this.setParams({})
            return
          }
          this._error(append, errorPaths)
        }
        _error(append, errorPaths) {
          ;(append ? errors_1.reportExtraError : errors_1.reportError)(
            this,
            this.def.error,
            errorPaths
          )
        }
        $dataError() {
          ;(0, errors_1.reportError)(
            this,
            this.def.$dataError || errors_1.keyword$DataError
          )
        }
        reset() {
          if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition')
          ;(0, errors_1.resetErrorsCount)(this.gen, this.errsCount)
        }
        ok(cond) {
          if (!this.allErrors) this.gen.if(cond)
        }
        setParams(obj, assign) {
          if (assign) Object.assign(this.params, obj)
          else this.params = obj
        }
        block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
          this.gen.block(() => {
            this.check$data(valid, $dataValid)
            codeBlock()
          })
        }
        check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
          if (!this.$data) return
          const { gen, schemaCode, schemaType, def } = this
          gen.if(
            (0, codegen_1.or)(
              (0, codegen_1._)`${schemaCode} === undefined`,
              $dataValid
            )
          )
          if (valid !== codegen_1.nil) gen.assign(valid, true)
          if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data())
            this.$dataError()
            if (valid !== codegen_1.nil) gen.assign(valid, false)
          }
          gen.else()
        }
        invalid$data() {
          const { gen, schemaCode, schemaType, def, it } = this
          return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema())
          function wrong$DataType() {
            if (schemaType.length) {
              /* istanbul ignore if */
              if (!(schemaCode instanceof codegen_1.Name))
                throw new Error('ajv implementation error')
              const st = Array.isArray(schemaType) ? schemaType : [schemaType]
              return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(
                st,
                schemaCode,
                it.opts.strictNumbers,
                dataType_2.DataType.Wrong
              )}`
            }
            return codegen_1.nil
          }
          function invalid$DataSchema() {
            if (def.validateSchema) {
              const validateSchemaRef = gen.scopeValue('validate$data', {
                ref: def.validateSchema
              }) // TODO value.code for standalone
              return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`
            }
            return codegen_1.nil
          }
        }
        subschema(appl, valid) {
          const subschema = (0, subschema_1.getSubschema)(this.it, appl)
          ;(0, subschema_1.extendSubschemaData)(subschema, this.it, appl)
          ;(0, subschema_1.extendSubschemaMode)(subschema, appl)
          const nextContext = {
            ...this.it,
            ...subschema,
            items: undefined,
            props: undefined
          }
          subschemaCode(nextContext, valid)
          return nextContext
        }
        mergeEvaluated(schemaCxt, toName) {
          const { it, gen } = this
          if (!it.opts.unevaluated) return
          if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(
              gen,
              schemaCxt.props,
              it.props,
              toName
            )
          }
          if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(
              gen,
              schemaCxt.items,
              it.items,
              toName
            )
          }
        }
        mergeValidEvaluated(schemaCxt, valid) {
          const { it, gen } = this
          if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name))
            return true
          }
        }
      }
      exports.KeywordCxt = KeywordCxt
      function keywordCode(it, keyword, def, ruleType) {
        const cxt = new KeywordCxt(it, def, keyword)
        if ('code' in def) {
          def.code(cxt, ruleType)
        } else if (cxt.$data && def.validate) {
          ;(0, keyword_1.funcKeywordCode)(cxt, def)
        } else if ('macro' in def) {
          ;(0, keyword_1.macroKeywordCode)(cxt, def)
        } else if (def.compile || def.validate) {
          ;(0, keyword_1.funcKeywordCode)(cxt, def)
        }
      }
      const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/
      const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/
      function getData($data, { dataLevel, dataNames, dataPathArr }) {
        let jsonPointer
        let data
        if ($data === '') return names_1.default.rootData
        if ($data[0] === '/') {
          if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`)
          jsonPointer = $data
          data = names_1.default.rootData
        } else {
          const matches = RELATIVE_JSON_POINTER.exec($data)
          if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)
          const up = +matches[1]
          jsonPointer = matches[2]
          if (jsonPointer === '#') {
            if (up >= dataLevel) throw new Error(errorMsg('property/index', up))
            return dataPathArr[dataLevel - up]
          }
          if (up > dataLevel) throw new Error(errorMsg('data', up))
          data = dataNames[dataLevel - up]
          if (!jsonPointer) return data
        }
        let expr = data
        const segments = jsonPointer.split('/')
        for (const segment of segments) {
          if (segment) {
            data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
              (0, util_1.unescapeJsonPointer)(segment)
            )}`
            expr = (0, codegen_1._)`${expr} && ${data}`
          }
        }
        return expr
        function errorMsg(pointerType, up) {
          return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`
        }
      }
      exports.getData = getData
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 5005: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateKeywordUsage =
        exports.validSchemaType =
        exports.funcKeywordCode =
        exports.macroKeywordCode =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const code_1 = __webpack_require__(412)
      const errors_1 = __webpack_require__(4181)
      function macroKeywordCode(cxt, def) {
        const { gen, keyword, schema, parentSchema, it } = cxt
        const macroSchema = def.macro.call(it.self, schema, parentSchema, it)
        const schemaRef = useKeyword(gen, keyword, macroSchema)
        if (it.opts.validateSchema !== false)
          it.self.validateSchema(macroSchema, true)
        const valid = gen.name('valid')
        cxt.subschema(
          {
            schema: macroSchema,
            schemaPath: codegen_1.nil,
            errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            topSchemaRef: schemaRef,
            compositeRule: true
          },
          valid
        )
        cxt.pass(valid, () => cxt.error(true))
      }
      exports.macroKeywordCode = macroKeywordCode
      function funcKeywordCode(cxt, def) {
        var _a
        const { gen, keyword, schema, parentSchema, $data, it } = cxt
        checkAsyncKeyword(it, def)
        const validate =
          !$data && def.compile
            ? def.compile.call(it.self, schema, parentSchema, it)
            : def.validate
        const validateRef = useKeyword(gen, keyword, validate)
        const valid = gen.let('valid')
        cxt.block$data(valid, validateKeyword)
        cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid)
        function validateKeyword() {
          if (def.errors === false) {
            assignValid()
            if (def.modifying) modifyData(cxt)
            reportErrs(() => cxt.error())
          } else {
            const ruleErrs = def.async ? validateAsync() : validateSync()
            if (def.modifying) modifyData(cxt)
            reportErrs(() => addErrs(cxt, ruleErrs))
          }
        }
        function validateAsync() {
          const ruleErrs = gen.let('ruleErrs', null)
          gen.try(
            () => assignValid((0, codegen_1._)`await `),
            (e) =>
              gen.assign(valid, false).if(
                (0, codegen_1._)`${e} instanceof ${it.ValidationError}`,
                () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`),
                () => gen.throw(e)
              )
          )
          return ruleErrs
        }
        function validateSync() {
          const validateErrs = (0, codegen_1._)`${validateRef}.errors`
          gen.assign(validateErrs, null)
          assignValid(codegen_1.nil)
          return validateErrs
        }
        function assignValid(
          _await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil
        ) {
          const passCxt = it.opts.passContext
            ? names_1.default.this
            : names_1.default.self
          const passSchema = !(
            ('compile' in def && !$data) ||
            def.schema === false
          )
          gen.assign(
            valid,
            (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(
              cxt,
              validateRef,
              passCxt,
              passSchema
            )}`,
            def.modifying
          )
        }
        function reportErrs(errors) {
          var _a
          gen.if(
            (0, codegen_1.not)(
              (_a = def.valid) !== null && _a !== void 0 ? _a : valid
            ),
            errors
          )
        }
      }
      exports.funcKeywordCode = funcKeywordCode
      function modifyData(cxt) {
        const { gen, data, it } = cxt
        gen.if(it.parentData, () =>
          gen.assign(
            data,
            (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`
          )
        )
      }
      function addErrs(cxt, errs) {
        const { gen } = cxt
        gen.if(
          (0, codegen_1._)`Array.isArray(${errs})`,
          () => {
            gen
              .assign(
                names_1.default.vErrors,
                (0,
                codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
              )
              .assign(
                names_1.default.errors,
                (0, codegen_1._)`${names_1.default.vErrors}.length`
              )
            ;(0, errors_1.extendErrors)(cxt)
          },
          () => cxt.error()
        )
      }
      function checkAsyncKeyword({ schemaEnv }, def) {
        if (def.async && !schemaEnv.$async)
          throw new Error('async keyword in sync schema')
      }
      function useKeyword(gen, keyword, result) {
        if (result === undefined)
          throw new Error(`keyword "${keyword}" failed to compile`)
        return gen.scopeValue(
          'keyword',
          typeof result == 'function'
            ? { ref: result }
            : { ref: result, code: (0, codegen_1.stringify)(result) }
        )
      }
      function validSchemaType(schema, schemaType, allowUndefined = false) {
        // TODO add tests
        return (
          !schemaType.length ||
          schemaType.some((st) =>
            st === 'array'
              ? Array.isArray(schema)
              : st === 'object'
              ? schema && typeof schema == 'object' && !Array.isArray(schema)
              : typeof schema == st ||
                (allowUndefined && typeof schema == 'undefined')
          )
        )
      }
      exports.validSchemaType = validSchemaType
      function validateKeywordUsage(
        { schema, opts, self, errSchemaPath },
        def,
        keyword
      ) {
        /* istanbul ignore if */
        if (
          Array.isArray(def.keyword)
            ? !def.keyword.includes(keyword)
            : def.keyword !== keyword
        ) {
          throw new Error('ajv implementation error')
        }
        const deps = def.dependencies
        if (
          deps === null || deps === void 0
            ? void 0
            : deps.some(
                (kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)
              )
        ) {
          throw new Error(
            `parent schema must have dependencies of ${keyword}: ${deps.join(
              ','
            )}`
          )
        }
        if (def.validateSchema) {
          const valid = def.validateSchema(schema[keyword])
          if (!valid) {
            const msg =
              `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
              self.errorsText(def.validateSchema.errors)
            if (opts.validateSchema === 'log') self.logger.error(msg)
            else throw new Error(msg)
          }
        }
      }
      exports.validateKeywordUsage = validateKeywordUsage
      //# sourceMappingURL=keyword.js.map

      /***/
    },

    /***/ 3099: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.extendSubschemaMode =
        exports.extendSubschemaData =
        exports.getSubschema =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      function getSubschema(
        it,
        { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }
      ) {
        if (keyword !== undefined && schema !== undefined) {
          throw new Error(
            'both "keyword" and "schema" passed, only one allowed'
          )
        }
        if (keyword !== undefined) {
          const sch = it.schema[keyword]
          return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
                codegen_1.getProperty)(keyword)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`
              }
            : {
                schema: sch[schemaProp],
                schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
                codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(
                  schemaProp
                )}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0,
                util_1.escapeFragment)(schemaProp)}`
              }
        }
        if (schema !== undefined) {
          if (
            schemaPath === undefined ||
            errSchemaPath === undefined ||
            topSchemaRef === undefined
          ) {
            throw new Error(
              '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
            )
          }
          return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath
          }
        }
        throw new Error('either "keyword" or "schema" must be passed')
      }
      exports.getSubschema = getSubschema
      function extendSubschemaData(
        subschema,
        it,
        { dataProp, dataPropType: dpType, data, dataTypes, propertyName }
      ) {
        if (data !== undefined && dataProp !== undefined) {
          throw new Error('both "data" and "dataProp" passed, only one allowed')
        }
        const { gen } = it
        if (dataProp !== undefined) {
          const { errorPath, dataPathArr, opts } = it
          const nextData = gen.let(
            'data',
            (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`,
            true
          )
          dataContextProps(nextData)
          subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0,
          util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`
          subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`
          subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]
        }
        if (data !== undefined) {
          const nextData =
            data instanceof codegen_1.Name ? data : gen.let('data', data, true) // replaceable if used once?
          dataContextProps(nextData)
          if (propertyName !== undefined) subschema.propertyName = propertyName
          // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
        }
        if (dataTypes) subschema.dataTypes = dataTypes
        function dataContextProps(_nextData) {
          subschema.data = _nextData
          subschema.dataLevel = it.dataLevel + 1
          subschema.dataTypes = []
          it.definedProperties = new Set()
          subschema.parentData = it.data
          subschema.dataNames = [...it.dataNames, _nextData]
        }
      }
      exports.extendSubschemaData = extendSubschemaData
      function extendSubschemaMode(
        subschema,
        {
          jtdDiscriminator,
          jtdMetadata,
          compositeRule,
          createErrors,
          allErrors
        }
      ) {
        if (compositeRule !== undefined) subschema.compositeRule = compositeRule
        if (createErrors !== undefined) subschema.createErrors = createErrors
        if (allErrors !== undefined) subschema.allErrors = allErrors
        subschema.jtdDiscriminator = jtdDiscriminator // not inherited
        subschema.jtdMetadata = jtdMetadata // not inherited
      }
      exports.extendSubschemaMode = extendSubschemaMode
      //# sourceMappingURL=subschema.js.map

      /***/
    },

    /***/ 7159: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.CodeGen =
        exports.Name =
        exports.nil =
        exports.stringify =
        exports.str =
        exports._ =
        exports.KeywordCxt =
          void 0
      var validate_1 = __webpack_require__(4815)
      Object.defineProperty(exports, 'KeywordCxt', {
        enumerable: true,
        get: function () {
          return validate_1.KeywordCxt
        }
      })
      var codegen_1 = __webpack_require__(3487)
      Object.defineProperty(exports, '_', {
        enumerable: true,
        get: function () {
          return codegen_1._
        }
      })
      Object.defineProperty(exports, 'str', {
        enumerable: true,
        get: function () {
          return codegen_1.str
        }
      })
      Object.defineProperty(exports, 'stringify', {
        enumerable: true,
        get: function () {
          return codegen_1.stringify
        }
      })
      Object.defineProperty(exports, 'nil', {
        enumerable: true,
        get: function () {
          return codegen_1.nil
        }
      })
      Object.defineProperty(exports, 'Name', {
        enumerable: true,
        get: function () {
          return codegen_1.Name
        }
      })
      Object.defineProperty(exports, 'CodeGen', {
        enumerable: true,
        get: function () {
          return codegen_1.CodeGen
        }
      })
      const validation_error_1 = __webpack_require__(7426)
      const ref_error_1 = __webpack_require__(6646)
      const rules_1 = __webpack_require__(3141)
      const compile_1 = __webpack_require__(5173)
      const codegen_2 = __webpack_require__(3487)
      const resolve_1 = __webpack_require__(2531)
      const dataType_1 = __webpack_require__(453)
      const util_1 = __webpack_require__(6776)
      const $dataRefSchema = __webpack_require__(4775)
      const uri_1 = __webpack_require__(3589)
      const defaultRegExp = (str, flags) => new RegExp(str, flags)
      defaultRegExp.code = 'new RegExp'
      const META_IGNORE_OPTIONS = [
        'removeAdditional',
        'useDefaults',
        'coerceTypes'
      ]
      const EXT_SCOPE_NAMES = new Set([
        'validate',
        'serialize',
        'parse',
        'wrapper',
        'root',
        'schema',
        'keyword',
        'pattern',
        'formats',
        'validate$data',
        'func',
        'obj',
        'Error'
      ])
      const removedOptions = {
        errorDataPath: '',
        format: '`validateFormats: false` can be used instead.',
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: 'Deprecated jsPropertySyntax can be used instead.',
        extendRefs: 'Deprecated ignoreKeywordsWithRef can be used instead.',
        missingRefs:
          'Pass empty schema with $id that should be ignored to ajv.addSchema.',
        processCode:
          'Use option `code: {process: (code, schemaEnv: object) => string}`',
        sourceCode: 'Use option `code: {source: true}`',
        strictDefaults: 'It is default now, see option `strict`.',
        strictKeywords: 'It is default now, see option `strict`.',
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats:
          'Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).',
        cache: 'Map is used as cache, schema object as key.',
        serialize: 'Map is used as cache, schema object as key.',
        ajvErrors: 'It is default now.'
      }
      const deprecatedOptions = {
        ignoreKeywordsWithRef: '',
        jsPropertySyntax: '',
        unicode:
          '"minLength"/"maxLength" account for unicode characters by default.'
      }
      const MAX_EXPRESSION = 200
      // eslint-disable-next-line complexity
      function requiredOptions(o) {
        var _a,
          _b,
          _c,
          _d,
          _e,
          _f,
          _g,
          _h,
          _j,
          _k,
          _l,
          _m,
          _o,
          _p,
          _q,
          _r,
          _s,
          _t,
          _u,
          _v,
          _w,
          _x,
          _y,
          _z,
          _0
        const s = o.strict
        const _optz =
          (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize
        const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0
        const regExp =
          (_c =
            (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !==
            null && _c !== void 0
            ? _c
            : defaultRegExp
        const uriResolver =
          (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default
        return {
          strictSchema:
            (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !==
              null && _f !== void 0
              ? _f
              : true,
          strictNumbers:
            (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !==
              null && _h !== void 0
              ? _h
              : true,
          strictTypes:
            (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !==
              null && _k !== void 0
              ? _k
              : 'log',
          strictTuples:
            (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !==
              null && _m !== void 0
              ? _m
              : 'log',
          strictRequired:
            (_p =
              (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !==
              null && _p !== void 0
              ? _p
              : false,
          code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
          loopRequired:
            (_q = o.loopRequired) !== null && _q !== void 0
              ? _q
              : MAX_EXPRESSION,
          loopEnum:
            (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : '$id',
          addUsedSchema:
            (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema:
            (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats:
            (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp:
            (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver: uriResolver
        }
      }
      class Ajv {
        constructor(opts = {}) {
          this.schemas = {}
          this.refs = {}
          this.formats = {}
          this._compilations = new Set()
          this._loading = {}
          this._cache = new Map()
          opts = this.opts = { ...opts, ...requiredOptions(opts) }
          const { es5, lines } = this.opts.code
          this.scope = new codegen_2.ValueScope({
            scope: {},
            prefixes: EXT_SCOPE_NAMES,
            es5,
            lines
          })
          this.logger = getLogger(opts.logger)
          const formatOpt = opts.validateFormats
          opts.validateFormats = false
          this.RULES = (0, rules_1.getRules)()
          checkOptions.call(this, removedOptions, opts, 'NOT SUPPORTED')
          checkOptions.call(this, deprecatedOptions, opts, 'DEPRECATED', 'warn')
          this._metaOpts = getMetaSchemaOptions.call(this)
          if (opts.formats) addInitialFormats.call(this)
          this._addVocabularies()
          this._addDefaultMetaSchema()
          if (opts.keywords) addInitialKeywords.call(this, opts.keywords)
          if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta)
          addInitialSchemas.call(this)
          opts.validateFormats = formatOpt
        }
        _addVocabularies() {
          this.addKeyword('$async')
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts
          let _dataRefSchema = $dataRefSchema
          if (schemaId === 'id') {
            _dataRefSchema = { ...$dataRefSchema }
            _dataRefSchema.id = _dataRefSchema.$id
            delete _dataRefSchema.$id
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts
          return (this.opts.defaultMeta =
            typeof meta == 'object' ? meta[schemaId] || meta : undefined)
        }
        validate(
          schemaKeyRef, // key, ref or schema object
          data // to be validated
        ) {
          let v
          if (typeof schemaKeyRef == 'string') {
            v = this.getSchema(schemaKeyRef)
            if (!v)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`)
          } else {
            v = this.compile(schemaKeyRef)
          }
          const valid = v(data)
          if (!('$async' in v)) this.errors = v.errors
          return valid
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta)
          return sch.validate || this._compileSchemaEnv(sch)
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != 'function') {
            throw new Error('options.loadSchema should be a function')
          }
          const { loadSchema } = this.opts
          return runCompileAsync.call(this, schema, meta)
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema)
            const sch = this._addSchema(_schema, _meta)
            return sch.validate || _compileAsync.call(this, sch)
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true)
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch)
            } catch (e) {
              if (!(e instanceof ref_error_1.default)) throw e
              checkLoaded.call(this, e)
              await loadMissingSchema.call(this, e.missingSchema)
              return _compileAsync.call(this, sch)
            }
          }
          function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
              throw new Error(
                `AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`
              )
            }
          }
          async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref)
            if (!this.refs[ref])
              await loadMetaSchema.call(this, _schema.$schema)
            if (!this.refs[ref]) this.addSchema(_schema, ref, meta)
          }
          async function _loadSchema(ref) {
            const p = this._loading[ref]
            if (p) return p
            try {
              return await (this._loading[ref] = loadSchema(ref))
            } finally {
              delete this._loading[ref]
            }
          }
        }
        // Adds schema to the instance
        addSchema(
          schema, // If array is passed, `key` will be ignored
          key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
          _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
          _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
        ) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, undefined, _meta, _validateSchema)
            return this
          }
          let id
          if (typeof schema === 'object') {
            const { schemaId } = this.opts
            id = schema[schemaId]
            if (id !== undefined && typeof id != 'string') {
              throw new Error(`schema ${schemaId} must be string`)
            }
          }
          key = (0, resolve_1.normalizeId)(key || id)
          this._checkUnique(key)
          this.schemas[key] = this._addSchema(
            schema,
            _meta,
            key,
            _validateSchema,
            true
          )
          return this
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(
          schema,
          key, // schema key
          _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
        ) {
          this.addSchema(schema, key, true, _validateSchema)
          return this
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == 'boolean') return true
          let $schema
          $schema = schema.$schema
          if ($schema !== undefined && typeof $schema != 'string') {
            throw new Error('$schema must be a string')
          }
          $schema = $schema || this.opts.defaultMeta || this.defaultMeta()
          if (!$schema) {
            this.logger.warn('meta-schema not available')
            this.errors = null
            return true
          }
          const valid = this.validate($schema, schema)
          if (!valid && throwOrLogError) {
            const message = 'schema is invalid: ' + this.errorsText()
            if (this.opts.validateSchema === 'log') this.logger.error(message)
            else throw new Error(message)
          }
          return valid
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch
          while (typeof (sch = getSchEnv.call(this, keyRef)) == 'string')
            keyRef = sch
          if (sch === undefined) {
            const { schemaId } = this.opts
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId })
            sch = compile_1.resolveSchema.call(this, root, keyRef)
            if (!sch) return
            this.refs[keyRef] = sch
          }
          return sch.validate || this._compileSchemaEnv(sch)
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef)
            this._removeAllSchemas(this.refs, schemaKeyRef)
            return this
          }
          switch (typeof schemaKeyRef) {
            case 'undefined':
              this._removeAllSchemas(this.schemas)
              this._removeAllSchemas(this.refs)
              this._cache.clear()
              return this
            case 'string': {
              const sch = getSchEnv.call(this, schemaKeyRef)
              if (typeof sch == 'object') this._cache.delete(sch.schema)
              delete this.schemas[schemaKeyRef]
              delete this.refs[schemaKeyRef]
              return this
            }
            case 'object': {
              const cacheKey = schemaKeyRef
              this._cache.delete(cacheKey)
              let id = schemaKeyRef[this.opts.schemaId]
              if (id) {
                id = (0, resolve_1.normalizeId)(id)
                delete this.schemas[id]
                delete this.refs[id]
              }
              return this
            }
            default:
              throw new Error('ajv.removeSchema: invalid parameter')
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions) {
          for (const def of definitions) this.addKeyword(def)
          return this
        }
        addKeyword(
          kwdOrDef,
          def // deprecated
        ) {
          let keyword
          if (typeof kwdOrDef == 'string') {
            keyword = kwdOrDef
            if (typeof def == 'object') {
              this.logger.warn(
                'these parameters are deprecated, see docs for addKeyword'
              )
              def.keyword = keyword
            }
          } else if (typeof kwdOrDef == 'object' && def === undefined) {
            def = kwdOrDef
            keyword = def.keyword
            if (Array.isArray(keyword) && !keyword.length) {
              throw new Error(
                'addKeywords: keyword must be string or non-empty array'
              )
            }
          } else {
            throw new Error('invalid addKeywords parameters')
          }
          checkKeyword.call(this, keyword, def)
          if (!def) {
            ;(0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd))
            return this
          }
          keywordMetaschema.call(this, def)
          const definition = {
            ...def,
            type: (0, dataType_1.getJSONTypes)(def.type),
            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
          }
          ;(0, util_1.eachItem)(
            keyword,
            definition.type.length === 0
              ? (k) => addRule.call(this, k, definition)
              : (k) =>
                  definition.type.forEach((t) =>
                    addRule.call(this, k, definition, t)
                  )
          )
          return this
        }
        getKeyword(keyword) {
          const rule = this.RULES.all[keyword]
          return typeof rule == 'object' ? rule.definition : !!rule
        }
        // Remove keyword
        removeKeyword(keyword) {
          // TODO return type should be Ajv
          const { RULES } = this
          delete RULES.keywords[keyword]
          delete RULES.all[keyword]
          for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword)
            if (i >= 0) group.rules.splice(i, 1)
          }
          return this
        }
        // Add format
        addFormat(name, format) {
          if (typeof format == 'string') format = new RegExp(format)
          this.formats[name] = format
          return this
        }
        errorsText(
          errors = this.errors, // optional array of validation errors
          { separator = ', ', dataVar = 'data' } = {} // optional options with properties `separator` and `dataVar`
        ) {
          if (!errors || errors.length === 0) return 'No errors'
          return errors
            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
            .reduce((text, msg) => text + separator + msg)
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
          const rules = this.RULES.all
          metaSchema = JSON.parse(JSON.stringify(metaSchema))
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split('/').slice(1) // first segment is an empty string
            let keywords = metaSchema
            for (const seg of segments) keywords = keywords[seg]
            for (const key in rules) {
              const rule = rules[key]
              if (typeof rule != 'object') continue
              const { $data } = rule.definition
              const schema = keywords[key]
              if ($data && schema) keywords[key] = schemaOrData(schema)
            }
          }
          return metaSchema
        }
        _removeAllSchemas(schemas, regex) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef]
            if (!regex || regex.test(keyRef)) {
              if (typeof sch == 'string') {
                delete schemas[keyRef]
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema)
                delete schemas[keyRef]
              }
            }
          }
        }
        _addSchema(
          schema,
          meta,
          baseId,
          validateSchema = this.opts.validateSchema,
          addSchema = this.opts.addUsedSchema
        ) {
          let id
          const { schemaId } = this.opts
          if (typeof schema == 'object') {
            id = schema[schemaId]
          } else {
            if (this.opts.jtd) throw new Error('schema must be object')
            else if (typeof schema != 'boolean')
              throw new Error('schema must be object or boolean')
          }
          let sch = this._cache.get(schema)
          if (sch !== undefined) return sch
          baseId = (0, resolve_1.normalizeId)(id || baseId)
          const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId)
          sch = new compile_1.SchemaEnv({
            schema,
            schemaId,
            meta,
            baseId,
            localRefs
          })
          this._cache.set(sch.schema, sch)
          if (addSchema && !baseId.startsWith('#')) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (baseId) this._checkUnique(baseId)
            this.refs[baseId] = sch
          }
          if (validateSchema) this.validateSchema(schema, true)
          return sch
        }
        _checkUnique(id) {
          if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`)
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta) this._compileMetaSchema(sch)
          else compile_1.compileSchema.call(this, sch)
          /* istanbul ignore if */
          if (!sch.validate) throw new Error('ajv implementation error')
          return sch.validate
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts
          this.opts = this._metaOpts
          try {
            compile_1.compileSchema.call(this, sch)
          } finally {
            this.opts = currentOpts
          }
        }
      }
      exports['default'] = Ajv
      Ajv.ValidationError = validation_error_1.default
      Ajv.MissingRefError = ref_error_1.default
      function checkOptions(checkOpts, options, msg, log = 'error') {
        for (const key in checkOpts) {
          const opt = key
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_1.normalizeId)(keyRef) // TODO tests fail without this line
        return this.schemas[keyRef] || this.refs[keyRef]
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas
        if (!optsSchemas) return
        if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)
        else
          for (const key in optsSchemas) this.addSchema(optsSchemas[key], key)
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format = this.opts.formats[name]
          if (format) this.addFormat(name, format)
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs)
          return
        }
        this.logger.warn('keywords option as map is deprecated, pass array')
        for (const keyword in defs) {
          const def = defs[keyword]
          if (!def.keyword) def.keyword = keyword
          this.addKeyword(def)
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts }
        for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]
        return metaOpts
      }
      const noLogs = { log() {}, warn() {}, error() {} }
      function getLogger(logger) {
        if (logger === false) return noLogs
        if (logger === undefined) return console
        if (logger.log && logger.warn && logger.error) return logger
        throw new Error('logger must implement log, warn and error methods')
      }
      const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i
      function checkKeyword(keyword, def) {
        const { RULES } = this
        ;(0, util_1.eachItem)(keyword, (kwd) => {
          if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`)
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`)
        })
        if (!def) return
        if (def.$data && !('code' in def || 'validate' in def)) {
          throw new Error(
            '$data keyword must have "code" or "validate" function'
          )
        }
      }
      function addRule(keyword, definition, dataType) {
        var _a
        const post =
          definition === null || definition === void 0
            ? void 0
            : definition.post
        if (dataType && post)
          throw new Error('keyword with "post" flag cannot have "type"')
        const { RULES } = this
        let ruleGroup = post
          ? RULES.post
          : RULES.rules.find(({ type: t }) => t === dataType)
        if (!ruleGroup) {
          ruleGroup = { type: dataType, rules: [] }
          RULES.rules.push(ruleGroup)
        }
        RULES.keywords[keyword] = true
        if (!definition) return
        const rule = {
          keyword,
          definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
          }
        }
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before)
        else ruleGroup.rules.push(rule)
        RULES.all[keyword] = rule
        ;(_a = definition.implements) === null || _a === void 0
          ? void 0
          : _a.forEach((kwd) => this.addKeyword(kwd))
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)
        if (i >= 0) {
          ruleGroup.rules.splice(i, 0, rule)
        } else {
          ruleGroup.rules.push(rule)
          this.logger.warn(`rule ${before} is not defined`)
        }
      }
      function keywordMetaschema(def) {
        let { metaSchema } = def
        if (metaSchema === undefined) return
        if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)
        def.validateSchema = this.compile(metaSchema, true)
      }
      const $dataRef = {
        $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#'
      }
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] }
      }
      //# sourceMappingURL=core.js.map

      /***/
    },

    /***/ 3510: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      // https://github.com/ajv-validator/ajv/issues/889
      const equal = __webpack_require__(4063)
      equal.code = 'require("ajv/dist/runtime/equal").default'
      exports['default'] = equal
      //# sourceMappingURL=equal.js.map

      /***/
    },

    /***/ 4499: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      // https://mathiasbynens.be/notes/javascript-encoding
      // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
      function ucs2length(str) {
        const len = str.length
        let length = 0
        let pos = 0
        let value
        while (pos < len) {
          length++
          value = str.charCodeAt(pos++)
          if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos)
            if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate
          }
        }
        return length
      }
      exports['default'] = ucs2length
      ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default'
      //# sourceMappingURL=ucs2length.js.map

      /***/
    },

    /***/ 3589: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const uri = __webpack_require__(540)
      uri.code = 'require("ajv/dist/runtime/uri").default'
      exports['default'] = uri
      //# sourceMappingURL=uri.js.map

      /***/
    },

    /***/ 7426: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      class ValidationError extends Error {
        constructor(errors) {
          super('validation failed')
          this.errors = errors
          this.ajv = this.validation = true
        }
      }
      exports['default'] = ValidationError
      //# sourceMappingURL=validation_error.js.map

      /***/
    },

    /***/ 4783: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateAdditionalItems = void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { len } }) =>
          (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      }
      const def = {
        keyword: 'additionalItems',
        type: 'array',
        schemaType: ['boolean', 'object'],
        before: 'uniqueItems',
        error,
        code(cxt) {
          const { parentSchema, it } = cxt
          const { items } = parentSchema
          if (!Array.isArray(items)) {
            ;(0, util_1.checkStrictMode)(
              it,
              '"additionalItems" is ignored when "items" is not an array of schemas'
            )
            return
          }
          validateAdditionalItems(cxt, items)
        }
      }
      function validateAdditionalItems(cxt, items) {
        const { gen, schema, data, keyword, it } = cxt
        it.items = true
        const len = gen.const('len', (0, codegen_1._)`${data}.length`)
        if (schema === false) {
          cxt.setParams({ len: items.length })
          cxt.pass((0, codegen_1._)`${len} <= ${items.length}`)
        } else if (
          typeof schema == 'object' &&
          !(0, util_1.alwaysValidSchema)(it, schema)
        ) {
          const valid = gen.var(
            'valid',
            (0, codegen_1._)`${len} <= ${items.length}`
          ) // TODO var
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid))
          cxt.ok(valid)
        }
        function validateItems(valid) {
          gen.forRange('i', items.length, len, (i) => {
            cxt.subschema(
              { keyword, dataProp: i, dataPropType: util_1.Type.Num },
              valid
            )
            if (!it.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break())
          })
        }
      }
      exports.validateAdditionalItems = validateAdditionalItems
      exports['default'] = def
      //# sourceMappingURL=additionalItems.js.map

      /***/
    },

    /***/ 9351: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: 'must NOT have additional properties',
        params: ({ params }) =>
          (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
      }
      const def = {
        keyword: 'additionalProperties',
        type: ['object'],
        schemaType: ['boolean', 'object'],
        allowUndefined: true,
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, errsCount, it } = cxt
          /* istanbul ignore if */
          if (!errsCount) throw new Error('ajv implementation error')
          const { allErrors, opts } = it
          it.props = true
          if (
            opts.removeAdditional !== 'all' &&
            (0, util_1.alwaysValidSchema)(it, schema)
          )
            return
          const props = (0, code_1.allSchemaProperties)(parentSchema.properties)
          const patProps = (0, code_1.allSchemaProperties)(
            parentSchema.patternProperties
          )
          checkAdditionalProperties()
          cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`)
          function checkAdditionalProperties() {
            gen.forIn('key', data, (key) => {
              if (!props.length && !patProps.length) additionalPropertyCode(key)
              else gen.if(isAdditional(key), () => additionalPropertyCode(key))
            })
          }
          function isAdditional(key) {
            let definedProp
            if (props.length > 8) {
              // TODO maybe an option instead of hard-coded 8?
              const propsSchema = (0, util_1.schemaRefOrVal)(
                it,
                parentSchema.properties,
                'properties'
              )
              definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key)
            } else if (props.length) {
              definedProp = (0, codegen_1.or)(
                ...props.map((p) => (0, codegen_1._)`${key} === ${p}`)
              )
            } else {
              definedProp = codegen_1.nil
            }
            if (patProps.length) {
              definedProp = (0, codegen_1.or)(
                definedProp,
                ...patProps.map(
                  (p) =>
                    (0, codegen_1._)`${(0, code_1.usePattern)(
                      cxt,
                      p
                    )}.test(${key})`
                )
              )
            }
            return (0, codegen_1.not)(definedProp)
          }
          function deleteAdditional(key) {
            gen.code((0, codegen_1._)`delete ${data}[${key}]`)
          }
          function additionalPropertyCode(key) {
            if (
              opts.removeAdditional === 'all' ||
              (opts.removeAdditional && schema === false)
            ) {
              deleteAdditional(key)
              return
            }
            if (schema === false) {
              cxt.setParams({ additionalProperty: key })
              cxt.error()
              if (!allErrors) gen.break()
              return
            }
            if (
              typeof schema == 'object' &&
              !(0, util_1.alwaysValidSchema)(it, schema)
            ) {
              const valid = gen.name('valid')
              if (opts.removeAdditional === 'failing') {
                applyAdditionalSchema(key, valid, false)
                gen.if((0, codegen_1.not)(valid), () => {
                  cxt.reset()
                  deleteAdditional(key)
                })
              } else {
                applyAdditionalSchema(key, valid)
                if (!allErrors)
                  gen.if((0, codegen_1.not)(valid), () => gen.break())
              }
            }
          }
          function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
              keyword: 'additionalProperties',
              dataProp: key,
              dataPropType: util_1.Type.Str
            }
            if (errors === false) {
              Object.assign(subschema, {
                compositeRule: true,
                createErrors: false,
                allErrors: false
              })
            }
            cxt.subschema(subschema, valid)
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=additionalProperties.js.map

      /***/
    },

    /***/ 1125: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: 'allOf',
        schemaType: 'array',
        code(cxt) {
          const { gen, schema, it } = cxt
          /* istanbul ignore if */
          if (!Array.isArray(schema))
            throw new Error('ajv implementation error')
          const valid = gen.name('valid')
          schema.forEach((sch, i) => {
            if ((0, util_1.alwaysValidSchema)(it, sch)) return
            const schCxt = cxt.subschema(
              { keyword: 'allOf', schemaProp: i },
              valid
            )
            cxt.ok(valid)
            cxt.mergeEvaluated(schCxt)
          })
        }
      }
      exports['default'] = def
      //# sourceMappingURL=allOf.js.map

      /***/
    },

    /***/ 19: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const def = {
        keyword: 'anyOf',
        schemaType: 'array',
        trackErrors: true,
        code: code_1.validateUnion,
        error: { message: 'must match a schema in anyOf' }
      }
      exports['default'] = def
      //# sourceMappingURL=anyOf.js.map

      /***/
    },

    /***/ 9864: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { min, max } }) =>
          max === undefined
            ? (0, codegen_1.str)`must contain at least ${min} valid item(s)`
            : (0,
              codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min, max } }) =>
          max === undefined
            ? (0, codegen_1._)`{minContains: ${min}}`
            : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
      }
      const def = {
        keyword: 'contains',
        type: 'array',
        schemaType: ['object', 'boolean'],
        before: 'uniqueItems',
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt
          let min
          let max
          const { minContains, maxContains } = parentSchema
          if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains
            max = maxContains
          } else {
            min = 1
          }
          const len = gen.const('len', (0, codegen_1._)`${data}.length`)
          cxt.setParams({ min, max })
          if (max === undefined && min === 0) {
            ;(0, util_1.checkStrictMode)(
              it,
              `"minContains" == 0 without "maxContains": "contains" keyword ignored`
            )
            return
          }
          if (max !== undefined && min > max) {
            ;(0, util_1.checkStrictMode)(
              it,
              `"minContains" > "maxContains" is always invalid`
            )
            cxt.fail()
            return
          }
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1._)`${len} >= ${min}`
            if (max !== undefined)
              cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`
            cxt.pass(cond)
            return
          }
          it.items = true
          const valid = gen.name('valid')
          if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()))
          } else if (min === 0) {
            gen.let(valid, true)
            if (max !== undefined)
              gen.if(
                (0, codegen_1._)`${data}.length > 0`,
                validateItemsWithCount
              )
          } else {
            gen.let(valid, false)
            validateItemsWithCount()
          }
          cxt.result(valid, () => cxt.reset())
          function validateItemsWithCount() {
            const schValid = gen.name('_valid')
            const count = gen.let('count', 0)
            validateItems(schValid, () =>
              gen.if(schValid, () => checkLimits(count))
            )
          }
          function validateItems(_valid, block) {
            gen.forRange('i', 0, len, (i) => {
              cxt.subschema(
                {
                  keyword: 'contains',
                  dataProp: i,
                  dataPropType: util_1.Type.Num,
                  compositeRule: true
                },
                _valid
              )
              block()
            })
          }
          function checkLimits(count) {
            gen.code((0, codegen_1._)`${count}++`)
            if (max === undefined) {
              gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
                gen.assign(valid, true).break()
              )
            } else {
              gen.if((0, codegen_1._)`${count} > ${max}`, () =>
                gen.assign(valid, false).break()
              )
              if (min === 1) gen.assign(valid, true)
              else
                gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
                  gen.assign(valid, true)
                )
            }
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=contains.js.map

      /***/
    },

    /***/ 7772: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateSchemaDeps =
        exports.validatePropertyDeps =
        exports.error =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const code_1 = __webpack_require__(412)
      exports.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? 'property' : 'properties'
          return (0,
          codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`
        },
        params: ({
          params: { property, depsCount, deps, missingProperty }
        }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}` // TODO change to reference
      }
      const def = {
        keyword: 'dependencies',
        type: 'object',
        schemaType: 'object',
        error: exports.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt)
          validatePropertyDeps(cxt, propDeps)
          validateSchemaDeps(cxt, schDeps)
        }
      }
      function splitDependencies({ schema }) {
        const propertyDeps = {}
        const schemaDeps = {}
        for (const key in schema) {
          if (key === '__proto__') continue
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps
          deps[key] = schema[key]
        }
        return [propertyDeps, schemaDeps]
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt
        if (Object.keys(propertyDeps).length === 0) return
        const missing = gen.let('missing')
        for (const prop in propertyDeps) {
          const deps = propertyDeps[prop]
          if (deps.length === 0) continue
          const hasProperty = (0, code_1.propertyInData)(
            gen,
            data,
            prop,
            it.opts.ownProperties
          )
          cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(', ')
          })
          if (it.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                ;(0, code_1.checkReportMissingProp)(cxt, depProp)
              }
            })
          } else {
            gen.if(
              (0, codegen_1._)`${hasProperty} && (${(0,
              code_1.checkMissingProp)(cxt, deps, missing)})`
            )
            ;(0, code_1.reportMissingProp)(cxt, missing)
            gen.else()
          }
        }
      }
      exports.validatePropertyDeps = validatePropertyDeps
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword, it } = cxt
        const valid = gen.name('valid')
        for (const prop in schemaDeps) {
          if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue
          gen.if(
            (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid)
              cxt.mergeValidEvaluated(schCxt, valid)
            },
            () => gen.var(valid, true) // TODO var
          )
          cxt.ok(valid)
        }
      }
      exports.validateSchemaDeps = validateSchemaDeps
      exports['default'] = def
      //# sourceMappingURL=dependencies.js.map

      /***/
    },

    /***/ 9434: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params }) =>
          (0, codegen_1.str)`must match "${params.ifClause}" schema`,
        params: ({ params }) =>
          (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
      }
      const def = {
        keyword: 'if',
        schemaType: ['object', 'boolean'],
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, parentSchema, it } = cxt
          if (
            parentSchema.then === undefined &&
            parentSchema.else === undefined
          ) {
            ;(0, util_1.checkStrictMode)(
              it,
              '"if" without "then" and "else" is ignored'
            )
          }
          const hasThen = hasSchema(it, 'then')
          const hasElse = hasSchema(it, 'else')
          if (!hasThen && !hasElse) return
          const valid = gen.let('valid', true)
          const schValid = gen.name('_valid')
          validateIf()
          cxt.reset()
          if (hasThen && hasElse) {
            const ifClause = gen.let('ifClause')
            cxt.setParams({ ifClause })
            gen.if(
              schValid,
              validateClause('then', ifClause),
              validateClause('else', ifClause)
            )
          } else if (hasThen) {
            gen.if(schValid, validateClause('then'))
          } else {
            gen.if((0, codegen_1.not)(schValid), validateClause('else'))
          }
          cxt.pass(valid, () => cxt.error(true))
          function validateIf() {
            const schCxt = cxt.subschema(
              {
                keyword: 'if',
                compositeRule: true,
                createErrors: false,
                allErrors: false
              },
              schValid
            )
            cxt.mergeEvaluated(schCxt)
          }
          function validateClause(keyword, ifClause) {
            return () => {
              const schCxt = cxt.subschema({ keyword }, schValid)
              gen.assign(valid, schValid)
              cxt.mergeValidEvaluated(schCxt, valid)
              if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`)
              else cxt.setParams({ ifClause: keyword })
            }
          }
        }
      }
      function hasSchema(it, keyword) {
        const schema = it.schema[keyword]
        return (
          schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema)
        )
      }
      exports['default'] = def
      //# sourceMappingURL=if.js.map

      /***/
    },

    /***/ 8200: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const additionalItems_1 = __webpack_require__(4783)
      const prefixItems_1 = __webpack_require__(2924)
      const items_1 = __webpack_require__(4665)
      const items2020_1 = __webpack_require__(1119)
      const contains_1 = __webpack_require__(9864)
      const dependencies_1 = __webpack_require__(7772)
      const propertyNames_1 = __webpack_require__(3708)
      const additionalProperties_1 = __webpack_require__(9351)
      const properties_1 = __webpack_require__(6239)
      const patternProperties_1 = __webpack_require__(2296)
      const not_1 = __webpack_require__(5697)
      const anyOf_1 = __webpack_require__(19)
      const oneOf_1 = __webpack_require__(4200)
      const allOf_1 = __webpack_require__(1125)
      const if_1 = __webpack_require__(9434)
      const thenElse_1 = __webpack_require__(6552)
      function getApplicator(draft2020 = false) {
        const applicator = [
          // any
          not_1.default,
          anyOf_1.default,
          oneOf_1.default,
          allOf_1.default,
          if_1.default,
          thenElse_1.default,
          // object
          propertyNames_1.default,
          additionalProperties_1.default,
          dependencies_1.default,
          properties_1.default,
          patternProperties_1.default
        ]
        // array
        if (draft2020)
          applicator.push(prefixItems_1.default, items2020_1.default)
        else applicator.push(additionalItems_1.default, items_1.default)
        applicator.push(contains_1.default)
        return applicator
      }
      exports['default'] = getApplicator
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 4665: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateTuple = void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const code_1 = __webpack_require__(412)
      const def = {
        keyword: 'items',
        type: 'array',
        schemaType: ['object', 'array', 'boolean'],
        before: 'uniqueItems',
        code(cxt) {
          const { schema, it } = cxt
          if (Array.isArray(schema))
            return validateTuple(cxt, 'additionalItems', schema)
          it.items = true
          if ((0, util_1.alwaysValidSchema)(it, schema)) return
          cxt.ok((0, code_1.validateArray)(cxt))
        }
      }
      function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen, parentSchema, data, keyword, it } = cxt
        checkStrictTuple(parentSchema)
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
          it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items)
        }
        const valid = gen.name('valid')
        const len = gen.const('len', (0, codegen_1._)`${data}.length`)
        schArr.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch)) return
          gen.if((0, codegen_1._)`${len} > ${i}`, () =>
            cxt.subschema(
              {
                keyword,
                schemaProp: i,
                dataProp: i
              },
              valid
            )
          )
          cxt.ok(valid)
        })
        function checkStrictTuple(sch) {
          const { opts, errSchemaPath } = it
          const l = schArr.length
          const fullTuple =
            l === sch.minItems &&
            (l === sch.maxItems || sch[extraItems] === false)
          if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`
            ;(0, util_1.checkStrictMode)(it, msg, opts.strictTuples)
          }
        }
      }
      exports.validateTuple = validateTuple
      exports['default'] = def
      //# sourceMappingURL=items.js.map

      /***/
    },

    /***/ 1119: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const code_1 = __webpack_require__(412)
      const additionalItems_1 = __webpack_require__(4783)
      const error = {
        message: ({ params: { len } }) =>
          (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      }
      const def = {
        keyword: 'items',
        type: 'array',
        schemaType: ['object', 'boolean'],
        before: 'uniqueItems',
        error,
        code(cxt) {
          const { schema, parentSchema, it } = cxt
          const { prefixItems } = parentSchema
          it.items = true
          if ((0, util_1.alwaysValidSchema)(it, schema)) return
          if (prefixItems)
            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems)
          else cxt.ok((0, code_1.validateArray)(cxt))
        }
      }
      exports['default'] = def
      //# sourceMappingURL=items2020.js.map

      /***/
    },

    /***/ 5697: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: 'not',
        schemaType: ['object', 'boolean'],
        trackErrors: true,
        code(cxt) {
          const { gen, schema, it } = cxt
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            cxt.fail()
            return
          }
          const valid = gen.name('valid')
          cxt.subschema(
            {
              keyword: 'not',
              compositeRule: true,
              createErrors: false,
              allErrors: false
            },
            valid
          )
          cxt.failResult(
            valid,
            () => cxt.reset(),
            () => cxt.error()
          )
        },
        error: { message: 'must NOT be valid' }
      }
      exports['default'] = def
      //# sourceMappingURL=not.js.map

      /***/
    },

    /***/ 4200: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: 'must match exactly one schema in oneOf',
        params: ({ params }) =>
          (0, codegen_1._)`{passingSchemas: ${params.passing}}`
      }
      const def = {
        keyword: 'oneOf',
        schemaType: 'array',
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, it } = cxt
          /* istanbul ignore if */
          if (!Array.isArray(schema))
            throw new Error('ajv implementation error')
          if (it.opts.discriminator && parentSchema.discriminator) return
          const schArr = schema
          const valid = gen.let('valid', false)
          const passing = gen.let('passing', null)
          const schValid = gen.name('_valid')
          cxt.setParams({ passing })
          // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
          gen.block(validateOneOf)
          cxt.result(
            valid,
            () => cxt.reset(),
            () => cxt.error(true)
          )
          function validateOneOf() {
            schArr.forEach((sch, i) => {
              let schCxt
              if ((0, util_1.alwaysValidSchema)(it, sch)) {
                gen.var(schValid, true)
              } else {
                schCxt = cxt.subschema(
                  {
                    keyword: 'oneOf',
                    schemaProp: i,
                    compositeRule: true
                  },
                  schValid
                )
              }
              if (i > 0) {
                gen
                  .if((0, codegen_1._)`${schValid} && ${valid}`)
                  .assign(valid, false)
                  .assign(passing, (0, codegen_1._)`[${passing}, ${i}]`)
                  .else()
              }
              gen.if(schValid, () => {
                gen.assign(valid, true)
                gen.assign(passing, i)
                if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name)
              })
            })
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=oneOf.js.map

      /***/
    },

    /***/ 2296: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const util_2 = __webpack_require__(6776)
      const def = {
        keyword: 'patternProperties',
        type: 'object',
        schemaType: 'object',
        code(cxt) {
          const { gen, schema, data, parentSchema, it } = cxt
          const { opts } = it
          const patterns = (0, code_1.allSchemaProperties)(schema)
          const alwaysValidPatterns = patterns.filter((p) =>
            (0, util_1.alwaysValidSchema)(it, schema[p])
          )
          if (
            patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
              (!it.opts.unevaluated || it.props === true))
          ) {
            return
          }
          const checkProperties =
            opts.strictSchema &&
            !opts.allowMatchingProperties &&
            parentSchema.properties
          const valid = gen.name('valid')
          if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props)
          }
          const { props } = it
          validatePatternProperties()
          function validatePatternProperties() {
            for (const pat of patterns) {
              if (checkProperties) checkMatchingProperties(pat)
              if (it.allErrors) {
                validateProperties(pat)
              } else {
                gen.var(valid, true) // TODO var
                validateProperties(pat)
                gen.if(valid)
              }
            }
          }
          function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
              if (new RegExp(pat).test(prop)) {
                ;(0, util_1.checkStrictMode)(
                  it,
                  `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`
                )
              }
            }
          }
          function validateProperties(pat) {
            gen.forIn('key', data, (key) => {
              gen.if(
                (0, codegen_1._)`${(0, code_1.usePattern)(
                  cxt,
                  pat
                )}.test(${key})`,
                () => {
                  const alwaysValid = alwaysValidPatterns.includes(pat)
                  if (!alwaysValid) {
                    cxt.subschema(
                      {
                        keyword: 'patternProperties',
                        schemaProp: pat,
                        dataProp: key,
                        dataPropType: util_2.Type.Str
                      },
                      valid
                    )
                  }
                  if (it.opts.unevaluated && props !== true) {
                    gen.assign((0, codegen_1._)`${props}[${key}]`, true)
                  } else if (!alwaysValid && !it.allErrors) {
                    // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                    // or if all properties were evaluated (props === true)
                    gen.if((0, codegen_1.not)(valid), () => gen.break())
                  }
                }
              )
            })
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=patternProperties.js.map

      /***/
    },

    /***/ 2924: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const items_1 = __webpack_require__(4665)
      const def = {
        keyword: 'prefixItems',
        type: 'array',
        schemaType: ['array'],
        before: 'uniqueItems',
        code: (cxt) => (0, items_1.validateTuple)(cxt, 'items')
      }
      exports['default'] = def
      //# sourceMappingURL=prefixItems.js.map

      /***/
    },

    /***/ 6239: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const validate_1 = __webpack_require__(4815)
      const code_1 = __webpack_require__(412)
      const util_1 = __webpack_require__(6776)
      const additionalProperties_1 = __webpack_require__(9351)
      const def = {
        keyword: 'properties',
        type: 'object',
        schemaType: 'object',
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt
          if (
            it.opts.removeAdditional === 'all' &&
            parentSchema.additionalProperties === undefined
          ) {
            additionalProperties_1.default.code(
              new validate_1.KeywordCxt(
                it,
                additionalProperties_1.default,
                'additionalProperties'
              )
            )
          }
          const allProps = (0, code_1.allSchemaProperties)(schema)
          for (const prop of allProps) {
            it.definedProperties.add(prop)
          }
          if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(
              gen,
              (0, util_1.toHash)(allProps),
              it.props
            )
          }
          const properties = allProps.filter(
            (p) => !(0, util_1.alwaysValidSchema)(it, schema[p])
          )
          if (properties.length === 0) return
          const valid = gen.name('valid')
          for (const prop of properties) {
            if (hasDefault(prop)) {
              applyPropertySchema(prop)
            } else {
              gen.if(
                (0, code_1.propertyInData)(
                  gen,
                  data,
                  prop,
                  it.opts.ownProperties
                )
              )
              applyPropertySchema(prop)
              if (!it.allErrors) gen.else().var(valid, true)
              gen.endIf()
            }
            cxt.it.definedProperties.add(prop)
            cxt.ok(valid)
          }
          function hasDefault(prop) {
            return (
              it.opts.useDefaults &&
              !it.compositeRule &&
              schema[prop].default !== undefined
            )
          }
          function applyPropertySchema(prop) {
            cxt.subschema(
              {
                keyword: 'properties',
                schemaProp: prop,
                dataProp: prop
              },
              valid
            )
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=properties.js.map

      /***/
    },

    /***/ 3708: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: 'property name must be valid',
        params: ({ params }) =>
          (0, codegen_1._)`{propertyName: ${params.propertyName}}`
      }
      const def = {
        keyword: 'propertyNames',
        type: 'object',
        schemaType: ['object', 'boolean'],
        error,
        code(cxt) {
          const { gen, schema, data, it } = cxt
          if ((0, util_1.alwaysValidSchema)(it, schema)) return
          const valid = gen.name('valid')
          gen.forIn('key', data, (key) => {
            cxt.setParams({ propertyName: key })
            cxt.subschema(
              {
                keyword: 'propertyNames',
                data: key,
                dataTypes: ['string'],
                propertyName: key,
                compositeRule: true
              },
              valid
            )
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(true)
              if (!it.allErrors) gen.break()
            })
          })
          cxt.ok(valid)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=propertyNames.js.map

      /***/
    },

    /***/ 6552: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: ['then', 'else'],
        schemaType: ['object', 'boolean'],
        code({ keyword, parentSchema, it }) {
          if (parentSchema.if === undefined)
            (0, util_1.checkStrictMode)(
              it,
              `"${keyword}" without "if" is ignored`
            )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=thenElse.js.map

      /***/
    },

    /***/ 412: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateUnion =
        exports.validateArray =
        exports.usePattern =
        exports.callValidateCode =
        exports.schemaProperties =
        exports.allSchemaProperties =
        exports.noPropertyInData =
        exports.propertyInData =
        exports.isOwnProperty =
        exports.hasPropFunc =
        exports.reportMissingProp =
        exports.checkMissingProp =
        exports.checkReportMissingProp =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const names_1 = __webpack_require__(2141)
      const util_2 = __webpack_require__(6776)
      function checkReportMissingProp(cxt, prop) {
        const { gen, data, it } = cxt
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
          cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true)
          cxt.error()
        })
      }
      exports.checkReportMissingProp = checkReportMissingProp
      function checkMissingProp(
        { gen, data, it: { opts } },
        properties,
        missing
      ) {
        return (0, codegen_1.or)(
          ...properties.map((prop) =>
            (0, codegen_1.and)(
              noPropertyInData(gen, data, prop, opts.ownProperties),
              (0, codegen_1._)`${missing} = ${prop}`
            )
          )
        )
      }
      exports.checkMissingProp = checkMissingProp
      function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true)
        cxt.error()
      }
      exports.reportMissingProp = reportMissingProp
      function hasPropFunc(gen) {
        return gen.scopeValue('func', {
          // eslint-disable-next-line @typescript-eslint/unbound-method
          ref: Object.prototype.hasOwnProperty,
          code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
        })
      }
      exports.hasPropFunc = hasPropFunc
      function isOwnProperty(gen, data, property) {
        return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`
      }
      exports.isOwnProperty = isOwnProperty
      function propertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
          property
        )} !== undefined`
        return ownProperties
          ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}`
          : cond
      }
      exports.propertyInData = propertyInData
      function noPropertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
          property
        )} === undefined`
        return ownProperties
          ? (0, codegen_1.or)(
              cond,
              (0, codegen_1.not)(isOwnProperty(gen, data, property))
            )
          : cond
      }
      exports.noPropertyInData = noPropertyInData
      function allSchemaProperties(schemaMap) {
        return schemaMap
          ? Object.keys(schemaMap).filter((p) => p !== '__proto__')
          : []
      }
      exports.allSchemaProperties = allSchemaProperties
      function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter(
          (p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p])
        )
      }
      exports.schemaProperties = schemaProperties
      function callValidateCode(
        {
          schemaCode,
          data,
          it: { gen, topSchemaRef, schemaPath, errorPath },
          it
        },
        func,
        context,
        passSchema
      ) {
        const dataAndSchema = passSchema
          ? (0,
            codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}`
          : data
        const valCxt = [
          [
            names_1.default.instancePath,
            (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)
          ],
          [names_1.default.parentData, it.parentData],
          [names_1.default.parentDataProperty, it.parentDataProperty],
          [names_1.default.rootData, names_1.default.rootData]
        ]
        if (it.opts.dynamicRef)
          valCxt.push([
            names_1.default.dynamicAnchors,
            names_1.default.dynamicAnchors
          ])
        const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(
          ...valCxt
        )}`
        return context !== codegen_1.nil
          ? (0, codegen_1._)`${func}.call(${context}, ${args})`
          : (0, codegen_1._)`${func}(${args})`
      }
      exports.callValidateCode = callValidateCode
      const newRegExp = (0, codegen_1._)`new RegExp`
      function usePattern({ gen, it: { opts } }, pattern) {
        const u = opts.unicodeRegExp ? 'u' : ''
        const { regExp } = opts.code
        const rx = regExp(pattern, u)
        return gen.scopeValue('pattern', {
          key: rx.toString(),
          ref: rx,
          code: (0, codegen_1._)`${
            regExp.code === 'new RegExp'
              ? newRegExp
              : (0, util_2.useFunc)(gen, regExp)
          }(${pattern}, ${u})`
        })
      }
      exports.usePattern = usePattern
      function validateArray(cxt) {
        const { gen, data, keyword, it } = cxt
        const valid = gen.name('valid')
        if (it.allErrors) {
          const validArr = gen.let('valid', true)
          validateItems(() => gen.assign(validArr, false))
          return validArr
        }
        gen.var(valid, true)
        validateItems(() => gen.break())
        return valid
        function validateItems(notValid) {
          const len = gen.const('len', (0, codegen_1._)`${data}.length`)
          gen.forRange('i', 0, len, (i) => {
            cxt.subschema(
              {
                keyword,
                dataProp: i,
                dataPropType: util_1.Type.Num
              },
              valid
            )
            gen.if((0, codegen_1.not)(valid), notValid)
          })
        }
      }
      exports.validateArray = validateArray
      function validateUnion(cxt) {
        const { gen, schema, keyword, it } = cxt
        /* istanbul ignore if */
        if (!Array.isArray(schema)) throw new Error('ajv implementation error')
        const alwaysValid = schema.some((sch) =>
          (0, util_1.alwaysValidSchema)(it, sch)
        )
        if (alwaysValid && !it.opts.unevaluated) return
        const valid = gen.let('valid', false)
        const schValid = gen.name('_valid')
        gen.block(() =>
          schema.forEach((_sch, i) => {
            const schCxt = cxt.subschema(
              {
                keyword,
                schemaProp: i,
                compositeRule: true
              },
              schValid
            )
            gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`)
            const merged = cxt.mergeValidEvaluated(schCxt, schValid)
            // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
            // or if all properties and items were evaluated (it.props === true && it.items === true)
            if (!merged) gen.if((0, codegen_1.not)(valid))
          })
        )
        cxt.result(
          valid,
          () => cxt.reset(),
          () => cxt.error(true)
        )
      }
      exports.validateUnion = validateUnion
      //# sourceMappingURL=code.js.map

      /***/
    },

    /***/ 8386: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const def = {
        keyword: 'id',
        code() {
          throw new Error(
            'NOT SUPPORTED: keyword "id", use "$id" for schema ID'
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=id.js.map

      /***/
    },

    /***/ 5684: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const id_1 = __webpack_require__(8386)
      const ref_1 = __webpack_require__(8280)
      const core = [
        '$schema',
        '$id',
        '$defs',
        '$vocabulary',
        { keyword: '$comment' },
        'definitions',
        id_1.default,
        ref_1.default
      ]
      exports['default'] = core
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 8280: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.callRef = exports.getValidate = void 0
      const ref_error_1 = __webpack_require__(6646)
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const compile_1 = __webpack_require__(5173)
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: '$ref',
        schemaType: 'string',
        code(cxt) {
          const { gen, schema: $ref, it } = cxt
          const { baseId, schemaEnv: env, validateName, opts, self } = it
          const { root } = env
          if (($ref === '#' || $ref === '#/') && baseId === root.baseId)
            return callRootRef()
          const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref)
          if (schOrEnv === undefined)
            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref)
          if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv)
          return inlineRefSchema(schOrEnv)
          function callRootRef() {
            if (env === root) return callRef(cxt, validateName, env, env.$async)
            const rootName = gen.scopeValue('root', { ref: root })
            return callRef(
              cxt,
              (0, codegen_1._)`${rootName}.validate`,
              root,
              root.$async
            )
          }
          function callValidate(sch) {
            const v = getValidate(cxt, sch)
            callRef(cxt, v, sch, sch.$async)
          }
          function inlineRefSchema(sch) {
            const schName = gen.scopeValue(
              'schema',
              opts.code.source === true
                ? { ref: sch, code: (0, codegen_1.stringify)(sch) }
                : { ref: sch }
            )
            const valid = gen.name('valid')
            const schCxt = cxt.subschema(
              {
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref
              },
              valid
            )
            cxt.mergeEvaluated(schCxt)
            cxt.ok(valid)
          }
        }
      }
      function getValidate(cxt, sch) {
        const { gen } = cxt
        return sch.validate
          ? gen.scopeValue('validate', { ref: sch.validate })
          : (0, codegen_1._)`${gen.scopeValue('wrapper', {
              ref: sch
            })}.validate`
      }
      exports.getValidate = getValidate
      function callRef(cxt, v, sch, $async) {
        const { gen, it } = cxt
        const { allErrors, schemaEnv: env, opts } = it
        const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil
        if ($async) callAsyncRef()
        else callSyncRef()
        function callAsyncRef() {
          if (!env.$async)
            throw new Error('async schema referenced by sync schema')
          const valid = gen.let('valid')
          gen.try(
            () => {
              gen.code(
                (0, codegen_1._)`await ${(0, code_1.callValidateCode)(
                  cxt,
                  v,
                  passCxt
                )}`
              )
              addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result
              if (!allErrors) gen.assign(valid, true)
            },
            (e) => {
              gen.if(
                (0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`,
                () => gen.throw(e)
              )
              addErrorsFrom(e)
              if (!allErrors) gen.assign(valid, false)
            }
          )
          cxt.ok(valid)
        }
        function callSyncRef() {
          cxt.result(
            (0, code_1.callValidateCode)(cxt, v, passCxt),
            () => addEvaluatedFrom(v),
            () => addErrorsFrom(v)
          )
        }
        function addErrorsFrom(source) {
          const errs = (0, codegen_1._)`${source}.errors`
          gen.assign(
            names_1.default.vErrors,
            (0,
            codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
          ) // TODO tagged
          gen.assign(
            names_1.default.errors,
            (0, codegen_1._)`${names_1.default.vErrors}.length`
          )
        }
        function addEvaluatedFrom(source) {
          var _a
          if (!it.opts.unevaluated) return
          const schEvaluated =
            (_a = sch === null || sch === void 0 ? void 0 : sch.validate) ===
              null || _a === void 0
              ? void 0
              : _a.evaluated
          // TODO refactor
          if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
              if (schEvaluated.props !== undefined) {
                it.props = util_1.mergeEvaluated.props(
                  gen,
                  schEvaluated.props,
                  it.props
                )
              }
            } else {
              const props = gen.var(
                'props',
                (0, codegen_1._)`${source}.evaluated.props`
              )
              it.props = util_1.mergeEvaluated.props(
                gen,
                props,
                it.props,
                codegen_1.Name
              )
            }
          }
          if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
              if (schEvaluated.items !== undefined) {
                it.items = util_1.mergeEvaluated.items(
                  gen,
                  schEvaluated.items,
                  it.items
                )
              }
            } else {
              const items = gen.var(
                'items',
                (0, codegen_1._)`${source}.evaluated.items`
              )
              it.items = util_1.mergeEvaluated.items(
                gen,
                items,
                it.items,
                codegen_1.Name
              )
            }
          }
        }
      }
      exports.callRef = callRef
      exports['default'] = def
      //# sourceMappingURL=ref.js.map

      /***/
    },

    /***/ 1240: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const types_1 = __webpack_require__(9306)
      const compile_1 = __webpack_require__(5173)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { discrError, tagName } }) =>
          discrError === types_1.DiscrError.Tag
            ? `tag "${tagName}" must be string`
            : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError, tag, tagName } }) =>
          (0,
          codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
      }
      const def = {
        keyword: 'discriminator',
        type: 'object',
        schemaType: 'object',
        error,
        code(cxt) {
          const { gen, data, schema, parentSchema, it } = cxt
          const { oneOf } = parentSchema
          if (!it.opts.discriminator) {
            throw new Error('discriminator: requires discriminator option')
          }
          const tagName = schema.propertyName
          if (typeof tagName != 'string')
            throw new Error('discriminator: requires propertyName')
          if (schema.mapping)
            throw new Error('discriminator: mapping is not supported')
          if (!oneOf) throw new Error('discriminator: requires oneOf keyword')
          const valid = gen.let('valid', false)
          const tag = gen.const(
            'tag',
            (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`
          )
          gen.if(
            (0, codegen_1._)`typeof ${tag} == "string"`,
            () => validateMapping(),
            () =>
              cxt.error(false, {
                discrError: types_1.DiscrError.Tag,
                tag,
                tagName
              })
          )
          cxt.ok(valid)
          function validateMapping() {
            const mapping = getMapping()
            gen.if(false)
            for (const tagValue in mapping) {
              gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`)
              gen.assign(valid, applyTagSchema(mapping[tagValue]))
            }
            gen.else()
            cxt.error(false, {
              discrError: types_1.DiscrError.Mapping,
              tag,
              tagName
            })
            gen.endIf()
          }
          function applyTagSchema(schemaProp) {
            const _valid = gen.name('valid')
            const schCxt = cxt.subschema(
              { keyword: 'oneOf', schemaProp },
              _valid
            )
            cxt.mergeEvaluated(schCxt, codegen_1.Name)
            return _valid
          }
          function getMapping() {
            var _a
            const oneOfMapping = {}
            const topRequired = hasRequired(parentSchema)
            let tagRequired = true
            for (let i = 0; i < oneOf.length; i++) {
              let sch = oneOf[i]
              if (
                (sch === null || sch === void 0 ? void 0 : sch.$ref) &&
                !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)
              ) {
                sch = compile_1.resolveRef.call(
                  it.self,
                  it.schemaEnv.root,
                  it.baseId,
                  sch === null || sch === void 0 ? void 0 : sch.$ref
                )
                if (sch instanceof compile_1.SchemaEnv) sch = sch.schema
              }
              const propSch =
                (_a =
                  sch === null || sch === void 0 ? void 0 : sch.properties) ===
                  null || _a === void 0
                  ? void 0
                  : _a[tagName]
              if (typeof propSch != 'object') {
                throw new Error(
                  `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`
                )
              }
              tagRequired = tagRequired && (topRequired || hasRequired(sch))
              addMappings(propSch, i)
            }
            if (!tagRequired)
              throw new Error(`discriminator: "${tagName}" must be required`)
            return oneOfMapping
            function hasRequired({ required }) {
              return Array.isArray(required) && required.includes(tagName)
            }
            function addMappings(sch, i) {
              if (sch.const) {
                addMapping(sch.const, i)
              } else if (sch.enum) {
                for (const tagValue of sch.enum) {
                  addMapping(tagValue, i)
                }
              } else {
                throw new Error(
                  `discriminator: "properties/${tagName}" must have "const" or "enum"`
                )
              }
            }
            function addMapping(tagValue, i) {
              if (typeof tagValue != 'string' || tagValue in oneOfMapping) {
                throw new Error(
                  `discriminator: "${tagName}" values must be unique strings`
                )
              }
              oneOfMapping[tagValue] = i
            }
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 9306: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.DiscrError = void 0
      var DiscrError
      ;(function (DiscrError) {
        DiscrError['Tag'] = 'tag'
        DiscrError['Mapping'] = 'mapping'
      })((DiscrError = exports.DiscrError || (exports.DiscrError = {})))
      //# sourceMappingURL=types.js.map

      /***/
    },

    /***/ 3924: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const core_1 = __webpack_require__(5684)
      const validation_1 = __webpack_require__(2649)
      const applicator_1 = __webpack_require__(8200)
      const format_1 = __webpack_require__(9502)
      const metadata_1 = __webpack_require__(6167)
      const draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        (0, applicator_1.default)(),
        format_1.default,
        metadata_1.metadataVocabulary,
        metadata_1.contentVocabulary
      ]
      exports['default'] = draft7Vocabularies
      //# sourceMappingURL=draft7.js.map

      /***/
    },

    /***/ 9651: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message: ({ schemaCode }) =>
          (0, codegen_1.str)`must match format "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
      }
      const def = {
        keyword: 'format',
        type: ['number', 'string'],
        schemaType: 'string',
        $data: true,
        error,
        code(cxt, ruleType) {
          const { gen, data, $data, schema, schemaCode, it } = cxt
          const { opts, errSchemaPath, schemaEnv, self } = it
          if (!opts.validateFormats) return
          if ($data) validate$DataFormat()
          else validateFormat()
          function validate$DataFormat() {
            const fmts = gen.scopeValue('formats', {
              ref: self.formats,
              code: opts.code.formats
            })
            const fDef = gen.const(
              'fDef',
              (0, codegen_1._)`${fmts}[${schemaCode}]`
            )
            const fType = gen.let('fType')
            const format = gen.let('format')
            // TODO simplify
            gen.if(
              (0,
              codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`,
              () =>
                gen
                  .assign(fType, (0, codegen_1._)`${fDef}.type || "string"`)
                  .assign(format, (0, codegen_1._)`${fDef}.validate`),
              () =>
                gen
                  .assign(fType, (0, codegen_1._)`"string"`)
                  .assign(format, fDef)
            )
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()))
            function unknownFmt() {
              if (opts.strictSchema === false) return codegen_1.nil
              return (0, codegen_1._)`${schemaCode} && !${format}`
            }
            function invalidFmt() {
              const callFormat = schemaEnv.$async
                ? (0,
                  codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                : (0, codegen_1._)`${format}(${data})`
              const validData = (0,
              codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`
              return (0,
              codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`
            }
          }
          function validateFormat() {
            const formatDef = self.formats[schema]
            if (!formatDef) {
              unknownFormat()
              return
            }
            if (formatDef === true) return
            const [fmtType, format, fmtRef] = getFormat(formatDef)
            if (fmtType === ruleType) cxt.pass(validCondition())
            function unknownFormat() {
              if (opts.strictSchema === false) {
                self.logger.warn(unknownMsg())
                return
              }
              throw new Error(unknownMsg())
              function unknownMsg() {
                return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`
              }
            }
            function getFormat(fmtDef) {
              const code =
                fmtDef instanceof RegExp
                  ? (0, codegen_1.regexpCode)(fmtDef)
                  : opts.code.formats
                  ? (0, codegen_1._)`${opts.code.formats}${(0,
                    codegen_1.getProperty)(schema)}`
                  : undefined
              const fmt = gen.scopeValue('formats', {
                key: schema,
                ref: fmtDef,
                code
              })
              if (typeof fmtDef == 'object' && !(fmtDef instanceof RegExp)) {
                return [
                  fmtDef.type || 'string',
                  fmtDef.validate,
                  (0, codegen_1._)`${fmt}.validate`
                ]
              }
              return ['string', fmtDef, fmt]
            }
            function validCondition() {
              if (
                typeof formatDef == 'object' &&
                !(formatDef instanceof RegExp) &&
                formatDef.async
              ) {
                if (!schemaEnv.$async)
                  throw new Error('async format in sync schema')
                return (0, codegen_1._)`await ${fmtRef}(${data})`
              }
              return typeof format == 'function'
                ? (0, codegen_1._)`${fmtRef}(${data})`
                : (0, codegen_1._)`${fmtRef}.test(${data})`
            }
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=format.js.map

      /***/
    },

    /***/ 9502: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const format_1 = __webpack_require__(9651)
      const format = [format_1.default]
      exports['default'] = format
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 6167: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.contentVocabulary = exports.metadataVocabulary = void 0
      exports.metadataVocabulary = [
        'title',
        'description',
        'default',
        'deprecated',
        'readOnly',
        'writeOnly',
        'examples'
      ]
      exports.contentVocabulary = [
        'contentMediaType',
        'contentEncoding',
        'contentSchema'
      ]
      //# sourceMappingURL=metadata.js.map

      /***/
    },

    /***/ 4693: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const equal_1 = __webpack_require__(3510)
      const error = {
        message: 'must be equal to constant',
        params: ({ schemaCode }) =>
          (0, codegen_1._)`{allowedValue: ${schemaCode}}`
      }
      const def = {
        keyword: 'const',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schemaCode, schema } = cxt
          if ($data || (schema && typeof schema == 'object')) {
            cxt.fail$data(
              (0, codegen_1._)`!${(0, util_1.useFunc)(
                gen,
                equal_1.default
              )}(${data}, ${schemaCode})`
            )
          } else {
            cxt.fail((0, codegen_1._)`${schema} !== ${data}`)
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=const.js.map

      /***/
    },

    /***/ 966: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const equal_1 = __webpack_require__(3510)
      const error = {
        message: 'must be equal to one of the allowed values',
        params: ({ schemaCode }) =>
          (0, codegen_1._)`{allowedValues: ${schemaCode}}`
      }
      const def = {
        keyword: 'enum',
        schemaType: 'array',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, schemaCode, it } = cxt
          if (!$data && schema.length === 0)
            throw new Error('enum must have non-empty array')
          const useLoop = schema.length >= it.opts.loopEnum
          let eql
          const getEql = () =>
            eql !== null && eql !== void 0
              ? eql
              : (eql = (0, util_1.useFunc)(gen, equal_1.default))
          let valid
          if (useLoop || $data) {
            valid = gen.let('valid')
            cxt.block$data(valid, loopEnum)
          } else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
              throw new Error('ajv implementation error')
            const vSchema = gen.const('vSchema', schemaCode)
            valid = (0, codegen_1.or)(
              ...schema.map((_x, i) => equalCode(vSchema, i))
            )
          }
          cxt.pass(valid)
          function loopEnum() {
            gen.assign(valid, false)
            gen.forOf('v', schemaCode, (v) =>
              gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () =>
                gen.assign(valid, true).break()
              )
            )
          }
          function equalCode(vSchema, i) {
            const sch = schema[i]
            return typeof sch === 'object' && sch !== null
              ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])`
              : (0, codegen_1._)`${data} === ${sch}`
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=enum.js.map

      /***/
    },

    /***/ 2649: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const limitNumber_1 = __webpack_require__(3983)
      const multipleOf_1 = __webpack_require__(430)
      const limitLength_1 = __webpack_require__(3229)
      const pattern_1 = __webpack_require__(4336)
      const limitProperties_1 = __webpack_require__(498)
      const required_1 = __webpack_require__(3301)
      const limitItems_1 = __webpack_require__(1687)
      const uniqueItems_1 = __webpack_require__(2958)
      const const_1 = __webpack_require__(4693)
      const enum_1 = __webpack_require__(966)
      const validation = [
        // number
        limitNumber_1.default,
        multipleOf_1.default,
        // string
        limitLength_1.default,
        pattern_1.default,
        // object
        limitProperties_1.default,
        required_1.default,
        // array
        limitItems_1.default,
        uniqueItems_1.default,
        // any
        { keyword: 'type', schemaType: ['string', 'array'] },
        { keyword: 'nullable', schemaType: 'boolean' },
        const_1.default,
        enum_1.default
      ]
      exports['default'] = validation
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 1687: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === 'maxItems' ? 'more' : 'fewer'
          return (0,
          codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      }
      const def = {
        keyword: ['maxItems', 'minItems'],
        type: 'array',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt
          const op =
            keyword === 'maxItems'
              ? codegen_1.operators.GT
              : codegen_1.operators.LT
          cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitItems.js.map

      /***/
    },

    /***/ 3229: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const ucs2length_1 = __webpack_require__(4499)
      const error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === 'maxLength' ? 'more' : 'fewer'
          return (0,
          codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      }
      const def = {
        keyword: ['maxLength', 'minLength'],
        type: 'string',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode, it } = cxt
          const op =
            keyword === 'maxLength'
              ? codegen_1.operators.GT
              : codegen_1.operators.LT
          const len =
            it.opts.unicode === false
              ? (0, codegen_1._)`${data}.length`
              : (0, codegen_1._)`${(0, util_1.useFunc)(
                  cxt.gen,
                  ucs2length_1.default
                )}(${data})`
          cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitLength.js.map

      /***/
    },

    /***/ 3983: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const ops = codegen_1.operators
      const KWDs = {
        maximum: { okStr: '<=', ok: ops.LTE, fail: ops.GT },
        minimum: { okStr: '>=', ok: ops.GTE, fail: ops.LT },
        exclusiveMaximum: { okStr: '<', ok: ops.LT, fail: ops.GTE },
        exclusiveMinimum: { okStr: '>', ok: ops.GT, fail: ops.LTE }
      }
      const error = {
        message: ({ keyword, schemaCode }) =>
          (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) =>
          (0,
          codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      }
      const def = {
        keyword: Object.keys(KWDs),
        type: 'number',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt
          cxt.fail$data(
            (0,
            codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitNumber.js.map

      /***/
    },

    /***/ 498: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === 'maxProperties' ? 'more' : 'fewer'
          return (0,
          codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      }
      const def = {
        keyword: ['maxProperties', 'minProperties'],
        type: 'object',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt
          const op =
            keyword === 'maxProperties'
              ? codegen_1.operators.GT
              : codegen_1.operators.LT
          cxt.fail$data(
            (0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitProperties.js.map

      /***/
    },

    /***/ 430: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message: ({ schemaCode }) =>
          (0, codegen_1.str)`must be multiple of ${schemaCode}`,
        params: ({ schemaCode }) =>
          (0, codegen_1._)`{multipleOf: ${schemaCode}}`
      }
      const def = {
        keyword: 'multipleOf',
        type: 'number',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, it } = cxt
          // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
          const prec = it.opts.multipleOfPrecision
          const res = gen.let('res')
          const invalid = prec
            ? (0,
              codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1._)`${res} !== parseInt(${res})`
          cxt.fail$data(
            (0,
            codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=multipleOf.js.map

      /***/
    },

    /***/ 4336: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message: ({ schemaCode }) =>
          (0, codegen_1.str)`must match pattern "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
      }
      const def = {
        keyword: 'pattern',
        type: 'string',
        schemaType: 'string',
        $data: true,
        error,
        code(cxt) {
          const { data, $data, schema, schemaCode, it } = cxt
          // TODO regexp should be wrapped in try/catchs
          const u = it.opts.unicodeRegExp ? 'u' : ''
          const regExp = $data
            ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))`
            : (0, code_1.usePattern)(cxt, schema)
          cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=pattern.js.map

      /***/
    },

    /***/ 3301: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { missingProperty } }) =>
          (0, codegen_1.str)`must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty } }) =>
          (0, codegen_1._)`{missingProperty: ${missingProperty}}`
      }
      const def = {
        keyword: 'required',
        type: 'object',
        schemaType: 'array',
        $data: true,
        error,
        code(cxt) {
          const { gen, schema, schemaCode, data, $data, it } = cxt
          const { opts } = it
          if (!$data && schema.length === 0) return
          const useLoop = schema.length >= opts.loopRequired
          if (it.allErrors) allErrorsMode()
          else exitOnErrorMode()
          if (opts.strictRequired) {
            const props = cxt.parentSchema.properties
            const { definedProperties } = cxt.it
            for (const requiredKey of schema) {
              if (
                (props === null || props === void 0
                  ? void 0
                  : props[requiredKey]) === undefined &&
                !definedProperties.has(requiredKey)
              ) {
                const schemaPath = it.schemaEnv.baseId + it.errSchemaPath
                const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`
                ;(0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired)
              }
            }
          }
          function allErrorsMode() {
            if (useLoop || $data) {
              cxt.block$data(codegen_1.nil, loopAllRequired)
            } else {
              for (const prop of schema) {
                ;(0, code_1.checkReportMissingProp)(cxt, prop)
              }
            }
          }
          function exitOnErrorMode() {
            const missing = gen.let('missing')
            if (useLoop || $data) {
              const valid = gen.let('valid', true)
              cxt.block$data(valid, () => loopUntilMissing(missing, valid))
              cxt.ok(valid)
            } else {
              gen.if((0, code_1.checkMissingProp)(cxt, schema, missing))
              ;(0, code_1.reportMissingProp)(cxt, missing)
              gen.else()
            }
          }
          function loopAllRequired() {
            gen.forOf('prop', schemaCode, (prop) => {
              cxt.setParams({ missingProperty: prop })
              gen.if(
                (0, code_1.noPropertyInData)(
                  gen,
                  data,
                  prop,
                  opts.ownProperties
                ),
                () => cxt.error()
              )
            })
          }
          function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing })
            gen.forOf(
              missing,
              schemaCode,
              () => {
                gen.assign(
                  valid,
                  (0, code_1.propertyInData)(
                    gen,
                    data,
                    missing,
                    opts.ownProperties
                  )
                )
                gen.if((0, codegen_1.not)(valid), () => {
                  cxt.error()
                  gen.break()
                })
              },
              codegen_1.nil
            )
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=required.js.map

      /***/
    },

    /***/ 2958: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const dataType_1 = __webpack_require__(453)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const equal_1 = __webpack_require__(3510)
      const error = {
        message: ({ params: { i, j } }) =>
          (0,
          codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
        params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
      }
      const def = {
        keyword: 'uniqueItems',
        type: 'array',
        schemaType: 'boolean',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt
          if (!$data && !schema) return
          const valid = gen.let('valid')
          const itemTypes = parentSchema.items
            ? (0, dataType_1.getSchemaTypes)(parentSchema.items)
            : []
          cxt.block$data(
            valid,
            validateUniqueItems,
            (0, codegen_1._)`${schemaCode} === false`
          )
          cxt.ok(valid)
          function validateUniqueItems() {
            const i = gen.let('i', (0, codegen_1._)`${data}.length`)
            const j = gen.let('j')
            cxt.setParams({ i, j })
            gen.assign(valid, true)
            gen.if((0, codegen_1._)`${i} > 1`, () =>
              (canOptimize() ? loopN : loopN2)(i, j)
            )
          }
          function canOptimize() {
            return (
              itemTypes.length > 0 &&
              !itemTypes.some((t) => t === 'object' || t === 'array')
            )
          }
          function loopN(i, j) {
            const item = gen.name('item')
            const wrongType = (0, dataType_1.checkDataTypes)(
              itemTypes,
              item,
              it.opts.strictNumbers,
              dataType_1.DataType.Wrong
            )
            const indices = gen.const('indices', (0, codegen_1._)`{}`)
            gen.for((0, codegen_1._)`;${i}--;`, () => {
              gen.let(item, (0, codegen_1._)`${data}[${i}]`)
              gen.if(wrongType, (0, codegen_1._)`continue`)
              if (itemTypes.length > 1)
                gen.if(
                  (0, codegen_1._)`typeof ${item} == "string"`,
                  (0, codegen_1._)`${item} += "_"`
                )
              gen
                .if(
                  (0, codegen_1._)`typeof ${indices}[${item}] == "number"`,
                  () => {
                    gen.assign(j, (0, codegen_1._)`${indices}[${item}]`)
                    cxt.error()
                    gen.assign(valid, false).break()
                  }
                )
                .code((0, codegen_1._)`${indices}[${item}] = ${i}`)
            })
          }
          function loopN2(i, j) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default)
            const outer = gen.name('outer')
            gen.label(outer).for((0, codegen_1._)`;${i}--;`, () =>
              gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () =>
                gen.if(
                  (0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`,
                  () => {
                    cxt.error()
                    gen.assign(valid, false).break(outer)
                  }
                )
              )
            )
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=uniqueItems.js.map

      /***/
    },

    /***/ 8307: /***/ function (module, exports) {
      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__
      /**
       * alertifyjs 1.13.1 http://alertifyjs.com
       * AlertifyJS is a javascript framework for developing pretty browser dialogs and notifications.
       * Copyright 2019 Mohammad Younes <Mohammad@alertifyjs.com> (http://alertifyjs.com)
       * Licensed under GPL 3 <https://opensource.org/licenses/gpl-3.0>*/
      ;(function (window) {
        'use strict'
        var NOT_DISABLED_NOT_RESET = ':not(:disabled):not(.ajs-reset)'
        /**
         * Keys enum
         * @type {Object}
         */
        var keys = {
          ENTER: 13,
          ESC: 27,
          F1: 112,
          F12: 123,
          LEFT: 37,
          RIGHT: 39,
          TAB: 9
        }
        /**
         * Default options
         * @type {Object}
         */
        var defaults = {
          autoReset: true,
          basic: false,
          closable: true,
          closableByDimmer: true,
          invokeOnCloseOff: false,
          frameless: false,
          defaultFocusOff: false,
          maintainFocus: true, //global default not per instance, applies to all dialogs
          maximizable: true,
          modal: true,
          movable: true,
          moveBounded: false,
          overflow: true,
          padding: true,
          pinnable: true,
          pinned: true,
          preventBodyShift: false, //global default not per instance, applies to all dialogs
          resizable: true,
          startMaximized: false,
          transition: 'pulse',
          transitionOff: false,
          tabbable: [
            'button',
            '[href]',
            'input',
            'select',
            'textarea',
            '[tabindex]:not([tabindex^="-"])' + NOT_DISABLED_NOT_RESET
          ].join(NOT_DISABLED_NOT_RESET + ','), //global
          notifier: {
            delay: 5,
            position: 'bottom-right',
            closeButton: false,
            classes: {
              base: 'alertify-notifier',
              prefix: 'ajs-',
              message: 'ajs-message',
              top: 'ajs-top',
              right: 'ajs-right',
              bottom: 'ajs-bottom',
              left: 'ajs-left',
              center: 'ajs-center',
              visible: 'ajs-visible',
              hidden: 'ajs-hidden',
              close: 'ajs-close'
            }
          },
          glossary: {
            title: 'AlertifyJS',
            ok: 'OK',
            cancel: 'Cancel',
            acccpt: 'Accept',
            deny: 'Deny',
            confirm: 'Confirm',
            decline: 'Decline',
            close: 'Close',
            maximize: 'Maximize',
            restore: 'Restore'
          },
          theme: {
            input: 'ajs-input',
            ok: 'ajs-ok',
            cancel: 'ajs-cancel'
          },
          hooks: {
            preinit: function () {},
            postinit: function () {}
          }
        }

        //holds open dialogs instances
        var openDialogs = []

        /**
         * [Helper]  Adds the specified class(es) to the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be added to the class attribute of the element.
         *
         * @return {undefined}
         */
        function addClass(element, classNames) {
          element.className += ' ' + classNames
        }

        /**
         * [Helper]  Removes the specified class(es) from the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be removed from the class attribute of the element.
         *
         * @return {undefined}
         */
        function removeClass(element, classNames) {
          var original = element.className.split(' ')
          var toBeRemoved = classNames.split(' ')
          for (var x = 0; x < toBeRemoved.length; x += 1) {
            var index = original.indexOf(toBeRemoved[x])
            if (index > -1) {
              original.splice(index, 1)
            }
          }
          element.className = original.join(' ')
        }

        /**
         * [Helper]  Checks if the document is RTL
         *
         * @return {Boolean} True if the document is RTL, false otherwise.
         */
        function isRightToLeft() {
          return window.getComputedStyle(document.body).direction === 'rtl'
        }
        /**
         * [Helper]  Get the document current scrollTop
         *
         * @return {Number} current document scrollTop value
         */
        function getScrollTop() {
          return (
            (document.documentElement && document.documentElement.scrollTop) ||
            document.body.scrollTop
          )
        }

        /**
         * [Helper]  Get the document current scrollLeft
         *
         * @return {Number} current document scrollLeft value
         */
        function getScrollLeft() {
          return (
            (document.documentElement && document.documentElement.scrollLeft) ||
            document.body.scrollLeft
          )
        }

        /**
         * Helper: clear contents
         *
         */
        function clearContents(element) {
          while (element.lastChild) {
            element.removeChild(element.lastChild)
          }
        }
        /**
         * Extends a given prototype by merging properties from base into sub.
         *
         * @sub {Object} sub The prototype being overwritten.
         * @base {Object} base The prototype being written.
         *
         * @return {Object} The extended prototype.
         */
        function copy(src) {
          if (null === src) {
            return src
          }
          var cpy
          if (Array.isArray(src)) {
            cpy = []
            for (var x = 0; x < src.length; x += 1) {
              cpy.push(copy(src[x]))
            }
            return cpy
          }

          if (src instanceof Date) {
            return new Date(src.getTime())
          }

          if (src instanceof RegExp) {
            cpy = new RegExp(src.source)
            cpy.global = src.global
            cpy.ignoreCase = src.ignoreCase
            cpy.multiline = src.multiline
            cpy.lastIndex = src.lastIndex
            return cpy
          }

          if (typeof src === 'object') {
            cpy = {}
            // copy dialog pototype over definition.
            for (var prop in src) {
              if (src.hasOwnProperty(prop)) {
                cpy[prop] = copy(src[prop])
              }
            }
            return cpy
          }
          return src
        }
        /**
         * Helper: destruct the dialog
         *
         */
        function destruct(instance, initialize) {
          if (instance.elements) {
            //delete the dom and it's references.
            var root = instance.elements.root
            root.parentNode.removeChild(root)
            delete instance.elements
            //copy back initial settings.
            instance.settings = copy(instance.__settings)
            //re-reference init function.
            instance.__init = initialize
            //delete __internal variable to allow re-initialization.
            delete instance.__internal
          }
        }

        /**
         * Test to check if passive event listeners are supported.
         */
        var IsPassiveSupported = false
        try {
          var options = Object.defineProperty({}, 'passive', {
            get: function () {
              IsPassiveSupported = true
            }
          })
          window.addEventListener('test', options, options)
          window.removeEventListener('test', options, options)
        } catch (e) {}

        /**
         * Removes an event listener
         *
         * @param {HTMLElement} el The EventTarget to register the listenr on.
         * @param {string} event The event type to listen for.
         * @param {Function} handler The function to handle the event.
         * @param {boolean} useCapture Specifices if the event to be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.
         * @param {boolean} passive A Boolean which, if true, indicates that the function specified by listener will never call preventDefault().
         */
        var on = function (el, event, fn, useCapture, passive) {
          el.addEventListener(
            event,
            fn,
            IsPassiveSupported
              ? { capture: useCapture, passive: passive }
              : useCapture === true
          )
        }

        /**
         * Removes an event listener
         *
         * @param {HTMLElement} el The EventTarget to unregister the listenr from.
         * @param {string} event The event type to remove.
         * @param {Function} fn The event handler to remove.
         * @param {boolean} useCapture Specifices if the event to be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.
         * @param {boolean} passive A Boolean which, if true, indicates that the function specified by listener will never call preventDefault().
         */
        var off = function (el, event, fn, useCapture, passive) {
          el.removeEventListener(
            event,
            fn,
            IsPassiveSupported
              ? { capture: useCapture, passive: passive }
              : useCapture === true
          )
        }

        /**
     * Prevent default event from firing
     *
     * @param  {Event} event Event object
     * @return {undefined}

    function prevent ( event ) {
        if ( event ) {
            if ( event.preventDefault ) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        }
    }
    */
        var transition = (function () {
          var t, type
          var supported = false
          var transitions = {
            animation: 'animationend',
            OAnimation: 'oAnimationEnd oanimationend',
            msAnimation: 'MSAnimationEnd',
            MozAnimation: 'animationend',
            WebkitAnimation: 'webkitAnimationEnd'
          }

          for (t in transitions) {
            if (document.documentElement.style[t] !== undefined) {
              type = transitions[t]
              supported = true
              break
            }
          }

          return {
            type: type,
            supported: supported
          }
        })()

        /**
         * Creates event handler delegate that sends the instance as last argument.
         *
         * @return {Function}    a function wrapper which sends the instance as last argument.
         */
        function delegate(context, method) {
          return function () {
            if (arguments.length > 0) {
              var args = []
              for (var x = 0; x < arguments.length; x += 1) {
                args.push(arguments[x])
              }
              args.push(context)
              return method.apply(context, args)
            }
            return method.apply(context, [null, context])
          }
        }
        /**
         * Helper for creating a dialog close event.
         *
         * @return {object}
         */
        function createCloseEvent(index, button) {
          return {
            index: index,
            button: button,
            cancel: false
          }
        }
        /**
         * Helper for dispatching events.
         *
         * @param  {string} evenType The type of the event to disptach.
         * @param  {object} instance The dialog instance disptaching the event.
         *
         * @return   {any}   The result of the invoked function.
         */
        function dispatchEvent(eventType, instance) {
          if (typeof instance.get(eventType) === 'function') {
            return instance.get(eventType).call(instance)
          }
        }

        /**
         * Super class for all dialogs
         *
         * @return {Object}		base dialog prototype
         */
        var dialog = (function () {
          var //holds the list of used keys.
            usedKeys = [],
            //dummy variable, used to trigger dom reflow.
            reflow = null,
            //holds body tab index in case it has any.
            tabindex = false,
            //condition for detecting safari
            isSafari =
              window.navigator.userAgent.indexOf('Safari') > -1 &&
              window.navigator.userAgent.indexOf('Chrome') < 0,
            //dialog building blocks
            templates = {
              dimmer: '<div class="ajs-dimmer"></div>',
              /*tab index required to fire click event before body focus*/
              modal: '<div class="ajs-modal" tabindex="0"></div>',
              dialog: '<div class="ajs-dialog" tabindex="0"></div>',
              reset: '<button class="ajs-reset"></button>',
              commands:
                '<div class="ajs-commands"><button class="ajs-pin"></button><button class="ajs-maximize"></button><button class="ajs-close"></button></div>',
              header: '<div class="ajs-header"></div>',
              body: '<div class="ajs-body"></div>',
              content: '<div class="ajs-content"></div>',
              footer: '<div class="ajs-footer"></div>',
              buttons: {
                primary: '<div class="ajs-primary ajs-buttons"></div>',
                auxiliary: '<div class="ajs-auxiliary ajs-buttons"></div>'
              },
              button: '<button class="ajs-button"></button>',
              resizeHandle: '<div class="ajs-handle"></div>'
            },
            //common class names
            classes = {
              animationIn: 'ajs-in',
              animationOut: 'ajs-out',
              base: 'alertify',
              basic: 'ajs-basic',
              capture: 'ajs-capture',
              closable: 'ajs-closable',
              fixed: 'ajs-fixed',
              frameless: 'ajs-frameless',
              hidden: 'ajs-hidden',
              maximize: 'ajs-maximize',
              maximized: 'ajs-maximized',
              maximizable: 'ajs-maximizable',
              modeless: 'ajs-modeless',
              movable: 'ajs-movable',
              noSelection: 'ajs-no-selection',
              noOverflow: 'ajs-no-overflow',
              noPadding: 'ajs-no-padding',
              pin: 'ajs-pin',
              pinnable: 'ajs-pinnable',
              prefix: 'ajs-',
              resizable: 'ajs-resizable',
              restore: 'ajs-restore',
              shake: 'ajs-shake',
              unpinned: 'ajs-unpinned',
              noTransition: 'ajs-no-transition'
            }

          /**
           * Helper: initializes the dialog instance
           *
           * @return	{Number}	The total count of currently open modals.
           */
          function initialize(instance) {
            if (!instance.__internal) {
              //invoke preinit global hook
              alertify.defaults.hooks.preinit(instance)
              //no need to expose init after this.
              delete instance.__init

              //keep a copy of initial dialog settings
              if (!instance.__settings) {
                instance.__settings = copy(instance.settings)
              }

              //get dialog buttons/focus setup
              var setup
              if (typeof instance.setup === 'function') {
                setup = instance.setup()
                setup.options = setup.options || {}
                setup.focus = setup.focus || {}
              } else {
                setup = {
                  buttons: [],
                  focus: {
                    element: null,
                    select: false
                  },
                  options: {}
                }
              }

              //initialize hooks object.
              if (typeof instance.hooks !== 'object') {
                instance.hooks = {}
              }

              //copy buttons defintion
              var buttonsDefinition = []
              if (Array.isArray(setup.buttons)) {
                for (var b = 0; b < setup.buttons.length; b += 1) {
                  var ref = setup.buttons[b],
                    cpy = {}
                  for (var i in ref) {
                    if (ref.hasOwnProperty(i)) {
                      cpy[i] = ref[i]
                    }
                  }
                  buttonsDefinition.push(cpy)
                }
              }

              var internal = (instance.__internal = {
                /**
                 * Flag holding the open state of the dialog
                 *
                 * @type {Boolean}
                 */
                isOpen: false,
                /**
                 * Active element is the element that will receive focus after
                 * closing the dialog. It defaults as the body tag, but gets updated
                 * to the last focused element before the dialog was opened.
                 *
                 * @type {Node}
                 */
                activeElement: document.body,
                timerIn: undefined,
                timerOut: undefined,
                buttons: buttonsDefinition,
                focus: setup.focus,
                options: {
                  title: undefined,
                  modal: undefined,
                  basic: undefined,
                  frameless: undefined,
                  defaultFocusOff: undefined,
                  pinned: undefined,
                  movable: undefined,
                  moveBounded: undefined,
                  resizable: undefined,
                  autoReset: undefined,
                  closable: undefined,
                  closableByDimmer: undefined,
                  invokeOnCloseOff: undefined,
                  maximizable: undefined,
                  startMaximized: undefined,
                  pinnable: undefined,
                  transition: undefined,
                  transitionOff: undefined,
                  padding: undefined,
                  overflow: undefined,
                  onshow: undefined,
                  onclosing: undefined,
                  onclose: undefined,
                  onfocus: undefined,
                  onmove: undefined,
                  onmoved: undefined,
                  onresize: undefined,
                  onresized: undefined,
                  onmaximize: undefined,
                  onmaximized: undefined,
                  onrestore: undefined,
                  onrestored: undefined
                },
                resetHandler: undefined,
                beginMoveHandler: undefined,
                beginResizeHandler: undefined,
                bringToFrontHandler: undefined,
                modalClickHandler: undefined,
                buttonsClickHandler: undefined,
                commandsClickHandler: undefined,
                transitionInHandler: undefined,
                transitionOutHandler: undefined,
                destroy: undefined
              })

              var elements = {}
              //root node
              elements.root = document.createElement('div')
              //prevent FOUC in case of async styles loading.
              elements.root.style.display = 'none'
              elements.root.className =
                classes.base + ' ' + classes.hidden + ' '

              elements.root.innerHTML = templates.dimmer + templates.modal

              //dimmer
              elements.dimmer = elements.root.firstChild

              //dialog
              elements.modal = elements.root.lastChild
              elements.modal.innerHTML = templates.dialog
              elements.dialog = elements.modal.firstChild
              elements.dialog.innerHTML =
                templates.reset +
                templates.commands +
                templates.header +
                templates.body +
                templates.footer +
                templates.resizeHandle +
                templates.reset

              //reset links
              elements.reset = []
              elements.reset.push(elements.dialog.firstChild)
              elements.reset.push(elements.dialog.lastChild)

              //commands
              elements.commands = {}
              elements.commands.container = elements.reset[0].nextSibling
              elements.commands.pin = elements.commands.container.firstChild
              elements.commands.maximize = elements.commands.pin.nextSibling
              elements.commands.close = elements.commands.maximize.nextSibling

              //header
              elements.header = elements.commands.container.nextSibling

              //body
              elements.body = elements.header.nextSibling
              elements.body.innerHTML = templates.content
              elements.content = elements.body.firstChild

              //footer
              elements.footer = elements.body.nextSibling
              elements.footer.innerHTML =
                templates.buttons.auxiliary + templates.buttons.primary

              //resize handle
              elements.resizeHandle = elements.footer.nextSibling

              //buttons
              elements.buttons = {}
              elements.buttons.auxiliary = elements.footer.firstChild
              elements.buttons.primary = elements.buttons.auxiliary.nextSibling
              elements.buttons.primary.innerHTML = templates.button
              elements.buttonTemplate = elements.buttons.primary.firstChild
              //remove button template
              elements.buttons.primary.removeChild(elements.buttonTemplate)

              for (var x = 0; x < instance.__internal.buttons.length; x += 1) {
                var button = instance.__internal.buttons[x]

                // add to the list of used keys.
                if (usedKeys.indexOf(button.key) < 0) {
                  usedKeys.push(button.key)
                }

                button.element = elements.buttonTemplate.cloneNode()
                button.element.innerHTML = button.text
                if (
                  typeof button.className === 'string' &&
                  button.className !== ''
                ) {
                  addClass(button.element, button.className)
                }
                for (var key in button.attrs) {
                  if (key !== 'className' && button.attrs.hasOwnProperty(key)) {
                    button.element.setAttribute(key, button.attrs[key])
                  }
                }
                if (button.scope === 'auxiliary') {
                  elements.buttons.auxiliary.appendChild(button.element)
                } else {
                  elements.buttons.primary.appendChild(button.element)
                }
              }
              //make elements pubic
              instance.elements = elements

              //save event handlers delegates
              internal.resetHandler = delegate(instance, onReset)
              internal.beginMoveHandler = delegate(instance, beginMove)
              internal.beginResizeHandler = delegate(instance, beginResize)
              internal.bringToFrontHandler = delegate(instance, bringToFront)
              internal.modalClickHandler = delegate(instance, modalClickHandler)
              internal.buttonsClickHandler = delegate(
                instance,
                buttonsClickHandler
              )
              internal.commandsClickHandler = delegate(
                instance,
                commandsClickHandler
              )
              internal.transitionInHandler = delegate(
                instance,
                handleTransitionInEvent
              )
              internal.transitionOutHandler = delegate(
                instance,
                handleTransitionOutEvent
              )

              //settings
              for (var opKey in internal.options) {
                if (setup.options[opKey] !== undefined) {
                  // if found in user options
                  instance.set(opKey, setup.options[opKey])
                } else if (alertify.defaults.hasOwnProperty(opKey)) {
                  // else if found in defaults options
                  instance.set(opKey, alertify.defaults[opKey])
                } else if (opKey === 'title') {
                  // else if title key, use alertify.defaults.glossary
                  instance.set(opKey, alertify.defaults.glossary[opKey])
                }
              }

              // allow dom customization
              if (typeof instance.build === 'function') {
                instance.build()
              }

              //invoke postinit global hook
              alertify.defaults.hooks.postinit(instance)
            }

            //add to the end of the DOM tree.
            document.body.appendChild(instance.elements.root)
          }

          /**
           * Helper: maintains scroll position
           *
           */
          var scrollX, scrollY
          function saveScrollPosition() {
            scrollX = getScrollLeft()
            scrollY = getScrollTop()
          }
          function restoreScrollPosition() {
            window.scrollTo(scrollX, scrollY)
          }

          /**
           * Helper: adds/removes no-overflow class from body
           *
           */
          function ensureNoOverflow() {
            var requiresNoOverflow = 0
            for (var x = 0; x < openDialogs.length; x += 1) {
              var instance = openDialogs[x]
              if (instance.isModal() || instance.isMaximized()) {
                requiresNoOverflow += 1
              }
            }
            if (
              requiresNoOverflow === 0 &&
              document.body.className.indexOf(classes.noOverflow) >= 0
            ) {
              //last open modal or last maximized one
              removeClass(document.body, classes.noOverflow)
              preventBodyShift(false)
            } else if (
              requiresNoOverflow > 0 &&
              document.body.className.indexOf(classes.noOverflow) < 0
            ) {
              //first open modal or first maximized one
              preventBodyShift(true)
              addClass(document.body, classes.noOverflow)
            }
          }
          var top = '',
            topScroll = 0
          /**
           * Helper: prevents body shift.
           *
           */
          function preventBodyShift(add) {
            if (alertify.defaults.preventBodyShift) {
              if (
                add &&
                document.documentElement.scrollHeight >
                  document.documentElement.clientHeight
              ) {
                //&& openDialogs[openDialogs.length-1].elements.dialog.clientHeight <= document.documentElement.clientHeight){
                topScroll = scrollY
                top = window.getComputedStyle(document.body).top
                addClass(document.body, classes.fixed)
                document.body.style.top = -scrollY + 'px'
              } else if (!add) {
                scrollY = topScroll
                document.body.style.top = top
                removeClass(document.body, classes.fixed)
                restoreScrollPosition()
              }
            }
          }

          /**
           * Sets the name of the transition used to show/hide the dialog
           *
           * @param {Object} instance The dilog instance.
           *
           */
          function updateTransition(instance, value, oldValue) {
            if (typeof oldValue === 'string') {
              removeClass(instance.elements.root, classes.prefix + oldValue)
            }
            addClass(instance.elements.root, classes.prefix + value)
            reflow = instance.elements.root.offsetWidth
          }

          /**
           * Toggles the dialog no transition
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateTransitionOff(instance) {
            if (instance.get('transitionOff')) {
              // add class
              addClass(instance.elements.root, classes.noTransition)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.noTransition)
            }
          }

          /**
           * Toggles the dialog display mode
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateDisplayMode(instance) {
            if (instance.get('modal')) {
              //make modal
              removeClass(instance.elements.root, classes.modeless)

              //only if open
              if (instance.isOpen()) {
                unbindModelessEvents(instance)

                //in case a pinned modless dialog was made modal while open.
                updateAbsPositionFix(instance)

                ensureNoOverflow()
              }
            } else {
              //make modelss
              addClass(instance.elements.root, classes.modeless)

              //only if open
              if (instance.isOpen()) {
                bindModelessEvents(instance)

                //in case pin/unpin was called while a modal is open
                updateAbsPositionFix(instance)

                ensureNoOverflow()
              }
            }
          }

          /**
           * Toggles the dialog basic view mode
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateBasicMode(instance) {
            if (instance.get('basic')) {
              // add class
              addClass(instance.elements.root, classes.basic)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.basic)
            }
          }

          /**
           * Toggles the dialog frameless view mode
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateFramelessMode(instance) {
            if (instance.get('frameless')) {
              // add class
              addClass(instance.elements.root, classes.frameless)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.frameless)
            }
          }

          /**
           * Helper: Brings the modeless dialog to front, attached to modeless dialogs.
           *
           * @param {Event} event Focus event
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bringToFront(event, instance) {
            // Do not bring to front if preceeded by an open modal
            var index = openDialogs.indexOf(instance)
            for (var x = index + 1; x < openDialogs.length; x += 1) {
              if (openDialogs[x].isModal()) {
                return
              }
            }

            // Bring to front by making it the last child.
            if (document.body.lastChild !== instance.elements.root) {
              document.body.appendChild(instance.elements.root)
              //also make sure its at the end of the list
              openDialogs.splice(openDialogs.indexOf(instance), 1)
              openDialogs.push(instance)
              setFocus(instance)
            }

            return false
          }

          /**
           * Helper: reflects dialogs options updates
           *
           * @param {Object} instance The dilog instance.
           * @param {String} option The updated option name.
           *
           * @return	{undefined}
           */
          function optionUpdated(instance, option, oldValue, newValue) {
            switch (option) {
              case 'title':
                instance.setHeader(newValue)
                break
              case 'modal':
                updateDisplayMode(instance)
                break
              case 'basic':
                updateBasicMode(instance)
                break
              case 'frameless':
                updateFramelessMode(instance)
                break
              case 'pinned':
                updatePinned(instance)
                break
              case 'closable':
                updateClosable(instance)
                break
              case 'maximizable':
                updateMaximizable(instance)
                break
              case 'pinnable':
                updatePinnable(instance)
                break
              case 'movable':
                updateMovable(instance)
                break
              case 'resizable':
                updateResizable(instance)
                break
              case 'padding':
                if (newValue) {
                  removeClass(instance.elements.root, classes.noPadding)
                } else if (
                  instance.elements.root.className.indexOf(classes.noPadding) <
                  0
                ) {
                  addClass(instance.elements.root, classes.noPadding)
                }
                break
              case 'overflow':
                if (newValue) {
                  removeClass(instance.elements.root, classes.noOverflow)
                } else if (
                  instance.elements.root.className.indexOf(classes.noOverflow) <
                  0
                ) {
                  addClass(instance.elements.root, classes.noOverflow)
                }
                break
              case 'transition':
                updateTransition(instance, newValue, oldValue)
                break
              case 'transitionOff':
                updateTransitionOff(instance)
                break
            }

            // internal on option updated event
            if (typeof instance.hooks.onupdate === 'function') {
              instance.hooks.onupdate.call(instance, option, oldValue, newValue)
            }
          }

          /**
           * Helper: reflects dialogs options updates
           *
           * @param {Object} instance The dilog instance.
           * @param {Object} obj The object to set/get a value on/from.
           * @param {Function} callback The callback function to call if the key was found.
           * @param {String|Object} key A string specifying a propery name or a collection of key value pairs.
           * @param {Object} value Optional, the value associated with the key (in case it was a string).
           * @param {String} option The updated option name.
           *
           * @return	{Object} result object
           *	The result objects has an 'op' property, indicating of this is a SET or GET operation.
           *		GET:
           *		- found: a flag indicating if the key was found or not.
           *		- value: the property value.
           *		SET:
           *		- items: a list of key value pairs of the properties being set.
           *				each contains:
           *					- found: a flag indicating if the key was found or not.
           *					- key: the property key.
           *					- value: the property value.
           */
          function update(instance, obj, callback, key, value) {
            var result = { op: undefined, items: [] }
            if (typeof value === 'undefined' && typeof key === 'string') {
              //get
              result.op = 'get'
              if (obj.hasOwnProperty(key)) {
                result.found = true
                result.value = obj[key]
              } else {
                result.found = false
                result.value = undefined
              }
            } else {
              var old
              //set
              result.op = 'set'
              if (typeof key === 'object') {
                //set multiple
                var args = key
                for (var prop in args) {
                  if (obj.hasOwnProperty(prop)) {
                    if (obj[prop] !== args[prop]) {
                      old = obj[prop]
                      obj[prop] = args[prop]
                      callback.call(instance, prop, old, args[prop])
                    }
                    result.items.push({
                      key: prop,
                      value: args[prop],
                      found: true
                    })
                  } else {
                    result.items.push({
                      key: prop,
                      value: args[prop],
                      found: false
                    })
                  }
                }
              } else if (typeof key === 'string') {
                //set single
                if (obj.hasOwnProperty(key)) {
                  if (obj[key] !== value) {
                    old = obj[key]
                    obj[key] = value
                    callback.call(instance, key, old, value)
                  }
                  result.items.push({ key: key, value: value, found: true })
                } else {
                  result.items.push({ key: key, value: value, found: false })
                }
              } else {
                //invalid params
                throw new Error('args must be a string or object')
              }
            }
            return result
          }

          /**
           * Triggers a close event.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function triggerClose(instance) {
            var found
            triggerCallback(instance, function (button) {
              return (found =
                instance.get('invokeOnCloseOff') !== true &&
                button.invokeOnClose === true)
            })
            //none of the buttons registered as onclose callback
            //close the dialog
            if (!found && instance.isOpen()) {
              instance.close()
            }
          }

          /**
           * Dialogs commands event handler, attached to the dialog commands element.
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function commandsClickHandler(event, instance) {
            var target = event.srcElement || event.target
            switch (target) {
              case instance.elements.commands.pin:
                if (!instance.isPinned()) {
                  pin(instance)
                } else {
                  unpin(instance)
                }
                break
              case instance.elements.commands.maximize:
                if (!instance.isMaximized()) {
                  maximize(instance)
                } else {
                  restore(instance)
                }
                break
              case instance.elements.commands.close:
                triggerClose(instance)
                break
            }
            return false
          }

          /**
           * Helper: pins the modeless dialog.
           *
           * @param {Object} instance	The dialog instance.
           *
           * @return {undefined}
           */
          function pin(instance) {
            //pin the dialog
            instance.set('pinned', true)
          }

          /**
           * Helper: unpins the modeless dialog.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function unpin(instance) {
            //unpin the dialog
            instance.set('pinned', false)
          }

          /**
           * Helper: enlarges the dialog to fill the entire screen.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function maximize(instance) {
            // allow custom `onmaximize` method
            dispatchEvent('onmaximize', instance)
            //maximize the dialog
            addClass(instance.elements.root, classes.maximized)
            if (instance.isOpen()) {
              ensureNoOverflow()
            }
            // allow custom `onmaximized` method
            dispatchEvent('onmaximized', instance)
          }

          /**
           * Helper: returns the dialog to its former size.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function restore(instance) {
            // allow custom `onrestore` method
            dispatchEvent('onrestore', instance)
            //maximize the dialog
            removeClass(instance.elements.root, classes.maximized)
            if (instance.isOpen()) {
              ensureNoOverflow()
            }
            // allow custom `onrestored` method
            dispatchEvent('onrestored', instance)
          }

          /**
           * Show or hide the maximize box.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updatePinnable(instance) {
            if (instance.get('pinnable')) {
              // add class
              addClass(instance.elements.root, classes.pinnable)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.pinnable)
            }
          }

          /**
           * Helper: Fixes the absolutly positioned modal div position.
           *
           * @param {Object} instance The dialog instance.
           *
           * @return {undefined}
           */
          function addAbsPositionFix(instance) {
            var scrollLeft = getScrollLeft()
            instance.elements.modal.style.marginTop = getScrollTop() + 'px'
            instance.elements.modal.style.marginLeft = scrollLeft + 'px'
            instance.elements.modal.style.marginRight = -scrollLeft + 'px'
          }

          /**
           * Helper: Removes the absolutly positioned modal div position fix.
           *
           * @param {Object} instance The dialog instance.
           *
           * @return {undefined}
           */
          function removeAbsPositionFix(instance) {
            var marginTop = parseInt(
              instance.elements.modal.style.marginTop,
              10
            )
            var marginLeft = parseInt(
              instance.elements.modal.style.marginLeft,
              10
            )
            instance.elements.modal.style.marginTop = ''
            instance.elements.modal.style.marginLeft = ''
            instance.elements.modal.style.marginRight = ''

            if (instance.isOpen()) {
              var top = 0,
                left = 0
              if (instance.elements.dialog.style.top !== '') {
                top = parseInt(instance.elements.dialog.style.top, 10)
              }
              instance.elements.dialog.style.top =
                top + (marginTop - getScrollTop()) + 'px'

              if (instance.elements.dialog.style.left !== '') {
                left = parseInt(instance.elements.dialog.style.left, 10)
              }
              instance.elements.dialog.style.left =
                left + (marginLeft - getScrollLeft()) + 'px'
            }
          }
          /**
           * Helper: Adds/Removes the absolutly positioned modal div position fix based on its pinned setting.
           *
           * @param {Object} instance The dialog instance.
           *
           * @return {undefined}
           */
          function updateAbsPositionFix(instance) {
            // if modeless and unpinned add fix
            if (!instance.get('modal') && !instance.get('pinned')) {
              addAbsPositionFix(instance)
            } else {
              removeAbsPositionFix(instance)
            }
          }
          /**
           * Toggles the dialog position lock | modeless only.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to make it modal, false otherwise.
           *
           * @return {undefined}
           */
          function updatePinned(instance) {
            if (instance.get('pinned')) {
              removeClass(instance.elements.root, classes.unpinned)
              if (instance.isOpen()) {
                removeAbsPositionFix(instance)
              }
            } else {
              addClass(instance.elements.root, classes.unpinned)
              if (instance.isOpen() && !instance.isModal()) {
                addAbsPositionFix(instance)
              }
            }
          }

          /**
           * Show or hide the maximize box.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateMaximizable(instance) {
            if (instance.get('maximizable')) {
              // add class
              addClass(instance.elements.root, classes.maximizable)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.maximizable)
            }
          }

          /**
           * Show or hide the close box.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateClosable(instance) {
            if (instance.get('closable')) {
              // add class
              addClass(instance.elements.root, classes.closable)
              bindClosableEvents(instance)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.closable)
              unbindClosableEvents(instance)
            }
          }

          var cancelClick = false, // flag to cancel click event if already handled by end resize event (the mousedown, mousemove, mouseup sequence fires a click event.).
            modalClickHandlerTS = 0 // stores last click timestamp to prevent executing the handler twice on double click.
          /**
           * Helper: closes the modal dialog when clicking the modal
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function modalClickHandler(event, instance) {
            if (
              event.timeStamp - modalClickHandlerTS > 200 &&
              (modalClickHandlerTS = event.timeStamp) &&
              !cancelClick
            ) {
              var target = event.srcElement || event.target
              if (
                instance.get('closableByDimmer') === true &&
                target === instance.elements.modal
              ) {
                triggerClose(instance)
              }
            }
            cancelClick = false
          }

          // stores last call timestamp to prevent triggering the callback twice.
          var callbackTS = 0
          // flag to cancel keyup event if already handled by click event (pressing Enter on a focusted button).
          var cancelKeyup = false
          /**
           * Helper: triggers a button callback
           *
           * @param {Object}		The dilog instance.
           * @param {Function}	Callback to check which button triggered the event.
           *
           * @return {undefined}
           */
          function triggerCallback(instance, check) {
            if (Date.now() - callbackTS > 200 && (callbackTS = Date.now())) {
              for (
                var idx = 0;
                idx < instance.__internal.buttons.length;
                idx += 1
              ) {
                var button = instance.__internal.buttons[idx]
                if (!button.element.disabled && check(button)) {
                  var closeEvent = createCloseEvent(idx, button)
                  if (typeof instance.callback === 'function') {
                    instance.callback.apply(instance, [closeEvent])
                  }
                  //close the dialog only if not canceled.
                  if (closeEvent.cancel === false) {
                    instance.close()
                  }
                  break
                }
              }
            }
          }

          /**
           * Clicks event handler, attached to the dialog footer.
           *
           * @param {Event}		DOM event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function buttonsClickHandler(event, instance) {
            var target = event.srcElement || event.target
            triggerCallback(instance, function (button) {
              // if this button caused the click, cancel keyup event
              return button.element === target && (cancelKeyup = true)
            })
          }

          /**
           * Keyup event handler, attached to the document.body
           *
           * @param {Event}		DOM event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function keyupHandler(event) {
            //hitting enter while button has focus will trigger keyup too.
            //ignore if handled by clickHandler
            if (cancelKeyup) {
              cancelKeyup = false
              return
            }
            var instance = openDialogs[openDialogs.length - 1]
            var keyCode = event.keyCode
            if (
              instance.__internal.buttons.length === 0 &&
              keyCode === keys.ESC &&
              instance.get('closable') === true
            ) {
              triggerClose(instance)
              return false
            } else if (usedKeys.indexOf(keyCode) > -1) {
              triggerCallback(instance, function (button) {
                return button.key === keyCode
              })
              return false
            }
          }
          /**
           * Keydown event handler, attached to the document.body
           *
           * @param {Event}		DOM event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function keydownHandler(event) {
            var instance = openDialogs[openDialogs.length - 1]
            var keyCode = event.keyCode
            if (keyCode === keys.LEFT || keyCode === keys.RIGHT) {
              var buttons = instance.__internal.buttons
              for (var x = 0; x < buttons.length; x += 1) {
                if (document.activeElement === buttons[x].element) {
                  switch (keyCode) {
                    case keys.LEFT:
                      buttons[(x || buttons.length) - 1].element.focus()
                      return
                    case keys.RIGHT:
                      buttons[(x + 1) % buttons.length].element.focus()
                      return
                  }
                }
              }
            } else if (
              keyCode < keys.F12 + 1 &&
              keyCode > keys.F1 - 1 &&
              usedKeys.indexOf(keyCode) > -1
            ) {
              event.preventDefault()
              event.stopPropagation()
              triggerCallback(instance, function (button) {
                return button.key === keyCode
              })
              return false
            }
          }

          /**
           * Sets focus to proper dialog element
           *
           * @param {Object} instance The dilog instance.
           * @param {Node} [resetTarget=undefined] DOM element to reset focus to.
           *
           * @return {undefined}
           */
          function setFocus(instance, resetTarget) {
            // reset target has already been determined.
            if (resetTarget) {
              resetTarget.focus()
            } else {
              // current instance focus settings
              var focus = instance.__internal.focus
              // the focus element.
              var element = focus.element

              switch (typeof focus.element) {
                // a number means a button index
                case 'number':
                  if (instance.__internal.buttons.length > focus.element) {
                    //in basic view, skip focusing the buttons.
                    if (instance.get('basic') === true) {
                      element = instance.elements.reset[0]
                    } else {
                      element =
                        instance.__internal.buttons[focus.element].element
                    }
                  }
                  break
                // a string means querySelector to select from dialog body contents.
                case 'string':
                  element = instance.elements.body.querySelector(focus.element)
                  break
                // a function should return the focus element.
                case 'function':
                  element = focus.element.call(instance)
                  break
              }

              // if no focus element, default to first reset element.
              if (
                instance.get('defaultFocusOff') === true ||
                ((typeof element === 'undefined' || element === null) &&
                  instance.__internal.buttons.length === 0)
              ) {
                element = instance.elements.reset[0]
              }
              // focus
              if (element && element.focus) {
                element.focus()
                // if selectable
                if (focus.select && element.select) {
                  element.select()
                }
              }
            }
          }

          /**
           * Focus event handler, attached to document.body and dialogs own reset links.
           * handles the focus for modal dialogs only.
           *
           * @param {Event} event DOM focus event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function onReset(event, instance) {
            // should work on last modal if triggered from document.body
            if (!instance) {
              for (var x = openDialogs.length - 1; x > -1; x -= 1) {
                if (openDialogs[x].isModal()) {
                  instance = openDialogs[x]
                  break
                }
              }
            }

            if (instance) {
              // if modal
              if (instance.isModal()) {
                // determine reset target to enable forward/backward tab cycle.
                var firstReset = instance.elements.reset[0],
                  lastReset = instance.elements.reset[1],
                  lastFocusedElement = event.relatedTarget,
                  within = instance.elements.root.contains(lastFocusedElement),
                  target = event.srcElement || event.target,
                  resetTarget

                //if the previous focused element element was outside the modal do nthing
                if (
                  /*first show */
                  (target === firstReset && !within) ||
                  /*focus cycle */
                  (target === lastReset && lastFocusedElement === firstReset)
                ) {
                  return
                } else if (target === lastReset || target === document.body) {
                  resetTarget = firstReset
                } else if (
                  target === firstReset &&
                  lastFocusedElement === lastReset
                ) {
                  resetTarget = findTabbable(instance)
                } else if (target === firstReset && within) {
                  resetTarget = findTabbable(instance, true)
                }
                // focus
                setFocus(instance, resetTarget)
              }
            }
          }
          function findTabbable(instance, last) {
            var tabbables = [].slice.call(
              instance.elements.dialog.querySelectorAll(defaults.tabbable)
            )
            if (last) {
              tabbables.reverse()
            }
            for (var x = 0; x < tabbables.length; x += 1) {
              var tabbable = tabbables[x]
              //check if visible
              if (
                !!(
                  tabbable.offsetParent ||
                  tabbable.offsetWidth ||
                  tabbable.offsetHeight ||
                  tabbable.getClientRects().length
                )
              ) {
                return tabbable
              }
            }
          }
          function recycleTab(event) {
            var instance = openDialogs[openDialogs.length - 1]
            if (instance && event.shiftKey && event.keyCode === keys.TAB) {
              instance.elements.reset[1].focus()
            }
          }
          /**
           * Transition in transitionend event handler.
           *
           * @param {Event}		TransitionEnd event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function handleTransitionInEvent(event, instance) {
            // clear the timer
            clearTimeout(instance.__internal.timerIn)

            // once transition is complete, set focus
            setFocus(instance)

            // allow handling key up after transition ended.
            cancelKeyup = false

            // allow custom `onfocus` method
            dispatchEvent('onfocus', instance)

            // unbind the event
            off(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionInHandler
            )

            removeClass(instance.elements.root, classes.animationIn)
          }

          /**
           * Transition out transitionend event handler.
           *
           * @param {Event}		TransitionEnd event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function handleTransitionOutEvent(event, instance) {
            // clear the timer
            clearTimeout(instance.__internal.timerOut)
            // unbind the event
            off(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionOutHandler
            )

            // reset move updates
            resetMove(instance)
            // reset resize updates
            resetResize(instance)

            // restore if maximized
            if (instance.isMaximized() && !instance.get('startMaximized')) {
              restore(instance)
            }

            //destory the instance
            if (typeof instance.__internal.destroy === 'function') {
              instance.__internal.destroy.apply(instance)
            }
          }
          /* Controls moving a dialog around */
          //holde the current moving instance
          var movable = null,
            //holds the current X offset when move starts
            offsetX = 0,
            //holds the current Y offset when move starts
            offsetY = 0,
            xProp = 'pageX',
            yProp = 'pageY',
            bounds = null,
            refreshTop = false,
            moveDelegate = null
          /**
           * Helper: sets the element top/left coordinates
           *
           * @param {Event} event	DOM event object.
           * @param {Node} element The element being moved.
           *
           * @return {undefined}
           */
          function moveElement(event, element) {
            var left = event[xProp] - offsetX,
              top = event[yProp] - offsetY

            if (refreshTop) {
              top -= document.body.scrollTop
            }

            element.style.left = left + 'px'
            element.style.top = top + 'px'
          }
          /**
           * Helper: sets the element top/left coordinates within screen bounds
           *
           * @param {Event} event	DOM event object.
           * @param {Node} element The element being moved.
           *
           * @return {undefined}
           */
          function moveElementBounded(event, element) {
            var left = event[xProp] - offsetX,
              top = event[yProp] - offsetY

            if (refreshTop) {
              top -= document.body.scrollTop
            }

            element.style.left =
              Math.min(bounds.maxLeft, Math.max(bounds.minLeft, left)) + 'px'
            if (refreshTop) {
              element.style.top =
                Math.min(bounds.maxTop, Math.max(bounds.minTop, top)) + 'px'
            } else {
              element.style.top = Math.max(bounds.minTop, top) + 'px'
            }
          }

          /**
           * Triggers the start of a move event, attached to the header element mouse down event.
           * Adds no-selection class to the body, disabling selection while moving.
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {Boolean} false
           */
          function beginMove(event, instance) {
            if (
              resizable === null &&
              !instance.isMaximized() &&
              instance.get('movable')
            ) {
              var eventSrc,
                left = 0,
                top = 0
              if (event.type === 'touchstart') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
                xProp = 'clientX'
                yProp = 'clientY'
              } else if (event.button === 0) {
                eventSrc = event
              }

              if (eventSrc) {
                var element = instance.elements.dialog
                addClass(element, classes.capture)

                if (element.style.left) {
                  left = parseInt(element.style.left, 10)
                }

                if (element.style.top) {
                  top = parseInt(element.style.top, 10)
                }

                offsetX = eventSrc[xProp] - left
                offsetY = eventSrc[yProp] - top

                if (instance.isModal()) {
                  offsetY += instance.elements.modal.scrollTop
                } else if (instance.isPinned()) {
                  offsetY -= document.body.scrollTop
                }

                if (instance.get('moveBounded')) {
                  var current = element,
                    offsetLeft = -left,
                    offsetTop = -top

                  //calc offset
                  do {
                    offsetLeft += current.offsetLeft
                    offsetTop += current.offsetTop
                  } while ((current = current.offsetParent))

                  bounds = {
                    maxLeft: offsetLeft,
                    minLeft: -offsetLeft,
                    maxTop:
                      document.documentElement.clientHeight -
                      element.clientHeight -
                      offsetTop,
                    minTop: -offsetTop
                  }
                  moveDelegate = moveElementBounded
                } else {
                  bounds = null
                  moveDelegate = moveElement
                }

                // allow custom `onmove` method
                dispatchEvent('onmove', instance)

                refreshTop = !instance.isModal() && instance.isPinned()
                movable = instance
                moveDelegate(eventSrc, element)
                addClass(document.body, classes.noSelection)
                return false
              }
            }
          }

          /**
           * The actual move handler,  attached to document.body mousemove event.
           *
           * @param {Event} event	DOM event object.
           *
           * @return {undefined}
           */
          function move(event) {
            if (movable) {
              var eventSrc
              if (event.type === 'touchmove') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
              } else if (event.button === 0) {
                eventSrc = event
              }
              if (eventSrc) {
                moveDelegate(eventSrc, movable.elements.dialog)
              }
            }
          }

          /**
           * Triggers the end of a move event,  attached to document.body mouseup event.
           * Removes no-selection class from document.body, allowing selection.
           *
           * @return {undefined}
           */
          function endMove() {
            if (movable) {
              var instance = movable
              movable = bounds = null
              removeClass(document.body, classes.noSelection)
              removeClass(instance.elements.dialog, classes.capture)
              // allow custom `onmoved` method
              dispatchEvent('onmoved', instance)
            }
          }

          /**
           * Resets any changes made by moving the element to its original state,
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function resetMove(instance) {
            movable = null
            var element = instance.elements.dialog
            element.style.left = element.style.top = ''
          }

          /**
           * Updates the dialog move behavior.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateMovable(instance) {
            if (instance.get('movable')) {
              // add class
              addClass(instance.elements.root, classes.movable)
              if (instance.isOpen()) {
                bindMovableEvents(instance)
              }
            } else {
              //reset
              resetMove(instance)
              // remove class
              removeClass(instance.elements.root, classes.movable)
              if (instance.isOpen()) {
                unbindMovableEvents(instance)
              }
            }
          }

          /* Controls moving a dialog around */
          //holde the current instance being resized
          var resizable = null,
            //holds the staring left offset when resize starts.
            startingLeft = Number.Nan,
            //holds the staring width when resize starts.
            startingWidth = 0,
            //holds the initial width when resized for the first time.
            minWidth = 0,
            //holds the offset of the resize handle.
            handleOffset = 0
          /**
           * Helper: sets the element width/height and updates left coordinate if neccessary.
           *
           * @param {Event} event	DOM mousemove event object.
           * @param {Node} element The element being moved.
           * @param {Boolean} pinned A flag indicating if the element being resized is pinned to the screen.
           *
           * @return {undefined}
           */
          function resizeElement(event, element, pageRelative) {
            //calculate offsets from 0,0
            var current = element
            var offsetLeft = 0
            var offsetTop = 0
            do {
              offsetLeft += current.offsetLeft
              offsetTop += current.offsetTop
            } while ((current = current.offsetParent))

            // determine X,Y coordinates.
            var X, Y
            if (pageRelative === true) {
              X = event.pageX
              Y = event.pageY
            } else {
              X = event.clientX
              Y = event.clientY
            }
            // rtl handling
            var isRTL = isRightToLeft()
            if (isRTL) {
              // reverse X
              X = document.body.offsetWidth - X
              // if has a starting left, calculate offsetRight
              if (!isNaN(startingLeft)) {
                offsetLeft =
                  document.body.offsetWidth - offsetLeft - element.offsetWidth
              }
            }

            // set width/height
            element.style.height = Y - offsetTop + handleOffset + 'px'
            element.style.width = X - offsetLeft + handleOffset + 'px'

            // if the element being resized has a starting left, maintain it.
            // the dialog is centered, divide by half the offset to maintain the margins.
            if (!isNaN(startingLeft)) {
              var diff = Math.abs(element.offsetWidth - startingWidth) * 0.5
              if (isRTL) {
                //negate the diff, why?
                //when growing it should decrease left
                //when shrinking it should increase left
                diff *= -1
              }
              if (element.offsetWidth > startingWidth) {
                //growing
                element.style.left = startingLeft + diff + 'px'
              } else if (element.offsetWidth >= minWidth) {
                //shrinking
                element.style.left = startingLeft - diff + 'px'
              }
            }
          }

          /**
           * Triggers the start of a resize event, attached to the resize handle element mouse down event.
           * Adds no-selection class to the body, disabling selection while moving.
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {Boolean} false
           */
          function beginResize(event, instance) {
            if (!instance.isMaximized()) {
              var eventSrc
              if (event.type === 'touchstart') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
              } else if (event.button === 0) {
                eventSrc = event
              }
              if (eventSrc) {
                // allow custom `onresize` method
                dispatchEvent('onresize', instance)

                resizable = instance
                handleOffset = instance.elements.resizeHandle.offsetHeight / 2
                var element = instance.elements.dialog
                addClass(element, classes.capture)
                startingLeft = parseInt(element.style.left, 10)
                element.style.height = element.offsetHeight + 'px'
                element.style.minHeight =
                  instance.elements.header.offsetHeight +
                  instance.elements.footer.offsetHeight +
                  'px'
                element.style.width =
                  (startingWidth = element.offsetWidth) + 'px'

                if (element.style.maxWidth !== 'none') {
                  element.style.minWidth =
                    (minWidth = element.offsetWidth) + 'px'
                }
                element.style.maxWidth = 'none'
                addClass(document.body, classes.noSelection)
                return false
              }
            }
          }

          /**
           * The actual resize handler,  attached to document.body mousemove event.
           *
           * @param {Event} event	DOM event object.
           *
           * @return {undefined}
           */
          function resize(event) {
            if (resizable) {
              var eventSrc
              if (event.type === 'touchmove') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
              } else if (event.button === 0) {
                eventSrc = event
              }
              if (eventSrc) {
                resizeElement(
                  eventSrc,
                  resizable.elements.dialog,
                  !resizable.get('modal') && !resizable.get('pinned')
                )
              }
            }
          }

          /**
           * Triggers the end of a resize event,  attached to document.body mouseup event.
           * Removes no-selection class from document.body, allowing selection.
           *
           * @return {undefined}
           */
          function endResize() {
            if (resizable) {
              var instance = resizable
              resizable = null
              removeClass(document.body, classes.noSelection)
              removeClass(instance.elements.dialog, classes.capture)
              cancelClick = true
              // allow custom `onresized` method
              dispatchEvent('onresized', instance)
            }
          }

          /**
           * Resets any changes made by resizing the element to its original state.
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function resetResize(instance) {
            resizable = null
            var element = instance.elements.dialog
            if (element.style.maxWidth === 'none') {
              //clear inline styles.
              element.style.maxWidth =
                element.style.minWidth =
                element.style.width =
                element.style.height =
                element.style.minHeight =
                element.style.left =
                  ''
              //reset variables.
              startingLeft = Number.Nan
              startingWidth = minWidth = handleOffset = 0
            }
          }

          /**
           * Updates the dialog move behavior.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateResizable(instance) {
            if (instance.get('resizable')) {
              // add class
              addClass(instance.elements.root, classes.resizable)
              if (instance.isOpen()) {
                bindResizableEvents(instance)
              }
            } else {
              //reset
              resetResize(instance)
              // remove class
              removeClass(instance.elements.root, classes.resizable)
              if (instance.isOpen()) {
                unbindResizableEvents(instance)
              }
            }
          }

          /**
           * Reset move/resize on window resize.
           *
           * @param {Event} event	window resize event object.
           *
           * @return {undefined}
           */
          function windowResize(/*event*/) {
            for (var x = 0; x < openDialogs.length; x += 1) {
              var instance = openDialogs[x]
              if (instance.get('autoReset')) {
                resetMove(instance)
                resetResize(instance)
              }
            }
          }
          /**
           * Bind dialogs events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindEvents(instance) {
            // if first dialog, hook global handlers
            if (openDialogs.length === 1) {
              //global
              on(window, 'resize', windowResize)
              on(document.body, 'keyup', keyupHandler)
              on(document.body, 'keydown', keydownHandler)
              on(document.body, 'focus', onReset)

              //move
              on(document.documentElement, 'mousemove', move)
              on(document.documentElement, 'touchmove', move, false, false)
              on(document.documentElement, 'mouseup', endMove)
              on(document.documentElement, 'touchend', endMove)
              //resize
              on(document.documentElement, 'mousemove', resize)
              on(document.documentElement, 'touchmove', resize, false, false)
              on(document.documentElement, 'mouseup', endResize)
              on(document.documentElement, 'touchend', endResize)
            }

            // common events
            on(
              instance.elements.commands.container,
              'click',
              instance.__internal.commandsClickHandler
            )
            on(
              instance.elements.footer,
              'click',
              instance.__internal.buttonsClickHandler
            )
            on(
              instance.elements.reset[0],
              'focusin',
              instance.__internal.resetHandler
            )
            on(instance.elements.reset[0], 'keydown', recycleTab)
            on(
              instance.elements.reset[1],
              'focusin',
              instance.__internal.resetHandler
            )

            //prevent handling key up when dialog is being opened by a key stroke.
            cancelKeyup = true
            // hook in transition handler
            on(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionInHandler
            )

            // modelss only events
            if (!instance.get('modal')) {
              bindModelessEvents(instance)
            }

            // resizable
            if (instance.get('resizable')) {
              bindResizableEvents(instance)
            }

            // movable
            if (instance.get('movable')) {
              bindMovableEvents(instance)
            }
          }

          /**
           * Unbind dialogs events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindEvents(instance) {
            // if last dialog, remove global handlers
            if (openDialogs.length === 1) {
              //global
              off(window, 'resize', windowResize)
              off(document.body, 'keyup', keyupHandler)
              off(document.body, 'keydown', keydownHandler)
              off(document.body, 'focus', onReset)
              //move
              off(document.documentElement, 'mousemove', move)
              off(document.documentElement, 'mouseup', endMove)
              //resize
              off(document.documentElement, 'mousemove', resize)
              off(document.documentElement, 'mouseup', endResize)
            }

            // common events
            off(
              instance.elements.commands.container,
              'click',
              instance.__internal.commandsClickHandler
            )
            off(
              instance.elements.footer,
              'click',
              instance.__internal.buttonsClickHandler
            )
            off(
              instance.elements.reset[0],
              'focusin',
              instance.__internal.resetHandler
            )
            off(instance.elements.reset[0], 'keydown', recycleTab)
            off(
              instance.elements.reset[1],
              'focusin',
              instance.__internal.resetHandler
            )

            // hook out transition handler
            on(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionOutHandler
            )

            // modelss only events
            if (!instance.get('modal')) {
              unbindModelessEvents(instance)
            }

            // movable
            if (instance.get('movable')) {
              unbindMovableEvents(instance)
            }

            // resizable
            if (instance.get('resizable')) {
              unbindResizableEvents(instance)
            }
          }

          /**
           * Bind modeless specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindModelessEvents(instance) {
            on(
              instance.elements.dialog,
              'focus',
              instance.__internal.bringToFrontHandler,
              true
            )
          }

          /**
           * Unbind modeless specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindModelessEvents(instance) {
            off(
              instance.elements.dialog,
              'focus',
              instance.__internal.bringToFrontHandler,
              true
            )
          }

          /**
           * Bind movable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindMovableEvents(instance) {
            on(
              instance.elements.header,
              'mousedown',
              instance.__internal.beginMoveHandler
            )
            on(
              instance.elements.header,
              'touchstart',
              instance.__internal.beginMoveHandler,
              false,
              false
            )
          }

          /**
           * Unbind movable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindMovableEvents(instance) {
            off(
              instance.elements.header,
              'mousedown',
              instance.__internal.beginMoveHandler
            )
            off(
              instance.elements.header,
              'touchstart',
              instance.__internal.beginMoveHandler,
              false,
              false
            )
          }

          /**
           * Bind resizable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindResizableEvents(instance) {
            on(
              instance.elements.resizeHandle,
              'mousedown',
              instance.__internal.beginResizeHandler
            )
            on(
              instance.elements.resizeHandle,
              'touchstart',
              instance.__internal.beginResizeHandler,
              false,
              false
            )
          }

          /**
           * Unbind resizable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindResizableEvents(instance) {
            off(
              instance.elements.resizeHandle,
              'mousedown',
              instance.__internal.beginResizeHandler
            )
            off(
              instance.elements.resizeHandle,
              'touchstart',
              instance.__internal.beginResizeHandler,
              false,
              false
            )
          }

          /**
           * Bind closable events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindClosableEvents(instance) {
            on(
              instance.elements.modal,
              'click',
              instance.__internal.modalClickHandler
            )
          }

          /**
           * Unbind closable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindClosableEvents(instance) {
            off(
              instance.elements.modal,
              'click',
              instance.__internal.modalClickHandler
            )
          }
          // dialog API
          return {
            __init: initialize,
            /**
             * Check if dialog is currently open
             *
             * @return {Boolean}
             */
            isOpen: function () {
              return this.__internal.isOpen
            },
            isModal: function () {
              return this.elements.root.className.indexOf(classes.modeless) < 0
            },
            isMaximized: function () {
              return (
                this.elements.root.className.indexOf(classes.maximized) > -1
              )
            },
            isPinned: function () {
              return this.elements.root.className.indexOf(classes.unpinned) < 0
            },
            maximize: function () {
              if (!this.isMaximized()) {
                maximize(this)
              }
              return this
            },
            restore: function () {
              if (this.isMaximized()) {
                restore(this)
              }
              return this
            },
            pin: function () {
              if (!this.isPinned()) {
                pin(this)
              }
              return this
            },
            unpin: function () {
              if (this.isPinned()) {
                unpin(this)
              }
              return this
            },
            bringToFront: function () {
              bringToFront(null, this)
              return this
            },
            /**
             * Move the dialog to a specific x/y coordinates
             *
             * @param {Number} x    The new dialog x coordinate in pixels.
             * @param {Number} y    The new dialog y coordinate in pixels.
             *
             * @return {Object} The dialog instance.
             */
            moveTo: function (x, y) {
              if (!isNaN(x) && !isNaN(y)) {
                // allow custom `onmove` method
                dispatchEvent('onmove', this)

                var element = this.elements.dialog,
                  current = element,
                  offsetLeft = 0,
                  offsetTop = 0

                //subtract existing left,top
                if (element.style.left) {
                  offsetLeft -= parseInt(element.style.left, 10)
                }
                if (element.style.top) {
                  offsetTop -= parseInt(element.style.top, 10)
                }
                //calc offset
                do {
                  offsetLeft += current.offsetLeft
                  offsetTop += current.offsetTop
                } while ((current = current.offsetParent))

                //calc left, top
                var left = x - offsetLeft
                var top = y - offsetTop

                //// rtl handling
                if (isRightToLeft()) {
                  left *= -1
                }

                element.style.left = left + 'px'
                element.style.top = top + 'px'

                // allow custom `onmoved` method
                dispatchEvent('onmoved', this)
              }
              return this
            },
            /**
             * Resize the dialog to a specific width/height (the dialog must be 'resizable').
             * The dialog can be resized to:
             *  A minimum width equal to the initial display width
             *  A minimum height equal to the sum of header/footer heights.
             *
             *
             * @param {Number or String} width    The new dialog width in pixels or in percent.
             * @param {Number or String} height   The new dialog height in pixels or in percent.
             *
             * @return {Object} The dialog instance.
             */
            resizeTo: function (width, height) {
              var w = parseFloat(width),
                h = parseFloat(height),
                regex = /(\d*\.\d+|\d+)%/
              if (!isNaN(w) && !isNaN(h) && this.get('resizable') === true) {
                // allow custom `onresize` method
                dispatchEvent('onresize', this)

                if (('' + width).match(regex)) {
                  w = (w / 100) * document.documentElement.clientWidth
                }

                if (('' + height).match(regex)) {
                  h = (h / 100) * document.documentElement.clientHeight
                }

                var element = this.elements.dialog
                if (element.style.maxWidth !== 'none') {
                  element.style.minWidth =
                    (minWidth = element.offsetWidth) + 'px'
                }
                element.style.maxWidth = 'none'
                element.style.minHeight =
                  this.elements.header.offsetHeight +
                  this.elements.footer.offsetHeight +
                  'px'
                element.style.width = w + 'px'
                element.style.height = h + 'px'

                // allow custom `onresized` method
                dispatchEvent('onresized', this)
              }
              return this
            },
            /**
             * Gets or Sets dialog settings/options
             *
             * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
             * @param {Object} value Optional, the value associated with the key (in case it was a string).
             *
             * @return {undefined}
             */
            setting: function (key, value) {
              var self = this
              var result = update(
                this,
                this.__internal.options,
                function (k, o, n) {
                  optionUpdated(self, k, o, n)
                },
                key,
                value
              )
              if (result.op === 'get') {
                if (result.found) {
                  return result.value
                } else if (typeof this.settings !== 'undefined') {
                  return update(
                    this,
                    this.settings,
                    this.settingUpdated || function () {},
                    key,
                    value
                  ).value
                } else {
                  return undefined
                }
              } else if (result.op === 'set') {
                if (result.items.length > 0) {
                  var callback = this.settingUpdated || function () {}
                  for (var x = 0; x < result.items.length; x += 1) {
                    var item = result.items[x]
                    if (!item.found && typeof this.settings !== 'undefined') {
                      update(
                        this,
                        this.settings,
                        callback,
                        item.key,
                        item.value
                      )
                    }
                  }
                }
                return this
              }
            },
            /**
             * [Alias] Sets dialog settings/options
             */
            set: function (key, value) {
              this.setting(key, value)
              return this
            },
            /**
             * [Alias] Gets dialog settings/options
             */
            get: function (key) {
              return this.setting(key)
            },
            /**
             * Sets dialog header
             * @content {string or element}
             *
             * @return {undefined}
             */
            setHeader: function (content) {
              if (typeof content === 'string') {
                clearContents(this.elements.header)
                this.elements.header.innerHTML = content
              } else if (
                content instanceof window.HTMLElement &&
                this.elements.header.firstChild !== content
              ) {
                clearContents(this.elements.header)
                this.elements.header.appendChild(content)
              }
              return this
            },
            /**
             * Sets dialog contents
             * @content {string or element}
             *
             * @return {undefined}
             */
            setContent: function (content) {
              if (typeof content === 'string') {
                clearContents(this.elements.content)
                this.elements.content.innerHTML = content
              } else if (
                content instanceof window.HTMLElement &&
                this.elements.content.firstChild !== content
              ) {
                clearContents(this.elements.content)
                this.elements.content.appendChild(content)
              }
              return this
            },
            /**
             * Show the dialog as modal
             *
             * @return {Object} the dialog instance.
             */
            showModal: function (className) {
              return this.show(true, className)
            },
            /**
             * Show the dialog
             *
             * @return {Object} the dialog instance.
             */
            show: function (modal, className) {
              // ensure initialization
              initialize(this)

              if (!this.__internal.isOpen) {
                // add to open dialogs
                this.__internal.isOpen = true
                openDialogs.push(this)

                // save last focused element
                if (alertify.defaults.maintainFocus) {
                  this.__internal.activeElement = document.activeElement
                }

                // set tabindex attribute on body element this allows script to give it focusable
                if (!document.body.hasAttribute('tabindex')) {
                  document.body.setAttribute('tabindex', (tabindex = '0'))
                }

                //allow custom dom manipulation updates before showing the dialog.
                if (typeof this.prepare === 'function') {
                  this.prepare()
                }

                bindEvents(this)

                if (modal !== undefined) {
                  this.set('modal', modal)
                }

                //save scroll to prevent document jump
                saveScrollPosition()

                ensureNoOverflow()

                // allow custom dialog class on show
                if (typeof className === 'string' && className !== '') {
                  this.__internal.className = className
                  addClass(this.elements.root, className)
                }

                // maximize if start maximized
                if (this.get('startMaximized')) {
                  this.maximize()
                } else if (this.isMaximized()) {
                  restore(this)
                }

                updateAbsPositionFix(this)
                this.elements.root.removeAttribute('style')
                removeClass(this.elements.root, classes.animationOut)
                addClass(this.elements.root, classes.animationIn)

                // set 1s fallback in case transition event doesn't fire
                clearTimeout(this.__internal.timerIn)
                this.__internal.timerIn = setTimeout(
                  this.__internal.transitionInHandler,
                  transition.supported ? 1000 : 100
                )

                if (isSafari) {
                  // force desktop safari reflow
                  var root = this.elements.root
                  root.style.display = 'none'
                  setTimeout(function () {
                    root.style.display = 'block'
                  }, 0)
                }

                //reflow
                reflow = this.elements.root.offsetWidth

                // show dialog
                removeClass(this.elements.root, classes.hidden)

                //restore scroll to prevent document jump
                restoreScrollPosition()

                // internal on show event
                if (typeof this.hooks.onshow === 'function') {
                  this.hooks.onshow.call(this)
                }

                // allow custom `onshow` method
                dispatchEvent('onshow', this)
              } else {
                // reset move updates
                resetMove(this)
                // reset resize updates
                resetResize(this)
                // shake the dialog to indicate its already open
                addClass(this.elements.dialog, classes.shake)
                var self = this
                setTimeout(function () {
                  removeClass(self.elements.dialog, classes.shake)
                }, 200)
              }
              return this
            },
            /**
             * Close the dialog
             *
             * @return {Object} The dialog instance
             */
            close: function () {
              if (this.__internal.isOpen) {
                // custom `onclosing` event
                if (dispatchEvent('onclosing', this) !== false) {
                  unbindEvents(this)

                  removeClass(this.elements.root, classes.animationIn)
                  addClass(this.elements.root, classes.animationOut)

                  // set 1s fallback in case transition event doesn't fire
                  clearTimeout(this.__internal.timerOut)
                  this.__internal.timerOut = setTimeout(
                    this.__internal.transitionOutHandler,
                    transition.supported ? 1000 : 100
                  )
                  // hide dialog
                  addClass(this.elements.root, classes.hidden)
                  //reflow
                  reflow = this.elements.modal.offsetWidth

                  // return focus to the last active element
                  if (
                    alertify.defaults.maintainFocus &&
                    this.__internal.activeElement
                  ) {
                    this.__internal.activeElement.focus()
                    this.__internal.activeElement = null
                  }

                  // remove custom dialog class on hide
                  if (
                    typeof this.__internal.className !== 'undefined' &&
                    this.__internal.className !== ''
                  ) {
                    removeClass(this.elements.root, this.__internal.className)
                  }

                  // internal on close event
                  if (typeof this.hooks.onclose === 'function') {
                    this.hooks.onclose.call(this)
                  }

                  // allow custom `onclose` method
                  dispatchEvent('onclose', this)

                  //remove from open dialogs
                  openDialogs.splice(openDialogs.indexOf(this), 1)
                  this.__internal.isOpen = false

                  ensureNoOverflow()
                }
              }
              // last dialog and tab index was set by us, remove it.
              if (!openDialogs.length && tabindex === '0') {
                document.body.removeAttribute('tabindex')
              }
              return this
            },
            /**
             * Close all open dialogs except this.
             *
             * @return {undefined}
             */
            closeOthers: function () {
              alertify.closeAll(this)
              return this
            },
            /**
             * Destroys this dialog instance
             *
             * @return {undefined}
             */
            destroy: function () {
              if (this.__internal) {
                if (this.__internal.isOpen) {
                  //mark dialog for destruction, this will be called on tranistionOut event.
                  this.__internal.destroy = function () {
                    destruct(this, initialize)
                  }
                  //close the dialog to unbind all events.
                  this.close()
                } else if (!this.__internal.destroy) {
                  destruct(this, initialize)
                }
              }
              return this
            }
          }
        })()
        var notifier = (function () {
          var reflow,
            element,
            openInstances = [],
            classes = defaults.notifier.classes,
            baseClass = classes.base
          /**
           * Helper: initializes the notifier instance
           *
           */
          function initialize(instance) {
            if (!instance.__internal) {
              instance.__internal = {
                position: alertify.defaults.notifier.position,
                delay: alertify.defaults.notifier.delay
              }

              element = document.createElement('DIV')
              var transitionOff =
                'transitionOff' in defaults.notifier
                  ? defaults.notifier.transitionOff
                  : defaults.transitionOff
              if (transitionOff) {
                baseClass = classes.base + ' ajs-no-transition'
              }
              updatePosition(instance)
            }

            //add to DOM tree.
            if (element.parentNode !== document.body) {
              document.body.appendChild(element)
            }
          }

          function pushInstance(instance) {
            instance.__internal.pushed = true
            openInstances.push(instance)
          }
          function popInstance(instance) {
            openInstances.splice(openInstances.indexOf(instance), 1)
            instance.__internal.pushed = false
          }
          /**
           * Helper: update the notifier instance position
           *
           */
          function updatePosition(instance) {
            element.className = baseClass
            switch (instance.__internal.position) {
              case 'top-right':
                addClass(element, classes.top + ' ' + classes.right)
                break
              case 'top-left':
                addClass(element, classes.top + ' ' + classes.left)
                break
              case 'top-center':
                addClass(element, classes.top + ' ' + classes.center)
                break
              case 'bottom-left':
                addClass(element, classes.bottom + ' ' + classes.left)
                break
              case 'bottom-center':
                addClass(element, classes.bottom + ' ' + classes.center)
                break

              default:
              case 'bottom-right':
                addClass(element, classes.bottom + ' ' + classes.right)
                break
            }
          }

          /**
           * creates a new notification message
           *
           * @param  {DOMElement} message	The notifier message element
           * @param  {Number} wait   Time (in ms) to wait before the message is dismissed, a value of 0 means keep open till clicked.
           * @param  {Function} callback A callback function to be invoked when the message is dismissed.
           *
           * @return {undefined}
           */
          function create(div, callback) {
            function clickDelegate(event, instance) {
              if (
                !instance.__internal.closeButton ||
                event.target.getAttribute('data-close') === 'true'
              ) {
                instance.dismiss(true)
              }
            }

            function transitionDone(event, instance) {
              // unbind event
              off(instance.element, transition.type, transitionDone)
              // remove the message
              element.removeChild(instance.element)
            }

            function initialize(instance) {
              if (!instance.__internal) {
                instance.__internal = {
                  pushed: false,
                  delay: undefined,
                  timer: undefined,
                  clickHandler: undefined,
                  transitionEndHandler: undefined,
                  transitionTimeout: undefined
                }
                instance.__internal.clickHandler = delegate(
                  instance,
                  clickDelegate
                )
                instance.__internal.transitionEndHandler = delegate(
                  instance,
                  transitionDone
                )
              }
              return instance
            }
            function clearTimers(instance) {
              clearTimeout(instance.__internal.timer)
              clearTimeout(instance.__internal.transitionTimeout)
            }
            return initialize({
              /* notification DOM element*/
              element: div,
              /*
               * Pushes a notification message
               * @param {string or DOMElement} content The notification message content
               * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
               *
               */
              push: function (_content, _wait) {
                if (!this.__internal.pushed) {
                  pushInstance(this)
                  clearTimers(this)

                  var content, wait
                  switch (arguments.length) {
                    case 0:
                      wait = this.__internal.delay
                      break
                    case 1:
                      if (typeof _content === 'number') {
                        wait = _content
                      } else {
                        content = _content
                        wait = this.__internal.delay
                      }
                      break
                    case 2:
                      content = _content
                      wait = _wait
                      break
                  }
                  this.__internal.closeButton =
                    alertify.defaults.notifier.closeButton
                  // set contents
                  if (typeof content !== 'undefined') {
                    this.setContent(content)
                  }
                  // append or insert
                  if (notifier.__internal.position.indexOf('top') < 0) {
                    element.appendChild(this.element)
                  } else {
                    element.insertBefore(this.element, element.firstChild)
                  }
                  reflow = this.element.offsetWidth
                  addClass(this.element, classes.visible)
                  // attach click event
                  on(this.element, 'click', this.__internal.clickHandler)
                  return this.delay(wait)
                }
                return this
              },
              /*
               * {Function} callback function to be invoked before dismissing the notification message.
               * Remarks: A return value === 'false' will cancel the dismissal
               *
               */
              ondismiss: function () {},
              /*
               * {Function} callback function to be invoked when the message is dismissed.
               *
               */
              callback: callback,
              /*
               * Dismisses the notification message
               * @param {Boolean} clicked A flag indicating if the dismissal was caused by a click.
               *
               */
              dismiss: function (clicked) {
                if (this.__internal.pushed) {
                  clearTimers(this)
                  if (
                    !(
                      typeof this.ondismiss === 'function' &&
                      this.ondismiss.call(this) === false
                    )
                  ) {
                    //detach click event
                    off(this.element, 'click', this.__internal.clickHandler)
                    // ensure element exists
                    if (
                      typeof this.element !== 'undefined' &&
                      this.element.parentNode === element
                    ) {
                      //transition end or fallback
                      this.__internal.transitionTimeout = setTimeout(
                        this.__internal.transitionEndHandler,
                        transition.supported ? 1000 : 100
                      )
                      removeClass(this.element, classes.visible)

                      // custom callback on dismiss
                      if (typeof this.callback === 'function') {
                        this.callback.call(this, clicked)
                      }
                    }
                    popInstance(this)
                  }
                }
                return this
              },
              /*
               * Delays the notification message dismissal
               * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
               *
               */
              delay: function (wait) {
                clearTimers(this)
                this.__internal.delay =
                  typeof wait !== 'undefined' && !isNaN(+wait)
                    ? +wait
                    : notifier.__internal.delay
                if (this.__internal.delay > 0) {
                  var self = this
                  this.__internal.timer = setTimeout(function () {
                    self.dismiss()
                  }, this.__internal.delay * 1000)
                }
                return this
              },
              /*
               * Sets the notification message contents
               * @param {string or DOMElement} content The notification message content
               *
               */
              setContent: function (content) {
                if (typeof content === 'string') {
                  clearContents(this.element)
                  this.element.innerHTML = content
                } else if (
                  content instanceof window.HTMLElement &&
                  this.element.firstChild !== content
                ) {
                  clearContents(this.element)
                  this.element.appendChild(content)
                }
                if (this.__internal.closeButton) {
                  var close = document.createElement('span')
                  addClass(close, classes.close)
                  close.setAttribute('data-close', true)
                  this.element.appendChild(close)
                }
                return this
              },
              /*
               * Dismisses all open notifications except this.
               *
               */
              dismissOthers: function () {
                notifier.dismissAll(this)
                return this
              }
            })
          }

          //notifier api
          return {
            /**
             * Gets or Sets notifier settings.
             *
             * @param {string} key The setting name
             * @param {Variant} value The setting value.
             *
             * @return {Object}	if the called as a setter, return the notifier instance.
             */
            setting: function (key, value) {
              //ensure init
              initialize(this)

              if (typeof value === 'undefined') {
                //get
                return this.__internal[key]
              } else {
                //set
                switch (key) {
                  case 'position':
                    this.__internal.position = value
                    updatePosition(this)
                    break
                  case 'delay':
                    this.__internal.delay = value
                    break
                }
              }
              return this
            },
            /**
             * [Alias] Sets dialog settings/options
             */
            set: function (key, value) {
              this.setting(key, value)
              return this
            },
            /**
             * [Alias] Gets dialog settings/options
             */
            get: function (key) {
              return this.setting(key)
            },
            /**
             * Creates a new notification message
             *
             * @param {string} type The type of notification message (simply a CSS class name 'ajs-{type}' to be added).
             * @param {Function} callback  A callback function to be invoked when the message is dismissed.
             *
             * @return {undefined}
             */
            create: function (type, callback) {
              //ensure notifier init
              initialize(this)
              //create new notification message
              var div = document.createElement('div')
              div.className =
                classes.message +
                (typeof type === 'string' && type !== ''
                  ? ' ' + classes.prefix + type
                  : '')
              return create(div, callback)
            },
            /**
             * Dismisses all open notifications.
             *
             * @param {Object} excpet [optional] The notification object to exclude from dismissal.
             *
             */
            dismissAll: function (except) {
              var clone = openInstances.slice(0)
              for (var x = 0; x < clone.length; x += 1) {
                var instance = clone[x]
                if (except === undefined || except !== instance) {
                  instance.dismiss()
                }
              }
            }
          }
        })()

        /**
         * Alertify public API
         * This contains everything that is exposed through the alertify object.
         *
         * @return {Object}
         */
        function Alertify() {
          // holds a references of created dialogs
          var dialogs = {}

          /**
           * Extends a given prototype by merging properties from base into sub.
           *
           * @sub {Object} sub The prototype being overwritten.
           * @base {Object} base The prototype being written.
           *
           * @return {Object} The extended prototype.
           */
          function extend(sub, base) {
            // copy dialog pototype over definition.
            for (var prop in base) {
              if (base.hasOwnProperty(prop)) {
                sub[prop] = base[prop]
              }
            }
            return sub
          }

          /**
           * Helper: returns a dialog instance from saved dialogs.
           * and initializes the dialog if its not already initialized.
           *
           * @name {String} name The dialog name.
           *
           * @return {Object} The dialog instance.
           */
          function get_dialog(name) {
            var dialog = dialogs[name].dialog
            //initialize the dialog if its not already initialized.
            if (dialog && typeof dialog.__init === 'function') {
              dialog.__init(dialog)
            }
            return dialog
          }

          /**
           * Helper:  registers a new dialog definition.
           *
           * @name {String} name The dialog name.
           * @Factory {Function} Factory a function resposible for creating dialog prototype.
           * @transient {Boolean} transient True to create a new dialog instance each time the dialog is invoked, false otherwise.
           * @base {String} base the name of another dialog to inherit from.
           *
           * @return {Object} The dialog definition.
           */
          function register(name, Factory, transient, base) {
            var definition = {
              dialog: null,
              factory: Factory
            }

            //if this is based on an existing dialog, create a new definition
            //by applying the new protoype over the existing one.
            if (base !== undefined) {
              definition.factory = function () {
                return extend(new dialogs[base].factory(), new Factory())
              }
            }

            if (!transient) {
              //create a new definition based on dialog
              definition.dialog = extend(new definition.factory(), dialog)
            }
            return (dialogs[name] = definition)
          }

          return {
            /**
             * Alertify defaults
             *
             * @type {Object}
             */
            defaults: defaults,
            /**
             * Dialogs factory
             *
             * @param {string}      Dialog name.
             * @param {Function}    A Dialog factory function.
             * @param {Boolean}     Indicates whether to create a singleton or transient dialog.
             * @param {String}      The name of the base type to inherit from.
             */
            dialog: function (name, Factory, transient, base) {
              // get request, create a new instance and return it.
              if (typeof Factory !== 'function') {
                return get_dialog(name)
              }

              if (this.hasOwnProperty(name)) {
                throw new Error('alertify.dialog: name already exists')
              }

              // register the dialog
              var definition = register(name, Factory, transient, base)

              if (transient) {
                // make it public
                this[name] = function () {
                  //if passed with no params, consider it a get request
                  if (arguments.length === 0) {
                    return definition.dialog
                  } else {
                    var instance = extend(new definition.factory(), dialog)
                    //ensure init
                    if (instance && typeof instance.__init === 'function') {
                      instance.__init(instance)
                    }
                    instance['main'].apply(instance, arguments)
                    return instance['show'].apply(instance)
                  }
                }
              } else {
                // make it public
                this[name] = function () {
                  //ensure init
                  if (
                    definition.dialog &&
                    typeof definition.dialog.__init === 'function'
                  ) {
                    definition.dialog.__init(definition.dialog)
                  }
                  //if passed with no params, consider it a get request
                  if (arguments.length === 0) {
                    return definition.dialog
                  } else {
                    var dialog = definition.dialog
                    dialog['main'].apply(definition.dialog, arguments)
                    return dialog['show'].apply(definition.dialog)
                  }
                }
              }
            },
            /**
             * Close all open dialogs.
             *
             * @param {Object} excpet [optional] The dialog object to exclude from closing.
             *
             * @return {undefined}
             */
            closeAll: function (except) {
              var clone = openDialogs.slice(0)
              for (var x = 0; x < clone.length; x += 1) {
                var instance = clone[x]
                if (except === undefined || except !== instance) {
                  instance.close()
                }
              }
            },
            /**
             * Gets or Sets dialog settings/options. if the dialog is transient, this call does nothing.
             *
             * @param {string} name The dialog name.
             * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
             * @param {Variant} value Optional, the value associated with the key (in case it was a string).
             *
             * @return {undefined}
             */
            setting: function (name, key, value) {
              if (name === 'notifier') {
                return notifier.setting(key, value)
              }

              var dialog = get_dialog(name)
              if (dialog) {
                return dialog.setting(key, value)
              }
            },
            /**
             * [Alias] Sets dialog settings/options
             */
            set: function (name, key, value) {
              return this.setting(name, key, value)
            },
            /**
             * [Alias] Gets dialog settings/options
             */
            get: function (name, key) {
              return this.setting(name, key)
            },
            /**
             * Creates a new notification message.
             * If a type is passed, a class name "ajs-{type}" will be added.
             * This allows for custom look and feel for various types of notifications.
             *
             * @param  {String | DOMElement}    [message=undefined]		Message text
             * @param  {String}                 [type='']				Type of log message
             * @param  {String}                 [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}               [callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            notify: function (message, type, wait, callback) {
              return notifier.create(type, callback).push(message, wait)
            },
            /**
             * Creates a new notification message.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            message: function (message, wait, callback) {
              return notifier.create(null, callback).push(message, wait)
            },
            /**
             * Creates a new notification message of type 'success'.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            success: function (message, wait, callback) {
              return notifier.create('success', callback).push(message, wait)
            },
            /**
             * Creates a new notification message of type 'error'.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            error: function (message, wait, callback) {
              return notifier.create('error', callback).push(message, wait)
            },
            /**
             * Creates a new notification message of type 'warning'.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            warning: function (message, wait, callback) {
              return notifier.create('warning', callback).push(message, wait)
            },
            /**
             * Dismisses all open notifications
             *
             * @return {undefined}
             */
            dismissAll: function () {
              notifier.dismissAll()
            }
          }
        }
        var alertify = new Alertify()

        /**
         * Alert dialog definition
         *
         * invoked by:
         *	alertify.alert(message);
         *	alertify.alert(title, message);
         *	alertify.alert(message, onok);
         *	alertify.alert(title, message, onok);
         */
        alertify.dialog('alert', function () {
          return {
            main: function (_title, _message, _onok) {
              var title, message, onok
              switch (arguments.length) {
                case 1:
                  message = _title
                  break
                case 2:
                  if (typeof _message === 'function') {
                    message = _title
                    onok = _message
                  } else {
                    title = _title
                    message = _message
                  }
                  break
                case 3:
                  title = _title
                  message = _message
                  onok = _onok
                  break
              }
              this.set('title', title)
              this.set('message', message)
              this.set('onok', onok)
              return this
            },
            setup: function () {
              return {
                buttons: [
                  {
                    text: alertify.defaults.glossary.ok,
                    key: keys.ESC,
                    invokeOnClose: true,
                    className: alertify.defaults.theme.ok
                  }
                ],
                focus: {
                  element: 0,
                  select: false
                },
                options: {
                  maximizable: false,
                  resizable: false
                }
              }
            },
            build: function () {
              // nothing
            },
            prepare: function () {
              //nothing
            },
            setMessage: function (message) {
              this.setContent(message)
            },
            settings: {
              message: undefined,
              onok: undefined,
              label: undefined
            },
            settingUpdated: function (key, oldValue, newValue) {
              switch (key) {
                case 'message':
                  this.setMessage(newValue)
                  break
                case 'label':
                  if (this.__internal.buttons[0].element) {
                    this.__internal.buttons[0].element.innerHTML = newValue
                  }
                  break
              }
            },
            callback: function (closeEvent) {
              if (typeof this.get('onok') === 'function') {
                var returnValue = this.get('onok').call(this, closeEvent)
                if (typeof returnValue !== 'undefined') {
                  closeEvent.cancel = !returnValue
                }
              }
            }
          }
        })
        /**
         * Confirm dialog object
         *
         *	alertify.confirm(message);
         *	alertify.confirm(message, onok);
         *	alertify.confirm(message, onok, oncancel);
         *	alertify.confirm(title, message, onok, oncancel);
         */
        alertify.dialog('confirm', function () {
          var autoConfirm = {
            timer: null,
            index: null,
            text: null,
            duration: null,
            task: function (event, self) {
              if (self.isOpen()) {
                self.__internal.buttons[autoConfirm.index].element.innerHTML =
                  autoConfirm.text +
                  ' (&#8207;' +
                  autoConfirm.duration +
                  '&#8207;) '
                autoConfirm.duration -= 1
                if (autoConfirm.duration === -1) {
                  clearAutoConfirm(self)
                  var button = self.__internal.buttons[autoConfirm.index]
                  var closeEvent = createCloseEvent(autoConfirm.index, button)

                  if (typeof self.callback === 'function') {
                    self.callback.apply(self, [closeEvent])
                  }
                  //close the dialog.
                  if (closeEvent.close !== false) {
                    self.close()
                  }
                }
              } else {
                clearAutoConfirm(self)
              }
            }
          }

          function clearAutoConfirm(self) {
            if (autoConfirm.timer !== null) {
              clearInterval(autoConfirm.timer)
              autoConfirm.timer = null
              self.__internal.buttons[autoConfirm.index].element.innerHTML =
                autoConfirm.text
            }
          }

          function startAutoConfirm(self, index, duration) {
            clearAutoConfirm(self)
            autoConfirm.duration = duration
            autoConfirm.index = index
            autoConfirm.text = self.__internal.buttons[index].element.innerHTML
            autoConfirm.timer = setInterval(
              delegate(self, autoConfirm.task),
              1000
            )
            autoConfirm.task(null, self)
          }

          return {
            main: function (_title, _message, _onok, _oncancel) {
              var title, message, onok, oncancel
              switch (arguments.length) {
                case 1:
                  message = _title
                  break
                case 2:
                  message = _title
                  onok = _message
                  break
                case 3:
                  message = _title
                  onok = _message
                  oncancel = _onok
                  break
                case 4:
                  title = _title
                  message = _message
                  onok = _onok
                  oncancel = _oncancel
                  break
              }
              this.set('title', title)
              this.set('message', message)
              this.set('onok', onok)
              this.set('oncancel', oncancel)
              return this
            },
            setup: function () {
              return {
                buttons: [
                  {
                    text: alertify.defaults.glossary.ok,
                    key: keys.ENTER,
                    className: alertify.defaults.theme.ok
                  },
                  {
                    text: alertify.defaults.glossary.cancel,
                    key: keys.ESC,
                    invokeOnClose: true,
                    className: alertify.defaults.theme.cancel
                  }
                ],
                focus: {
                  element: 0,
                  select: false
                },
                options: {
                  maximizable: false,
                  resizable: false
                }
              }
            },
            build: function () {
              //nothing
            },
            prepare: function () {
              //nothing
            },
            setMessage: function (message) {
              this.setContent(message)
            },
            settings: {
              message: null,
              labels: null,
              onok: null,
              oncancel: null,
              defaultFocus: null,
              reverseButtons: null
            },
            settingUpdated: function (key, oldValue, newValue) {
              switch (key) {
                case 'message':
                  this.setMessage(newValue)
                  break
                case 'labels':
                  if ('ok' in newValue && this.__internal.buttons[0].element) {
                    this.__internal.buttons[0].text = newValue.ok
                    this.__internal.buttons[0].element.innerHTML = newValue.ok
                  }
                  if (
                    'cancel' in newValue &&
                    this.__internal.buttons[1].element
                  ) {
                    this.__internal.buttons[1].text = newValue.cancel
                    this.__internal.buttons[1].element.innerHTML =
                      newValue.cancel
                  }
                  break
                case 'reverseButtons':
                  if (newValue === true) {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[0].element
                    )
                  } else {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[1].element
                    )
                  }
                  break
                case 'defaultFocus':
                  this.__internal.focus.element = newValue === 'ok' ? 0 : 1
                  break
              }
            },
            callback: function (closeEvent) {
              clearAutoConfirm(this)
              var returnValue
              switch (closeEvent.index) {
                case 0:
                  if (typeof this.get('onok') === 'function') {
                    returnValue = this.get('onok').call(this, closeEvent)
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  break
                case 1:
                  if (typeof this.get('oncancel') === 'function') {
                    returnValue = this.get('oncancel').call(this, closeEvent)
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  break
              }
            },
            autoOk: function (duration) {
              startAutoConfirm(this, 0, duration)
              return this
            },
            autoCancel: function (duration) {
              startAutoConfirm(this, 1, duration)
              return this
            }
          }
        })
        /**
         * Prompt dialog object
         *
         * invoked by:
         *	alertify.prompt(message);
         *	alertify.prompt(message, value);
         *	alertify.prompt(message, value, onok);
         *	alertify.prompt(message, value, onok, oncancel);
         *	alertify.prompt(title, message, value, onok, oncancel);
         */
        alertify.dialog('prompt', function () {
          var input = document.createElement('INPUT')
          var p = document.createElement('P')
          return {
            main: function (_title, _message, _value, _onok, _oncancel) {
              var title, message, value, onok, oncancel
              switch (arguments.length) {
                case 1:
                  message = _title
                  break
                case 2:
                  message = _title
                  value = _message
                  break
                case 3:
                  message = _title
                  value = _message
                  onok = _value
                  break
                case 4:
                  message = _title
                  value = _message
                  onok = _value
                  oncancel = _onok
                  break
                case 5:
                  title = _title
                  message = _message
                  value = _value
                  onok = _onok
                  oncancel = _oncancel
                  break
              }
              this.set('title', title)
              this.set('message', message)
              this.set('value', value)
              this.set('onok', onok)
              this.set('oncancel', oncancel)
              return this
            },
            setup: function () {
              return {
                buttons: [
                  {
                    text: alertify.defaults.glossary.ok,
                    key: keys.ENTER,
                    className: alertify.defaults.theme.ok
                  },
                  {
                    text: alertify.defaults.glossary.cancel,
                    key: keys.ESC,
                    invokeOnClose: true,
                    className: alertify.defaults.theme.cancel
                  }
                ],
                focus: {
                  element: input,
                  select: true
                },
                options: {
                  maximizable: false,
                  resizable: false
                }
              }
            },
            build: function () {
              input.className = alertify.defaults.theme.input
              input.setAttribute('type', 'text')
              input.value = this.get('value')
              this.elements.content.appendChild(p)
              this.elements.content.appendChild(input)
            },
            prepare: function () {
              //nothing
            },
            setMessage: function (message) {
              if (typeof message === 'string') {
                clearContents(p)
                p.innerHTML = message
              } else if (
                message instanceof window.HTMLElement &&
                p.firstChild !== message
              ) {
                clearContents(p)
                p.appendChild(message)
              }
            },
            settings: {
              message: undefined,
              labels: undefined,
              onok: undefined,
              oncancel: undefined,
              value: '',
              type: 'text',
              reverseButtons: undefined
            },
            settingUpdated: function (key, oldValue, newValue) {
              switch (key) {
                case 'message':
                  this.setMessage(newValue)
                  break
                case 'value':
                  input.value = newValue
                  break
                case 'type':
                  switch (newValue) {
                    case 'text':
                    case 'color':
                    case 'date':
                    case 'datetime-local':
                    case 'email':
                    case 'month':
                    case 'number':
                    case 'password':
                    case 'search':
                    case 'tel':
                    case 'time':
                    case 'week':
                      input.type = newValue
                      break
                    default:
                      input.type = 'text'
                      break
                  }
                  break
                case 'labels':
                  if (newValue.ok && this.__internal.buttons[0].element) {
                    this.__internal.buttons[0].element.innerHTML = newValue.ok
                  }
                  if (newValue.cancel && this.__internal.buttons[1].element) {
                    this.__internal.buttons[1].element.innerHTML =
                      newValue.cancel
                  }
                  break
                case 'reverseButtons':
                  if (newValue === true) {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[0].element
                    )
                  } else {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[1].element
                    )
                  }
                  break
              }
            },
            callback: function (closeEvent) {
              var returnValue
              switch (closeEvent.index) {
                case 0:
                  this.settings.value = input.value
                  if (typeof this.get('onok') === 'function') {
                    returnValue = this.get('onok').call(
                      this,
                      closeEvent,
                      this.settings.value
                    )
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  break
                case 1:
                  if (typeof this.get('oncancel') === 'function') {
                    returnValue = this.get('oncancel').call(this, closeEvent)
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  if (!closeEvent.cancel) {
                    input.value = this.settings.value
                  }
                  break
              }
            }
          }
        })

        // CommonJS
        if (true && typeof module.exports === 'object') {
          module.exports = alertify
          // AMD
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
          (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return alertify
          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
          // window
        } else {
        }
      })(typeof window !== 'undefined' ? window : this)

      /***/
    },

    /***/ 4631: /***/ function (module) {
      // CodeMirror, copyright (c) by Marijn Haverbeke and others
      // Distributed under an MIT license: https://codemirror.net/LICENSE

      // This is CodeMirror (https://codemirror.net), a code editor
      // implemented in JavaScript on top of the browser's DOM.
      //
      // You can find some technical background for some of the code below
      // at http://marijnhaverbeke.nl/blog/#cm-internals .

      ;(function (global, factory) {
        true ? (module.exports = factory()) : 0
      })(this, function () {
        'use strict'

        // Kludges for bugs and behavior differences that can't be feature
        // detected are enabled based on userAgent etc sniffing.
        var userAgent = navigator.userAgent
        var platform = navigator.platform

        var gecko = /gecko\/\d/i.test(userAgent)
        var ie_upto10 = /MSIE \d/.test(userAgent)
        var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent)
        var edge = /Edge\/(\d+)/.exec(userAgent)
        var ie = ie_upto10 || ie_11up || edge
        var ie_version =
          ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1])
        var webkit = !edge && /WebKit\//.test(userAgent)
        var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent)
        var chrome = !edge && /Chrome\//.test(userAgent)
        var presto = /Opera\//.test(userAgent)
        var safari = /Apple Computer/.test(navigator.vendor)
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent)
        var phantom = /PhantomJS/.test(userAgent)

        var ios =
          safari &&
          (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2)
        var android = /Android/.test(userAgent)
        // This is woefully incomplete. Suggestions for alternative methods welcome.
        var mobile =
          ios ||
          android ||
          /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)
        var mac = ios || /Mac/.test(platform)
        var chromeOS = /\bCrOS\b/.test(userAgent)
        var windows = /win/i.test(platform)

        var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/)
        if (presto_version) {
          presto_version = Number(presto_version[1])
        }
        if (presto_version && presto_version >= 15) {
          presto = false
          webkit = true
        }
        // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
        var flipCtrlCmd =
          mac &&
          (qtwebkit ||
            (presto && (presto_version == null || presto_version < 12.11)))
        var captureRightClick = gecko || (ie && ie_version >= 9)

        function classTest(cls) {
          return new RegExp('(^|\\s)' + cls + '(?:$|\\s)\\s*')
        }

        var rmClass = function (node, cls) {
          var current = node.className
          var match = classTest(cls).exec(current)
          if (match) {
            var after = current.slice(match.index + match[0].length)
            node.className =
              current.slice(0, match.index) + (after ? match[1] + after : '')
          }
        }

        function removeChildren(e) {
          for (var count = e.childNodes.length; count > 0; --count) {
            e.removeChild(e.firstChild)
          }
          return e
        }

        function removeChildrenAndAdd(parent, e) {
          return removeChildren(parent).appendChild(e)
        }

        function elt(tag, content, className, style) {
          var e = document.createElement(tag)
          if (className) {
            e.className = className
          }
          if (style) {
            e.style.cssText = style
          }
          if (typeof content == 'string') {
            e.appendChild(document.createTextNode(content))
          } else if (content) {
            for (var i = 0; i < content.length; ++i) {
              e.appendChild(content[i])
            }
          }
          return e
        }
        // wrapper for elt, which removes the elt from the accessibility tree
        function eltP(tag, content, className, style) {
          var e = elt(tag, content, className, style)
          e.setAttribute('role', 'presentation')
          return e
        }

        var range
        if (document.createRange) {
          range = function (node, start, end, endNode) {
            var r = document.createRange()
            r.setEnd(endNode || node, end)
            r.setStart(node, start)
            return r
          }
        } else {
          range = function (node, start, end) {
            var r = document.body.createTextRange()
            try {
              r.moveToElementText(node.parentNode)
            } catch (e) {
              return r
            }
            r.collapse(true)
            r.moveEnd('character', end)
            r.moveStart('character', start)
            return r
          }
        }

        function contains(parent, child) {
          if (child.nodeType == 3) {
            // Android browser always returns false when child is a textnode
            child = child.parentNode
          }
          if (parent.contains) {
            return parent.contains(child)
          }
          do {
            if (child.nodeType == 11) {
              child = child.host
            }
            if (child == parent) {
              return true
            }
          } while ((child = child.parentNode))
        }

        function activeElt() {
          // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
          // IE < 10 will throw when accessed while the page is loading or in an iframe.
          // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
          var activeElement
          try {
            activeElement = document.activeElement
          } catch (e) {
            activeElement = document.body || null
          }
          while (
            activeElement &&
            activeElement.shadowRoot &&
            activeElement.shadowRoot.activeElement
          ) {
            activeElement = activeElement.shadowRoot.activeElement
          }
          return activeElement
        }

        function addClass(node, cls) {
          var current = node.className
          if (!classTest(cls).test(current)) {
            node.className += (current ? ' ' : '') + cls
          }
        }
        function joinClasses(a, b) {
          var as = a.split(' ')
          for (var i = 0; i < as.length; i++) {
            if (as[i] && !classTest(as[i]).test(b)) {
              b += ' ' + as[i]
            }
          }
          return b
        }

        var selectInput = function (node) {
          node.select()
        }
        if (ios) {
          // Mobile Safari apparently has a bug where select() is broken.
          selectInput = function (node) {
            node.selectionStart = 0
            node.selectionEnd = node.value.length
          }
        } else if (ie) {
          // Suppress mysterious IE10 errors
          selectInput = function (node) {
            try {
              node.select()
            } catch (_e) {}
          }
        }

        function bind(f) {
          var args = Array.prototype.slice.call(arguments, 1)
          return function () {
            return f.apply(null, args)
          }
        }

        function copyObj(obj, target, overwrite) {
          if (!target) {
            target = {}
          }
          for (var prop in obj) {
            if (
              obj.hasOwnProperty(prop) &&
              (overwrite !== false || !target.hasOwnProperty(prop))
            ) {
              target[prop] = obj[prop]
            }
          }
          return target
        }

        // Counts the column offset in a string, taking tabs into account.
        // Used mostly to find indentation.
        function countColumn(string, end, tabSize, startIndex, startValue) {
          if (end == null) {
            end = string.search(/[^\s\u00a0]/)
            if (end == -1) {
              end = string.length
            }
          }
          for (var i = startIndex || 0, n = startValue || 0; ; ) {
            var nextTab = string.indexOf('\t', i)
            if (nextTab < 0 || nextTab >= end) {
              return n + (end - i)
            }
            n += nextTab - i
            n += tabSize - (n % tabSize)
            i = nextTab + 1
          }
        }

        var Delayed = function () {
          this.id = null
          this.f = null
          this.time = 0
          this.handler = bind(this.onTimeout, this)
        }
        Delayed.prototype.onTimeout = function (self) {
          self.id = 0
          if (self.time <= +new Date()) {
            self.f()
          } else {
            setTimeout(self.handler, self.time - +new Date())
          }
        }
        Delayed.prototype.set = function (ms, f) {
          this.f = f
          var time = +new Date() + ms
          if (!this.id || time < this.time) {
            clearTimeout(this.id)
            this.id = setTimeout(this.handler, ms)
            this.time = time
          }
        }

        function indexOf(array, elt) {
          for (var i = 0; i < array.length; ++i) {
            if (array[i] == elt) {
              return i
            }
          }
          return -1
        }

        // Number of pixels added to scroller and sizer to hide scrollbar
        var scrollerGap = 50

        // Returned or thrown by various protocols to signal 'I'm not
        // handling this'.
        var Pass = {
          toString: function () {
            return 'CodeMirror.Pass'
          }
        }

        // Reused option objects for setSelection & friends
        var sel_dontScroll = { scroll: false },
          sel_mouse = { origin: '*mouse' },
          sel_move = { origin: '+move' }

        // The inverse of countColumn -- find the offset that corresponds to
        // a particular column.
        function findColumn(string, goal, tabSize) {
          for (var pos = 0, col = 0; ; ) {
            var nextTab = string.indexOf('\t', pos)
            if (nextTab == -1) {
              nextTab = string.length
            }
            var skipped = nextTab - pos
            if (nextTab == string.length || col + skipped >= goal) {
              return pos + Math.min(skipped, goal - col)
            }
            col += nextTab - pos
            col += tabSize - (col % tabSize)
            pos = nextTab + 1
            if (col >= goal) {
              return pos
            }
          }
        }

        var spaceStrs = ['']
        function spaceStr(n) {
          while (spaceStrs.length <= n) {
            spaceStrs.push(lst(spaceStrs) + ' ')
          }
          return spaceStrs[n]
        }

        function lst(arr) {
          return arr[arr.length - 1]
        }

        function map(array, f) {
          var out = []
          for (var i = 0; i < array.length; i++) {
            out[i] = f(array[i], i)
          }
          return out
        }

        function insertSorted(array, value, score) {
          var pos = 0,
            priority = score(value)
          while (pos < array.length && score(array[pos]) <= priority) {
            pos++
          }
          array.splice(pos, 0, value)
        }

        function nothing() {}

        function createObj(base, props) {
          var inst
          if (Object.create) {
            inst = Object.create(base)
          } else {
            nothing.prototype = base
            inst = new nothing()
          }
          if (props) {
            copyObj(props, inst)
          }
          return inst
        }

        var nonASCIISingleCaseWordChar =
          /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
        function isWordCharBasic(ch) {
          return (
            /\w/.test(ch) ||
            (ch > '\x80' &&
              (ch.toUpperCase() != ch.toLowerCase() ||
                nonASCIISingleCaseWordChar.test(ch)))
          )
        }
        function isWordChar(ch, helper) {
          if (!helper) {
            return isWordCharBasic(ch)
          }
          if (helper.source.indexOf('\\w') > -1 && isWordCharBasic(ch)) {
            return true
          }
          return helper.test(ch)
        }

        function isEmpty(obj) {
          for (var n in obj) {
            if (obj.hasOwnProperty(n) && obj[n]) {
              return false
            }
          }
          return true
        }

        // Extending unicode characters. A series of a non-extending char +
        // any number of extending chars is treated as a single unit as far
        // as editing and measuring is concerned. This is not fully correct,
        // since some scripts/fonts/browsers also treat other configurations
        // of code points as a group.
        var extendingChars =
          /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/
        function isExtendingChar(ch) {
          return ch.charCodeAt(0) >= 768 && extendingChars.test(ch)
        }

        // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
        function skipExtendingChars(str, pos, dir) {
          while (
            (dir < 0 ? pos > 0 : pos < str.length) &&
            isExtendingChar(str.charAt(pos))
          ) {
            pos += dir
          }
          return pos
        }

        // Returns the value from the range [`from`; `to`] that satisfies
        // `pred` and is closest to `from`. Assumes that at least `to`
        // satisfies `pred`. Supports `from` being greater than `to`.
        function findFirst(pred, from, to) {
          // At any point we are certain `to` satisfies `pred`, don't know
          // whether `from` does.
          var dir = from > to ? -1 : 1
          for (;;) {
            if (from == to) {
              return from
            }
            var midF = (from + to) / 2,
              mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF)
            if (mid == from) {
              return pred(mid) ? from : to
            }
            if (pred(mid)) {
              to = mid
            } else {
              from = mid + dir
            }
          }
        }

        // BIDI HELPERS

        function iterateBidiSections(order, from, to, f) {
          if (!order) {
            return f(from, to, 'ltr', 0)
          }
          var found = false
          for (var i = 0; i < order.length; ++i) {
            var part = order[i]
            if (
              (part.from < to && part.to > from) ||
              (from == to && part.to == from)
            ) {
              f(
                Math.max(part.from, from),
                Math.min(part.to, to),
                part.level == 1 ? 'rtl' : 'ltr',
                i
              )
              found = true
            }
          }
          if (!found) {
            f(from, to, 'ltr')
          }
        }

        var bidiOther = null
        function getBidiPartAt(order, ch, sticky) {
          var found
          bidiOther = null
          for (var i = 0; i < order.length; ++i) {
            var cur = order[i]
            if (cur.from < ch && cur.to > ch) {
              return i
            }
            if (cur.to == ch) {
              if (cur.from != cur.to && sticky == 'before') {
                found = i
              } else {
                bidiOther = i
              }
            }
            if (cur.from == ch) {
              if (cur.from != cur.to && sticky != 'before') {
                found = i
              } else {
                bidiOther = i
              }
            }
          }
          return found != null ? found : bidiOther
        }

        // Bidirectional ordering algorithm
        // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
        // that this (partially) implements.

        // One-char codes used for character types:
        // L (L):   Left-to-Right
        // R (R):   Right-to-Left
        // r (AL):  Right-to-Left Arabic
        // 1 (EN):  European Number
        // + (ES):  European Number Separator
        // % (ET):  European Number Terminator
        // n (AN):  Arabic Number
        // , (CS):  Common Number Separator
        // m (NSM): Non-Spacing Mark
        // b (BN):  Boundary Neutral
        // s (B):   Paragraph Separator
        // t (S):   Segment Separator
        // w (WS):  Whitespace
        // N (ON):  Other Neutrals

        // Returns null if characters are ordered as they appear
        // (left-to-right), or an array of sections ({from, to, level}
        // objects) in the order in which they occur visually.
        var bidiOrdering = (function () {
          // Character types for codepoints 0 to 0xff
          var lowTypes =
            'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN'
          // Character types for codepoints 0x600 to 0x6f9
          var arabicTypes =
            'nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111'
          function charType(code) {
            if (code <= 0xf7) {
              return lowTypes.charAt(code)
            } else if (0x590 <= code && code <= 0x5f4) {
              return 'R'
            } else if (0x600 <= code && code <= 0x6f9) {
              return arabicTypes.charAt(code - 0x600)
            } else if (0x6ee <= code && code <= 0x8ac) {
              return 'r'
            } else if (0x2000 <= code && code <= 0x200b) {
              return 'w'
            } else if (code == 0x200c) {
              return 'b'
            } else {
              return 'L'
            }
          }

          var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
          var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/

          function BidiSpan(level, from, to) {
            this.level = level
            this.from = from
            this.to = to
          }

          return function (str, direction) {
            var outerType = direction == 'ltr' ? 'L' : 'R'

            if (str.length == 0 || (direction == 'ltr' && !bidiRE.test(str))) {
              return false
            }
            var len = str.length,
              types = []
            for (var i = 0; i < len; ++i) {
              types.push(charType(str.charCodeAt(i)))
            }

            // W1. Examine each non-spacing mark (NSM) in the level run, and
            // change the type of the NSM to the type of the previous
            // character. If the NSM is at the start of the level run, it will
            // get the type of sor.
            for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
              var type = types[i$1]
              if (type == 'm') {
                types[i$1] = prev
              } else {
                prev = type
              }
            }

            // W2. Search backwards from each instance of a European number
            // until the first strong type (R, L, AL, or sor) is found. If an
            // AL is found, change the type of the European number to Arabic
            // number.
            // W3. Change all ALs to R.
            for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
              var type$1 = types[i$2]
              if (type$1 == '1' && cur == 'r') {
                types[i$2] = 'n'
              } else if (isStrong.test(type$1)) {
                cur = type$1
                if (type$1 == 'r') {
                  types[i$2] = 'R'
                }
              }
            }

            // W4. A single European separator between two European numbers
            // changes to a European number. A single common separator between
            // two numbers of the same type changes to that type.
            for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
              var type$2 = types[i$3]
              if (type$2 == '+' && prev$1 == '1' && types[i$3 + 1] == '1') {
                types[i$3] = '1'
              } else if (
                type$2 == ',' &&
                prev$1 == types[i$3 + 1] &&
                (prev$1 == '1' || prev$1 == 'n')
              ) {
                types[i$3] = prev$1
              }
              prev$1 = type$2
            }

            // W5. A sequence of European terminators adjacent to European
            // numbers changes to all European numbers.
            // W6. Otherwise, separators and terminators change to Other
            // Neutral.
            for (var i$4 = 0; i$4 < len; ++i$4) {
              var type$3 = types[i$4]
              if (type$3 == ',') {
                types[i$4] = 'N'
              } else if (type$3 == '%') {
                var end = void 0
                for (end = i$4 + 1; end < len && types[end] == '%'; ++end) {}
                var replace =
                  (i$4 && types[i$4 - 1] == '!') ||
                  (end < len && types[end] == '1')
                    ? '1'
                    : 'N'
                for (var j = i$4; j < end; ++j) {
                  types[j] = replace
                }
                i$4 = end - 1
              }
            }

            // W7. Search backwards from each instance of a European number
            // until the first strong type (R, L, or sor) is found. If an L is
            // found, then change the type of the European number to L.
            for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
              var type$4 = types[i$5]
              if (cur$1 == 'L' && type$4 == '1') {
                types[i$5] = 'L'
              } else if (isStrong.test(type$4)) {
                cur$1 = type$4
              }
            }

            // N1. A sequence of neutrals takes the direction of the
            // surrounding strong text if the text on both sides has the same
            // direction. European and Arabic numbers act as if they were R in
            // terms of their influence on neutrals. Start-of-level-run (sor)
            // and end-of-level-run (eor) are used at level run boundaries.
            // N2. Any remaining neutrals take the embedding direction.
            for (var i$6 = 0; i$6 < len; ++i$6) {
              if (isNeutral.test(types[i$6])) {
                var end$1 = void 0
                for (
                  end$1 = i$6 + 1;
                  end$1 < len && isNeutral.test(types[end$1]);
                  ++end$1
                ) {}
                var before = (i$6 ? types[i$6 - 1] : outerType) == 'L'
                var after = (end$1 < len ? types[end$1] : outerType) == 'L'
                var replace$1 =
                  before == after ? (before ? 'L' : 'R') : outerType
                for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                  types[j$1] = replace$1
                }
                i$6 = end$1 - 1
              }
            }

            // Here we depart from the documented algorithm, in order to avoid
            // building up an actual levels array. Since there are only three
            // levels (0, 1, 2) in an implementation that doesn't take
            // explicit embedding into account, we can build up the order on
            // the fly, without following the level-based algorithm.
            var order = [],
              m
            for (var i$7 = 0; i$7 < len; ) {
              if (countsAsLeft.test(types[i$7])) {
                var start = i$7
                for (
                  ++i$7;
                  i$7 < len && countsAsLeft.test(types[i$7]);
                  ++i$7
                ) {}
                order.push(new BidiSpan(0, start, i$7))
              } else {
                var pos = i$7,
                  at = order.length,
                  isRTL = direction == 'rtl' ? 1 : 0
                for (++i$7; i$7 < len && types[i$7] != 'L'; ++i$7) {}
                for (var j$2 = pos; j$2 < i$7; ) {
                  if (countsAsNum.test(types[j$2])) {
                    if (pos < j$2) {
                      order.splice(at, 0, new BidiSpan(1, pos, j$2))
                      at += isRTL
                    }
                    var nstart = j$2
                    for (
                      ++j$2;
                      j$2 < i$7 && countsAsNum.test(types[j$2]);
                      ++j$2
                    ) {}
                    order.splice(at, 0, new BidiSpan(2, nstart, j$2))
                    at += isRTL
                    pos = j$2
                  } else {
                    ++j$2
                  }
                }
                if (pos < i$7) {
                  order.splice(at, 0, new BidiSpan(1, pos, i$7))
                }
              }
            }
            if (direction == 'ltr') {
              if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                order[0].from = m[0].length
                order.unshift(new BidiSpan(0, 0, m[0].length))
              }
              if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                lst(order).to -= m[0].length
                order.push(new BidiSpan(0, len - m[0].length, len))
              }
            }

            return direction == 'rtl' ? order.reverse() : order
          }
        })()

        // Get the bidi ordering for the given line (and cache it). Returns
        // false for lines that are fully left-to-right, and an array of
        // BidiSpan objects otherwise.
        function getOrder(line, direction) {
          var order = line.order
          if (order == null) {
            order = line.order = bidiOrdering(line.text, direction)
          }
          return order
        }

        // EVENT HANDLING

        // Lightweight event framework. on/off also work on DOM nodes,
        // registering native DOM handlers.

        var noHandlers = []

        var on = function (emitter, type, f) {
          if (emitter.addEventListener) {
            emitter.addEventListener(type, f, false)
          } else if (emitter.attachEvent) {
            emitter.attachEvent('on' + type, f)
          } else {
            var map = emitter._handlers || (emitter._handlers = {})
            map[type] = (map[type] || noHandlers).concat(f)
          }
        }

        function getHandlers(emitter, type) {
          return (emitter._handlers && emitter._handlers[type]) || noHandlers
        }

        function off(emitter, type, f) {
          if (emitter.removeEventListener) {
            emitter.removeEventListener(type, f, false)
          } else if (emitter.detachEvent) {
            emitter.detachEvent('on' + type, f)
          } else {
            var map = emitter._handlers,
              arr = map && map[type]
            if (arr) {
              var index = indexOf(arr, f)
              if (index > -1) {
                map[type] = arr.slice(0, index).concat(arr.slice(index + 1))
              }
            }
          }
        }

        function signal(emitter, type /*, values...*/) {
          var handlers = getHandlers(emitter, type)
          if (!handlers.length) {
            return
          }
          var args = Array.prototype.slice.call(arguments, 2)
          for (var i = 0; i < handlers.length; ++i) {
            handlers[i].apply(null, args)
          }
        }

        // The DOM events that CodeMirror handles can be overridden by
        // registering a (non-DOM) handler on the editor for the event name,
        // and preventDefault-ing the event in that handler.
        function signalDOMEvent(cm, e, override) {
          if (typeof e == 'string') {
            e = {
              type: e,
              preventDefault: function () {
                this.defaultPrevented = true
              }
            }
          }
          signal(cm, override || e.type, cm, e)
          return e_defaultPrevented(e) || e.codemirrorIgnore
        }

        function signalCursorActivity(cm) {
          var arr = cm._handlers && cm._handlers.cursorActivity
          if (!arr) {
            return
          }
          var set =
            cm.curOp.cursorActivityHandlers ||
            (cm.curOp.cursorActivityHandlers = [])
          for (var i = 0; i < arr.length; ++i) {
            if (indexOf(set, arr[i]) == -1) {
              set.push(arr[i])
            }
          }
        }

        function hasHandler(emitter, type) {
          return getHandlers(emitter, type).length > 0
        }

        // Add on and off methods to a constructor's prototype, to make
        // registering events on such objects more convenient.
        function eventMixin(ctor) {
          ctor.prototype.on = function (type, f) {
            on(this, type, f)
          }
          ctor.prototype.off = function (type, f) {
            off(this, type, f)
          }
        }

        // Due to the fact that we still support jurassic IE versions, some
        // compatibility wrappers are needed.

        function e_preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault()
          } else {
            e.returnValue = false
          }
        }
        function e_stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation()
          } else {
            e.cancelBubble = true
          }
        }
        function e_defaultPrevented(e) {
          return e.defaultPrevented != null
            ? e.defaultPrevented
            : e.returnValue == false
        }
        function e_stop(e) {
          e_preventDefault(e)
          e_stopPropagation(e)
        }

        function e_target(e) {
          return e.target || e.srcElement
        }
        function e_button(e) {
          var b = e.which
          if (b == null) {
            if (e.button & 1) {
              b = 1
            } else if (e.button & 2) {
              b = 3
            } else if (e.button & 4) {
              b = 2
            }
          }
          if (mac && e.ctrlKey && b == 1) {
            b = 3
          }
          return b
        }

        // Detect drag-and-drop
        var dragAndDrop = (function () {
          // There is *some* kind of drag-and-drop support in IE6-8, but I
          // couldn't get it to work yet.
          if (ie && ie_version < 9) {
            return false
          }
          var div = elt('div')
          return 'draggable' in div || 'dragDrop' in div
        })()

        var zwspSupported
        function zeroWidthElement(measure) {
          if (zwspSupported == null) {
            var test = elt('span', '\u200b')
            removeChildrenAndAdd(
              measure,
              elt('span', [test, document.createTextNode('x')])
            )
            if (measure.firstChild.offsetHeight != 0) {
              zwspSupported =
                test.offsetWidth <= 1 &&
                test.offsetHeight > 2 &&
                !(ie && ie_version < 8)
            }
          }
          var node = zwspSupported
            ? elt('span', '\u200b')
            : elt(
                'span',
                '\u00a0',
                null,
                'display: inline-block; width: 1px; margin-right: -1px'
              )
          node.setAttribute('cm-text', '')
          return node
        }

        // Feature-detect IE's crummy client rect reporting for bidi text
        var badBidiRects
        function hasBadBidiRects(measure) {
          if (badBidiRects != null) {
            return badBidiRects
          }
          var txt = removeChildrenAndAdd(
            measure,
            document.createTextNode('A\u062eA')
          )
          var r0 = range(txt, 0, 1).getBoundingClientRect()
          var r1 = range(txt, 1, 2).getBoundingClientRect()
          removeChildren(measure)
          if (!r0 || r0.left == r0.right) {
            return false
          } // Safari returns null in some cases (#2780)
          return (badBidiRects = r1.right - r0.right < 3)
        }

        // See if "".split is the broken IE version, if so, provide an
        // alternative way to split lines.
        var splitLinesAuto =
          '\n\nb'.split(/\n/).length != 3
            ? function (string) {
                var pos = 0,
                  result = [],
                  l = string.length
                while (pos <= l) {
                  var nl = string.indexOf('\n', pos)
                  if (nl == -1) {
                    nl = string.length
                  }
                  var line = string.slice(
                    pos,
                    string.charAt(nl - 1) == '\r' ? nl - 1 : nl
                  )
                  var rt = line.indexOf('\r')
                  if (rt != -1) {
                    result.push(line.slice(0, rt))
                    pos += rt + 1
                  } else {
                    result.push(line)
                    pos = nl + 1
                  }
                }
                return result
              }
            : function (string) {
                return string.split(/\r\n?|\n/)
              }

        var hasSelection = window.getSelection
          ? function (te) {
              try {
                return te.selectionStart != te.selectionEnd
              } catch (e) {
                return false
              }
            }
          : function (te) {
              var range
              try {
                range = te.ownerDocument.selection.createRange()
              } catch (e) {}
              if (!range || range.parentElement() != te) {
                return false
              }
              return range.compareEndPoints('StartToEnd', range) != 0
            }

        var hasCopyEvent = (function () {
          var e = elt('div')
          if ('oncopy' in e) {
            return true
          }
          e.setAttribute('oncopy', 'return;')
          return typeof e.oncopy == 'function'
        })()

        var badZoomedRects = null
        function hasBadZoomedRects(measure) {
          if (badZoomedRects != null) {
            return badZoomedRects
          }
          var node = removeChildrenAndAdd(measure, elt('span', 'x'))
          var normal = node.getBoundingClientRect()
          var fromRange = range(node, 0, 1).getBoundingClientRect()
          return (badZoomedRects = Math.abs(normal.left - fromRange.left) > 1)
        }

        // Known modes, by name and by MIME
        var modes = {},
          mimeModes = {}

        // Extra arguments are stored as the mode's dependencies, which is
        // used by (legacy) mechanisms like loadmode.js to automatically
        // load a mode. (Preferred mechanism is the require/define calls.)
        function defineMode(name, mode) {
          if (arguments.length > 2) {
            mode.dependencies = Array.prototype.slice.call(arguments, 2)
          }
          modes[name] = mode
        }

        function defineMIME(mime, spec) {
          mimeModes[mime] = spec
        }

        // Given a MIME type, a {name, ...options} config object, or a name
        // string, return a mode config object.
        function resolveMode(spec) {
          if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec]
          } else if (
            spec &&
            typeof spec.name == 'string' &&
            mimeModes.hasOwnProperty(spec.name)
          ) {
            var found = mimeModes[spec.name]
            if (typeof found == 'string') {
              found = { name: found }
            }
            spec = createObj(found, spec)
            spec.name = found.name
          } else if (
            typeof spec == 'string' &&
            /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)
          ) {
            return resolveMode('application/xml')
          } else if (
            typeof spec == 'string' &&
            /^[\w\-]+\/[\w\-]+\+json$/.test(spec)
          ) {
            return resolveMode('application/json')
          }
          if (typeof spec == 'string') {
            return { name: spec }
          } else {
            return spec || { name: 'null' }
          }
        }

        // Given a mode spec (anything that resolveMode accepts), find and
        // initialize an actual mode object.
        function getMode(options, spec) {
          spec = resolveMode(spec)
          var mfactory = modes[spec.name]
          if (!mfactory) {
            return getMode(options, 'text/plain')
          }
          var modeObj = mfactory(options, spec)
          if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name]
            for (var prop in exts) {
              if (!exts.hasOwnProperty(prop)) {
                continue
              }
              if (modeObj.hasOwnProperty(prop)) {
                modeObj['_' + prop] = modeObj[prop]
              }
              modeObj[prop] = exts[prop]
            }
          }
          modeObj.name = spec.name
          if (spec.helperType) {
            modeObj.helperType = spec.helperType
          }
          if (spec.modeProps) {
            for (var prop$1 in spec.modeProps) {
              modeObj[prop$1] = spec.modeProps[prop$1]
            }
          }

          return modeObj
        }

        // This can be used to attach properties to mode objects from
        // outside the actual mode definition.
        var modeExtensions = {}
        function extendMode(mode, properties) {
          var exts = modeExtensions.hasOwnProperty(mode)
            ? modeExtensions[mode]
            : (modeExtensions[mode] = {})
          copyObj(properties, exts)
        }

        function copyState(mode, state) {
          if (state === true) {
            return state
          }
          if (mode.copyState) {
            return mode.copyState(state)
          }
          var nstate = {}
          for (var n in state) {
            var val = state[n]
            if (val instanceof Array) {
              val = val.concat([])
            }
            nstate[n] = val
          }
          return nstate
        }

        // Given a mode and a state (for that mode), find the inner mode and
        // state at the position that the state refers to.
        function innerMode(mode, state) {
          var info
          while (mode.innerMode) {
            info = mode.innerMode(state)
            if (!info || info.mode == mode) {
              break
            }
            state = info.state
            mode = info.mode
          }
          return info || { mode: mode, state: state }
        }

        function startState(mode, a1, a2) {
          return mode.startState ? mode.startState(a1, a2) : true
        }

        // STRING STREAM

        // Fed to the mode parsers, provides helper functions to make
        // parsers more succinct.

        var StringStream = function (string, tabSize, lineOracle) {
          this.pos = this.start = 0
          this.string = string
          this.tabSize = tabSize || 8
          this.lastColumnPos = this.lastColumnValue = 0
          this.lineStart = 0
          this.lineOracle = lineOracle
        }

        StringStream.prototype.eol = function () {
          return this.pos >= this.string.length
        }
        StringStream.prototype.sol = function () {
          return this.pos == this.lineStart
        }
        StringStream.prototype.peek = function () {
          return this.string.charAt(this.pos) || undefined
        }
        StringStream.prototype.next = function () {
          if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++)
          }
        }
        StringStream.prototype.eat = function (match) {
          var ch = this.string.charAt(this.pos)
          var ok
          if (typeof match == 'string') {
            ok = ch == match
          } else {
            ok = ch && (match.test ? match.test(ch) : match(ch))
          }
          if (ok) {
            ++this.pos
            return ch
          }
        }
        StringStream.prototype.eatWhile = function (match) {
          var start = this.pos
          while (this.eat(match)) {}
          return this.pos > start
        }
        StringStream.prototype.eatSpace = function () {
          var start = this.pos
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
            ++this.pos
          }
          return this.pos > start
        }
        StringStream.prototype.skipToEnd = function () {
          this.pos = this.string.length
        }
        StringStream.prototype.skipTo = function (ch) {
          var found = this.string.indexOf(ch, this.pos)
          if (found > -1) {
            this.pos = found
            return true
          }
        }
        StringStream.prototype.backUp = function (n) {
          this.pos -= n
        }
        StringStream.prototype.column = function () {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(
              this.string,
              this.start,
              this.tabSize,
              this.lastColumnPos,
              this.lastColumnValue
            )
            this.lastColumnPos = this.start
          }
          return (
            this.lastColumnValue -
            (this.lineStart
              ? countColumn(this.string, this.lineStart, this.tabSize)
              : 0)
          )
        }
        StringStream.prototype.indentation = function () {
          return (
            countColumn(this.string, null, this.tabSize) -
            (this.lineStart
              ? countColumn(this.string, this.lineStart, this.tabSize)
              : 0)
          )
        }
        StringStream.prototype.match = function (
          pattern,
          consume,
          caseInsensitive
        ) {
          if (typeof pattern == 'string') {
            var cased = function (str) {
              return caseInsensitive ? str.toLowerCase() : str
            }
            var substr = this.string.substr(this.pos, pattern.length)
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) {
                this.pos += pattern.length
              }
              return true
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern)
            if (match && match.index > 0) {
              return null
            }
            if (match && consume !== false) {
              this.pos += match[0].length
            }
            return match
          }
        }
        StringStream.prototype.current = function () {
          return this.string.slice(this.start, this.pos)
        }
        StringStream.prototype.hideFirstChars = function (n, inner) {
          this.lineStart += n
          try {
            return inner()
          } finally {
            this.lineStart -= n
          }
        }
        StringStream.prototype.lookAhead = function (n) {
          var oracle = this.lineOracle
          return oracle && oracle.lookAhead(n)
        }
        StringStream.prototype.baseToken = function () {
          var oracle = this.lineOracle
          return oracle && oracle.baseToken(this.pos)
        }

        // Find the line object corresponding to the given line number.
        function getLine(doc, n) {
          n -= doc.first
          if (n < 0 || n >= doc.size) {
            throw new Error(
              'There is no line ' + (n + doc.first) + ' in the document.'
            )
          }
          var chunk = doc
          while (!chunk.lines) {
            for (var i = 0; ; ++i) {
              var child = chunk.children[i],
                sz = child.chunkSize()
              if (n < sz) {
                chunk = child
                break
              }
              n -= sz
            }
          }
          return chunk.lines[n]
        }

        // Get the part of a document between two positions, as an array of
        // strings.
        function getBetween(doc, start, end) {
          var out = [],
            n = start.line
          doc.iter(start.line, end.line + 1, function (line) {
            var text = line.text
            if (n == end.line) {
              text = text.slice(0, end.ch)
            }
            if (n == start.line) {
              text = text.slice(start.ch)
            }
            out.push(text)
            ++n
          })
          return out
        }
        // Get the lines between from and to, as array of strings.
        function getLines(doc, from, to) {
          var out = []
          doc.iter(from, to, function (line) {
            out.push(line.text)
          }) // iter aborts when callback returns truthy value
          return out
        }

        // Update the height of a line, propagating the height change
        // upwards to parent nodes.
        function updateLineHeight(line, height) {
          var diff = height - line.height
          if (diff) {
            for (var n = line; n; n = n.parent) {
              n.height += diff
            }
          }
        }

        // Given a line object, find its line number by walking up through
        // its parent links.
        function lineNo(line) {
          if (line.parent == null) {
            return null
          }
          var cur = line.parent,
            no = indexOf(cur.lines, line)
          for (
            var chunk = cur.parent;
            chunk;
            cur = chunk, chunk = chunk.parent
          ) {
            for (var i = 0; ; ++i) {
              if (chunk.children[i] == cur) {
                break
              }
              no += chunk.children[i].chunkSize()
            }
          }
          return no + cur.first
        }

        // Find the line at the given vertical position, using the height
        // information in the document tree.
        function lineAtHeight(chunk, h) {
          var n = chunk.first
          outer: do {
            for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
              var child = chunk.children[i$1],
                ch = child.height
              if (h < ch) {
                chunk = child
                continue outer
              }
              h -= ch
              n += child.chunkSize()
            }
            return n
          } while (!chunk.lines)
          var i = 0
          for (; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i],
              lh = line.height
            if (h < lh) {
              break
            }
            h -= lh
          }
          return n + i
        }

        function isLine(doc, l) {
          return l >= doc.first && l < doc.first + doc.size
        }

        function lineNumberFor(options, i) {
          return String(
            options.lineNumberFormatter(i + options.firstLineNumber)
          )
        }

        // A Pos instance represents a position within the text.
        function Pos(line, ch, sticky) {
          if (sticky === void 0) sticky = null

          if (!(this instanceof Pos)) {
            return new Pos(line, ch, sticky)
          }
          this.line = line
          this.ch = ch
          this.sticky = sticky
        }

        // Compare two positions, return 0 if they are the same, a negative
        // number when a is less, and a positive number otherwise.
        function cmp(a, b) {
          return a.line - b.line || a.ch - b.ch
        }

        function equalCursorPos(a, b) {
          return a.sticky == b.sticky && cmp(a, b) == 0
        }

        function copyPos(x) {
          return Pos(x.line, x.ch)
        }
        function maxPos(a, b) {
          return cmp(a, b) < 0 ? b : a
        }
        function minPos(a, b) {
          return cmp(a, b) < 0 ? a : b
        }

        // Most of the external API clips given positions to make sure they
        // actually exist within the document.
        function clipLine(doc, n) {
          return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))
        }
        function clipPos(doc, pos) {
          if (pos.line < doc.first) {
            return Pos(doc.first, 0)
          }
          var last = doc.first + doc.size - 1
          if (pos.line > last) {
            return Pos(last, getLine(doc, last).text.length)
          }
          return clipToLen(pos, getLine(doc, pos.line).text.length)
        }
        function clipToLen(pos, linelen) {
          var ch = pos.ch
          if (ch == null || ch > linelen) {
            return Pos(pos.line, linelen)
          } else if (ch < 0) {
            return Pos(pos.line, 0)
          } else {
            return pos
          }
        }
        function clipPosArray(doc, array) {
          var out = []
          for (var i = 0; i < array.length; i++) {
            out[i] = clipPos(doc, array[i])
          }
          return out
        }

        var SavedContext = function (state, lookAhead) {
          this.state = state
          this.lookAhead = lookAhead
        }

        var Context = function (doc, state, line, lookAhead) {
          this.state = state
          this.doc = doc
          this.line = line
          this.maxLookAhead = lookAhead || 0
          this.baseTokens = null
          this.baseTokenPos = 1
        }

        Context.prototype.lookAhead = function (n) {
          var line = this.doc.getLine(this.line + n)
          if (line != null && n > this.maxLookAhead) {
            this.maxLookAhead = n
          }
          return line
        }

        Context.prototype.baseToken = function (n) {
          if (!this.baseTokens) {
            return null
          }
          while (this.baseTokens[this.baseTokenPos] <= n) {
            this.baseTokenPos += 2
          }
          var type = this.baseTokens[this.baseTokenPos + 1]
          return {
            type: type && type.replace(/( |^)overlay .*/, ''),
            size: this.baseTokens[this.baseTokenPos] - n
          }
        }

        Context.prototype.nextLine = function () {
          this.line++
          if (this.maxLookAhead > 0) {
            this.maxLookAhead--
          }
        }

        Context.fromSaved = function (doc, saved, line) {
          if (saved instanceof SavedContext) {
            return new Context(
              doc,
              copyState(doc.mode, saved.state),
              line,
              saved.lookAhead
            )
          } else {
            return new Context(doc, copyState(doc.mode, saved), line)
          }
        }

        Context.prototype.save = function (copy) {
          var state =
            copy !== false ? copyState(this.doc.mode, this.state) : this.state
          return this.maxLookAhead > 0
            ? new SavedContext(state, this.maxLookAhead)
            : state
        }

        // Compute a style array (an array starting with a mode generation
        // -- for invalidation -- followed by pairs of end positions and
        // style strings), which is used to highlight the tokens on the
        // line.
        function highlightLine(cm, line, context, forceToEnd) {
          // A styles array always starts with a number identifying the
          // mode/overlays that it is based on (for easy invalidation).
          var st = [cm.state.modeGen],
            lineClasses = {}
          // Compute the base array of styles
          runMode(
            cm,
            line.text,
            cm.doc.mode,
            context,
            function (end, style) {
              return st.push(end, style)
            },
            lineClasses,
            forceToEnd
          )
          var state = context.state

          // Run overlays, adjust style array.
          var loop = function (o) {
            context.baseTokens = st
            var overlay = cm.state.overlays[o],
              i = 1,
              at = 0
            context.state = true
            runMode(
              cm,
              line.text,
              overlay.mode,
              context,
              function (end, style) {
                var start = i
                // Ensure there's a token end at the current position, and that i points at it
                while (at < end) {
                  var i_end = st[i]
                  if (i_end > end) {
                    st.splice(i, 1, end, st[i + 1], i_end)
                  }
                  i += 2
                  at = Math.min(end, i_end)
                }
                if (!style) {
                  return
                }
                if (overlay.opaque) {
                  st.splice(start, i - start, end, 'overlay ' + style)
                  i = start + 2
                } else {
                  for (; start < i; start += 2) {
                    var cur = st[start + 1]
                    st[start + 1] = (cur ? cur + ' ' : '') + 'overlay ' + style
                  }
                }
              },
              lineClasses
            )
            context.state = state
            context.baseTokens = null
            context.baseTokenPos = 1
          }

          for (var o = 0; o < cm.state.overlays.length; ++o) loop(o)

          return {
            styles: st,
            classes:
              lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
          }
        }

        function getLineStyles(cm, line, updateFrontier) {
          if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var context = getContextBefore(cm, lineNo(line))
            var resetState =
              line.text.length > cm.options.maxHighlightLength &&
              copyState(cm.doc.mode, context.state)
            var result = highlightLine(cm, line, context)
            if (resetState) {
              context.state = resetState
            }
            line.stateAfter = context.save(!resetState)
            line.styles = result.styles
            if (result.classes) {
              line.styleClasses = result.classes
            } else if (line.styleClasses) {
              line.styleClasses = null
            }
            if (updateFrontier === cm.doc.highlightFrontier) {
              cm.doc.modeFrontier = Math.max(
                cm.doc.modeFrontier,
                ++cm.doc.highlightFrontier
              )
            }
          }
          return line.styles
        }

        function getContextBefore(cm, n, precise) {
          var doc = cm.doc,
            display = cm.display
          if (!doc.mode.startState) {
            return new Context(doc, true, n)
          }
          var start = findStartLine(cm, n, precise)
          var saved = start > doc.first && getLine(doc, start - 1).stateAfter
          var context = saved
            ? Context.fromSaved(doc, saved, start)
            : new Context(doc, startState(doc.mode), start)

          doc.iter(start, n, function (line) {
            processLine(cm, line.text, context)
            var pos = context.line
            line.stateAfter =
              pos == n - 1 ||
              pos % 5 == 0 ||
              (pos >= display.viewFrom && pos < display.viewTo)
                ? context.save()
                : null
            context.nextLine()
          })
          if (precise) {
            doc.modeFrontier = context.line
          }
          return context
        }

        // Lightweight form of highlight -- proceed over this line and
        // update state, but don't save a style array. Used for lines that
        // aren't currently visible.
        function processLine(cm, text, context, startAt) {
          var mode = cm.doc.mode
          var stream = new StringStream(text, cm.options.tabSize, context)
          stream.start = stream.pos = startAt || 0
          if (text == '') {
            callBlankLine(mode, context.state)
          }
          while (!stream.eol()) {
            readToken(mode, stream, context.state)
            stream.start = stream.pos
          }
        }

        function callBlankLine(mode, state) {
          if (mode.blankLine) {
            return mode.blankLine(state)
          }
          if (!mode.innerMode) {
            return
          }
          var inner = innerMode(mode, state)
          if (inner.mode.blankLine) {
            return inner.mode.blankLine(inner.state)
          }
        }

        function readToken(mode, stream, state, inner) {
          for (var i = 0; i < 10; i++) {
            if (inner) {
              inner[0] = innerMode(mode, state).mode
            }
            var style = mode.token(stream, state)
            if (stream.pos > stream.start) {
              return style
            }
          }
          throw new Error('Mode ' + mode.name + ' failed to advance stream.')
        }

        var Token = function (stream, type, state) {
          this.start = stream.start
          this.end = stream.pos
          this.string = stream.current()
          this.type = type || null
          this.state = state
        }

        // Utility for getTokenAt and getLineTokens
        function takeToken(cm, pos, precise, asArray) {
          var doc = cm.doc,
            mode = doc.mode,
            style
          pos = clipPos(doc, pos)
          var line = getLine(doc, pos.line),
            context = getContextBefore(cm, pos.line, precise)
          var stream = new StringStream(line.text, cm.options.tabSize, context),
            tokens
          if (asArray) {
            tokens = []
          }
          while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos
            style = readToken(mode, stream, context.state)
            if (asArray) {
              tokens.push(
                new Token(stream, style, copyState(doc.mode, context.state))
              )
            }
          }
          return asArray ? tokens : new Token(stream, style, context.state)
        }

        function extractLineClasses(type, output) {
          if (type) {
            for (;;) {
              var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/)
              if (!lineClass) {
                break
              }
              type =
                type.slice(0, lineClass.index) +
                type.slice(lineClass.index + lineClass[0].length)
              var prop = lineClass[1] ? 'bgClass' : 'textClass'
              if (output[prop] == null) {
                output[prop] = lineClass[2]
              } else if (
                !new RegExp('(?:^|\\s)' + lineClass[2] + '(?:$|\\s)').test(
                  output[prop]
                )
              ) {
                output[prop] += ' ' + lineClass[2]
              }
            }
          }
          return type
        }

        // Run the given mode's parser over a line, calling f for each token.
        function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
          var flattenSpans = mode.flattenSpans
          if (flattenSpans == null) {
            flattenSpans = cm.options.flattenSpans
          }
          var curStart = 0,
            curStyle = null
          var stream = new StringStream(text, cm.options.tabSize, context),
            style
          var inner = cm.options.addModeClass && [null]
          if (text == '') {
            extractLineClasses(callBlankLine(mode, context.state), lineClasses)
          }
          while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
              flattenSpans = false
              if (forceToEnd) {
                processLine(cm, text, context, stream.pos)
              }
              stream.pos = text.length
              style = null
            } else {
              style = extractLineClasses(
                readToken(mode, stream, context.state, inner),
                lineClasses
              )
            }
            if (inner) {
              var mName = inner[0].name
              if (mName) {
                style = 'm-' + (style ? mName + ' ' + style : mName)
              }
            }
            if (!flattenSpans || curStyle != style) {
              while (curStart < stream.start) {
                curStart = Math.min(stream.start, curStart + 5000)
                f(curStart, curStyle)
              }
              curStyle = style
            }
            stream.start = stream.pos
          }
          while (curStart < stream.pos) {
            // Webkit seems to refuse to render text nodes longer than 57444
            // characters, and returns inaccurate measurements in nodes
            // starting around 5000 chars.
            var pos = Math.min(stream.pos, curStart + 5000)
            f(pos, curStyle)
            curStart = pos
          }
        }

        // Finds the line to start with when starting a parse. Tries to
        // find a line with a stateAfter, so that it can start with a
        // valid state. If that fails, it returns the line with the
        // smallest indentation, which tends to need the least context to
        // parse correctly.
        function findStartLine(cm, n, precise) {
          var minindent,
            minline,
            doc = cm.doc
          var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)
          for (var search = n; search > lim; --search) {
            if (search <= doc.first) {
              return doc.first
            }
            var line = getLine(doc, search - 1),
              after = line.stateAfter
            if (
              after &&
              (!precise ||
                search +
                  (after instanceof SavedContext ? after.lookAhead : 0) <=
                  doc.modeFrontier)
            ) {
              return search
            }
            var indented = countColumn(line.text, null, cm.options.tabSize)
            if (minline == null || minindent > indented) {
              minline = search - 1
              minindent = indented
            }
          }
          return minline
        }

        function retreatFrontier(doc, n) {
          doc.modeFrontier = Math.min(doc.modeFrontier, n)
          if (doc.highlightFrontier < n - 10) {
            return
          }
          var start = doc.first
          for (var line = n - 1; line > start; line--) {
            var saved = getLine(doc, line).stateAfter
            // change is on 3
            // state on line 1 looked ahead 2 -- so saw 3
            // test 1 + 2 < 3 should cover this
            if (
              saved &&
              (!(saved instanceof SavedContext) || line + saved.lookAhead < n)
            ) {
              start = line + 1
              break
            }
          }
          doc.highlightFrontier = Math.min(doc.highlightFrontier, start)
        }

        // Optimize some code when these features are not used.
        var sawReadOnlySpans = false,
          sawCollapsedSpans = false

        function seeReadOnlySpans() {
          sawReadOnlySpans = true
        }

        function seeCollapsedSpans() {
          sawCollapsedSpans = true
        }

        // TEXTMARKER SPANS

        function MarkedSpan(marker, from, to) {
          this.marker = marker
          this.from = from
          this.to = to
        }

        // Search an array of spans for a span matching the given marker.
        function getMarkedSpanFor(spans, marker) {
          if (spans) {
            for (var i = 0; i < spans.length; ++i) {
              var span = spans[i]
              if (span.marker == marker) {
                return span
              }
            }
          }
        }

        // Remove a span from an array, returning undefined if no spans are
        // left (we don't store arrays for lines without spans).
        function removeMarkedSpan(spans, span) {
          var r
          for (var i = 0; i < spans.length; ++i) {
            if (spans[i] != span) {
              ;(r || (r = [])).push(spans[i])
            }
          }
          return r
        }

        // Add a span to a line.
        function addMarkedSpan(line, span, op) {
          var inThisOp =
            op &&
            window.WeakSet &&
            (op.markedSpans || (op.markedSpans = new WeakSet()))
          if (inThisOp && inThisOp.has(line.markedSpans)) {
            line.markedSpans.push(span)
          } else {
            line.markedSpans = line.markedSpans
              ? line.markedSpans.concat([span])
              : [span]
            if (inThisOp) {
              inThisOp.add(line.markedSpans)
            }
          }
          span.marker.attachLine(line)
        }

        // Used for the algorithm that adjusts markers for a change in the
        // document. These functions cut an array of spans at a given
        // character position, returning an array of remaining chunks (or
        // undefined if nothing remains).
        function markedSpansBefore(old, startCh, isInsert) {
          var nw
          if (old) {
            for (var i = 0; i < old.length; ++i) {
              var span = old[i],
                marker = span.marker
              var startsBefore =
                span.from == null ||
                (marker.inclusiveLeft
                  ? span.from <= startCh
                  : span.from < startCh)
              if (
                startsBefore ||
                (span.from == startCh &&
                  marker.type == 'bookmark' &&
                  (!isInsert || !span.marker.insertLeft))
              ) {
                var endsAfter =
                  span.to == null ||
                  (marker.inclusiveRight
                    ? span.to >= startCh
                    : span.to > startCh)
                ;(nw || (nw = [])).push(
                  new MarkedSpan(marker, span.from, endsAfter ? null : span.to)
                )
              }
            }
          }
          return nw
        }
        function markedSpansAfter(old, endCh, isInsert) {
          var nw
          if (old) {
            for (var i = 0; i < old.length; ++i) {
              var span = old[i],
                marker = span.marker
              var endsAfter =
                span.to == null ||
                (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)
              if (
                endsAfter ||
                (span.from == endCh &&
                  marker.type == 'bookmark' &&
                  (!isInsert || span.marker.insertLeft))
              ) {
                var startsBefore =
                  span.from == null ||
                  (marker.inclusiveLeft
                    ? span.from <= endCh
                    : span.from < endCh)
                ;(nw || (nw = [])).push(
                  new MarkedSpan(
                    marker,
                    startsBefore ? null : span.from - endCh,
                    span.to == null ? null : span.to - endCh
                  )
                )
              }
            }
          }
          return nw
        }

        // Given a change object, compute the new set of marker spans that
        // cover the line in which the change took place. Removes spans
        // entirely within the change, reconnects spans belonging to the
        // same marker that appear on both sides of the change, and cuts off
        // spans partially within the change. Returns an array of span
        // arrays with one element for each line in (after) the change.
        function stretchSpansOverChange(doc, change) {
          if (change.full) {
            return null
          }
          var oldFirst =
            isLine(doc, change.from.line) &&
            getLine(doc, change.from.line).markedSpans
          var oldLast =
            isLine(doc, change.to.line) &&
            getLine(doc, change.to.line).markedSpans
          if (!oldFirst && !oldLast) {
            return null
          }

          var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = cmp(change.from, change.to) == 0
          // Get the spans that 'stick out' on both sides
          var first = markedSpansBefore(oldFirst, startCh, isInsert)
          var last = markedSpansAfter(oldLast, endCh, isInsert)

          // Next, merge those two ends
          var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0)
          if (first) {
            // Fix up .to properties of first
            for (var i = 0; i < first.length; ++i) {
              var span = first[i]
              if (span.to == null) {
                var found = getMarkedSpanFor(last, span.marker)
                if (!found) {
                  span.to = startCh
                } else if (sameLine) {
                  span.to = found.to == null ? null : found.to + offset
                }
              }
            }
          }
          if (last) {
            // Fix up .from in last (or move them into first in case of sameLine)
            for (var i$1 = 0; i$1 < last.length; ++i$1) {
              var span$1 = last[i$1]
              if (span$1.to != null) {
                span$1.to += offset
              }
              if (span$1.from == null) {
                var found$1 = getMarkedSpanFor(first, span$1.marker)
                if (!found$1) {
                  span$1.from = offset
                  if (sameLine) {
                    ;(first || (first = [])).push(span$1)
                  }
                }
              } else {
                span$1.from += offset
                if (sameLine) {
                  ;(first || (first = [])).push(span$1)
                }
              }
            }
          }
          // Make sure we didn't create any zero-length spans
          if (first) {
            first = clearEmptySpans(first)
          }
          if (last && last != first) {
            last = clearEmptySpans(last)
          }

          var newMarkers = [first]
          if (!sameLine) {
            // Fill gap with whole-line-spans
            var gap = change.text.length - 2,
              gapMarkers
            if (gap > 0 && first) {
              for (var i$2 = 0; i$2 < first.length; ++i$2) {
                if (first[i$2].to == null) {
                  ;(gapMarkers || (gapMarkers = [])).push(
                    new MarkedSpan(first[i$2].marker, null, null)
                  )
                }
              }
            }
            for (var i$3 = 0; i$3 < gap; ++i$3) {
              newMarkers.push(gapMarkers)
            }
            newMarkers.push(last)
          }
          return newMarkers
        }

        // Remove spans that are empty and don't have a clearWhenEmpty
        // option of false.
        function clearEmptySpans(spans) {
          for (var i = 0; i < spans.length; ++i) {
            var span = spans[i]
            if (
              span.from != null &&
              span.from == span.to &&
              span.marker.clearWhenEmpty !== false
            ) {
              spans.splice(i--, 1)
            }
          }
          if (!spans.length) {
            return null
          }
          return spans
        }

        // Used to 'clip' out readOnly ranges when making a change.
        function removeReadOnlyRanges(doc, from, to) {
          var markers = null
          doc.iter(from.line, to.line + 1, function (line) {
            if (line.markedSpans) {
              for (var i = 0; i < line.markedSpans.length; ++i) {
                var mark = line.markedSpans[i].marker
                if (
                  mark.readOnly &&
                  (!markers || indexOf(markers, mark) == -1)
                ) {
                  ;(markers || (markers = [])).push(mark)
                }
              }
            }
          })
          if (!markers) {
            return null
          }
          var parts = [{ from: from, to: to }]
          for (var i = 0; i < markers.length; ++i) {
            var mk = markers[i],
              m = mk.find(0)
            for (var j = 0; j < parts.length; ++j) {
              var p = parts[j]
              if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
                continue
              }
              var newParts = [j, 1],
                dfrom = cmp(p.from, m.from),
                dto = cmp(p.to, m.to)
              if (dfrom < 0 || (!mk.inclusiveLeft && !dfrom)) {
                newParts.push({ from: p.from, to: m.from })
              }
              if (dto > 0 || (!mk.inclusiveRight && !dto)) {
                newParts.push({ from: m.to, to: p.to })
              }
              parts.splice.apply(parts, newParts)
              j += newParts.length - 3
            }
          }
          return parts
        }

        // Connect or disconnect spans from a line.
        function detachMarkedSpans(line) {
          var spans = line.markedSpans
          if (!spans) {
            return
          }
          for (var i = 0; i < spans.length; ++i) {
            spans[i].marker.detachLine(line)
          }
          line.markedSpans = null
        }
        function attachMarkedSpans(line, spans) {
          if (!spans) {
            return
          }
          for (var i = 0; i < spans.length; ++i) {
            spans[i].marker.attachLine(line)
          }
          line.markedSpans = spans
        }

        // Helpers used when computing which overlapping collapsed span
        // counts as the larger one.
        function extraLeft(marker) {
          return marker.inclusiveLeft ? -1 : 0
        }
        function extraRight(marker) {
          return marker.inclusiveRight ? 1 : 0
        }

        // Returns a number indicating which of two overlapping collapsed
        // spans is larger (and thus includes the other). Falls back to
        // comparing ids when the spans cover exactly the same range.
        function compareCollapsedMarkers(a, b) {
          var lenDiff = a.lines.length - b.lines.length
          if (lenDiff != 0) {
            return lenDiff
          }
          var aPos = a.find(),
            bPos = b.find()
          var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)
          if (fromCmp) {
            return -fromCmp
          }
          var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)
          if (toCmp) {
            return toCmp
          }
          return b.id - a.id
        }

        // Find out whether a line ends or starts in a collapsed span. If
        // so, return the marker for that span.
        function collapsedSpanAtSide(line, start) {
          var sps = sawCollapsedSpans && line.markedSpans,
            found
          if (sps) {
            for (var sp = void 0, i = 0; i < sps.length; ++i) {
              sp = sps[i]
              if (
                sp.marker.collapsed &&
                (start ? sp.from : sp.to) == null &&
                (!found || compareCollapsedMarkers(found, sp.marker) < 0)
              ) {
                found = sp.marker
              }
            }
          }
          return found
        }
        function collapsedSpanAtStart(line) {
          return collapsedSpanAtSide(line, true)
        }
        function collapsedSpanAtEnd(line) {
          return collapsedSpanAtSide(line, false)
        }

        function collapsedSpanAround(line, ch) {
          var sps = sawCollapsedSpans && line.markedSpans,
            found
          if (sps) {
            for (var i = 0; i < sps.length; ++i) {
              var sp = sps[i]
              if (
                sp.marker.collapsed &&
                (sp.from == null || sp.from < ch) &&
                (sp.to == null || sp.to > ch) &&
                (!found || compareCollapsedMarkers(found, sp.marker) < 0)
              ) {
                found = sp.marker
              }
            }
          }
          return found
        }

        // Test whether there exists a collapsed span that partially
        // overlaps (covers the start or end, but not both) of a new span.
        // Such overlap is not allowed.
        function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
          var line = getLine(doc, lineNo)
          var sps = sawCollapsedSpans && line.markedSpans
          if (sps) {
            for (var i = 0; i < sps.length; ++i) {
              var sp = sps[i]
              if (!sp.marker.collapsed) {
                continue
              }
              var found = sp.marker.find(0)
              var fromCmp =
                cmp(found.from, from) ||
                extraLeft(sp.marker) - extraLeft(marker)
              var toCmp =
                cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)
              if (
                (fromCmp >= 0 && toCmp <= 0) ||
                (fromCmp <= 0 && toCmp >= 0)
              ) {
                continue
              }
              if (
                (fromCmp <= 0 &&
                  (sp.marker.inclusiveRight && marker.inclusiveLeft
                    ? cmp(found.to, from) >= 0
                    : cmp(found.to, from) > 0)) ||
                (fromCmp >= 0 &&
                  (sp.marker.inclusiveRight && marker.inclusiveLeft
                    ? cmp(found.from, to) <= 0
                    : cmp(found.from, to) < 0))
              ) {
                return true
              }
            }
          }
        }

        // A visual line is a line as drawn on the screen. Folding, for
        // example, can cause multiple logical lines to appear on the same
        // visual line. This finds the start of the visual line that the
        // given line is part of (usually that is the line itself).
        function visualLine(line) {
          var merged
          while ((merged = collapsedSpanAtStart(line))) {
            line = merged.find(-1, true).line
          }
          return line
        }

        function visualLineEnd(line) {
          var merged
          while ((merged = collapsedSpanAtEnd(line))) {
            line = merged.find(1, true).line
          }
          return line
        }

        // Returns an array of logical lines that continue the visual line
        // started by the argument, or undefined if there are no such lines.
        function visualLineContinued(line) {
          var merged, lines
          while ((merged = collapsedSpanAtEnd(line))) {
            line = merged.find(1, true).line
            ;(lines || (lines = [])).push(line)
          }
          return lines
        }

        // Get the line number of the start of the visual line that the
        // given line number is part of.
        function visualLineNo(doc, lineN) {
          var line = getLine(doc, lineN),
            vis = visualLine(line)
          if (line == vis) {
            return lineN
          }
          return lineNo(vis)
        }

        // Get the line number of the start of the next visual line after
        // the given line.
        function visualLineEndNo(doc, lineN) {
          if (lineN > doc.lastLine()) {
            return lineN
          }
          var line = getLine(doc, lineN),
            merged
          if (!lineIsHidden(doc, line)) {
            return lineN
          }
          while ((merged = collapsedSpanAtEnd(line))) {
            line = merged.find(1, true).line
          }
          return lineNo(line) + 1
        }

        // Compute whether a line is hidden. Lines count as hidden when they
        // are part of a visual line that starts with another line, or when
        // they are entirely covered by collapsed, non-widget span.
        function lineIsHidden(doc, line) {
          var sps = sawCollapsedSpans && line.markedSpans
          if (sps) {
            for (var sp = void 0, i = 0; i < sps.length; ++i) {
              sp = sps[i]
              if (!sp.marker.collapsed) {
                continue
              }
              if (sp.from == null) {
                return true
              }
              if (sp.marker.widgetNode) {
                continue
              }
              if (
                sp.from == 0 &&
                sp.marker.inclusiveLeft &&
                lineIsHiddenInner(doc, line, sp)
              ) {
                return true
              }
            }
          }
        }
        function lineIsHiddenInner(doc, line, span) {
          if (span.to == null) {
            var end = span.marker.find(1, true)
            return lineIsHiddenInner(
              doc,
              end.line,
              getMarkedSpanFor(end.line.markedSpans, span.marker)
            )
          }
          if (span.marker.inclusiveRight && span.to == line.text.length) {
            return true
          }
          for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
            sp = line.markedSpans[i]
            if (
              sp.marker.collapsed &&
              !sp.marker.widgetNode &&
              sp.from == span.to &&
              (sp.to == null || sp.to != span.from) &&
              (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
              lineIsHiddenInner(doc, line, sp)
            ) {
              return true
            }
          }
        }

        // Find the height above the given line.
        function heightAtLine(lineObj) {
          lineObj = visualLine(lineObj)

          var h = 0,
            chunk = lineObj.parent
          for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i]
            if (line == lineObj) {
              break
            } else {
              h += line.height
            }
          }
          for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
            for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
              var cur = p.children[i$1]
              if (cur == chunk) {
                break
              } else {
                h += cur.height
              }
            }
          }
          return h
        }

        // Compute the character length of a line, taking into account
        // collapsed ranges (see markText) that might hide parts, and join
        // other lines onto it.
        function lineLength(line) {
          if (line.height == 0) {
            return 0
          }
          var len = line.text.length,
            merged,
            cur = line
          while ((merged = collapsedSpanAtStart(cur))) {
            var found = merged.find(0, true)
            cur = found.from.line
            len += found.from.ch - found.to.ch
          }
          cur = line
          while ((merged = collapsedSpanAtEnd(cur))) {
            var found$1 = merged.find(0, true)
            len -= cur.text.length - found$1.from.ch
            cur = found$1.to.line
            len += cur.text.length - found$1.to.ch
          }
          return len
        }

        // Find the longest line in the document.
        function findMaxLine(cm) {
          var d = cm.display,
            doc = cm.doc
          d.maxLine = getLine(doc, doc.first)
          d.maxLineLength = lineLength(d.maxLine)
          d.maxLineChanged = true
          doc.iter(function (line) {
            var len = lineLength(line)
            if (len > d.maxLineLength) {
              d.maxLineLength = len
              d.maxLine = line
            }
          })
        }

        // LINE DATA STRUCTURE

        // Line objects. These hold state related to a line, including
        // highlighting info (the styles array).
        var Line = function (text, markedSpans, estimateHeight) {
          this.text = text
          attachMarkedSpans(this, markedSpans)
          this.height = estimateHeight ? estimateHeight(this) : 1
        }

        Line.prototype.lineNo = function () {
          return lineNo(this)
        }
        eventMixin(Line)

        // Change the content (text, markers) of a line. Automatically
        // invalidates cached information and tries to re-estimate the
        // line's height.
        function updateLine(line, text, markedSpans, estimateHeight) {
          line.text = text
          if (line.stateAfter) {
            line.stateAfter = null
          }
          if (line.styles) {
            line.styles = null
          }
          if (line.order != null) {
            line.order = null
          }
          detachMarkedSpans(line)
          attachMarkedSpans(line, markedSpans)
          var estHeight = estimateHeight ? estimateHeight(line) : 1
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight)
          }
        }

        // Detach a line from the document tree and its markers.
        function cleanUpLine(line) {
          line.parent = null
          detachMarkedSpans(line)
        }

        // Convert a style as returned by a mode (either null, or a string
        // containing one or more styles) to a CSS style. This is cached,
        // and also looks for line-wide styles.
        var styleToClassCache = {},
          styleToClassCacheWithMode = {}
        function interpretTokenStyle(style, options) {
          if (!style || /^\s*$/.test(style)) {
            return null
          }
          var cache = options.addModeClass
            ? styleToClassCacheWithMode
            : styleToClassCache
          return cache[style] || (cache[style] = style.replace(/\S+/g, 'cm-$&'))
        }

        // Render the DOM representation of the text of a line. Also builds
        // up a 'line map', which points at the DOM nodes that represent
        // specific stretches of text, and is used by the measuring code.
        // The returned object contains the DOM node, this map, and
        // information about line-wide styles that were set by the mode.
        function buildLineContent(cm, lineView) {
          // The padding-right forces the element to have a 'border', which
          // is needed on Webkit to be able to get line-level bounding
          // rectangles for it (in measureChar).
          var content = eltP(
            'span',
            null,
            null,
            webkit ? 'padding-right: .1px' : null
          )
          var builder = {
            pre: eltP('pre', [content], 'CodeMirror-line'),
            content: content,
            col: 0,
            pos: 0,
            cm: cm,
            trailingSpace: false,
            splitSpaces: cm.getOption('lineWrapping')
          }
          lineView.measure = {}

          // Iterate over the logical lines that make up this visual line.
          for (
            var i = 0;
            i <= (lineView.rest ? lineView.rest.length : 0);
            i++
          ) {
            var line = i ? lineView.rest[i - 1] : lineView.line,
              order = void 0
            builder.pos = 0
            builder.addToken = buildToken
            // Optionally wire in some hacks into the token-rendering
            // algorithm, to deal with browser quirks.
            if (
              hasBadBidiRects(cm.display.measure) &&
              (order = getOrder(line, cm.doc.direction))
            ) {
              builder.addToken = buildTokenBadBidi(builder.addToken, order)
            }
            builder.map = []
            var allowFrontierUpdate =
              lineView != cm.display.externalMeasured && lineNo(line)
            insertLineContent(
              line,
              builder,
              getLineStyles(cm, line, allowFrontierUpdate)
            )
            if (line.styleClasses) {
              if (line.styleClasses.bgClass) {
                builder.bgClass = joinClasses(
                  line.styleClasses.bgClass,
                  builder.bgClass || ''
                )
              }
              if (line.styleClasses.textClass) {
                builder.textClass = joinClasses(
                  line.styleClasses.textClass,
                  builder.textClass || ''
                )
              }
            }

            // Ensure at least a single node is present, for measuring.
            if (builder.map.length == 0) {
              builder.map.push(
                0,
                0,
                builder.content.appendChild(
                  zeroWidthElement(cm.display.measure)
                )
              )
            }

            // Store the map and a cache object for the current logical line
            if (i == 0) {
              lineView.measure.map = builder.map
              lineView.measure.cache = {}
            } else {
              ;(lineView.measure.maps || (lineView.measure.maps = [])).push(
                builder.map
              )
              ;(lineView.measure.caches || (lineView.measure.caches = [])).push(
                {}
              )
            }
          }

          // See issue #2901
          if (webkit) {
            var last = builder.content.lastChild
            if (
              /\bcm-tab\b/.test(last.className) ||
              (last.querySelector && last.querySelector('.cm-tab'))
            ) {
              builder.content.className = 'cm-tab-wrap-hack'
            }
          }

          signal(cm, 'renderLine', cm, lineView.line, builder.pre)
          if (builder.pre.className) {
            builder.textClass = joinClasses(
              builder.pre.className,
              builder.textClass || ''
            )
          }

          return builder
        }

        function defaultSpecialCharPlaceholder(ch) {
          var token = elt('span', '\u2022', 'cm-invalidchar')
          token.title = '\\u' + ch.charCodeAt(0).toString(16)
          token.setAttribute('aria-label', token.title)
          return token
        }

        // Build up the DOM representation for a single token, and add it to
        // the line map. Takes care to render special characters separately.
        function buildToken(
          builder,
          text,
          style,
          startStyle,
          endStyle,
          css,
          attributes
        ) {
          if (!text) {
            return
          }
          var displayText = builder.splitSpaces
            ? splitSpaces(text, builder.trailingSpace)
            : text
          var special = builder.cm.state.specialChars,
            mustWrap = false
          var content
          if (!special.test(text)) {
            builder.col += text.length
            content = document.createTextNode(displayText)
            builder.map.push(builder.pos, builder.pos + text.length, content)
            if (ie && ie_version < 9) {
              mustWrap = true
            }
            builder.pos += text.length
          } else {
            content = document.createDocumentFragment()
            var pos = 0
            while (true) {
              special.lastIndex = pos
              var m = special.exec(text)
              var skipped = m ? m.index - pos : text.length - pos
              if (skipped) {
                var txt = document.createTextNode(
                  displayText.slice(pos, pos + skipped)
                )
                if (ie && ie_version < 9) {
                  content.appendChild(elt('span', [txt]))
                } else {
                  content.appendChild(txt)
                }
                builder.map.push(builder.pos, builder.pos + skipped, txt)
                builder.col += skipped
                builder.pos += skipped
              }
              if (!m) {
                break
              }
              pos += skipped + 1
              var txt$1 = void 0
              if (m[0] == '\t') {
                var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - (builder.col % tabSize)
                txt$1 = content.appendChild(
                  elt('span', spaceStr(tabWidth), 'cm-tab')
                )
                txt$1.setAttribute('role', 'presentation')
                txt$1.setAttribute('cm-text', '\t')
                builder.col += tabWidth
              } else if (m[0] == '\r' || m[0] == '\n') {
                txt$1 = content.appendChild(
                  elt(
                    'span',
                    m[0] == '\r' ? '\u240d' : '\u2424',
                    'cm-invalidchar'
                  )
                )
                txt$1.setAttribute('cm-text', m[0])
                builder.col += 1
              } else {
                txt$1 = builder.cm.options.specialCharPlaceholder(m[0])
                txt$1.setAttribute('cm-text', m[0])
                if (ie && ie_version < 9) {
                  content.appendChild(elt('span', [txt$1]))
                } else {
                  content.appendChild(txt$1)
                }
                builder.col += 1
              }
              builder.map.push(builder.pos, builder.pos + 1, txt$1)
              builder.pos++
            }
          }
          builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
          if (
            style ||
            startStyle ||
            endStyle ||
            mustWrap ||
            css ||
            attributes
          ) {
            var fullStyle = style || ''
            if (startStyle) {
              fullStyle += startStyle
            }
            if (endStyle) {
              fullStyle += endStyle
            }
            var token = elt('span', [content], fullStyle, css)
            if (attributes) {
              for (var attr in attributes) {
                if (
                  attributes.hasOwnProperty(attr) &&
                  attr != 'style' &&
                  attr != 'class'
                ) {
                  token.setAttribute(attr, attributes[attr])
                }
              }
            }
            return builder.content.appendChild(token)
          }
          builder.content.appendChild(content)
        }

        // Change some spaces to NBSP to prevent the browser from collapsing
        // trailing spaces at the end of a line when rendering text (issue #1362).
        function splitSpaces(text, trailingBefore) {
          if (text.length > 1 && !/  /.test(text)) {
            return text
          }
          var spaceBefore = trailingBefore,
            result = ''
          for (var i = 0; i < text.length; i++) {
            var ch = text.charAt(i)
            if (
              ch == ' ' &&
              spaceBefore &&
              (i == text.length - 1 || text.charCodeAt(i + 1) == 32)
            ) {
              ch = '\u00a0'
            }
            result += ch
            spaceBefore = ch == ' '
          }
          return result
        }

        // Work around nonsense dimensions being reported for stretches of
        // right-to-left text.
        function buildTokenBadBidi(inner, order) {
          return function (
            builder,
            text,
            style,
            startStyle,
            endStyle,
            css,
            attributes
          ) {
            style = style ? style + ' cm-force-border' : 'cm-force-border'
            var start = builder.pos,
              end = start + text.length
            for (;;) {
              // Find the part that overlaps with the start of this text
              var part = void 0
              for (var i = 0; i < order.length; i++) {
                part = order[i]
                if (part.to > start && part.from <= start) {
                  break
                }
              }
              if (part.to >= end) {
                return inner(
                  builder,
                  text,
                  style,
                  startStyle,
                  endStyle,
                  css,
                  attributes
                )
              }
              inner(
                builder,
                text.slice(0, part.to - start),
                style,
                startStyle,
                null,
                css,
                attributes
              )
              startStyle = null
              text = text.slice(part.to - start)
              start = part.to
            }
          }
        }

        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
          var widget = !ignoreWidget && marker.widgetNode
          if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget)
          }
          if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget) {
              widget = builder.content.appendChild(
                document.createElement('span')
              )
            }
            widget.setAttribute('cm-marker', marker.id)
          }
          if (widget) {
            builder.cm.display.input.setUneditable(widget)
            builder.content.appendChild(widget)
          }
          builder.pos += size
          builder.trailingSpace = false
        }

        // Outputs a number of spans to make up a line, taking highlighting
        // and marked text into account.
        function insertLineContent(line, builder, styles) {
          var spans = line.markedSpans,
            allText = line.text,
            at = 0
          if (!spans) {
            for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
              builder.addToken(
                builder,
                allText.slice(at, (at = styles[i$1])),
                interpretTokenStyle(styles[i$1 + 1], builder.cm.options)
              )
            }
            return
          }

          var len = allText.length,
            pos = 0,
            i = 1,
            text = '',
            style,
            css
          var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            collapsed,
            attributes
          for (;;) {
            if (nextChange == pos) {
              // Update current marker set
              spanStyle = spanEndStyle = spanStartStyle = css = ''
              attributes = null
              collapsed = null
              nextChange = Infinity
              var foundBookmarks = [],
                endStyles = void 0
              for (var j = 0; j < spans.length; ++j) {
                var sp = spans[j],
                  m = sp.marker
                if (m.type == 'bookmark' && sp.from == pos && m.widgetNode) {
                  foundBookmarks.push(m)
                } else if (
                  sp.from <= pos &&
                  (sp.to == null ||
                    sp.to > pos ||
                    (m.collapsed && sp.to == pos && sp.from == pos))
                ) {
                  if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                    nextChange = sp.to
                    spanEndStyle = ''
                  }
                  if (m.className) {
                    spanStyle += ' ' + m.className
                  }
                  if (m.css) {
                    css = (css ? css + ';' : '') + m.css
                  }
                  if (m.startStyle && sp.from == pos) {
                    spanStartStyle += ' ' + m.startStyle
                  }
                  if (m.endStyle && sp.to == nextChange) {
                    ;(endStyles || (endStyles = [])).push(m.endStyle, sp.to)
                  }
                  // support for the old title property
                  // https://github.com/codemirror/CodeMirror/pull/5673
                  if (m.title) {
                    ;(attributes || (attributes = {})).title = m.title
                  }
                  if (m.attributes) {
                    for (var attr in m.attributes) {
                      ;(attributes || (attributes = {}))[attr] =
                        m.attributes[attr]
                    }
                  }
                  if (
                    m.collapsed &&
                    (!collapsed ||
                      compareCollapsedMarkers(collapsed.marker, m) < 0)
                  ) {
                    collapsed = sp
                  }
                } else if (sp.from > pos && nextChange > sp.from) {
                  nextChange = sp.from
                }
              }
              if (endStyles) {
                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                  if (endStyles[j$1 + 1] == nextChange) {
                    spanEndStyle += ' ' + endStyles[j$1]
                  }
                }
              }

              if (!collapsed || collapsed.from == pos) {
                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                  buildCollapsedSpan(builder, 0, foundBookmarks[j$2])
                }
              }
              if (collapsed && (collapsed.from || 0) == pos) {
                buildCollapsedSpan(
                  builder,
                  (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                  collapsed.marker,
                  collapsed.from == null
                )
                if (collapsed.to == null) {
                  return
                }
                if (collapsed.to == pos) {
                  collapsed = false
                }
              }
            }
            if (pos >= len) {
              break
            }

            var upto = Math.min(len, nextChange)
            while (true) {
              if (text) {
                var end = pos + text.length
                if (!collapsed) {
                  var tokenText = end > upto ? text.slice(0, upto - pos) : text
                  builder.addToken(
                    builder,
                    tokenText,
                    style ? style + spanStyle : spanStyle,
                    spanStartStyle,
                    pos + tokenText.length == nextChange ? spanEndStyle : '',
                    css,
                    attributes
                  )
                }
                if (end >= upto) {
                  text = text.slice(upto - pos)
                  pos = upto
                  break
                }
                pos = end
                spanStartStyle = ''
              }
              text = allText.slice(at, (at = styles[i++]))
              style = interpretTokenStyle(styles[i++], builder.cm.options)
            }
          }
        }

        // These objects are used to represent the visible (currently drawn)
        // part of the document. A LineView may correspond to multiple
        // logical lines, if those are connected by collapsed ranges.
        function LineView(doc, line, lineN) {
          // The starting line
          this.line = line
          // Continuing lines, if any
          this.rest = visualLineContinued(line)
          // Number of logical lines in this visual line
          this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1
          this.node = this.text = null
          this.hidden = lineIsHidden(doc, line)
        }

        // Create a range of LineView objects for the given lines.
        function buildViewArray(cm, from, to) {
          var array = [],
            nextPos
          for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)
            nextPos = pos + view.size
            array.push(view)
          }
          return array
        }

        var operationGroup = null

        function pushOperation(op) {
          if (operationGroup) {
            operationGroup.ops.push(op)
          } else {
            op.ownsGroup = operationGroup = {
              ops: [op],
              delayedCallbacks: []
            }
          }
        }

        function fireCallbacksForOps(group) {
          // Calls delayed callbacks and cursorActivity handlers until no
          // new ones appear
          var callbacks = group.delayedCallbacks,
            i = 0
          do {
            for (; i < callbacks.length; i++) {
              callbacks[i].call(null)
            }
            for (var j = 0; j < group.ops.length; j++) {
              var op = group.ops[j]
              if (op.cursorActivityHandlers) {
                while (
                  op.cursorActivityCalled < op.cursorActivityHandlers.length
                ) {
                  op.cursorActivityHandlers[op.cursorActivityCalled++].call(
                    null,
                    op.cm
                  )
                }
              }
            }
          } while (i < callbacks.length)
        }

        function finishOperation(op, endCb) {
          var group = op.ownsGroup
          if (!group) {
            return
          }

          try {
            fireCallbacksForOps(group)
          } finally {
            operationGroup = null
            endCb(group)
          }
        }

        var orphanDelayedCallbacks = null

        // Often, we want to signal events at a point where we are in the
        // middle of some work, but don't want the handler to start calling
        // other methods on the editor, which might be in an inconsistent
        // state or simply not expect any other events to happen.
        // signalLater looks whether there are any handlers, and schedules
        // them to be executed when the last operation ends, or, if no
        // operation is active, when a timeout fires.
        function signalLater(emitter, type /*, values...*/) {
          var arr = getHandlers(emitter, type)
          if (!arr.length) {
            return
          }
          var args = Array.prototype.slice.call(arguments, 2),
            list
          if (operationGroup) {
            list = operationGroup.delayedCallbacks
          } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks
          } else {
            list = orphanDelayedCallbacks = []
            setTimeout(fireOrphanDelayed, 0)
          }
          var loop = function (i) {
            list.push(function () {
              return arr[i].apply(null, args)
            })
          }

          for (var i = 0; i < arr.length; ++i) loop(i)
        }

        function fireOrphanDelayed() {
          var delayed = orphanDelayedCallbacks
          orphanDelayedCallbacks = null
          for (var i = 0; i < delayed.length; ++i) {
            delayed[i]()
          }
        }

        // When an aspect of a line changes, a string is added to
        // lineView.changes. This updates the relevant part of the line's
        // DOM structure.
        function updateLineForChanges(cm, lineView, lineN, dims) {
          for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j]
            if (type == 'text') {
              updateLineText(cm, lineView)
            } else if (type == 'gutter') {
              updateLineGutter(cm, lineView, lineN, dims)
            } else if (type == 'class') {
              updateLineClasses(cm, lineView)
            } else if (type == 'widget') {
              updateLineWidgets(cm, lineView, dims)
            }
          }
          lineView.changes = null
        }

        // Lines with gutter elements, widgets or a background class need to
        // be wrapped, and have the extra elements added to the wrapper div
        function ensureLineWrapped(lineView) {
          if (lineView.node == lineView.text) {
            lineView.node = elt('div', null, null, 'position: relative')
            if (lineView.text.parentNode) {
              lineView.text.parentNode.replaceChild(
                lineView.node,
                lineView.text
              )
            }
            lineView.node.appendChild(lineView.text)
            if (ie && ie_version < 8) {
              lineView.node.style.zIndex = 2
            }
          }
          return lineView.node
        }

        function updateLineBackground(cm, lineView) {
          var cls = lineView.bgClass
            ? lineView.bgClass + ' ' + (lineView.line.bgClass || '')
            : lineView.line.bgClass
          if (cls) {
            cls += ' CodeMirror-linebackground'
          }
          if (lineView.background) {
            if (cls) {
              lineView.background.className = cls
            } else {
              lineView.background.parentNode.removeChild(lineView.background)
              lineView.background = null
            }
          } else if (cls) {
            var wrap = ensureLineWrapped(lineView)
            lineView.background = wrap.insertBefore(
              elt('div', null, cls),
              wrap.firstChild
            )
            cm.display.input.setUneditable(lineView.background)
          }
        }

        // Wrapper around buildLineContent which will reuse the structure
        // in display.externalMeasured when possible.
        function getLineContent(cm, lineView) {
          var ext = cm.display.externalMeasured
          if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null
            lineView.measure = ext.measure
            return ext.built
          }
          return buildLineContent(cm, lineView)
        }

        // Redraw the line's text. Interacts with the background and text
        // classes because the mode may output tokens that influence these
        // classes.
        function updateLineText(cm, lineView) {
          var cls = lineView.text.className
          var built = getLineContent(cm, lineView)
          if (lineView.text == lineView.node) {
            lineView.node = built.pre
          }
          lineView.text.parentNode.replaceChild(built.pre, lineView.text)
          lineView.text = built.pre
          if (
            built.bgClass != lineView.bgClass ||
            built.textClass != lineView.textClass
          ) {
            lineView.bgClass = built.bgClass
            lineView.textClass = built.textClass
            updateLineClasses(cm, lineView)
          } else if (cls) {
            lineView.text.className = cls
          }
        }

        function updateLineClasses(cm, lineView) {
          updateLineBackground(cm, lineView)
          if (lineView.line.wrapClass) {
            ensureLineWrapped(lineView).className = lineView.line.wrapClass
          } else if (lineView.node != lineView.text) {
            lineView.node.className = ''
          }
          var textClass = lineView.textClass
            ? lineView.textClass + ' ' + (lineView.line.textClass || '')
            : lineView.line.textClass
          lineView.text.className = textClass || ''
        }

        function updateLineGutter(cm, lineView, lineN, dims) {
          if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter)
            lineView.gutter = null
          }
          if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground)
            lineView.gutterBackground = null
          }
          if (lineView.line.gutterClass) {
            var wrap = ensureLineWrapped(lineView)
            lineView.gutterBackground = elt(
              'div',
              null,
              'CodeMirror-gutter-background ' + lineView.line.gutterClass,
              'left: ' +
                (cm.options.fixedGutter
                  ? dims.fixedPos
                  : -dims.gutterTotalWidth) +
                'px; width: ' +
                dims.gutterTotalWidth +
                'px'
            )
            cm.display.input.setUneditable(lineView.gutterBackground)
            wrap.insertBefore(lineView.gutterBackground, lineView.text)
          }
          var markers = lineView.line.gutterMarkers
          if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView)
            var gutterWrap = (lineView.gutter = elt(
              'div',
              null,
              'CodeMirror-gutter-wrapper',
              'left: ' +
                (cm.options.fixedGutter
                  ? dims.fixedPos
                  : -dims.gutterTotalWidth) +
                'px'
            ))
            gutterWrap.setAttribute('aria-hidden', 'true')
            cm.display.input.setUneditable(gutterWrap)
            wrap$1.insertBefore(gutterWrap, lineView.text)
            if (lineView.line.gutterClass) {
              gutterWrap.className += ' ' + lineView.line.gutterClass
            }
            if (
              cm.options.lineNumbers &&
              (!markers || !markers['CodeMirror-linenumbers'])
            ) {
              lineView.lineNumber = gutterWrap.appendChild(
                elt(
                  'div',
                  lineNumberFor(cm.options, lineN),
                  'CodeMirror-linenumber CodeMirror-gutter-elt',
                  'left: ' +
                    dims.gutterLeft['CodeMirror-linenumbers'] +
                    'px; width: ' +
                    cm.display.lineNumInnerWidth +
                    'px'
                )
              )
            }
            if (markers) {
              for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
                var id = cm.display.gutterSpecs[k].className,
                  found = markers.hasOwnProperty(id) && markers[id]
                if (found) {
                  gutterWrap.appendChild(
                    elt(
                      'div',
                      [found],
                      'CodeMirror-gutter-elt',
                      'left: ' +
                        dims.gutterLeft[id] +
                        'px; width: ' +
                        dims.gutterWidth[id] +
                        'px'
                    )
                  )
                }
              }
            }
          }
        }

        function updateLineWidgets(cm, lineView, dims) {
          if (lineView.alignable) {
            lineView.alignable = null
          }
          var isWidget = classTest('CodeMirror-linewidget')
          for (
            var node = lineView.node.firstChild, next = void 0;
            node;
            node = next
          ) {
            next = node.nextSibling
            if (isWidget.test(node.className)) {
              lineView.node.removeChild(node)
            }
          }
          insertLineWidgets(cm, lineView, dims)
        }

        // Build a line's DOM representation from scratch
        function buildLineElement(cm, lineView, lineN, dims) {
          var built = getLineContent(cm, lineView)
          lineView.text = lineView.node = built.pre
          if (built.bgClass) {
            lineView.bgClass = built.bgClass
          }
          if (built.textClass) {
            lineView.textClass = built.textClass
          }

          updateLineClasses(cm, lineView)
          updateLineGutter(cm, lineView, lineN, dims)
          insertLineWidgets(cm, lineView, dims)
          return lineView.node
        }

        // A lineView may contain multiple logical lines (when merged by
        // collapsed spans). The widgets for all of them need to be drawn.
        function insertLineWidgets(cm, lineView, dims) {
          insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)
          if (lineView.rest) {
            for (var i = 0; i < lineView.rest.length; i++) {
              insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false)
            }
          }
        }

        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
          if (!line.widgets) {
            return
          }
          var wrap = ensureLineWrapped(lineView)
          for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
            var widget = ws[i],
              node = elt(
                'div',
                [widget.node],
                'CodeMirror-linewidget' +
                  (widget.className ? ' ' + widget.className : '')
              )
            if (!widget.handleMouseEvents) {
              node.setAttribute('cm-ignore-events', 'true')
            }
            positionLineWidget(widget, node, lineView, dims)
            cm.display.input.setUneditable(node)
            if (allowAbove && widget.above) {
              wrap.insertBefore(node, lineView.gutter || lineView.text)
            } else {
              wrap.appendChild(node)
            }
            signalLater(widget, 'redraw')
          }
        }

        function positionLineWidget(widget, node, lineView, dims) {
          if (widget.noHScroll) {
            ;(lineView.alignable || (lineView.alignable = [])).push(node)
            var width = dims.wrapperWidth
            node.style.left = dims.fixedPos + 'px'
            if (!widget.coverGutter) {
              width -= dims.gutterTotalWidth
              node.style.paddingLeft = dims.gutterTotalWidth + 'px'
            }
            node.style.width = width + 'px'
          }
          if (widget.coverGutter) {
            node.style.zIndex = 5
            node.style.position = 'relative'
            if (!widget.noHScroll) {
              node.style.marginLeft = -dims.gutterTotalWidth + 'px'
            }
          }
        }

        function widgetHeight(widget) {
          if (widget.height != null) {
            return widget.height
          }
          var cm = widget.doc.cm
          if (!cm) {
            return 0
          }
          if (!contains(document.body, widget.node)) {
            var parentStyle = 'position: relative;'
            if (widget.coverGutter) {
              parentStyle +=
                'margin-left: -' + cm.display.gutters.offsetWidth + 'px;'
            }
            if (widget.noHScroll) {
              parentStyle += 'width: ' + cm.display.wrapper.clientWidth + 'px;'
            }
            removeChildrenAndAdd(
              cm.display.measure,
              elt('div', [widget.node], null, parentStyle)
            )
          }
          return (widget.height = widget.node.parentNode.offsetHeight)
        }

        // Return true when the given mouse event happened in a widget
        function eventInWidget(display, e) {
          for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
            if (
              !n ||
              (n.nodeType == 1 &&
                n.getAttribute('cm-ignore-events') == 'true') ||
              (n.parentNode == display.sizer && n != display.mover)
            ) {
              return true
            }
          }
        }

        // POSITION MEASUREMENT

        function paddingTop(display) {
          return display.lineSpace.offsetTop
        }
        function paddingVert(display) {
          return display.mover.offsetHeight - display.lineSpace.offsetHeight
        }
        function paddingH(display) {
          if (display.cachedPaddingH) {
            return display.cachedPaddingH
          }
          var e = removeChildrenAndAdd(
            display.measure,
            elt('pre', 'x', 'CodeMirror-line-like')
          )
          var style = window.getComputedStyle
            ? window.getComputedStyle(e)
            : e.currentStyle
          var data = {
            left: parseInt(style.paddingLeft),
            right: parseInt(style.paddingRight)
          }
          if (!isNaN(data.left) && !isNaN(data.right)) {
            display.cachedPaddingH = data
          }
          return data
        }

        function scrollGap(cm) {
          return scrollerGap - cm.display.nativeBarWidth
        }
        function displayWidth(cm) {
          return (
            cm.display.scroller.clientWidth -
            scrollGap(cm) -
            cm.display.barWidth
          )
        }
        function displayHeight(cm) {
          return (
            cm.display.scroller.clientHeight -
            scrollGap(cm) -
            cm.display.barHeight
          )
        }

        // Ensure the lineView.wrapping.heights array is populated. This is
        // an array of bottom offsets for the lines that make up a drawn
        // line. When lineWrapping is on, there might be more than one
        // height.
        function ensureLineHeights(cm, lineView, rect) {
          var wrapping = cm.options.lineWrapping
          var curWidth = wrapping && displayWidth(cm)
          if (
            !lineView.measure.heights ||
            (wrapping && lineView.measure.width != curWidth)
          ) {
            var heights = (lineView.measure.heights = [])
            if (wrapping) {
              lineView.measure.width = curWidth
              var rects = lineView.text.firstChild.getClientRects()
              for (var i = 0; i < rects.length - 1; i++) {
                var cur = rects[i],
                  next = rects[i + 1]
                if (Math.abs(cur.bottom - next.bottom) > 2) {
                  heights.push((cur.bottom + next.top) / 2 - rect.top)
                }
              }
            }
            heights.push(rect.bottom - rect.top)
          }
        }

        // Find a line map (mapping character offsets to text nodes) and a
        // measurement cache for the given line number. (A line view might
        // contain multiple lines when collapsed ranges are present.)
        function mapFromLineView(lineView, line, lineN) {
          if (lineView.line == line) {
            return { map: lineView.measure.map, cache: lineView.measure.cache }
          }
          if (lineView.rest) {
            for (var i = 0; i < lineView.rest.length; i++) {
              if (lineView.rest[i] == line) {
                return {
                  map: lineView.measure.maps[i],
                  cache: lineView.measure.caches[i]
                }
              }
            }
            for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
              if (lineNo(lineView.rest[i$1]) > lineN) {
                return {
                  map: lineView.measure.maps[i$1],
                  cache: lineView.measure.caches[i$1],
                  before: true
                }
              }
            }
          }
        }

        // Render a line into the hidden node display.externalMeasured. Used
        // when measurement is needed for a line that's not in the viewport.
        function updateExternalMeasurement(cm, line) {
          line = visualLine(line)
          var lineN = lineNo(line)
          var view = (cm.display.externalMeasured = new LineView(
            cm.doc,
            line,
            lineN
          ))
          view.lineN = lineN
          var built = (view.built = buildLineContent(cm, view))
          view.text = built.pre
          removeChildrenAndAdd(cm.display.lineMeasure, built.pre)
          return view
        }

        // Get a {top, bottom, left, right} box (in line-local coordinates)
        // for a given character.
        function measureChar(cm, line, ch, bias) {
          return measureCharPrepared(
            cm,
            prepareMeasureForLine(cm, line),
            ch,
            bias
          )
        }

        // Find a line view that corresponds to the given line number.
        function findViewForLine(cm, lineN) {
          if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
            return cm.display.view[findViewIndex(cm, lineN)]
          }
          var ext = cm.display.externalMeasured
          if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
            return ext
          }
        }

        // Measurement can be split in two steps, the set-up work that
        // applies to the whole line, and the measurement of the actual
        // character. Functions like coordsChar, that need to do a lot of
        // measurements in a row, can thus ensure that the set-up work is
        // only done once.
        function prepareMeasureForLine(cm, line) {
          var lineN = lineNo(line)
          var view = findViewForLine(cm, lineN)
          if (view && !view.text) {
            view = null
          } else if (view && view.changes) {
            updateLineForChanges(cm, view, lineN, getDimensions(cm))
            cm.curOp.forceUpdate = true
          }
          if (!view) {
            view = updateExternalMeasurement(cm, line)
          }

          var info = mapFromLineView(view, line, lineN)
          return {
            line: line,
            view: view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
          }
        }

        // Given a prepared measurement object, measures the position of an
        // actual character (or fetches it from the cache).
        function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
          if (prepared.before) {
            ch = -1
          }
          var key = ch + (bias || ''),
            found
          if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key]
          } else {
            if (!prepared.rect) {
              prepared.rect = prepared.view.text.getBoundingClientRect()
            }
            if (!prepared.hasHeights) {
              ensureLineHeights(cm, prepared.view, prepared.rect)
              prepared.hasHeights = true
            }
            found = measureCharInner(cm, prepared, ch, bias)
            if (!found.bogus) {
              prepared.cache[key] = found
            }
          }
          return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
          }
        }

        var nullRect = { left: 0, right: 0, top: 0, bottom: 0 }

        function nodeAndOffsetInLineMap(map, ch, bias) {
          var node, start, end, collapse, mStart, mEnd
          // First, search the line map for the text node corresponding to,
          // or closest to, the target character.
          for (var i = 0; i < map.length; i += 3) {
            mStart = map[i]
            mEnd = map[i + 1]
            if (ch < mStart) {
              start = 0
              end = 1
              collapse = 'left'
            } else if (ch < mEnd) {
              start = ch - mStart
              end = start + 1
            } else if (i == map.length - 3 || (ch == mEnd && map[i + 3] > ch)) {
              end = mEnd - mStart
              start = end - 1
              if (ch >= mEnd) {
                collapse = 'right'
              }
            }
            if (start != null) {
              node = map[i + 2]
              if (
                mStart == mEnd &&
                bias == (node.insertLeft ? 'left' : 'right')
              ) {
                collapse = bias
              }
              if (bias == 'left' && start == 0) {
                while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                  node = map[(i -= 3) + 2]
                  collapse = 'left'
                }
              }
              if (bias == 'right' && start == mEnd - mStart) {
                while (
                  i < map.length - 3 &&
                  map[i + 3] == map[i + 4] &&
                  !map[i + 5].insertLeft
                ) {
                  node = map[(i += 3) + 2]
                  collapse = 'right'
                }
              }
              break
            }
          }
          return {
            node: node,
            start: start,
            end: end,
            collapse: collapse,
            coverStart: mStart,
            coverEnd: mEnd
          }
        }

        function getUsefulRect(rects, bias) {
          var rect = nullRect
          if (bias == 'left') {
            for (var i = 0; i < rects.length; i++) {
              if ((rect = rects[i]).left != rect.right) {
                break
              }
            }
          } else {
            for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
              if ((rect = rects[i$1]).left != rect.right) {
                break
              }
            }
          }
          return rect
        }

        function measureCharInner(cm, prepared, ch, bias) {
          var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)
          var node = place.node,
            start = place.start,
            end = place.end,
            collapse = place.collapse

          var rect
          if (node.nodeType == 3) {
            // If it is a text node, use a range to retrieve the coordinates.
            for (var i$1 = 0; i$1 < 4; i$1++) {
              // Retry a maximum of 4 times when nonsense rectangles are returned
              while (
                start &&
                isExtendingChar(
                  prepared.line.text.charAt(place.coverStart + start)
                )
              ) {
                --start
              }
              while (
                place.coverStart + end < place.coverEnd &&
                isExtendingChar(
                  prepared.line.text.charAt(place.coverStart + end)
                )
              ) {
                ++end
              }
              if (
                ie &&
                ie_version < 9 &&
                start == 0 &&
                end == place.coverEnd - place.coverStart
              ) {
                rect = node.parentNode.getBoundingClientRect()
              } else {
                rect = getUsefulRect(
                  range(node, start, end).getClientRects(),
                  bias
                )
              }
              if (rect.left || rect.right || start == 0) {
                break
              }
              end = start
              start = start - 1
              collapse = 'right'
            }
            if (ie && ie_version < 11) {
              rect = maybeUpdateRectForZooming(cm.display.measure, rect)
            }
          } else {
            // If it is a widget, simply get the box for the whole widget.
            if (start > 0) {
              collapse = bias = 'right'
            }
            var rects
            if (
              cm.options.lineWrapping &&
              (rects = node.getClientRects()).length > 1
            ) {
              rect = rects[bias == 'right' ? rects.length - 1 : 0]
            } else {
              rect = node.getBoundingClientRect()
            }
          }
          if (
            ie &&
            ie_version < 9 &&
            !start &&
            (!rect || (!rect.left && !rect.right))
          ) {
            var rSpan = node.parentNode.getClientRects()[0]
            if (rSpan) {
              rect = {
                left: rSpan.left,
                right: rSpan.left + charWidth(cm.display),
                top: rSpan.top,
                bottom: rSpan.bottom
              }
            } else {
              rect = nullRect
            }
          }

          var rtop = rect.top - prepared.rect.top,
            rbot = rect.bottom - prepared.rect.top
          var mid = (rtop + rbot) / 2
          var heights = prepared.view.measure.heights
          var i = 0
          for (; i < heights.length - 1; i++) {
            if (mid < heights[i]) {
              break
            }
          }
          var top = i ? heights[i - 1] : 0,
            bot = heights[i]
          var result = {
            left:
              (collapse == 'right' ? rect.right : rect.left) -
              prepared.rect.left,
            right:
              (collapse == 'left' ? rect.left : rect.right) -
              prepared.rect.left,
            top: top,
            bottom: bot
          }
          if (!rect.left && !rect.right) {
            result.bogus = true
          }
          if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop
            result.rbottom = rbot
          }

          return result
        }

        // Work around problem with bounding client rects on ranges being
        // returned incorrectly when zoomed on IE10 and below.
        function maybeUpdateRectForZooming(measure, rect) {
          if (
            !window.screen ||
            screen.logicalXDPI == null ||
            screen.logicalXDPI == screen.deviceXDPI ||
            !hasBadZoomedRects(measure)
          ) {
            return rect
          }
          var scaleX = screen.logicalXDPI / screen.deviceXDPI
          var scaleY = screen.logicalYDPI / screen.deviceYDPI
          return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
          }
        }

        function clearLineMeasurementCacheFor(lineView) {
          if (lineView.measure) {
            lineView.measure.cache = {}
            lineView.measure.heights = null
            if (lineView.rest) {
              for (var i = 0; i < lineView.rest.length; i++) {
                lineView.measure.caches[i] = {}
              }
            }
          }
        }

        function clearLineMeasurementCache(cm) {
          cm.display.externalMeasure = null
          removeChildren(cm.display.lineMeasure)
          for (var i = 0; i < cm.display.view.length; i++) {
            clearLineMeasurementCacheFor(cm.display.view[i])
          }
        }

        function clearCaches(cm) {
          clearLineMeasurementCache(cm)
          cm.display.cachedCharWidth =
            cm.display.cachedTextHeight =
            cm.display.cachedPaddingH =
              null
          if (!cm.options.lineWrapping) {
            cm.display.maxLineChanged = true
          }
          cm.display.lineNumChars = null
        }

        function pageScrollX() {
          // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
          // which causes page_Offset and bounding client rects to use
          // different reference viewports and invalidate our calculations.
          if (chrome && android) {
            return -(
              document.body.getBoundingClientRect().left -
              parseInt(getComputedStyle(document.body).marginLeft)
            )
          }
          return (
            window.pageXOffset ||
            (document.documentElement || document.body).scrollLeft
          )
        }
        function pageScrollY() {
          if (chrome && android) {
            return -(
              document.body.getBoundingClientRect().top -
              parseInt(getComputedStyle(document.body).marginTop)
            )
          }
          return (
            window.pageYOffset ||
            (document.documentElement || document.body).scrollTop
          )
        }

        function widgetTopHeight(lineObj) {
          var ref = visualLine(lineObj)
          var widgets = ref.widgets
          var height = 0
          if (widgets) {
            for (var i = 0; i < widgets.length; ++i) {
              if (widgets[i].above) {
                height += widgetHeight(widgets[i])
              }
            }
          }
          return height
        }

        // Converts a {top, bottom, left, right} box from line-local
        // coordinates into another coordinate system. Context may be one of
        // "line", "div" (display.lineDiv), "local"./null (editor), "window",
        // or "page".
        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
          if (!includeWidgets) {
            var height = widgetTopHeight(lineObj)
            rect.top += height
            rect.bottom += height
          }
          if (context == 'line') {
            return rect
          }
          if (!context) {
            context = 'local'
          }
          var yOff = heightAtLine(lineObj)
          if (context == 'local') {
            yOff += paddingTop(cm.display)
          } else {
            yOff -= cm.display.viewOffset
          }
          if (context == 'page' || context == 'window') {
            var lOff = cm.display.lineSpace.getBoundingClientRect()
            yOff += lOff.top + (context == 'window' ? 0 : pageScrollY())
            var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX())
            rect.left += xOff
            rect.right += xOff
          }
          rect.top += yOff
          rect.bottom += yOff
          return rect
        }

        // Coverts a box from "div" coords to another coordinate system.
        // Context may be "window", "page", "div", or "local"./null.
        function fromCoordSystem(cm, coords, context) {
          if (context == 'div') {
            return coords
          }
          var left = coords.left,
            top = coords.top
          // First move into "page" coordinate system
          if (context == 'page') {
            left -= pageScrollX()
            top -= pageScrollY()
          } else if (context == 'local' || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect()
            left += localBox.left
            top += localBox.top
          }

          var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()
          return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top }
        }

        function charCoords(cm, pos, context, lineObj, bias) {
          if (!lineObj) {
            lineObj = getLine(cm.doc, pos.line)
          }
          return intoCoordSystem(
            cm,
            lineObj,
            measureChar(cm, lineObj, pos.ch, bias),
            context
          )
        }

        // Returns a box for a given cursor position, which may have an
        // 'other' property containing the position of the secondary cursor
        // on a bidi boundary.
        // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
        // and after `char - 1` in writing order of `char - 1`
        // A cursor Pos(line, char, "after") is on the same visual line as `char`
        // and before `char` in writing order of `char`
        // Examples (upper-case letters are RTL, lower-case are LTR):
        //     Pos(0, 1, ...)
        //     before   after
        // ab     a|b     a|b
        // aB     a|B     aB|
        // Ab     |Ab     A|b
        // AB     B|A     B|A
        // Every position after the last character on a line is considered to stick
        // to the last character on the line.
        function cursorCoords(
          cm,
          pos,
          context,
          lineObj,
          preparedMeasure,
          varHeight
        ) {
          lineObj = lineObj || getLine(cm.doc, pos.line)
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj)
          }
          function get(ch, right) {
            var m = measureCharPrepared(
              cm,
              preparedMeasure,
              ch,
              right ? 'right' : 'left',
              varHeight
            )
            if (right) {
              m.left = m.right
            } else {
              m.right = m.left
            }
            return intoCoordSystem(cm, lineObj, m, context)
          }
          var order = getOrder(lineObj, cm.doc.direction),
            ch = pos.ch,
            sticky = pos.sticky
          if (ch >= lineObj.text.length) {
            ch = lineObj.text.length
            sticky = 'before'
          } else if (ch <= 0) {
            ch = 0
            sticky = 'after'
          }
          if (!order) {
            return get(sticky == 'before' ? ch - 1 : ch, sticky == 'before')
          }

          function getBidi(ch, partPos, invert) {
            var part = order[partPos],
              right = part.level == 1
            return get(invert ? ch - 1 : ch, right != invert)
          }
          var partPos = getBidiPartAt(order, ch, sticky)
          var other = bidiOther
          var val = getBidi(ch, partPos, sticky == 'before')
          if (other != null) {
            val.other = getBidi(ch, other, sticky != 'before')
          }
          return val
        }

        // Used to cheaply estimate the coordinates for a position. Used for
        // intermediate scroll updates.
        function estimateCoords(cm, pos) {
          var left = 0
          pos = clipPos(cm.doc, pos)
          if (!cm.options.lineWrapping) {
            left = charWidth(cm.display) * pos.ch
          }
          var lineObj = getLine(cm.doc, pos.line)
          var top = heightAtLine(lineObj) + paddingTop(cm.display)
          return {
            left: left,
            right: left,
            top: top,
            bottom: top + lineObj.height
          }
        }

        // Positions returned by coordsChar contain some extra information.
        // xRel is the relative x position of the input coordinates compared
        // to the found position (so xRel > 0 means the coordinates are to
        // the right of the character position, for example). When outside
        // is true, that means the coordinates lie outside the line's
        // vertical range.
        function PosWithInfo(line, ch, sticky, outside, xRel) {
          var pos = Pos(line, ch, sticky)
          pos.xRel = xRel
          if (outside) {
            pos.outside = outside
          }
          return pos
        }

        // Compute the character position closest to the given coordinates.
        // Input must be lineSpace-local ("div" coordinate system).
        function coordsChar(cm, x, y) {
          var doc = cm.doc
          y += cm.display.viewOffset
          if (y < 0) {
            return PosWithInfo(doc.first, 0, null, -1, -1)
          }
          var lineN = lineAtHeight(doc, y),
            last = doc.first + doc.size - 1
          if (lineN > last) {
            return PosWithInfo(
              doc.first + doc.size - 1,
              getLine(doc, last).text.length,
              null,
              1,
              1
            )
          }
          if (x < 0) {
            x = 0
          }

          var lineObj = getLine(doc, lineN)
          for (;;) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y)
            var collapsed = collapsedSpanAround(
              lineObj,
              found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0)
            )
            if (!collapsed) {
              return found
            }
            var rangeEnd = collapsed.find(1)
            if (rangeEnd.line == lineN) {
              return rangeEnd
            }
            lineObj = getLine(doc, (lineN = rangeEnd.line))
          }
        }

        function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
          y -= widgetTopHeight(lineObj)
          var end = lineObj.text.length
          var begin = findFirst(
            function (ch) {
              return (
                measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y
              )
            },
            end,
            0
          )
          end = findFirst(
            function (ch) {
              return measureCharPrepared(cm, preparedMeasure, ch).top > y
            },
            begin,
            end
          )
          return { begin: begin, end: end }
        }

        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj)
          }
          var targetTop = intoCoordSystem(
            cm,
            lineObj,
            measureCharPrepared(cm, preparedMeasure, target),
            'line'
          ).top
          return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
        }

        // Returns true if the given side of a box is after the given
        // coordinates, in top-to-bottom, left-to-right order.
        function boxIsAfter(box, x, y, left) {
          return box.bottom <= y
            ? false
            : box.top > y
            ? true
            : (left ? box.left : box.right) > x
        }

        function coordsCharInner(cm, lineObj, lineNo, x, y) {
          // Move y into line-local coordinate space
          y -= heightAtLine(lineObj)
          var preparedMeasure = prepareMeasureForLine(cm, lineObj)
          // When directly calling `measureCharPrepared`, we have to adjust
          // for the widgets at this line.
          var widgetHeight = widgetTopHeight(lineObj)
          var begin = 0,
            end = lineObj.text.length,
            ltr = true

          var order = getOrder(lineObj, cm.doc.direction)
          // If the line isn't plain left-to-right text, first figure out
          // which bidi section the coordinates fall into.
          if (order) {
            var part = (
              cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart
            )(cm, lineObj, lineNo, preparedMeasure, order, x, y)
            ltr = part.level != 1
            // The awkward -1 offsets are needed because findFirst (called
            // on these below) will treat its first bound as inclusive,
            // second as exclusive, but we want to actually address the
            // characters in the part's range
            begin = ltr ? part.from : part.to - 1
            end = ltr ? part.to : part.from - 1
          }

          // A binary search to find the first character whose bounding box
          // starts after the coordinates. If we run across any whose box wrap
          // the coordinates, store that.
          var chAround = null,
            boxAround = null
          var ch = findFirst(
            function (ch) {
              var box = measureCharPrepared(cm, preparedMeasure, ch)
              box.top += widgetHeight
              box.bottom += widgetHeight
              if (!boxIsAfter(box, x, y, false)) {
                return false
              }
              if (box.top <= y && box.left <= x) {
                chAround = ch
                boxAround = box
              }
              return true
            },
            begin,
            end
          )

          var baseX,
            sticky,
            outside = false
          // If a box around the coordinates was found, use that
          if (boxAround) {
            // Distinguish coordinates nearer to the left or right side of the box
            var atLeft = x - boxAround.left < boxAround.right - x,
              atStart = atLeft == ltr
            ch = chAround + (atStart ? 0 : 1)
            sticky = atStart ? 'after' : 'before'
            baseX = atLeft ? boxAround.left : boxAround.right
          } else {
            // (Adjust for extended bound, if necessary.)
            if (!ltr && (ch == end || ch == begin)) {
              ch++
            }
            // To determine which side to associate with, get the box to the
            // left of the character and compare it's vertical position to the
            // coordinates
            sticky =
              ch == 0
                ? 'after'
                : ch == lineObj.text.length
                ? 'before'
                : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0))
                    .bottom +
                    widgetHeight <=
                    y ==
                  ltr
                ? 'after'
                : 'before'
            // Now get accurate coordinates for this place, in order to get a
            // base X position
            var coords = cursorCoords(
              cm,
              Pos(lineNo, ch, sticky),
              'line',
              lineObj,
              preparedMeasure
            )
            baseX = coords.left
            outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0
          }

          ch = skipExtendingChars(lineObj.text, ch, 1)
          return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
        }

        function coordsBidiPart(
          cm,
          lineObj,
          lineNo,
          preparedMeasure,
          order,
          x,
          y
        ) {
          // Bidi parts are sorted left-to-right, and in a non-line-wrapping
          // situation, we can take this ordering to correspond to the visual
          // ordering. This finds the first part whose end is after the given
          // coordinates.
          var index = findFirst(
            function (i) {
              var part = order[i],
                ltr = part.level != 1
              return boxIsAfter(
                cursorCoords(
                  cm,
                  Pos(
                    lineNo,
                    ltr ? part.to : part.from,
                    ltr ? 'before' : 'after'
                  ),
                  'line',
                  lineObj,
                  preparedMeasure
                ),
                x,
                y,
                true
              )
            },
            0,
            order.length - 1
          )
          var part = order[index]
          // If this isn't the first part, the part's start is also after
          // the coordinates, and the coordinates aren't on the same line as
          // that start, move one part back.
          if (index > 0) {
            var ltr = part.level != 1
            var start = cursorCoords(
              cm,
              Pos(lineNo, ltr ? part.from : part.to, ltr ? 'after' : 'before'),
              'line',
              lineObj,
              preparedMeasure
            )
            if (boxIsAfter(start, x, y, true) && start.top > y) {
              part = order[index - 1]
            }
          }
          return part
        }

        function coordsBidiPartWrapped(
          cm,
          lineObj,
          _lineNo,
          preparedMeasure,
          order,
          x,
          y
        ) {
          // In a wrapped line, rtl text on wrapping boundaries can do things
          // that don't correspond to the ordering in our `order` array at
          // all, so a binary search doesn't work, and we want to return a
          // part that only spans one line so that the binary search in
          // coordsCharInner is safe. As such, we first find the extent of the
          // wrapped line, and then do a flat search in which we discard any
          // spans that aren't on the line.
          var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y)
          var begin = ref.begin
          var end = ref.end
          if (/\s/.test(lineObj.text.charAt(end - 1))) {
            end--
          }
          var part = null,
            closestDist = null
          for (var i = 0; i < order.length; i++) {
            var p = order[i]
            if (p.from >= end || p.to <= begin) {
              continue
            }
            var ltr = p.level != 1
            var endX = measureCharPrepared(
              cm,
              preparedMeasure,
              ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)
            ).right
            // Weigh against spans ending before this, so that they are only
            // picked if nothing ends after
            var dist = endX < x ? x - endX + 1e9 : endX - x
            if (!part || closestDist > dist) {
              part = p
              closestDist = dist
            }
          }
          if (!part) {
            part = order[order.length - 1]
          }
          // Clip the part to the wrapped line.
          if (part.from < begin) {
            part = { from: begin, to: part.to, level: part.level }
          }
          if (part.to > end) {
            part = { from: part.from, to: end, level: part.level }
          }
          return part
        }

        var measureText
        // Compute the default text height.
        function textHeight(display) {
          if (display.cachedTextHeight != null) {
            return display.cachedTextHeight
          }
          if (measureText == null) {
            measureText = elt('pre', null, 'CodeMirror-line-like')
            // Measure a bunch of lines, for browsers that compute
            // fractional heights.
            for (var i = 0; i < 49; ++i) {
              measureText.appendChild(document.createTextNode('x'))
              measureText.appendChild(elt('br'))
            }
            measureText.appendChild(document.createTextNode('x'))
          }
          removeChildrenAndAdd(display.measure, measureText)
          var height = measureText.offsetHeight / 50
          if (height > 3) {
            display.cachedTextHeight = height
          }
          removeChildren(display.measure)
          return height || 1
        }

        // Compute the default character width.
        function charWidth(display) {
          if (display.cachedCharWidth != null) {
            return display.cachedCharWidth
          }
          var anchor = elt('span', 'xxxxxxxxxx')
          var pre = elt('pre', [anchor], 'CodeMirror-line-like')
          removeChildrenAndAdd(display.measure, pre)
          var rect = anchor.getBoundingClientRect(),
            width = (rect.right - rect.left) / 10
          if (width > 2) {
            display.cachedCharWidth = width
          }
          return width || 10
        }

        // Do a bulk-read of the DOM positions and sizes needed to draw the
        // view, so that we don't interleave reading and writing to the DOM.
        function getDimensions(cm) {
          var d = cm.display,
            left = {},
            width = {}
          var gutterLeft = d.gutters.clientLeft
          for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
            var id = cm.display.gutterSpecs[i].className
            left[id] = n.offsetLeft + n.clientLeft + gutterLeft
            width[id] = n.clientWidth
          }
          return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
          }
        }

        // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
        // but using getBoundingClientRect to get a sub-pixel-accurate
        // result.
        function compensateForHScroll(display) {
          return (
            display.scroller.getBoundingClientRect().left -
            display.sizer.getBoundingClientRect().left
          )
        }

        // Returns a function that estimates the height of a line, to use as
        // first approximation until the line becomes visible (and is thus
        // properly measurable).
        function estimateHeight(cm) {
          var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping
          var perLine =
            wrapping &&
            Math.max(
              5,
              cm.display.scroller.clientWidth / charWidth(cm.display) - 3
            )
          return function (line) {
            if (lineIsHidden(cm.doc, line)) {
              return 0
            }

            var widgetsHeight = 0
            if (line.widgets) {
              for (var i = 0; i < line.widgets.length; i++) {
                if (line.widgets[i].height) {
                  widgetsHeight += line.widgets[i].height
                }
              }
            }

            if (wrapping) {
              return (
                widgetsHeight +
                (Math.ceil(line.text.length / perLine) || 1) * th
              )
            } else {
              return widgetsHeight + th
            }
          }
        }

        function estimateLineHeights(cm) {
          var doc = cm.doc,
            est = estimateHeight(cm)
          doc.iter(function (line) {
            var estHeight = est(line)
            if (estHeight != line.height) {
              updateLineHeight(line, estHeight)
            }
          })
        }

        // Given a mouse event, find the corresponding position. If liberal
        // is false, it checks whether a gutter or scrollbar was clicked,
        // and returns null if it was. forRect is used by rectangular
        // selections, and tries to estimate a character position even for
        // coordinates beyond the right of the text.
        function posFromMouse(cm, e, liberal, forRect) {
          var display = cm.display
          if (
            !liberal &&
            e_target(e).getAttribute('cm-not-content') == 'true'
          ) {
            return null
          }

          var x,
            y,
            space = display.lineSpace.getBoundingClientRect()
          // Fails unpredictably on IE[67] when mouse is dragged around quickly.
          try {
            x = e.clientX - space.left
            y = e.clientY - space.top
          } catch (e$1) {
            return null
          }
          var coords = coordsChar(cm, x, y),
            line
          if (
            forRect &&
            coords.xRel > 0 &&
            (line = getLine(cm.doc, coords.line).text).length == coords.ch
          ) {
            var colDiff =
              countColumn(line, line.length, cm.options.tabSize) - line.length
            coords = Pos(
              coords.line,
              Math.max(
                0,
                Math.round(
                  (x - paddingH(cm.display).left) / charWidth(cm.display)
                ) - colDiff
              )
            )
          }
          return coords
        }

        // Find the view element corresponding to a given line. Return null
        // when the line isn't visible.
        function findViewIndex(cm, n) {
          if (n >= cm.display.viewTo) {
            return null
          }
          n -= cm.display.viewFrom
          if (n < 0) {
            return null
          }
          var view = cm.display.view
          for (var i = 0; i < view.length; i++) {
            n -= view[i].size
            if (n < 0) {
              return i
            }
          }
        }

        // Updates the display.view data structure for a given change to the
        // document. From and to are in pre-change coordinates. Lendiff is
        // the amount of lines added or subtracted by the change. This is
        // used for changes that span multiple lines, or change the way
        // lines are divided into visual lines. regLineChange (below)
        // registers single-line changes.
        function regChange(cm, from, to, lendiff) {
          if (from == null) {
            from = cm.doc.first
          }
          if (to == null) {
            to = cm.doc.first + cm.doc.size
          }
          if (!lendiff) {
            lendiff = 0
          }

          var display = cm.display
          if (
            lendiff &&
            to < display.viewTo &&
            (display.updateLineNumbers == null ||
              display.updateLineNumbers > from)
          ) {
            display.updateLineNumbers = from
          }

          cm.curOp.viewChanged = true

          if (from >= display.viewTo) {
            // Change after
            if (
              sawCollapsedSpans &&
              visualLineNo(cm.doc, from) < display.viewTo
            ) {
              resetView(cm)
            }
          } else if (to <= display.viewFrom) {
            // Change before
            if (
              sawCollapsedSpans &&
              visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom
            ) {
              resetView(cm)
            } else {
              display.viewFrom += lendiff
              display.viewTo += lendiff
            }
          } else if (from <= display.viewFrom && to >= display.viewTo) {
            // Full overlap
            resetView(cm)
          } else if (from <= display.viewFrom) {
            // Top overlap
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1)
            if (cut) {
              display.view = display.view.slice(cut.index)
              display.viewFrom = cut.lineN
              display.viewTo += lendiff
            } else {
              resetView(cm)
            }
          } else if (to >= display.viewTo) {
            // Bottom overlap
            var cut$1 = viewCuttingPoint(cm, from, from, -1)
            if (cut$1) {
              display.view = display.view.slice(0, cut$1.index)
              display.viewTo = cut$1.lineN
            } else {
              resetView(cm)
            }
          } else {
            // Gap in the middle
            var cutTop = viewCuttingPoint(cm, from, from, -1)
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)
            if (cutTop && cutBot) {
              display.view = display.view
                .slice(0, cutTop.index)
                .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
                .concat(display.view.slice(cutBot.index))
              display.viewTo += lendiff
            } else {
              resetView(cm)
            }
          }

          var ext = display.externalMeasured
          if (ext) {
            if (to < ext.lineN) {
              ext.lineN += lendiff
            } else if (from < ext.lineN + ext.size) {
              display.externalMeasured = null
            }
          }
        }

        // Register a change to a single line. Type must be one of "text",
        // "gutter", "class", "widget"
        function regLineChange(cm, line, type) {
          cm.curOp.viewChanged = true
          var display = cm.display,
            ext = cm.display.externalMeasured
          if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
            display.externalMeasured = null
          }

          if (line < display.viewFrom || line >= display.viewTo) {
            return
          }
          var lineView = display.view[findViewIndex(cm, line)]
          if (lineView.node == null) {
            return
          }
          var arr = lineView.changes || (lineView.changes = [])
          if (indexOf(arr, type) == -1) {
            arr.push(type)
          }
        }

        // Clear the view.
        function resetView(cm) {
          cm.display.viewFrom = cm.display.viewTo = cm.doc.first
          cm.display.view = []
          cm.display.viewOffset = 0
        }

        function viewCuttingPoint(cm, oldN, newN, dir) {
          var index = findViewIndex(cm, oldN),
            diff,
            view = cm.display.view
          if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
            return { index: index, lineN: newN }
          }
          var n = cm.display.viewFrom
          for (var i = 0; i < index; i++) {
            n += view[i].size
          }
          if (n != oldN) {
            if (dir > 0) {
              if (index == view.length - 1) {
                return null
              }
              diff = n + view[index].size - oldN
              index++
            } else {
              diff = n - oldN
            }
            oldN += diff
            newN += diff
          }
          while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1)) {
              return null
            }
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size
            index += dir
          }
          return { index: index, lineN: newN }
        }

        // Force the view to cover a given range, adding empty view element
        // or clipping off existing ones as needed.
        function adjustView(cm, from, to) {
          var display = cm.display,
            view = display.view
          if (
            view.length == 0 ||
            from >= display.viewTo ||
            to <= display.viewFrom
          ) {
            display.view = buildViewArray(cm, from, to)
            display.viewFrom = from
          } else {
            if (display.viewFrom > from) {
              display.view = buildViewArray(cm, from, display.viewFrom).concat(
                display.view
              )
            } else if (display.viewFrom < from) {
              display.view = display.view.slice(findViewIndex(cm, from))
            }
            display.viewFrom = from
            if (display.viewTo < to) {
              display.view = display.view.concat(
                buildViewArray(cm, display.viewTo, to)
              )
            } else if (display.viewTo > to) {
              display.view = display.view.slice(0, findViewIndex(cm, to))
            }
          }
          display.viewTo = to
        }

        // Count the number of lines in the view whose DOM representation is
        // out of date (or nonexistent).
        function countDirtyView(cm) {
          var view = cm.display.view,
            dirty = 0
          for (var i = 0; i < view.length; i++) {
            var lineView = view[i]
            if (!lineView.hidden && (!lineView.node || lineView.changes)) {
              ++dirty
            }
          }
          return dirty
        }

        function updateSelection(cm) {
          cm.display.input.showSelection(cm.display.input.prepareSelection())
        }

        function prepareSelection(cm, primary) {
          if (primary === void 0) primary = true

          var doc = cm.doc,
            result = {}
          var curFragment = (result.cursors = document.createDocumentFragment())
          var selFragment = (result.selection =
            document.createDocumentFragment())

          var customCursor = cm.options.$customCursor
          if (customCursor) {
            primary = true
          }
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            if (!primary && i == doc.sel.primIndex) {
              continue
            }
            var range = doc.sel.ranges[i]
            if (
              range.from().line >= cm.display.viewTo ||
              range.to().line < cm.display.viewFrom
            ) {
              continue
            }
            var collapsed = range.empty()
            if (customCursor) {
              var head = customCursor(cm, range)
              if (head) {
                drawSelectionCursor(cm, head, curFragment)
              }
            } else if (collapsed || cm.options.showCursorWhenSelecting) {
              drawSelectionCursor(cm, range.head, curFragment)
            }
            if (!collapsed) {
              drawSelectionRange(cm, range, selFragment)
            }
          }
          return result
        }

        // Draws a cursor for the given range
        function drawSelectionCursor(cm, head, output) {
          var pos = cursorCoords(
            cm,
            head,
            'div',
            null,
            null,
            !cm.options.singleCursorHeightPerLine
          )

          var cursor = output.appendChild(
            elt('div', '\u00a0', 'CodeMirror-cursor')
          )
          cursor.style.left = pos.left + 'px'
          cursor.style.top = pos.top + 'px'
          cursor.style.height =
            Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px'

          if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
            var charPos = charCoords(cm, head, 'div', null, null)
            var width = charPos.right - charPos.left
            cursor.style.width =
              (width > 0 ? width : cm.defaultCharWidth()) + 'px'
          }

          if (pos.other) {
            // Secondary cursor, shown when on a 'jump' in bi-directional text
            var otherCursor = output.appendChild(
              elt(
                'div',
                '\u00a0',
                'CodeMirror-cursor CodeMirror-secondarycursor'
              )
            )
            otherCursor.style.display = ''
            otherCursor.style.left = pos.other.left + 'px'
            otherCursor.style.top = pos.other.top + 'px'
            otherCursor.style.height =
              (pos.other.bottom - pos.other.top) * 0.85 + 'px'
          }
        }

        function cmpCoords(a, b) {
          return a.top - b.top || a.left - b.left
        }

        // Draws the given range as a highlighted selection
        function drawSelectionRange(cm, range, output) {
          var display = cm.display,
            doc = cm.doc
          var fragment = document.createDocumentFragment()
          var padding = paddingH(cm.display),
            leftSide = padding.left
          var rightSide =
            Math.max(
              display.sizerWidth,
              displayWidth(cm) - display.sizer.offsetLeft
            ) - padding.right
          var docLTR = doc.direction == 'ltr'

          function add(left, top, width, bottom) {
            if (top < 0) {
              top = 0
            }
            top = Math.round(top)
            bottom = Math.round(bottom)
            fragment.appendChild(
              elt(
                'div',
                null,
                'CodeMirror-selected',
                'position: absolute; left: ' +
                  left +
                  'px;\n                             top: ' +
                  top +
                  'px; width: ' +
                  (width == null ? rightSide - left : width) +
                  'px;\n                             height: ' +
                  (bottom - top) +
                  'px'
              )
            )
          }

          function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc, line)
            var lineLen = lineObj.text.length
            var start, end
            function coords(ch, bias) {
              return charCoords(cm, Pos(line, ch), 'div', lineObj, bias)
            }

            function wrapX(pos, dir, side) {
              var extent = wrappedLineExtentChar(cm, lineObj, null, pos)
              var prop = (dir == 'ltr') == (side == 'after') ? 'left' : 'right'
              var ch =
                side == 'after'
                  ? extent.begin
                  : extent.end -
                    (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1)
              return coords(ch, prop)[prop]
            }

            var order = getOrder(lineObj, doc.direction)
            iterateBidiSections(
              order,
              fromArg || 0,
              toArg == null ? lineLen : toArg,
              function (from, to, dir, i) {
                var ltr = dir == 'ltr'
                var fromPos = coords(from, ltr ? 'left' : 'right')
                var toPos = coords(to - 1, ltr ? 'right' : 'left')

                var openStart = fromArg == null && from == 0,
                  openEnd = toArg == null && to == lineLen
                var first = i == 0,
                  last = !order || i == order.length - 1
                if (toPos.top - fromPos.top <= 3) {
                  // Single line
                  var openLeft = (docLTR ? openStart : openEnd) && first
                  var openRight = (docLTR ? openEnd : openStart) && last
                  var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left
                  var right = openRight
                    ? rightSide
                    : (ltr ? toPos : fromPos).right
                  add(left, fromPos.top, right - left, fromPos.bottom)
                } else {
                  // Multiple lines
                  var topLeft, topRight, botLeft, botRight
                  if (ltr) {
                    topLeft =
                      docLTR && openStart && first ? leftSide : fromPos.left
                    topRight = docLTR ? rightSide : wrapX(from, dir, 'before')
                    botLeft = docLTR ? leftSide : wrapX(to, dir, 'after')
                    botRight =
                      docLTR && openEnd && last ? rightSide : toPos.right
                  } else {
                    topLeft = !docLTR ? leftSide : wrapX(from, dir, 'before')
                    topRight =
                      !docLTR && openStart && first ? rightSide : fromPos.right
                    botLeft = !docLTR && openEnd && last ? leftSide : toPos.left
                    botRight = !docLTR ? rightSide : wrapX(to, dir, 'after')
                  }
                  add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom)
                  if (fromPos.bottom < toPos.top) {
                    add(leftSide, fromPos.bottom, null, toPos.top)
                  }
                  add(botLeft, toPos.top, botRight - botLeft, toPos.bottom)
                }

                if (!start || cmpCoords(fromPos, start) < 0) {
                  start = fromPos
                }
                if (cmpCoords(toPos, start) < 0) {
                  start = toPos
                }
                if (!end || cmpCoords(fromPos, end) < 0) {
                  end = fromPos
                }
                if (cmpCoords(toPos, end) < 0) {
                  end = toPos
                }
              }
            )
            return { start: start, end: end }
          }

          var sFrom = range.from(),
            sTo = range.to()
          if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch)
          } else {
            var fromLine = getLine(doc, sFrom.line),
              toLine = getLine(doc, sTo.line)
            var singleVLine = visualLine(fromLine) == visualLine(toLine)
            var leftEnd = drawForLine(
              sFrom.line,
              sFrom.ch,
              singleVLine ? fromLine.text.length + 1 : null
            ).end
            var rightStart = drawForLine(
              sTo.line,
              singleVLine ? 0 : null,
              sTo.ch
            ).start
            if (singleVLine) {
              if (leftEnd.top < rightStart.top - 2) {
                add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)
                add(
                  leftSide,
                  rightStart.top,
                  rightStart.left,
                  rightStart.bottom
                )
              } else {
                add(
                  leftEnd.right,
                  leftEnd.top,
                  rightStart.left - leftEnd.right,
                  leftEnd.bottom
                )
              }
            }
            if (leftEnd.bottom < rightStart.top) {
              add(leftSide, leftEnd.bottom, null, rightStart.top)
            }
          }

          output.appendChild(fragment)
        }

        // Cursor-blinking
        function restartBlink(cm) {
          if (!cm.state.focused) {
            return
          }
          var display = cm.display
          clearInterval(display.blinker)
          var on = true
          display.cursorDiv.style.visibility = ''
          if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function () {
              if (!cm.hasFocus()) {
                onBlur(cm)
              }
              display.cursorDiv.style.visibility = (on = !on) ? '' : 'hidden'
            }, cm.options.cursorBlinkRate)
          } else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = 'hidden'
          }
        }

        function ensureFocus(cm) {
          if (!cm.hasFocus()) {
            cm.display.input.focus()
            if (!cm.state.focused) {
              onFocus(cm)
            }
          }
        }

        function delayBlurEvent(cm) {
          cm.state.delayingBlurEvent = true
          setTimeout(function () {
            if (cm.state.delayingBlurEvent) {
              cm.state.delayingBlurEvent = false
              if (cm.state.focused) {
                onBlur(cm)
              }
            }
          }, 100)
        }

        function onFocus(cm, e) {
          if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
            cm.state.delayingBlurEvent = false
          }

          if (cm.options.readOnly == 'nocursor') {
            return
          }
          if (!cm.state.focused) {
            signal(cm, 'focus', cm, e)
            cm.state.focused = true
            addClass(cm.display.wrapper, 'CodeMirror-focused')
            // This test prevents this from firing when a context
            // menu is closed (since the input reset would kill the
            // select-all detection hack)
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
              cm.display.input.reset()
              if (webkit) {
                setTimeout(function () {
                  return cm.display.input.reset(true)
                }, 20)
              } // Issue #1730
            }
            cm.display.input.receivedFocus()
          }
          restartBlink(cm)
        }
        function onBlur(cm, e) {
          if (cm.state.delayingBlurEvent) {
            return
          }

          if (cm.state.focused) {
            signal(cm, 'blur', cm, e)
            cm.state.focused = false
            rmClass(cm.display.wrapper, 'CodeMirror-focused')
          }
          clearInterval(cm.display.blinker)
          setTimeout(function () {
            if (!cm.state.focused) {
              cm.display.shift = false
            }
          }, 150)
        }

        // Read the actual heights of the rendered lines, and update their
        // stored heights to match.
        function updateHeightsInViewport(cm) {
          var display = cm.display
          var prevBottom = display.lineDiv.offsetTop
          var viewTop = Math.max(
            0,
            display.scroller.getBoundingClientRect().top
          )
          var oldHeight = display.lineDiv.getBoundingClientRect().top
          var mustScroll = 0
          for (var i = 0; i < display.view.length; i++) {
            var cur = display.view[i],
              wrapping = cm.options.lineWrapping
            var height = void 0,
              width = 0
            if (cur.hidden) {
              continue
            }
            oldHeight += cur.line.height
            if (ie && ie_version < 8) {
              var bot = cur.node.offsetTop + cur.node.offsetHeight
              height = bot - prevBottom
              prevBottom = bot
            } else {
              var box = cur.node.getBoundingClientRect()
              height = box.bottom - box.top
              // Check that lines don't extend past the right of the current
              // editor width
              if (!wrapping && cur.text.firstChild) {
                width =
                  cur.text.firstChild.getBoundingClientRect().right -
                  box.left -
                  1
              }
            }
            var diff = cur.line.height - height
            if (diff > 0.005 || diff < -0.005) {
              if (oldHeight < viewTop) {
                mustScroll -= diff
              }
              updateLineHeight(cur.line, height)
              updateWidgetHeight(cur.line)
              if (cur.rest) {
                for (var j = 0; j < cur.rest.length; j++) {
                  updateWidgetHeight(cur.rest[j])
                }
              }
            }
            if (width > cm.display.sizerWidth) {
              var chWidth = Math.ceil(width / charWidth(cm.display))
              if (chWidth > cm.display.maxLineLength) {
                cm.display.maxLineLength = chWidth
                cm.display.maxLine = cur.line
                cm.display.maxLineChanged = true
              }
            }
          }
          if (Math.abs(mustScroll) > 2) {
            display.scroller.scrollTop += mustScroll
          }
        }

        // Read and store the height of line widgets associated with the
        // given line.
        function updateWidgetHeight(line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; ++i) {
              var w = line.widgets[i],
                parent = w.node.parentNode
              if (parent) {
                w.height = parent.offsetHeight
              }
            }
          }
        }

        // Compute the lines that are visible in a given viewport (defaults
        // the the current scroll position). viewport may contain top,
        // height, and ensure (see op.scrollToPos) properties.
        function visibleLines(display, doc, viewport) {
          var top =
            viewport && viewport.top != null
              ? Math.max(0, viewport.top)
              : display.scroller.scrollTop
          top = Math.floor(top - paddingTop(display))
          var bottom =
            viewport && viewport.bottom != null
              ? viewport.bottom
              : top + display.wrapper.clientHeight

          var from = lineAtHeight(doc, top),
            to = lineAtHeight(doc, bottom)
          // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
          // forces those lines into the viewport (if possible).
          if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line,
              ensureTo = viewport.ensure.to.line
            if (ensureFrom < from) {
              from = ensureFrom
              to = lineAtHeight(
                doc,
                heightAtLine(getLine(doc, ensureFrom)) +
                  display.wrapper.clientHeight
              )
            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
              from = lineAtHeight(
                doc,
                heightAtLine(getLine(doc, ensureTo)) -
                  display.wrapper.clientHeight
              )
              to = ensureTo
            }
          }
          return { from: from, to: Math.max(to, from + 1) }
        }

        // SCROLLING THINGS INTO VIEW

        // If an editor sits on the top or bottom of the window, partially
        // scrolled out of view, this ensures that the cursor is visible.
        function maybeScrollWindow(cm, rect) {
          if (signalDOMEvent(cm, 'scrollCursorIntoView')) {
            return
          }

          var display = cm.display,
            box = display.sizer.getBoundingClientRect(),
            doScroll = null
          if (rect.top + box.top < 0) {
            doScroll = true
          } else if (
            rect.bottom + box.top >
            (window.innerHeight || document.documentElement.clientHeight)
          ) {
            doScroll = false
          }
          if (doScroll != null && !phantom) {
            var scrollNode = elt(
              'div',
              '\u200b',
              null,
              'position: absolute;\n                         top: ' +
                (rect.top - display.viewOffset - paddingTop(cm.display)) +
                'px;\n                         height: ' +
                (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) +
                'px;\n                         left: ' +
                rect.left +
                'px; width: ' +
                Math.max(2, rect.right - rect.left) +
                'px;'
            )
            cm.display.lineSpace.appendChild(scrollNode)
            scrollNode.scrollIntoView(doScroll)
            cm.display.lineSpace.removeChild(scrollNode)
          }
        }

        // Scroll a given position into view (immediately), verifying that
        // it actually became visible (as line heights are accurately
        // measured, the position of something may 'drift' during drawing).
        function scrollPosIntoView(cm, pos, end, margin) {
          if (margin == null) {
            margin = 0
          }
          var rect
          if (!cm.options.lineWrapping && pos == end) {
            // Set pos and end to the cursor positions around the character pos sticks to
            // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
            // If pos == Pos(_, 0, "before"), pos and end are unchanged
            end =
              pos.sticky == 'before' ? Pos(pos.line, pos.ch + 1, 'before') : pos
            pos = pos.ch
              ? Pos(
                  pos.line,
                  pos.sticky == 'before' ? pos.ch - 1 : pos.ch,
                  'after'
                )
              : pos
          }
          for (var limit = 0; limit < 5; limit++) {
            var changed = false
            var coords = cursorCoords(cm, pos)
            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)
            rect = {
              left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            }
            var scrollPos = calculateScrollPos(cm, rect)
            var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft
            if (scrollPos.scrollTop != null) {
              updateScrollTop(cm, scrollPos.scrollTop)
              if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
                changed = true
              }
            }
            if (scrollPos.scrollLeft != null) {
              setScrollLeft(cm, scrollPos.scrollLeft)
              if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
                changed = true
              }
            }
            if (!changed) {
              break
            }
          }
          return rect
        }

        // Scroll a given set of coordinates into view (immediately).
        function scrollIntoView(cm, rect) {
          var scrollPos = calculateScrollPos(cm, rect)
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop)
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft)
          }
        }

        // Calculate a new scroll position needed to scroll the given
        // rectangle into view. Returns an object with scrollTop and
        // scrollLeft properties. When these are undefined, the
        // vertical/horizontal position does not need to be adjusted.
        function calculateScrollPos(cm, rect) {
          var display = cm.display,
            snapMargin = textHeight(cm.display)
          if (rect.top < 0) {
            rect.top = 0
          }
          var screentop =
            cm.curOp && cm.curOp.scrollTop != null
              ? cm.curOp.scrollTop
              : display.scroller.scrollTop
          var screen = displayHeight(cm),
            result = {}
          if (rect.bottom - rect.top > screen) {
            rect.bottom = rect.top + screen
          }
          var docBottom = cm.doc.height + paddingVert(display)
          var atTop = rect.top < snapMargin,
            atBottom = rect.bottom > docBottom - snapMargin
          if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top
          } else if (rect.bottom > screentop + screen) {
            var newTop = Math.min(
              rect.top,
              (atBottom ? docBottom : rect.bottom) - screen
            )
            if (newTop != screentop) {
              result.scrollTop = newTop
            }
          }

          var gutterSpace = cm.options.fixedGutter
            ? 0
            : display.gutters.offsetWidth
          var screenleft =
            cm.curOp && cm.curOp.scrollLeft != null
              ? cm.curOp.scrollLeft
              : display.scroller.scrollLeft - gutterSpace
          var screenw = displayWidth(cm) - display.gutters.offsetWidth
          var tooWide = rect.right - rect.left > screenw
          if (tooWide) {
            rect.right = rect.left + screenw
          }
          if (rect.left < 10) {
            result.scrollLeft = 0
          } else if (rect.left < screenleft) {
            result.scrollLeft = Math.max(
              0,
              rect.left + gutterSpace - (tooWide ? 0 : 10)
            )
          } else if (rect.right > screenw + screenleft - 3) {
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw
          }
          return result
        }

        // Store a relative adjustment to the scroll position in the current
        // operation (to be applied when the operation finishes).
        function addToScrollTop(cm, top) {
          if (top == null) {
            return
          }
          resolveScrollToPos(cm)
          cm.curOp.scrollTop =
            (cm.curOp.scrollTop == null
              ? cm.doc.scrollTop
              : cm.curOp.scrollTop) + top
        }

        // Make sure that at the end of the operation the current cursor is
        // shown.
        function ensureCursorVisible(cm) {
          resolveScrollToPos(cm)
          var cur = cm.getCursor()
          cm.curOp.scrollToPos = {
            from: cur,
            to: cur,
            margin: cm.options.cursorScrollMargin
          }
        }

        function scrollToCoords(cm, x, y) {
          if (x != null || y != null) {
            resolveScrollToPos(cm)
          }
          if (x != null) {
            cm.curOp.scrollLeft = x
          }
          if (y != null) {
            cm.curOp.scrollTop = y
          }
        }

        function scrollToRange(cm, range) {
          resolveScrollToPos(cm)
          cm.curOp.scrollToPos = range
        }

        // When an operation has its scrollToPos property set, and another
        // scroll action is applied before the end of the operation, this
        // 'simulates' scrolling that position into view in a cheap way, so
        // that the effect of intermediate scroll commands is not ignored.
        function resolveScrollToPos(cm) {
          var range = cm.curOp.scrollToPos
          if (range) {
            cm.curOp.scrollToPos = null
            var from = estimateCoords(cm, range.from),
              to = estimateCoords(cm, range.to)
            scrollToCoordsRange(cm, from, to, range.margin)
          }
        }

        function scrollToCoordsRange(cm, from, to, margin) {
          var sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
          })
          scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop)
        }

        // Sync the scrollable area and scrollbars, ensure the viewport
        // covers the visible area.
        function updateScrollTop(cm, val) {
          if (Math.abs(cm.doc.scrollTop - val) < 2) {
            return
          }
          if (!gecko) {
            updateDisplaySimple(cm, { top: val })
          }
          setScrollTop(cm, val, true)
          if (gecko) {
            updateDisplaySimple(cm)
          }
          startWorker(cm, 100)
        }

        function setScrollTop(cm, val, forceScroll) {
          val = Math.max(
            0,
            Math.min(
              cm.display.scroller.scrollHeight -
                cm.display.scroller.clientHeight,
              val
            )
          )
          if (cm.display.scroller.scrollTop == val && !forceScroll) {
            return
          }
          cm.doc.scrollTop = val
          cm.display.scrollbars.setScrollTop(val)
          if (cm.display.scroller.scrollTop != val) {
            cm.display.scroller.scrollTop = val
          }
        }

        // Sync scroller and scrollbar, ensure the gutter elements are
        // aligned.
        function setScrollLeft(cm, val, isScroller, forceScroll) {
          val = Math.max(
            0,
            Math.min(
              val,
              cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth
            )
          )
          if (
            (isScroller
              ? val == cm.doc.scrollLeft
              : Math.abs(cm.doc.scrollLeft - val) < 2) &&
            !forceScroll
          ) {
            return
          }
          cm.doc.scrollLeft = val
          alignHorizontally(cm)
          if (cm.display.scroller.scrollLeft != val) {
            cm.display.scroller.scrollLeft = val
          }
          cm.display.scrollbars.setScrollLeft(val)
        }

        // SCROLLBARS

        // Prepare DOM reads needed to update the scrollbars. Done in one
        // shot to minimize update/measure roundtrips.
        function measureForScrollbars(cm) {
          var d = cm.display,
            gutterW = d.gutters.offsetWidth
          var docH = Math.round(cm.doc.height + paddingVert(cm.display))
          return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
          }
        }

        var NativeScrollbars = function (place, scroll, cm) {
          this.cm = cm
          var vert = (this.vert = elt(
            'div',
            [elt('div', null, null, 'min-width: 1px')],
            'CodeMirror-vscrollbar'
          ))
          var horiz = (this.horiz = elt(
            'div',
            [elt('div', null, null, 'height: 100%; min-height: 1px')],
            'CodeMirror-hscrollbar'
          ))
          vert.tabIndex = horiz.tabIndex = -1
          place(vert)
          place(horiz)

          on(vert, 'scroll', function () {
            if (vert.clientHeight) {
              scroll(vert.scrollTop, 'vertical')
            }
          })
          on(horiz, 'scroll', function () {
            if (horiz.clientWidth) {
              scroll(horiz.scrollLeft, 'horizontal')
            }
          })

          this.checkedZeroWidth = false
          // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
          if (ie && ie_version < 8) {
            this.horiz.style.minHeight = this.vert.style.minWidth = '18px'
          }
        }

        NativeScrollbars.prototype.update = function (measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1
          var needsV = measure.scrollHeight > measure.clientHeight + 1
          var sWidth = measure.nativeBarWidth

          if (needsV) {
            this.vert.style.display = 'block'
            this.vert.style.bottom = needsH ? sWidth + 'px' : '0'
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)
            // A bug in IE8 can cause this value to be negative, so guard it.
            this.vert.firstChild.style.height =
              Math.max(
                0,
                measure.scrollHeight - measure.clientHeight + totalHeight
              ) + 'px'
          } else {
            this.vert.scrollTop = 0
            this.vert.style.display = ''
            this.vert.firstChild.style.height = '0'
          }

          if (needsH) {
            this.horiz.style.display = 'block'
            this.horiz.style.right = needsV ? sWidth + 'px' : '0'
            this.horiz.style.left = measure.barLeft + 'px'
            var totalWidth =
              measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)
            this.horiz.firstChild.style.width =
              Math.max(
                0,
                measure.scrollWidth - measure.clientWidth + totalWidth
              ) + 'px'
          } else {
            this.horiz.style.display = ''
            this.horiz.firstChild.style.width = '0'
          }

          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
              this.zeroWidthHack()
            }
            this.checkedZeroWidth = true
          }

          return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 }
        }

        NativeScrollbars.prototype.setScrollLeft = function (pos) {
          if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos
          }
          if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz, 'horiz')
          }
        }

        NativeScrollbars.prototype.setScrollTop = function (pos) {
          if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos
          }
          if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert, 'vert')
          }
        }

        NativeScrollbars.prototype.zeroWidthHack = function () {
          var w = mac && !mac_geMountainLion ? '12px' : '18px'
          this.horiz.style.height = this.vert.style.width = w
          this.horiz.style.pointerEvents = this.vert.style.pointerEvents =
            'none'
          this.disableHoriz = new Delayed()
          this.disableVert = new Delayed()
        }

        NativeScrollbars.prototype.enableZeroWidthBar = function (
          bar,
          delay,
          type
        ) {
          bar.style.pointerEvents = 'auto'
          function maybeDisable() {
            // To find out whether the scrollbar is still visible, we
            // check whether the element under the pixel in the bottom
            // right corner of the scrollbar box is the scrollbar box
            // itself (when the bar is still visible) or its filler child
            // (when the bar is hidden). If it is still visible, we keep
            // it enabled, if it's hidden, we disable pointer events.
            var box = bar.getBoundingClientRect()
            var elt =
              type == 'vert'
                ? document.elementFromPoint(
                    box.right - 1,
                    (box.top + box.bottom) / 2
                  )
                : document.elementFromPoint(
                    (box.right + box.left) / 2,
                    box.bottom - 1
                  )
            if (elt != bar) {
              bar.style.pointerEvents = 'none'
            } else {
              delay.set(1000, maybeDisable)
            }
          }
          delay.set(1000, maybeDisable)
        }

        NativeScrollbars.prototype.clear = function () {
          var parent = this.horiz.parentNode
          parent.removeChild(this.horiz)
          parent.removeChild(this.vert)
        }

        var NullScrollbars = function () {}

        NullScrollbars.prototype.update = function () {
          return { bottom: 0, right: 0 }
        }
        NullScrollbars.prototype.setScrollLeft = function () {}
        NullScrollbars.prototype.setScrollTop = function () {}
        NullScrollbars.prototype.clear = function () {}

        function updateScrollbars(cm, measure) {
          if (!measure) {
            measure = measureForScrollbars(cm)
          }
          var startWidth = cm.display.barWidth,
            startHeight = cm.display.barHeight
          updateScrollbarsInner(cm, measure)
          for (
            var i = 0;
            (i < 4 && startWidth != cm.display.barWidth) ||
            startHeight != cm.display.barHeight;
            i++
          ) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
              updateHeightsInViewport(cm)
            }
            updateScrollbarsInner(cm, measureForScrollbars(cm))
            startWidth = cm.display.barWidth
            startHeight = cm.display.barHeight
          }
        }

        // Re-synchronize the fake scrollbars with the actual size of the
        // content.
        function updateScrollbarsInner(cm, measure) {
          var d = cm.display
          var sizes = d.scrollbars.update(measure)

          d.sizer.style.paddingRight = (d.barWidth = sizes.right) + 'px'
          d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + 'px'
          d.heightForcer.style.borderBottom =
            sizes.bottom + 'px solid transparent'

          if (sizes.right && sizes.bottom) {
            d.scrollbarFiller.style.display = 'block'
            d.scrollbarFiller.style.height = sizes.bottom + 'px'
            d.scrollbarFiller.style.width = sizes.right + 'px'
          } else {
            d.scrollbarFiller.style.display = ''
          }
          if (
            sizes.bottom &&
            cm.options.coverGutterNextToScrollbar &&
            cm.options.fixedGutter
          ) {
            d.gutterFiller.style.display = 'block'
            d.gutterFiller.style.height = sizes.bottom + 'px'
            d.gutterFiller.style.width = measure.gutterWidth + 'px'
          } else {
            d.gutterFiller.style.display = ''
          }
        }

        var scrollbarModel = { native: NativeScrollbars, null: NullScrollbars }

        function initScrollbars(cm) {
          if (cm.display.scrollbars) {
            cm.display.scrollbars.clear()
            if (cm.display.scrollbars.addClass) {
              rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)
            }
          }

          cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](
            function (node) {
              cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)
              // Prevent clicks in the scrollbars from killing focus
              on(node, 'mousedown', function () {
                if (cm.state.focused) {
                  setTimeout(function () {
                    return cm.display.input.focus()
                  }, 0)
                }
              })
              node.setAttribute('cm-not-content', 'true')
            },
            function (pos, axis) {
              if (axis == 'horizontal') {
                setScrollLeft(cm, pos)
              } else {
                updateScrollTop(cm, pos)
              }
            },
            cm
          )
          if (cm.display.scrollbars.addClass) {
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass)
          }
        }

        // Operations are used to wrap a series of changes to the editor
        // state in such a way that each change won't have to update the
        // cursor and display (which would be awkward, slow, and
        // error-prone). Instead, display updates are batched and then all
        // combined and executed at once.

        var nextOpId = 0
        // Start a new operation.
        function startOperation(cm) {
          cm.curOp = {
            cm: cm,
            viewChanged: false, // Flag that indicates that lines might need to be redrawn
            startHeight: cm.doc.height, // Used to detect need to update scrollbar
            forceUpdate: false, // Used to force a redraw
            updateInput: 0, // Whether to reset the input textarea
            typing: false, // Whether this reset should be careful to leave existing text (for compositing)
            changeObjs: null, // Accumulated changes, for firing change events
            cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
            cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
            selectionChanged: false, // Whether the selection needs to be redrawn
            updateMaxLine: false, // Set when the widest line needs to be determined anew
            scrollLeft: null,
            scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
            scrollToPos: null, // Used to scroll to a specific position
            focus: false,
            id: ++nextOpId, // Unique ID
            markArrays: null // Used by addMarkedSpan
          }
          pushOperation(cm.curOp)
        }

        // Finish an operation, updating the display and signalling delayed events
        function endOperation(cm) {
          var op = cm.curOp
          if (op) {
            finishOperation(op, function (group) {
              for (var i = 0; i < group.ops.length; i++) {
                group.ops[i].cm.curOp = null
              }
              endOperations(group)
            })
          }
        }

        // The DOM updates done when an operation finishes are batched so
        // that the minimum number of relayouts are required.
        function endOperations(group) {
          var ops = group.ops
          for (
            var i = 0;
            i < ops.length;
            i++ // Read DOM
          ) {
            endOperation_R1(ops[i])
          }
          for (
            var i$1 = 0;
            i$1 < ops.length;
            i$1++ // Write DOM (maybe)
          ) {
            endOperation_W1(ops[i$1])
          }
          for (
            var i$2 = 0;
            i$2 < ops.length;
            i$2++ // Read DOM
          ) {
            endOperation_R2(ops[i$2])
          }
          for (
            var i$3 = 0;
            i$3 < ops.length;
            i$3++ // Write DOM (maybe)
          ) {
            endOperation_W2(ops[i$3])
          }
          for (
            var i$4 = 0;
            i$4 < ops.length;
            i$4++ // Read DOM
          ) {
            endOperation_finish(ops[i$4])
          }
        }

        function endOperation_R1(op) {
          var cm = op.cm,
            display = cm.display
          maybeClipScrollbars(cm)
          if (op.updateMaxLine) {
            findMaxLine(cm)
          }

          op.mustUpdate =
            op.viewChanged ||
            op.forceUpdate ||
            op.scrollTop != null ||
            (op.scrollToPos &&
              (op.scrollToPos.from.line < display.viewFrom ||
                op.scrollToPos.to.line >= display.viewTo)) ||
            (display.maxLineChanged && cm.options.lineWrapping)
          op.update =
            op.mustUpdate &&
            new DisplayUpdate(
              cm,
              op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos },
              op.forceUpdate
            )
        }

        function endOperation_W1(op) {
          op.updatedDisplay =
            op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
        }

        function endOperation_R2(op) {
          var cm = op.cm,
            display = cm.display
          if (op.updatedDisplay) {
            updateHeightsInViewport(cm)
          }

          op.barMeasure = measureForScrollbars(cm)

          // If the max line changed since it was last measured, measure it,
          // and ensure the document's width matches it.
          // updateDisplay_W2 will use these properties to do the actual resizing
          if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo =
              measureChar(cm, display.maxLine, display.maxLine.text.length)
                .left + 3
            cm.display.sizerWidth = op.adjustWidthTo
            op.barMeasure.scrollWidth = Math.max(
              display.scroller.clientWidth,
              display.sizer.offsetLeft +
                op.adjustWidthTo +
                scrollGap(cm) +
                cm.display.barWidth
            )
            op.maxScrollLeft = Math.max(
              0,
              display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm)
            )
          }

          if (op.updatedDisplay || op.selectionChanged) {
            op.preparedSelection = display.input.prepareSelection()
          }
        }

        function endOperation_W2(op) {
          var cm = op.cm

          if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + 'px'
            if (op.maxScrollLeft < cm.doc.scrollLeft) {
              setScrollLeft(
                cm,
                Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft),
                true
              )
            }
            cm.display.maxLineChanged = false
          }

          var takeFocus = op.focus && op.focus == activeElt()
          if (op.preparedSelection) {
            cm.display.input.showSelection(op.preparedSelection, takeFocus)
          }
          if (op.updatedDisplay || op.startHeight != cm.doc.height) {
            updateScrollbars(cm, op.barMeasure)
          }
          if (op.updatedDisplay) {
            setDocumentHeight(cm, op.barMeasure)
          }

          if (op.selectionChanged) {
            restartBlink(cm)
          }

          if (cm.state.focused && op.updateInput) {
            cm.display.input.reset(op.typing)
          }
          if (takeFocus) {
            ensureFocus(op.cm)
          }
        }

        function endOperation_finish(op) {
          var cm = op.cm,
            display = cm.display,
            doc = cm.doc

          if (op.updatedDisplay) {
            postUpdateDisplay(cm, op.update)
          }

          // Abort mouse wheel delta measurement, when scrolling explicitly
          if (
            display.wheelStartX != null &&
            (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)
          ) {
            display.wheelStartX = display.wheelStartY = null
          }

          // Propagate the scroll position to the actual DOM scroller
          if (op.scrollTop != null) {
            setScrollTop(cm, op.scrollTop, op.forceScroll)
          }

          if (op.scrollLeft != null) {
            setScrollLeft(cm, op.scrollLeft, true, true)
          }
          // If we need to scroll a specific position into view, do so.
          if (op.scrollToPos) {
            var rect = scrollPosIntoView(
              cm,
              clipPos(doc, op.scrollToPos.from),
              clipPos(doc, op.scrollToPos.to),
              op.scrollToPos.margin
            )
            maybeScrollWindow(cm, rect)
          }

          // Fire events for markers that are hidden/unidden by editing or
          // undoing
          var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers
          if (hidden) {
            for (var i = 0; i < hidden.length; ++i) {
              if (!hidden[i].lines.length) {
                signal(hidden[i], 'hide')
              }
            }
          }
          if (unhidden) {
            for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
              if (unhidden[i$1].lines.length) {
                signal(unhidden[i$1], 'unhide')
              }
            }
          }

          if (display.wrapper.offsetHeight) {
            doc.scrollTop = cm.display.scroller.scrollTop
          }

          // Fire change events, and delayed event handlers
          if (op.changeObjs) {
            signal(cm, 'changes', cm, op.changeObjs)
          }
          if (op.update) {
            op.update.finish()
          }
        }

        // Run the given function in an operation
        function runInOp(cm, f) {
          if (cm.curOp) {
            return f()
          }
          startOperation(cm)
          try {
            return f()
          } finally {
            endOperation(cm)
          }
        }
        // Wraps a function in an operation. Returns the wrapped function.
        function operation(cm, f) {
          return function () {
            if (cm.curOp) {
              return f.apply(cm, arguments)
            }
            startOperation(cm)
            try {
              return f.apply(cm, arguments)
            } finally {
              endOperation(cm)
            }
          }
        }
        // Used to add methods to editor and doc instances, wrapping them in
        // operations.
        function methodOp(f) {
          return function () {
            if (this.curOp) {
              return f.apply(this, arguments)
            }
            startOperation(this)
            try {
              return f.apply(this, arguments)
            } finally {
              endOperation(this)
            }
          }
        }
        function docMethodOp(f) {
          return function () {
            var cm = this.cm
            if (!cm || cm.curOp) {
              return f.apply(this, arguments)
            }
            startOperation(cm)
            try {
              return f.apply(this, arguments)
            } finally {
              endOperation(cm)
            }
          }
        }

        // HIGHLIGHT WORKER

        function startWorker(cm, time) {
          if (cm.doc.highlightFrontier < cm.display.viewTo) {
            cm.state.highlight.set(time, bind(highlightWorker, cm))
          }
        }

        function highlightWorker(cm) {
          var doc = cm.doc
          if (doc.highlightFrontier >= cm.display.viewTo) {
            return
          }
          var end = +new Date() + cm.options.workTime
          var context = getContextBefore(cm, doc.highlightFrontier)
          var changedLines = []

          doc.iter(
            context.line,
            Math.min(doc.first + doc.size, cm.display.viewTo + 500),
            function (line) {
              if (context.line >= cm.display.viewFrom) {
                // Visible
                var oldStyles = line.styles
                var resetState =
                  line.text.length > cm.options.maxHighlightLength
                    ? copyState(doc.mode, context.state)
                    : null
                var highlighted = highlightLine(cm, line, context, true)
                if (resetState) {
                  context.state = resetState
                }
                line.styles = highlighted.styles
                var oldCls = line.styleClasses,
                  newCls = highlighted.classes
                if (newCls) {
                  line.styleClasses = newCls
                } else if (oldCls) {
                  line.styleClasses = null
                }
                var ischange =
                  !oldStyles ||
                  oldStyles.length != line.styles.length ||
                  (oldCls != newCls &&
                    (!oldCls ||
                      !newCls ||
                      oldCls.bgClass != newCls.bgClass ||
                      oldCls.textClass != newCls.textClass))
                for (var i = 0; !ischange && i < oldStyles.length; ++i) {
                  ischange = oldStyles[i] != line.styles[i]
                }
                if (ischange) {
                  changedLines.push(context.line)
                }
                line.stateAfter = context.save()
                context.nextLine()
              } else {
                if (line.text.length <= cm.options.maxHighlightLength) {
                  processLine(cm, line.text, context)
                }
                line.stateAfter = context.line % 5 == 0 ? context.save() : null
                context.nextLine()
              }
              if (+new Date() > end) {
                startWorker(cm, cm.options.workDelay)
                return true
              }
            }
          )
          doc.highlightFrontier = context.line
          doc.modeFrontier = Math.max(doc.modeFrontier, context.line)
          if (changedLines.length) {
            runInOp(cm, function () {
              for (var i = 0; i < changedLines.length; i++) {
                regLineChange(cm, changedLines[i], 'text')
              }
            })
          }
        }

        // DISPLAY DRAWING

        var DisplayUpdate = function (cm, viewport, force) {
          var display = cm.display

          this.viewport = viewport
          // Store some values that we'll need later (but don't want to force a relayout for)
          this.visible = visibleLines(display, cm.doc, viewport)
          this.editorIsHidden = !display.wrapper.offsetWidth
          this.wrapperHeight = display.wrapper.clientHeight
          this.wrapperWidth = display.wrapper.clientWidth
          this.oldDisplayWidth = displayWidth(cm)
          this.force = force
          this.dims = getDimensions(cm)
          this.events = []
        }

        DisplayUpdate.prototype.signal = function (emitter, type) {
          if (hasHandler(emitter, type)) {
            this.events.push(arguments)
          }
        }
        DisplayUpdate.prototype.finish = function () {
          for (var i = 0; i < this.events.length; i++) {
            signal.apply(null, this.events[i])
          }
        }

        function maybeClipScrollbars(cm) {
          var display = cm.display
          if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth =
              display.scroller.offsetWidth - display.scroller.clientWidth
            display.heightForcer.style.height = scrollGap(cm) + 'px'
            display.sizer.style.marginBottom = -display.nativeBarWidth + 'px'
            display.sizer.style.borderRightWidth = scrollGap(cm) + 'px'
            display.scrollbarsClipped = true
          }
        }

        function selectionSnapshot(cm) {
          if (cm.hasFocus()) {
            return null
          }
          var active = activeElt()
          if (!active || !contains(cm.display.lineDiv, active)) {
            return null
          }
          var result = { activeElt: active }
          if (window.getSelection) {
            var sel = window.getSelection()
            if (
              sel.anchorNode &&
              sel.extend &&
              contains(cm.display.lineDiv, sel.anchorNode)
            ) {
              result.anchorNode = sel.anchorNode
              result.anchorOffset = sel.anchorOffset
              result.focusNode = sel.focusNode
              result.focusOffset = sel.focusOffset
            }
          }
          return result
        }

        function restoreSelection(snapshot) {
          if (
            !snapshot ||
            !snapshot.activeElt ||
            snapshot.activeElt == activeElt()
          ) {
            return
          }
          snapshot.activeElt.focus()
          if (
            !/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
            snapshot.anchorNode &&
            contains(document.body, snapshot.anchorNode) &&
            contains(document.body, snapshot.focusNode)
          ) {
            var sel = window.getSelection(),
              range = document.createRange()
            range.setEnd(snapshot.anchorNode, snapshot.anchorOffset)
            range.collapse(false)
            sel.removeAllRanges()
            sel.addRange(range)
            sel.extend(snapshot.focusNode, snapshot.focusOffset)
          }
        }

        // Does the actual updating of the line display. Bails out
        // (returning false) when there is nothing to be done and forced is
        // false.
        function updateDisplayIfNeeded(cm, update) {
          var display = cm.display,
            doc = cm.doc

          if (update.editorIsHidden) {
            resetView(cm)
            return false
          }

          // Bail out if the visible area is already rendered and nothing changed.
          if (
            !update.force &&
            update.visible.from >= display.viewFrom &&
            update.visible.to <= display.viewTo &&
            (display.updateLineNumbers == null ||
              display.updateLineNumbers >= display.viewTo) &&
            display.renderedView == display.view &&
            countDirtyView(cm) == 0
          ) {
            return false
          }

          if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm)
            update.dims = getDimensions(cm)
          }

          // Compute a suitable new viewport (from & to)
          var end = doc.first + doc.size
          var from = Math.max(
            update.visible.from - cm.options.viewportMargin,
            doc.first
          )
          var to = Math.min(end, update.visible.to + cm.options.viewportMargin)
          if (display.viewFrom < from && from - display.viewFrom < 20) {
            from = Math.max(doc.first, display.viewFrom)
          }
          if (display.viewTo > to && display.viewTo - to < 20) {
            to = Math.min(end, display.viewTo)
          }
          if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from)
            to = visualLineEndNo(cm.doc, to)
          }

          var different =
            from != display.viewFrom ||
            to != display.viewTo ||
            display.lastWrapHeight != update.wrapperHeight ||
            display.lastWrapWidth != update.wrapperWidth
          adjustView(cm, from, to)

          display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))
          // Position the mover div to align with the current scroll position
          cm.display.mover.style.top = display.viewOffset + 'px'

          var toUpdate = countDirtyView(cm)
          if (
            !different &&
            toUpdate == 0 &&
            !update.force &&
            display.renderedView == display.view &&
            (display.updateLineNumbers == null ||
              display.updateLineNumbers >= display.viewTo)
          ) {
            return false
          }

          // For big changes, we hide the enclosing element during the
          // update, since that speeds up the operations on most browsers.
          var selSnapshot = selectionSnapshot(cm)
          if (toUpdate > 4) {
            display.lineDiv.style.display = 'none'
          }
          patchDisplay(cm, display.updateLineNumbers, update.dims)
          if (toUpdate > 4) {
            display.lineDiv.style.display = ''
          }
          display.renderedView = display.view
          // There might have been a widget with a focused element that got
          // hidden or updated, if so re-focus it.
          restoreSelection(selSnapshot)

          // Prevent selection and cursors from interfering with the scroll
          // width and height.
          removeChildren(display.cursorDiv)
          removeChildren(display.selectionDiv)
          display.gutters.style.height = display.sizer.style.minHeight = 0

          if (different) {
            display.lastWrapHeight = update.wrapperHeight
            display.lastWrapWidth = update.wrapperWidth
            startWorker(cm, 400)
          }

          display.updateLineNumbers = null

          return true
        }

        function postUpdateDisplay(cm, update) {
          var viewport = update.viewport

          for (var first = true; ; first = false) {
            if (
              !first ||
              !cm.options.lineWrapping ||
              update.oldDisplayWidth == displayWidth(cm)
            ) {
              // Clip forced viewport to actual scrollable area.
              if (viewport && viewport.top != null) {
                viewport = {
                  top: Math.min(
                    cm.doc.height + paddingVert(cm.display) - displayHeight(cm),
                    viewport.top
                  )
                }
              }
              // Updated line heights might result in the drawn area not
              // actually covering the viewport. Keep looping until it does.
              update.visible = visibleLines(cm.display, cm.doc, viewport)
              if (
                update.visible.from >= cm.display.viewFrom &&
                update.visible.to <= cm.display.viewTo
              ) {
                break
              }
            } else if (first) {
              update.visible = visibleLines(cm.display, cm.doc, viewport)
            }
            if (!updateDisplayIfNeeded(cm, update)) {
              break
            }
            updateHeightsInViewport(cm)
            var barMeasure = measureForScrollbars(cm)
            updateSelection(cm)
            updateScrollbars(cm, barMeasure)
            setDocumentHeight(cm, barMeasure)
            update.force = false
          }

          update.signal(cm, 'update', cm)
          if (
            cm.display.viewFrom != cm.display.reportedViewFrom ||
            cm.display.viewTo != cm.display.reportedViewTo
          ) {
            update.signal(
              cm,
              'viewportChange',
              cm,
              cm.display.viewFrom,
              cm.display.viewTo
            )
            cm.display.reportedViewFrom = cm.display.viewFrom
            cm.display.reportedViewTo = cm.display.viewTo
          }
        }

        function updateDisplaySimple(cm, viewport) {
          var update = new DisplayUpdate(cm, viewport)
          if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm)
            postUpdateDisplay(cm, update)
            var barMeasure = measureForScrollbars(cm)
            updateSelection(cm)
            updateScrollbars(cm, barMeasure)
            setDocumentHeight(cm, barMeasure)
            update.finish()
          }
        }

        // Sync the actual display DOM structure with display.view, removing
        // nodes for lines that are no longer in view, and creating the ones
        // that are not there yet, and updating the ones that are out of
        // date.
        function patchDisplay(cm, updateNumbersFrom, dims) {
          var display = cm.display,
            lineNumbers = cm.options.lineNumbers
          var container = display.lineDiv,
            cur = container.firstChild

          function rm(node) {
            var next = node.nextSibling
            // Works around a throw-scroll bug in OS X Webkit
            if (webkit && mac && cm.display.currentWheelTarget == node) {
              node.style.display = 'none'
            } else {
              node.parentNode.removeChild(node)
            }
            return next
          }

          var view = display.view,
            lineN = display.viewFrom
          // Loop over the elements in the view, syncing cur (the DOM nodes
          // in display.lineDiv) with the view as we go.
          for (var i = 0; i < view.length; i++) {
            var lineView = view[i]
            if (lineView.hidden);
            else if (!lineView.node || lineView.node.parentNode != container) {
              // Not drawn yet
              var node = buildLineElement(cm, lineView, lineN, dims)
              container.insertBefore(node, cur)
            } else {
              // Already drawn
              while (cur != lineView.node) {
                cur = rm(cur)
              }
              var updateNumber =
                lineNumbers &&
                updateNumbersFrom != null &&
                updateNumbersFrom <= lineN &&
                lineView.lineNumber
              if (lineView.changes) {
                if (indexOf(lineView.changes, 'gutter') > -1) {
                  updateNumber = false
                }
                updateLineForChanges(cm, lineView, lineN, dims)
              }
              if (updateNumber) {
                removeChildren(lineView.lineNumber)
                lineView.lineNumber.appendChild(
                  document.createTextNode(lineNumberFor(cm.options, lineN))
                )
              }
              cur = lineView.node.nextSibling
            }
            lineN += lineView.size
          }
          while (cur) {
            cur = rm(cur)
          }
        }

        function updateGutterSpace(display) {
          var width = display.gutters.offsetWidth
          display.sizer.style.marginLeft = width + 'px'
          // Send an event to consumers responding to changes in gutter width.
          signalLater(display, 'gutterChanged', display)
        }

        function setDocumentHeight(cm, measure) {
          cm.display.sizer.style.minHeight = measure.docHeight + 'px'
          cm.display.heightForcer.style.top = measure.docHeight + 'px'
          cm.display.gutters.style.height =
            measure.docHeight + cm.display.barHeight + scrollGap(cm) + 'px'
        }

        // Re-align line numbers and gutter marks to compensate for
        // horizontal scrolling.
        function alignHorizontally(cm) {
          var display = cm.display,
            view = display.view
          if (
            !display.alignWidgets &&
            (!display.gutters.firstChild || !cm.options.fixedGutter)
          ) {
            return
          }
          var comp =
            compensateForHScroll(display) -
            display.scroller.scrollLeft +
            cm.doc.scrollLeft
          var gutterW = display.gutters.offsetWidth,
            left = comp + 'px'
          for (var i = 0; i < view.length; i++) {
            if (!view[i].hidden) {
              if (cm.options.fixedGutter) {
                if (view[i].gutter) {
                  view[i].gutter.style.left = left
                }
                if (view[i].gutterBackground) {
                  view[i].gutterBackground.style.left = left
                }
              }
              var align = view[i].alignable
              if (align) {
                for (var j = 0; j < align.length; j++) {
                  align[j].style.left = left
                }
              }
            }
          }
          if (cm.options.fixedGutter) {
            display.gutters.style.left = comp + gutterW + 'px'
          }
        }

        // Used to ensure that the line number gutter is still the right
        // size for the current document size. Returns true when an update
        // is needed.
        function maybeUpdateLineNumberWidth(cm) {
          if (!cm.options.lineNumbers) {
            return false
          }
          var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display
          if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(
              elt(
                'div',
                [elt('div', last)],
                'CodeMirror-linenumber CodeMirror-gutter-elt'
              )
            )
            var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW
            display.lineGutter.style.width = ''
            display.lineNumInnerWidth =
              Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1
            display.lineNumWidth = display.lineNumInnerWidth + padding
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1
            display.lineGutter.style.width = display.lineNumWidth + 'px'
            updateGutterSpace(cm.display)
            return true
          }
          return false
        }

        function getGutters(gutters, lineNumbers) {
          var result = [],
            sawLineNumbers = false
          for (var i = 0; i < gutters.length; i++) {
            var name = gutters[i],
              style = null
            if (typeof name != 'string') {
              style = name.style
              name = name.className
            }
            if (name == 'CodeMirror-linenumbers') {
              if (!lineNumbers) {
                continue
              } else {
                sawLineNumbers = true
              }
            }
            result.push({ className: name, style: style })
          }
          if (lineNumbers && !sawLineNumbers) {
            result.push({ className: 'CodeMirror-linenumbers', style: null })
          }
          return result
        }

        // Rebuild the gutter elements, ensure the margin to the left of the
        // code matches their width.
        function renderGutters(display) {
          var gutters = display.gutters,
            specs = display.gutterSpecs
          removeChildren(gutters)
          display.lineGutter = null
          for (var i = 0; i < specs.length; ++i) {
            var ref = specs[i]
            var className = ref.className
            var style = ref.style
            var gElt = gutters.appendChild(
              elt('div', null, 'CodeMirror-gutter ' + className)
            )
            if (style) {
              gElt.style.cssText = style
            }
            if (className == 'CodeMirror-linenumbers') {
              display.lineGutter = gElt
              gElt.style.width = (display.lineNumWidth || 1) + 'px'
            }
          }
          gutters.style.display = specs.length ? '' : 'none'
          updateGutterSpace(display)
        }

        function updateGutters(cm) {
          renderGutters(cm.display)
          regChange(cm)
          alignHorizontally(cm)
        }

        // The display handles the DOM integration, both for input reading
        // and content drawing. It holds references to DOM nodes and
        // display-related state.

        function Display(place, doc, input, options) {
          var d = this
          this.input = input

          // Covers bottom-right square when both scrollbars are present.
          d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler')
          d.scrollbarFiller.setAttribute('cm-not-content', 'true')
          // Covers bottom of gutter when coverGutterNextToScrollbar is on
          // and h scrollbar is present.
          d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler')
          d.gutterFiller.setAttribute('cm-not-content', 'true')
          // Will contain the actual code, positioned to cover the viewport.
          d.lineDiv = eltP('div', null, 'CodeMirror-code')
          // Elements are added to these to represent selection and cursors.
          d.selectionDiv = elt(
            'div',
            null,
            null,
            'position: relative; z-index: 1'
          )
          d.cursorDiv = elt('div', null, 'CodeMirror-cursors')
          // A visibility: hidden element used to find the size of things.
          d.measure = elt('div', null, 'CodeMirror-measure')
          // When lines outside of the viewport are measured, they are drawn in this.
          d.lineMeasure = elt('div', null, 'CodeMirror-measure')
          // Wraps everything that needs to exist inside the vertically-padded coordinate system
          d.lineSpace = eltP(
            'div',
            [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
            null,
            'position: relative; outline: none'
          )
          var lines = eltP('div', [d.lineSpace], 'CodeMirror-lines')
          // Moved around its parent to cover visible view.
          d.mover = elt('div', [lines], null, 'position: relative')
          // Set to the height of the document, allowing scrolling.
          d.sizer = elt('div', [d.mover], 'CodeMirror-sizer')
          d.sizerWidth = null
          // Behavior of elts with overflow: auto and padding is
          // inconsistent across browsers. This is used to ensure the
          // scrollable area is big enough.
          d.heightForcer = elt(
            'div',
            null,
            null,
            'position: absolute; height: ' + scrollerGap + 'px; width: 1px;'
          )
          // Will contain the gutters, if any.
          d.gutters = elt('div', null, 'CodeMirror-gutters')
          d.lineGutter = null
          // Actual scrollable element.
          d.scroller = elt(
            'div',
            [d.sizer, d.heightForcer, d.gutters],
            'CodeMirror-scroll'
          )
          d.scroller.setAttribute('tabIndex', '-1')
          // The element in which the editor lives.
          d.wrapper = elt(
            'div',
            [d.scrollbarFiller, d.gutterFiller, d.scroller],
            'CodeMirror'
          )

          // This attribute is respected by automatic translation systems such as Google Translate,
          // and may also be respected by tools used by human translators.
          d.wrapper.setAttribute('translate', 'no')

          // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
          if (ie && ie_version < 8) {
            d.gutters.style.zIndex = -1
            d.scroller.style.paddingRight = 0
          }
          if (!webkit && !(gecko && mobile)) {
            d.scroller.draggable = true
          }

          if (place) {
            if (place.appendChild) {
              place.appendChild(d.wrapper)
            } else {
              place(d.wrapper)
            }
          }

          // Current rendered range (may be bigger than the view window).
          d.viewFrom = d.viewTo = doc.first
          d.reportedViewFrom = d.reportedViewTo = doc.first
          // Information about the rendered lines.
          d.view = []
          d.renderedView = null
          // Holds info about a single rendered line when it was rendered
          // for measurement, while not in view.
          d.externalMeasured = null
          // Empty space (in pixels) above the view
          d.viewOffset = 0
          d.lastWrapHeight = d.lastWrapWidth = 0
          d.updateLineNumbers = null

          d.nativeBarWidth = d.barHeight = d.barWidth = 0
          d.scrollbarsClipped = false

          // Used to only resize the line number gutter when necessary (when
          // the amount of lines crosses a boundary that makes its width change)
          d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null
          // Set to true when a non-horizontal-scrolling line widget is
          // added. As an optimization, line widget aligning is skipped when
          // this is false.
          d.alignWidgets = false

          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null

          // Tracks the maximum line length so that the horizontal scrollbar
          // can be kept static when scrolling.
          d.maxLine = null
          d.maxLineLength = 0
          d.maxLineChanged = false

          // Used for measuring wheel scrolling granularity
          d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null

          // True when shift is held down.
          d.shift = false

          // Used to track whether anything happened since the context menu
          // was opened.
          d.selForContextMenu = null

          d.activeTouch = null

          d.gutterSpecs = getGutters(options.gutters, options.lineNumbers)
          renderGutters(d)

          input.init(d)
        }

        // Since the delta values reported on mouse wheel events are
        // unstandardized between browsers and even browser versions, and
        // generally horribly unpredictable, this code starts by measuring
        // the scroll effect that the first few mouse wheel events have,
        // and, from that, detects the way it can convert deltas to pixel
        // offsets afterwards.
        //
        // The reason we want to know the amount a wheel event will scroll
        // is that it gives us a chance to update the display before the
        // actual scrolling happens, reducing flickering.

        var wheelSamples = 0,
          wheelPixelsPerUnit = null
        // Fill in a browser-detected starting value on browsers where we
        // know one. These don't have to be accurate -- the result of them
        // being wrong would just be a slight flicker on the first wheel
        // scroll (if it is large enough).
        if (ie) {
          wheelPixelsPerUnit = -0.53
        } else if (gecko) {
          wheelPixelsPerUnit = 15
        } else if (chrome) {
          wheelPixelsPerUnit = -0.7
        } else if (safari) {
          wheelPixelsPerUnit = -1 / 3
        }

        function wheelEventDelta(e) {
          var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY
          if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
            dx = e.detail
          }
          if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
            dy = e.detail
          } else if (dy == null) {
            dy = e.wheelDelta
          }
          return { x: dx, y: dy }
        }
        function wheelEventPixels(e) {
          var delta = wheelEventDelta(e)
          delta.x *= wheelPixelsPerUnit
          delta.y *= wheelPixelsPerUnit
          return delta
        }

        function onScrollWheel(cm, e) {
          var delta = wheelEventDelta(e),
            dx = delta.x,
            dy = delta.y
          var pixelsPerUnit = wheelPixelsPerUnit
          if (e.deltaMode === 0) {
            dx = e.deltaX
            dy = e.deltaY
            pixelsPerUnit = 1
          }

          var display = cm.display,
            scroll = display.scroller
          // Quit if there's nothing to scroll here
          var canScrollX = scroll.scrollWidth > scroll.clientWidth
          var canScrollY = scroll.scrollHeight > scroll.clientHeight
          if (!((dx && canScrollX) || (dy && canScrollY))) {
            return
          }

          // Webkit browsers on OS X abort momentum scrolls when the target
          // of the scroll event is removed from the scrollable element.
          // This hack (see related code in patchDisplay) makes sure the
          // element is kept around.
          if (dy && mac && webkit) {
            outer: for (
              var cur = e.target, view = display.view;
              cur != scroll;
              cur = cur.parentNode
            ) {
              for (var i = 0; i < view.length; i++) {
                if (view[i].node == cur) {
                  cm.display.currentWheelTarget = cur
                  break outer
                }
              }
            }
          }

          // On some browsers, horizontal scrolling will cause redraws to
          // happen before the gutter has been realigned, causing it to
          // wriggle around in a most unseemly way. When we have an
          // estimated pixels/delta value, we just handle horizontal
          // scrolling entirely here. It'll be slightly off from native, but
          // better than glitching out.
          if (dx && !gecko && !presto && pixelsPerUnit != null) {
            if (dy && canScrollY) {
              updateScrollTop(
                cm,
                Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)
              )
            }
            setScrollLeft(
              cm,
              Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit)
            )
            // Only prevent default scrolling if vertical scrolling is
            // actually possible. Otherwise, it causes vertical scroll
            // jitter on OSX trackpads when deltaX is small and deltaY
            // is large (issue #3579)
            if (!dy || (dy && canScrollY)) {
              e_preventDefault(e)
            }
            display.wheelStartX = null // Abort measurement, if in progress
            return
          }

          // 'Project' the visible viewport to cover the area that is being
          // scrolled into view (if we know enough to estimate it).
          if (dy && pixelsPerUnit != null) {
            var pixels = dy * pixelsPerUnit
            var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight
            if (pixels < 0) {
              top = Math.max(0, top + pixels - 50)
            } else {
              bot = Math.min(cm.doc.height, bot + pixels + 50)
            }
            updateDisplaySimple(cm, { top: top, bottom: bot })
          }

          if (wheelSamples < 20 && e.deltaMode !== 0) {
            if (display.wheelStartX == null) {
              display.wheelStartX = scroll.scrollLeft
              display.wheelStartY = scroll.scrollTop
              display.wheelDX = dx
              display.wheelDY = dy
              setTimeout(function () {
                if (display.wheelStartX == null) {
                  return
                }
                var movedX = scroll.scrollLeft - display.wheelStartX
                var movedY = scroll.scrollTop - display.wheelStartY
                var sample =
                  (movedY && display.wheelDY && movedY / display.wheelDY) ||
                  (movedX && display.wheelDX && movedX / display.wheelDX)
                display.wheelStartX = display.wheelStartY = null
                if (!sample) {
                  return
                }
                wheelPixelsPerUnit =
                  (wheelPixelsPerUnit * wheelSamples + sample) /
                  (wheelSamples + 1)
                ++wheelSamples
              }, 200)
            } else {
              display.wheelDX += dx
              display.wheelDY += dy
            }
          }
        }

        // Selection objects are immutable. A new one is created every time
        // the selection changes. A selection is one or more non-overlapping
        // (and non-touching) ranges, sorted, and an integer that indicates
        // which one is the primary selection (the one that's scrolled into
        // view, that getCursor returns, etc).
        var Selection = function (ranges, primIndex) {
          this.ranges = ranges
          this.primIndex = primIndex
        }

        Selection.prototype.primary = function () {
          return this.ranges[this.primIndex]
        }

        Selection.prototype.equals = function (other) {
          if (other == this) {
            return true
          }
          if (
            other.primIndex != this.primIndex ||
            other.ranges.length != this.ranges.length
          ) {
            return false
          }
          for (var i = 0; i < this.ranges.length; i++) {
            var here = this.ranges[i],
              there = other.ranges[i]
            if (
              !equalCursorPos(here.anchor, there.anchor) ||
              !equalCursorPos(here.head, there.head)
            ) {
              return false
            }
          }
          return true
        }

        Selection.prototype.deepCopy = function () {
          var out = []
          for (var i = 0; i < this.ranges.length; i++) {
            out[i] = new Range(
              copyPos(this.ranges[i].anchor),
              copyPos(this.ranges[i].head)
            )
          }
          return new Selection(out, this.primIndex)
        }

        Selection.prototype.somethingSelected = function () {
          for (var i = 0; i < this.ranges.length; i++) {
            if (!this.ranges[i].empty()) {
              return true
            }
          }
          return false
        }

        Selection.prototype.contains = function (pos, end) {
          if (!end) {
            end = pos
          }
          for (var i = 0; i < this.ranges.length; i++) {
            var range = this.ranges[i]
            if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
              return i
            }
          }
          return -1
        }

        var Range = function (anchor, head) {
          this.anchor = anchor
          this.head = head
        }

        Range.prototype.from = function () {
          return minPos(this.anchor, this.head)
        }
        Range.prototype.to = function () {
          return maxPos(this.anchor, this.head)
        }
        Range.prototype.empty = function () {
          return (
            this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
          )
        }

        // Take an unsorted, potentially overlapping set of ranges, and
        // build a selection out of it. 'Consumes' ranges array (modifying
        // it).
        function normalizeSelection(cm, ranges, primIndex) {
          var mayTouch = cm && cm.options.selectionsMayTouch
          var prim = ranges[primIndex]
          ranges.sort(function (a, b) {
            return cmp(a.from(), b.from())
          })
          primIndex = indexOf(ranges, prim)
          for (var i = 1; i < ranges.length; i++) {
            var cur = ranges[i],
              prev = ranges[i - 1]
            var diff = cmp(prev.to(), cur.from())
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
              var from = minPos(prev.from(), cur.from()),
                to = maxPos(prev.to(), cur.to())
              var inv = prev.empty()
                ? cur.from() == cur.head
                : prev.from() == prev.head
              if (i <= primIndex) {
                --primIndex
              }
              ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
            }
          }
          return new Selection(ranges, primIndex)
        }

        function simpleSelection(anchor, head) {
          return new Selection([new Range(anchor, head || anchor)], 0)
        }

        // Compute the position of the end of a change (its 'to' property
        // refers to the pre-change end).
        function changeEnd(change) {
          if (!change.text) {
            return change.to
          }
          return Pos(
            change.from.line + change.text.length - 1,
            lst(change.text).length +
              (change.text.length == 1 ? change.from.ch : 0)
          )
        }

        // Adjust a position to refer to the post-change position of the
        // same text, or the end of the change if the change covers it.
        function adjustForChange(pos, change) {
          if (cmp(pos, change.from) < 0) {
            return pos
          }
          if (cmp(pos, change.to) <= 0) {
            return changeEnd(change)
          }

          var line =
              pos.line +
              change.text.length -
              (change.to.line - change.from.line) -
              1,
            ch = pos.ch
          if (pos.line == change.to.line) {
            ch += changeEnd(change).ch - change.to.ch
          }
          return Pos(line, ch)
        }

        function computeSelAfterChange(doc, change) {
          var out = []
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i]
            out.push(
              new Range(
                adjustForChange(range.anchor, change),
                adjustForChange(range.head, change)
              )
            )
          }
          return normalizeSelection(doc.cm, out, doc.sel.primIndex)
        }

        function offsetPos(pos, old, nw) {
          if (pos.line == old.line) {
            return Pos(nw.line, pos.ch - old.ch + nw.ch)
          } else {
            return Pos(nw.line + (pos.line - old.line), pos.ch)
          }
        }

        // Used by replaceSelections to allow moving the selection to the
        // start or around the replaced test. Hint may be "start" or "around".
        function computeReplacedSel(doc, changes, hint) {
          var out = []
          var oldPrev = Pos(doc.first, 0),
            newPrev = oldPrev
          for (var i = 0; i < changes.length; i++) {
            var change = changes[i]
            var from = offsetPos(change.from, oldPrev, newPrev)
            var to = offsetPos(changeEnd(change), oldPrev, newPrev)
            oldPrev = change.to
            newPrev = to
            if (hint == 'around') {
              var range = doc.sel.ranges[i],
                inv = cmp(range.head, range.anchor) < 0
              out[i] = new Range(inv ? to : from, inv ? from : to)
            } else {
              out[i] = new Range(from, from)
            }
          }
          return new Selection(out, doc.sel.primIndex)
        }

        // Used to get the editor into a consistent state again when options change.

        function loadMode(cm) {
          cm.doc.mode = getMode(cm.options, cm.doc.modeOption)
          resetModeState(cm)
        }

        function resetModeState(cm) {
          cm.doc.iter(function (line) {
            if (line.stateAfter) {
              line.stateAfter = null
            }
            if (line.styles) {
              line.styles = null
            }
          })
          cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first
          startWorker(cm, 100)
          cm.state.modeGen++
          if (cm.curOp) {
            regChange(cm)
          }
        }

        // DOCUMENT DATA STRUCTURE

        // By default, updates that start and end at the beginning of a line
        // are treated specially, in order to make the association of line
        // widgets and marker elements with the text behave more intuitive.
        function isWholeLineUpdate(doc, change) {
          return (
            change.from.ch == 0 &&
            change.to.ch == 0 &&
            lst(change.text) == '' &&
            (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
          )
        }

        // Perform a change on the document data structure.
        function updateDoc(doc, change, markedSpans, estimateHeight) {
          function spansFor(n) {
            return markedSpans ? markedSpans[n] : null
          }
          function update(line, text, spans) {
            updateLine(line, text, spans, estimateHeight)
            signalLater(line, 'change', line, change)
          }
          function linesFor(start, end) {
            var result = []
            for (var i = start; i < end; ++i) {
              result.push(new Line(text[i], spansFor(i), estimateHeight))
            }
            return result
          }

          var from = change.from,
            to = change.to,
            text = change.text
          var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line)
          var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line

          // Adjust the line structure
          if (change.full) {
            doc.insert(0, linesFor(0, text.length))
            doc.remove(text.length, doc.size - text.length)
          } else if (isWholeLineUpdate(doc, change)) {
            // This is a whole-line replace. Treated specially to make
            // sure line objects move the way they are supposed to.
            var added = linesFor(0, text.length - 1)
            update(lastLine, lastLine.text, lastSpans)
            if (nlines) {
              doc.remove(from.line, nlines)
            }
            if (added.length) {
              doc.insert(from.line, added)
            }
          } else if (firstLine == lastLine) {
            if (text.length == 1) {
              update(
                firstLine,
                firstLine.text.slice(0, from.ch) +
                  lastText +
                  firstLine.text.slice(to.ch),
                lastSpans
              )
            } else {
              var added$1 = linesFor(1, text.length - 1)
              added$1.push(
                new Line(
                  lastText + firstLine.text.slice(to.ch),
                  lastSpans,
                  estimateHeight
                )
              )
              update(
                firstLine,
                firstLine.text.slice(0, from.ch) + text[0],
                spansFor(0)
              )
              doc.insert(from.line + 1, added$1)
            }
          } else if (text.length == 1) {
            update(
              firstLine,
              firstLine.text.slice(0, from.ch) +
                text[0] +
                lastLine.text.slice(to.ch),
              spansFor(0)
            )
            doc.remove(from.line + 1, nlines)
          } else {
            update(
              firstLine,
              firstLine.text.slice(0, from.ch) + text[0],
              spansFor(0)
            )
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)
            var added$2 = linesFor(1, text.length - 1)
            if (nlines > 1) {
              doc.remove(from.line + 1, nlines - 1)
            }
            doc.insert(from.line + 1, added$2)
          }

          signalLater(doc, 'change', doc, change)
        }

        // Call f for all linked documents.
        function linkedDocs(doc, f, sharedHistOnly) {
          function propagate(doc, skip, sharedHist) {
            if (doc.linked) {
              for (var i = 0; i < doc.linked.length; ++i) {
                var rel = doc.linked[i]
                if (rel.doc == skip) {
                  continue
                }
                var shared = sharedHist && rel.sharedHist
                if (sharedHistOnly && !shared) {
                  continue
                }
                f(rel.doc, shared)
                propagate(rel.doc, doc, shared)
              }
            }
          }
          propagate(doc, null, true)
        }

        // Attach a document to an editor.
        function attachDoc(cm, doc) {
          if (doc.cm) {
            throw new Error('This document is already in use.')
          }
          cm.doc = doc
          doc.cm = cm
          estimateLineHeights(cm)
          loadMode(cm)
          setDirectionClass(cm)
          cm.options.direction = doc.direction
          if (!cm.options.lineWrapping) {
            findMaxLine(cm)
          }
          cm.options.mode = doc.modeOption
          regChange(cm)
        }

        function setDirectionClass(cm) {
          ;(cm.doc.direction == 'rtl'
            ? addClass
            : rmClass)(cm.display.lineDiv, 'CodeMirror-rtl')
        }

        function directionChanged(cm) {
          runInOp(cm, function () {
            setDirectionClass(cm)
            regChange(cm)
          })
        }

        function History(prev) {
          // Arrays of change events and selections. Doing something adds an
          // event to done and clears undo. Undoing moves events from done
          // to undone, redoing moves them in the other direction.
          this.done = []
          this.undone = []
          this.undoDepth = prev ? prev.undoDepth : Infinity
          // Used to track when changes can be merged into a single undo
          // event
          this.lastModTime = this.lastSelTime = 0
          this.lastOp = this.lastSelOp = null
          this.lastOrigin = this.lastSelOrigin = null
          // Used by the isClean() method
          this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1
        }

        // Create a history change event from an updateDoc-style change
        // object.
        function historyChangeFromChange(doc, change) {
          var histChange = {
            from: copyPos(change.from),
            to: changeEnd(change),
            text: getBetween(doc, change.from, change.to)
          }
          attachLocalSpans(
            doc,
            histChange,
            change.from.line,
            change.to.line + 1
          )
          linkedDocs(
            doc,
            function (doc) {
              return attachLocalSpans(
                doc,
                histChange,
                change.from.line,
                change.to.line + 1
              )
            },
            true
          )
          return histChange
        }

        // Pop all selection events off the end of a history array. Stop at
        // a change event.
        function clearSelectionEvents(array) {
          while (array.length) {
            var last = lst(array)
            if (last.ranges) {
              array.pop()
            } else {
              break
            }
          }
        }

        // Find the top change event in the history. Pop off selection
        // events that are in the way.
        function lastChangeEvent(hist, force) {
          if (force) {
            clearSelectionEvents(hist.done)
            return lst(hist.done)
          } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done)
          } else if (
            hist.done.length > 1 &&
            !hist.done[hist.done.length - 2].ranges
          ) {
            hist.done.pop()
            return lst(hist.done)
          }
        }

        // Register a change in the history. Merges changes that are within
        // a single operation, or are close together with an origin that
        // allows merging (starting with "+") into a single event.
        function addChangeToHistory(doc, change, selAfter, opId) {
          var hist = doc.history
          hist.undone.length = 0
          var time = +new Date(),
            cur
          var last

          if (
            (hist.lastOp == opId ||
              (hist.lastOrigin == change.origin &&
                change.origin &&
                ((change.origin.charAt(0) == '+' &&
                  hist.lastModTime >
                    time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
                  change.origin.charAt(0) == '*'))) &&
            (cur = lastChangeEvent(hist, hist.lastOp == opId))
          ) {
            // Merge this change into the last event
            last = lst(cur.changes)
            if (
              cmp(change.from, change.to) == 0 &&
              cmp(change.from, last.to) == 0
            ) {
              // Optimized case for simple insertion -- don't want to add
              // new changesets for every character typed
              last.to = changeEnd(change)
            } else {
              // Add new sub-event
              cur.changes.push(historyChangeFromChange(doc, change))
            }
          } else {
            // Can not be merged, start a new event.
            var before = lst(hist.done)
            if (!before || !before.ranges) {
              pushSelectionToHistory(doc.sel, hist.done)
            }
            cur = {
              changes: [historyChangeFromChange(doc, change)],
              generation: hist.generation
            }
            hist.done.push(cur)
            while (hist.done.length > hist.undoDepth) {
              hist.done.shift()
              if (!hist.done[0].ranges) {
                hist.done.shift()
              }
            }
          }
          hist.done.push(selAfter)
          hist.generation = ++hist.maxGeneration
          hist.lastModTime = hist.lastSelTime = time
          hist.lastOp = hist.lastSelOp = opId
          hist.lastOrigin = hist.lastSelOrigin = change.origin

          if (!last) {
            signal(doc, 'historyAdded')
          }
        }

        function selectionEventCanBeMerged(doc, origin, prev, sel) {
          var ch = origin.charAt(0)
          return (
            ch == '*' ||
            (ch == '+' &&
              prev.ranges.length == sel.ranges.length &&
              prev.somethingSelected() == sel.somethingSelected() &&
              new Date() - doc.history.lastSelTime <=
                (doc.cm ? doc.cm.options.historyEventDelay : 500))
          )
        }

        // Called whenever the selection changes, sets the new selection as
        // the pending selection in the history, and pushes the old pending
        // selection into the 'done' array when it was significantly
        // different (in number of selected ranges, emptiness, or time).
        function addSelectionToHistory(doc, sel, opId, options) {
          var hist = doc.history,
            origin = options && options.origin

          // A new event is started when the previous origin does not match
          // the current, or the origins don't allow matching. Origins
          // starting with * are always merged, those starting with + are
          // merged when similar and close together in time.
          if (
            opId == hist.lastSelOp ||
            (origin &&
              hist.lastSelOrigin == origin &&
              ((hist.lastModTime == hist.lastSelTime &&
                hist.lastOrigin == origin) ||
                selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)))
          ) {
            hist.done[hist.done.length - 1] = sel
          } else {
            pushSelectionToHistory(sel, hist.done)
          }

          hist.lastSelTime = +new Date()
          hist.lastSelOrigin = origin
          hist.lastSelOp = opId
          if (options && options.clearRedo !== false) {
            clearSelectionEvents(hist.undone)
          }
        }

        function pushSelectionToHistory(sel, dest) {
          var top = lst(dest)
          if (!(top && top.ranges && top.equals(sel))) {
            dest.push(sel)
          }
        }

        // Used to store marked span information in the history.
        function attachLocalSpans(doc, change, from, to) {
          var existing = change['spans_' + doc.id],
            n = 0
          doc.iter(
            Math.max(doc.first, from),
            Math.min(doc.first + doc.size, to),
            function (line) {
              if (line.markedSpans) {
                ;(existing || (existing = change['spans_' + doc.id] = {}))[n] =
                  line.markedSpans
              }
              ++n
            }
          )
        }

        // When un/re-doing restores text containing marked spans, those
        // that have been explicitly cleared should not be restored.
        function removeClearedSpans(spans) {
          if (!spans) {
            return null
          }
          var out
          for (var i = 0; i < spans.length; ++i) {
            if (spans[i].marker.explicitlyCleared) {
              if (!out) {
                out = spans.slice(0, i)
              }
            } else if (out) {
              out.push(spans[i])
            }
          }
          return !out ? spans : out.length ? out : null
        }

        // Retrieve and filter the old marked spans stored in a change event.
        function getOldSpans(doc, change) {
          var found = change['spans_' + doc.id]
          if (!found) {
            return null
          }
          var nw = []
          for (var i = 0; i < change.text.length; ++i) {
            nw.push(removeClearedSpans(found[i]))
          }
          return nw
        }

        // Used for un/re-doing changes from the history. Combines the
        // result of computing the existing spans with the set of spans that
        // existed in the history (so that deleting around a span and then
        // undoing brings back the span).
        function mergeOldSpans(doc, change) {
          var old = getOldSpans(doc, change)
          var stretched = stretchSpansOverChange(doc, change)
          if (!old) {
            return stretched
          }
          if (!stretched) {
            return old
          }

          for (var i = 0; i < old.length; ++i) {
            var oldCur = old[i],
              stretchCur = stretched[i]
            if (oldCur && stretchCur) {
              spans: for (var j = 0; j < stretchCur.length; ++j) {
                var span = stretchCur[j]
                for (var k = 0; k < oldCur.length; ++k) {
                  if (oldCur[k].marker == span.marker) {
                    continue spans
                  }
                }
                oldCur.push(span)
              }
            } else if (stretchCur) {
              old[i] = stretchCur
            }
          }
          return old
        }

        // Used both to provide a JSON-safe object in .getHistory, and, when
        // detaching a document, to split the history in two
        function copyHistoryArray(events, newGroup, instantiateSel) {
          var copy = []
          for (var i = 0; i < events.length; ++i) {
            var event = events[i]
            if (event.ranges) {
              copy.push(
                instantiateSel
                  ? Selection.prototype.deepCopy.call(event)
                  : event
              )
              continue
            }
            var changes = event.changes,
              newChanges = []
            copy.push({ changes: newChanges })
            for (var j = 0; j < changes.length; ++j) {
              var change = changes[j],
                m = void 0
              newChanges.push({
                from: change.from,
                to: change.to,
                text: change.text
              })
              if (newGroup) {
                for (var prop in change) {
                  if ((m = prop.match(/^spans_(\d+)$/))) {
                    if (indexOf(newGroup, Number(m[1])) > -1) {
                      lst(newChanges)[prop] = change[prop]
                      delete change[prop]
                    }
                  }
                }
              }
            }
          }
          return copy
        }

        // The 'scroll' parameter given to many of these indicated whether
        // the new cursor position should be scrolled into view after
        // modifying the selection.

        // If shift is held or the extend flag is set, extends a range to
        // include a given position (and optionally a second position).
        // Otherwise, simply returns the range between the given positions.
        // Used for cursor motion and such.
        function extendRange(range, head, other, extend) {
          if (extend) {
            var anchor = range.anchor
            if (other) {
              var posBefore = cmp(head, anchor) < 0
              if (posBefore != cmp(other, anchor) < 0) {
                anchor = head
                head = other
              } else if (posBefore != cmp(head, other) < 0) {
                head = other
              }
            }
            return new Range(anchor, head)
          } else {
            return new Range(other || head, head)
          }
        }

        // Extend the primary selection range, discard the rest.
        function extendSelection(doc, head, other, options, extend) {
          if (extend == null) {
            extend = doc.cm && (doc.cm.display.shift || doc.extend)
          }
          setSelection(
            doc,
            new Selection(
              [extendRange(doc.sel.primary(), head, other, extend)],
              0
            ),
            options
          )
        }

        // Extend all selections (pos is an array of selections with length
        // equal the number of selections)
        function extendSelections(doc, heads, options) {
          var out = []
          var extend = doc.cm && (doc.cm.display.shift || doc.extend)
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend)
          }
          var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex)
          setSelection(doc, newSel, options)
        }

        // Updates a single range in the selection.
        function replaceOneSelection(doc, i, range, options) {
          var ranges = doc.sel.ranges.slice(0)
          ranges[i] = range
          setSelection(
            doc,
            normalizeSelection(doc.cm, ranges, doc.sel.primIndex),
            options
          )
        }

        // Reset the selection to a single range.
        function setSimpleSelection(doc, anchor, head, options) {
          setSelection(doc, simpleSelection(anchor, head), options)
        }

        // Give beforeSelectionChange handlers a change to influence a
        // selection update.
        function filterSelectionChange(doc, sel, options) {
          var obj = {
            ranges: sel.ranges,
            update: function (ranges) {
              this.ranges = []
              for (var i = 0; i < ranges.length; i++) {
                this.ranges[i] = new Range(
                  clipPos(doc, ranges[i].anchor),
                  clipPos(doc, ranges[i].head)
                )
              }
            },
            origin: options && options.origin
          }
          signal(doc, 'beforeSelectionChange', doc, obj)
          if (doc.cm) {
            signal(doc.cm, 'beforeSelectionChange', doc.cm, obj)
          }
          if (obj.ranges != sel.ranges) {
            return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1)
          } else {
            return sel
          }
        }

        function setSelectionReplaceHistory(doc, sel, options) {
          var done = doc.history.done,
            last = lst(done)
          if (last && last.ranges) {
            done[done.length - 1] = sel
            setSelectionNoUndo(doc, sel, options)
          } else {
            setSelection(doc, sel, options)
          }
        }

        // Set a new selection.
        function setSelection(doc, sel, options) {
          setSelectionNoUndo(doc, sel, options)
          addSelectionToHistory(
            doc,
            doc.sel,
            doc.cm ? doc.cm.curOp.id : NaN,
            options
          )
        }

        function setSelectionNoUndo(doc, sel, options) {
          if (
            hasHandler(doc, 'beforeSelectionChange') ||
            (doc.cm && hasHandler(doc.cm, 'beforeSelectionChange'))
          ) {
            sel = filterSelectionChange(doc, sel, options)
          }

          var bias =
            (options && options.bias) ||
            (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)
          setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))

          if (
            !(options && options.scroll === false) &&
            doc.cm &&
            doc.cm.getOption('readOnly') != 'nocursor'
          ) {
            ensureCursorVisible(doc.cm)
          }
        }

        function setSelectionInner(doc, sel) {
          if (sel.equals(doc.sel)) {
            return
          }

          doc.sel = sel

          if (doc.cm) {
            doc.cm.curOp.updateInput = 1
            doc.cm.curOp.selectionChanged = true
            signalCursorActivity(doc.cm)
          }
          signalLater(doc, 'cursorActivity', doc)
        }

        // Verify that the selection does not partially select any atomic
        // marked ranges.
        function reCheckSelection(doc) {
          setSelectionInner(
            doc,
            skipAtomicInSelection(doc, doc.sel, null, false)
          )
        }

        // Return a selection that does not partially select any atomic
        // ranges.
        function skipAtomicInSelection(doc, sel, bias, mayClear) {
          var out
          for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i]
            var old =
              sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]
            var newAnchor = skipAtomic(
              doc,
              range.anchor,
              old && old.anchor,
              bias,
              mayClear
            )
            var newHead = skipAtomic(
              doc,
              range.head,
              old && old.head,
              bias,
              mayClear
            )
            if (out || newAnchor != range.anchor || newHead != range.head) {
              if (!out) {
                out = sel.ranges.slice(0, i)
              }
              out[i] = new Range(newAnchor, newHead)
            }
          }
          return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
        }

        function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
          var line = getLine(doc, pos.line)
          if (line.markedSpans) {
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var sp = line.markedSpans[i],
                m = sp.marker

              // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
              // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
              // is with selectLeft/Right
              var preventCursorLeft =
                'selectLeft' in m ? !m.selectLeft : m.inclusiveLeft
              var preventCursorRight =
                'selectRight' in m ? !m.selectRight : m.inclusiveRight

              if (
                (sp.from == null ||
                  (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
                (sp.to == null ||
                  (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))
              ) {
                if (mayClear) {
                  signal(m, 'beforeCursorEnter')
                  if (m.explicitlyCleared) {
                    if (!line.markedSpans) {
                      break
                    } else {
                      --i
                      continue
                    }
                  }
                }
                if (!m.atomic) {
                  continue
                }

                if (oldPos) {
                  var near = m.find(dir < 0 ? 1 : -1),
                    diff = void 0
                  if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                    near = movePos(
                      doc,
                      near,
                      -dir,
                      near && near.line == pos.line ? line : null
                    )
                  }
                  if (
                    near &&
                    near.line == pos.line &&
                    (diff = cmp(near, oldPos)) &&
                    (dir < 0 ? diff < 0 : diff > 0)
                  ) {
                    return skipAtomicInner(doc, near, pos, dir, mayClear)
                  }
                }

                var far = m.find(dir < 0 ? -1 : 1)
                if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                  far = movePos(
                    doc,
                    far,
                    dir,
                    far.line == pos.line ? line : null
                  )
                }
                return far
                  ? skipAtomicInner(doc, far, pos, dir, mayClear)
                  : null
              }
            }
          }
          return pos
        }

        // Ensure a given position is not inside an atomic range.
        function skipAtomic(doc, pos, oldPos, bias, mayClear) {
          var dir = bias || 1
          var found =
            skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
            (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
            skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
            (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))
          if (!found) {
            doc.cantEdit = true
            return Pos(doc.first, 0)
          }
          return found
        }

        function movePos(doc, pos, dir, line) {
          if (dir < 0 && pos.ch == 0) {
            if (pos.line > doc.first) {
              return clipPos(doc, Pos(pos.line - 1))
            } else {
              return null
            }
          } else if (
            dir > 0 &&
            pos.ch == (line || getLine(doc, pos.line)).text.length
          ) {
            if (pos.line < doc.first + doc.size - 1) {
              return Pos(pos.line + 1, 0)
            } else {
              return null
            }
          } else {
            return new Pos(pos.line, pos.ch + dir)
          }
        }

        function selectAll(cm) {
          cm.setSelection(
            Pos(cm.firstLine(), 0),
            Pos(cm.lastLine()),
            sel_dontScroll
          )
        }

        // UPDATING

        // Allow "beforeChange" event handlers to influence a change
        function filterChange(doc, change, update) {
          var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function () {
              return (obj.canceled = true)
            }
          }
          if (update) {
            obj.update = function (from, to, text, origin) {
              if (from) {
                obj.from = clipPos(doc, from)
              }
              if (to) {
                obj.to = clipPos(doc, to)
              }
              if (text) {
                obj.text = text
              }
              if (origin !== undefined) {
                obj.origin = origin
              }
            }
          }
          signal(doc, 'beforeChange', doc, obj)
          if (doc.cm) {
            signal(doc.cm, 'beforeChange', doc.cm, obj)
          }

          if (obj.canceled) {
            if (doc.cm) {
              doc.cm.curOp.updateInput = 2
            }
            return null
          }
          return {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
          }
        }

        // Apply a change to a document, and add it to the document's
        // history, and propagating it to all linked documents.
        function makeChange(doc, change, ignoreReadOnly) {
          if (doc.cm) {
            if (!doc.cm.curOp) {
              return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly)
            }
            if (doc.cm.state.suppressEdits) {
              return
            }
          }

          if (
            hasHandler(doc, 'beforeChange') ||
            (doc.cm && hasHandler(doc.cm, 'beforeChange'))
          ) {
            change = filterChange(doc, change, true)
            if (!change) {
              return
            }
          }

          // Possibly split or suppress the update based on the presence
          // of read-only spans in its range.
          var split =
            sawReadOnlySpans &&
            !ignoreReadOnly &&
            removeReadOnlyRanges(doc, change.from, change.to)
          if (split) {
            for (var i = split.length - 1; i >= 0; --i) {
              makeChangeInner(doc, {
                from: split[i].from,
                to: split[i].to,
                text: i ? [''] : change.text,
                origin: change.origin
              })
            }
          } else {
            makeChangeInner(doc, change)
          }
        }

        function makeChangeInner(doc, change) {
          if (
            change.text.length == 1 &&
            change.text[0] == '' &&
            cmp(change.from, change.to) == 0
          ) {
            return
          }
          var selAfter = computeSelAfterChange(doc, change)
          addChangeToHistory(
            doc,
            change,
            selAfter,
            doc.cm ? doc.cm.curOp.id : NaN
          )

          makeChangeSingleDoc(
            doc,
            change,
            selAfter,
            stretchSpansOverChange(doc, change)
          )
          var rebased = []

          linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change)
              rebased.push(doc.history)
            }
            makeChangeSingleDoc(
              doc,
              change,
              null,
              stretchSpansOverChange(doc, change)
            )
          })
        }

        // Revert a change stored in a document's history.
        function makeChangeFromHistory(doc, type, allowSelectionOnly) {
          var suppress = doc.cm && doc.cm.state.suppressEdits
          if (suppress && !allowSelectionOnly) {
            return
          }

          var hist = doc.history,
            event,
            selAfter = doc.sel
          var source = type == 'undo' ? hist.done : hist.undone,
            dest = type == 'undo' ? hist.undone : hist.done

          // Verify that there is a useable event (so that ctrl-z won't
          // needlessly clear selection events)
          var i = 0
          for (; i < source.length; i++) {
            event = source[i]
            if (
              allowSelectionOnly
                ? event.ranges && !event.equals(doc.sel)
                : !event.ranges
            ) {
              break
            }
          }
          if (i == source.length) {
            return
          }
          hist.lastOrigin = hist.lastSelOrigin = null

          for (;;) {
            event = source.pop()
            if (event.ranges) {
              pushSelectionToHistory(event, dest)
              if (allowSelectionOnly && !event.equals(doc.sel)) {
                setSelection(doc, event, { clearRedo: false })
                return
              }
              selAfter = event
            } else if (suppress) {
              source.push(event)
              return
            } else {
              break
            }
          }

          // Build up a reverse change object to add to the opposite history
          // stack (redo when undoing, and vice versa).
          var antiChanges = []
          pushSelectionToHistory(selAfter, dest)
          dest.push({ changes: antiChanges, generation: hist.generation })
          hist.generation = event.generation || ++hist.maxGeneration

          var filter =
            hasHandler(doc, 'beforeChange') ||
            (doc.cm && hasHandler(doc.cm, 'beforeChange'))

          var loop = function (i) {
            var change = event.changes[i]
            change.origin = type
            if (filter && !filterChange(doc, change, false)) {
              source.length = 0
              return {}
            }

            antiChanges.push(historyChangeFromChange(doc, change))

            var after = i ? computeSelAfterChange(doc, change) : lst(source)
            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))
            if (!i && doc.cm) {
              doc.cm.scrollIntoView({
                from: change.from,
                to: changeEnd(change)
              })
            }
            var rebased = []

            // Propagate to the linked documents
            linkedDocs(doc, function (doc, sharedHist) {
              if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                rebaseHist(doc.history, change)
                rebased.push(doc.history)
              }
              makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
            })
          }

          for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
            var returned = loop(i$1)

            if (returned) return returned.v
          }
        }

        // Sub-views need their line numbers shifted when text is added
        // above or below them in the parent document.
        function shiftDoc(doc, distance) {
          if (distance == 0) {
            return
          }
          doc.first += distance
          doc.sel = new Selection(
            map(doc.sel.ranges, function (range) {
              return new Range(
                Pos(range.anchor.line + distance, range.anchor.ch),
                Pos(range.head.line + distance, range.head.ch)
              )
            }),
            doc.sel.primIndex
          )
          if (doc.cm) {
            regChange(doc.cm, doc.first, doc.first - distance, distance)
            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
              regLineChange(doc.cm, l, 'gutter')
            }
          }
        }

        // More lower-level change function, handling only a single document
        // (not linked ones).
        function makeChangeSingleDoc(doc, change, selAfter, spans) {
          if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, makeChangeSingleDoc)(
              doc,
              change,
              selAfter,
              spans
            )
          }

          if (change.to.line < doc.first) {
            shiftDoc(
              doc,
              change.text.length - 1 - (change.to.line - change.from.line)
            )
            return
          }
          if (change.from.line > doc.lastLine()) {
            return
          }

          // Clip the change to the size of this doc
          if (change.from.line < doc.first) {
            var shift = change.text.length - 1 - (doc.first - change.from.line)
            shiftDoc(doc, shift)
            change = {
              from: Pos(doc.first, 0),
              to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)],
              origin: change.origin
            }
          }
          var last = doc.lastLine()
          if (change.to.line > last) {
            change = {
              from: change.from,
              to: Pos(last, getLine(doc, last).text.length),
              text: [change.text[0]],
              origin: change.origin
            }
          }

          change.removed = getBetween(doc, change.from, change.to)

          if (!selAfter) {
            selAfter = computeSelAfterChange(doc, change)
          }
          if (doc.cm) {
            makeChangeSingleDocInEditor(doc.cm, change, spans)
          } else {
            updateDoc(doc, change, spans)
          }
          setSelectionNoUndo(doc, selAfter, sel_dontScroll)

          if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
            doc.cantEdit = false
          }
        }

        // Handle the interaction of a change to a document with the editor
        // that this document is part of.
        function makeChangeSingleDocInEditor(cm, change, spans) {
          var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to

          var recomputeMaxLength = false,
            checkWidthStart = from.line
          if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))
            doc.iter(checkWidthStart, to.line + 1, function (line) {
              if (line == display.maxLine) {
                recomputeMaxLength = true
                return true
              }
            })
          }

          if (doc.sel.contains(change.from, change.to) > -1) {
            signalCursorActivity(cm)
          }

          updateDoc(doc, change, spans, estimateHeight(cm))

          if (!cm.options.lineWrapping) {
            doc.iter(
              checkWidthStart,
              from.line + change.text.length,
              function (line) {
                var len = lineLength(line)
                if (len > display.maxLineLength) {
                  display.maxLine = line
                  display.maxLineLength = len
                  display.maxLineChanged = true
                  recomputeMaxLength = false
                }
              }
            )
            if (recomputeMaxLength) {
              cm.curOp.updateMaxLine = true
            }
          }

          retreatFrontier(doc, from.line)
          startWorker(cm, 400)

          var lendiff = change.text.length - (to.line - from.line) - 1
          // Remember that these lines changed, for updating the display
          if (change.full) {
            regChange(cm)
          } else if (
            from.line == to.line &&
            change.text.length == 1 &&
            !isWholeLineUpdate(cm.doc, change)
          ) {
            regLineChange(cm, from.line, 'text')
          } else {
            regChange(cm, from.line, to.line + 1, lendiff)
          }

          var changesHandler = hasHandler(cm, 'changes'),
            changeHandler = hasHandler(cm, 'change')
          if (changeHandler || changesHandler) {
            var obj = {
              from: from,
              to: to,
              text: change.text,
              removed: change.removed,
              origin: change.origin
            }
            if (changeHandler) {
              signalLater(cm, 'change', cm, obj)
            }
            if (changesHandler) {
              ;(cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj)
            }
          }
          cm.display.selForContextMenu = null
        }

        function replaceRange(doc, code, from, to, origin) {
          var assign

          if (!to) {
            to = from
          }
          if (cmp(to, from) < 0) {
            ;(assign = [to, from]), (from = assign[0]), (to = assign[1])
          }
          if (typeof code == 'string') {
            code = doc.splitLines(code)
          }
          makeChange(doc, { from: from, to: to, text: code, origin: origin })
        }

        // Rebasing/resetting history to deal with externally-sourced changes

        function rebaseHistSelSingle(pos, from, to, diff) {
          if (to < pos.line) {
            pos.line += diff
          } else if (from < pos.line) {
            pos.line = from
            pos.ch = 0
          }
        }

        // Tries to rebase an array of history events given a change in the
        // document. If the change touches the same lines as the event, the
        // event, and everything 'behind' it, is discarded. If the change is
        // before the event, the event's positions are updated. Uses a
        // copy-on-write scheme for the positions, to avoid having to
        // reallocate them all on every rebase, but also avoid problems with
        // shared position objects being unsafely updated.
        function rebaseHistArray(array, from, to, diff) {
          for (var i = 0; i < array.length; ++i) {
            var sub = array[i],
              ok = true
            if (sub.ranges) {
              if (!sub.copied) {
                sub = array[i] = sub.deepCopy()
                sub.copied = true
              }
              for (var j = 0; j < sub.ranges.length; j++) {
                rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)
                rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
              }
              continue
            }
            for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
              var cur = sub.changes[j$1]
              if (to < cur.from.line) {
                cur.from = Pos(cur.from.line + diff, cur.from.ch)
                cur.to = Pos(cur.to.line + diff, cur.to.ch)
              } else if (from <= cur.to.line) {
                ok = false
                break
              }
            }
            if (!ok) {
              array.splice(0, i + 1)
              i = 0
            }
          }
        }

        function rebaseHist(hist, change) {
          var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1
          rebaseHistArray(hist.done, from, to, diff)
          rebaseHistArray(hist.undone, from, to, diff)
        }

        // Utility for applying a change to a line by handle or number,
        // returning the number and optionally registering the line as
        // changed.
        function changeLine(doc, handle, changeType, op) {
          var no = handle,
            line = handle
          if (typeof handle == 'number') {
            line = getLine(doc, clipLine(doc, handle))
          } else {
            no = lineNo(handle)
          }
          if (no == null) {
            return null
          }
          if (op(line, no) && doc.cm) {
            regLineChange(doc.cm, no, changeType)
          }
          return line
        }

        // The document is represented as a BTree consisting of leaves, with
        // chunk of lines in them, and branches, with up to ten leaves or
        // other branch nodes below them. The top node is always a branch
        // node, and is the document object itself (meaning it has
        // additional methods and properties).
        //
        // All nodes have parent links. The tree is used both to go from
        // line numbers to line objects, and to go from objects to numbers.
        // It also indexes by height, and is used to convert between height
        // and line object, and to find the total height of the document.
        //
        // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

        function LeafChunk(lines) {
          this.lines = lines
          this.parent = null
          var height = 0
          for (var i = 0; i < lines.length; ++i) {
            lines[i].parent = this
            height += lines[i].height
          }
          this.height = height
        }

        LeafChunk.prototype = {
          chunkSize: function () {
            return this.lines.length
          },

          // Remove the n lines at offset 'at'.
          removeInner: function (at, n) {
            for (var i = at, e = at + n; i < e; ++i) {
              var line = this.lines[i]
              this.height -= line.height
              cleanUpLine(line)
              signalLater(line, 'delete')
            }
            this.lines.splice(at, n)
          },

          // Helper used to collapse a small branch into a single leaf.
          collapse: function (lines) {
            lines.push.apply(lines, this.lines)
          },

          // Insert the given array of lines at offset 'at', count them as
          // having the given height.
          insertInner: function (at, lines, height) {
            this.height += height
            this.lines = this.lines
              .slice(0, at)
              .concat(lines)
              .concat(this.lines.slice(at))
            for (var i = 0; i < lines.length; ++i) {
              lines[i].parent = this
            }
          },

          // Used to iterate over a part of the tree.
          iterN: function (at, n, op) {
            for (var e = at + n; at < e; ++at) {
              if (op(this.lines[at])) {
                return true
              }
            }
          }
        }

        function BranchChunk(children) {
          this.children = children
          var size = 0,
            height = 0
          for (var i = 0; i < children.length; ++i) {
            var ch = children[i]
            size += ch.chunkSize()
            height += ch.height
            ch.parent = this
          }
          this.size = size
          this.height = height
          this.parent = null
        }

        BranchChunk.prototype = {
          chunkSize: function () {
            return this.size
          },

          removeInner: function (at, n) {
            this.size -= n
            for (var i = 0; i < this.children.length; ++i) {
              var child = this.children[i],
                sz = child.chunkSize()
              if (at < sz) {
                var rm = Math.min(n, sz - at),
                  oldHeight = child.height
                child.removeInner(at, rm)
                this.height -= oldHeight - child.height
                if (sz == rm) {
                  this.children.splice(i--, 1)
                  child.parent = null
                }
                if ((n -= rm) == 0) {
                  break
                }
                at = 0
              } else {
                at -= sz
              }
            }
            // If the result is smaller than 25 lines, ensure that it is a
            // single leaf node.
            if (
              this.size - n < 25 &&
              (this.children.length > 1 ||
                !(this.children[0] instanceof LeafChunk))
            ) {
              var lines = []
              this.collapse(lines)
              this.children = [new LeafChunk(lines)]
              this.children[0].parent = this
            }
          },

          collapse: function (lines) {
            for (var i = 0; i < this.children.length; ++i) {
              this.children[i].collapse(lines)
            }
          },

          insertInner: function (at, lines, height) {
            this.size += lines.length
            this.height += height
            for (var i = 0; i < this.children.length; ++i) {
              var child = this.children[i],
                sz = child.chunkSize()
              if (at <= sz) {
                child.insertInner(at, lines, height)
                if (child.lines && child.lines.length > 50) {
                  // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
                  // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
                  var remaining = (child.lines.length % 25) + 25
                  for (var pos = remaining; pos < child.lines.length; ) {
                    var leaf = new LeafChunk(
                      child.lines.slice(pos, (pos += 25))
                    )
                    child.height -= leaf.height
                    this.children.splice(++i, 0, leaf)
                    leaf.parent = this
                  }
                  child.lines = child.lines.slice(0, remaining)
                  this.maybeSpill()
                }
                break
              }
              at -= sz
            }
          },

          // When a node has grown, check whether it should be split.
          maybeSpill: function () {
            if (this.children.length <= 10) {
              return
            }
            var me = this
            do {
              var spilled = me.children.splice(me.children.length - 5, 5)
              var sibling = new BranchChunk(spilled)
              if (!me.parent) {
                // Become the parent node
                var copy = new BranchChunk(me.children)
                copy.parent = me
                me.children = [copy, sibling]
                me = copy
              } else {
                me.size -= sibling.size
                me.height -= sibling.height
                var myIndex = indexOf(me.parent.children, me)
                me.parent.children.splice(myIndex + 1, 0, sibling)
              }
              sibling.parent = me.parent
            } while (me.children.length > 10)
            me.parent.maybeSpill()
          },

          iterN: function (at, n, op) {
            for (var i = 0; i < this.children.length; ++i) {
              var child = this.children[i],
                sz = child.chunkSize()
              if (at < sz) {
                var used = Math.min(n, sz - at)
                if (child.iterN(at, used, op)) {
                  return true
                }
                if ((n -= used) == 0) {
                  break
                }
                at = 0
              } else {
                at -= sz
              }
            }
          }
        }

        // Line widgets are block elements displayed above or below a line.

        var LineWidget = function (doc, node, options) {
          if (options) {
            for (var opt in options) {
              if (options.hasOwnProperty(opt)) {
                this[opt] = options[opt]
              }
            }
          }
          this.doc = doc
          this.node = node
        }

        LineWidget.prototype.clear = function () {
          var cm = this.doc.cm,
            ws = this.line.widgets,
            line = this.line,
            no = lineNo(line)
          if (no == null || !ws) {
            return
          }
          for (var i = 0; i < ws.length; ++i) {
            if (ws[i] == this) {
              ws.splice(i--, 1)
            }
          }
          if (!ws.length) {
            line.widgets = null
          }
          var height = widgetHeight(this)
          updateLineHeight(line, Math.max(0, line.height - height))
          if (cm) {
            runInOp(cm, function () {
              adjustScrollWhenAboveVisible(cm, line, -height)
              regLineChange(cm, no, 'widget')
            })
            signalLater(cm, 'lineWidgetCleared', cm, this, no)
          }
        }

        LineWidget.prototype.changed = function () {
          var this$1 = this

          var oldH = this.height,
            cm = this.doc.cm,
            line = this.line
          this.height = null
          var diff = widgetHeight(this) - oldH
          if (!diff) {
            return
          }
          if (!lineIsHidden(this.doc, line)) {
            updateLineHeight(line, line.height + diff)
          }
          if (cm) {
            runInOp(cm, function () {
              cm.curOp.forceUpdate = true
              adjustScrollWhenAboveVisible(cm, line, diff)
              signalLater(cm, 'lineWidgetChanged', cm, this$1, lineNo(line))
            })
          }
        }
        eventMixin(LineWidget)

        function adjustScrollWhenAboveVisible(cm, line, diff) {
          if (
            heightAtLine(line) <
            ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop)
          ) {
            addToScrollTop(cm, diff)
          }
        }

        function addLineWidget(doc, handle, node, options) {
          var widget = new LineWidget(doc, node, options)
          var cm = doc.cm
          if (cm && widget.noHScroll) {
            cm.display.alignWidgets = true
          }
          changeLine(doc, handle, 'widget', function (line) {
            var widgets = line.widgets || (line.widgets = [])
            if (widget.insertAt == null) {
              widgets.push(widget)
            } else {
              widgets.splice(
                Math.min(widgets.length, Math.max(0, widget.insertAt)),
                0,
                widget
              )
            }
            widget.line = line
            if (cm && !lineIsHidden(doc, line)) {
              var aboveVisible = heightAtLine(line) < doc.scrollTop
              updateLineHeight(line, line.height + widgetHeight(widget))
              if (aboveVisible) {
                addToScrollTop(cm, widget.height)
              }
              cm.curOp.forceUpdate = true
            }
            return true
          })
          if (cm) {
            signalLater(
              cm,
              'lineWidgetAdded',
              cm,
              widget,
              typeof handle == 'number' ? handle : lineNo(handle)
            )
          }
          return widget
        }

        // TEXTMARKERS

        // Created with markText and setBookmark methods. A TextMarker is a
        // handle that can be used to clear or find a marked position in the
        // document. Line objects hold arrays (markedSpans) containing
        // {from, to, marker} object pointing to such marker objects, and
        // indicating that such a marker is present on that line. Multiple
        // lines may point to the same marker when it spans across lines.
        // The spans will have null for their from/to properties when the
        // marker continues beyond the start/end of the line. Markers have
        // links back to the lines they currently touch.

        // Collapsed markers have unique ids, in order to be able to order
        // them, which is needed for uniquely determining an outer marker
        // when they overlap (they may nest, but not partially overlap).
        var nextMarkerId = 0

        var TextMarker = function (doc, type) {
          this.lines = []
          this.type = type
          this.doc = doc
          this.id = ++nextMarkerId
        }

        // Clear the marker.
        TextMarker.prototype.clear = function () {
          if (this.explicitlyCleared) {
            return
          }
          var cm = this.doc.cm,
            withOp = cm && !cm.curOp
          if (withOp) {
            startOperation(cm)
          }
          if (hasHandler(this, 'clear')) {
            var found = this.find()
            if (found) {
              signalLater(this, 'clear', found.from, found.to)
            }
          }
          var min = null,
            max = null
          for (var i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i]
            var span = getMarkedSpanFor(line.markedSpans, this)
            if (cm && !this.collapsed) {
              regLineChange(cm, lineNo(line), 'text')
            } else if (cm) {
              if (span.to != null) {
                max = lineNo(line)
              }
              if (span.from != null) {
                min = lineNo(line)
              }
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span)
            if (
              span.from == null &&
              this.collapsed &&
              !lineIsHidden(this.doc, line) &&
              cm
            ) {
              updateLineHeight(line, textHeight(cm.display))
            }
          }
          if (cm && this.collapsed && !cm.options.lineWrapping) {
            for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
              var visual = visualLine(this.lines[i$1]),
                len = lineLength(visual)
              if (len > cm.display.maxLineLength) {
                cm.display.maxLine = visual
                cm.display.maxLineLength = len
                cm.display.maxLineChanged = true
              }
            }
          }

          if (min != null && cm && this.collapsed) {
            regChange(cm, min, max + 1)
          }
          this.lines.length = 0
          this.explicitlyCleared = true
          if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false
            if (cm) {
              reCheckSelection(cm.doc)
            }
          }
          if (cm) {
            signalLater(cm, 'markerCleared', cm, this, min, max)
          }
          if (withOp) {
            endOperation(cm)
          }
          if (this.parent) {
            this.parent.clear()
          }
        }

        // Find the position of the marker in the document. Returns a {from,
        // to} object by default. Side can be passed to get a specific side
        // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
        // Pos objects returned contain a line object, rather than a line
        // number (used to prevent looking up the same line twice).
        TextMarker.prototype.find = function (side, lineObj) {
          if (side == null && this.type == 'bookmark') {
            side = 1
          }
          var from, to
          for (var i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i]
            var span = getMarkedSpanFor(line.markedSpans, this)
            if (span.from != null) {
              from = Pos(lineObj ? line : lineNo(line), span.from)
              if (side == -1) {
                return from
              }
            }
            if (span.to != null) {
              to = Pos(lineObj ? line : lineNo(line), span.to)
              if (side == 1) {
                return to
              }
            }
          }
          return from && { from: from, to: to }
        }

        // Signals that the marker's widget changed, and surrounding layout
        // should be recomputed.
        TextMarker.prototype.changed = function () {
          var this$1 = this

          var pos = this.find(-1, true),
            widget = this,
            cm = this.doc.cm
          if (!pos || !cm) {
            return
          }
          runInOp(cm, function () {
            var line = pos.line,
              lineN = lineNo(pos.line)
            var view = findViewForLine(cm, lineN)
            if (view) {
              clearLineMeasurementCacheFor(view)
              cm.curOp.selectionChanged = cm.curOp.forceUpdate = true
            }
            cm.curOp.updateMaxLine = true
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
              var oldHeight = widget.height
              widget.height = null
              var dHeight = widgetHeight(widget) - oldHeight
              if (dHeight) {
                updateLineHeight(line, line.height + dHeight)
              }
            }
            signalLater(cm, 'markerChanged', cm, this$1)
          })
        }

        TextMarker.prototype.attachLine = function (line) {
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp
            if (
              !op.maybeHiddenMarkers ||
              indexOf(op.maybeHiddenMarkers, this) == -1
            ) {
              ;(op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(
                this
              )
            }
          }
          this.lines.push(line)
        }

        TextMarker.prototype.detachLine = function (line) {
          this.lines.splice(indexOf(this.lines, line), 1)
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp
            ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
          }
        }
        eventMixin(TextMarker)

        // Create a marker, wire it up to the right lines, and
        function markText(doc, from, to, options, type) {
          // Shared markers (across linked documents) are handled separately
          // (markTextShared will call out to this again, once per
          // document).
          if (options && options.shared) {
            return markTextShared(doc, from, to, options, type)
          }
          // Ensure we are in an operation.
          if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, markText)(doc, from, to, options, type)
          }

          var marker = new TextMarker(doc, type),
            diff = cmp(from, to)
          if (options) {
            copyObj(options, marker, false)
          }
          // Don't connect empty markers unless clearWhenEmpty is false
          if (diff > 0 || (diff == 0 && marker.clearWhenEmpty !== false)) {
            return marker
          }
          if (marker.replacedWith) {
            // Showing up as a widget implies collapsed (widget replaces text)
            marker.collapsed = true
            marker.widgetNode = eltP(
              'span',
              [marker.replacedWith],
              'CodeMirror-widget'
            )
            if (!options.handleMouseEvents) {
              marker.widgetNode.setAttribute('cm-ignore-events', 'true')
            }
            if (options.insertLeft) {
              marker.widgetNode.insertLeft = true
            }
          }
          if (marker.collapsed) {
            if (
              conflictingCollapsedRange(doc, from.line, from, to, marker) ||
              (from.line != to.line &&
                conflictingCollapsedRange(doc, to.line, from, to, marker))
            ) {
              throw new Error(
                'Inserting collapsed marker partially overlapping an existing one'
              )
            }
            seeCollapsedSpans()
          }

          if (marker.addToHistory) {
            addChangeToHistory(
              doc,
              { from: from, to: to, origin: 'markText' },
              doc.sel,
              NaN
            )
          }

          var curLine = from.line,
            cm = doc.cm,
            updateMaxLine
          doc.iter(curLine, to.line + 1, function (line) {
            if (
              cm &&
              marker.collapsed &&
              !cm.options.lineWrapping &&
              visualLine(line) == cm.display.maxLine
            ) {
              updateMaxLine = true
            }
            if (marker.collapsed && curLine != from.line) {
              updateLineHeight(line, 0)
            }
            addMarkedSpan(
              line,
              new MarkedSpan(
                marker,
                curLine == from.line ? from.ch : null,
                curLine == to.line ? to.ch : null
              ),
              doc.cm && doc.cm.curOp
            )
            ++curLine
          })
          // lineIsHidden depends on the presence of the spans, so needs a second pass
          if (marker.collapsed) {
            doc.iter(from.line, to.line + 1, function (line) {
              if (lineIsHidden(doc, line)) {
                updateLineHeight(line, 0)
              }
            })
          }

          if (marker.clearOnEnter) {
            on(marker, 'beforeCursorEnter', function () {
              return marker.clear()
            })
          }

          if (marker.readOnly) {
            seeReadOnlySpans()
            if (doc.history.done.length || doc.history.undone.length) {
              doc.clearHistory()
            }
          }
          if (marker.collapsed) {
            marker.id = ++nextMarkerId
            marker.atomic = true
          }
          if (cm) {
            // Sync editor state
            if (updateMaxLine) {
              cm.curOp.updateMaxLine = true
            }
            if (marker.collapsed) {
              regChange(cm, from.line, to.line + 1)
            } else if (
              marker.className ||
              marker.startStyle ||
              marker.endStyle ||
              marker.css ||
              marker.attributes ||
              marker.title
            ) {
              for (var i = from.line; i <= to.line; i++) {
                regLineChange(cm, i, 'text')
              }
            }
            if (marker.atomic) {
              reCheckSelection(cm.doc)
            }
            signalLater(cm, 'markerAdded', cm, marker)
          }
          return marker
        }

        // SHARED TEXTMARKERS

        // A shared marker spans multiple linked documents. It is
        // implemented as a meta-marker-object controlling multiple normal
        // markers.
        var SharedTextMarker = function (markers, primary) {
          this.markers = markers
          this.primary = primary
          for (var i = 0; i < markers.length; ++i) {
            markers[i].parent = this
          }
        }

        SharedTextMarker.prototype.clear = function () {
          if (this.explicitlyCleared) {
            return
          }
          this.explicitlyCleared = true
          for (var i = 0; i < this.markers.length; ++i) {
            this.markers[i].clear()
          }
          signalLater(this, 'clear')
        }

        SharedTextMarker.prototype.find = function (side, lineObj) {
          return this.primary.find(side, lineObj)
        }
        eventMixin(SharedTextMarker)

        function markTextShared(doc, from, to, options, type) {
          options = copyObj(options)
          options.shared = false
          var markers = [markText(doc, from, to, options, type)],
            primary = markers[0]
          var widget = options.widgetNode
          linkedDocs(doc, function (doc) {
            if (widget) {
              options.widgetNode = widget.cloneNode(true)
            }
            markers.push(
              markText(doc, clipPos(doc, from), clipPos(doc, to), options, type)
            )
            for (var i = 0; i < doc.linked.length; ++i) {
              if (doc.linked[i].isParent) {
                return
              }
            }
            primary = lst(markers)
          })
          return new SharedTextMarker(markers, primary)
        }

        function findSharedMarkers(doc) {
          return doc.findMarks(
            Pos(doc.first, 0),
            doc.clipPos(Pos(doc.lastLine())),
            function (m) {
              return m.parent
            }
          )
        }

        function copySharedMarkers(doc, markers) {
          for (var i = 0; i < markers.length; i++) {
            var marker = markers[i],
              pos = marker.find()
            var mFrom = doc.clipPos(pos.from),
              mTo = doc.clipPos(pos.to)
            if (cmp(mFrom, mTo)) {
              var subMark = markText(
                doc,
                mFrom,
                mTo,
                marker.primary,
                marker.primary.type
              )
              marker.markers.push(subMark)
              subMark.parent = marker
            }
          }
        }

        function detachSharedMarkers(markers) {
          var loop = function (i) {
            var marker = markers[i],
              linked = [marker.primary.doc]
            linkedDocs(marker.primary.doc, function (d) {
              return linked.push(d)
            })
            for (var j = 0; j < marker.markers.length; j++) {
              var subMarker = marker.markers[j]
              if (indexOf(linked, subMarker.doc) == -1) {
                subMarker.parent = null
                marker.markers.splice(j--, 1)
              }
            }
          }

          for (var i = 0; i < markers.length; i++) loop(i)
        }

        var nextDocId = 0
        var Doc = function (text, mode, firstLine, lineSep, direction) {
          if (!(this instanceof Doc)) {
            return new Doc(text, mode, firstLine, lineSep, direction)
          }
          if (firstLine == null) {
            firstLine = 0
          }

          BranchChunk.call(this, [new LeafChunk([new Line('', null)])])
          this.first = firstLine
          this.scrollTop = this.scrollLeft = 0
          this.cantEdit = false
          this.cleanGeneration = 1
          this.modeFrontier = this.highlightFrontier = firstLine
          var start = Pos(firstLine, 0)
          this.sel = simpleSelection(start)
          this.history = new History(null)
          this.id = ++nextDocId
          this.modeOption = mode
          this.lineSep = lineSep
          this.direction = direction == 'rtl' ? 'rtl' : 'ltr'
          this.extend = false

          if (typeof text == 'string') {
            text = this.splitLines(text)
          }
          updateDoc(this, { from: start, to: start, text: text })
          setSelection(this, simpleSelection(start), sel_dontScroll)
        }

        Doc.prototype = createObj(BranchChunk.prototype, {
          constructor: Doc,
          // Iterate over the document. Supports two forms -- with only one
          // argument, it calls that for each line in the document. With
          // three, it iterates over the range given by the first two (with
          // the second being non-inclusive).
          iter: function (from, to, op) {
            if (op) {
              this.iterN(from - this.first, to - from, op)
            } else {
              this.iterN(this.first, this.first + this.size, from)
            }
          },

          // Non-public interface for adding and removing lines.
          insert: function (at, lines) {
            var height = 0
            for (var i = 0; i < lines.length; ++i) {
              height += lines[i].height
            }
            this.insertInner(at - this.first, lines, height)
          },
          remove: function (at, n) {
            this.removeInner(at - this.first, n)
          },

          // From here, the methods are part of the public interface. Most
          // are also available from CodeMirror (editor) instances.

          getValue: function (lineSep) {
            var lines = getLines(this, this.first, this.first + this.size)
            if (lineSep === false) {
              return lines
            }
            return lines.join(lineSep || this.lineSeparator())
          },
          setValue: docMethodOp(function (code) {
            var top = Pos(this.first, 0),
              last = this.first + this.size - 1
            makeChange(
              this,
              {
                from: top,
                to: Pos(last, getLine(this, last).text.length),
                text: this.splitLines(code),
                origin: 'setValue',
                full: true
              },
              true
            )
            if (this.cm) {
              scrollToCoords(this.cm, 0, 0)
            }
            setSelection(this, simpleSelection(top), sel_dontScroll)
          }),
          replaceRange: function (code, from, to, origin) {
            from = clipPos(this, from)
            to = to ? clipPos(this, to) : from
            replaceRange(this, code, from, to, origin)
          },
          getRange: function (from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to))
            if (lineSep === false) {
              return lines
            }
            if (lineSep === '') {
              return lines.join('')
            }
            return lines.join(lineSep || this.lineSeparator())
          },

          getLine: function (line) {
            var l = this.getLineHandle(line)
            return l && l.text
          },

          getLineHandle: function (line) {
            if (isLine(this, line)) {
              return getLine(this, line)
            }
          },
          getLineNumber: function (line) {
            return lineNo(line)
          },

          getLineHandleVisualStart: function (line) {
            if (typeof line == 'number') {
              line = getLine(this, line)
            }
            return visualLine(line)
          },

          lineCount: function () {
            return this.size
          },
          firstLine: function () {
            return this.first
          },
          lastLine: function () {
            return this.first + this.size - 1
          },

          clipPos: function (pos) {
            return clipPos(this, pos)
          },

          getCursor: function (start) {
            var range = this.sel.primary(),
              pos
            if (start == null || start == 'head') {
              pos = range.head
            } else if (start == 'anchor') {
              pos = range.anchor
            } else if (start == 'end' || start == 'to' || start === false) {
              pos = range.to()
            } else {
              pos = range.from()
            }
            return pos
          },
          listSelections: function () {
            return this.sel.ranges
          },
          somethingSelected: function () {
            return this.sel.somethingSelected()
          },

          setCursor: docMethodOp(function (line, ch, options) {
            setSimpleSelection(
              this,
              clipPos(
                this,
                typeof line == 'number' ? Pos(line, ch || 0) : line
              ),
              null,
              options
            )
          }),
          setSelection: docMethodOp(function (anchor, head, options) {
            setSimpleSelection(
              this,
              clipPos(this, anchor),
              clipPos(this, head || anchor),
              options
            )
          }),
          extendSelection: docMethodOp(function (head, other, options) {
            extendSelection(
              this,
              clipPos(this, head),
              other && clipPos(this, other),
              options
            )
          }),
          extendSelections: docMethodOp(function (heads, options) {
            extendSelections(this, clipPosArray(this, heads), options)
          }),
          extendSelectionsBy: docMethodOp(function (f, options) {
            var heads = map(this.sel.ranges, f)
            extendSelections(this, clipPosArray(this, heads), options)
          }),
          setSelections: docMethodOp(function (ranges, primary, options) {
            if (!ranges.length) {
              return
            }
            var out = []
            for (var i = 0; i < ranges.length; i++) {
              out[i] = new Range(
                clipPos(this, ranges[i].anchor),
                clipPos(this, ranges[i].head || ranges[i].anchor)
              )
            }
            if (primary == null) {
              primary = Math.min(ranges.length - 1, this.sel.primIndex)
            }
            setSelection(
              this,
              normalizeSelection(this.cm, out, primary),
              options
            )
          }),
          addSelection: docMethodOp(function (anchor, head, options) {
            var ranges = this.sel.ranges.slice(0)
            ranges.push(
              new Range(clipPos(this, anchor), clipPos(this, head || anchor))
            )
            setSelection(
              this,
              normalizeSelection(this.cm, ranges, ranges.length - 1),
              options
            )
          }),

          getSelection: function (lineSep) {
            var ranges = this.sel.ranges,
              lines
            for (var i = 0; i < ranges.length; i++) {
              var sel = getBetween(this, ranges[i].from(), ranges[i].to())
              lines = lines ? lines.concat(sel) : sel
            }
            if (lineSep === false) {
              return lines
            } else {
              return lines.join(lineSep || this.lineSeparator())
            }
          },
          getSelections: function (lineSep) {
            var parts = [],
              ranges = this.sel.ranges
            for (var i = 0; i < ranges.length; i++) {
              var sel = getBetween(this, ranges[i].from(), ranges[i].to())
              if (lineSep !== false) {
                sel = sel.join(lineSep || this.lineSeparator())
              }
              parts[i] = sel
            }
            return parts
          },
          replaceSelection: function (code, collapse, origin) {
            var dup = []
            for (var i = 0; i < this.sel.ranges.length; i++) {
              dup[i] = code
            }
            this.replaceSelections(dup, collapse, origin || '+input')
          },
          replaceSelections: docMethodOp(function (code, collapse, origin) {
            var changes = [],
              sel = this.sel
            for (var i = 0; i < sel.ranges.length; i++) {
              var range = sel.ranges[i]
              changes[i] = {
                from: range.from(),
                to: range.to(),
                text: this.splitLines(code[i]),
                origin: origin
              }
            }
            var newSel =
              collapse &&
              collapse != 'end' &&
              computeReplacedSel(this, changes, collapse)
            for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
              makeChange(this, changes[i$1])
            }
            if (newSel) {
              setSelectionReplaceHistory(this, newSel)
            } else if (this.cm) {
              ensureCursorVisible(this.cm)
            }
          }),
          undo: docMethodOp(function () {
            makeChangeFromHistory(this, 'undo')
          }),
          redo: docMethodOp(function () {
            makeChangeFromHistory(this, 'redo')
          }),
          undoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, 'undo', true)
          }),
          redoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, 'redo', true)
          }),

          setExtending: function (val) {
            this.extend = val
          },
          getExtending: function () {
            return this.extend
          },

          historySize: function () {
            var hist = this.history,
              done = 0,
              undone = 0
            for (var i = 0; i < hist.done.length; i++) {
              if (!hist.done[i].ranges) {
                ++done
              }
            }
            for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
              if (!hist.undone[i$1].ranges) {
                ++undone
              }
            }
            return { undo: done, redo: undone }
          },
          clearHistory: function () {
            var this$1 = this

            this.history = new History(this.history)
            linkedDocs(
              this,
              function (doc) {
                return (doc.history = this$1.history)
              },
              true
            )
          },

          markClean: function () {
            this.cleanGeneration = this.changeGeneration(true)
          },
          changeGeneration: function (forceSplit) {
            if (forceSplit) {
              this.history.lastOp =
                this.history.lastSelOp =
                this.history.lastOrigin =
                  null
            }
            return this.history.generation
          },
          isClean: function (gen) {
            return this.history.generation == (gen || this.cleanGeneration)
          },

          getHistory: function () {
            return {
              done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)
            }
          },
          setHistory: function (histData) {
            var hist = (this.history = new History(this.history))
            hist.done = copyHistoryArray(histData.done.slice(0), null, true)
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)
          },

          setGutterMarker: docMethodOp(function (line, gutterID, value) {
            return changeLine(this, line, 'gutter', function (line) {
              var markers = line.gutterMarkers || (line.gutterMarkers = {})
              markers[gutterID] = value
              if (!value && isEmpty(markers)) {
                line.gutterMarkers = null
              }
              return true
            })
          }),

          clearGutter: docMethodOp(function (gutterID) {
            var this$1 = this

            this.iter(function (line) {
              if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                changeLine(this$1, line, 'gutter', function () {
                  line.gutterMarkers[gutterID] = null
                  if (isEmpty(line.gutterMarkers)) {
                    line.gutterMarkers = null
                  }
                  return true
                })
              }
            })
          }),

          lineInfo: function (line) {
            var n
            if (typeof line == 'number') {
              if (!isLine(this, line)) {
                return null
              }
              n = line
              line = getLine(this, line)
              if (!line) {
                return null
              }
            } else {
              n = lineNo(line)
              if (n == null) {
                return null
              }
            }
            return {
              line: n,
              handle: line,
              text: line.text,
              gutterMarkers: line.gutterMarkers,
              textClass: line.textClass,
              bgClass: line.bgClass,
              wrapClass: line.wrapClass,
              widgets: line.widgets
            }
          },

          addLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(
              this,
              handle,
              where == 'gutter' ? 'gutter' : 'class',
              function (line) {
                var prop =
                  where == 'text'
                    ? 'textClass'
                    : where == 'background'
                    ? 'bgClass'
                    : where == 'gutter'
                    ? 'gutterClass'
                    : 'wrapClass'
                if (!line[prop]) {
                  line[prop] = cls
                } else if (classTest(cls).test(line[prop])) {
                  return false
                } else {
                  line[prop] += ' ' + cls
                }
                return true
              }
            )
          }),
          removeLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(
              this,
              handle,
              where == 'gutter' ? 'gutter' : 'class',
              function (line) {
                var prop =
                  where == 'text'
                    ? 'textClass'
                    : where == 'background'
                    ? 'bgClass'
                    : where == 'gutter'
                    ? 'gutterClass'
                    : 'wrapClass'
                var cur = line[prop]
                if (!cur) {
                  return false
                } else if (cls == null) {
                  line[prop] = null
                } else {
                  var found = cur.match(classTest(cls))
                  if (!found) {
                    return false
                  }
                  var end = found.index + found[0].length
                  line[prop] =
                    cur.slice(0, found.index) +
                      (!found.index || end == cur.length ? '' : ' ') +
                      cur.slice(end) || null
                }
                return true
              }
            )
          }),

          addLineWidget: docMethodOp(function (handle, node, options) {
            return addLineWidget(this, handle, node, options)
          }),
          removeLineWidget: function (widget) {
            widget.clear()
          },

          markText: function (from, to, options) {
            return markText(
              this,
              clipPos(this, from),
              clipPos(this, to),
              options,
              (options && options.type) || 'range'
            )
          },
          setBookmark: function (pos, options) {
            var realOpts = {
              replacedWith:
                options &&
                (options.nodeType == null ? options.widget : options),
              insertLeft: options && options.insertLeft,
              clearWhenEmpty: false,
              shared: options && options.shared,
              handleMouseEvents: options && options.handleMouseEvents
            }
            pos = clipPos(this, pos)
            return markText(this, pos, pos, realOpts, 'bookmark')
          },
          findMarksAt: function (pos) {
            pos = clipPos(this, pos)
            var markers = [],
              spans = getLine(this, pos.line).markedSpans
            if (spans) {
              for (var i = 0; i < spans.length; ++i) {
                var span = spans[i]
                if (
                  (span.from == null || span.from <= pos.ch) &&
                  (span.to == null || span.to >= pos.ch)
                ) {
                  markers.push(span.marker.parent || span.marker)
                }
              }
            }
            return markers
          },
          findMarks: function (from, to, filter) {
            from = clipPos(this, from)
            to = clipPos(this, to)
            var found = [],
              lineNo = from.line
            this.iter(from.line, to.line + 1, function (line) {
              var spans = line.markedSpans
              if (spans) {
                for (var i = 0; i < spans.length; i++) {
                  var span = spans[i]
                  if (
                    !(
                      (span.to != null &&
                        lineNo == from.line &&
                        from.ch >= span.to) ||
                      (span.from == null && lineNo != from.line) ||
                      (span.from != null &&
                        lineNo == to.line &&
                        span.from >= to.ch)
                    ) &&
                    (!filter || filter(span.marker))
                  ) {
                    found.push(span.marker.parent || span.marker)
                  }
                }
              }
              ++lineNo
            })
            return found
          },
          getAllMarks: function () {
            var markers = []
            this.iter(function (line) {
              var sps = line.markedSpans
              if (sps) {
                for (var i = 0; i < sps.length; ++i) {
                  if (sps[i].from != null) {
                    markers.push(sps[i].marker)
                  }
                }
              }
            })
            return markers
          },

          posFromIndex: function (off) {
            var ch,
              lineNo = this.first,
              sepSize = this.lineSeparator().length
            this.iter(function (line) {
              var sz = line.text.length + sepSize
              if (sz > off) {
                ch = off
                return true
              }
              off -= sz
              ++lineNo
            })
            return clipPos(this, Pos(lineNo, ch))
          },
          indexFromPos: function (coords) {
            coords = clipPos(this, coords)
            var index = coords.ch
            if (coords.line < this.first || coords.ch < 0) {
              return 0
            }
            var sepSize = this.lineSeparator().length
            this.iter(this.first, coords.line, function (line) {
              // iter aborts when callback returns a truthy value
              index += line.text.length + sepSize
            })
            return index
          },

          copy: function (copyHistory) {
            var doc = new Doc(
              getLines(this, this.first, this.first + this.size),
              this.modeOption,
              this.first,
              this.lineSep,
              this.direction
            )
            doc.scrollTop = this.scrollTop
            doc.scrollLeft = this.scrollLeft
            doc.sel = this.sel
            doc.extend = false
            if (copyHistory) {
              doc.history.undoDepth = this.history.undoDepth
              doc.setHistory(this.getHistory())
            }
            return doc
          },

          linkedDoc: function (options) {
            if (!options) {
              options = {}
            }
            var from = this.first,
              to = this.first + this.size
            if (options.from != null && options.from > from) {
              from = options.from
            }
            if (options.to != null && options.to < to) {
              to = options.to
            }
            var copy = new Doc(
              getLines(this, from, to),
              options.mode || this.modeOption,
              from,
              this.lineSep,
              this.direction
            )
            if (options.sharedHist) {
              copy.history = this.history
            }
            ;(this.linked || (this.linked = [])).push({
              doc: copy,
              sharedHist: options.sharedHist
            })
            copy.linked = [
              { doc: this, isParent: true, sharedHist: options.sharedHist }
            ]
            copySharedMarkers(copy, findSharedMarkers(this))
            return copy
          },
          unlinkDoc: function (other) {
            if (other instanceof CodeMirror) {
              other = other.doc
            }
            if (this.linked) {
              for (var i = 0; i < this.linked.length; ++i) {
                var link = this.linked[i]
                if (link.doc != other) {
                  continue
                }
                this.linked.splice(i, 1)
                other.unlinkDoc(this)
                detachSharedMarkers(findSharedMarkers(this))
                break
              }
            }
            // If the histories were shared, split them again
            if (other.history == this.history) {
              var splitIds = [other.id]
              linkedDocs(
                other,
                function (doc) {
                  return splitIds.push(doc.id)
                },
                true
              )
              other.history = new History(null)
              other.history.done = copyHistoryArray(this.history.done, splitIds)
              other.history.undone = copyHistoryArray(
                this.history.undone,
                splitIds
              )
            }
          },
          iterLinkedDocs: function (f) {
            linkedDocs(this, f)
          },

          getMode: function () {
            return this.mode
          },
          getEditor: function () {
            return this.cm
          },

          splitLines: function (str) {
            if (this.lineSep) {
              return str.split(this.lineSep)
            }
            return splitLinesAuto(str)
          },
          lineSeparator: function () {
            return this.lineSep || '\n'
          },

          setDirection: docMethodOp(function (dir) {
            if (dir != 'rtl') {
              dir = 'ltr'
            }
            if (dir == this.direction) {
              return
            }
            this.direction = dir
            this.iter(function (line) {
              return (line.order = null)
            })
            if (this.cm) {
              directionChanged(this.cm)
            }
          })
        })

        // Public alias.
        Doc.prototype.eachLine = Doc.prototype.iter

        // Kludge to work around strange IE behavior where it'll sometimes
        // re-fire a series of drag-related events right after the drop (#1551)
        var lastDrop = 0

        function onDrop(e) {
          var cm = this
          clearDragCursor(cm)
          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return
          }
          e_preventDefault(e)
          if (ie) {
            lastDrop = +new Date()
          }
          var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files
          if (!pos || cm.isReadOnly()) {
            return
          }
          // Might be a file drop, in which case we simply extract the text
          // and insert it.
          if (files && files.length && window.FileReader && window.File) {
            var n = files.length,
              text = Array(n),
              read = 0
            var markAsReadAndPasteIfAllFilesAreRead = function () {
              if (++read == n) {
                operation(cm, function () {
                  pos = clipPos(cm.doc, pos)
                  var change = {
                    from: pos,
                    to: pos,
                    text: cm.doc.splitLines(
                      text
                        .filter(function (t) {
                          return t != null
                        })
                        .join(cm.doc.lineSeparator())
                    ),
                    origin: 'paste'
                  }
                  makeChange(cm.doc, change)
                  setSelectionReplaceHistory(
                    cm.doc,
                    simpleSelection(
                      clipPos(cm.doc, pos),
                      clipPos(cm.doc, changeEnd(change))
                    )
                  )
                })()
              }
            }
            var readTextFromFile = function (file, i) {
              if (
                cm.options.allowDropFileTypes &&
                indexOf(cm.options.allowDropFileTypes, file.type) == -1
              ) {
                markAsReadAndPasteIfAllFilesAreRead()
                return
              }
              var reader = new FileReader()
              reader.onerror = function () {
                return markAsReadAndPasteIfAllFilesAreRead()
              }
              reader.onload = function () {
                var content = reader.result
                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                  markAsReadAndPasteIfAllFilesAreRead()
                  return
                }
                text[i] = content
                markAsReadAndPasteIfAllFilesAreRead()
              }
              reader.readAsText(file)
            }
            for (var i = 0; i < files.length; i++) {
              readTextFromFile(files[i], i)
            }
          } else {
            // Normal drop
            // Don't do a replace if the drop happened inside of the selected text.
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
              cm.state.draggingText(e)
              // Ensure the editor is re-focused
              setTimeout(function () {
                return cm.display.input.focus()
              }, 20)
              return
            }
            try {
              var text$1 = e.dataTransfer.getData('Text')
              if (text$1) {
                var selected
                if (cm.state.draggingText && !cm.state.draggingText.copy) {
                  selected = cm.listSelections()
                }
                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))
                if (selected) {
                  for (var i$1 = 0; i$1 < selected.length; ++i$1) {
                    replaceRange(
                      cm.doc,
                      '',
                      selected[i$1].anchor,
                      selected[i$1].head,
                      'drag'
                    )
                  }
                }
                cm.replaceSelection(text$1, 'around', 'paste')
                cm.display.input.focus()
              }
            } catch (e$1) {}
          }
        }

        function onDragStart(cm, e) {
          if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            e_stop(e)
            return
          }
          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return
          }

          e.dataTransfer.setData('Text', cm.getSelection())
          e.dataTransfer.effectAllowed = 'copyMove'

          // Use dummy image instead of default browsers image.
          // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
          if (e.dataTransfer.setDragImage && !safari) {
            var img = elt(
              'img',
              null,
              null,
              'position: fixed; left: 0; top: 0;'
            )
            img.src =
              'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
            if (presto) {
              img.width = img.height = 1
              cm.display.wrapper.appendChild(img)
              // Force a relayout, or Opera won't use our image for some obscure reason
              img._top = img.offsetTop
            }
            e.dataTransfer.setDragImage(img, 0, 0)
            if (presto) {
              img.parentNode.removeChild(img)
            }
          }
        }

        function onDragOver(cm, e) {
          var pos = posFromMouse(cm, e)
          if (!pos) {
            return
          }
          var frag = document.createDocumentFragment()
          drawSelectionCursor(cm, pos, frag)
          if (!cm.display.dragCursor) {
            cm.display.dragCursor = elt(
              'div',
              null,
              'CodeMirror-cursors CodeMirror-dragcursors'
            )
            cm.display.lineSpace.insertBefore(
              cm.display.dragCursor,
              cm.display.cursorDiv
            )
          }
          removeChildrenAndAdd(cm.display.dragCursor, frag)
        }

        function clearDragCursor(cm) {
          if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor)
            cm.display.dragCursor = null
          }
        }

        // These must be handled carefully, because naively registering a
        // handler for each editor will cause the editors to never be
        // garbage collected.

        function forEachCodeMirror(f) {
          if (!document.getElementsByClassName) {
            return
          }
          var byClass = document.getElementsByClassName('CodeMirror'),
            editors = []
          for (var i = 0; i < byClass.length; i++) {
            var cm = byClass[i].CodeMirror
            if (cm) {
              editors.push(cm)
            }
          }
          if (editors.length) {
            editors[0].operation(function () {
              for (var i = 0; i < editors.length; i++) {
                f(editors[i])
              }
            })
          }
        }

        var globalsRegistered = false
        function ensureGlobalHandlers() {
          if (globalsRegistered) {
            return
          }
          registerGlobalHandlers()
          globalsRegistered = true
        }
        function registerGlobalHandlers() {
          // When the window resizes, we need to refresh active editors.
          var resizeTimer
          on(window, 'resize', function () {
            if (resizeTimer == null) {
              resizeTimer = setTimeout(function () {
                resizeTimer = null
                forEachCodeMirror(onResize)
              }, 100)
            }
          })
          // When the window loses focus, we want to show the editor as blurred
          on(window, 'blur', function () {
            return forEachCodeMirror(onBlur)
          })
        }
        // Called when the window resizes
        function onResize(cm) {
          var d = cm.display
          // Might be a text scaling operation, clear size caches.
          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
          d.scrollbarsClipped = false
          cm.setSize()
        }

        var keyNames = {
          3: 'Pause',
          8: 'Backspace',
          9: 'Tab',
          13: 'Enter',
          16: 'Shift',
          17: 'Ctrl',
          18: 'Alt',
          19: 'Pause',
          20: 'CapsLock',
          27: 'Esc',
          32: 'Space',
          33: 'PageUp',
          34: 'PageDown',
          35: 'End',
          36: 'Home',
          37: 'Left',
          38: 'Up',
          39: 'Right',
          40: 'Down',
          44: 'PrintScrn',
          45: 'Insert',
          46: 'Delete',
          59: ';',
          61: '=',
          91: 'Mod',
          92: 'Mod',
          93: 'Mod',
          106: '*',
          107: '=',
          109: '-',
          110: '.',
          111: '/',
          145: 'ScrollLock',
          173: '-',
          186: ';',
          187: '=',
          188: ',',
          189: '-',
          190: '.',
          191: '/',
          192: '`',
          219: '[',
          220: '\\',
          221: ']',
          222: "'",
          224: 'Mod',
          63232: 'Up',
          63233: 'Down',
          63234: 'Left',
          63235: 'Right',
          63272: 'Delete',
          63273: 'Home',
          63275: 'End',
          63276: 'PageUp',
          63277: 'PageDown',
          63302: 'Insert'
        }

        // Number keys
        for (var i = 0; i < 10; i++) {
          keyNames[i + 48] = keyNames[i + 96] = String(i)
        }
        // Alphabetic keys
        for (var i$1 = 65; i$1 <= 90; i$1++) {
          keyNames[i$1] = String.fromCharCode(i$1)
        }
        // Function keys
        for (var i$2 = 1; i$2 <= 12; i$2++) {
          keyNames[i$2 + 111] = keyNames[i$2 + 63235] = 'F' + i$2
        }

        var keyMap = {}

        keyMap.basic = {
          Left: 'goCharLeft',
          Right: 'goCharRight',
          Up: 'goLineUp',
          Down: 'goLineDown',
          End: 'goLineEnd',
          Home: 'goLineStartSmart',
          PageUp: 'goPageUp',
          PageDown: 'goPageDown',
          Delete: 'delCharAfter',
          Backspace: 'delCharBefore',
          'Shift-Backspace': 'delCharBefore',
          Tab: 'defaultTab',
          'Shift-Tab': 'indentAuto',
          Enter: 'newlineAndIndent',
          Insert: 'toggleOverwrite',
          Esc: 'singleSelection'
        }
        // Note that the save and find-related commands aren't defined by
        // default. User code or addons can define them. Unknown commands
        // are simply ignored.
        keyMap.pcDefault = {
          'Ctrl-A': 'selectAll',
          'Ctrl-D': 'deleteLine',
          'Ctrl-Z': 'undo',
          'Shift-Ctrl-Z': 'redo',
          'Ctrl-Y': 'redo',
          'Ctrl-Home': 'goDocStart',
          'Ctrl-End': 'goDocEnd',
          'Ctrl-Up': 'goLineUp',
          'Ctrl-Down': 'goLineDown',
          'Ctrl-Left': 'goGroupLeft',
          'Ctrl-Right': 'goGroupRight',
          'Alt-Left': 'goLineStart',
          'Alt-Right': 'goLineEnd',
          'Ctrl-Backspace': 'delGroupBefore',
          'Ctrl-Delete': 'delGroupAfter',
          'Ctrl-S': 'save',
          'Ctrl-F': 'find',
          'Ctrl-G': 'findNext',
          'Shift-Ctrl-G': 'findPrev',
          'Shift-Ctrl-F': 'replace',
          'Shift-Ctrl-R': 'replaceAll',
          'Ctrl-[': 'indentLess',
          'Ctrl-]': 'indentMore',
          'Ctrl-U': 'undoSelection',
          'Shift-Ctrl-U': 'redoSelection',
          'Alt-U': 'redoSelection',
          fallthrough: 'basic'
        }
        // Very basic readline/emacs-style bindings, which are standard on Mac.
        keyMap.emacsy = {
          'Ctrl-F': 'goCharRight',
          'Ctrl-B': 'goCharLeft',
          'Ctrl-P': 'goLineUp',
          'Ctrl-N': 'goLineDown',
          'Ctrl-A': 'goLineStart',
          'Ctrl-E': 'goLineEnd',
          'Ctrl-V': 'goPageDown',
          'Shift-Ctrl-V': 'goPageUp',
          'Ctrl-D': 'delCharAfter',
          'Ctrl-H': 'delCharBefore',
          'Alt-Backspace': 'delWordBefore',
          'Ctrl-K': 'killLine',
          'Ctrl-T': 'transposeChars',
          'Ctrl-O': 'openLine'
        }
        keyMap.macDefault = {
          'Cmd-A': 'selectAll',
          'Cmd-D': 'deleteLine',
          'Cmd-Z': 'undo',
          'Shift-Cmd-Z': 'redo',
          'Cmd-Y': 'redo',
          'Cmd-Home': 'goDocStart',
          'Cmd-Up': 'goDocStart',
          'Cmd-End': 'goDocEnd',
          'Cmd-Down': 'goDocEnd',
          'Alt-Left': 'goGroupLeft',
          'Alt-Right': 'goGroupRight',
          'Cmd-Left': 'goLineLeft',
          'Cmd-Right': 'goLineRight',
          'Alt-Backspace': 'delGroupBefore',
          'Ctrl-Alt-Backspace': 'delGroupAfter',
          'Alt-Delete': 'delGroupAfter',
          'Cmd-S': 'save',
          'Cmd-F': 'find',
          'Cmd-G': 'findNext',
          'Shift-Cmd-G': 'findPrev',
          'Cmd-Alt-F': 'replace',
          'Shift-Cmd-Alt-F': 'replaceAll',
          'Cmd-[': 'indentLess',
          'Cmd-]': 'indentMore',
          'Cmd-Backspace': 'delWrappedLineLeft',
          'Cmd-Delete': 'delWrappedLineRight',
          'Cmd-U': 'undoSelection',
          'Shift-Cmd-U': 'redoSelection',
          'Ctrl-Up': 'goDocStart',
          'Ctrl-Down': 'goDocEnd',
          fallthrough: ['basic', 'emacsy']
        }
        keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault

        // KEYMAP DISPATCH

        function normalizeKeyName(name) {
          var parts = name.split(/-(?!$)/)
          name = parts[parts.length - 1]
          var alt, ctrl, shift, cmd
          for (var i = 0; i < parts.length - 1; i++) {
            var mod = parts[i]
            if (/^(cmd|meta|m)$/i.test(mod)) {
              cmd = true
            } else if (/^a(lt)?$/i.test(mod)) {
              alt = true
            } else if (/^(c|ctrl|control)$/i.test(mod)) {
              ctrl = true
            } else if (/^s(hift)?$/i.test(mod)) {
              shift = true
            } else {
              throw new Error('Unrecognized modifier name: ' + mod)
            }
          }
          if (alt) {
            name = 'Alt-' + name
          }
          if (ctrl) {
            name = 'Ctrl-' + name
          }
          if (cmd) {
            name = 'Cmd-' + name
          }
          if (shift) {
            name = 'Shift-' + name
          }
          return name
        }

        // This is a kludge to keep keymaps mostly working as raw objects
        // (backwards compatibility) while at the same time support features
        // like normalization and multi-stroke key bindings. It compiles a
        // new normalized keymap, and then updates the old object to reflect
        // this.
        function normalizeKeyMap(keymap) {
          var copy = {}
          for (var keyname in keymap) {
            if (keymap.hasOwnProperty(keyname)) {
              var value = keymap[keyname]
              if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                continue
              }
              if (value == '...') {
                delete keymap[keyname]
                continue
              }

              var keys = map(keyname.split(' '), normalizeKeyName)
              for (var i = 0; i < keys.length; i++) {
                var val = void 0,
                  name = void 0
                if (i == keys.length - 1) {
                  name = keys.join(' ')
                  val = value
                } else {
                  name = keys.slice(0, i + 1).join(' ')
                  val = '...'
                }
                var prev = copy[name]
                if (!prev) {
                  copy[name] = val
                } else if (prev != val) {
                  throw new Error('Inconsistent bindings for ' + name)
                }
              }
              delete keymap[keyname]
            }
          }
          for (var prop in copy) {
            keymap[prop] = copy[prop]
          }
          return keymap
        }

        function lookupKey(key, map, handle, context) {
          map = getKeyMap(map)
          var found = map.call ? map.call(key, context) : map[key]
          if (found === false) {
            return 'nothing'
          }
          if (found === '...') {
            return 'multi'
          }
          if (found != null && handle(found)) {
            return 'handled'
          }

          if (map.fallthrough) {
            if (
              Object.prototype.toString.call(map.fallthrough) !=
              '[object Array]'
            ) {
              return lookupKey(key, map.fallthrough, handle, context)
            }
            for (var i = 0; i < map.fallthrough.length; i++) {
              var result = lookupKey(key, map.fallthrough[i], handle, context)
              if (result) {
                return result
              }
            }
          }
        }

        // Modifier key presses don't count as 'real' key presses for the
        // purpose of keymap fallthrough.
        function isModifierKey(value) {
          var name = typeof value == 'string' ? value : keyNames[value.keyCode]
          return (
            name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod'
          )
        }

        function addModifierNames(name, event, noShift) {
          var base = name
          if (event.altKey && base != 'Alt') {
            name = 'Alt-' + name
          }
          if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != 'Ctrl') {
            name = 'Ctrl-' + name
          }
          if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != 'Mod') {
            name = 'Cmd-' + name
          }
          if (!noShift && event.shiftKey && base != 'Shift') {
            name = 'Shift-' + name
          }
          return name
        }

        // Look up the name of a key as indicated by an event object.
        function keyName(event, noShift) {
          if (presto && event.keyCode == 34 && event['char']) {
            return false
          }
          var name = keyNames[event.keyCode]
          if (name == null || event.altGraphKey) {
            return false
          }
          // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
          // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
          if (event.keyCode == 3 && event.code) {
            name = event.code
          }
          return addModifierNames(name, event, noShift)
        }

        function getKeyMap(val) {
          return typeof val == 'string' ? keyMap[val] : val
        }

        // Helper for deleting text near the selection(s), used to implement
        // backspace, delete, and similar functionality.
        function deleteNearSelection(cm, compute) {
          var ranges = cm.doc.sel.ranges,
            kill = []
          // Build up a set of ranges to kill first, merging overlapping
          // ranges.
          for (var i = 0; i < ranges.length; i++) {
            var toKill = compute(ranges[i])
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
              var replaced = kill.pop()
              if (cmp(replaced.from, toKill.from) < 0) {
                toKill.from = replaced.from
                break
              }
            }
            kill.push(toKill)
          }
          // Next, remove those actual ranges.
          runInOp(cm, function () {
            for (var i = kill.length - 1; i >= 0; i--) {
              replaceRange(cm.doc, '', kill[i].from, kill[i].to, '+delete')
            }
            ensureCursorVisible(cm)
          })
        }

        function moveCharLogically(line, ch, dir) {
          var target = skipExtendingChars(line.text, ch + dir, dir)
          return target < 0 || target > line.text.length ? null : target
        }

        function moveLogically(line, start, dir) {
          var ch = moveCharLogically(line, start.ch, dir)
          return ch == null
            ? null
            : new Pos(start.line, ch, dir < 0 ? 'after' : 'before')
        }

        function endOfLine(visually, cm, lineObj, lineNo, dir) {
          if (visually) {
            if (cm.doc.direction == 'rtl') {
              dir = -dir
            }
            var order = getOrder(lineObj, cm.doc.direction)
            if (order) {
              var part = dir < 0 ? lst(order) : order[0]
              var moveInStorageOrder = dir < 0 == (part.level == 1)
              var sticky = moveInStorageOrder ? 'after' : 'before'
              var ch
              // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
              // it could be that the last bidi part is not on the last visual line,
              // since visual lines contain content order-consecutive chunks.
              // Thus, in rtl, we are looking for the first (content-order) character
              // in the rtl chunk that is on the last line (that is, the same line
              // as the last (content-order) character).
              if (part.level > 0 || cm.doc.direction == 'rtl') {
                var prep = prepareMeasureForLine(cm, lineObj)
                ch = dir < 0 ? lineObj.text.length - 1 : 0
                var targetTop = measureCharPrepared(cm, prep, ch).top
                ch = findFirst(
                  function (ch) {
                    return measureCharPrepared(cm, prep, ch).top == targetTop
                  },
                  dir < 0 == (part.level == 1) ? part.from : part.to - 1,
                  ch
                )
                if (sticky == 'before') {
                  ch = moveCharLogically(lineObj, ch, 1)
                }
              } else {
                ch = dir < 0 ? part.to : part.from
              }
              return new Pos(lineNo, ch, sticky)
            }
          }
          return new Pos(
            lineNo,
            dir < 0 ? lineObj.text.length : 0,
            dir < 0 ? 'before' : 'after'
          )
        }

        function moveVisually(cm, line, start, dir) {
          var bidi = getOrder(line, cm.doc.direction)
          if (!bidi) {
            return moveLogically(line, start, dir)
          }
          if (start.ch >= line.text.length) {
            start.ch = line.text.length
            start.sticky = 'before'
          } else if (start.ch <= 0) {
            start.ch = 0
            start.sticky = 'after'
          }
          var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
            part = bidi[partPos]
          if (
            cm.doc.direction == 'ltr' &&
            part.level % 2 == 0 &&
            (dir > 0 ? part.to > start.ch : part.from < start.ch)
          ) {
            // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
            // nothing interesting happens.
            return moveLogically(line, start, dir)
          }

          var mv = function (pos, dir) {
            return moveCharLogically(
              line,
              pos instanceof Pos ? pos.ch : pos,
              dir
            )
          }
          var prep
          var getWrappedLineExtent = function (ch) {
            if (!cm.options.lineWrapping) {
              return { begin: 0, end: line.text.length }
            }
            prep = prep || prepareMeasureForLine(cm, line)
            return wrappedLineExtentChar(cm, line, prep, ch)
          }
          var wrappedLineExtent = getWrappedLineExtent(
            start.sticky == 'before' ? mv(start, -1) : start.ch
          )

          if (cm.doc.direction == 'rtl' || part.level == 1) {
            var moveInStorageOrder = (part.level == 1) == dir < 0
            var ch = mv(start, moveInStorageOrder ? 1 : -1)
            if (
              ch != null &&
              (!moveInStorageOrder
                ? ch >= part.from && ch >= wrappedLineExtent.begin
                : ch <= part.to && ch <= wrappedLineExtent.end)
            ) {
              // Case 2: We move within an rtl part or in an rtl editor on the same visual line
              var sticky = moveInStorageOrder ? 'before' : 'after'
              return new Pos(start.line, ch, sticky)
            }
          }

          // Case 3: Could not move within this bidi part in this visual line, so leave
          // the current bidi part

          var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
            var getRes = function (ch, moveInStorageOrder) {
              return moveInStorageOrder
                ? new Pos(start.line, mv(ch, 1), 'before')
                : new Pos(start.line, ch, 'after')
            }

            for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
              var part = bidi[partPos]
              var moveInStorageOrder = dir > 0 == (part.level != 1)
              var ch = moveInStorageOrder
                ? wrappedLineExtent.begin
                : mv(wrappedLineExtent.end, -1)
              if (part.from <= ch && ch < part.to) {
                return getRes(ch, moveInStorageOrder)
              }
              ch = moveInStorageOrder ? part.from : mv(part.to, -1)
              if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
                return getRes(ch, moveInStorageOrder)
              }
            }
          }

          // Case 3a: Look for other bidi parts on the same visual line
          var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent)
          if (res) {
            return res
          }

          // Case 3b: Look for other bidi parts on the next visual line
          var nextCh =
            dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1)
          if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(
              dir > 0 ? 0 : bidi.length - 1,
              dir,
              getWrappedLineExtent(nextCh)
            )
            if (res) {
              return res
            }
          }

          // Case 4: Nowhere to move
          return null
        }

        // Commands are parameter-less actions that can be performed on an
        // editor, mostly used for keybindings.
        var commands = {
          selectAll: selectAll,
          singleSelection: function (cm) {
            return cm.setSelection(
              cm.getCursor('anchor'),
              cm.getCursor('head'),
              sel_dontScroll
            )
          },
          killLine: function (cm) {
            return deleteNearSelection(cm, function (range) {
              if (range.empty()) {
                var len = getLine(cm.doc, range.head.line).text.length
                if (range.head.ch == len && range.head.line < cm.lastLine()) {
                  return { from: range.head, to: Pos(range.head.line + 1, 0) }
                } else {
                  return { from: range.head, to: Pos(range.head.line, len) }
                }
              } else {
                return { from: range.from(), to: range.to() }
              }
            })
          },
          deleteLine: function (cm) {
            return deleteNearSelection(cm, function (range) {
              return {
                from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
              }
            })
          },
          delLineLeft: function (cm) {
            return deleteNearSelection(cm, function (range) {
              return {
                from: Pos(range.from().line, 0),
                to: range.from()
              }
            })
          },
          delWrappedLineLeft: function (cm) {
            return deleteNearSelection(cm, function (range) {
              var top = cm.charCoords(range.head, 'div').top + 5
              var leftPos = cm.coordsChar({ left: 0, top: top }, 'div')
              return { from: leftPos, to: range.from() }
            })
          },
          delWrappedLineRight: function (cm) {
            return deleteNearSelection(cm, function (range) {
              var top = cm.charCoords(range.head, 'div').top + 5
              var rightPos = cm.coordsChar(
                { left: cm.display.lineDiv.offsetWidth + 100, top: top },
                'div'
              )
              return { from: range.from(), to: rightPos }
            })
          },
          undo: function (cm) {
            return cm.undo()
          },
          redo: function (cm) {
            return cm.redo()
          },
          undoSelection: function (cm) {
            return cm.undoSelection()
          },
          redoSelection: function (cm) {
            return cm.redoSelection()
          },
          goDocStart: function (cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0))
          },
          goDocEnd: function (cm) {
            return cm.extendSelection(Pos(cm.lastLine()))
          },
          goLineStart: function (cm) {
            return cm.extendSelectionsBy(
              function (range) {
                return lineStart(cm, range.head.line)
              },
              { origin: '+move', bias: 1 }
            )
          },
          goLineStartSmart: function (cm) {
            return cm.extendSelectionsBy(
              function (range) {
                return lineStartSmart(cm, range.head)
              },
              { origin: '+move', bias: 1 }
            )
          },
          goLineEnd: function (cm) {
            return cm.extendSelectionsBy(
              function (range) {
                return lineEnd(cm, range.head.line)
              },
              { origin: '+move', bias: -1 }
            )
          },
          goLineRight: function (cm) {
            return cm.extendSelectionsBy(function (range) {
              var top = cm.cursorCoords(range.head, 'div').top + 5
              return cm.coordsChar(
                { left: cm.display.lineDiv.offsetWidth + 100, top: top },
                'div'
              )
            }, sel_move)
          },
          goLineLeft: function (cm) {
            return cm.extendSelectionsBy(function (range) {
              var top = cm.cursorCoords(range.head, 'div').top + 5
              return cm.coordsChar({ left: 0, top: top }, 'div')
            }, sel_move)
          },
          goLineLeftSmart: function (cm) {
            return cm.extendSelectionsBy(function (range) {
              var top = cm.cursorCoords(range.head, 'div').top + 5
              var pos = cm.coordsChar({ left: 0, top: top }, 'div')
              if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
                return lineStartSmart(cm, range.head)
              }
              return pos
            }, sel_move)
          },
          goLineUp: function (cm) {
            return cm.moveV(-1, 'line')
          },
          goLineDown: function (cm) {
            return cm.moveV(1, 'line')
          },
          goPageUp: function (cm) {
            return cm.moveV(-1, 'page')
          },
          goPageDown: function (cm) {
            return cm.moveV(1, 'page')
          },
          goCharLeft: function (cm) {
            return cm.moveH(-1, 'char')
          },
          goCharRight: function (cm) {
            return cm.moveH(1, 'char')
          },
          goColumnLeft: function (cm) {
            return cm.moveH(-1, 'column')
          },
          goColumnRight: function (cm) {
            return cm.moveH(1, 'column')
          },
          goWordLeft: function (cm) {
            return cm.moveH(-1, 'word')
          },
          goGroupRight: function (cm) {
            return cm.moveH(1, 'group')
          },
          goGroupLeft: function (cm) {
            return cm.moveH(-1, 'group')
          },
          goWordRight: function (cm) {
            return cm.moveH(1, 'word')
          },
          delCharBefore: function (cm) {
            return cm.deleteH(-1, 'codepoint')
          },
          delCharAfter: function (cm) {
            return cm.deleteH(1, 'char')
          },
          delWordBefore: function (cm) {
            return cm.deleteH(-1, 'word')
          },
          delWordAfter: function (cm) {
            return cm.deleteH(1, 'word')
          },
          delGroupBefore: function (cm) {
            return cm.deleteH(-1, 'group')
          },
          delGroupAfter: function (cm) {
            return cm.deleteH(1, 'group')
          },
          indentAuto: function (cm) {
            return cm.indentSelection('smart')
          },
          indentMore: function (cm) {
            return cm.indentSelection('add')
          },
          indentLess: function (cm) {
            return cm.indentSelection('subtract')
          },
          insertTab: function (cm) {
            return cm.replaceSelection('\t')
          },
          insertSoftTab: function (cm) {
            var spaces = [],
              ranges = cm.listSelections(),
              tabSize = cm.options.tabSize
            for (var i = 0; i < ranges.length; i++) {
              var pos = ranges[i].from()
              var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)
              spaces.push(spaceStr(tabSize - (col % tabSize)))
            }
            cm.replaceSelections(spaces)
          },
          defaultTab: function (cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection('add')
            } else {
              cm.execCommand('insertTab')
            }
          },
          // Swap the two chars left and right of each selection's head.
          // Move cursor behind the two swapped characters afterwards.
          //
          // Doesn't consider line feeds a character.
          // Doesn't scan more than one line above to find a character.
          // Doesn't do anything on an empty line.
          // Doesn't do anything with non-empty selections.
          transposeChars: function (cm) {
            return runInOp(cm, function () {
              var ranges = cm.listSelections(),
                newSel = []
              for (var i = 0; i < ranges.length; i++) {
                if (!ranges[i].empty()) {
                  continue
                }
                var cur = ranges[i].head,
                  line = getLine(cm.doc, cur.line).text
                if (line) {
                  if (cur.ch == line.length) {
                    cur = new Pos(cur.line, cur.ch - 1)
                  }
                  if (cur.ch > 0) {
                    cur = new Pos(cur.line, cur.ch + 1)
                    cm.replaceRange(
                      line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                      Pos(cur.line, cur.ch - 2),
                      cur,
                      '+transpose'
                    )
                  } else if (cur.line > cm.doc.first) {
                    var prev = getLine(cm.doc, cur.line - 1).text
                    if (prev) {
                      cur = new Pos(cur.line, 1)
                      cm.replaceRange(
                        line.charAt(0) +
                          cm.doc.lineSeparator() +
                          prev.charAt(prev.length - 1),
                        Pos(cur.line - 1, prev.length - 1),
                        cur,
                        '+transpose'
                      )
                    }
                  }
                }
                newSel.push(new Range(cur, cur))
              }
              cm.setSelections(newSel)
            })
          },
          newlineAndIndent: function (cm) {
            return runInOp(cm, function () {
              var sels = cm.listSelections()
              for (var i = sels.length - 1; i >= 0; i--) {
                cm.replaceRange(
                  cm.doc.lineSeparator(),
                  sels[i].anchor,
                  sels[i].head,
                  '+input'
                )
              }
              sels = cm.listSelections()
              for (var i$1 = 0; i$1 < sels.length; i$1++) {
                cm.indentLine(sels[i$1].from().line, null, true)
              }
              ensureCursorVisible(cm)
            })
          },
          openLine: function (cm) {
            return cm.replaceSelection('\n', 'start')
          },
          toggleOverwrite: function (cm) {
            return cm.toggleOverwrite()
          }
        }

        function lineStart(cm, lineN) {
          var line = getLine(cm.doc, lineN)
          var visual = visualLine(line)
          if (visual != line) {
            lineN = lineNo(visual)
          }
          return endOfLine(true, cm, visual, lineN, 1)
        }
        function lineEnd(cm, lineN) {
          var line = getLine(cm.doc, lineN)
          var visual = visualLineEnd(line)
          if (visual != line) {
            lineN = lineNo(visual)
          }
          return endOfLine(true, cm, line, lineN, -1)
        }
        function lineStartSmart(cm, pos) {
          var start = lineStart(cm, pos.line)
          var line = getLine(cm.doc, start.line)
          var order = getOrder(line, cm.doc.direction)
          if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(start.ch, line.text.search(/\S/))
            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch
            return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
          }
          return start
        }

        // Run a handler that was bound to a key.
        function doHandleBinding(cm, bound, dropShift) {
          if (typeof bound == 'string') {
            bound = commands[bound]
            if (!bound) {
              return false
            }
          }
          // Ensure previous input has been read, so that the handler sees a
          // consistent view of the document
          cm.display.input.ensurePolled()
          var prevShift = cm.display.shift,
            done = false
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true
            }
            if (dropShift) {
              cm.display.shift = false
            }
            done = bound(cm) != Pass
          } finally {
            cm.display.shift = prevShift
            cm.state.suppressEdits = false
          }
          return done
        }

        function lookupKeyForEditor(cm, name, handle) {
          for (var i = 0; i < cm.state.keyMaps.length; i++) {
            var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)
            if (result) {
              return result
            }
          }
          return (
            (cm.options.extraKeys &&
              lookupKey(name, cm.options.extraKeys, handle, cm)) ||
            lookupKey(name, cm.options.keyMap, handle, cm)
          )
        }

        // Note that, despite the name, this function is also used to check
        // for bound mouse clicks.

        var stopSeq = new Delayed()

        function dispatchKey(cm, name, e, handle) {
          var seq = cm.state.keySeq
          if (seq) {
            if (isModifierKey(name)) {
              return 'handled'
            }
            if (/\'$/.test(name)) {
              cm.state.keySeq = null
            } else {
              stopSeq.set(50, function () {
                if (cm.state.keySeq == seq) {
                  cm.state.keySeq = null
                  cm.display.input.reset()
                }
              })
            }
            if (dispatchKeyInner(cm, seq + ' ' + name, e, handle)) {
              return true
            }
          }
          return dispatchKeyInner(cm, name, e, handle)
        }

        function dispatchKeyInner(cm, name, e, handle) {
          var result = lookupKeyForEditor(cm, name, handle)

          if (result == 'multi') {
            cm.state.keySeq = name
          }
          if (result == 'handled') {
            signalLater(cm, 'keyHandled', cm, name, e)
          }

          if (result == 'handled' || result == 'multi') {
            e_preventDefault(e)
            restartBlink(cm)
          }

          return !!result
        }

        // Handle a key from the keydown event.
        function handleKeyBinding(cm, e) {
          var name = keyName(e, true)
          if (!name) {
            return false
          }

          if (e.shiftKey && !cm.state.keySeq) {
            // First try to resolve full name (including 'Shift-'). Failing
            // that, see if there is a cursor-motion command (starting with
            // 'go') bound to the keyname without 'Shift-'.
            return (
              dispatchKey(cm, 'Shift-' + name, e, function (b) {
                return doHandleBinding(cm, b, true)
              }) ||
              dispatchKey(cm, name, e, function (b) {
                if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion) {
                  return doHandleBinding(cm, b)
                }
              })
            )
          } else {
            return dispatchKey(cm, name, e, function (b) {
              return doHandleBinding(cm, b)
            })
          }
        }

        // Handle a key from the keypress event
        function handleCharBinding(cm, e, ch) {
          return dispatchKey(cm, "'" + ch + "'", e, function (b) {
            return doHandleBinding(cm, b, true)
          })
        }

        var lastStoppedKey = null
        function onKeyDown(e) {
          var cm = this
          if (e.target && e.target != cm.display.input.getField()) {
            return
          }
          cm.curOp.focus = activeElt()
          if (signalDOMEvent(cm, e)) {
            return
          }
          // IE does strange things with escape.
          if (ie && ie_version < 11 && e.keyCode == 27) {
            e.returnValue = false
          }
          var code = e.keyCode
          cm.display.shift = code == 16 || e.shiftKey
          var handled = handleKeyBinding(cm, e)
          if (presto) {
            lastStoppedKey = handled ? code : null
            // Opera has no cut event... we try to at least catch the key combo
            if (
              !handled &&
              code == 88 &&
              !hasCopyEvent &&
              (mac ? e.metaKey : e.ctrlKey)
            ) {
              cm.replaceSelection('', null, 'cut')
            }
          }
          if (
            gecko &&
            !mac &&
            !handled &&
            code == 46 &&
            e.shiftKey &&
            !e.ctrlKey &&
            document.execCommand
          ) {
            document.execCommand('cut')
          }

          // Turn mouse into crosshair when Alt is held on Mac.
          if (
            code == 18 &&
            !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)
          ) {
            showCrossHair(cm)
          }
        }

        function showCrossHair(cm) {
          var lineDiv = cm.display.lineDiv
          addClass(lineDiv, 'CodeMirror-crosshair')

          function up(e) {
            if (e.keyCode == 18 || !e.altKey) {
              rmClass(lineDiv, 'CodeMirror-crosshair')
              off(document, 'keyup', up)
              off(document, 'mouseover', up)
            }
          }
          on(document, 'keyup', up)
          on(document, 'mouseover', up)
        }

        function onKeyUp(e) {
          if (e.keyCode == 16) {
            this.doc.sel.shift = false
          }
          signalDOMEvent(this, e)
        }

        function onKeyPress(e) {
          var cm = this
          if (e.target && e.target != cm.display.input.getField()) {
            return
          }
          if (
            eventInWidget(cm.display, e) ||
            signalDOMEvent(cm, e) ||
            (e.ctrlKey && !e.altKey) ||
            (mac && e.metaKey)
          ) {
            return
          }
          var keyCode = e.keyCode,
            charCode = e.charCode
          if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null
            e_preventDefault(e)
            return
          }
          if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
            return
          }
          var ch = String.fromCharCode(charCode == null ? keyCode : charCode)
          // Some browsers fire keypress events for backspace
          if (ch == '\x08') {
            return
          }
          if (handleCharBinding(cm, e, ch)) {
            return
          }
          cm.display.input.onKeyPress(e)
        }

        var DOUBLECLICK_DELAY = 400

        var PastClick = function (time, pos, button) {
          this.time = time
          this.pos = pos
          this.button = button
        }

        PastClick.prototype.compare = function (time, pos, button) {
          return (
            this.time + DOUBLECLICK_DELAY > time &&
            cmp(pos, this.pos) == 0 &&
            button == this.button
          )
        }

        var lastClick, lastDoubleClick
        function clickRepeat(pos, button) {
          var now = +new Date()
          if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
            lastClick = lastDoubleClick = null
            return 'triple'
          } else if (lastClick && lastClick.compare(now, pos, button)) {
            lastDoubleClick = new PastClick(now, pos, button)
            lastClick = null
            return 'double'
          } else {
            lastClick = new PastClick(now, pos, button)
            lastDoubleClick = null
            return 'single'
          }
        }

        // A mouse down can be a single click, double click, triple click,
        // start of selection drag, start of text drag, new cursor
        // (ctrl-click), rectangle drag (alt-drag), or xwin
        // middle-click-paste. Or it might be a click on something we should
        // not interfere with, such as a scrollbar or widget.
        function onMouseDown(e) {
          var cm = this,
            display = cm.display
          if (
            signalDOMEvent(cm, e) ||
            (display.activeTouch && display.input.supportsTouch())
          ) {
            return
          }
          display.input.ensurePolled()
          display.shift = e.shiftKey

          if (eventInWidget(display, e)) {
            if (!webkit) {
              // Briefly turn off draggability, to allow widgets to do
              // normal dragging things.
              display.scroller.draggable = false
              setTimeout(function () {
                return (display.scroller.draggable = true)
              }, 100)
            }
            return
          }
          if (clickInGutter(cm, e)) {
            return
          }
          var pos = posFromMouse(cm, e),
            button = e_button(e),
            repeat = pos ? clickRepeat(pos, button) : 'single'
          window.focus()

          // #3261: make sure, that we're not starting a second selection
          if (button == 1 && cm.state.selectingText) {
            cm.state.selectingText(e)
          }

          if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
            return
          }

          if (button == 1) {
            if (pos) {
              leftButtonDown(cm, pos, repeat, e)
            } else if (e_target(e) == display.scroller) {
              e_preventDefault(e)
            }
          } else if (button == 2) {
            if (pos) {
              extendSelection(cm.doc, pos)
            }
            setTimeout(function () {
              return display.input.focus()
            }, 20)
          } else if (button == 3) {
            if (captureRightClick) {
              cm.display.input.onContextMenu(e)
            } else {
              delayBlurEvent(cm)
            }
          }
        }

        function handleMappedButton(cm, button, pos, repeat, event) {
          var name = 'Click'
          if (repeat == 'double') {
            name = 'Double' + name
          } else if (repeat == 'triple') {
            name = 'Triple' + name
          }
          name =
            (button == 1 ? 'Left' : button == 2 ? 'Middle' : 'Right') + name

          return dispatchKey(
            cm,
            addModifierNames(name, event),
            event,
            function (bound) {
              if (typeof bound == 'string') {
                bound = commands[bound]
              }
              if (!bound) {
                return false
              }
              var done = false
              try {
                if (cm.isReadOnly()) {
                  cm.state.suppressEdits = true
                }
                done = bound(cm, pos) != Pass
              } finally {
                cm.state.suppressEdits = false
              }
              return done
            }
          )
        }

        function configureMouse(cm, repeat, event) {
          var option = cm.getOption('configureMouse')
          var value = option ? option(cm, repeat, event) : {}
          if (value.unit == null) {
            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey
            value.unit = rect
              ? 'rectangle'
              : repeat == 'single'
              ? 'char'
              : repeat == 'double'
              ? 'word'
              : 'line'
          }
          if (value.extend == null || cm.doc.extend) {
            value.extend = cm.doc.extend || event.shiftKey
          }
          if (value.addNew == null) {
            value.addNew = mac ? event.metaKey : event.ctrlKey
          }
          if (value.moveOnDrag == null) {
            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey)
          }
          return value
        }

        function leftButtonDown(cm, pos, repeat, event) {
          if (ie) {
            setTimeout(bind(ensureFocus, cm), 0)
          } else {
            cm.curOp.focus = activeElt()
          }

          var behavior = configureMouse(cm, repeat, event)

          var sel = cm.doc.sel,
            contained
          if (
            cm.options.dragDrop &&
            dragAndDrop &&
            !cm.isReadOnly() &&
            repeat == 'single' &&
            (contained = sel.contains(pos)) > -1 &&
            (cmp((contained = sel.ranges[contained]).from(), pos) < 0 ||
              pos.xRel > 0) &&
            (cmp(contained.to(), pos) > 0 || pos.xRel < 0)
          ) {
            leftButtonStartDrag(cm, event, pos, behavior)
          } else {
            leftButtonSelect(cm, event, pos, behavior)
          }
        }

        // Start a text drag. When it ends, see if any dragging actually
        // happen, and treat as a click if it didn't.
        function leftButtonStartDrag(cm, event, pos, behavior) {
          var display = cm.display,
            moved = false
          var dragEnd = operation(cm, function (e) {
            if (webkit) {
              display.scroller.draggable = false
            }
            cm.state.draggingText = false
            if (cm.state.delayingBlurEvent) {
              if (cm.hasFocus()) {
                cm.state.delayingBlurEvent = false
              } else {
                delayBlurEvent(cm)
              }
            }
            off(display.wrapper.ownerDocument, 'mouseup', dragEnd)
            off(display.wrapper.ownerDocument, 'mousemove', mouseMove)
            off(display.scroller, 'dragstart', dragStart)
            off(display.scroller, 'drop', dragEnd)
            if (!moved) {
              e_preventDefault(e)
              if (!behavior.addNew) {
                extendSelection(cm.doc, pos, null, null, behavior.extend)
              }
              // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
              if ((webkit && !safari) || (ie && ie_version == 9)) {
                setTimeout(function () {
                  display.wrapper.ownerDocument.body.focus({
                    preventScroll: true
                  })
                  display.input.focus()
                }, 20)
              } else {
                display.input.focus()
              }
            }
          })
          var mouseMove = function (e2) {
            moved =
              moved ||
              Math.abs(event.clientX - e2.clientX) +
                Math.abs(event.clientY - e2.clientY) >=
                10
          }
          var dragStart = function () {
            return (moved = true)
          }
          // Let the drag handler handle this.
          if (webkit) {
            display.scroller.draggable = true
          }
          cm.state.draggingText = dragEnd
          dragEnd.copy = !behavior.moveOnDrag
          on(display.wrapper.ownerDocument, 'mouseup', dragEnd)
          on(display.wrapper.ownerDocument, 'mousemove', mouseMove)
          on(display.scroller, 'dragstart', dragStart)
          on(display.scroller, 'drop', dragEnd)

          cm.state.delayingBlurEvent = true
          setTimeout(function () {
            return display.input.focus()
          }, 20)
          // IE's approach to draggable
          if (display.scroller.dragDrop) {
            display.scroller.dragDrop()
          }
        }

        function rangeForUnit(cm, pos, unit) {
          if (unit == 'char') {
            return new Range(pos, pos)
          }
          if (unit == 'word') {
            return cm.findWordAt(pos)
          }
          if (unit == 'line') {
            return new Range(
              Pos(pos.line, 0),
              clipPos(cm.doc, Pos(pos.line + 1, 0))
            )
          }
          var result = unit(cm, pos)
          return new Range(result.from, result.to)
        }

        // Normal selection, as opposed to text dragging.
        function leftButtonSelect(cm, event, start, behavior) {
          if (ie) {
            delayBlurEvent(cm)
          }
          var display = cm.display,
            doc = cm.doc
          e_preventDefault(event)

          var ourRange,
            ourIndex,
            startSel = doc.sel,
            ranges = startSel.ranges
          if (behavior.addNew && !behavior.extend) {
            ourIndex = doc.sel.contains(start)
            if (ourIndex > -1) {
              ourRange = ranges[ourIndex]
            } else {
              ourRange = new Range(start, start)
            }
          } else {
            ourRange = doc.sel.primary()
            ourIndex = doc.sel.primIndex
          }

          if (behavior.unit == 'rectangle') {
            if (!behavior.addNew) {
              ourRange = new Range(start, start)
            }
            start = posFromMouse(cm, event, true, true)
            ourIndex = -1
          } else {
            var range = rangeForUnit(cm, start, behavior.unit)
            if (behavior.extend) {
              ourRange = extendRange(
                ourRange,
                range.anchor,
                range.head,
                behavior.extend
              )
            } else {
              ourRange = range
            }
          }

          if (!behavior.addNew) {
            ourIndex = 0
            setSelection(doc, new Selection([ourRange], 0), sel_mouse)
            startSel = doc.sel
          } else if (ourIndex == -1) {
            ourIndex = ranges.length
            setSelection(
              doc,
              normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
              { scroll: false, origin: '*mouse' }
            )
          } else if (
            ranges.length > 1 &&
            ranges[ourIndex].empty() &&
            behavior.unit == 'char' &&
            !behavior.extend
          ) {
            setSelection(
              doc,
              normalizeSelection(
                cm,
                ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)),
                0
              ),
              { scroll: false, origin: '*mouse' }
            )
            startSel = doc.sel
          } else {
            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)
          }

          var lastPos = start
          function extendTo(pos) {
            if (cmp(lastPos, pos) == 0) {
              return
            }
            lastPos = pos

            if (behavior.unit == 'rectangle') {
              var ranges = [],
                tabSize = cm.options.tabSize
              var startCol = countColumn(
                getLine(doc, start.line).text,
                start.ch,
                tabSize
              )
              var posCol = countColumn(
                getLine(doc, pos.line).text,
                pos.ch,
                tabSize
              )
              var left = Math.min(startCol, posCol),
                right = Math.max(startCol, posCol)
              for (
                var line = Math.min(start.line, pos.line),
                  end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
                line <= end;
                line++
              ) {
                var text = getLine(doc, line).text,
                  leftPos = findColumn(text, left, tabSize)
                if (left == right) {
                  ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)))
                } else if (text.length > leftPos) {
                  ranges.push(
                    new Range(
                      Pos(line, leftPos),
                      Pos(line, findColumn(text, right, tabSize))
                    )
                  )
                }
              }
              if (!ranges.length) {
                ranges.push(new Range(start, start))
              }
              setSelection(
                doc,
                normalizeSelection(
                  cm,
                  startSel.ranges.slice(0, ourIndex).concat(ranges),
                  ourIndex
                ),
                { origin: '*mouse', scroll: false }
              )
              cm.scrollIntoView(pos)
            } else {
              var oldRange = ourRange
              var range = rangeForUnit(cm, pos, behavior.unit)
              var anchor = oldRange.anchor,
                head
              if (cmp(range.anchor, anchor) > 0) {
                head = range.head
                anchor = minPos(oldRange.from(), range.anchor)
              } else {
                head = range.anchor
                anchor = maxPos(oldRange.to(), range.head)
              }
              var ranges$1 = startSel.ranges.slice(0)
              ranges$1[ourIndex] = bidiSimplify(
                cm,
                new Range(clipPos(doc, anchor), head)
              )
              setSelection(
                doc,
                normalizeSelection(cm, ranges$1, ourIndex),
                sel_mouse
              )
            }
          }

          var editorSize = display.wrapper.getBoundingClientRect()
          // Used to ensure timeout re-tries don't fire when another extend
          // happened in the meantime (clearTimeout isn't reliable -- at
          // least on Chrome, the timeouts still happen even when cleared,
          // if the clear happens after their scheduled firing time).
          var counter = 0

          function extend(e) {
            var curCount = ++counter
            var cur = posFromMouse(cm, e, true, behavior.unit == 'rectangle')
            if (!cur) {
              return
            }
            if (cmp(cur, lastPos) != 0) {
              cm.curOp.focus = activeElt()
              extendTo(cur)
              var visible = visibleLines(display, doc)
              if (cur.line >= visible.to || cur.line < visible.from) {
                setTimeout(
                  operation(cm, function () {
                    if (counter == curCount) {
                      extend(e)
                    }
                  }),
                  150
                )
              }
            } else {
              var outside =
                e.clientY < editorSize.top
                  ? -20
                  : e.clientY > editorSize.bottom
                  ? 20
                  : 0
              if (outside) {
                setTimeout(
                  operation(cm, function () {
                    if (counter != curCount) {
                      return
                    }
                    display.scroller.scrollTop += outside
                    extend(e)
                  }),
                  50
                )
              }
            }
          }

          function done(e) {
            cm.state.selectingText = false
            counter = Infinity
            // If e is null or undefined we interpret this as someone trying
            // to explicitly cancel the selection rather than the user
            // letting go of the mouse button.
            if (e) {
              e_preventDefault(e)
              display.input.focus()
            }
            off(display.wrapper.ownerDocument, 'mousemove', move)
            off(display.wrapper.ownerDocument, 'mouseup', up)
            doc.history.lastSelOrigin = null
          }

          var move = operation(cm, function (e) {
            if (e.buttons === 0 || !e_button(e)) {
              done(e)
            } else {
              extend(e)
            }
          })
          var up = operation(cm, done)
          cm.state.selectingText = up
          on(display.wrapper.ownerDocument, 'mousemove', move)
          on(display.wrapper.ownerDocument, 'mouseup', up)
        }

        // Used when mouse-selecting to adjust the anchor to the proper side
        // of a bidi jump depending on the visual position of the head.
        function bidiSimplify(cm, range) {
          var anchor = range.anchor
          var head = range.head
          var anchorLine = getLine(cm.doc, anchor.line)
          if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
            return range
          }
          var order = getOrder(anchorLine)
          if (!order) {
            return range
          }
          var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
            part = order[index]
          if (part.from != anchor.ch && part.to != anchor.ch) {
            return range
          }
          var boundary =
            index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1)
          if (boundary == 0 || boundary == order.length) {
            return range
          }

          // Compute the relative visual position of the head compared to the
          // anchor (<0 is to the left, >0 to the right)
          var leftSide
          if (head.line != anchor.line) {
            leftSide =
              (head.line - anchor.line) * (cm.doc.direction == 'ltr' ? 1 : -1) >
              0
          } else {
            var headIndex = getBidiPartAt(order, head.ch, head.sticky)
            var dir =
              headIndex - index ||
              (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1)
            if (headIndex == boundary - 1 || headIndex == boundary) {
              leftSide = dir < 0
            } else {
              leftSide = dir > 0
            }
          }

          var usePart = order[boundary + (leftSide ? -1 : 0)]
          var from = leftSide == (usePart.level == 1)
          var ch = from ? usePart.from : usePart.to,
            sticky = from ? 'after' : 'before'
          return anchor.ch == ch && anchor.sticky == sticky
            ? range
            : new Range(new Pos(anchor.line, ch, sticky), head)
        }

        // Determines whether an event happened in the gutter, and fires the
        // handlers for the corresponding event.
        function gutterEvent(cm, e, type, prevent) {
          var mX, mY
          if (e.touches) {
            mX = e.touches[0].clientX
            mY = e.touches[0].clientY
          } else {
            try {
              mX = e.clientX
              mY = e.clientY
            } catch (e$1) {
              return false
            }
          }
          if (
            mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)
          ) {
            return false
          }
          if (prevent) {
            e_preventDefault(e)
          }

          var display = cm.display
          var lineBox = display.lineDiv.getBoundingClientRect()

          if (mY > lineBox.bottom || !hasHandler(cm, type)) {
            return e_defaultPrevented(e)
          }
          mY -= lineBox.top - display.viewOffset

          for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
            var g = display.gutters.childNodes[i]
            if (g && g.getBoundingClientRect().right >= mX) {
              var line = lineAtHeight(cm.doc, mY)
              var gutter = cm.display.gutterSpecs[i]
              signal(cm, type, cm, line, gutter.className, e)
              return e_defaultPrevented(e)
            }
          }
        }

        function clickInGutter(cm, e) {
          return gutterEvent(cm, e, 'gutterClick', true)
        }

        // CONTEXT MENU HANDLING

        // To make the context menu work, we need to briefly unhide the
        // textarea (making it as unobtrusive as possible) to let the
        // right-click take effect on it.
        function onContextMenu(cm, e) {
          if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
            return
          }
          if (signalDOMEvent(cm, e, 'contextmenu')) {
            return
          }
          if (!captureRightClick) {
            cm.display.input.onContextMenu(e)
          }
        }

        function contextMenuInGutter(cm, e) {
          if (!hasHandler(cm, 'gutterContextMenu')) {
            return false
          }
          return gutterEvent(cm, e, 'gutterContextMenu', false)
        }

        function themeChanged(cm) {
          cm.display.wrapper.className =
            cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') +
            cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-')
          clearCaches(cm)
        }

        var Init = {
          toString: function () {
            return 'CodeMirror.Init'
          }
        }

        var defaults = {}
        var optionHandlers = {}

        function defineOptions(CodeMirror) {
          var optionHandlers = CodeMirror.optionHandlers

          function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt
            if (handle) {
              optionHandlers[name] = notOnInit
                ? function (cm, val, old) {
                    if (old != Init) {
                      handle(cm, val, old)
                    }
                  }
                : handle
            }
          }

          CodeMirror.defineOption = option

          // Passed to option handlers when there is no old value.
          CodeMirror.Init = Init

          // These two are, on init, called from the constructor because they
          // have to be initialized before the editor can start at all.
          option(
            'value',
            '',
            function (cm, val) {
              return cm.setValue(val)
            },
            true
          )
          option(
            'mode',
            null,
            function (cm, val) {
              cm.doc.modeOption = val
              loadMode(cm)
            },
            true
          )

          option('indentUnit', 2, loadMode, true)
          option('indentWithTabs', false)
          option('smartIndent', true)
          option(
            'tabSize',
            4,
            function (cm) {
              resetModeState(cm)
              clearCaches(cm)
              regChange(cm)
            },
            true
          )

          option('lineSeparator', null, function (cm, val) {
            cm.doc.lineSep = val
            if (!val) {
              return
            }
            var newBreaks = [],
              lineNo = cm.doc.first
            cm.doc.iter(function (line) {
              for (var pos = 0; ; ) {
                var found = line.text.indexOf(val, pos)
                if (found == -1) {
                  break
                }
                pos = found + val.length
                newBreaks.push(Pos(lineNo, found))
              }
              lineNo++
            })
            for (var i = newBreaks.length - 1; i >= 0; i--) {
              replaceRange(
                cm.doc,
                val,
                newBreaks[i],
                Pos(newBreaks[i].line, newBreaks[i].ch + val.length)
              )
            }
          })
          option(
            'specialChars',
            /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g,
            function (cm, val, old) {
              cm.state.specialChars = new RegExp(
                val.source + (val.test('\t') ? '' : '|\t'),
                'g'
              )
              if (old != Init) {
                cm.refresh()
              }
            }
          )
          option(
            'specialCharPlaceholder',
            defaultSpecialCharPlaceholder,
            function (cm) {
              return cm.refresh()
            },
            true
          )
          option('electricChars', true)
          option(
            'inputStyle',
            mobile ? 'contenteditable' : 'textarea',
            function () {
              throw new Error(
                'inputStyle can not (yet) be changed in a running editor'
              ) // FIXME
            },
            true
          )
          option(
            'spellcheck',
            false,
            function (cm, val) {
              return (cm.getInputField().spellcheck = val)
            },
            true
          )
          option(
            'autocorrect',
            false,
            function (cm, val) {
              return (cm.getInputField().autocorrect = val)
            },
            true
          )
          option(
            'autocapitalize',
            false,
            function (cm, val) {
              return (cm.getInputField().autocapitalize = val)
            },
            true
          )
          option('rtlMoveVisually', !windows)
          option('wholeLineUpdateBefore', true)

          option(
            'theme',
            'default',
            function (cm) {
              themeChanged(cm)
              updateGutters(cm)
            },
            true
          )
          option('keyMap', 'default', function (cm, val, old) {
            var next = getKeyMap(val)
            var prev = old != Init && getKeyMap(old)
            if (prev && prev.detach) {
              prev.detach(cm, next)
            }
            if (next.attach) {
              next.attach(cm, prev || null)
            }
          })
          option('extraKeys', null)
          option('configureMouse', null)

          option('lineWrapping', false, wrappingChanged, true)
          option(
            'gutters',
            [],
            function (cm, val) {
              cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers)
              updateGutters(cm)
            },
            true
          )
          option(
            'fixedGutter',
            true,
            function (cm, val) {
              cm.display.gutters.style.left = val
                ? compensateForHScroll(cm.display) + 'px'
                : '0'
              cm.refresh()
            },
            true
          )
          option(
            'coverGutterNextToScrollbar',
            false,
            function (cm) {
              return updateScrollbars(cm)
            },
            true
          )
          option(
            'scrollbarStyle',
            'native',
            function (cm) {
              initScrollbars(cm)
              updateScrollbars(cm)
              cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)
              cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
            },
            true
          )
          option(
            'lineNumbers',
            false,
            function (cm, val) {
              cm.display.gutterSpecs = getGutters(cm.options.gutters, val)
              updateGutters(cm)
            },
            true
          )
          option('firstLineNumber', 1, updateGutters, true)
          option(
            'lineNumberFormatter',
            function (integer) {
              return integer
            },
            updateGutters,
            true
          )
          option('showCursorWhenSelecting', false, updateSelection, true)

          option('resetSelectionOnContextMenu', true)
          option('lineWiseCopyCut', true)
          option('pasteLinesPerSelection', true)
          option('selectionsMayTouch', false)

          option('readOnly', false, function (cm, val) {
            if (val == 'nocursor') {
              onBlur(cm)
              cm.display.input.blur()
            }
            cm.display.input.readOnlyChanged(val)
          })

          option('screenReaderLabel', null, function (cm, val) {
            val = val === '' ? null : val
            cm.display.input.screenReaderLabelChanged(val)
          })

          option(
            'disableInput',
            false,
            function (cm, val) {
              if (!val) {
                cm.display.input.reset()
              }
            },
            true
          )
          option('dragDrop', true, dragDropChanged)
          option('allowDropFileTypes', null)

          option('cursorBlinkRate', 530)
          option('cursorScrollMargin', 0)
          option('cursorHeight', 1, updateSelection, true)
          option('singleCursorHeightPerLine', true, updateSelection, true)
          option('workTime', 100)
          option('workDelay', 100)
          option('flattenSpans', true, resetModeState, true)
          option('addModeClass', false, resetModeState, true)
          option('pollInterval', 100)
          option('undoDepth', 200, function (cm, val) {
            return (cm.doc.history.undoDepth = val)
          })
          option('historyEventDelay', 1250)
          option(
            'viewportMargin',
            10,
            function (cm) {
              return cm.refresh()
            },
            true
          )
          option('maxHighlightLength', 10000, resetModeState, true)
          option('moveInputWithCursor', true, function (cm, val) {
            if (!val) {
              cm.display.input.resetPosition()
            }
          })

          option('tabindex', null, function (cm, val) {
            return (cm.display.input.getField().tabIndex = val || '')
          })
          option('autofocus', null)
          option(
            'direction',
            'ltr',
            function (cm, val) {
              return cm.doc.setDirection(val)
            },
            true
          )
          option('phrases', null)
        }

        function dragDropChanged(cm, value, old) {
          var wasOn = old && old != Init
          if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions
            var toggle = value ? on : off
            toggle(cm.display.scroller, 'dragstart', funcs.start)
            toggle(cm.display.scroller, 'dragenter', funcs.enter)
            toggle(cm.display.scroller, 'dragover', funcs.over)
            toggle(cm.display.scroller, 'dragleave', funcs.leave)
            toggle(cm.display.scroller, 'drop', funcs.drop)
          }
        }

        function wrappingChanged(cm) {
          if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, 'CodeMirror-wrap')
            cm.display.sizer.style.minWidth = ''
            cm.display.sizerWidth = null
          } else {
            rmClass(cm.display.wrapper, 'CodeMirror-wrap')
            findMaxLine(cm)
          }
          estimateLineHeights(cm)
          regChange(cm)
          clearCaches(cm)
          setTimeout(function () {
            return updateScrollbars(cm)
          }, 100)
        }

        // A CodeMirror instance represents an editor. This is the object
        // that user code is usually dealing with.

        function CodeMirror(place, options) {
          var this$1 = this

          if (!(this instanceof CodeMirror)) {
            return new CodeMirror(place, options)
          }

          this.options = options = options ? copyObj(options) : {}
          // Determine effective options based on given values and defaults.
          copyObj(defaults, options, false)

          var doc = options.value
          if (typeof doc == 'string') {
            doc = new Doc(
              doc,
              options.mode,
              null,
              options.lineSeparator,
              options.direction
            )
          } else if (options.mode) {
            doc.modeOption = options.mode
          }
          this.doc = doc

          var input = new CodeMirror.inputStyles[options.inputStyle](this)
          var display = (this.display = new Display(place, doc, input, options))
          display.wrapper.CodeMirror = this
          themeChanged(this)
          if (options.lineWrapping) {
            this.display.wrapper.className += ' CodeMirror-wrap'
          }
          initScrollbars(this)

          this.state = {
            keyMaps: [], // stores maps added by addKeyMap
            overlays: [], // highlighting overlays, as added by addOverlay
            modeGen: 0, // bumped when mode/overlay changes, used to invalidate highlighting info
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
            pasteIncoming: -1,
            cutIncoming: -1, // help recognize paste/cut edits in input.poll
            selectingText: false,
            draggingText: false,
            highlight: new Delayed(), // stores highlight worker timeout
            keySeq: null, // Unfinished key sequence
            specialChars: null
          }

          if (options.autofocus && !mobile) {
            display.input.focus()
          }

          // Override magic textarea content restore that IE sometimes does
          // on our hidden textarea on reload
          if (ie && ie_version < 11) {
            setTimeout(function () {
              return this$1.display.input.reset(true)
            }, 20)
          }

          registerEventHandlers(this)
          ensureGlobalHandlers()

          startOperation(this)
          this.curOp.forceUpdate = true
          attachDoc(this, doc)

          if ((options.autofocus && !mobile) || this.hasFocus()) {
            setTimeout(function () {
              if (this$1.hasFocus() && !this$1.state.focused) {
                onFocus(this$1)
              }
            }, 20)
          } else {
            onBlur(this)
          }

          for (var opt in optionHandlers) {
            if (optionHandlers.hasOwnProperty(opt)) {
              optionHandlers[opt](this, options[opt], Init)
            }
          }
          maybeUpdateLineNumberWidth(this)
          if (options.finishInit) {
            options.finishInit(this)
          }
          for (var i = 0; i < initHooks.length; ++i) {
            initHooks[i](this)
          }
          endOperation(this)
          // Suppress optimizelegibility in Webkit, since it breaks text
          // measuring on line wrapping boundaries.
          if (
            webkit &&
            options.lineWrapping &&
            getComputedStyle(display.lineDiv).textRendering ==
              'optimizelegibility'
          ) {
            display.lineDiv.style.textRendering = 'auto'
          }
        }

        // The default configuration options.
        CodeMirror.defaults = defaults
        // Functions to run when options are changed.
        CodeMirror.optionHandlers = optionHandlers

        // Attach the necessary event handlers when initializing the editor
        function registerEventHandlers(cm) {
          var d = cm.display
          on(d.scroller, 'mousedown', operation(cm, onMouseDown))
          // Older IE's will not fire a second mousedown for a double click
          if (ie && ie_version < 11) {
            on(
              d.scroller,
              'dblclick',
              operation(cm, function (e) {
                if (signalDOMEvent(cm, e)) {
                  return
                }
                var pos = posFromMouse(cm, e)
                if (
                  !pos ||
                  clickInGutter(cm, e) ||
                  eventInWidget(cm.display, e)
                ) {
                  return
                }
                e_preventDefault(e)
                var word = cm.findWordAt(pos)
                extendSelection(cm.doc, word.anchor, word.head)
              })
            )
          } else {
            on(d.scroller, 'dblclick', function (e) {
              return signalDOMEvent(cm, e) || e_preventDefault(e)
            })
          }
          // Some browsers fire contextmenu *after* opening the menu, at
          // which point we can't mess with it anymore. Context menu is
          // handled in onMouseDown for these browsers.
          on(d.scroller, 'contextmenu', function (e) {
            return onContextMenu(cm, e)
          })
          on(d.input.getField(), 'contextmenu', function (e) {
            if (!d.scroller.contains(e.target)) {
              onContextMenu(cm, e)
            }
          })

          // Used to suppress mouse event handling when a touch happens
          var touchFinished,
            prevTouch = { end: 0 }
          function finishTouch() {
            if (d.activeTouch) {
              touchFinished = setTimeout(function () {
                return (d.activeTouch = null)
              }, 1000)
              prevTouch = d.activeTouch
              prevTouch.end = +new Date()
            }
          }
          function isMouseLikeTouchEvent(e) {
            if (e.touches.length != 1) {
              return false
            }
            var touch = e.touches[0]
            return touch.radiusX <= 1 && touch.radiusY <= 1
          }
          function farAway(touch, other) {
            if (other.left == null) {
              return true
            }
            var dx = other.left - touch.left,
              dy = other.top - touch.top
            return dx * dx + dy * dy > 20 * 20
          }
          on(d.scroller, 'touchstart', function (e) {
            if (
              !signalDOMEvent(cm, e) &&
              !isMouseLikeTouchEvent(e) &&
              !clickInGutter(cm, e)
            ) {
              d.input.ensurePolled()
              clearTimeout(touchFinished)
              var now = +new Date()
              d.activeTouch = {
                start: now,
                moved: false,
                prev: now - prevTouch.end <= 300 ? prevTouch : null
              }
              if (e.touches.length == 1) {
                d.activeTouch.left = e.touches[0].pageX
                d.activeTouch.top = e.touches[0].pageY
              }
            }
          })
          on(d.scroller, 'touchmove', function () {
            if (d.activeTouch) {
              d.activeTouch.moved = true
            }
          })
          on(d.scroller, 'touchend', function (e) {
            var touch = d.activeTouch
            if (
              touch &&
              !eventInWidget(d, e) &&
              touch.left != null &&
              !touch.moved &&
              new Date() - touch.start < 300
            ) {
              var pos = cm.coordsChar(d.activeTouch, 'page'),
                range
              if (!touch.prev || farAway(touch, touch.prev)) {
                // Single tap
                range = new Range(pos, pos)
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
                // Double tap
                range = cm.findWordAt(pos)
              } // Triple tap
              else {
                range = new Range(
                  Pos(pos.line, 0),
                  clipPos(cm.doc, Pos(pos.line + 1, 0))
                )
              }
              cm.setSelection(range.anchor, range.head)
              cm.focus()
              e_preventDefault(e)
            }
            finishTouch()
          })
          on(d.scroller, 'touchcancel', finishTouch)

          // Sync scrolling between fake scrollbars and real scrollable
          // area, ensure viewport is updated when scrolling.
          on(d.scroller, 'scroll', function () {
            if (d.scroller.clientHeight) {
              updateScrollTop(cm, d.scroller.scrollTop)
              setScrollLeft(cm, d.scroller.scrollLeft, true)
              signal(cm, 'scroll', cm)
            }
          })

          // Listen to wheel events in order to try and update the viewport on time.
          on(d.scroller, 'mousewheel', function (e) {
            return onScrollWheel(cm, e)
          })
          on(d.scroller, 'DOMMouseScroll', function (e) {
            return onScrollWheel(cm, e)
          })

          // Prevent wrapper from ever scrolling
          on(d.wrapper, 'scroll', function () {
            return (d.wrapper.scrollTop = d.wrapper.scrollLeft = 0)
          })

          d.dragFunctions = {
            enter: function (e) {
              if (!signalDOMEvent(cm, e)) {
                e_stop(e)
              }
            },
            over: function (e) {
              if (!signalDOMEvent(cm, e)) {
                onDragOver(cm, e)
                e_stop(e)
              }
            },
            start: function (e) {
              return onDragStart(cm, e)
            },
            drop: operation(cm, onDrop),
            leave: function (e) {
              if (!signalDOMEvent(cm, e)) {
                clearDragCursor(cm)
              }
            }
          }

          var inp = d.input.getField()
          on(inp, 'keyup', function (e) {
            return onKeyUp.call(cm, e)
          })
          on(inp, 'keydown', operation(cm, onKeyDown))
          on(inp, 'keypress', operation(cm, onKeyPress))
          on(inp, 'focus', function (e) {
            return onFocus(cm, e)
          })
          on(inp, 'blur', function (e) {
            return onBlur(cm, e)
          })
        }

        var initHooks = []
        CodeMirror.defineInitHook = function (f) {
          return initHooks.push(f)
        }

        // Indent the given line. The how parameter can be "smart",
        // "add"/null, "subtract", or "prev". When aggressive is false
        // (typically set to true for forced single-line indents), empty
        // lines are not indented, and places where the mode returns Pass
        // are left alone.
        function indentLine(cm, n, how, aggressive) {
          var doc = cm.doc,
            state
          if (how == null) {
            how = 'add'
          }
          if (how == 'smart') {
            // Fall back to "prev" when the mode doesn't have an indentation
            // method.
            if (!doc.mode.indent) {
              how = 'prev'
            } else {
              state = getContextBefore(cm, n).state
            }
          }

          var tabSize = cm.options.tabSize
          var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize)
          if (line.stateAfter) {
            line.stateAfter = null
          }
          var curSpaceString = line.text.match(/^\s*/)[0],
            indentation
          if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0
            how = 'not'
          } else if (how == 'smart') {
            indentation = doc.mode.indent(
              state,
              line.text.slice(curSpaceString.length),
              line.text
            )
            if (indentation == Pass || indentation > 150) {
              if (!aggressive) {
                return
              }
              how = 'prev'
            }
          }
          if (how == 'prev') {
            if (n > doc.first) {
              indentation = countColumn(getLine(doc, n - 1).text, null, tabSize)
            } else {
              indentation = 0
            }
          } else if (how == 'add') {
            indentation = curSpace + cm.options.indentUnit
          } else if (how == 'subtract') {
            indentation = curSpace - cm.options.indentUnit
          } else if (typeof how == 'number') {
            indentation = curSpace + how
          }
          indentation = Math.max(0, indentation)

          var indentString = '',
            pos = 0
          if (cm.options.indentWithTabs) {
            for (var i = Math.floor(indentation / tabSize); i; --i) {
              pos += tabSize
              indentString += '\t'
            }
          }
          if (pos < indentation) {
            indentString += spaceStr(indentation - pos)
          }

          if (indentString != curSpaceString) {
            replaceRange(
              doc,
              indentString,
              Pos(n, 0),
              Pos(n, curSpaceString.length),
              '+input'
            )
            line.stateAfter = null
            return true
          } else {
            // Ensure that, if the cursor was in the whitespace at the start
            // of the line, it is moved to the end of that space.
            for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
              var range = doc.sel.ranges[i$1]
              if (
                range.head.line == n &&
                range.head.ch < curSpaceString.length
              ) {
                var pos$1 = Pos(n, curSpaceString.length)
                replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))
                break
              }
            }
          }
        }

        // This will be set to a {lineWise: bool, text: [string]} object, so
        // that, when pasting, we know what kind of selections the copied
        // text was made out of.
        var lastCopied = null

        function setLastCopied(newLastCopied) {
          lastCopied = newLastCopied
        }

        function applyTextInput(cm, inserted, deleted, sel, origin) {
          var doc = cm.doc
          cm.display.shift = false
          if (!sel) {
            sel = doc.sel
          }

          var recent = +new Date() - 200
          var paste = origin == 'paste' || cm.state.pasteIncoming > recent
          var textLines = splitLinesAuto(inserted),
            multiPaste = null
          // When pasting N lines into N selections, insert one line per selection
          if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join('\n') == inserted) {
              if (sel.ranges.length % lastCopied.text.length == 0) {
                multiPaste = []
                for (var i = 0; i < lastCopied.text.length; i++) {
                  multiPaste.push(doc.splitLines(lastCopied.text[i]))
                }
              }
            } else if (
              textLines.length == sel.ranges.length &&
              cm.options.pasteLinesPerSelection
            ) {
              multiPaste = map(textLines, function (l) {
                return [l]
              })
            }
          }

          var updateInput = cm.curOp.updateInput
          // Normal behavior is to insert the new text into every selection
          for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
            var range = sel.ranges[i$1]
            var from = range.from(),
              to = range.to()
            if (range.empty()) {
              if (deleted && deleted > 0) {
                // Handle deletion
                from = Pos(from.line, from.ch - deleted)
              } else if (cm.state.overwrite && !paste) {
                // Handle overwrite
                to = Pos(
                  to.line,
                  Math.min(
                    getLine(doc, to.line).text.length,
                    to.ch + lst(textLines).length
                  )
                )
              } else if (
                paste &&
                lastCopied &&
                lastCopied.lineWise &&
                lastCopied.text.join('\n') == textLines.join('\n')
              ) {
                from = to = Pos(from.line, 0)
              }
            }
            var changeEvent = {
              from: from,
              to: to,
              text: multiPaste
                ? multiPaste[i$1 % multiPaste.length]
                : textLines,
              origin:
                origin ||
                (paste
                  ? 'paste'
                  : cm.state.cutIncoming > recent
                  ? 'cut'
                  : '+input')
            }
            makeChange(cm.doc, changeEvent)
            signalLater(cm, 'inputRead', cm, changeEvent)
          }
          if (inserted && !paste) {
            triggerElectric(cm, inserted)
          }

          ensureCursorVisible(cm)
          if (cm.curOp.updateInput < 2) {
            cm.curOp.updateInput = updateInput
          }
          cm.curOp.typing = true
          cm.state.pasteIncoming = cm.state.cutIncoming = -1
        }

        function handlePaste(e, cm) {
          var pasted = e.clipboardData && e.clipboardData.getData('Text')
          if (pasted) {
            e.preventDefault()
            if (!cm.isReadOnly() && !cm.options.disableInput) {
              runInOp(cm, function () {
                return applyTextInput(cm, pasted, 0, null, 'paste')
              })
            }
            return true
          }
        }

        function triggerElectric(cm, inserted) {
          // When an 'electric' character is inserted, immediately trigger a reindent
          if (!cm.options.electricChars || !cm.options.smartIndent) {
            return
          }
          var sel = cm.doc.sel

          for (var i = sel.ranges.length - 1; i >= 0; i--) {
            var range = sel.ranges[i]
            if (
              range.head.ch > 100 ||
              (i && sel.ranges[i - 1].head.line == range.head.line)
            ) {
              continue
            }
            var mode = cm.getModeAt(range.head)
            var indented = false
            if (mode.electricChars) {
              for (var j = 0; j < mode.electricChars.length; j++) {
                if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                  indented = indentLine(cm, range.head.line, 'smart')
                  break
                }
              }
            } else if (mode.electricInput) {
              if (
                mode.electricInput.test(
                  getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)
                )
              ) {
                indented = indentLine(cm, range.head.line, 'smart')
              }
            }
            if (indented) {
              signalLater(cm, 'electricInput', cm, range.head.line)
            }
          }
        }

        function copyableRanges(cm) {
          var text = [],
            ranges = []
          for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
            var line = cm.doc.sel.ranges[i].head.line
            var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) }
            ranges.push(lineRange)
            text.push(cm.getRange(lineRange.anchor, lineRange.head))
          }
          return { text: text, ranges: ranges }
        }

        function disableBrowserMagic(
          field,
          spellcheck,
          autocorrect,
          autocapitalize
        ) {
          field.setAttribute('autocorrect', autocorrect ? '' : 'off')
          field.setAttribute('autocapitalize', autocapitalize ? '' : 'off')
          field.setAttribute('spellcheck', !!spellcheck)
        }

        function hiddenTextarea() {
          var te = elt(
            'textarea',
            null,
            null,
            'position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none'
          )
          var div = elt(
            'div',
            [te],
            null,
            'overflow: hidden; position: relative; width: 3px; height: 0px;'
          )
          // The textarea is kept positioned near the cursor to prevent the
          // fact that it'll be scrolled into view on input from scrolling
          // our fake cursor out of view. On webkit, when wrap=off, paste is
          // very slow. So make the area wide instead.
          if (webkit) {
            te.style.width = '1000px'
          } else {
            te.setAttribute('wrap', 'off')
          }
          // If border: 0; -- iOS fails to open keyboard (issue #1287)
          if (ios) {
            te.style.border = '1px solid black'
          }
          disableBrowserMagic(te)
          return div
        }

        // The publicly visible API. Note that methodOp(f) means
        // 'wrap f in an operation, performed on its `this` parameter'.

        // This is not the complete set of editor methods. Most of the
        // methods defined on the Doc type are also injected into
        // CodeMirror.prototype, for backwards compatibility and
        // convenience.

        function addEditorMethods(CodeMirror) {
          var optionHandlers = CodeMirror.optionHandlers

          var helpers = (CodeMirror.helpers = {})

          CodeMirror.prototype = {
            constructor: CodeMirror,
            focus: function () {
              window.focus()
              this.display.input.focus()
            },

            setOption: function (option, value) {
              var options = this.options,
                old = options[option]
              if (options[option] == value && option != 'mode') {
                return
              }
              options[option] = value
              if (optionHandlers.hasOwnProperty(option)) {
                operation(this, optionHandlers[option])(this, value, old)
              }
              signal(this, 'optionChange', this, option)
            },

            getOption: function (option) {
              return this.options[option]
            },
            getDoc: function () {
              return this.doc
            },

            addKeyMap: function (map, bottom) {
              this.state.keyMaps[bottom ? 'push' : 'unshift'](getKeyMap(map))
            },
            removeKeyMap: function (map) {
              var maps = this.state.keyMaps
              for (var i = 0; i < maps.length; ++i) {
                if (maps[i] == map || maps[i].name == map) {
                  maps.splice(i, 1)
                  return true
                }
              }
            },

            addOverlay: methodOp(function (spec, options) {
              var mode = spec.token
                ? spec
                : CodeMirror.getMode(this.options, spec)
              if (mode.startState) {
                throw new Error('Overlays may not be stateful.')
              }
              insertSorted(
                this.state.overlays,
                {
                  mode: mode,
                  modeSpec: spec,
                  opaque: options && options.opaque,
                  priority: (options && options.priority) || 0
                },
                function (overlay) {
                  return overlay.priority
                }
              )
              this.state.modeGen++
              regChange(this)
            }),
            removeOverlay: methodOp(function (spec) {
              var overlays = this.state.overlays
              for (var i = 0; i < overlays.length; ++i) {
                var cur = overlays[i].modeSpec
                if (
                  cur == spec ||
                  (typeof spec == 'string' && cur.name == spec)
                ) {
                  overlays.splice(i, 1)
                  this.state.modeGen++
                  regChange(this)
                  return
                }
              }
            }),

            indentLine: methodOp(function (n, dir, aggressive) {
              if (typeof dir != 'string' && typeof dir != 'number') {
                if (dir == null) {
                  dir = this.options.smartIndent ? 'smart' : 'prev'
                } else {
                  dir = dir ? 'add' : 'subtract'
                }
              }
              if (isLine(this.doc, n)) {
                indentLine(this, n, dir, aggressive)
              }
            }),
            indentSelection: methodOp(function (how) {
              var ranges = this.doc.sel.ranges,
                end = -1
              for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i]
                if (!range.empty()) {
                  var from = range.from(),
                    to = range.to()
                  var start = Math.max(end, from.line)
                  end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1
                  for (var j = start; j < end; ++j) {
                    indentLine(this, j, how)
                  }
                  var newRanges = this.doc.sel.ranges
                  if (
                    from.ch == 0 &&
                    ranges.length == newRanges.length &&
                    newRanges[i].from().ch > 0
                  ) {
                    replaceOneSelection(
                      this.doc,
                      i,
                      new Range(from, newRanges[i].to()),
                      sel_dontScroll
                    )
                  }
                } else if (range.head.line > end) {
                  indentLine(this, range.head.line, how, true)
                  end = range.head.line
                  if (i == this.doc.sel.primIndex) {
                    ensureCursorVisible(this)
                  }
                }
              }
            }),

            // Fetch the parser token for a given character. Useful for hacks
            // that want to inspect the mode state (say, for completion).
            getTokenAt: function (pos, precise) {
              return takeToken(this, pos, precise)
            },

            getLineTokens: function (line, precise) {
              return takeToken(this, Pos(line), precise, true)
            },

            getTokenTypeAt: function (pos) {
              pos = clipPos(this.doc, pos)
              var styles = getLineStyles(this, getLine(this.doc, pos.line))
              var before = 0,
                after = (styles.length - 1) / 2,
                ch = pos.ch
              var type
              if (ch == 0) {
                type = styles[2]
              } else {
                for (;;) {
                  var mid = (before + after) >> 1
                  if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                    after = mid
                  } else if (styles[mid * 2 + 1] < ch) {
                    before = mid + 1
                  } else {
                    type = styles[mid * 2 + 2]
                    break
                  }
                }
              }
              var cut = type ? type.indexOf('overlay ') : -1
              return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
            },

            getModeAt: function (pos) {
              var mode = this.doc.mode
              if (!mode.innerMode) {
                return mode
              }
              return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
            },

            getHelper: function (pos, type) {
              return this.getHelpers(pos, type)[0]
            },

            getHelpers: function (pos, type) {
              var found = []
              if (!helpers.hasOwnProperty(type)) {
                return found
              }
              var help = helpers[type],
                mode = this.getModeAt(pos)
              if (typeof mode[type] == 'string') {
                if (help[mode[type]]) {
                  found.push(help[mode[type]])
                }
              } else if (mode[type]) {
                for (var i = 0; i < mode[type].length; i++) {
                  var val = help[mode[type][i]]
                  if (val) {
                    found.push(val)
                  }
                }
              } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType])
              } else if (help[mode.name]) {
                found.push(help[mode.name])
              }
              for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                var cur = help._global[i$1]
                if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                  found.push(cur.val)
                }
              }
              return found
            },

            getStateAfter: function (line, precise) {
              var doc = this.doc
              line = clipLine(
                doc,
                line == null ? doc.first + doc.size - 1 : line
              )
              return getContextBefore(this, line + 1, precise).state
            },

            cursorCoords: function (start, mode) {
              var pos,
                range = this.doc.sel.primary()
              if (start == null) {
                pos = range.head
              } else if (typeof start == 'object') {
                pos = clipPos(this.doc, start)
              } else {
                pos = start ? range.from() : range.to()
              }
              return cursorCoords(this, pos, mode || 'page')
            },

            charCoords: function (pos, mode) {
              return charCoords(this, clipPos(this.doc, pos), mode || 'page')
            },

            coordsChar: function (coords, mode) {
              coords = fromCoordSystem(this, coords, mode || 'page')
              return coordsChar(this, coords.left, coords.top)
            },

            lineAtHeight: function (height, mode) {
              height = fromCoordSystem(
                this,
                { top: height, left: 0 },
                mode || 'page'
              ).top
              return lineAtHeight(this.doc, height + this.display.viewOffset)
            },
            heightAtLine: function (line, mode, includeWidgets) {
              var end = false,
                lineObj
              if (typeof line == 'number') {
                var last = this.doc.first + this.doc.size - 1
                if (line < this.doc.first) {
                  line = this.doc.first
                } else if (line > last) {
                  line = last
                  end = true
                }
                lineObj = getLine(this.doc, line)
              } else {
                lineObj = line
              }
              return (
                intoCoordSystem(
                  this,
                  lineObj,
                  { top: 0, left: 0 },
                  mode || 'page',
                  includeWidgets || end
                ).top + (end ? this.doc.height - heightAtLine(lineObj) : 0)
              )
            },

            defaultTextHeight: function () {
              return textHeight(this.display)
            },
            defaultCharWidth: function () {
              return charWidth(this.display)
            },

            getViewport: function () {
              return { from: this.display.viewFrom, to: this.display.viewTo }
            },

            addWidget: function (pos, node, scroll, vert, horiz) {
              var display = this.display
              pos = cursorCoords(this, clipPos(this.doc, pos))
              var top = pos.bottom,
                left = pos.left
              node.style.position = 'absolute'
              node.setAttribute('cm-ignore-events', 'true')
              this.display.input.setUneditable(node)
              display.sizer.appendChild(node)
              if (vert == 'over') {
                top = pos.top
              } else if (vert == 'above' || vert == 'near') {
                var vspace = Math.max(
                    display.wrapper.clientHeight,
                    this.doc.height
                  ),
                  hspace = Math.max(
                    display.sizer.clientWidth,
                    display.lineSpace.clientWidth
                  )
                // Default to positioning above (if specified and possible); otherwise default to positioning below
                if (
                  (vert == 'above' ||
                    pos.bottom + node.offsetHeight > vspace) &&
                  pos.top > node.offsetHeight
                ) {
                  top = pos.top - node.offsetHeight
                } else if (pos.bottom + node.offsetHeight <= vspace) {
                  top = pos.bottom
                }
                if (left + node.offsetWidth > hspace) {
                  left = hspace - node.offsetWidth
                }
              }
              node.style.top = top + 'px'
              node.style.left = node.style.right = ''
              if (horiz == 'right') {
                left = display.sizer.clientWidth - node.offsetWidth
                node.style.right = '0px'
              } else {
                if (horiz == 'left') {
                  left = 0
                } else if (horiz == 'middle') {
                  left = (display.sizer.clientWidth - node.offsetWidth) / 2
                }
                node.style.left = left + 'px'
              }
              if (scroll) {
                scrollIntoView(this, {
                  left: left,
                  top: top,
                  right: left + node.offsetWidth,
                  bottom: top + node.offsetHeight
                })
              }
            },

            triggerOnKeyDown: methodOp(onKeyDown),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),

            execCommand: function (cmd) {
              if (commands.hasOwnProperty(cmd)) {
                return commands[cmd].call(null, this)
              }
            },

            triggerElectric: methodOp(function (text) {
              triggerElectric(this, text)
            }),

            findPosH: function (from, amount, unit, visually) {
              var dir = 1
              if (amount < 0) {
                dir = -1
                amount = -amount
              }
              var cur = clipPos(this.doc, from)
              for (var i = 0; i < amount; ++i) {
                cur = findPosH(this.doc, cur, dir, unit, visually)
                if (cur.hitSide) {
                  break
                }
              }
              return cur
            },

            moveH: methodOp(function (dir, unit) {
              var this$1 = this

              this.extendSelectionsBy(function (range) {
                if (
                  this$1.display.shift ||
                  this$1.doc.extend ||
                  range.empty()
                ) {
                  return findPosH(
                    this$1.doc,
                    range.head,
                    dir,
                    unit,
                    this$1.options.rtlMoveVisually
                  )
                } else {
                  return dir < 0 ? range.from() : range.to()
                }
              }, sel_move)
            }),

            deleteH: methodOp(function (dir, unit) {
              var sel = this.doc.sel,
                doc = this.doc
              if (sel.somethingSelected()) {
                doc.replaceSelection('', null, '+delete')
              } else {
                deleteNearSelection(this, function (range) {
                  var other = findPosH(doc, range.head, dir, unit, false)
                  return dir < 0
                    ? { from: other, to: range.head }
                    : { from: range.head, to: other }
                })
              }
            }),

            findPosV: function (from, amount, unit, goalColumn) {
              var dir = 1,
                x = goalColumn
              if (amount < 0) {
                dir = -1
                amount = -amount
              }
              var cur = clipPos(this.doc, from)
              for (var i = 0; i < amount; ++i) {
                var coords = cursorCoords(this, cur, 'div')
                if (x == null) {
                  x = coords.left
                } else {
                  coords.left = x
                }
                cur = findPosV(this, coords, dir, unit)
                if (cur.hitSide) {
                  break
                }
              }
              return cur
            },

            moveV: methodOp(function (dir, unit) {
              var this$1 = this

              var doc = this.doc,
                goals = []
              var collapse =
                !this.display.shift &&
                !doc.extend &&
                doc.sel.somethingSelected()
              doc.extendSelectionsBy(function (range) {
                if (collapse) {
                  return dir < 0 ? range.from() : range.to()
                }
                var headPos = cursorCoords(this$1, range.head, 'div')
                if (range.goalColumn != null) {
                  headPos.left = range.goalColumn
                }
                goals.push(headPos.left)
                var pos = findPosV(this$1, headPos, dir, unit)
                if (unit == 'page' && range == doc.sel.primary()) {
                  addToScrollTop(
                    this$1,
                    charCoords(this$1, pos, 'div').top - headPos.top
                  )
                }
                return pos
              }, sel_move)
              if (goals.length) {
                for (var i = 0; i < doc.sel.ranges.length; i++) {
                  doc.sel.ranges[i].goalColumn = goals[i]
                }
              }
            }),

            // Find the word at the given position (as returned by coordsChar).
            findWordAt: function (pos) {
              var doc = this.doc,
                line = getLine(doc, pos.line).text
              var start = pos.ch,
                end = pos.ch
              if (line) {
                var helper = this.getHelper(pos, 'wordChars')
                if ((pos.sticky == 'before' || end == line.length) && start) {
                  --start
                } else {
                  ++end
                }
                var startChar = line.charAt(start)
                var check = isWordChar(startChar, helper)
                  ? function (ch) {
                      return isWordChar(ch, helper)
                    }
                  : /\s/.test(startChar)
                  ? function (ch) {
                      return /\s/.test(ch)
                    }
                  : function (ch) {
                      return !/\s/.test(ch) && !isWordChar(ch)
                    }
                while (start > 0 && check(line.charAt(start - 1))) {
                  --start
                }
                while (end < line.length && check(line.charAt(end))) {
                  ++end
                }
              }
              return new Range(Pos(pos.line, start), Pos(pos.line, end))
            },

            toggleOverwrite: function (value) {
              if (value != null && value == this.state.overwrite) {
                return
              }
              if ((this.state.overwrite = !this.state.overwrite)) {
                addClass(this.display.cursorDiv, 'CodeMirror-overwrite')
              } else {
                rmClass(this.display.cursorDiv, 'CodeMirror-overwrite')
              }

              signal(this, 'overwriteToggle', this, this.state.overwrite)
            },
            hasFocus: function () {
              return this.display.input.getField() == activeElt()
            },
            isReadOnly: function () {
              return !!(this.options.readOnly || this.doc.cantEdit)
            },

            scrollTo: methodOp(function (x, y) {
              scrollToCoords(this, x, y)
            }),
            getScrollInfo: function () {
              var scroller = this.display.scroller
              return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height:
                  scroller.scrollHeight -
                  scrollGap(this) -
                  this.display.barHeight,
                width:
                  scroller.scrollWidth -
                  scrollGap(this) -
                  this.display.barWidth,
                clientHeight: displayHeight(this),
                clientWidth: displayWidth(this)
              }
            },

            scrollIntoView: methodOp(function (range, margin) {
              if (range == null) {
                range = { from: this.doc.sel.primary().head, to: null }
                if (margin == null) {
                  margin = this.options.cursorScrollMargin
                }
              } else if (typeof range == 'number') {
                range = { from: Pos(range, 0), to: null }
              } else if (range.from == null) {
                range = { from: range, to: null }
              }
              if (!range.to) {
                range.to = range.from
              }
              range.margin = margin || 0

              if (range.from.line != null) {
                scrollToRange(this, range)
              } else {
                scrollToCoordsRange(this, range.from, range.to, range.margin)
              }
            }),

            setSize: methodOp(function (width, height) {
              var this$1 = this

              var interpret = function (val) {
                return typeof val == 'number' || /^\d+$/.test(String(val))
                  ? val + 'px'
                  : val
              }
              if (width != null) {
                this.display.wrapper.style.width = interpret(width)
              }
              if (height != null) {
                this.display.wrapper.style.height = interpret(height)
              }
              if (this.options.lineWrapping) {
                clearLineMeasurementCache(this)
              }
              var lineNo = this.display.viewFrom
              this.doc.iter(lineNo, this.display.viewTo, function (line) {
                if (line.widgets) {
                  for (var i = 0; i < line.widgets.length; i++) {
                    if (line.widgets[i].noHScroll) {
                      regLineChange(this$1, lineNo, 'widget')
                      break
                    }
                  }
                }
                ++lineNo
              })
              this.curOp.forceUpdate = true
              signal(this, 'refresh', this)
            }),

            operation: function (f) {
              return runInOp(this, f)
            },
            startOperation: function () {
              return startOperation(this)
            },
            endOperation: function () {
              return endOperation(this)
            },

            refresh: methodOp(function () {
              var oldHeight = this.display.cachedTextHeight
              regChange(this)
              this.curOp.forceUpdate = true
              clearCaches(this)
              scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop)
              updateGutterSpace(this.display)
              if (
                oldHeight == null ||
                Math.abs(oldHeight - textHeight(this.display)) > 0.5 ||
                this.options.lineWrapping
              ) {
                estimateLineHeights(this)
              }
              signal(this, 'refresh', this)
            }),

            swapDoc: methodOp(function (doc) {
              var old = this.doc
              old.cm = null
              // Cancel the current text selection if any (#5821)
              if (this.state.selectingText) {
                this.state.selectingText()
              }
              attachDoc(this, doc)
              clearCaches(this)
              this.display.input.reset()
              scrollToCoords(this, doc.scrollLeft, doc.scrollTop)
              this.curOp.forceScroll = true
              signalLater(this, 'swapDoc', this, old)
              return old
            }),

            phrase: function (phraseText) {
              var phrases = this.options.phrases
              return phrases &&
                Object.prototype.hasOwnProperty.call(phrases, phraseText)
                ? phrases[phraseText]
                : phraseText
            },

            getInputField: function () {
              return this.display.input.getField()
            },
            getWrapperElement: function () {
              return this.display.wrapper
            },
            getScrollerElement: function () {
              return this.display.scroller
            },
            getGutterElement: function () {
              return this.display.gutters
            }
          }
          eventMixin(CodeMirror)

          CodeMirror.registerHelper = function (type, name, value) {
            if (!helpers.hasOwnProperty(type)) {
              helpers[type] = CodeMirror[type] = { _global: [] }
            }
            helpers[type][name] = value
          }
          CodeMirror.registerGlobalHelper = function (
            type,
            name,
            predicate,
            value
          ) {
            CodeMirror.registerHelper(type, name, value)
            helpers[type]._global.push({ pred: predicate, val: value })
          }
        }

        // Used for horizontal relative motion. Dir is -1 or 1 (left or
        // right), unit can be "codepoint", "char", "column" (like char, but
        // doesn't cross line boundaries), "word" (across next word), or
        // "group" (to the start of next group of word or
        // non-word-non-whitespace chars). The visually param controls
        // whether, in right-to-left text, direction 1 means to move towards
        // the next index in the string, or towards the character to the right
        // of the current position. The resulting position will have a
        // hitSide=true property if it reached the end of the document.
        function findPosH(doc, pos, dir, unit, visually) {
          var oldPos = pos
          var origDir = dir
          var lineObj = getLine(doc, pos.line)
          var lineDir = visually && doc.direction == 'rtl' ? -dir : dir
          function findNextLine() {
            var l = pos.line + lineDir
            if (l < doc.first || l >= doc.first + doc.size) {
              return false
            }
            pos = new Pos(l, pos.ch, pos.sticky)
            return (lineObj = getLine(doc, l))
          }
          function moveOnce(boundToLine) {
            var next
            if (unit == 'codepoint') {
              var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1))
              if (isNaN(ch)) {
                next = null
              } else {
                var astral =
                  dir > 0
                    ? ch >= 0xd800 && ch < 0xdc00
                    : ch >= 0xdc00 && ch < 0xdfff
                next = new Pos(
                  pos.line,
                  Math.max(
                    0,
                    Math.min(
                      lineObj.text.length,
                      pos.ch + dir * (astral ? 2 : 1)
                    )
                  ),
                  -dir
                )
              }
            } else if (visually) {
              next = moveVisually(doc.cm, lineObj, pos, dir)
            } else {
              next = moveLogically(lineObj, pos, dir)
            }
            if (next == null) {
              if (!boundToLine && findNextLine()) {
                pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir)
              } else {
                return false
              }
            } else {
              pos = next
            }
            return true
          }

          if (unit == 'char' || unit == 'codepoint') {
            moveOnce()
          } else if (unit == 'column') {
            moveOnce(true)
          } else if (unit == 'word' || unit == 'group') {
            var sawType = null,
              group = unit == 'group'
            var helper = doc.cm && doc.cm.getHelper(pos, 'wordChars')
            for (var first = true; ; first = false) {
              if (dir < 0 && !moveOnce(!first)) {
                break
              }
              var cur = lineObj.text.charAt(pos.ch) || '\n'
              var type = isWordChar(cur, helper)
                ? 'w'
                : group && cur == '\n'
                ? 'n'
                : !group || /\s/.test(cur)
                ? null
                : 'p'
              if (group && !first && !type) {
                type = 's'
              }
              if (sawType && sawType != type) {
                if (dir < 0) {
                  dir = 1
                  moveOnce()
                  pos.sticky = 'after'
                }
                break
              }

              if (type) {
                sawType = type
              }
              if (dir > 0 && !moveOnce(!first)) {
                break
              }
            }
          }
          var result = skipAtomic(doc, pos, oldPos, origDir, true)
          if (equalCursorPos(oldPos, result)) {
            result.hitSide = true
          }
          return result
        }

        // For relative vertical movement. Dir may be -1 or 1. Unit can be
        // "page" or "line". The resulting position will have a hitSide=true
        // property if it reached the end of the document.
        function findPosV(cm, pos, dir, unit) {
          var doc = cm.doc,
            x = pos.left,
            y
          if (unit == 'page') {
            var pageSize = Math.min(
              cm.display.wrapper.clientHeight,
              window.innerHeight || document.documentElement.clientHeight
            )
            var moveAmount = Math.max(
              pageSize - 0.5 * textHeight(cm.display),
              3
            )
            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount
          } else if (unit == 'line') {
            y = dir > 0 ? pos.bottom + 3 : pos.top - 3
          }
          var target
          for (;;) {
            target = coordsChar(cm, x, y)
            if (!target.outside) {
              break
            }
            if (dir < 0 ? y <= 0 : y >= doc.height) {
              target.hitSide = true
              break
            }
            y += dir * 5
          }
          return target
        }

        // CONTENTEDITABLE INPUT STYLE

        var ContentEditableInput = function (cm) {
          this.cm = cm
          this.lastAnchorNode =
            this.lastAnchorOffset =
            this.lastFocusNode =
            this.lastFocusOffset =
              null
          this.polling = new Delayed()
          this.composing = null
          this.gracePeriod = false
          this.readDOMTimeout = null
        }

        ContentEditableInput.prototype.init = function (display) {
          var this$1 = this

          var input = this,
            cm = input.cm
          var div = (input.div = display.lineDiv)
          div.contentEditable = true
          disableBrowserMagic(
            div,
            cm.options.spellcheck,
            cm.options.autocorrect,
            cm.options.autocapitalize
          )

          function belongsToInput(e) {
            for (var t = e.target; t; t = t.parentNode) {
              if (t == div) {
                return true
              }
              if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
                break
              }
            }
            return false
          }

          on(div, 'paste', function (e) {
            if (
              !belongsToInput(e) ||
              signalDOMEvent(cm, e) ||
              handlePaste(e, cm)
            ) {
              return
            }
            // IE doesn't fire input events, so we schedule a read for the pasted content in this way
            if (ie_version <= 11) {
              setTimeout(
                operation(cm, function () {
                  return this$1.updateFromDOM()
                }),
                20
              )
            }
          })

          on(div, 'compositionstart', function (e) {
            this$1.composing = { data: e.data, done: false }
          })
          on(div, 'compositionupdate', function (e) {
            if (!this$1.composing) {
              this$1.composing = { data: e.data, done: false }
            }
          })
          on(div, 'compositionend', function (e) {
            if (this$1.composing) {
              if (e.data != this$1.composing.data) {
                this$1.readFromDOMSoon()
              }
              this$1.composing.done = true
            }
          })

          on(div, 'touchstart', function () {
            return input.forceCompositionEnd()
          })

          on(div, 'input', function () {
            if (!this$1.composing) {
              this$1.readFromDOMSoon()
            }
          })

          function onCopyCut(e) {
            if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
              return
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() })
              if (e.type == 'cut') {
                cm.replaceSelection('', null, 'cut')
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return
            } else {
              var ranges = copyableRanges(cm)
              setLastCopied({ lineWise: true, text: ranges.text })
              if (e.type == 'cut') {
                cm.operation(function () {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll)
                  cm.replaceSelection('', null, 'cut')
                })
              }
            }
            if (e.clipboardData) {
              e.clipboardData.clearData()
              var content = lastCopied.text.join('\n')
              // iOS exposes the clipboard API, but seems to discard content inserted into it
              e.clipboardData.setData('Text', content)
              if (e.clipboardData.getData('Text') == content) {
                e.preventDefault()
                return
              }
            }
            // Old-fashioned briefly-focus-a-textarea hack
            var kludge = hiddenTextarea(),
              te = kludge.firstChild
            cm.display.lineSpace.insertBefore(
              kludge,
              cm.display.lineSpace.firstChild
            )
            te.value = lastCopied.text.join('\n')
            var hadFocus = activeElt()
            selectInput(te)
            setTimeout(function () {
              cm.display.lineSpace.removeChild(kludge)
              hadFocus.focus()
              if (hadFocus == div) {
                input.showPrimarySelection()
              }
            }, 50)
          }
          on(div, 'copy', onCopyCut)
          on(div, 'cut', onCopyCut)
        }

        ContentEditableInput.prototype.screenReaderLabelChanged = function (
          label
        ) {
          // Label for screenreaders, accessibility
          if (label) {
            this.div.setAttribute('aria-label', label)
          } else {
            this.div.removeAttribute('aria-label')
          }
        }

        ContentEditableInput.prototype.prepareSelection = function () {
          var result = prepareSelection(this.cm, false)
          result.focus = activeElt() == this.div
          return result
        }

        ContentEditableInput.prototype.showSelection = function (
          info,
          takeFocus
        ) {
          if (!info || !this.cm.display.view.length) {
            return
          }
          if (info.focus || takeFocus) {
            this.showPrimarySelection()
          }
          this.showMultipleSelections(info)
        }

        ContentEditableInput.prototype.getSelection = function () {
          return this.cm.display.wrapper.ownerDocument.getSelection()
        }

        ContentEditableInput.prototype.showPrimarySelection = function () {
          var sel = this.getSelection(),
            cm = this.cm,
            prim = cm.doc.sel.primary()
          var from = prim.from(),
            to = prim.to()

          if (
            cm.display.viewTo == cm.display.viewFrom ||
            from.line >= cm.display.viewTo ||
            to.line < cm.display.viewFrom
          ) {
            sel.removeAllRanges()
            return
          }

          var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)
          var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset)
          if (
            curAnchor &&
            !curAnchor.bad &&
            curFocus &&
            !curFocus.bad &&
            cmp(minPos(curAnchor, curFocus), from) == 0 &&
            cmp(maxPos(curAnchor, curFocus), to) == 0
          ) {
            return
          }

          var view = cm.display.view
          var start = (from.line >= cm.display.viewFrom &&
            posToDOM(cm, from)) || { node: view[0].measure.map[2], offset: 0 }
          var end = to.line < cm.display.viewTo && posToDOM(cm, to)
          if (!end) {
            var measure = view[view.length - 1].measure
            var map = measure.maps
              ? measure.maps[measure.maps.length - 1]
              : measure.map
            end = {
              node: map[map.length - 1],
              offset: map[map.length - 2] - map[map.length - 3]
            }
          }

          if (!start || !end) {
            sel.removeAllRanges()
            return
          }

          var old = sel.rangeCount && sel.getRangeAt(0),
            rng
          try {
            rng = range(start.node, start.offset, end.offset, end.node)
          } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
          if (rng) {
            if (!gecko && cm.state.focused) {
              sel.collapse(start.node, start.offset)
              if (!rng.collapsed) {
                sel.removeAllRanges()
                sel.addRange(rng)
              }
            } else {
              sel.removeAllRanges()
              sel.addRange(rng)
            }
            if (old && sel.anchorNode == null) {
              sel.addRange(old)
            } else if (gecko) {
              this.startGracePeriod()
            }
          }
          this.rememberSelection()
        }

        ContentEditableInput.prototype.startGracePeriod = function () {
          var this$1 = this

          clearTimeout(this.gracePeriod)
          this.gracePeriod = setTimeout(function () {
            this$1.gracePeriod = false
            if (this$1.selectionChanged()) {
              this$1.cm.operation(function () {
                return (this$1.cm.curOp.selectionChanged = true)
              })
            }
          }, 20)
        }

        ContentEditableInput.prototype.showMultipleSelections = function (
          info
        ) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
        }

        ContentEditableInput.prototype.rememberSelection = function () {
          var sel = this.getSelection()
          this.lastAnchorNode = sel.anchorNode
          this.lastAnchorOffset = sel.anchorOffset
          this.lastFocusNode = sel.focusNode
          this.lastFocusOffset = sel.focusOffset
        }

        ContentEditableInput.prototype.selectionInEditor = function () {
          var sel = this.getSelection()
          if (!sel.rangeCount) {
            return false
          }
          var node = sel.getRangeAt(0).commonAncestorContainer
          return contains(this.div, node)
        }

        ContentEditableInput.prototype.focus = function () {
          if (this.cm.options.readOnly != 'nocursor') {
            if (!this.selectionInEditor() || activeElt() != this.div) {
              this.showSelection(this.prepareSelection(), true)
            }
            this.div.focus()
          }
        }
        ContentEditableInput.prototype.blur = function () {
          this.div.blur()
        }
        ContentEditableInput.prototype.getField = function () {
          return this.div
        }

        ContentEditableInput.prototype.supportsTouch = function () {
          return true
        }

        ContentEditableInput.prototype.receivedFocus = function () {
          var this$1 = this

          var input = this
          if (this.selectionInEditor()) {
            setTimeout(function () {
              return this$1.pollSelection()
            }, 20)
          } else {
            runInOp(this.cm, function () {
              return (input.cm.curOp.selectionChanged = true)
            })
          }

          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection()
              input.polling.set(input.cm.options.pollInterval, poll)
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll)
        }

        ContentEditableInput.prototype.selectionChanged = function () {
          var sel = this.getSelection()
          return (
            sel.anchorNode != this.lastAnchorNode ||
            sel.anchorOffset != this.lastAnchorOffset ||
            sel.focusNode != this.lastFocusNode ||
            sel.focusOffset != this.lastFocusOffset
          )
        }

        ContentEditableInput.prototype.pollSelection = function () {
          if (
            this.readDOMTimeout != null ||
            this.gracePeriod ||
            !this.selectionChanged()
          ) {
            return
          }
          var sel = this.getSelection(),
            cm = this.cm
          // On Android Chrome (version 56, at least), backspacing into an
          // uneditable block element will put the cursor in that element,
          // and then, because it's not editable, hide the virtual keyboard.
          // Because Android doesn't allow us to actually detect backspace
          // presses in a sane way, this code checks for when that happens
          // and simulates a backspace press in this case.
          if (
            android &&
            chrome &&
            this.cm.display.gutterSpecs.length &&
            isInGutter(sel.anchorNode)
          ) {
            this.cm.triggerOnKeyDown({
              type: 'keydown',
              keyCode: 8,
              preventDefault: Math.abs
            })
            this.blur()
            this.focus()
            return
          }
          if (this.composing) {
            return
          }
          this.rememberSelection()
          var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)
          var head = domToPos(cm, sel.focusNode, sel.focusOffset)
          if (anchor && head) {
            runInOp(cm, function () {
              setSelection(
                cm.doc,
                simpleSelection(anchor, head),
                sel_dontScroll
              )
              if (anchor.bad || head.bad) {
                cm.curOp.selectionChanged = true
              }
            })
          }
        }

        ContentEditableInput.prototype.pollContent = function () {
          if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout)
            this.readDOMTimeout = null
          }

          var cm = this.cm,
            display = cm.display,
            sel = cm.doc.sel.primary()
          var from = sel.from(),
            to = sel.to()
          if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length)
          }
          if (
            to.ch == getLine(cm.doc, to.line).text.length &&
            to.line < cm.lastLine()
          ) {
            to = Pos(to.line + 1, 0)
          }
          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false
          }

          var fromIndex, fromLine, fromNode
          if (
            from.line == display.viewFrom ||
            (fromIndex = findViewIndex(cm, from.line)) == 0
          ) {
            fromLine = lineNo(display.view[0].line)
            fromNode = display.view[0].node
          } else {
            fromLine = lineNo(display.view[fromIndex].line)
            fromNode = display.view[fromIndex - 1].node.nextSibling
          }
          var toIndex = findViewIndex(cm, to.line)
          var toLine, toNode
          if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1
            toNode = display.lineDiv.lastChild
          } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1
            toNode = display.view[toIndex + 1].node.previousSibling
          }

          if (!fromNode) {
            return false
          }
          var newText = cm.doc.splitLines(
            domTextBetween(cm, fromNode, toNode, fromLine, toLine)
          )
          var oldText = getBetween(
            cm.doc,
            Pos(fromLine, 0),
            Pos(toLine, getLine(cm.doc, toLine).text.length)
          )
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop()
              oldText.pop()
              toLine--
            } else if (newText[0] == oldText[0]) {
              newText.shift()
              oldText.shift()
              fromLine++
            } else {
              break
            }
          }

          var cutFront = 0,
            cutEnd = 0
          var newTop = newText[0],
            oldTop = oldText[0],
            maxCutFront = Math.min(newTop.length, oldTop.length)
          while (
            cutFront < maxCutFront &&
            newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)
          ) {
            ++cutFront
          }
          var newBot = lst(newText),
            oldBot = lst(oldText)
          var maxCutEnd = Math.min(
            newBot.length - (newText.length == 1 ? cutFront : 0),
            oldBot.length - (oldText.length == 1 ? cutFront : 0)
          )
          while (
            cutEnd < maxCutEnd &&
            newBot.charCodeAt(newBot.length - cutEnd - 1) ==
              oldBot.charCodeAt(oldBot.length - cutEnd - 1)
          ) {
            ++cutEnd
          }
          // Try to move start of change to start of selection if ambiguous
          if (
            newText.length == 1 &&
            oldText.length == 1 &&
            fromLine == from.line
          ) {
            while (
              cutFront &&
              cutFront > from.ch &&
              newBot.charCodeAt(newBot.length - cutEnd - 1) ==
                oldBot.charCodeAt(oldBot.length - cutEnd - 1)
            ) {
              cutFront--
              cutEnd++
            }
          }

          newText[newText.length - 1] = newBot
            .slice(0, newBot.length - cutEnd)
            .replace(/^\u200b+/, '')
          newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, '')

          var chFrom = Pos(fromLine, cutFront)
          var chTo = Pos(
            toLine,
            oldText.length ? lst(oldText).length - cutEnd : 0
          )
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, '+input')
            return true
          }
        }

        ContentEditableInput.prototype.ensurePolled = function () {
          this.forceCompositionEnd()
        }
        ContentEditableInput.prototype.reset = function () {
          this.forceCompositionEnd()
        }
        ContentEditableInput.prototype.forceCompositionEnd = function () {
          if (!this.composing) {
            return
          }
          clearTimeout(this.readDOMTimeout)
          this.composing = null
          this.updateFromDOM()
          this.div.blur()
          this.div.focus()
        }
        ContentEditableInput.prototype.readFromDOMSoon = function () {
          var this$1 = this

          if (this.readDOMTimeout != null) {
            return
          }
          this.readDOMTimeout = setTimeout(function () {
            this$1.readDOMTimeout = null
            if (this$1.composing) {
              if (this$1.composing.done) {
                this$1.composing = null
              } else {
                return
              }
            }
            this$1.updateFromDOM()
          }, 80)
        }

        ContentEditableInput.prototype.updateFromDOM = function () {
          var this$1 = this

          if (this.cm.isReadOnly() || !this.pollContent()) {
            runInOp(this.cm, function () {
              return regChange(this$1.cm)
            })
          }
        }

        ContentEditableInput.prototype.setUneditable = function (node) {
          node.contentEditable = 'false'
        }

        ContentEditableInput.prototype.onKeyPress = function (e) {
          if (e.charCode == 0 || this.composing) {
            return
          }
          e.preventDefault()
          if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(
              this.cm,
              String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode),
              0
            )
          }
        }

        ContentEditableInput.prototype.readOnlyChanged = function (val) {
          this.div.contentEditable = String(val != 'nocursor')
        }

        ContentEditableInput.prototype.onContextMenu = function () {}
        ContentEditableInput.prototype.resetPosition = function () {}

        ContentEditableInput.prototype.needsContentAttribute = true

        function posToDOM(cm, pos) {
          var view = findViewForLine(cm, pos.line)
          if (!view || view.hidden) {
            return null
          }
          var line = getLine(cm.doc, pos.line)
          var info = mapFromLineView(view, line, pos.line)

          var order = getOrder(line, cm.doc.direction),
            side = 'left'
          if (order) {
            var partPos = getBidiPartAt(order, pos.ch)
            side = partPos % 2 ? 'right' : 'left'
          }
          var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)
          result.offset = result.collapse == 'right' ? result.end : result.start
          return result
        }

        function isInGutter(node) {
          for (var scan = node; scan; scan = scan.parentNode) {
            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
              return true
            }
          }
          return false
        }

        function badPos(pos, bad) {
          if (bad) {
            pos.bad = true
          }
          return pos
        }

        function domTextBetween(cm, from, to, fromLine, toLine) {
          var text = '',
            closing = false,
            lineSep = cm.doc.lineSeparator(),
            extraLinebreak = false
          function recognizeMarker(id) {
            return function (marker) {
              return marker.id == id
            }
          }
          function close() {
            if (closing) {
              text += lineSep
              if (extraLinebreak) {
                text += lineSep
              }
              closing = extraLinebreak = false
            }
          }
          function addText(str) {
            if (str) {
              close()
              text += str
            }
          }
          function walk(node) {
            if (node.nodeType == 1) {
              var cmText = node.getAttribute('cm-text')
              if (cmText) {
                addText(cmText)
                return
              }
              var markerID = node.getAttribute('cm-marker'),
                range
              if (markerID) {
                var found = cm.findMarks(
                  Pos(fromLine, 0),
                  Pos(toLine + 1, 0),
                  recognizeMarker(+markerID)
                )
                if (found.length && (range = found[0].find(0))) {
                  addText(
                    getBetween(cm.doc, range.from, range.to).join(lineSep)
                  )
                }
                return
              }
              if (node.getAttribute('contenteditable') == 'false') {
                return
              }
              var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName)
              if (
                !/^br$/i.test(node.nodeName) &&
                node.textContent.length == 0
              ) {
                return
              }

              if (isBlock) {
                close()
              }
              for (var i = 0; i < node.childNodes.length; i++) {
                walk(node.childNodes[i])
              }

              if (/^(pre|p)$/i.test(node.nodeName)) {
                extraLinebreak = true
              }
              if (isBlock) {
                closing = true
              }
            } else if (node.nodeType == 3) {
              addText(
                node.nodeValue.replace(/\u200b/g, '').replace(/\u00a0/g, ' ')
              )
            }
          }
          for (;;) {
            walk(from)
            if (from == to) {
              break
            }
            from = from.nextSibling
            extraLinebreak = false
          }
          return text
        }

        function domToPos(cm, node, offset) {
          var lineNode
          if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset]
            if (!lineNode) {
              return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true)
            }
            node = null
            offset = 0
          } else {
            for (lineNode = node; ; lineNode = lineNode.parentNode) {
              if (!lineNode || lineNode == cm.display.lineDiv) {
                return null
              }
              if (
                lineNode.parentNode &&
                lineNode.parentNode == cm.display.lineDiv
              ) {
                break
              }
            }
          }
          for (var i = 0; i < cm.display.view.length; i++) {
            var lineView = cm.display.view[i]
            if (lineView.node == lineNode) {
              return locateNodeInLineView(lineView, node, offset)
            }
          }
        }

        function locateNodeInLineView(lineView, node, offset) {
          var wrapper = lineView.text.firstChild,
            bad = false
          if (!node || !contains(wrapper, node)) {
            return badPos(Pos(lineNo(lineView.line), 0), true)
          }
          if (node == wrapper) {
            bad = true
            node = wrapper.childNodes[offset]
            offset = 0
            if (!node) {
              var line = lineView.rest ? lst(lineView.rest) : lineView.line
              return badPos(Pos(lineNo(line), line.text.length), bad)
            }
          }

          var textNode = node.nodeType == 3 ? node : null,
            topNode = node
          if (
            !textNode &&
            node.childNodes.length == 1 &&
            node.firstChild.nodeType == 3
          ) {
            textNode = node.firstChild
            if (offset) {
              offset = textNode.nodeValue.length
            }
          }
          while (topNode.parentNode != wrapper) {
            topNode = topNode.parentNode
          }
          var measure = lineView.measure,
            maps = measure.maps

          function find(textNode, topNode, offset) {
            for (var i = -1; i < (maps ? maps.length : 0); i++) {
              var map = i < 0 ? measure.map : maps[i]
              for (var j = 0; j < map.length; j += 3) {
                var curNode = map[j + 2]
                if (curNode == textNode || curNode == topNode) {
                  var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])
                  var ch = map[j] + offset
                  if (offset < 0 || curNode != textNode) {
                    ch = map[j + (offset ? 1 : 0)]
                  }
                  return Pos(line, ch)
                }
              }
            }
          }
          var found = find(textNode, topNode, offset)
          if (found) {
            return badPos(found, bad)
          }

          // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
          for (
            var after = topNode.nextSibling,
              dist = textNode ? textNode.nodeValue.length - offset : 0;
            after;
            after = after.nextSibling
          ) {
            found = find(after, after.firstChild, 0)
            if (found) {
              return badPos(Pos(found.line, found.ch - dist), bad)
            } else {
              dist += after.textContent.length
            }
          }
          for (
            var before = topNode.previousSibling, dist$1 = offset;
            before;
            before = before.previousSibling
          ) {
            found = find(before, before.firstChild, -1)
            if (found) {
              return badPos(Pos(found.line, found.ch + dist$1), bad)
            } else {
              dist$1 += before.textContent.length
            }
          }
        }

        // TEXTAREA INPUT STYLE

        var TextareaInput = function (cm) {
          this.cm = cm
          // See input.poll and input.reset
          this.prevInput = ''

          // Flag that indicates whether we expect input to appear real soon
          // now (after some event like 'keypress' or 'input') and are
          // polling intensively.
          this.pollingFast = false
          // Self-resetting timeout for the poller
          this.polling = new Delayed()
          // Used to work around IE issue with selection being forgotten when focus moves away from textarea
          this.hasSelection = false
          this.composing = null
        }

        TextareaInput.prototype.init = function (display) {
          var this$1 = this

          var input = this,
            cm = this.cm
          this.createField(display)
          var te = this.textarea

          display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild)

          // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
          if (ios) {
            te.style.width = '0px'
          }

          on(te, 'input', function () {
            if (ie && ie_version >= 9 && this$1.hasSelection) {
              this$1.hasSelection = null
            }
            input.poll()
          })

          on(te, 'paste', function (e) {
            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
              return
            }

            cm.state.pasteIncoming = +new Date()
            input.fastPoll()
          })

          function prepareCopyCut(e) {
            if (signalDOMEvent(cm, e)) {
              return
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() })
            } else if (!cm.options.lineWiseCopyCut) {
              return
            } else {
              var ranges = copyableRanges(cm)
              setLastCopied({ lineWise: true, text: ranges.text })
              if (e.type == 'cut') {
                cm.setSelections(ranges.ranges, null, sel_dontScroll)
              } else {
                input.prevInput = ''
                te.value = ranges.text.join('\n')
                selectInput(te)
              }
            }
            if (e.type == 'cut') {
              cm.state.cutIncoming = +new Date()
            }
          }
          on(te, 'cut', prepareCopyCut)
          on(te, 'copy', prepareCopyCut)

          on(display.scroller, 'paste', function (e) {
            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
              return
            }
            if (!te.dispatchEvent) {
              cm.state.pasteIncoming = +new Date()
              input.focus()
              return
            }

            // Pass the `paste` event to the textarea so it's handled by its event listener.
            var event = new Event('paste')
            event.clipboardData = e.clipboardData
            te.dispatchEvent(event)
          })

          // Prevent normal selection in the editor (we handle our own)
          on(display.lineSpace, 'selectstart', function (e) {
            if (!eventInWidget(display, e)) {
              e_preventDefault(e)
            }
          })

          on(te, 'compositionstart', function () {
            var start = cm.getCursor('from')
            if (input.composing) {
              input.composing.range.clear()
            }
            input.composing = {
              start: start,
              range: cm.markText(start, cm.getCursor('to'), {
                className: 'CodeMirror-composing'
              })
            }
          })
          on(te, 'compositionend', function () {
            if (input.composing) {
              input.poll()
              input.composing.range.clear()
              input.composing = null
            }
          })
        }

        TextareaInput.prototype.createField = function (_display) {
          // Wraps and hides input textarea
          this.wrapper = hiddenTextarea()
          // The semihidden textarea that is focused when the editor is
          // focused, and receives input.
          this.textarea = this.wrapper.firstChild
        }

        TextareaInput.prototype.screenReaderLabelChanged = function (label) {
          // Label for screenreaders, accessibility
          if (label) {
            this.textarea.setAttribute('aria-label', label)
          } else {
            this.textarea.removeAttribute('aria-label')
          }
        }

        TextareaInput.prototype.prepareSelection = function () {
          // Redraw the selection and/or cursor
          var cm = this.cm,
            display = cm.display,
            doc = cm.doc
          var result = prepareSelection(cm)

          // Move the hidden textarea near the cursor to prevent scrolling artifacts
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, 'div')
            var wrapOff = display.wrapper.getBoundingClientRect(),
              lineOff = display.lineDiv.getBoundingClientRect()
            result.teTop = Math.max(
              0,
              Math.min(
                display.wrapper.clientHeight - 10,
                headPos.top + lineOff.top - wrapOff.top
              )
            )
            result.teLeft = Math.max(
              0,
              Math.min(
                display.wrapper.clientWidth - 10,
                headPos.left + lineOff.left - wrapOff.left
              )
            )
          }

          return result
        }

        TextareaInput.prototype.showSelection = function (drawn) {
          var cm = this.cm,
            display = cm.display
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors)
          removeChildrenAndAdd(display.selectionDiv, drawn.selection)
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + 'px'
            this.wrapper.style.left = drawn.teLeft + 'px'
          }
        }

        // Reset the input to correspond to the selection (or to be empty,
        // when not typing and nothing is selected)
        TextareaInput.prototype.reset = function (typing) {
          if (this.contextMenuPending || this.composing) {
            return
          }
          var cm = this.cm
          if (cm.somethingSelected()) {
            this.prevInput = ''
            var content = cm.getSelection()
            this.textarea.value = content
            if (cm.state.focused) {
              selectInput(this.textarea)
            }
            if (ie && ie_version >= 9) {
              this.hasSelection = content
            }
          } else if (!typing) {
            this.prevInput = this.textarea.value = ''
            if (ie && ie_version >= 9) {
              this.hasSelection = null
            }
          }
        }

        TextareaInput.prototype.getField = function () {
          return this.textarea
        }

        TextareaInput.prototype.supportsTouch = function () {
          return false
        }

        TextareaInput.prototype.focus = function () {
          if (
            this.cm.options.readOnly != 'nocursor' &&
            (!mobile || activeElt() != this.textarea)
          ) {
            try {
              this.textarea.focus()
            } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
          }
        }

        TextareaInput.prototype.blur = function () {
          this.textarea.blur()
        }

        TextareaInput.prototype.resetPosition = function () {
          this.wrapper.style.top = this.wrapper.style.left = 0
        }

        TextareaInput.prototype.receivedFocus = function () {
          this.slowPoll()
        }

        // Poll for input changes, using the normal rate of polling. This
        // runs as long as the editor is focused.
        TextareaInput.prototype.slowPoll = function () {
          var this$1 = this

          if (this.pollingFast) {
            return
          }
          this.polling.set(this.cm.options.pollInterval, function () {
            this$1.poll()
            if (this$1.cm.state.focused) {
              this$1.slowPoll()
            }
          })
        }

        // When an event has just come in that is likely to add or change
        // something in the input textarea, we poll faster, to ensure that
        // the change appears on the screen quickly.
        TextareaInput.prototype.fastPoll = function () {
          var missed = false,
            input = this
          input.pollingFast = true
          function p() {
            var changed = input.poll()
            if (!changed && !missed) {
              missed = true
              input.polling.set(60, p)
            } else {
              input.pollingFast = false
              input.slowPoll()
            }
          }
          input.polling.set(20, p)
        }

        // Read input from the textarea, and update the document to match.
        // When something is selected, it is present in the textarea, and
        // selected (unless it is huge, in which case a placeholder is
        // used). When nothing is selected, the cursor sits after previously
        // seen text (can be empty), which is stored in prevInput (we must
        // not reset the textarea when typing, because that breaks IME).
        TextareaInput.prototype.poll = function () {
          var this$1 = this

          var cm = this.cm,
            input = this.textarea,
            prevInput = this.prevInput
          // Since this is called a *lot*, try to bail out as cheaply as
          // possible when it is clear that nothing happened. hasSelection
          // will be the case when there is a lot of text in the textarea,
          // in which case reading its value would be expensive.
          if (
            this.contextMenuPending ||
            !cm.state.focused ||
            (hasSelection(input) && !prevInput && !this.composing) ||
            cm.isReadOnly() ||
            cm.options.disableInput ||
            cm.state.keySeq
          ) {
            return false
          }

          var text = input.value
          // If nothing changed, bail.
          if (text == prevInput && !cm.somethingSelected()) {
            return false
          }
          // Work around nonsensical selection resetting in IE9/10, and
          // inexplicable appearance of private area unicode characters on
          // some key combos in Mac (#2689).
          if (
            (ie && ie_version >= 9 && this.hasSelection === text) ||
            (mac && /[\uf700-\uf7ff]/.test(text))
          ) {
            cm.display.input.reset()
            return false
          }

          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0)
            if (first == 0x200b && !prevInput) {
              prevInput = '\u200b'
            }
            if (first == 0x21da) {
              this.reset()
              return this.cm.execCommand('undo')
            }
          }
          // Find the part of the input that is actually new
          var same = 0,
            l = Math.min(prevInput.length, text.length)
          while (
            same < l &&
            prevInput.charCodeAt(same) == text.charCodeAt(same)
          ) {
            ++same
          }

          runInOp(cm, function () {
            applyTextInput(
              cm,
              text.slice(same),
              prevInput.length - same,
              null,
              this$1.composing ? '*compose' : null
            )

            // Don't leave long text in the textarea, since it makes further polling slow
            if (text.length > 1000 || text.indexOf('\n') > -1) {
              input.value = this$1.prevInput = ''
            } else {
              this$1.prevInput = text
            }

            if (this$1.composing) {
              this$1.composing.range.clear()
              this$1.composing.range = cm.markText(
                this$1.composing.start,
                cm.getCursor('to'),
                { className: 'CodeMirror-composing' }
              )
            }
          })
          return true
        }

        TextareaInput.prototype.ensurePolled = function () {
          if (this.pollingFast && this.poll()) {
            this.pollingFast = false
          }
        }

        TextareaInput.prototype.onKeyPress = function () {
          if (ie && ie_version >= 9) {
            this.hasSelection = null
          }
          this.fastPoll()
        }

        TextareaInput.prototype.onContextMenu = function (e) {
          var input = this,
            cm = input.cm,
            display = cm.display,
            te = input.textarea
          if (input.contextMenuPending) {
            input.contextMenuPending()
          }
          var pos = posFromMouse(cm, e),
            scrollPos = display.scroller.scrollTop
          if (!pos || presto) {
            return
          } // Opera is difficult.

          // Reset the current text selection only if the click is done outside of the selection
          // and 'resetSelectionOnContextMenu' option is true.
          var reset = cm.options.resetSelectionOnContextMenu
          if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(
              cm.doc,
              simpleSelection(pos),
              sel_dontScroll
            )
          }

          var oldCSS = te.style.cssText,
            oldWrapperCSS = input.wrapper.style.cssText
          var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect()
          input.wrapper.style.cssText = 'position: static'
          te.style.cssText =
            'position: absolute; width: 30px; height: 30px;\n      top: ' +
            (e.clientY - wrapperBox.top - 5) +
            'px; left: ' +
            (e.clientX - wrapperBox.left - 5) +
            'px;\n      z-index: 1000; background: ' +
            (ie ? 'rgba(255, 255, 255, .05)' : 'transparent') +
            ';\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);'
          var oldScrollY
          if (webkit) {
            oldScrollY = window.scrollY
          } // Work around Chrome issue (#2712)
          display.input.focus()
          if (webkit) {
            window.scrollTo(null, oldScrollY)
          }
          display.input.reset()
          // Adds "Select all" to context menu in FF
          if (!cm.somethingSelected()) {
            te.value = input.prevInput = ' '
          }
          input.contextMenuPending = rehide
          display.selForContextMenu = cm.doc.sel
          clearTimeout(display.detectingSelectAll)

          // Select-all will be greyed out if there's nothing to select, so
          // this adds a zero-width space so that we can later check whether
          // it got selected.
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected()
              var extval = '\u200b' + (selected ? te.value : '')
              te.value = '\u21da' // Used to catch context-menu undo
              te.value = extval
              input.prevInput = selected ? '' : '\u200b'
              te.selectionStart = 1
              te.selectionEnd = extval.length
              // Re-set this, in case some other handler touched the
              // selection in the meantime.
              display.selForContextMenu = cm.doc.sel
            }
          }
          function rehide() {
            if (input.contextMenuPending != rehide) {
              return
            }
            input.contextMenuPending = false
            input.wrapper.style.cssText = oldWrapperCSS
            te.style.cssText = oldCSS
            if (ie && ie_version < 9) {
              display.scrollbars.setScrollTop(
                (display.scroller.scrollTop = scrollPos)
              )
            }

            // Try to detect the user choosing select-all
            if (te.selectionStart != null) {
              if (!ie || (ie && ie_version < 9)) {
                prepareSelectAllHack()
              }
              var i = 0,
                poll = function () {
                  if (
                    display.selForContextMenu == cm.doc.sel &&
                    te.selectionStart == 0 &&
                    te.selectionEnd > 0 &&
                    input.prevInput == '\u200b'
                  ) {
                    operation(cm, selectAll)(cm)
                  } else if (i++ < 10) {
                    display.detectingSelectAll = setTimeout(poll, 500)
                  } else {
                    display.selForContextMenu = null
                    display.input.reset()
                  }
                }
              display.detectingSelectAll = setTimeout(poll, 200)
            }
          }

          if (ie && ie_version >= 9) {
            prepareSelectAllHack()
          }
          if (captureRightClick) {
            e_stop(e)
            var mouseup = function () {
              off(window, 'mouseup', mouseup)
              setTimeout(rehide, 20)
            }
            on(window, 'mouseup', mouseup)
          } else {
            setTimeout(rehide, 50)
          }
        }

        TextareaInput.prototype.readOnlyChanged = function (val) {
          if (!val) {
            this.reset()
          }
          this.textarea.disabled = val == 'nocursor'
          this.textarea.readOnly = !!val
        }

        TextareaInput.prototype.setUneditable = function () {}

        TextareaInput.prototype.needsContentAttribute = false

        function fromTextArea(textarea, options) {
          options = options ? copyObj(options) : {}
          options.value = textarea.value
          if (!options.tabindex && textarea.tabIndex) {
            options.tabindex = textarea.tabIndex
          }
          if (!options.placeholder && textarea.placeholder) {
            options.placeholder = textarea.placeholder
          }
          // Set autofocus to true if this textarea is focused, or if it has
          // autofocus and no other element is focused.
          if (options.autofocus == null) {
            var hasFocus = activeElt()
            options.autofocus =
              hasFocus == textarea ||
              (textarea.getAttribute('autofocus') != null &&
                hasFocus == document.body)
          }

          function save() {
            textarea.value = cm.getValue()
          }

          var realSubmit
          if (textarea.form) {
            on(textarea.form, 'submit', save)
            // Deplorable hack to make the submit method do the right thing.
            if (!options.leaveSubmitMethodAlone) {
              var form = textarea.form
              realSubmit = form.submit
              try {
                var wrappedSubmit = (form.submit = function () {
                  save()
                  form.submit = realSubmit
                  form.submit()
                  form.submit = wrappedSubmit
                })
              } catch (e) {}
            }
          }

          options.finishInit = function (cm) {
            cm.save = save
            cm.getTextArea = function () {
              return textarea
            }
            cm.toTextArea = function () {
              cm.toTextArea = isNaN // Prevent this from being ran twice
              save()
              textarea.parentNode.removeChild(cm.getWrapperElement())
              textarea.style.display = ''
              if (textarea.form) {
                off(textarea.form, 'submit', save)
                if (
                  !options.leaveSubmitMethodAlone &&
                  typeof textarea.form.submit == 'function'
                ) {
                  textarea.form.submit = realSubmit
                }
              }
            }
          }

          textarea.style.display = 'none'
          var cm = CodeMirror(function (node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling)
          }, options)
          return cm
        }

        function addLegacyProps(CodeMirror) {
          CodeMirror.off = off
          CodeMirror.on = on
          CodeMirror.wheelEventPixels = wheelEventPixels
          CodeMirror.Doc = Doc
          CodeMirror.splitLines = splitLinesAuto
          CodeMirror.countColumn = countColumn
          CodeMirror.findColumn = findColumn
          CodeMirror.isWordChar = isWordCharBasic
          CodeMirror.Pass = Pass
          CodeMirror.signal = signal
          CodeMirror.Line = Line
          CodeMirror.changeEnd = changeEnd
          CodeMirror.scrollbarModel = scrollbarModel
          CodeMirror.Pos = Pos
          CodeMirror.cmpPos = cmp
          CodeMirror.modes = modes
          CodeMirror.mimeModes = mimeModes
          CodeMirror.resolveMode = resolveMode
          CodeMirror.getMode = getMode
          CodeMirror.modeExtensions = modeExtensions
          CodeMirror.extendMode = extendMode
          CodeMirror.copyState = copyState
          CodeMirror.startState = startState
          CodeMirror.innerMode = innerMode
          CodeMirror.commands = commands
          CodeMirror.keyMap = keyMap
          CodeMirror.keyName = keyName
          CodeMirror.isModifierKey = isModifierKey
          CodeMirror.lookupKey = lookupKey
          CodeMirror.normalizeKeyMap = normalizeKeyMap
          CodeMirror.StringStream = StringStream
          CodeMirror.SharedTextMarker = SharedTextMarker
          CodeMirror.TextMarker = TextMarker
          CodeMirror.LineWidget = LineWidget
          CodeMirror.e_preventDefault = e_preventDefault
          CodeMirror.e_stopPropagation = e_stopPropagation
          CodeMirror.e_stop = e_stop
          CodeMirror.addClass = addClass
          CodeMirror.contains = contains
          CodeMirror.rmClass = rmClass
          CodeMirror.keyNames = keyNames
        }

        // EDITOR CONSTRUCTOR

        defineOptions(CodeMirror)

        addEditorMethods(CodeMirror)

        // Set up methods on CodeMirror's prototype to redirect to the editor's document.
        var dontDelegate =
          'iter insert remove copy getEditor constructor'.split(' ')
        for (var prop in Doc.prototype) {
          if (
            Doc.prototype.hasOwnProperty(prop) &&
            indexOf(dontDelegate, prop) < 0
          ) {
            CodeMirror.prototype[prop] = (function (method) {
              return function () {
                return method.apply(this.doc, arguments)
              }
            })(Doc.prototype[prop])
          }
        }

        eventMixin(Doc)
        CodeMirror.inputStyles = {
          textarea: TextareaInput,
          contenteditable: ContentEditableInput
        }

        // Extra arguments are stored as the mode's dependencies, which is
        // used by (legacy) mechanisms like loadmode.js to automatically
        // load a mode. (Preferred mechanism is the require/define calls.)
        CodeMirror.defineMode = function (name /*, mode, */) {
          if (!CodeMirror.defaults.mode && name != 'null') {
            CodeMirror.defaults.mode = name
          }
          defineMode.apply(this, arguments)
        }

        CodeMirror.defineMIME = defineMIME

        // Minimal default mode.
        CodeMirror.defineMode('null', function () {
          return {
            token: function (stream) {
              return stream.skipToEnd()
            }
          }
        })
        CodeMirror.defineMIME('text/plain', 'null')

        // EXTENSIONS

        CodeMirror.defineExtension = function (name, func) {
          CodeMirror.prototype[name] = func
        }
        CodeMirror.defineDocExtension = function (name, func) {
          Doc.prototype[name] = func
        }

        CodeMirror.fromTextArea = fromTextArea

        addLegacyProps(CodeMirror)

        CodeMirror.version = '5.65.2'

        return CodeMirror
      })

      /***/
    },

    /***/ 6876: /***/ (
      __unused_webpack_module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      // CodeMirror, copyright (c) by Marijn Haverbeke and others
      // Distributed under an MIT license: https://codemirror.net/LICENSE

      ;(function (mod) {
        if (true)
          // CommonJS
          mod(__webpack_require__(4631))
        else {
        }
      })(function (CodeMirror) {
        'use strict'

        CodeMirror.defineMode('javascript', function (config, parserConfig) {
          var indentUnit = config.indentUnit
          var statementIndent = parserConfig.statementIndent
          var jsonldMode = parserConfig.jsonld
          var jsonMode = parserConfig.json || jsonldMode
          var trackScope = parserConfig.trackScope !== false
          var isTS = parserConfig.typescript
          var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/

          // Tokenizer

          var keywords = (function () {
            function kw(type) {
              return { type: type, style: 'keyword' }
            }
            var A = kw('keyword a'),
              B = kw('keyword b'),
              C = kw('keyword c'),
              D = kw('keyword d')
            var operator = kw('operator'),
              atom = { type: 'atom', style: 'atom' }

            return {
              if: kw('if'),
              while: A,
              with: A,
              else: B,
              do: B,
              try: B,
              finally: B,
              return: D,
              break: D,
              continue: D,
              new: kw('new'),
              delete: C,
              void: C,
              throw: C,
              debugger: kw('debugger'),
              var: kw('var'),
              const: kw('var'),
              let: kw('var'),
              function: kw('function'),
              catch: kw('catch'),
              for: kw('for'),
              switch: kw('switch'),
              case: kw('case'),
              default: kw('default'),
              in: operator,
              typeof: operator,
              instanceof: operator,
              true: atom,
              false: atom,
              null: atom,
              undefined: atom,
              NaN: atom,
              Infinity: atom,
              this: kw('this'),
              class: kw('class'),
              super: kw('atom'),
              yield: C,
              export: kw('export'),
              import: kw('import'),
              extends: C,
              await: C
            }
          })()

          var isOperatorChar = /[+\-*&%=<>!?|~^@]/
          var isJsonldKeyword =
            /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/

          function readRegexp(stream) {
            var escaped = false,
              next,
              inSet = false
            while ((next = stream.next()) != null) {
              if (!escaped) {
                if (next == '/' && !inSet) return
                if (next == '[') inSet = true
                else if (inSet && next == ']') inSet = false
              }
              escaped = !escaped && next == '\\'
            }
          }

          // Used as scratch variables to communicate multiple values without
          // consing up tons of objects.
          var type, content
          function ret(tp, style, cont) {
            type = tp
            content = cont
            return style
          }
          function tokenBase(stream, state) {
            var ch = stream.next()
            if (ch == '"' || ch == "'") {
              state.tokenize = tokenString(ch)
              return state.tokenize(stream, state)
            } else if (
              ch == '.' &&
              stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)
            ) {
              return ret('number', 'number')
            } else if (ch == '.' && stream.match('..')) {
              return ret('spread', 'meta')
            } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
              return ret(ch)
            } else if (ch == '=' && stream.eat('>')) {
              return ret('=>', 'operator')
            } else if (
              ch == '0' &&
              stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)
            ) {
              return ret('number', 'number')
            } else if (/\d/.test(ch)) {
              stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/)
              return ret('number', 'number')
            } else if (ch == '/') {
              if (stream.eat('*')) {
                state.tokenize = tokenComment
                return tokenComment(stream, state)
              } else if (stream.eat('/')) {
                stream.skipToEnd()
                return ret('comment', 'comment')
              } else if (expressionAllowed(stream, state, 1)) {
                readRegexp(stream)
                stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/)
                return ret('regexp', 'string-2')
              } else {
                stream.eat('=')
                return ret('operator', 'operator', stream.current())
              }
            } else if (ch == '`') {
              state.tokenize = tokenQuasi
              return tokenQuasi(stream, state)
            } else if (ch == '#' && stream.peek() == '!') {
              stream.skipToEnd()
              return ret('meta', 'meta')
            } else if (ch == '#' && stream.eatWhile(wordRE)) {
              return ret('variable', 'property')
            } else if (
              (ch == '<' && stream.match('!--')) ||
              (ch == '-' &&
                stream.match('->') &&
                !/\S/.test(stream.string.slice(0, stream.start)))
            ) {
              stream.skipToEnd()
              return ret('comment', 'comment')
            } else if (isOperatorChar.test(ch)) {
              if (ch != '>' || !state.lexical || state.lexical.type != '>') {
                if (stream.eat('=')) {
                  if (ch == '!' || ch == '=') stream.eat('=')
                } else if (/[<>*+\-|&?]/.test(ch)) {
                  stream.eat(ch)
                  if (ch == '>') stream.eat(ch)
                }
              }
              if (ch == '?' && stream.eat('.')) return ret('.')
              return ret('operator', 'operator', stream.current())
            } else if (wordRE.test(ch)) {
              stream.eatWhile(wordRE)
              var word = stream.current()
              if (state.lastType != '.') {
                if (keywords.propertyIsEnumerable(word)) {
                  var kw = keywords[word]
                  return ret(kw.type, kw.style, word)
                }
                if (
                  word == 'async' &&
                  stream.match(
                    /^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/,
                    false
                  )
                )
                  return ret('async', 'keyword', word)
              }
              return ret('variable', 'variable', word)
            }
          }

          function tokenString(quote) {
            return function (stream, state) {
              var escaped = false,
                next
              if (
                jsonldMode &&
                stream.peek() == '@' &&
                stream.match(isJsonldKeyword)
              ) {
                state.tokenize = tokenBase
                return ret('jsonld-keyword', 'meta')
              }
              while ((next = stream.next()) != null) {
                if (next == quote && !escaped) break
                escaped = !escaped && next == '\\'
              }
              if (!escaped) state.tokenize = tokenBase
              return ret('string', 'string')
            }
          }

          function tokenComment(stream, state) {
            var maybeEnd = false,
              ch
            while ((ch = stream.next())) {
              if (ch == '/' && maybeEnd) {
                state.tokenize = tokenBase
                break
              }
              maybeEnd = ch == '*'
            }
            return ret('comment', 'comment')
          }

          function tokenQuasi(stream, state) {
            var escaped = false,
              next
            while ((next = stream.next()) != null) {
              if (
                !escaped &&
                (next == '`' || (next == '$' && stream.eat('{')))
              ) {
                state.tokenize = tokenBase
                break
              }
              escaped = !escaped && next == '\\'
            }
            return ret('quasi', 'string-2', stream.current())
          }

          var brackets = '([{}])'
          // This is a crude lookahead trick to try and notice that we're
          // parsing the argument patterns for a fat-arrow function before we
          // actually hit the arrow token. It only works if the arrow is on
          // the same line as the arguments and there's no strange noise
          // (comments) in between. Fallback is to only notice when we hit the
          // arrow, and not declare the arguments as locals for the arrow
          // body.
          function findFatArrow(stream, state) {
            if (state.fatArrowAt) state.fatArrowAt = null
            var arrow = stream.string.indexOf('=>', stream.start)
            if (arrow < 0) return

            if (isTS) {
              // Try to skip TypeScript return type declarations after the arguments
              var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(
                stream.string.slice(stream.start, arrow)
              )
              if (m) arrow = m.index
            }

            var depth = 0,
              sawSomething = false
            for (var pos = arrow - 1; pos >= 0; --pos) {
              var ch = stream.string.charAt(pos)
              var bracket = brackets.indexOf(ch)
              if (bracket >= 0 && bracket < 3) {
                if (!depth) {
                  ++pos
                  break
                }
                if (--depth == 0) {
                  if (ch == '(') sawSomething = true
                  break
                }
              } else if (bracket >= 3 && bracket < 6) {
                ++depth
              } else if (wordRE.test(ch)) {
                sawSomething = true
              } else if (/["'\/`]/.test(ch)) {
                for (; ; --pos) {
                  if (pos == 0) return
                  var next = stream.string.charAt(pos - 1)
                  if (next == ch && stream.string.charAt(pos - 2) != '\\') {
                    pos--
                    break
                  }
                }
              } else if (sawSomething && !depth) {
                ++pos
                break
              }
            }
            if (sawSomething && !depth) state.fatArrowAt = pos
          }

          // Parser

          var atomicTypes = {
            atom: true,
            number: true,
            variable: true,
            string: true,
            regexp: true,
            this: true,
            import: true,
            'jsonld-keyword': true
          }

          function JSLexical(indented, column, type, align, prev, info) {
            this.indented = indented
            this.column = column
            this.type = type
            this.prev = prev
            this.info = info
            if (align != null) this.align = align
          }

          function inScope(state, varname) {
            if (!trackScope) return false
            for (var v = state.localVars; v; v = v.next)
              if (v.name == varname) return true
            for (var cx = state.context; cx; cx = cx.prev) {
              for (var v = cx.vars; v; v = v.next)
                if (v.name == varname) return true
            }
          }

          function parseJS(state, style, type, content, stream) {
            var cc = state.cc
            // Communicate our context to the combinators.
            // (Less wasteful than consing up a hundred closures on every call.)
            cx.state = state
            cx.stream = stream
            ;(cx.marked = null), (cx.cc = cc)
            cx.style = style

            if (!state.lexical.hasOwnProperty('align'))
              state.lexical.align = true

            while (true) {
              var combinator = cc.length
                ? cc.pop()
                : jsonMode
                ? expression
                : statement
              if (combinator(type, content)) {
                while (cc.length && cc[cc.length - 1].lex) cc.pop()()
                if (cx.marked) return cx.marked
                if (type == 'variable' && inScope(state, content))
                  return 'variable-2'
                return style
              }
            }
          }

          // Combinator utils

          var cx = { state: null, column: null, marked: null, cc: null }
          function pass() {
            for (var i = arguments.length - 1; i >= 0; i--)
              cx.cc.push(arguments[i])
          }
          function cont() {
            pass.apply(null, arguments)
            return true
          }
          function inList(name, list) {
            for (var v = list; v; v = v.next) if (v.name == name) return true
            return false
          }
          function register(varname) {
            var state = cx.state
            cx.marked = 'def'
            if (!trackScope) return
            if (state.context) {
              if (
                state.lexical.info == 'var' &&
                state.context &&
                state.context.block
              ) {
                // FIXME function decls are also not block scoped
                var newContext = registerVarScoped(varname, state.context)
                if (newContext != null) {
                  state.context = newContext
                  return
                }
              } else if (!inList(varname, state.localVars)) {
                state.localVars = new Var(varname, state.localVars)
                return
              }
            }
            // Fall through means this is global
            if (parserConfig.globalVars && !inList(varname, state.globalVars))
              state.globalVars = new Var(varname, state.globalVars)
          }
          function registerVarScoped(varname, context) {
            if (!context) {
              return null
            } else if (context.block) {
              var inner = registerVarScoped(varname, context.prev)
              if (!inner) return null
              if (inner == context.prev) return context
              return new Context(inner, context.vars, true)
            } else if (inList(varname, context.vars)) {
              return context
            } else {
              return new Context(
                context.prev,
                new Var(varname, context.vars),
                false
              )
            }
          }

          function isModifier(name) {
            return (
              name == 'public' ||
              name == 'private' ||
              name == 'protected' ||
              name == 'abstract' ||
              name == 'readonly'
            )
          }

          // Combinators

          function Context(prev, vars, block) {
            this.prev = prev
            this.vars = vars
            this.block = block
          }
          function Var(name, next) {
            this.name = name
            this.next = next
          }

          var defaultVars = new Var('this', new Var('arguments', null))
          function pushcontext() {
            cx.state.context = new Context(
              cx.state.context,
              cx.state.localVars,
              false
            )
            cx.state.localVars = defaultVars
          }
          function pushblockcontext() {
            cx.state.context = new Context(
              cx.state.context,
              cx.state.localVars,
              true
            )
            cx.state.localVars = null
          }
          pushcontext.lex = pushblockcontext.lex = true
          function popcontext() {
            cx.state.localVars = cx.state.context.vars
            cx.state.context = cx.state.context.prev
          }
          popcontext.lex = true
          function pushlex(type, info) {
            var result = function () {
              var state = cx.state,
                indent = state.indented
              if (state.lexical.type == 'stat') indent = state.lexical.indented
              else
                for (
                  var outer = state.lexical;
                  outer && outer.type == ')' && outer.align;
                  outer = outer.prev
                )
                  indent = outer.indented
              state.lexical = new JSLexical(
                indent,
                cx.stream.column(),
                type,
                null,
                state.lexical,
                info
              )
            }
            result.lex = true
            return result
          }
          function poplex() {
            var state = cx.state
            if (state.lexical.prev) {
              if (state.lexical.type == ')')
                state.indented = state.lexical.indented
              state.lexical = state.lexical.prev
            }
          }
          poplex.lex = true

          function expect(wanted) {
            function exp(type) {
              if (type == wanted) return cont()
              else if (
                wanted == ';' ||
                type == '}' ||
                type == ')' ||
                type == ']'
              )
                return pass()
              else return cont(exp)
            }
            return exp
          }

          function statement(type, value) {
            if (type == 'var')
              return cont(pushlex('vardef', value), vardef, expect(';'), poplex)
            if (type == 'keyword a')
              return cont(pushlex('form'), parenExpr, statement, poplex)
            if (type == 'keyword b')
              return cont(pushlex('form'), statement, poplex)
            if (type == 'keyword d')
              return cx.stream.match(/^\s*$/, false)
                ? cont()
                : cont(pushlex('stat'), maybeexpression, expect(';'), poplex)
            if (type == 'debugger') return cont(expect(';'))
            if (type == '{')
              return cont(
                pushlex('}'),
                pushblockcontext,
                block,
                poplex,
                popcontext
              )
            if (type == ';') return cont()
            if (type == 'if') {
              if (
                cx.state.lexical.info == 'else' &&
                cx.state.cc[cx.state.cc.length - 1] == poplex
              )
                cx.state.cc.pop()()
              return cont(
                pushlex('form'),
                parenExpr,
                statement,
                poplex,
                maybeelse
              )
            }
            if (type == 'function') return cont(functiondef)
            if (type == 'for')
              return cont(
                pushlex('form'),
                pushblockcontext,
                forspec,
                statement,
                popcontext,
                poplex
              )
            if (type == 'class' || (isTS && value == 'interface')) {
              cx.marked = 'keyword'
              return cont(
                pushlex('form', type == 'class' ? type : value),
                className,
                poplex
              )
            }
            if (type == 'variable') {
              if (isTS && value == 'declare') {
                cx.marked = 'keyword'
                return cont(statement)
              } else if (
                isTS &&
                (value == 'module' || value == 'enum' || value == 'type') &&
                cx.stream.match(/^\s*\w/, false)
              ) {
                cx.marked = 'keyword'
                if (value == 'enum') return cont(enumdef)
                else if (value == 'type')
                  return cont(
                    typename,
                    expect('operator'),
                    typeexpr,
                    expect(';')
                  )
                else
                  return cont(
                    pushlex('form'),
                    pattern,
                    expect('{'),
                    pushlex('}'),
                    block,
                    poplex,
                    poplex
                  )
              } else if (isTS && value == 'namespace') {
                cx.marked = 'keyword'
                return cont(pushlex('form'), expression, statement, poplex)
              } else if (isTS && value == 'abstract') {
                cx.marked = 'keyword'
                return cont(statement)
              } else {
                return cont(pushlex('stat'), maybelabel)
              }
            }
            if (type == 'switch')
              return cont(
                pushlex('form'),
                parenExpr,
                expect('{'),
                pushlex('}', 'switch'),
                pushblockcontext,
                block,
                poplex,
                poplex,
                popcontext
              )
            if (type == 'case') return cont(expression, expect(':'))
            if (type == 'default') return cont(expect(':'))
            if (type == 'catch')
              return cont(
                pushlex('form'),
                pushcontext,
                maybeCatchBinding,
                statement,
                poplex,
                popcontext
              )
            if (type == 'export')
              return cont(pushlex('stat'), afterExport, poplex)
            if (type == 'import')
              return cont(pushlex('stat'), afterImport, poplex)
            if (type == 'async') return cont(statement)
            if (value == '@') return cont(expression, statement)
            return pass(pushlex('stat'), expression, expect(';'), poplex)
          }
          function maybeCatchBinding(type) {
            if (type == '(') return cont(funarg, expect(')'))
          }
          function expression(type, value) {
            return expressionInner(type, value, false)
          }
          function expressionNoComma(type, value) {
            return expressionInner(type, value, true)
          }
          function parenExpr(type) {
            if (type != '(') return pass()
            return cont(pushlex(')'), maybeexpression, expect(')'), poplex)
          }
          function expressionInner(type, value, noComma) {
            if (cx.state.fatArrowAt == cx.stream.start) {
              var body = noComma ? arrowBodyNoComma : arrowBody
              if (type == '(')
                return cont(
                  pushcontext,
                  pushlex(')'),
                  commasep(funarg, ')'),
                  poplex,
                  expect('=>'),
                  body,
                  popcontext
                )
              else if (type == 'variable')
                return pass(
                  pushcontext,
                  pattern,
                  expect('=>'),
                  body,
                  popcontext
                )
            }

            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma
            if (atomicTypes.hasOwnProperty(type)) return cont(maybeop)
            if (type == 'function') return cont(functiondef, maybeop)
            if (type == 'class' || (isTS && value == 'interface')) {
              cx.marked = 'keyword'
              return cont(pushlex('form'), classExpression, poplex)
            }
            if (type == 'keyword c' || type == 'async')
              return cont(noComma ? expressionNoComma : expression)
            if (type == '(')
              return cont(
                pushlex(')'),
                maybeexpression,
                expect(')'),
                poplex,
                maybeop
              )
            if (type == 'operator' || type == 'spread')
              return cont(noComma ? expressionNoComma : expression)
            if (type == '[')
              return cont(pushlex(']'), arrayLiteral, poplex, maybeop)
            if (type == '{') return contCommasep(objprop, '}', null, maybeop)
            if (type == 'quasi') return pass(quasi, maybeop)
            if (type == 'new') return cont(maybeTarget(noComma))
            return cont()
          }
          function maybeexpression(type) {
            if (type.match(/[;\}\)\],]/)) return pass()
            return pass(expression)
          }

          function maybeoperatorComma(type, value) {
            if (type == ',') return cont(maybeexpression)
            return maybeoperatorNoComma(type, value, false)
          }
          function maybeoperatorNoComma(type, value, noComma) {
            var me =
              noComma == false ? maybeoperatorComma : maybeoperatorNoComma
            var expr = noComma == false ? expression : expressionNoComma
            if (type == '=>')
              return cont(
                pushcontext,
                noComma ? arrowBodyNoComma : arrowBody,
                popcontext
              )
            if (type == 'operator') {
              if (/\+\+|--/.test(value) || (isTS && value == '!'))
                return cont(me)
              if (
                isTS &&
                value == '<' &&
                cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false)
              )
                return cont(pushlex('>'), commasep(typeexpr, '>'), poplex, me)
              if (value == '?') return cont(expression, expect(':'), expr)
              return cont(expr)
            }
            if (type == 'quasi') {
              return pass(quasi, me)
            }
            if (type == ';') return
            if (type == '(')
              return contCommasep(expressionNoComma, ')', 'call', me)
            if (type == '.') return cont(property, me)
            if (type == '[')
              return cont(
                pushlex(']'),
                maybeexpression,
                expect(']'),
                poplex,
                me
              )
            if (isTS && value == 'as') {
              cx.marked = 'keyword'
              return cont(typeexpr, me)
            }
            if (type == 'regexp') {
              cx.state.lastType = cx.marked = 'operator'
              cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
              return cont(expr)
            }
          }
          function quasi(type, value) {
            if (type != 'quasi') return pass()
            if (value.slice(value.length - 2) != '${') return cont(quasi)
            return cont(maybeexpression, continueQuasi)
          }
          function continueQuasi(type) {
            if (type == '}') {
              cx.marked = 'string-2'
              cx.state.tokenize = tokenQuasi
              return cont(quasi)
            }
          }
          function arrowBody(type) {
            findFatArrow(cx.stream, cx.state)
            return pass(type == '{' ? statement : expression)
          }
          function arrowBodyNoComma(type) {
            findFatArrow(cx.stream, cx.state)
            return pass(type == '{' ? statement : expressionNoComma)
          }
          function maybeTarget(noComma) {
            return function (type) {
              if (type == '.') return cont(noComma ? targetNoComma : target)
              else if (type == 'variable' && isTS)
                return cont(
                  maybeTypeArgs,
                  noComma ? maybeoperatorNoComma : maybeoperatorComma
                )
              else return pass(noComma ? expressionNoComma : expression)
            }
          }
          function target(_, value) {
            if (value == 'target') {
              cx.marked = 'keyword'
              return cont(maybeoperatorComma)
            }
          }
          function targetNoComma(_, value) {
            if (value == 'target') {
              cx.marked = 'keyword'
              return cont(maybeoperatorNoComma)
            }
          }
          function maybelabel(type) {
            if (type == ':') return cont(poplex, statement)
            return pass(maybeoperatorComma, expect(';'), poplex)
          }
          function property(type) {
            if (type == 'variable') {
              cx.marked = 'property'
              return cont()
            }
          }
          function objprop(type, value) {
            if (type == 'async') {
              cx.marked = 'property'
              return cont(objprop)
            } else if (type == 'variable' || cx.style == 'keyword') {
              cx.marked = 'property'
              if (value == 'get' || value == 'set') return cont(getterSetter)
              var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
              if (
                isTS &&
                cx.state.fatArrowAt == cx.stream.start &&
                (m = cx.stream.match(/^\s*:\s*/, false))
              )
                cx.state.fatArrowAt = cx.stream.pos + m[0].length
              return cont(afterprop)
            } else if (type == 'number' || type == 'string') {
              cx.marked = jsonldMode ? 'property' : cx.style + ' property'
              return cont(afterprop)
            } else if (type == 'jsonld-keyword') {
              return cont(afterprop)
            } else if (isTS && isModifier(value)) {
              cx.marked = 'keyword'
              return cont(objprop)
            } else if (type == '[') {
              return cont(expression, maybetype, expect(']'), afterprop)
            } else if (type == 'spread') {
              return cont(expressionNoComma, afterprop)
            } else if (value == '*') {
              cx.marked = 'keyword'
              return cont(objprop)
            } else if (type == ':') {
              return pass(afterprop)
            }
          }
          function getterSetter(type) {
            if (type != 'variable') return pass(afterprop)
            cx.marked = 'property'
            return cont(functiondef)
          }
          function afterprop(type) {
            if (type == ':') return cont(expressionNoComma)
            if (type == '(') return pass(functiondef)
          }
          function commasep(what, end, sep) {
            function proceed(type, value) {
              if (sep ? sep.indexOf(type) > -1 : type == ',') {
                var lex = cx.state.lexical
                if (lex.info == 'call') lex.pos = (lex.pos || 0) + 1
                return cont(function (type, value) {
                  if (type == end || value == end) return pass()
                  return pass(what)
                }, proceed)
              }
              if (type == end || value == end) return cont()
              if (sep && sep.indexOf(';') > -1) return pass(what)
              return cont(expect(end))
            }
            return function (type, value) {
              if (type == end || value == end) return cont()
              return pass(what, proceed)
            }
          }
          function contCommasep(what, end, info) {
            for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i])
            return cont(pushlex(end, info), commasep(what, end), poplex)
          }
          function block(type) {
            if (type == '}') return cont()
            return pass(statement, block)
          }
          function maybetype(type, value) {
            if (isTS) {
              if (type == ':') return cont(typeexpr)
              if (value == '?') return cont(maybetype)
            }
          }
          function maybetypeOrIn(type, value) {
            if (isTS && (type == ':' || value == 'in')) return cont(typeexpr)
          }
          function mayberettype(type) {
            if (isTS && type == ':') {
              if (cx.stream.match(/^\s*\w+\s+is\b/, false))
                return cont(expression, isKW, typeexpr)
              else return cont(typeexpr)
            }
          }
          function isKW(_, value) {
            if (value == 'is') {
              cx.marked = 'keyword'
              return cont()
            }
          }
          function typeexpr(type, value) {
            if (
              value == 'keyof' ||
              value == 'typeof' ||
              value == 'infer' ||
              value == 'readonly'
            ) {
              cx.marked = 'keyword'
              return cont(value == 'typeof' ? expressionNoComma : typeexpr)
            }
            if (type == 'variable' || value == 'void') {
              cx.marked = 'type'
              return cont(afterType)
            }
            if (value == '|' || value == '&') return cont(typeexpr)
            if (type == 'string' || type == 'number' || type == 'atom')
              return cont(afterType)
            if (type == '[')
              return cont(
                pushlex(']'),
                commasep(typeexpr, ']', ','),
                poplex,
                afterType
              )
            if (type == '{')
              return cont(pushlex('}'), typeprops, poplex, afterType)
            if (type == '(')
              return cont(commasep(typearg, ')'), maybeReturnType, afterType)
            if (type == '<') return cont(commasep(typeexpr, '>'), typeexpr)
            if (type == 'quasi') {
              return pass(quasiType, afterType)
            }
          }
          function maybeReturnType(type) {
            if (type == '=>') return cont(typeexpr)
          }
          function typeprops(type) {
            if (type.match(/[\}\)\]]/)) return cont()
            if (type == ',' || type == ';') return cont(typeprops)
            return pass(typeprop, typeprops)
          }
          function typeprop(type, value) {
            if (type == 'variable' || cx.style == 'keyword') {
              cx.marked = 'property'
              return cont(typeprop)
            } else if (value == '?' || type == 'number' || type == 'string') {
              return cont(typeprop)
            } else if (type == ':') {
              return cont(typeexpr)
            } else if (type == '[') {
              return cont(
                expect('variable'),
                maybetypeOrIn,
                expect(']'),
                typeprop
              )
            } else if (type == '(') {
              return pass(functiondecl, typeprop)
            } else if (!type.match(/[;\}\)\],]/)) {
              return cont()
            }
          }
          function quasiType(type, value) {
            if (type != 'quasi') return pass()
            if (value.slice(value.length - 2) != '${') return cont(quasiType)
            return cont(typeexpr, continueQuasiType)
          }
          function continueQuasiType(type) {
            if (type == '}') {
              cx.marked = 'string-2'
              cx.state.tokenize = tokenQuasi
              return cont(quasiType)
            }
          }
          function typearg(type, value) {
            if (
              (type == 'variable' && cx.stream.match(/^\s*[?:]/, false)) ||
              value == '?'
            )
              return cont(typearg)
            if (type == ':') return cont(typeexpr)
            if (type == 'spread') return cont(typearg)
            return pass(typeexpr)
          }
          function afterType(type, value) {
            if (value == '<')
              return cont(
                pushlex('>'),
                commasep(typeexpr, '>'),
                poplex,
                afterType
              )
            if (value == '|' || type == '.' || value == '&')
              return cont(typeexpr)
            if (type == '[') return cont(typeexpr, expect(']'), afterType)
            if (value == 'extends' || value == 'implements') {
              cx.marked = 'keyword'
              return cont(typeexpr)
            }
            if (value == '?') return cont(typeexpr, expect(':'), typeexpr)
          }
          function maybeTypeArgs(_, value) {
            if (value == '<')
              return cont(
                pushlex('>'),
                commasep(typeexpr, '>'),
                poplex,
                afterType
              )
          }
          function typeparam() {
            return pass(typeexpr, maybeTypeDefault)
          }
          function maybeTypeDefault(_, value) {
            if (value == '=') return cont(typeexpr)
          }
          function vardef(_, value) {
            if (value == 'enum') {
              cx.marked = 'keyword'
              return cont(enumdef)
            }
            return pass(pattern, maybetype, maybeAssign, vardefCont)
          }
          function pattern(type, value) {
            if (isTS && isModifier(value)) {
              cx.marked = 'keyword'
              return cont(pattern)
            }
            if (type == 'variable') {
              register(value)
              return cont()
            }
            if (type == 'spread') return cont(pattern)
            if (type == '[') return contCommasep(eltpattern, ']')
            if (type == '{') return contCommasep(proppattern, '}')
          }
          function proppattern(type, value) {
            if (type == 'variable' && !cx.stream.match(/^\s*:/, false)) {
              register(value)
              return cont(maybeAssign)
            }
            if (type == 'variable') cx.marked = 'property'
            if (type == 'spread') return cont(pattern)
            if (type == '}') return pass()
            if (type == '[')
              return cont(expression, expect(']'), expect(':'), proppattern)
            return cont(expect(':'), pattern, maybeAssign)
          }
          function eltpattern() {
            return pass(pattern, maybeAssign)
          }
          function maybeAssign(_type, value) {
            if (value == '=') return cont(expressionNoComma)
          }
          function vardefCont(type) {
            if (type == ',') return cont(vardef)
          }
          function maybeelse(type, value) {
            if (type == 'keyword b' && value == 'else')
              return cont(pushlex('form', 'else'), statement, poplex)
          }
          function forspec(type, value) {
            if (value == 'await') return cont(forspec)
            if (type == '(') return cont(pushlex(')'), forspec1, poplex)
          }
          function forspec1(type) {
            if (type == 'var') return cont(vardef, forspec2)
            if (type == 'variable') return cont(forspec2)
            return pass(forspec2)
          }
          function forspec2(type, value) {
            if (type == ')') return cont()
            if (type == ';') return cont(forspec2)
            if (value == 'in' || value == 'of') {
              cx.marked = 'keyword'
              return cont(expression, forspec2)
            }
            return pass(expression, forspec2)
          }
          function functiondef(type, value) {
            if (value == '*') {
              cx.marked = 'keyword'
              return cont(functiondef)
            }
            if (type == 'variable') {
              register(value)
              return cont(functiondef)
            }
            if (type == '(')
              return cont(
                pushcontext,
                pushlex(')'),
                commasep(funarg, ')'),
                poplex,
                mayberettype,
                statement,
                popcontext
              )
            if (isTS && value == '<')
              return cont(
                pushlex('>'),
                commasep(typeparam, '>'),
                poplex,
                functiondef
              )
          }
          function functiondecl(type, value) {
            if (value == '*') {
              cx.marked = 'keyword'
              return cont(functiondecl)
            }
            if (type == 'variable') {
              register(value)
              return cont(functiondecl)
            }
            if (type == '(')
              return cont(
                pushcontext,
                pushlex(')'),
                commasep(funarg, ')'),
                poplex,
                mayberettype,
                popcontext
              )
            if (isTS && value == '<')
              return cont(
                pushlex('>'),
                commasep(typeparam, '>'),
                poplex,
                functiondecl
              )
          }
          function typename(type, value) {
            if (type == 'keyword' || type == 'variable') {
              cx.marked = 'type'
              return cont(typename)
            } else if (value == '<') {
              return cont(pushlex('>'), commasep(typeparam, '>'), poplex)
            }
          }
          function funarg(type, value) {
            if (value == '@') cont(expression, funarg)
            if (type == 'spread') return cont(funarg)
            if (isTS && isModifier(value)) {
              cx.marked = 'keyword'
              return cont(funarg)
            }
            if (isTS && type == 'this') return cont(maybetype, maybeAssign)
            return pass(pattern, maybetype, maybeAssign)
          }
          function classExpression(type, value) {
            // Class expressions may have an optional name.
            if (type == 'variable') return className(type, value)
            return classNameAfter(type, value)
          }
          function className(type, value) {
            if (type == 'variable') {
              register(value)
              return cont(classNameAfter)
            }
          }
          function classNameAfter(type, value) {
            if (value == '<')
              return cont(
                pushlex('>'),
                commasep(typeparam, '>'),
                poplex,
                classNameAfter
              )
            if (
              value == 'extends' ||
              value == 'implements' ||
              (isTS && type == ',')
            ) {
              if (value == 'implements') cx.marked = 'keyword'
              return cont(isTS ? typeexpr : expression, classNameAfter)
            }
            if (type == '{') return cont(pushlex('}'), classBody, poplex)
          }
          function classBody(type, value) {
            if (
              type == 'async' ||
              (type == 'variable' &&
                (value == 'static' ||
                  value == 'get' ||
                  value == 'set' ||
                  (isTS && isModifier(value))) &&
                cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))
            ) {
              cx.marked = 'keyword'
              return cont(classBody)
            }
            if (type == 'variable' || cx.style == 'keyword') {
              cx.marked = 'property'
              return cont(classfield, classBody)
            }
            if (type == 'number' || type == 'string')
              return cont(classfield, classBody)
            if (type == '[')
              return cont(
                expression,
                maybetype,
                expect(']'),
                classfield,
                classBody
              )
            if (value == '*') {
              cx.marked = 'keyword'
              return cont(classBody)
            }
            if (isTS && type == '(') return pass(functiondecl, classBody)
            if (type == ';' || type == ',') return cont(classBody)
            if (type == '}') return cont()
            if (value == '@') return cont(expression, classBody)
          }
          function classfield(type, value) {
            if (value == '!') return cont(classfield)
            if (value == '?') return cont(classfield)
            if (type == ':') return cont(typeexpr, maybeAssign)
            if (value == '=') return cont(expressionNoComma)
            var context = cx.state.lexical.prev,
              isInterface = context && context.info == 'interface'
            return pass(isInterface ? functiondecl : functiondef)
          }
          function afterExport(type, value) {
            if (value == '*') {
              cx.marked = 'keyword'
              return cont(maybeFrom, expect(';'))
            }
            if (value == 'default') {
              cx.marked = 'keyword'
              return cont(expression, expect(';'))
            }
            if (type == '{')
              return cont(commasep(exportField, '}'), maybeFrom, expect(';'))
            return pass(statement)
          }
          function exportField(type, value) {
            if (value == 'as') {
              cx.marked = 'keyword'
              return cont(expect('variable'))
            }
            if (type == 'variable') return pass(expressionNoComma, exportField)
          }
          function afterImport(type) {
            if (type == 'string') return cont()
            if (type == '(') return pass(expression)
            if (type == '.') return pass(maybeoperatorComma)
            return pass(importSpec, maybeMoreImports, maybeFrom)
          }
          function importSpec(type, value) {
            if (type == '{') return contCommasep(importSpec, '}')
            if (type == 'variable') register(value)
            if (value == '*') cx.marked = 'keyword'
            return cont(maybeAs)
          }
          function maybeMoreImports(type) {
            if (type == ',') return cont(importSpec, maybeMoreImports)
          }
          function maybeAs(_type, value) {
            if (value == 'as') {
              cx.marked = 'keyword'
              return cont(importSpec)
            }
          }
          function maybeFrom(_type, value) {
            if (value == 'from') {
              cx.marked = 'keyword'
              return cont(expression)
            }
          }
          function arrayLiteral(type) {
            if (type == ']') return cont()
            return pass(commasep(expressionNoComma, ']'))
          }
          function enumdef() {
            return pass(
              pushlex('form'),
              pattern,
              expect('{'),
              pushlex('}'),
              commasep(enummember, '}'),
              poplex,
              poplex
            )
          }
          function enummember() {
            return pass(pattern, maybeAssign)
          }

          function isContinuedStatement(state, textAfter) {
            return (
              state.lastType == 'operator' ||
              state.lastType == ',' ||
              isOperatorChar.test(textAfter.charAt(0)) ||
              /[,.]/.test(textAfter.charAt(0))
            )
          }

          function expressionAllowed(stream, state, backUp) {
            return (
              (state.tokenize == tokenBase &&
                /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(
                  state.lastType
                )) ||
              (state.lastType == 'quasi' &&
                /\{\s*$/.test(
                  stream.string.slice(0, stream.pos - (backUp || 0))
                ))
            )
          }

          // Interface

          return {
            startState: function (basecolumn) {
              var state = {
                tokenize: tokenBase,
                lastType: 'sof',
                cc: [],
                lexical: new JSLexical(
                  (basecolumn || 0) - indentUnit,
                  0,
                  'block',
                  false
                ),
                localVars: parserConfig.localVars,
                context:
                  parserConfig.localVars && new Context(null, null, false),
                indented: basecolumn || 0
              }
              if (
                parserConfig.globalVars &&
                typeof parserConfig.globalVars == 'object'
              )
                state.globalVars = parserConfig.globalVars
              return state
            },

            token: function (stream, state) {
              if (stream.sol()) {
                if (!state.lexical.hasOwnProperty('align'))
                  state.lexical.align = false
                state.indented = stream.indentation()
                findFatArrow(stream, state)
              }
              if (state.tokenize != tokenComment && stream.eatSpace())
                return null
              var style = state.tokenize(stream, state)
              if (type == 'comment') return style
              state.lastType =
                type == 'operator' && (content == '++' || content == '--')
                  ? 'incdec'
                  : type
              return parseJS(state, style, type, content, stream)
            },

            indent: function (state, textAfter) {
              if (
                state.tokenize == tokenComment ||
                state.tokenize == tokenQuasi
              )
                return CodeMirror.Pass
              if (state.tokenize != tokenBase) return 0
              var firstChar = textAfter && textAfter.charAt(0),
                lexical = state.lexical,
                top
              // Kludge to prevent 'maybelse' from blocking lexical scope pops
              if (!/^\s*else\b/.test(textAfter))
                for (var i = state.cc.length - 1; i >= 0; --i) {
                  var c = state.cc[i]
                  if (c == poplex) lexical = lexical.prev
                  else if (c != maybeelse && c != popcontext) break
                }
              while (
                (lexical.type == 'stat' || lexical.type == 'form') &&
                (firstChar == '}' ||
                  ((top = state.cc[state.cc.length - 1]) &&
                    (top == maybeoperatorComma ||
                      top == maybeoperatorNoComma) &&
                    !/^[,\.=+\-*:?[\(]/.test(textAfter)))
              )
                lexical = lexical.prev
              if (
                statementIndent &&
                lexical.type == ')' &&
                lexical.prev.type == 'stat'
              )
                lexical = lexical.prev
              var type = lexical.type,
                closing = firstChar == type

              if (type == 'vardef')
                return (
                  lexical.indented +
                  (state.lastType == 'operator' || state.lastType == ','
                    ? lexical.info.length + 1
                    : 0)
                )
              else if (type == 'form' && firstChar == '{')
                return lexical.indented
              else if (type == 'form') return lexical.indented + indentUnit
              else if (type == 'stat')
                return (
                  lexical.indented +
                  (isContinuedStatement(state, textAfter)
                    ? statementIndent || indentUnit
                    : 0)
                )
              else if (
                lexical.info == 'switch' &&
                !closing &&
                parserConfig.doubleIndentSwitch != false
              )
                return (
                  lexical.indented +
                  (/^(?:case|default)\b/.test(textAfter)
                    ? indentUnit
                    : 2 * indentUnit)
                )
              else if (lexical.align) return lexical.column + (closing ? 0 : 1)
              else return lexical.indented + (closing ? 0 : indentUnit)
            },

            electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            blockCommentStart: jsonMode ? null : '/*',
            blockCommentEnd: jsonMode ? null : '*/',
            blockCommentContinue: jsonMode ? null : ' * ',
            lineComment: jsonMode ? null : '//',
            fold: 'brace',
            closeBrackets: '()[]{}\'\'""``',

            helperType: jsonMode ? 'json' : 'javascript',
            jsonldMode: jsonldMode,
            jsonMode: jsonMode,

            expressionAllowed: expressionAllowed,

            skipExpression: function (state) {
              parseJS(
                state,
                'atom',
                'atom',
                'true',
                new CodeMirror.StringStream('', 2, null)
              )
            }
          }
        })

        CodeMirror.registerHelper('wordChars', 'javascript', /[\w$]/)

        CodeMirror.defineMIME('text/javascript', 'javascript')
        CodeMirror.defineMIME('text/ecmascript', 'javascript')
        CodeMirror.defineMIME('application/javascript', 'javascript')
        CodeMirror.defineMIME('application/x-javascript', 'javascript')
        CodeMirror.defineMIME('application/ecmascript', 'javascript')
        CodeMirror.defineMIME('application/json', {
          name: 'javascript',
          json: true
        })
        CodeMirror.defineMIME('application/x-json', {
          name: 'javascript',
          json: true
        })
        CodeMirror.defineMIME('application/manifest+json', {
          name: 'javascript',
          json: true
        })
        CodeMirror.defineMIME('application/ld+json', {
          name: 'javascript',
          jsonld: true
        })
        CodeMirror.defineMIME('text/typescript', {
          name: 'javascript',
          typescript: true
        })
        CodeMirror.defineMIME('application/typescript', {
          name: 'javascript',
          typescript: true
        })
      })

      /***/
    },

    /***/ 296: /***/ (module) => {
      /**
       * Returns a function, that, as long as it continues to be invoked, will not
       * be triggered. The function will be called after it stops being called for
       * N milliseconds. If `immediate` is passed, trigger the function on the
       * leading edge, instead of the trailing. The function also has a property 'clear'
       * that is a function which will clear the timer to prevent previously scheduled executions.
       *
       * @source underscore.js
       * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
       * @param {Function} function to wrap
       * @param {Number} timeout in ms (`100`)
       * @param {Boolean} whether to execute at the beginning (`false`)
       * @api public
       */
      function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result
        if (null == wait) wait = 100

        function later() {
          var last = Date.now() - timestamp

          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last)
          } else {
            timeout = null
            if (!immediate) {
              result = func.apply(context, args)
              context = args = null
            }
          }
        }

        var debounced = function () {
          context = this
          args = arguments
          timestamp = Date.now()
          var callNow = immediate && !timeout
          if (!timeout) timeout = setTimeout(later, wait)
          if (callNow) {
            result = func.apply(context, args)
            context = args = null
          }

          return result
        }

        debounced.clear = function () {
          if (timeout) {
            clearTimeout(timeout)
            timeout = null
          }
        }

        debounced.flush = function () {
          if (timeout) {
            result = func.apply(context, args)
            context = args = null

            clearTimeout(timeout)
            timeout = null
          }
        }

        return debounced
      }

      // Adds compatibility for ES modules
      debounce.debounce = debounce

      module.exports = debounce

      /***/
    },

    /***/ 1245: /***/ function (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) {
      /*!
       * @license deepcopy.js Copyright(c) 2013 sasa+1
       * https://github.com/sasaplus1/deepcopy.js
       * Released under the MIT license.
       *
       * type-detect
       * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
       * MIT Licensed
       */
      ;(function (global, factory) {
        true ? (module.exports = factory()) : 0
      })(this, function () {
        'use strict'

        var commonjsGlobal =
          typeof globalThis !== 'undefined'
            ? globalThis
            : typeof window !== 'undefined'
            ? window
            : typeof __webpack_require__.g !== 'undefined'
            ? __webpack_require__.g
            : typeof self !== 'undefined'
            ? self
            : {}

        function createCommonjsModule(fn, module) {
          return (
            (module = { exports: {} }),
            fn(module, module.exports),
            module.exports
          )
        }

        var typeDetect = createCommonjsModule(function (module, exports) {
          ;(function (global, factory) {
            module.exports = factory()
          })(commonjsGlobal, function () {
            /* !
             * type-detect
             * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
             * MIT Licensed
             */
            var promiseExists = typeof Promise === 'function'

            /* eslint-disable no-undef */
            var globalObject = typeof self === 'object' ? self : commonjsGlobal // eslint-disable-line id-blacklist

            var symbolExists = typeof Symbol !== 'undefined'
            var mapExists = typeof Map !== 'undefined'
            var setExists = typeof Set !== 'undefined'
            var weakMapExists = typeof WeakMap !== 'undefined'
            var weakSetExists = typeof WeakSet !== 'undefined'
            var dataViewExists = typeof DataView !== 'undefined'
            var symbolIteratorExists =
              symbolExists && typeof Symbol.iterator !== 'undefined'
            var symbolToStringTagExists =
              symbolExists && typeof Symbol.toStringTag !== 'undefined'
            var setEntriesExists =
              setExists && typeof Set.prototype.entries === 'function'
            var mapEntriesExists =
              mapExists && typeof Map.prototype.entries === 'function'
            var setIteratorPrototype =
              setEntriesExists && Object.getPrototypeOf(new Set().entries())
            var mapIteratorPrototype =
              mapEntriesExists && Object.getPrototypeOf(new Map().entries())
            var arrayIteratorExists =
              symbolIteratorExists &&
              typeof Array.prototype[Symbol.iterator] === 'function'
            var arrayIteratorPrototype =
              arrayIteratorExists &&
              Object.getPrototypeOf([][Symbol.iterator]())
            var stringIteratorExists =
              symbolIteratorExists &&
              typeof String.prototype[Symbol.iterator] === 'function'
            var stringIteratorPrototype =
              stringIteratorExists &&
              Object.getPrototypeOf(''[Symbol.iterator]())
            var toStringLeftSliceLength = 8
            var toStringRightSliceLength = -1
            /**
             * ### typeOf (obj)
             *
             * Uses `Object.prototype.toString` to determine the type of an object,
             * normalising behaviour across engine versions & well optimised.
             *
             * @param {Mixed} object
             * @return {String} object type
             * @api public
             */
            function typeDetect(obj) {
              /* ! Speed optimisation
               * Pre:
               *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
               *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
               *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
               *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
               *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
               * Post:
               *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
               *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
               *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
               *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
               *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
               */
              var typeofObj = typeof obj
              if (typeofObj !== 'object') {
                return typeofObj
              }

              /* ! Speed optimisation
               * Pre:
               *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
               * Post:
               *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
               */
              if (obj === null) {
                return 'null'
              }

              /* ! Spec Conformance
               * Test: `Object.prototype.toString.call(window)``
               *  - Node === "[object global]"
               *  - Chrome === "[object global]"
               *  - Firefox === "[object Window]"
               *  - PhantomJS === "[object Window]"
               *  - Safari === "[object Window]"
               *  - IE 11 === "[object Window]"
               *  - IE Edge === "[object Window]"
               * Test: `Object.prototype.toString.call(this)``
               *  - Chrome Worker === "[object global]"
               *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
               *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
               *  - IE 11 Worker === "[object WorkerGlobalScope]"
               *  - IE Edge Worker === "[object WorkerGlobalScope]"
               */
              if (obj === globalObject) {
                return 'global'
              }

              /* ! Speed optimisation
               * Pre:
               *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
               * Post:
               *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
               */
              if (
                Array.isArray(obj) &&
                (symbolToStringTagExists === false ||
                  !(Symbol.toStringTag in obj))
              ) {
                return 'Array'
              }

              // Not caching existence of `window` and related properties due to potential
              // for `window` to be unset before tests in quasi-browser environments.
              if (typeof window === 'object' && window !== null) {
                /* ! Spec Conformance
                 * (https://html.spec.whatwg.org/multipage/browsers.html#location)
                 * WhatWG HTML$7.7.3 - The `Location` interface
                 * Test: `Object.prototype.toString.call(window.location)``
                 *  - IE <=11 === "[object Object]"
                 *  - IE Edge <=13 === "[object Object]"
                 */
                if (
                  typeof window.location === 'object' &&
                  obj === window.location
                ) {
                  return 'Location'
                }

                /* ! Spec Conformance
                 * (https://html.spec.whatwg.org/#document)
                 * WhatWG HTML$3.1.1 - The `Document` object
                 * Note: Most browsers currently adher to the W3C DOM Level 2 spec
                 *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
                 *       which suggests that browsers should use HTMLTableCellElement for
                 *       both TD and TH elements. WhatWG separates these.
                 *       WhatWG HTML states:
                 *         > For historical reasons, Window objects must also have a
                 *         > writable, configurable, non-enumerable property named
                 *         > HTMLDocument whose value is the Document interface object.
                 * Test: `Object.prototype.toString.call(document)``
                 *  - Chrome === "[object HTMLDocument]"
                 *  - Firefox === "[object HTMLDocument]"
                 *  - Safari === "[object HTMLDocument]"
                 *  - IE <=10 === "[object Document]"
                 *  - IE 11 === "[object HTMLDocument]"
                 *  - IE Edge <=13 === "[object HTMLDocument]"
                 */
                if (
                  typeof window.document === 'object' &&
                  obj === window.document
                ) {
                  return 'Document'
                }

                if (typeof window.navigator === 'object') {
                  /* ! Spec Conformance
                   * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
                   * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
                   * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
                   *  - IE <=10 === "[object MSMimeTypesCollection]"
                   */
                  if (
                    typeof window.navigator.mimeTypes === 'object' &&
                    obj === window.navigator.mimeTypes
                  ) {
                    return 'MimeTypeArray'
                  }

                  /* ! Spec Conformance
                   * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
                   * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
                   * Test: `Object.prototype.toString.call(navigator.plugins)``
                   *  - IE <=10 === "[object MSPluginsCollection]"
                   */
                  if (
                    typeof window.navigator.plugins === 'object' &&
                    obj === window.navigator.plugins
                  ) {
                    return 'PluginArray'
                  }
                }

                if (
                  (typeof window.HTMLElement === 'function' ||
                    typeof window.HTMLElement === 'object') &&
                  obj instanceof window.HTMLElement
                ) {
                  /* ! Spec Conformance
                   * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
                   * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
                   * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
                   *  - IE <=10 === "[object HTMLBlockElement]"
                   */
                  if (obj.tagName === 'BLOCKQUOTE') {
                    return 'HTMLQuoteElement'
                  }

                  /* ! Spec Conformance
                   * (https://html.spec.whatwg.org/#htmltabledatacellelement)
                   * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
                   * Note: Most browsers currently adher to the W3C DOM Level 2 spec
                   *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
                   *       which suggests that browsers should use HTMLTableCellElement for
                   *       both TD and TH elements. WhatWG separates these.
                   * Test: Object.prototype.toString.call(document.createElement('td'))
                   *  - Chrome === "[object HTMLTableCellElement]"
                   *  - Firefox === "[object HTMLTableCellElement]"
                   *  - Safari === "[object HTMLTableCellElement]"
                   */
                  if (obj.tagName === 'TD') {
                    return 'HTMLTableDataCellElement'
                  }

                  /* ! Spec Conformance
                   * (https://html.spec.whatwg.org/#htmltableheadercellelement)
                   * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
                   * Note: Most browsers currently adher to the W3C DOM Level 2 spec
                   *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
                   *       which suggests that browsers should use HTMLTableCellElement for
                   *       both TD and TH elements. WhatWG separates these.
                   * Test: Object.prototype.toString.call(document.createElement('th'))
                   *  - Chrome === "[object HTMLTableCellElement]"
                   *  - Firefox === "[object HTMLTableCellElement]"
                   *  - Safari === "[object HTMLTableCellElement]"
                   */
                  if (obj.tagName === 'TH') {
                    return 'HTMLTableHeaderCellElement'
                  }
                }
              }

              /* ! Speed optimisation
               * Pre:
               *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
               *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
               *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
               *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
               *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
               *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
               *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
               *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
               *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
               * Post:
               *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
               *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
               *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
               *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
               *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
               *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
               *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
               *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
               *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
               */
              var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag]
              if (typeof stringTag === 'string') {
                return stringTag
              }

              var objPrototype = Object.getPrototypeOf(obj)
              /* ! Speed optimisation
               * Pre:
               *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
               *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
               * Post:
               *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
               *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
               */
              if (objPrototype === RegExp.prototype) {
                return 'RegExp'
              }

              /* ! Speed optimisation
               * Pre:
               *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
               * Post:
               *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
               */
              if (objPrototype === Date.prototype) {
                return 'Date'
              }

              /* ! Spec Conformance
               * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
               * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
               * Test: `Object.prototype.toString.call(Promise.resolve())``
               *  - Chrome <=47 === "[object Object]"
               *  - Edge <=20 === "[object Object]"
               *  - Firefox 29-Latest === "[object Promise]"
               *  - Safari 7.1-Latest === "[object Promise]"
               */
              if (promiseExists && objPrototype === Promise.prototype) {
                return 'Promise'
              }

              /* ! Speed optimisation
               * Pre:
               *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
               * Post:
               *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
               */
              if (setExists && objPrototype === Set.prototype) {
                return 'Set'
              }

              /* ! Speed optimisation
               * Pre:
               *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
               * Post:
               *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
               */
              if (mapExists && objPrototype === Map.prototype) {
                return 'Map'
              }

              /* ! Speed optimisation
               * Pre:
               *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
               * Post:
               *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
               */
              if (weakSetExists && objPrototype === WeakSet.prototype) {
                return 'WeakSet'
              }

              /* ! Speed optimisation
               * Pre:
               *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
               * Post:
               *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
               */
              if (weakMapExists && objPrototype === WeakMap.prototype) {
                return 'WeakMap'
              }

              /* ! Spec Conformance
               * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
               * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
               * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
               *  - Edge <=13 === "[object Object]"
               */
              if (dataViewExists && objPrototype === DataView.prototype) {
                return 'DataView'
              }

              /* ! Spec Conformance
               * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
               * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
               * Test: `Object.prototype.toString.call(new Map().entries())``
               *  - Edge <=13 === "[object Object]"
               */
              if (mapExists && objPrototype === mapIteratorPrototype) {
                return 'Map Iterator'
              }

              /* ! Spec Conformance
               * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
               * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
               * Test: `Object.prototype.toString.call(new Set().entries())``
               *  - Edge <=13 === "[object Object]"
               */
              if (setExists && objPrototype === setIteratorPrototype) {
                return 'Set Iterator'
              }

              /* ! Spec Conformance
               * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
               * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
               * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
               *  - Edge <=13 === "[object Object]"
               */
              if (
                arrayIteratorExists &&
                objPrototype === arrayIteratorPrototype
              ) {
                return 'Array Iterator'
              }

              /* ! Spec Conformance
               * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
               * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
               * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
               *  - Edge <=13 === "[object Object]"
               */
              if (
                stringIteratorExists &&
                objPrototype === stringIteratorPrototype
              ) {
                return 'String Iterator'
              }

              /* ! Speed optimisation
               * Pre:
               *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
               * Post:
               *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
               */
              if (objPrototype === null) {
                return 'Object'
              }

              return Object.prototype.toString
                .call(obj)
                .slice(toStringLeftSliceLength, toStringRightSliceLength)
            }

            return typeDetect
          })
        })

        const isBufferExists = typeof Buffer !== 'undefined'
        const isBufferFromExists =
          isBufferExists && typeof Buffer.from !== 'undefined'

        const isBuffer = isBufferExists
          ? /**
             * is value is Buffer?
             *
             * @param {*} value
             * @return {boolean}
             */
            function isBuffer(value) {
              return Buffer.isBuffer(value)
            }
          : /**
             * return false
             *
             * NOTE: for Buffer unsupported
             *
             * @return {boolean}
             */
            function isBuffer() {
              return false
            }

        const copy = isBufferFromExists
          ? /**
             * copy Buffer
             *
             * @param {Buffer} value
             * @return {Buffer}
             */
            function copy(value) {
              return Buffer.from(value)
            }
          : isBufferExists
          ? /**
             * copy Buffer
             *
             * NOTE: for old node.js
             *
             * @param {Buffer} value
             * @return {Buffer}
             */
            function copy(value) {
              return new Buffer(value)
            }
          : /**
             * shallow copy
             *
             * NOTE: for Buffer unsupported
             *
             * @param {*}
             * @return {*}
             */
            function copy(value) {
              return value
            }

        /**
         * detect type of value
         *
         * @param {*} value
         * @return {string}
         */
        function detectType(value) {
          // NOTE: isBuffer must execute before type-detect,
          // because type-detect returns 'Uint8Array'.
          if (isBuffer(value)) {
            return 'Buffer'
          }

          return typeDetect(value)
        }

        /**
         * collection types
         */
        const collectionTypeSet = new Set([
          'Arguments',
          'Array',
          'Map',
          'Object',
          'Set'
        ])

        /**
         * get value from collection
         *
         * @param {Array|Object|Map|Set} collection
         * @param {string|number|symbol} key
         * @param {string} [type=null]
         * @return {*}
         */
        function get(collection, key, type = null) {
          const valueType = type || detectType(collection)

          switch (valueType) {
            case 'Arguments':
            case 'Array':
            case 'Object':
              return collection[key]
            case 'Map':
              return collection.get(key)
            case 'Set':
              // NOTE: Set.prototype.keys is alias of Set.prototype.values
              // it means key is equals value
              return key
          }
        }

        /**
         * check to type string is collection
         *
         * @param {string} type
         */
        function isCollection(type) {
          return collectionTypeSet.has(type)
        }

        /**
         * set value to collection
         *
         * @param {Array|Object|Map|Set} collection
         * @param {string|number|symbol} key
         * @param {*} value
         * @param {string} [type=null]
         * @return {Array|Object|Map|Set}
         */
        function set(collection, key, value, type = null) {
          const valueType = type || detectType(collection)

          switch (valueType) {
            case 'Arguments':
            case 'Array':
            case 'Object':
              collection[key] = value
              break
            case 'Map':
              collection.set(key, value)
              break
            case 'Set':
              collection.add(value)
              break
          }

          return collection
        }

        const freeGlobalThis =
          typeof globalThis !== 'undefined' &&
          globalThis !== null &&
          globalThis.Object === Object &&
          globalThis

        const freeGlobal =
          typeof __webpack_require__.g !== 'undefined' &&
          __webpack_require__.g !== null &&
          __webpack_require__.g.Object === Object &&
          __webpack_require__.g

        const freeSelf =
          typeof self !== 'undefined' &&
          self !== null &&
          self.Object === Object &&
          self

        const globalObject =
          freeGlobalThis || freeGlobal || freeSelf || Function('return this')()

        /**
         * copy ArrayBuffer
         *
         * @param {ArrayBuffer} value
         * @return {ArrayBuffer}
         */
        function copyArrayBuffer(value) {
          return value.slice(0)
        }

        /**
         * copy Boolean
         *
         * @param {Boolean} value
         * @return {Boolean}
         */
        function copyBoolean(value) {
          return new Boolean(value.valueOf())
        }

        /**
         * copy DataView
         *
         * @param {DataView} value
         * @return {DataView}
         */
        function copyDataView(value) {
          // TODO: copy ArrayBuffer?
          return new DataView(value.buffer)
        }

        /**
         * copy Buffer
         *
         * @param {Buffer} value
         * @return {Buffer}
         */
        function copyBuffer(value) {
          return copy(value)
        }

        /**
         * copy Date
         *
         * @param {Date} value
         * @return {Date}
         */
        function copyDate(value) {
          return new Date(value.getTime())
        }

        /**
         * copy Number
         *
         * @param {Number} value
         * @return {Number}
         */
        function copyNumber(value) {
          return new Number(value)
        }

        /**
         * copy RegExp
         *
         * @param {RegExp} value
         * @return {RegExp}
         */
        function copyRegExp(value) {
          return new RegExp(value.source, value.flags)
        }

        /**
         * copy String
         *
         * @param {String} value
         * @return {String}
         */
        function copyString(value) {
          return new String(value)
        }

        /**
         * copy TypedArray
         *
         * @param {*} value
         * @return {*}
         */
        function copyTypedArray(value, type) {
          const typedArray = globalObject[type]

          if (typedArray.from) {
            return globalObject[type].from(value)
          }

          return new globalObject[type](value)
        }

        /**
         * shallow copy
         *
         * @param {*} value
         * @return {*}
         */
        function shallowCopy(value) {
          return value
        }

        /**
         * get empty Array
         *
         * @return {Array}
         */
        function getEmptyArray() {
          return []
        }

        /**
         * get empty Map
         *
         * @return {Map}
         */
        function getEmptyMap() {
          return new Map()
        }

        /**
         * get empty Object
         *
         * @return {Object}
         */
        function getEmptyObject() {
          return {}
        }

        /**
         * get empty Set
         *
         * @return {Set}
         */
        function getEmptySet() {
          return new Set()
        }

        var copyMap = new Map([
          // deep copy
          ['ArrayBuffer', copyArrayBuffer],
          ['Boolean', copyBoolean],
          ['Buffer', copyBuffer],
          ['DataView', copyDataView],
          ['Date', copyDate],
          ['Number', copyNumber],
          ['RegExp', copyRegExp],
          ['String', copyString],

          // typed arrays
          // TODO: pass bound function
          ['Float32Array', copyTypedArray],
          ['Float64Array', copyTypedArray],
          ['Int16Array', copyTypedArray],
          ['Int32Array', copyTypedArray],
          ['Int8Array', copyTypedArray],
          ['Uint16Array', copyTypedArray],
          ['Uint32Array', copyTypedArray],
          ['Uint8Array', copyTypedArray],
          ['Uint8ClampedArray', copyTypedArray],

          // shallow copy
          ['Array Iterator', shallowCopy],
          ['Map Iterator', shallowCopy],
          ['Promise', shallowCopy],
          ['Set Iterator', shallowCopy],
          ['String Iterator', shallowCopy],
          ['function', shallowCopy],
          ['global', shallowCopy],
          // NOTE: WeakMap and WeakSet cannot get entries
          ['WeakMap', shallowCopy],
          ['WeakSet', shallowCopy],

          // primitives
          ['boolean', shallowCopy],
          ['null', shallowCopy],
          ['number', shallowCopy],
          ['string', shallowCopy],
          ['symbol', shallowCopy],
          ['undefined', shallowCopy],

          // collections
          // NOTE: return empty value, because recursively copy later.
          ['Arguments', getEmptyArray],
          ['Array', getEmptyArray],
          ['Map', getEmptyMap],
          ['Object', getEmptyObject],
          ['Set', getEmptySet]

          // NOTE: type-detect returns following types
          // 'Location'
          // 'Document'
          // 'MimeTypeArray'
          // 'PluginArray'
          // 'HTMLQuoteElement'
          // 'HTMLTableDataCellElement'
          // 'HTMLTableHeaderCellElement'

          // TODO: is type-detect never return 'object'?
          // 'object'
        ])

        /**
         * no operation
         */
        function noop() {}

        /**
         * copy value
         *
         * @param {*} value
         * @param {string} [type=null]
         * @param {Function} [customizer=noop]
         * @return {*}
         */
        function copy$1(value, type = null, customizer = noop) {
          if (arguments.length === 2 && typeof type === 'function') {
            customizer = type
            type = null
          }

          const valueType = type || detectType(value)
          const copyFunction = copyMap.get(valueType)

          if (valueType === 'Object') {
            const result = customizer(value, valueType)

            if (result !== undefined) {
              return result
            }
          }

          // NOTE: TypedArray needs pass type to argument
          return copyFunction ? copyFunction(value, valueType) : value
        }

        /**
         * deepcopy function
         *
         * @param {*} value
         * @param {Object|Function} [options]
         * @return {*}
         */
        function deepcopy(value, options = {}) {
          if (typeof options === 'function') {
            options = {
              customizer: options
            }
          }

          const {
            // TODO: before/after customizer
            customizer
            // TODO: max depth
            // depth = Infinity,
          } = options

          const valueType = detectType(value)

          if (!isCollection(valueType)) {
            return recursiveCopy(value, null, null, null)
          }

          const copiedValue = copy$1(value, valueType, customizer)

          const references = new WeakMap([[value, copiedValue]])
          const visited = new WeakSet([value])

          return recursiveCopy(value, copiedValue, references, visited)
        }

        /**
         * recursively copy
         *
         * @param {*} value target value
         * @param {*} clone clone of value
         * @param {WeakMap} references visited references of clone
         * @param {WeakSet} visited visited references of value
         * @param {Function} customizer user customize function
         * @return {*}
         */
        function recursiveCopy(value, clone, references, visited, customizer) {
          const type = detectType(value)
          const copiedValue = copy$1(value, type)

          // return if not a collection value
          if (!isCollection(type)) {
            return copiedValue
          }

          let keys

          switch (type) {
            case 'Arguments':
            case 'Array':
              keys = Object.keys(value)
              break
            case 'Object':
              keys = Object.keys(value)
              keys.push(...Object.getOwnPropertySymbols(value))
              break
            case 'Map':
            case 'Set':
              keys = value.keys()
              break
          }

          // walk within collection with iterator
          for (let collectionKey of keys) {
            const collectionValue = get(value, collectionKey, type)

            if (visited.has(collectionValue)) {
              // for [Circular]
              set(clone, collectionKey, references.get(collectionValue), type)
            } else {
              const collectionValueType = detectType(collectionValue)
              const copiedCollectionValue = copy$1(
                collectionValue,
                collectionValueType
              )

              // save reference if value is collection
              if (isCollection(collectionValueType)) {
                references.set(collectionValue, copiedCollectionValue)
                visited.add(collectionValue)
              }

              set(
                clone,
                collectionKey,
                recursiveCopy(
                  collectionValue,
                  copiedCollectionValue,
                  references,
                  visited
                ),
                type
              )
            }
          }

          // TODO: isSealed/isFrozen/isExtensible

          return clone
        }

        return deepcopy
      })
      //# sourceMappingURL=deepcopy.js.map

      /***/
    },

    /***/ 2828: /***/ (module) => {
      var DOCUMENT_NODE_TYPE = 9

      /**
       * A polyfill for Element.matches()
       */
      if (typeof Element !== 'undefined' && !Element.prototype.matches) {
        var proto = Element.prototype

        proto.matches =
          proto.matchesSelector ||
          proto.mozMatchesSelector ||
          proto.msMatchesSelector ||
          proto.oMatchesSelector ||
          proto.webkitMatchesSelector
      }

      /**
       * Finds the closest parent that matches a selector.
       *
       * @param {Element} element
       * @param {String} selector
       * @return {Function}
       */
      function closest(element, selector) {
        while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
          if (
            typeof element.matches === 'function' &&
            element.matches(selector)
          ) {
            return element
          }
          element = element.parentNode
        }
      }

      module.exports = closest

      /***/
    },

    /***/ 9438: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      var closest = __webpack_require__(2828)

      /**
       * Delegates event to a selector.
       *
       * @param {Element} element
       * @param {String} selector
       * @param {String} type
       * @param {Function} callback
       * @param {Boolean} useCapture
       * @return {Object}
       */
      function _delegate(element, selector, type, callback, useCapture) {
        var listenerFn = listener.apply(this, arguments)

        element.addEventListener(type, listenerFn, useCapture)

        return {
          destroy: function () {
            element.removeEventListener(type, listenerFn, useCapture)
          }
        }
      }

      /**
       * Delegates event to a selector.
       *
       * @param {Element|String|Array} [elements]
       * @param {String} selector
       * @param {String} type
       * @param {Function} callback
       * @param {Boolean} useCapture
       * @return {Object}
       */
      function delegate(elements, selector, type, callback, useCapture) {
        // Handle the regular Element usage
        if (typeof elements.addEventListener === 'function') {
          return _delegate.apply(null, arguments)
        }

        // Handle Element-less usage, it defaults to global delegation
        if (typeof type === 'function') {
          // Use `document` as the first parameter, then apply arguments
          // This is a short way to .unshift `arguments` without running into deoptimizations
          return _delegate.bind(null, document).apply(null, arguments)
        }

        // Handle Selector-based usage
        if (typeof elements === 'string') {
          elements = document.querySelectorAll(elements)
        }

        // Handle Array-like based usage
        return Array.prototype.map.call(elements, function (element) {
          return _delegate(element, selector, type, callback, useCapture)
        })
      }

      /**
       * Finds closest match and invokes callback.
       *
       * @param {Element} element
       * @param {String} selector
       * @param {String} type
       * @param {Function} callback
       * @return {Function}
       */
      function listener(element, selector, type, callback) {
        return function (e) {
          e.delegateTarget = closest(e.target, selector)

          if (e.delegateTarget) {
            callback.call(element, e)
          }
        }
      }

      module.exports = delegate

      /***/
    },

    /***/ 1182: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      module.exports = __webpack_require__(9269)

      /***/
    },

    /***/ 9269: /***/ (module) => {
      function toArray(value) {
        if (value === null || value === undefined) return []
        else return Array.isArray(value) ? value : [value]
      }

      /**
       * dohtml
       * @type {{create: dom.create, isValidNode: dom.isValidNode, render: dom.render}}
       */
      var dom = {
        /**
         * Create DOM element
         * @param str html string or a single tag
         * @returns {Element | Node | null}
         */
        create: function (str) {
          var element
          str = str.trim()

          if (/<.*>/g.test(str)) {
            var template = document.createElement('div')
            template.innerHTML = str
            element = template.firstChild
          } else {
            element = document.createElement(str)
          }

          if (!this.isValidNode(element)) throw new Error('Element not valid')
          return element
        },

        /**
         * Check if is a valid Node
         * @param {*} el
         * @returns {Boolean}
         */
        isValidNode: function (el) {
          return el && 'nodeType' in el
        },

        /**
         * Append multiple elements into target element
         * @param {Element} target
         * @param {Array | Element} els
         * @returns {Element | Node | Error}
         */
        render: function (target, els) {
          els = toArray(els)
          if (!this.isValidNode(target))
            throw new Error('Require a valid HTML Element')

          els.forEach(function (el) {
            target.appendChild(el)
          })
          return target
        }
      }

      module.exports = dom

      /***/
    },

    /***/ 2025: /***/ (module) => {
      ;(function webpackUniversalModuleDefinition(root, factory) {
        if (true) module.exports = factory()
        else {
          var i, a
        }
      })(self, function () {
        return /******/ (function () {
          // webpackBootstrap
          /******/ var __webpack_modules__ = {
            /***/ 3099: /***/ function (module) {
              module.exports = function (it) {
                if (typeof it != 'function') {
                  throw TypeError(String(it) + ' is not a function')
                }
                return it
              }

              /***/
            },

            /***/ 6077: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_703__
            ) {
              var isObject = __nested_webpack_require_703__(111)

              module.exports = function (it) {
                if (!isObject(it) && it !== null) {
                  throw TypeError("Can't set " + String(it) + ' as a prototype')
                }
                return it
              }

              /***/
            },

            /***/ 1223: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_1001__
            ) {
              var wellKnownSymbol = __nested_webpack_require_1001__(5112)
              var create = __nested_webpack_require_1001__(30)
              var definePropertyModule = __nested_webpack_require_1001__(3070)

              var UNSCOPABLES = wellKnownSymbol('unscopables')
              var ArrayPrototype = Array.prototype

              // Array.prototype[@@unscopables]
              // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
              if (ArrayPrototype[UNSCOPABLES] == undefined) {
                definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                  configurable: true,
                  value: create(null)
                })
              }

              // add a key to Array.prototype[@@unscopables]
              module.exports = function (key) {
                ArrayPrototype[UNSCOPABLES][key] = true
              }

              /***/
            },

            /***/ 1530: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_1715__
            ) {
              'use strict'

              var charAt = __nested_webpack_require_1715__(8710).charAt

              // `AdvanceStringIndex` abstract operation
              // https://tc39.es/ecma262/#sec-advancestringindex
              module.exports = function (S, index, unicode) {
                return index + (unicode ? charAt(S, index).length : 1)
              }

              /***/
            },

            /***/ 5787: /***/ function (module) {
              module.exports = function (it, Constructor, name) {
                if (!(it instanceof Constructor)) {
                  throw TypeError(
                    'Incorrect ' + (name ? name + ' ' : '') + 'invocation'
                  )
                }
                return it
              }

              /***/
            },

            /***/ 9670: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_2317__
            ) {
              var isObject = __nested_webpack_require_2317__(111)

              module.exports = function (it) {
                if (!isObject(it)) {
                  throw TypeError(String(it) + ' is not an object')
                }
                return it
              }

              /***/
            },

            /***/ 4019: /***/ function (module) {
              module.exports =
                typeof ArrayBuffer !== 'undefined' &&
                typeof DataView !== 'undefined'

              /***/
            },

            /***/ 260: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_2726__
            ) {
              'use strict'

              var NATIVE_ARRAY_BUFFER = __nested_webpack_require_2726__(4019)
              var DESCRIPTORS = __nested_webpack_require_2726__(9781)
              var global = __nested_webpack_require_2726__(7854)
              var isObject = __nested_webpack_require_2726__(111)
              var has = __nested_webpack_require_2726__(6656)
              var classof = __nested_webpack_require_2726__(648)
              var createNonEnumerableProperty =
                __nested_webpack_require_2726__(8880)
              var redefine = __nested_webpack_require_2726__(1320)
              var defineProperty = __nested_webpack_require_2726__(3070).f
              var getPrototypeOf = __nested_webpack_require_2726__(9518)
              var setPrototypeOf = __nested_webpack_require_2726__(7674)
              var wellKnownSymbol = __nested_webpack_require_2726__(5112)
              var uid = __nested_webpack_require_2726__(9711)

              var Int8Array = global.Int8Array
              var Int8ArrayPrototype = Int8Array && Int8Array.prototype
              var Uint8ClampedArray = global.Uint8ClampedArray
              var Uint8ClampedArrayPrototype =
                Uint8ClampedArray && Uint8ClampedArray.prototype
              var TypedArray = Int8Array && getPrototypeOf(Int8Array)
              var TypedArrayPrototype =
                Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype)
              var ObjectPrototype = Object.prototype
              var isPrototypeOf = ObjectPrototype.isPrototypeOf

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG')
              // Fixing native typed arrays in Opera Presto crashes the browser, see #595
              var NATIVE_ARRAY_BUFFER_VIEWS =
                NATIVE_ARRAY_BUFFER &&
                !!setPrototypeOf &&
                classof(global.opera) !== 'Opera'
              var TYPED_ARRAY_TAG_REQIRED = false
              var NAME

              var TypedArrayConstructorsList = {
                Int8Array: 1,
                Uint8Array: 1,
                Uint8ClampedArray: 1,
                Int16Array: 2,
                Uint16Array: 2,
                Int32Array: 4,
                Uint32Array: 4,
                Float32Array: 4,
                Float64Array: 8
              }

              var BigIntArrayConstructorsList = {
                BigInt64Array: 8,
                BigUint64Array: 8
              }

              var isView = function isView(it) {
                if (!isObject(it)) return false
                var klass = classof(it)
                return (
                  klass === 'DataView' ||
                  has(TypedArrayConstructorsList, klass) ||
                  has(BigIntArrayConstructorsList, klass)
                )
              }

              var isTypedArray = function (it) {
                if (!isObject(it)) return false
                var klass = classof(it)
                return (
                  has(TypedArrayConstructorsList, klass) ||
                  has(BigIntArrayConstructorsList, klass)
                )
              }

              var aTypedArray = function (it) {
                if (isTypedArray(it)) return it
                throw TypeError('Target is not a typed array')
              }

              var aTypedArrayConstructor = function (C) {
                if (setPrototypeOf) {
                  if (isPrototypeOf.call(TypedArray, C)) return C
                } else
                  for (var ARRAY in TypedArrayConstructorsList)
                    if (has(TypedArrayConstructorsList, NAME)) {
                      var TypedArrayConstructor = global[ARRAY]
                      if (
                        TypedArrayConstructor &&
                        (C === TypedArrayConstructor ||
                          isPrototypeOf.call(TypedArrayConstructor, C))
                      ) {
                        return C
                      }
                    }
                throw TypeError('Target is not a typed array constructor')
              }

              var exportTypedArrayMethod = function (KEY, property, forced) {
                if (!DESCRIPTORS) return
                if (forced)
                  for (var ARRAY in TypedArrayConstructorsList) {
                    var TypedArrayConstructor = global[ARRAY]
                    if (
                      TypedArrayConstructor &&
                      has(TypedArrayConstructor.prototype, KEY)
                    ) {
                      delete TypedArrayConstructor.prototype[KEY]
                    }
                  }
                if (!TypedArrayPrototype[KEY] || forced) {
                  redefine(
                    TypedArrayPrototype,
                    KEY,
                    forced
                      ? property
                      : (NATIVE_ARRAY_BUFFER_VIEWS &&
                          Int8ArrayPrototype[KEY]) ||
                          property
                  )
                }
              }

              var exportTypedArrayStaticMethod = function (
                KEY,
                property,
                forced
              ) {
                var ARRAY, TypedArrayConstructor
                if (!DESCRIPTORS) return
                if (setPrototypeOf) {
                  if (forced)
                    for (ARRAY in TypedArrayConstructorsList) {
                      TypedArrayConstructor = global[ARRAY]
                      if (
                        TypedArrayConstructor &&
                        has(TypedArrayConstructor, KEY)
                      ) {
                        delete TypedArrayConstructor[KEY]
                      }
                    }
                  if (!TypedArray[KEY] || forced) {
                    // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
                    try {
                      return redefine(
                        TypedArray,
                        KEY,
                        forced
                          ? property
                          : (NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY]) ||
                              property
                      )
                    } catch (error) {
                      /* empty */
                    }
                  } else return
                }
                for (ARRAY in TypedArrayConstructorsList) {
                  TypedArrayConstructor = global[ARRAY]
                  if (
                    TypedArrayConstructor &&
                    (!TypedArrayConstructor[KEY] || forced)
                  ) {
                    redefine(TypedArrayConstructor, KEY, property)
                  }
                }
              }

              for (NAME in TypedArrayConstructorsList) {
                if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false
              }

              // WebKit bug - typed arrays constructors prototype is Object.prototype
              if (
                !NATIVE_ARRAY_BUFFER_VIEWS ||
                typeof TypedArray != 'function' ||
                TypedArray === Function.prototype
              ) {
                // eslint-disable-next-line no-shadow -- safe
                TypedArray = function TypedArray() {
                  throw TypeError('Incorrect invocation')
                }
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray)
                  }
              }

              if (
                !NATIVE_ARRAY_BUFFER_VIEWS ||
                !TypedArrayPrototype ||
                TypedArrayPrototype === ObjectPrototype
              ) {
                TypedArrayPrototype = TypedArray.prototype
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global[NAME])
                      setPrototypeOf(
                        global[NAME].prototype,
                        TypedArrayPrototype
                      )
                  }
              }

              // WebKit bug - one more object in Uint8ClampedArray prototype chain
              if (
                NATIVE_ARRAY_BUFFER_VIEWS &&
                getPrototypeOf(Uint8ClampedArrayPrototype) !==
                  TypedArrayPrototype
              ) {
                setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype)
              }

              if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
                TYPED_ARRAY_TAG_REQIRED = true
                defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
                  get: function () {
                    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined
                  }
                })
                for (NAME in TypedArrayConstructorsList)
                  if (global[NAME]) {
                    createNonEnumerableProperty(
                      global[NAME],
                      TYPED_ARRAY_TAG,
                      NAME
                    )
                  }
              }

              module.exports = {
                NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
                TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
                aTypedArray: aTypedArray,
                aTypedArrayConstructor: aTypedArrayConstructor,
                exportTypedArrayMethod: exportTypedArrayMethod,
                exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
                isView: isView,
                isTypedArray: isTypedArray,
                TypedArray: TypedArray,
                TypedArrayPrototype: TypedArrayPrototype
              }

              /***/
            },

            /***/ 3331: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_8934__
            ) {
              'use strict'

              var global = __nested_webpack_require_8934__(7854)
              var DESCRIPTORS = __nested_webpack_require_8934__(9781)
              var NATIVE_ARRAY_BUFFER = __nested_webpack_require_8934__(4019)
              var createNonEnumerableProperty =
                __nested_webpack_require_8934__(8880)
              var redefineAll = __nested_webpack_require_8934__(2248)
              var fails = __nested_webpack_require_8934__(7293)
              var anInstance = __nested_webpack_require_8934__(5787)
              var toInteger = __nested_webpack_require_8934__(9958)
              var toLength = __nested_webpack_require_8934__(7466)
              var toIndex = __nested_webpack_require_8934__(7067)
              var IEEE754 = __nested_webpack_require_8934__(1179)
              var getPrototypeOf = __nested_webpack_require_8934__(9518)
              var setPrototypeOf = __nested_webpack_require_8934__(7674)
              var getOwnPropertyNames = __nested_webpack_require_8934__(8006).f
              var defineProperty = __nested_webpack_require_8934__(3070).f
              var arrayFill = __nested_webpack_require_8934__(1285)
              var setToStringTag = __nested_webpack_require_8934__(8003)
              var InternalStateModule = __nested_webpack_require_8934__(9909)

              var getInternalState = InternalStateModule.get
              var setInternalState = InternalStateModule.set
              var ARRAY_BUFFER = 'ArrayBuffer'
              var DATA_VIEW = 'DataView'
              var PROTOTYPE = 'prototype'
              var WRONG_LENGTH = 'Wrong length'
              var WRONG_INDEX = 'Wrong index'
              var NativeArrayBuffer = global[ARRAY_BUFFER]
              var $ArrayBuffer = NativeArrayBuffer
              var $DataView = global[DATA_VIEW]
              var $DataViewPrototype = $DataView && $DataView[PROTOTYPE]
              var ObjectPrototype = Object.prototype
              var RangeError = global.RangeError

              var packIEEE754 = IEEE754.pack
              var unpackIEEE754 = IEEE754.unpack

              var packInt8 = function (number) {
                return [number & 0xff]
              }

              var packInt16 = function (number) {
                return [number & 0xff, (number >> 8) & 0xff]
              }

              var packInt32 = function (number) {
                return [
                  number & 0xff,
                  (number >> 8) & 0xff,
                  (number >> 16) & 0xff,
                  (number >> 24) & 0xff
                ]
              }

              var unpackInt32 = function (buffer) {
                return (
                  (buffer[3] << 24) |
                  (buffer[2] << 16) |
                  (buffer[1] << 8) |
                  buffer[0]
                )
              }

              var packFloat32 = function (number) {
                return packIEEE754(number, 23, 4)
              }

              var packFloat64 = function (number) {
                return packIEEE754(number, 52, 8)
              }

              var addGetter = function (Constructor, key) {
                defineProperty(Constructor[PROTOTYPE], key, {
                  get: function () {
                    return getInternalState(this)[key]
                  }
                })
              }

              var get = function (view, count, index, isLittleEndian) {
                var intIndex = toIndex(index)
                var store = getInternalState(view)
                if (intIndex + count > store.byteLength)
                  throw RangeError(WRONG_INDEX)
                var bytes = getInternalState(store.buffer).bytes
                var start = intIndex + store.byteOffset
                var pack = bytes.slice(start, start + count)
                return isLittleEndian ? pack : pack.reverse()
              }

              var set = function (
                view,
                count,
                index,
                conversion,
                value,
                isLittleEndian
              ) {
                var intIndex = toIndex(index)
                var store = getInternalState(view)
                if (intIndex + count > store.byteLength)
                  throw RangeError(WRONG_INDEX)
                var bytes = getInternalState(store.buffer).bytes
                var start = intIndex + store.byteOffset
                var pack = conversion(+value)
                for (var i = 0; i < count; i++)
                  bytes[start + i] = pack[isLittleEndian ? i : count - i - 1]
              }

              if (!NATIVE_ARRAY_BUFFER) {
                $ArrayBuffer = function ArrayBuffer(length) {
                  anInstance(this, $ArrayBuffer, ARRAY_BUFFER)
                  var byteLength = toIndex(length)
                  setInternalState(this, {
                    bytes: arrayFill.call(new Array(byteLength), 0),
                    byteLength: byteLength
                  })
                  if (!DESCRIPTORS) this.byteLength = byteLength
                }

                $DataView = function DataView(buffer, byteOffset, byteLength) {
                  anInstance(this, $DataView, DATA_VIEW)
                  anInstance(buffer, $ArrayBuffer, DATA_VIEW)
                  var bufferLength = getInternalState(buffer).byteLength
                  var offset = toInteger(byteOffset)
                  if (offset < 0 || offset > bufferLength)
                    throw RangeError('Wrong offset')
                  byteLength =
                    byteLength === undefined
                      ? bufferLength - offset
                      : toLength(byteLength)
                  if (offset + byteLength > bufferLength)
                    throw RangeError(WRONG_LENGTH)
                  setInternalState(this, {
                    buffer: buffer,
                    byteLength: byteLength,
                    byteOffset: offset
                  })
                  if (!DESCRIPTORS) {
                    this.buffer = buffer
                    this.byteLength = byteLength
                    this.byteOffset = offset
                  }
                }

                if (DESCRIPTORS) {
                  addGetter($ArrayBuffer, 'byteLength')
                  addGetter($DataView, 'buffer')
                  addGetter($DataView, 'byteLength')
                  addGetter($DataView, 'byteOffset')
                }

                redefineAll($DataView[PROTOTYPE], {
                  getInt8: function getInt8(byteOffset) {
                    return (get(this, 1, byteOffset)[0] << 24) >> 24
                  },
                  getUint8: function getUint8(byteOffset) {
                    return get(this, 1, byteOffset)[0]
                  },
                  getInt16: function getInt16(byteOffset /* , littleEndian */) {
                    var bytes = get(
                      this,
                      2,
                      byteOffset,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                    return (((bytes[1] << 8) | bytes[0]) << 16) >> 16
                  },
                  getUint16: function getUint16(
                    byteOffset /* , littleEndian */
                  ) {
                    var bytes = get(
                      this,
                      2,
                      byteOffset,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                    return (bytes[1] << 8) | bytes[0]
                  },
                  getInt32: function getInt32(byteOffset /* , littleEndian */) {
                    return unpackInt32(
                      get(
                        this,
                        4,
                        byteOffset,
                        arguments.length > 1 ? arguments[1] : undefined
                      )
                    )
                  },
                  getUint32: function getUint32(
                    byteOffset /* , littleEndian */
                  ) {
                    return (
                      unpackInt32(
                        get(
                          this,
                          4,
                          byteOffset,
                          arguments.length > 1 ? arguments[1] : undefined
                        )
                      ) >>> 0
                    )
                  },
                  getFloat32: function getFloat32(
                    byteOffset /* , littleEndian */
                  ) {
                    return unpackIEEE754(
                      get(
                        this,
                        4,
                        byteOffset,
                        arguments.length > 1 ? arguments[1] : undefined
                      ),
                      23
                    )
                  },
                  getFloat64: function getFloat64(
                    byteOffset /* , littleEndian */
                  ) {
                    return unpackIEEE754(
                      get(
                        this,
                        8,
                        byteOffset,
                        arguments.length > 1 ? arguments[1] : undefined
                      ),
                      52
                    )
                  },
                  setInt8: function setInt8(byteOffset, value) {
                    set(this, 1, byteOffset, packInt8, value)
                  },
                  setUint8: function setUint8(byteOffset, value) {
                    set(this, 1, byteOffset, packInt8, value)
                  },
                  setInt16: function setInt16(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      2,
                      byteOffset,
                      packInt16,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setUint16: function setUint16(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      2,
                      byteOffset,
                      packInt16,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setInt32: function setInt32(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      4,
                      byteOffset,
                      packInt32,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setUint32: function setUint32(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      4,
                      byteOffset,
                      packInt32,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setFloat32: function setFloat32(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      4,
                      byteOffset,
                      packFloat32,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setFloat64: function setFloat64(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      8,
                      byteOffset,
                      packFloat64,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  }
                })
              } else {
                /* eslint-disable no-new -- required for testing */
                if (
                  !fails(function () {
                    NativeArrayBuffer(1)
                  }) ||
                  !fails(function () {
                    new NativeArrayBuffer(-1)
                  }) ||
                  fails(function () {
                    new NativeArrayBuffer()
                    new NativeArrayBuffer(1.5)
                    new NativeArrayBuffer(NaN)
                    return NativeArrayBuffer.name != ARRAY_BUFFER
                  })
                ) {
                  /* eslint-enable no-new -- required for testing */
                  $ArrayBuffer = function ArrayBuffer(length) {
                    anInstance(this, $ArrayBuffer)
                    return new NativeArrayBuffer(toIndex(length))
                  }
                  var ArrayBufferPrototype = ($ArrayBuffer[PROTOTYPE] =
                    NativeArrayBuffer[PROTOTYPE])
                  for (
                    var keys = getOwnPropertyNames(NativeArrayBuffer),
                      j = 0,
                      key;
                    keys.length > j;

                  ) {
                    if (!((key = keys[j++]) in $ArrayBuffer)) {
                      createNonEnumerableProperty(
                        $ArrayBuffer,
                        key,
                        NativeArrayBuffer[key]
                      )
                    }
                  }
                  ArrayBufferPrototype.constructor = $ArrayBuffer
                }

                // WebKit bug - the same parent prototype for typed arrays and data view
                if (
                  setPrototypeOf &&
                  getPrototypeOf($DataViewPrototype) !== ObjectPrototype
                ) {
                  setPrototypeOf($DataViewPrototype, ObjectPrototype)
                }

                // iOS Safari 7.x bug
                var testView = new $DataView(new $ArrayBuffer(2))
                var nativeSetInt8 = $DataViewPrototype.setInt8
                testView.setInt8(0, 2147483648)
                testView.setInt8(1, 2147483649)
                if (testView.getInt8(0) || !testView.getInt8(1))
                  redefineAll(
                    $DataViewPrototype,
                    {
                      setInt8: function setInt8(byteOffset, value) {
                        nativeSetInt8.call(
                          this,
                          byteOffset,
                          (value << 24) >> 24
                        )
                      },
                      setUint8: function setUint8(byteOffset, value) {
                        nativeSetInt8.call(
                          this,
                          byteOffset,
                          (value << 24) >> 24
                        )
                      }
                    },
                    { unsafe: true }
                  )
              }

              setToStringTag($ArrayBuffer, ARRAY_BUFFER)
              setToStringTag($DataView, DATA_VIEW)

              module.exports = {
                ArrayBuffer: $ArrayBuffer,
                DataView: $DataView
              }

              /***/
            },

            /***/ 1048: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_17881__
            ) {
              'use strict'

              var toObject = __nested_webpack_require_17881__(7908)
              var toAbsoluteIndex = __nested_webpack_require_17881__(1400)
              var toLength = __nested_webpack_require_17881__(7466)

              var min = Math.min

              // `Array.prototype.copyWithin` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.copywithin
              module.exports =
                [].copyWithin ||
                function copyWithin(
                  target /* = 0 */,
                  start /* = 0, end = @length */
                ) {
                  var O = toObject(this)
                  var len = toLength(O.length)
                  var to = toAbsoluteIndex(target, len)
                  var from = toAbsoluteIndex(start, len)
                  var end = arguments.length > 2 ? arguments[2] : undefined
                  var count = min(
                    (end === undefined ? len : toAbsoluteIndex(end, len)) -
                      from,
                    len - to
                  )
                  var inc = 1
                  if (from < to && to < from + count) {
                    inc = -1
                    from += count - 1
                    to += count - 1
                  }
                  while (count-- > 0) {
                    if (from in O) O[to] = O[from]
                    else delete O[to]
                    to += inc
                    from += inc
                  }
                  return O
                }

              /***/
            },

            /***/ 1285: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_18911__
            ) {
              'use strict'

              var toObject = __nested_webpack_require_18911__(7908)
              var toAbsoluteIndex = __nested_webpack_require_18911__(1400)
              var toLength = __nested_webpack_require_18911__(7466)

              // `Array.prototype.fill` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.fill
              module.exports = function fill(
                value /* , start = 0, end = @length */
              ) {
                var O = toObject(this)
                var length = toLength(O.length)
                var argumentsLength = arguments.length
                var index = toAbsoluteIndex(
                  argumentsLength > 1 ? arguments[1] : undefined,
                  length
                )
                var end = argumentsLength > 2 ? arguments[2] : undefined
                var endPos =
                  end === undefined ? length : toAbsoluteIndex(end, length)
                while (endPos > index) O[index++] = value
                return O
              }

              /***/
            },

            /***/ 8533: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_19717__
            ) {
              'use strict'

              var $forEach = __nested_webpack_require_19717__(2092).forEach
              var arrayMethodIsStrict = __nested_webpack_require_19717__(9341)

              var STRICT_METHOD = arrayMethodIsStrict('forEach')

              // `Array.prototype.forEach` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.foreach
              module.exports = !STRICT_METHOD
                ? function forEach(callbackfn /* , thisArg */) {
                    return $forEach(
                      this,
                      callbackfn,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                  }
                : [].forEach

              /***/
            },

            /***/ 8457: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_20278__
            ) {
              'use strict'

              var bind = __nested_webpack_require_20278__(9974)
              var toObject = __nested_webpack_require_20278__(7908)
              var callWithSafeIterationClosing =
                __nested_webpack_require_20278__(3411)
              var isArrayIteratorMethod = __nested_webpack_require_20278__(7659)
              var toLength = __nested_webpack_require_20278__(7466)
              var createProperty = __nested_webpack_require_20278__(6135)
              var getIteratorMethod = __nested_webpack_require_20278__(1246)

              // `Array.from` method implementation
              // https://tc39.es/ecma262/#sec-array.from
              module.exports = function from(
                arrayLike /* , mapfn = undefined, thisArg = undefined */
              ) {
                var O = toObject(arrayLike)
                var C = typeof this == 'function' ? this : Array
                var argumentsLength = arguments.length
                var mapfn = argumentsLength > 1 ? arguments[1] : undefined
                var mapping = mapfn !== undefined
                var iteratorMethod = getIteratorMethod(O)
                var index = 0
                var length, result, step, iterator, next, value
                if (mapping)
                  mapfn = bind(
                    mapfn,
                    argumentsLength > 2 ? arguments[2] : undefined,
                    2
                  )
                // if the target is not iterable or it's an array with the default iterator - use a simple case
                if (
                  iteratorMethod != undefined &&
                  !(C == Array && isArrayIteratorMethod(iteratorMethod))
                ) {
                  iterator = iteratorMethod.call(O)
                  next = iterator.next
                  result = new C()
                  for (; !(step = next.call(iterator)).done; index++) {
                    value = mapping
                      ? callWithSafeIterationClosing(
                          iterator,
                          mapfn,
                          [step.value, index],
                          true
                        )
                      : step.value
                    createProperty(result, index, value)
                  }
                } else {
                  length = toLength(O.length)
                  result = new C(length)
                  for (; length > index; index++) {
                    value = mapping ? mapfn(O[index], index) : O[index]
                    createProperty(result, index, value)
                  }
                }
                result.length = index
                return result
              }

              /***/
            },

            /***/ 1318: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_22092__
            ) {
              var toIndexedObject = __nested_webpack_require_22092__(5656)
              var toLength = __nested_webpack_require_22092__(7466)
              var toAbsoluteIndex = __nested_webpack_require_22092__(1400)

              // `Array.prototype.{ indexOf, includes }` methods implementation
              var createMethod = function (IS_INCLUDES) {
                return function ($this, el, fromIndex) {
                  var O = toIndexedObject($this)
                  var length = toLength(O.length)
                  var index = toAbsoluteIndex(fromIndex, length)
                  var value
                  // Array#includes uses SameValueZero equality algorithm
                  // eslint-disable-next-line no-self-compare -- NaN check
                  if (IS_INCLUDES && el != el)
                    while (length > index) {
                      value = O[index++]
                      // eslint-disable-next-line no-self-compare -- NaN check
                      if (value != value) return true
                      // Array#indexOf ignores holes, Array#includes - not
                    }
                  else
                    for (; length > index; index++) {
                      if ((IS_INCLUDES || index in O) && O[index] === el)
                        return IS_INCLUDES || index || 0
                    }
                  return !IS_INCLUDES && -1
                }
              }

              module.exports = {
                // `Array.prototype.includes` method
                // https://tc39.es/ecma262/#sec-array.prototype.includes
                includes: createMethod(true),
                // `Array.prototype.indexOf` method
                // https://tc39.es/ecma262/#sec-array.prototype.indexof
                indexOf: createMethod(false)
              }

              /***/
            },

            /***/ 2092: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_23446__
            ) {
              var bind = __nested_webpack_require_23446__(9974)
              var IndexedObject = __nested_webpack_require_23446__(8361)
              var toObject = __nested_webpack_require_23446__(7908)
              var toLength = __nested_webpack_require_23446__(7466)
              var arraySpeciesCreate = __nested_webpack_require_23446__(5417)

              var push = [].push

              // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
              var createMethod = function (TYPE) {
                var IS_MAP = TYPE == 1
                var IS_FILTER = TYPE == 2
                var IS_SOME = TYPE == 3
                var IS_EVERY = TYPE == 4
                var IS_FIND_INDEX = TYPE == 6
                var IS_FILTER_OUT = TYPE == 7
                var NO_HOLES = TYPE == 5 || IS_FIND_INDEX
                return function ($this, callbackfn, that, specificCreate) {
                  var O = toObject($this)
                  var self = IndexedObject(O)
                  var boundFunction = bind(callbackfn, that, 3)
                  var length = toLength(self.length)
                  var index = 0
                  var create = specificCreate || arraySpeciesCreate
                  var target = IS_MAP
                    ? create($this, length)
                    : IS_FILTER || IS_FILTER_OUT
                    ? create($this, 0)
                    : undefined
                  var value, result
                  for (; length > index; index++)
                    if (NO_HOLES || index in self) {
                      value = self[index]
                      result = boundFunction(value, index, O)
                      if (TYPE) {
                        if (IS_MAP) target[index] = result // map
                        else if (result)
                          switch (TYPE) {
                            case 3:
                              return true // some
                            case 5:
                              return value // find
                            case 6:
                              return index // findIndex
                            case 2:
                              push.call(target, value) // filter
                          }
                        else
                          switch (TYPE) {
                            case 4:
                              return false // every
                            case 7:
                              push.call(target, value) // filterOut
                          }
                      }
                    }
                  return IS_FIND_INDEX
                    ? -1
                    : IS_SOME || IS_EVERY
                    ? IS_EVERY
                    : target
                }
              }

              module.exports = {
                // `Array.prototype.forEach` method
                // https://tc39.es/ecma262/#sec-array.prototype.foreach
                forEach: createMethod(0),
                // `Array.prototype.map` method
                // https://tc39.es/ecma262/#sec-array.prototype.map
                map: createMethod(1),
                // `Array.prototype.filter` method
                // https://tc39.es/ecma262/#sec-array.prototype.filter
                filter: createMethod(2),
                // `Array.prototype.some` method
                // https://tc39.es/ecma262/#sec-array.prototype.some
                some: createMethod(3),
                // `Array.prototype.every` method
                // https://tc39.es/ecma262/#sec-array.prototype.every
                every: createMethod(4),
                // `Array.prototype.find` method
                // https://tc39.es/ecma262/#sec-array.prototype.find
                find: createMethod(5),
                // `Array.prototype.findIndex` method
                // https://tc39.es/ecma262/#sec-array.prototype.findIndex
                findIndex: createMethod(6),
                // `Array.prototype.filterOut` method
                // https://github.com/tc39/proposal-array-filtering
                filterOut: createMethod(7)
              }

              /***/
            },

            /***/ 6583: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_26271__
            ) {
              'use strict'

              var toIndexedObject = __nested_webpack_require_26271__(5656)
              var toInteger = __nested_webpack_require_26271__(9958)
              var toLength = __nested_webpack_require_26271__(7466)
              var arrayMethodIsStrict = __nested_webpack_require_26271__(9341)

              var min = Math.min
              var nativeLastIndexOf = [].lastIndexOf
              var NEGATIVE_ZERO =
                !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0
              var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf')
              var FORCED = NEGATIVE_ZERO || !STRICT_METHOD

              // `Array.prototype.lastIndexOf` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.lastindexof
              module.exports = FORCED
                ? function lastIndexOf(
                    searchElement /* , fromIndex = @[*-1] */
                  ) {
                    // convert -0 to +0
                    if (NEGATIVE_ZERO)
                      return nativeLastIndexOf.apply(this, arguments) || 0
                    var O = toIndexedObject(this)
                    var length = toLength(O.length)
                    var index = length - 1
                    if (arguments.length > 1)
                      index = min(index, toInteger(arguments[1]))
                    if (index < 0) index = length + index
                    for (; index >= 0; index--)
                      if (index in O && O[index] === searchElement)
                        return index || 0
                    return -1
                  }
                : nativeLastIndexOf

              /***/
            },

            /***/ 1194: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_27452__
            ) {
              var fails = __nested_webpack_require_27452__(7293)
              var wellKnownSymbol = __nested_webpack_require_27452__(5112)
              var V8_VERSION = __nested_webpack_require_27452__(7392)

              var SPECIES = wellKnownSymbol('species')

              module.exports = function (METHOD_NAME) {
                // We can't use this feature detection in V8 since it causes
                // deoptimization and serious performance degradation
                // https://github.com/zloirock/core-js/issues/677
                return (
                  V8_VERSION >= 51 ||
                  !fails(function () {
                    var array = []
                    var constructor = (array.constructor = {})
                    constructor[SPECIES] = function () {
                      return { foo: 1 }
                    }
                    return array[METHOD_NAME](Boolean).foo !== 1
                  })
                )
              }

              /***/
            },

            /***/ 9341: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_28188__
            ) {
              'use strict'

              var fails = __nested_webpack_require_28188__(7293)

              module.exports = function (METHOD_NAME, argument) {
                var method = [][METHOD_NAME]
                return (
                  !!method &&
                  fails(function () {
                    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
                    method.call(
                      null,
                      argument ||
                        function () {
                          throw 1
                        },
                      1
                    )
                  })
                )
              }

              /***/
            },

            /***/ 3671: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_28629__
            ) {
              var aFunction = __nested_webpack_require_28629__(3099)
              var toObject = __nested_webpack_require_28629__(7908)
              var IndexedObject = __nested_webpack_require_28629__(8361)
              var toLength = __nested_webpack_require_28629__(7466)

              // `Array.prototype.{ reduce, reduceRight }` methods implementation
              var createMethod = function (IS_RIGHT) {
                return function (that, callbackfn, argumentsLength, memo) {
                  aFunction(callbackfn)
                  var O = toObject(that)
                  var self = IndexedObject(O)
                  var length = toLength(O.length)
                  var index = IS_RIGHT ? length - 1 : 0
                  var i = IS_RIGHT ? -1 : 1
                  if (argumentsLength < 2)
                    while (true) {
                      if (index in self) {
                        memo = self[index]
                        index += i
                        break
                      }
                      index += i
                      if (IS_RIGHT ? index < 0 : length <= index) {
                        throw TypeError(
                          'Reduce of empty array with no initial value'
                        )
                      }
                    }
                  for (; IS_RIGHT ? index >= 0 : length > index; index += i)
                    if (index in self) {
                      memo = callbackfn(memo, self[index], index, O)
                    }
                  return memo
                }
              }

              module.exports = {
                // `Array.prototype.reduce` method
                // https://tc39.es/ecma262/#sec-array.prototype.reduce
                left: createMethod(false),
                // `Array.prototype.reduceRight` method
                // https://tc39.es/ecma262/#sec-array.prototype.reduceright
                right: createMethod(true)
              }

              /***/
            },

            /***/ 5417: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_30017__
            ) {
              var isObject = __nested_webpack_require_30017__(111)
              var isArray = __nested_webpack_require_30017__(3157)
              var wellKnownSymbol = __nested_webpack_require_30017__(5112)

              var SPECIES = wellKnownSymbol('species')

              // `ArraySpeciesCreate` abstract operation
              // https://tc39.es/ecma262/#sec-arrayspeciescreate
              module.exports = function (originalArray, length) {
                var C
                if (isArray(originalArray)) {
                  C = originalArray.constructor
                  // cross-realm fallback
                  if (
                    typeof C == 'function' &&
                    (C === Array || isArray(C.prototype))
                  )
                    C = undefined
                  else if (isObject(C)) {
                    C = C[SPECIES]
                    if (C === null) C = undefined
                  }
                }
                return new (C === undefined ? Array : C)(
                  length === 0 ? 0 : length
                )
              }

              /***/
            },

            /***/ 3411: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_30798__
            ) {
              var anObject = __nested_webpack_require_30798__(9670)
              var iteratorClose = __nested_webpack_require_30798__(9212)

              // call something on iterator step with safe closing on error
              module.exports = function (iterator, fn, value, ENTRIES) {
                try {
                  return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value)
                  // 7.4.6 IteratorClose(iterator, completion)
                } catch (error) {
                  iteratorClose(iterator)
                  throw error
                }
              }

              /***/
            },

            /***/ 7072: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_31303__
            ) {
              var wellKnownSymbol = __nested_webpack_require_31303__(5112)

              var ITERATOR = wellKnownSymbol('iterator')
              var SAFE_CLOSING = false

              try {
                var called = 0
                var iteratorWithReturn = {
                  next: function () {
                    return { done: !!called++ }
                  },
                  return: function () {
                    SAFE_CLOSING = true
                  }
                }
                iteratorWithReturn[ITERATOR] = function () {
                  return this
                }
                // eslint-disable-next-line no-throw-literal -- required for testing
                Array.from(iteratorWithReturn, function () {
                  throw 2
                })
              } catch (error) {
                /* empty */
              }

              module.exports = function (exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING) return false
                var ITERATION_SUPPORT = false
                try {
                  var object = {}
                  object[ITERATOR] = function () {
                    return {
                      next: function () {
                        return { done: (ITERATION_SUPPORT = true) }
                      }
                    }
                  }
                  exec(object)
                } catch (error) {
                  /* empty */
                }
                return ITERATION_SUPPORT
              }

              /***/
            },

            /***/ 4326: /***/ function (module) {
              var toString = {}.toString

              module.exports = function (it) {
                return toString.call(it).slice(8, -1)
              }

              /***/
            },

            /***/ 648: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_32503__
            ) {
              var TO_STRING_TAG_SUPPORT = __nested_webpack_require_32503__(1694)
              var classofRaw = __nested_webpack_require_32503__(4326)
              var wellKnownSymbol = __nested_webpack_require_32503__(5112)

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              // ES3 wrong here
              var CORRECT_ARGUMENTS =
                classofRaw(
                  (function () {
                    return arguments
                  })()
                ) == 'Arguments'

              // fallback for IE11 Script Access Denied error
              var tryGet = function (it, key) {
                try {
                  return it[key]
                } catch (error) {
                  /* empty */
                }
              }

              // getting tag from ES6+ `Object.prototype.toString`
              module.exports = TO_STRING_TAG_SUPPORT
                ? classofRaw
                : function (it) {
                    var O, tag, result
                    return it === undefined
                      ? 'Undefined'
                      : it === null
                      ? 'Null'
                      : // @@toStringTag case
                      typeof (tag = tryGet((O = Object(it)), TO_STRING_TAG)) ==
                        'string'
                      ? tag
                      : // builtinTag case
                      CORRECT_ARGUMENTS
                      ? classofRaw(O)
                      : // ES3 arguments fallback
                      (result = classofRaw(O)) == 'Object' &&
                        typeof O.callee == 'function'
                      ? 'Arguments'
                      : result
                  }

              /***/
            },

            /***/ 9920: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_33565__
            ) {
              var has = __nested_webpack_require_33565__(6656)
              var ownKeys = __nested_webpack_require_33565__(3887)
              var getOwnPropertyDescriptorModule =
                __nested_webpack_require_33565__(1236)
              var definePropertyModule = __nested_webpack_require_33565__(3070)

              module.exports = function (target, source) {
                var keys = ownKeys(source)
                var defineProperty = definePropertyModule.f
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i]
                  if (!has(target, key))
                    defineProperty(
                      target,
                      key,
                      getOwnPropertyDescriptor(source, key)
                    )
                }
              }

              /***/
            },

            /***/ 8544: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_34217__
            ) {
              var fails = __nested_webpack_require_34217__(7293)

              module.exports = !fails(function () {
                function F() {
                  /* empty */
                }
                F.prototype.constructor = null
                return Object.getPrototypeOf(new F()) !== F.prototype
              })

              /***/
            },

            /***/ 4994: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_34520__
            ) {
              'use strict'

              var IteratorPrototype =
                __nested_webpack_require_34520__(3383).IteratorPrototype
              var create = __nested_webpack_require_34520__(30)
              var createPropertyDescriptor =
                __nested_webpack_require_34520__(9114)
              var setToStringTag = __nested_webpack_require_34520__(8003)
              var Iterators = __nested_webpack_require_34520__(7497)

              var returnThis = function () {
                return this
              }

              module.exports = function (IteratorConstructor, NAME, next) {
                var TO_STRING_TAG = NAME + ' Iterator'
                IteratorConstructor.prototype = create(IteratorPrototype, {
                  next: createPropertyDescriptor(1, next)
                })
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true)
                Iterators[TO_STRING_TAG] = returnThis
                return IteratorConstructor
              }

              /***/
            },

            /***/ 8880: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_35290__
            ) {
              var DESCRIPTORS = __nested_webpack_require_35290__(9781)
              var definePropertyModule = __nested_webpack_require_35290__(3070)
              var createPropertyDescriptor =
                __nested_webpack_require_35290__(9114)

              module.exports = DESCRIPTORS
                ? function (object, key, value) {
                    return definePropertyModule.f(
                      object,
                      key,
                      createPropertyDescriptor(1, value)
                    )
                  }
                : function (object, key, value) {
                    object[key] = value
                    return object
                  }

              /***/
            },

            /***/ 9114: /***/ function (module) {
              module.exports = function (bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value: value
                }
              }

              /***/
            },

            /***/ 6135: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_35996__
            ) {
              'use strict'

              var toPrimitive = __nested_webpack_require_35996__(7593)
              var definePropertyModule = __nested_webpack_require_35996__(3070)
              var createPropertyDescriptor =
                __nested_webpack_require_35996__(9114)

              module.exports = function (object, key, value) {
                var propertyKey = toPrimitive(key)
                if (propertyKey in object)
                  definePropertyModule.f(
                    object,
                    propertyKey,
                    createPropertyDescriptor(0, value)
                  )
                else object[propertyKey] = value
              }

              /***/
            },

            /***/ 654: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_36503__
            ) {
              'use strict'

              var $ = __nested_webpack_require_36503__(2109)
              var createIteratorConstructor =
                __nested_webpack_require_36503__(4994)
              var getPrototypeOf = __nested_webpack_require_36503__(9518)
              var setPrototypeOf = __nested_webpack_require_36503__(7674)
              var setToStringTag = __nested_webpack_require_36503__(8003)
              var createNonEnumerableProperty =
                __nested_webpack_require_36503__(8880)
              var redefine = __nested_webpack_require_36503__(1320)
              var wellKnownSymbol = __nested_webpack_require_36503__(5112)
              var IS_PURE = __nested_webpack_require_36503__(1913)
              var Iterators = __nested_webpack_require_36503__(7497)
              var IteratorsCore = __nested_webpack_require_36503__(3383)

              var IteratorPrototype = IteratorsCore.IteratorPrototype
              var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS
              var ITERATOR = wellKnownSymbol('iterator')
              var KEYS = 'keys'
              var VALUES = 'values'
              var ENTRIES = 'entries'

              var returnThis = function () {
                return this
              }

              module.exports = function (
                Iterable,
                NAME,
                IteratorConstructor,
                next,
                DEFAULT,
                IS_SET,
                FORCED
              ) {
                createIteratorConstructor(IteratorConstructor, NAME, next)

                var getIterationMethod = function (KIND) {
                  if (KIND === DEFAULT && defaultIterator)
                    return defaultIterator
                  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                    return IterablePrototype[KIND]
                  switch (KIND) {
                    case KEYS:
                      return function keys() {
                        return new IteratorConstructor(this, KIND)
                      }
                    case VALUES:
                      return function values() {
                        return new IteratorConstructor(this, KIND)
                      }
                    case ENTRIES:
                      return function entries() {
                        return new IteratorConstructor(this, KIND)
                      }
                  }
                  return function () {
                    return new IteratorConstructor(this)
                  }
                }

                var TO_STRING_TAG = NAME + ' Iterator'
                var INCORRECT_VALUES_NAME = false
                var IterablePrototype = Iterable.prototype
                var nativeIterator =
                  IterablePrototype[ITERATOR] ||
                  IterablePrototype['@@iterator'] ||
                  (DEFAULT && IterablePrototype[DEFAULT])
                var defaultIterator =
                  (!BUGGY_SAFARI_ITERATORS && nativeIterator) ||
                  getIterationMethod(DEFAULT)
                var anyNativeIterator =
                  NAME == 'Array'
                    ? IterablePrototype.entries || nativeIterator
                    : nativeIterator
                var CurrentIteratorPrototype, methods, KEY

                // fix native
                if (anyNativeIterator) {
                  CurrentIteratorPrototype = getPrototypeOf(
                    anyNativeIterator.call(new Iterable())
                  )
                  if (
                    IteratorPrototype !== Object.prototype &&
                    CurrentIteratorPrototype.next
                  ) {
                    if (
                      !IS_PURE &&
                      getPrototypeOf(CurrentIteratorPrototype) !==
                        IteratorPrototype
                    ) {
                      if (setPrototypeOf) {
                        setPrototypeOf(
                          CurrentIteratorPrototype,
                          IteratorPrototype
                        )
                      } else if (
                        typeof CurrentIteratorPrototype[ITERATOR] != 'function'
                      ) {
                        createNonEnumerableProperty(
                          CurrentIteratorPrototype,
                          ITERATOR,
                          returnThis
                        )
                      }
                    }
                    // Set @@toStringTag to native iterators
                    setToStringTag(
                      CurrentIteratorPrototype,
                      TO_STRING_TAG,
                      true,
                      true
                    )
                    if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis
                  }
                }

                // fix Array#{values, @@iterator}.name in V8 / FF
                if (
                  DEFAULT == VALUES &&
                  nativeIterator &&
                  nativeIterator.name !== VALUES
                ) {
                  INCORRECT_VALUES_NAME = true
                  defaultIterator = function values() {
                    return nativeIterator.call(this)
                  }
                }

                // define iterator
                if (
                  (!IS_PURE || FORCED) &&
                  IterablePrototype[ITERATOR] !== defaultIterator
                ) {
                  createNonEnumerableProperty(
                    IterablePrototype,
                    ITERATOR,
                    defaultIterator
                  )
                }
                Iterators[NAME] = defaultIterator

                // export additional methods
                if (DEFAULT) {
                  methods = {
                    values: getIterationMethod(VALUES),
                    keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                    entries: getIterationMethod(ENTRIES)
                  }
                  if (FORCED)
                    for (KEY in methods) {
                      if (
                        BUGGY_SAFARI_ITERATORS ||
                        INCORRECT_VALUES_NAME ||
                        !(KEY in IterablePrototype)
                      ) {
                        redefine(IterablePrototype, KEY, methods[KEY])
                      }
                    }
                  else
                    $(
                      {
                        target: NAME,
                        proto: true,
                        forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                      },
                      methods
                    )
                }

                return methods
              }

              /***/
            },

            /***/ 9781: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_40475__
            ) {
              var fails = __nested_webpack_require_40475__(7293)

              // Detect IE8's incomplete defineProperty implementation
              module.exports = !fails(function () {
                return (
                  Object.defineProperty({}, 1, {
                    get: function () {
                      return 7
                    }
                  })[1] != 7
                )
              })

              /***/
            },

            /***/ 317: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_40795__
            ) {
              var global = __nested_webpack_require_40795__(7854)
              var isObject = __nested_webpack_require_40795__(111)

              var document = global.document
              // typeof document.createElement is 'object' in old IE
              var EXISTS =
                isObject(document) && isObject(document.createElement)

              module.exports = function (it) {
                return EXISTS ? document.createElement(it) : {}
              }

              /***/
            },

            /***/ 8324: /***/ function (module) {
              // iterable DOM collections
              // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
              module.exports = {
                CSSRuleList: 0,
                CSSStyleDeclaration: 0,
                CSSValueList: 0,
                ClientRectList: 0,
                DOMRectList: 0,
                DOMStringList: 0,
                DOMTokenList: 1,
                DataTransferItemList: 0,
                FileList: 0,
                HTMLAllCollection: 0,
                HTMLCollection: 0,
                HTMLFormElement: 0,
                HTMLSelectElement: 0,
                MediaList: 0,
                MimeTypeArray: 0,
                NamedNodeMap: 0,
                NodeList: 1,
                PaintRequestList: 0,
                Plugin: 0,
                PluginArray: 0,
                SVGLengthList: 0,
                SVGNumberList: 0,
                SVGPathSegList: 0,
                SVGPointList: 0,
                SVGStringList: 0,
                SVGTransformList: 0,
                SourceBufferList: 0,
                StyleSheetList: 0,
                TextTrackCueList: 0,
                TextTrackList: 0,
                TouchList: 0
              }

              /***/
            },

            /***/ 8113: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_42025__
            ) {
              var getBuiltIn = __nested_webpack_require_42025__(5005)

              module.exports = getBuiltIn('navigator', 'userAgent') || ''

              /***/
            },

            /***/ 7392: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_42230__
            ) {
              var global = __nested_webpack_require_42230__(7854)
              var userAgent = __nested_webpack_require_42230__(8113)

              var process = global.process
              var versions = process && process.versions
              var v8 = versions && versions.v8
              var match, version

              if (v8) {
                match = v8.split('.')
                version = match[0] + match[1]
              } else if (userAgent) {
                match = userAgent.match(/Edge\/(\d+)/)
                if (!match || match[1] >= 74) {
                  match = userAgent.match(/Chrome\/(\d+)/)
                  if (match) version = match[1]
                }
              }

              module.exports = version && +version

              /***/
            },

            /***/ 748: /***/ function (module) {
              // IE8- don't enum bug keys
              module.exports = [
                'constructor',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'toLocaleString',
                'toString',
                'valueOf'
              ]

              /***/
            },

            /***/ 2109: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_43065__
            ) {
              var global = __nested_webpack_require_43065__(7854)
              var getOwnPropertyDescriptor =
                __nested_webpack_require_43065__(1236).f
              var createNonEnumerableProperty =
                __nested_webpack_require_43065__(8880)
              var redefine = __nested_webpack_require_43065__(1320)
              var setGlobal = __nested_webpack_require_43065__(3505)
              var copyConstructorProperties =
                __nested_webpack_require_43065__(9920)
              var isForced = __nested_webpack_require_43065__(4705)

              /*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
              module.exports = function (options, source) {
                var TARGET = options.target
                var GLOBAL = options.global
                var STATIC = options.stat
                var FORCED,
                  target,
                  key,
                  targetProperty,
                  sourceProperty,
                  descriptor
                if (GLOBAL) {
                  target = global
                } else if (STATIC) {
                  target = global[TARGET] || setGlobal(TARGET, {})
                } else {
                  target = (global[TARGET] || {}).prototype
                }
                if (target)
                  for (key in source) {
                    sourceProperty = source[key]
                    if (options.noTargetGet) {
                      descriptor = getOwnPropertyDescriptor(target, key)
                      targetProperty = descriptor && descriptor.value
                    } else targetProperty = target[key]
                    FORCED = isForced(
                      GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key,
                      options.forced
                    )
                    // contained in target
                    if (!FORCED && targetProperty !== undefined) {
                      if (typeof sourceProperty === typeof targetProperty)
                        continue
                      copyConstructorProperties(sourceProperty, targetProperty)
                    }
                    // add a flag to not completely full polyfills
                    if (
                      options.sham ||
                      (targetProperty && targetProperty.sham)
                    ) {
                      createNonEnumerableProperty(sourceProperty, 'sham', true)
                    }
                    // extend global
                    redefine(target, key, sourceProperty, options)
                  }
              }

              /***/
            },

            /***/ 7293: /***/ function (module) {
              module.exports = function (exec) {
                try {
                  return !!exec()
                } catch (error) {
                  return true
                }
              }

              /***/
            },

            /***/ 7007: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_45726__
            ) {
              'use strict'

              // TODO: Remove from `core-js@4` since it's moved to entry points
              __nested_webpack_require_45726__(4916)
              var redefine = __nested_webpack_require_45726__(1320)
              var fails = __nested_webpack_require_45726__(7293)
              var wellKnownSymbol = __nested_webpack_require_45726__(5112)
              var regexpExec = __nested_webpack_require_45726__(2261)
              var createNonEnumerableProperty =
                __nested_webpack_require_45726__(8880)

              var SPECIES = wellKnownSymbol('species')

              var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
                // #replace needs built-in support for named groups.
                // #match works fine because it just return the exec results, even if it has
                // a "grops" property.
                var re = /./
                re.exec = function () {
                  var result = []
                  result.groups = { a: '7' }
                  return result
                }
                return ''.replace(re, '$<a>') !== '7'
              })

              // IE <= 11 replaces $0 with the whole match, as if it was $&
              // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
              var REPLACE_KEEPS_$0 = (function () {
                return 'a'.replace(/./, '$0') === '$0'
              })()

              var REPLACE = wellKnownSymbol('replace')
              // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
              var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
                if (/./[REPLACE]) {
                  return /./[REPLACE]('a', '$0') === ''
                }
                return false
              })()

              // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
              // Weex JS has frozen built-in prototypes, so use try / catch wrapper
              var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
                // eslint-disable-next-line regexp/no-empty-group -- required for testing
                var re = /(?:)/
                var originalExec = re.exec
                re.exec = function () {
                  return originalExec.apply(this, arguments)
                }
                var result = 'ab'.split(re)
                return (
                  result.length !== 2 || result[0] !== 'a' || result[1] !== 'b'
                )
              })

              module.exports = function (KEY, length, exec, sham) {
                var SYMBOL = wellKnownSymbol(KEY)

                var DELEGATES_TO_SYMBOL = !fails(function () {
                  // String methods call symbol-named RegEp methods
                  var O = {}
                  O[SYMBOL] = function () {
                    return 7
                  }
                  return ''[KEY](O) != 7
                })

                var DELEGATES_TO_EXEC =
                  DELEGATES_TO_SYMBOL &&
                  !fails(function () {
                    // Symbol-named RegExp methods call .exec
                    var execCalled = false
                    var re = /a/

                    if (KEY === 'split') {
                      // We can't use real regex here since it causes deoptimization
                      // and serious performance degradation in V8
                      // https://github.com/zloirock/core-js/issues/306
                      re = {}
                      // RegExp[@@split] doesn't call the regex's exec method, but first creates
                      // a new one. We need to return the patched regex when creating the new one.
                      re.constructor = {}
                      re.constructor[SPECIES] = function () {
                        return re
                      }
                      re.flags = ''
                      re[SYMBOL] = /./[SYMBOL]
                    }

                    re.exec = function () {
                      execCalled = true
                      return null
                    }

                    re[SYMBOL]('')
                    return !execCalled
                  })

                if (
                  !DELEGATES_TO_SYMBOL ||
                  !DELEGATES_TO_EXEC ||
                  (KEY === 'replace' &&
                    !(
                      REPLACE_SUPPORTS_NAMED_GROUPS &&
                      REPLACE_KEEPS_$0 &&
                      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                    )) ||
                  (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
                ) {
                  var nativeRegExpMethod = /./[SYMBOL]
                  var methods = exec(
                    SYMBOL,
                    ''[KEY],
                    function (
                      nativeMethod,
                      regexp,
                      str,
                      arg2,
                      forceStringMethod
                    ) {
                      if (regexp.exec === regexpExec) {
                        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                          // The native String method already delegates to @@method (this
                          // polyfilled function), leasing to infinite recursion.
                          // We avoid it by directly calling the native @@method method.
                          return {
                            done: true,
                            value: nativeRegExpMethod.call(regexp, str, arg2)
                          }
                        }
                        return {
                          done: true,
                          value: nativeMethod.call(str, regexp, arg2)
                        }
                      }
                      return { done: false }
                    },
                    {
                      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
                      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:
                        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                    }
                  )
                  var stringMethod = methods[0]
                  var regexMethod = methods[1]

                  redefine(String.prototype, KEY, stringMethod)
                  redefine(
                    RegExp.prototype,
                    SYMBOL,
                    length == 2
                      ? // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
                        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
                        function (string, arg) {
                          return regexMethod.call(string, this, arg)
                        }
                      : // 21.2.5.6 RegExp.prototype[@@match](string)
                        // 21.2.5.9 RegExp.prototype[@@search](string)
                        function (string) {
                          return regexMethod.call(string, this)
                        }
                  )
                }

                if (sham)
                  createNonEnumerableProperty(
                    RegExp.prototype[SYMBOL],
                    'sham',
                    true
                  )
              }

              /***/
            },

            /***/ 9974: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_50488__
            ) {
              var aFunction = __nested_webpack_require_50488__(3099)

              // optional / simple context binding
              module.exports = function (fn, that, length) {
                aFunction(fn)
                if (that === undefined) return fn
                switch (length) {
                  case 0:
                    return function () {
                      return fn.call(that)
                    }
                  case 1:
                    return function (a) {
                      return fn.call(that, a)
                    }
                  case 2:
                    return function (a, b) {
                      return fn.call(that, a, b)
                    }
                  case 3:
                    return function (a, b, c) {
                      return fn.call(that, a, b, c)
                    }
                }
                return function (/* ...args */) {
                  return fn.apply(that, arguments)
                }
              }

              /***/
            },

            /***/ 5005: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_51177__
            ) {
              var path = __nested_webpack_require_51177__(857)
              var global = __nested_webpack_require_51177__(7854)

              var aFunction = function (variable) {
                return typeof variable == 'function' ? variable : undefined
              }

              module.exports = function (namespace, method) {
                return arguments.length < 2
                  ? aFunction(path[namespace]) || aFunction(global[namespace])
                  : (path[namespace] && path[namespace][method]) ||
                      (global[namespace] && global[namespace][method])
              }

              /***/
            },

            /***/ 1246: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_51701__
            ) {
              var classof = __nested_webpack_require_51701__(648)
              var Iterators = __nested_webpack_require_51701__(7497)
              var wellKnownSymbol = __nested_webpack_require_51701__(5112)

              var ITERATOR = wellKnownSymbol('iterator')

              module.exports = function (it) {
                if (it != undefined)
                  return (
                    it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)]
                  )
              }

              /***/
            },

            /***/ 8554: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_52112__
            ) {
              var anObject = __nested_webpack_require_52112__(9670)
              var getIteratorMethod = __nested_webpack_require_52112__(1246)

              module.exports = function (it) {
                var iteratorMethod = getIteratorMethod(it)
                if (typeof iteratorMethod != 'function') {
                  throw TypeError(String(it) + ' is not iterable')
                }
                return anObject(iteratorMethod.call(it))
              }

              /***/
            },

            /***/ 647: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_52531__
            ) {
              var toObject = __nested_webpack_require_52531__(7908)

              var floor = Math.floor
              var replace = ''.replace
              var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g
              var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g

              // https://tc39.es/ecma262/#sec-getsubstitution
              module.exports = function (
                matched,
                str,
                position,
                captures,
                namedCaptures,
                replacement
              ) {
                var tailPos = position + matched.length
                var m = captures.length
                var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED
                if (namedCaptures !== undefined) {
                  namedCaptures = toObject(namedCaptures)
                  symbols = SUBSTITUTION_SYMBOLS
                }
                return replace.call(replacement, symbols, function (match, ch) {
                  var capture
                  switch (ch.charAt(0)) {
                    case '$':
                      return '$'
                    case '&':
                      return matched
                    case '`':
                      return str.slice(0, position)
                    case "'":
                      return str.slice(tailPos)
                    case '<':
                      capture = namedCaptures[ch.slice(1, -1)]
                      break
                    default: // \d\d?
                      var n = +ch
                      if (n === 0) return match
                      if (n > m) {
                        var f = floor(n / 10)
                        if (f === 0) return match
                        if (f <= m)
                          return captures[f - 1] === undefined
                            ? ch.charAt(1)
                            : captures[f - 1] + ch.charAt(1)
                        return match
                      }
                      capture = captures[n - 1]
                  }
                  return capture === undefined ? '' : capture
                })
              }

              /***/
            },

            /***/ 7854: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_53970__
            ) {
              var check = function (it) {
                return it && it.Math == Math && it
              }

              // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
              module.exports =
                /* global globalThis -- safe */
                check(typeof globalThis == 'object' && globalThis) ||
                check(typeof window == 'object' && window) ||
                check(typeof self == 'object' && self) ||
                check(
                  typeof __nested_webpack_require_53970__.g == 'object' &&
                    __nested_webpack_require_53970__.g
                ) ||
                // eslint-disable-next-line no-new-func -- fallback
                (function () {
                  return this
                })() ||
                Function('return this')()

              /***/
            },

            /***/ 6656: /***/ function (module) {
              var hasOwnProperty = {}.hasOwnProperty

              module.exports = function (it, key) {
                return hasOwnProperty.call(it, key)
              }

              /***/
            },

            /***/ 3501: /***/ function (module) {
              module.exports = {}

              /***/
            },

            /***/ 490: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_54852__
            ) {
              var getBuiltIn = __nested_webpack_require_54852__(5005)

              module.exports = getBuiltIn('document', 'documentElement')

              /***/
            },

            /***/ 4664: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_55056__
            ) {
              var DESCRIPTORS = __nested_webpack_require_55056__(9781)
              var fails = __nested_webpack_require_55056__(7293)
              var createElement = __nested_webpack_require_55056__(317)

              // Thank's IE8 for his funny defineProperty
              module.exports =
                !DESCRIPTORS &&
                !fails(function () {
                  return (
                    Object.defineProperty(createElement('div'), 'a', {
                      get: function () {
                        return 7
                      }
                    }).a != 7
                  )
                })

              /***/
            },

            /***/ 1179: /***/ function (module) {
              // IEEE754 conversions based on https://github.com/feross/ieee754
              var abs = Math.abs
              var pow = Math.pow
              var floor = Math.floor
              var log = Math.log
              var LN2 = Math.LN2

              var pack = function (number, mantissaLength, bytes) {
                var buffer = new Array(bytes)
                var exponentLength = bytes * 8 - mantissaLength - 1
                var eMax = (1 << exponentLength) - 1
                var eBias = eMax >> 1
                var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0
                var sign =
                  number < 0 || (number === 0 && 1 / number < 0) ? 1 : 0
                var index = 0
                var exponent, mantissa, c
                number = abs(number)
                // eslint-disable-next-line no-self-compare -- NaN check
                if (number != number || number === Infinity) {
                  // eslint-disable-next-line no-self-compare -- NaN check
                  mantissa = number != number ? 1 : 0
                  exponent = eMax
                } else {
                  exponent = floor(log(number) / LN2)
                  if (number * (c = pow(2, -exponent)) < 1) {
                    exponent--
                    c *= 2
                  }
                  if (exponent + eBias >= 1) {
                    number += rt / c
                  } else {
                    number += rt * pow(2, 1 - eBias)
                  }
                  if (number * c >= 2) {
                    exponent++
                    c /= 2
                  }
                  if (exponent + eBias >= eMax) {
                    mantissa = 0
                    exponent = eMax
                  } else if (exponent + eBias >= 1) {
                    mantissa = (number * c - 1) * pow(2, mantissaLength)
                    exponent = exponent + eBias
                  } else {
                    mantissa =
                      number * pow(2, eBias - 1) * pow(2, mantissaLength)
                    exponent = 0
                  }
                }
                for (
                  ;
                  mantissaLength >= 8;
                  buffer[index++] = mantissa & 255,
                    mantissa /= 256,
                    mantissaLength -= 8
                );
                exponent = (exponent << mantissaLength) | mantissa
                exponentLength += mantissaLength
                for (
                  ;
                  exponentLength > 0;
                  buffer[index++] = exponent & 255,
                    exponent /= 256,
                    exponentLength -= 8
                );
                buffer[--index] |= sign * 128
                return buffer
              }

              var unpack = function (buffer, mantissaLength) {
                var bytes = buffer.length
                var exponentLength = bytes * 8 - mantissaLength - 1
                var eMax = (1 << exponentLength) - 1
                var eBias = eMax >> 1
                var nBits = exponentLength - 7
                var index = bytes - 1
                var sign = buffer[index--]
                var exponent = sign & 127
                var mantissa
                sign >>= 7
                for (
                  ;
                  nBits > 0;
                  exponent = exponent * 256 + buffer[index], index--, nBits -= 8
                );
                mantissa = exponent & ((1 << -nBits) - 1)
                exponent >>= -nBits
                nBits += mantissaLength
                for (
                  ;
                  nBits > 0;
                  mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8
                );
                if (exponent === 0) {
                  exponent = 1 - eBias
                } else if (exponent === eMax) {
                  return mantissa ? NaN : sign ? -Infinity : Infinity
                } else {
                  mantissa = mantissa + pow(2, mantissaLength)
                  exponent = exponent - eBias
                }
                return (
                  (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength)
                )
              }

              module.exports = {
                pack: pack,
                unpack: unpack
              }

              /***/
            },

            /***/ 8361: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_58329__
            ) {
              var fails = __nested_webpack_require_58329__(7293)
              var classof = __nested_webpack_require_58329__(4326)

              var split = ''.split

              // fallback for non-array-like ES3 and non-enumerable old V8 strings
              module.exports = fails(function () {
                // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
                // eslint-disable-next-line no-prototype-builtins -- safe
                return !Object('z').propertyIsEnumerable(0)
              })
                ? function (it) {
                    return classof(it) == 'String'
                      ? split.call(it, '')
                      : Object(it)
                  }
                : Object

              /***/
            },

            /***/ 9587: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_58925__
            ) {
              var isObject = __nested_webpack_require_58925__(111)
              var setPrototypeOf = __nested_webpack_require_58925__(7674)

              // makes subclassing work correct for wrapped built-ins
              module.exports = function ($this, dummy, Wrapper) {
                var NewTarget, NewTargetPrototype
                if (
                  // it can work only with native `setPrototypeOf`
                  setPrototypeOf &&
                  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
                  typeof (NewTarget = dummy.constructor) == 'function' &&
                  NewTarget !== Wrapper &&
                  isObject((NewTargetPrototype = NewTarget.prototype)) &&
                  NewTargetPrototype !== Wrapper.prototype
                )
                  setPrototypeOf($this, NewTargetPrototype)
                return $this
              }

              /***/
            },

            /***/ 2788: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_59686__
            ) {
              var store = __nested_webpack_require_59686__(5465)

              var functionToString = Function.toString

              // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
              if (typeof store.inspectSource != 'function') {
                store.inspectSource = function (it) {
                  return functionToString.call(it)
                }
              }

              module.exports = store.inspectSource

              /***/
            },

            /***/ 9909: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_60112__
            ) {
              var NATIVE_WEAK_MAP = __nested_webpack_require_60112__(8536)
              var global = __nested_webpack_require_60112__(7854)
              var isObject = __nested_webpack_require_60112__(111)
              var createNonEnumerableProperty =
                __nested_webpack_require_60112__(8880)
              var objectHas = __nested_webpack_require_60112__(6656)
              var shared = __nested_webpack_require_60112__(5465)
              var sharedKey = __nested_webpack_require_60112__(6200)
              var hiddenKeys = __nested_webpack_require_60112__(3501)

              var WeakMap = global.WeakMap
              var set, get, has

              var enforce = function (it) {
                return has(it) ? get(it) : set(it, {})
              }

              var getterFor = function (TYPE) {
                return function (it) {
                  var state
                  if (!isObject(it) || (state = get(it)).type !== TYPE) {
                    throw TypeError(
                      'Incompatible receiver, ' + TYPE + ' required'
                    )
                  }
                  return state
                }
              }

              if (NATIVE_WEAK_MAP) {
                var store = shared.state || (shared.state = new WeakMap())
                var wmget = store.get
                var wmhas = store.has
                var wmset = store.set
                set = function (it, metadata) {
                  metadata.facade = it
                  wmset.call(store, it, metadata)
                  return metadata
                }
                get = function (it) {
                  return wmget.call(store, it) || {}
                }
                has = function (it) {
                  return wmhas.call(store, it)
                }
              } else {
                var STATE = sharedKey('state')
                hiddenKeys[STATE] = true
                set = function (it, metadata) {
                  metadata.facade = it
                  createNonEnumerableProperty(it, STATE, metadata)
                  return metadata
                }
                get = function (it) {
                  return objectHas(it, STATE) ? it[STATE] : {}
                }
                has = function (it) {
                  return objectHas(it, STATE)
                }
              }

              module.exports = {
                set: set,
                get: get,
                has: has,
                enforce: enforce,
                getterFor: getterFor
              }

              /***/
            },

            /***/ 7659: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_61804__
            ) {
              var wellKnownSymbol = __nested_webpack_require_61804__(5112)
              var Iterators = __nested_webpack_require_61804__(7497)

              var ITERATOR = wellKnownSymbol('iterator')
              var ArrayPrototype = Array.prototype

              // check on default Array iterator
              module.exports = function (it) {
                return (
                  it !== undefined &&
                  (Iterators.Array === it || ArrayPrototype[ITERATOR] === it)
                )
              }

              /***/
            },

            /***/ 3157: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_62240__
            ) {
              var classof = __nested_webpack_require_62240__(4326)

              // `IsArray` abstract operation
              // https://tc39.es/ecma262/#sec-isarray
              module.exports =
                Array.isArray ||
                function isArray(arg) {
                  return classof(arg) == 'Array'
                }

              /***/
            },

            /***/ 4705: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_62548__
            ) {
              var fails = __nested_webpack_require_62548__(7293)

              var replacement = /#|\.prototype\./

              var isForced = function (feature, detection) {
                var value = data[normalize(feature)]
                return value == POLYFILL
                  ? true
                  : value == NATIVE
                  ? false
                  : typeof detection == 'function'
                  ? fails(detection)
                  : !!detection
              }

              var normalize = (isForced.normalize = function (string) {
                return String(string).replace(replacement, '.').toLowerCase()
              })

              var data = (isForced.data = {})
              var NATIVE = (isForced.NATIVE = 'N')
              var POLYFILL = (isForced.POLYFILL = 'P')

              module.exports = isForced

              /***/
            },

            /***/ 111: /***/ function (module) {
              module.exports = function (it) {
                return typeof it === 'object'
                  ? it !== null
                  : typeof it === 'function'
              }

              /***/
            },

            /***/ 1913: /***/ function (module) {
              module.exports = false

              /***/
            },

            /***/ 7850: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_63453__
            ) {
              var isObject = __nested_webpack_require_63453__(111)
              var classof = __nested_webpack_require_63453__(4326)
              var wellKnownSymbol = __nested_webpack_require_63453__(5112)

              var MATCH = wellKnownSymbol('match')

              // `IsRegExp` abstract operation
              // https://tc39.es/ecma262/#sec-isregexp
              module.exports = function (it) {
                var isRegExp
                return (
                  isObject(it) &&
                  ((isRegExp = it[MATCH]) !== undefined
                    ? !!isRegExp
                    : classof(it) == 'RegExp')
                )
              }

              /***/
            },

            /***/ 9212: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_63953__
            ) {
              var anObject = __nested_webpack_require_63953__(9670)

              module.exports = function (iterator) {
                var returnMethod = iterator['return']
                if (returnMethod !== undefined) {
                  return anObject(returnMethod.call(iterator)).value
                }
              }

              /***/
            },

            /***/ 3383: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_64274__
            ) {
              'use strict'

              var fails = __nested_webpack_require_64274__(7293)
              var getPrototypeOf = __nested_webpack_require_64274__(9518)
              var createNonEnumerableProperty =
                __nested_webpack_require_64274__(8880)
              var has = __nested_webpack_require_64274__(6656)
              var wellKnownSymbol = __nested_webpack_require_64274__(5112)
              var IS_PURE = __nested_webpack_require_64274__(1913)

              var ITERATOR = wellKnownSymbol('iterator')
              var BUGGY_SAFARI_ITERATORS = false

              var returnThis = function () {
                return this
              }

              // `%IteratorPrototype%` object
              // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
              var IteratorPrototype,
                PrototypeOfArrayIteratorPrototype,
                arrayIterator

              if ([].keys) {
                arrayIterator = [].keys()
                // Safari 8 has buggy iterators w/o `next`
                if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true
                else {
                  PrototypeOfArrayIteratorPrototype = getPrototypeOf(
                    getPrototypeOf(arrayIterator)
                  )
                  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                    IteratorPrototype = PrototypeOfArrayIteratorPrototype
                }
              }

              var NEW_ITERATOR_PROTOTYPE =
                IteratorPrototype == undefined ||
                fails(function () {
                  var test = {}
                  // FF44- legacy iterators case
                  return IteratorPrototype[ITERATOR].call(test) !== test
                })

              if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {}

              // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
              if (
                (!IS_PURE || NEW_ITERATOR_PROTOTYPE) &&
                !has(IteratorPrototype, ITERATOR)
              ) {
                createNonEnumerableProperty(
                  IteratorPrototype,
                  ITERATOR,
                  returnThis
                )
              }

              module.exports = {
                IteratorPrototype: IteratorPrototype,
                BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
              }

              /***/
            },

            /***/ 7497: /***/ function (module) {
              module.exports = {}

              /***/
            },

            /***/ 133: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_65970__
            ) {
              var fails = __nested_webpack_require_65970__(7293)

              module.exports =
                !!Object.getOwnPropertySymbols &&
                !fails(function () {
                  // Chrome 38 Symbol has incorrect toString conversion
                  /* global Symbol -- required for testing */
                  return !String(Symbol())
                })

              /***/
            },

            /***/ 590: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_66314__
            ) {
              var fails = __nested_webpack_require_66314__(7293)
              var wellKnownSymbol = __nested_webpack_require_66314__(5112)
              var IS_PURE = __nested_webpack_require_66314__(1913)

              var ITERATOR = wellKnownSymbol('iterator')

              module.exports = !fails(function () {
                var url = new URL('b?a=1&b=2&c=3', 'http://a')
                var searchParams = url.searchParams
                var result = ''
                url.pathname = 'c%20d'
                searchParams.forEach(function (value, key) {
                  searchParams['delete']('b')
                  result += key + value
                })
                return (
                  (IS_PURE && !url.toJSON) ||
                  !searchParams.sort ||
                  url.href !== 'http://a/c%20d?a=1&c=3' ||
                  searchParams.get('c') !== '3' ||
                  String(new URLSearchParams('?a=1')) !== 'a=1' ||
                  !searchParams[ITERATOR] ||
                  // throws in Edge
                  new URL('https://a@b').username !== 'a' ||
                  new URLSearchParams(new URLSearchParams('a=b')).get('a') !==
                    'b' ||
                  // not punycoded in Edge
                  new URL('http://').host !== 'xn--e1aybc' ||
                  // not escaped in Chrome 62-
                  new URL('http://a#').hash !== '#%D0%B1' ||
                  // fails in Chrome 66-
                  result !== 'a1c3' ||
                  // throws in Safari
                  new URL('http://x', undefined).host !== 'x'
                )
              })

              /***/
            },

            /***/ 8536: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_67534__
            ) {
              var global = __nested_webpack_require_67534__(7854)
              var inspectSource = __nested_webpack_require_67534__(2788)

              var WeakMap = global.WeakMap

              module.exports =
                typeof WeakMap === 'function' &&
                /native code/.test(inspectSource(WeakMap))

              /***/
            },

            /***/ 1574: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_67846__
            ) {
              'use strict'

              var DESCRIPTORS = __nested_webpack_require_67846__(9781)
              var fails = __nested_webpack_require_67846__(7293)
              var objectKeys = __nested_webpack_require_67846__(1956)
              var getOwnPropertySymbolsModule =
                __nested_webpack_require_67846__(5181)
              var propertyIsEnumerableModule =
                __nested_webpack_require_67846__(5296)
              var toObject = __nested_webpack_require_67846__(7908)
              var IndexedObject = __nested_webpack_require_67846__(8361)

              var nativeAssign = Object.assign
              var defineProperty = Object.defineProperty

              // `Object.assign` method
              // https://tc39.es/ecma262/#sec-object.assign
              module.exports =
                !nativeAssign ||
                fails(function () {
                  // should have correct order of operations (Edge bug)
                  if (
                    DESCRIPTORS &&
                    nativeAssign(
                      { b: 1 },
                      nativeAssign(
                        defineProperty({}, 'a', {
                          enumerable: true,
                          get: function () {
                            defineProperty(this, 'b', {
                              value: 3,
                              enumerable: false
                            })
                          }
                        }),
                        { b: 2 }
                      )
                    ).b !== 1
                  )
                    return true
                  // should work with symbols and should have deterministic property order (V8 bug)
                  var A = {}
                  var B = {}
                  /* global Symbol -- required for testing */
                  var symbol = Symbol()
                  var alphabet = 'abcdefghijklmnopqrst'
                  A[symbol] = 7
                  alphabet.split('').forEach(function (chr) {
                    B[chr] = chr
                  })
                  return (
                    nativeAssign({}, A)[symbol] != 7 ||
                    objectKeys(nativeAssign({}, B)).join('') != alphabet
                  )
                })
                  ? function assign(target, source) {
                      // eslint-disable-line no-unused-vars -- required for `.length`
                      var T = toObject(target)
                      var argumentsLength = arguments.length
                      var index = 1
                      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f
                      var propertyIsEnumerable = propertyIsEnumerableModule.f
                      while (argumentsLength > index) {
                        var S = IndexedObject(arguments[index++])
                        var keys = getOwnPropertySymbols
                          ? objectKeys(S).concat(getOwnPropertySymbols(S))
                          : objectKeys(S)
                        var length = keys.length
                        var j = 0
                        var key
                        while (length > j) {
                          key = keys[j++]
                          if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))
                            T[key] = S[key]
                        }
                      }
                      return T
                    }
                  : nativeAssign

              /***/
            },

            /***/ 30: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_69941__
            ) {
              var anObject = __nested_webpack_require_69941__(9670)
              var defineProperties = __nested_webpack_require_69941__(6048)
              var enumBugKeys = __nested_webpack_require_69941__(748)
              var hiddenKeys = __nested_webpack_require_69941__(3501)
              var html = __nested_webpack_require_69941__(490)
              var documentCreateElement = __nested_webpack_require_69941__(317)
              var sharedKey = __nested_webpack_require_69941__(6200)

              var GT = '>'
              var LT = '<'
              var PROTOTYPE = 'prototype'
              var SCRIPT = 'script'
              var IE_PROTO = sharedKey('IE_PROTO')

              var EmptyConstructor = function () {
                /* empty */
              }

              var scriptTag = function (content) {
                return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT
              }

              // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
              var NullProtoObjectViaActiveX = function (activeXDocument) {
                activeXDocument.write(scriptTag(''))
                activeXDocument.close()
                var temp = activeXDocument.parentWindow.Object
                activeXDocument = null // avoid memory leak
                return temp
              }

              // Create object with fake `null` prototype: use iframe Object with cleared prototype
              var NullProtoObjectViaIFrame = function () {
                // Thrash, waste and sodomy: IE GC bug
                var iframe = documentCreateElement('iframe')
                var JS = 'java' + SCRIPT + ':'
                var iframeDocument
                iframe.style.display = 'none'
                html.appendChild(iframe)
                // https://github.com/zloirock/core-js/issues/475
                iframe.src = String(JS)
                iframeDocument = iframe.contentWindow.document
                iframeDocument.open()
                iframeDocument.write(scriptTag('document.F=Object'))
                iframeDocument.close()
                return iframeDocument.F
              }

              // Check for document.domain and active x support
              // No need to use active x approach when document.domain is not set
              // see https://github.com/es-shims/es5-shim/issues/150
              // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
              // avoid IE GC bug
              var activeXDocument
              var NullProtoObject = function () {
                try {
                  /* global ActiveXObject -- old IE */
                  activeXDocument =
                    document.domain && new ActiveXObject('htmlfile')
                } catch (error) {
                  /* ignore */
                }
                NullProtoObject = activeXDocument
                  ? NullProtoObjectViaActiveX(activeXDocument)
                  : NullProtoObjectViaIFrame()
                var length = enumBugKeys.length
                while (length--)
                  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]
                return NullProtoObject()
              }

              hiddenKeys[IE_PROTO] = true

              // `Object.create` method
              // https://tc39.es/ecma262/#sec-object.create
              module.exports =
                Object.create ||
                function create(O, Properties) {
                  var result
                  if (O !== null) {
                    EmptyConstructor[PROTOTYPE] = anObject(O)
                    result = new EmptyConstructor()
                    EmptyConstructor[PROTOTYPE] = null
                    // add "__proto__" for Object.getPrototypeOf polyfill
                    result[IE_PROTO] = O
                  } else result = NullProtoObject()
                  return Properties === undefined
                    ? result
                    : defineProperties(result, Properties)
                }

              /***/
            },

            /***/ 6048: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_72835__
            ) {
              var DESCRIPTORS = __nested_webpack_require_72835__(9781)
              var definePropertyModule = __nested_webpack_require_72835__(3070)
              var anObject = __nested_webpack_require_72835__(9670)
              var objectKeys = __nested_webpack_require_72835__(1956)

              // `Object.defineProperties` method
              // https://tc39.es/ecma262/#sec-object.defineproperties
              module.exports = DESCRIPTORS
                ? Object.defineProperties
                : function defineProperties(O, Properties) {
                    anObject(O)
                    var keys = objectKeys(Properties)
                    var length = keys.length
                    var index = 0
                    var key
                    while (length > index)
                      definePropertyModule.f(
                        O,
                        (key = keys[index++]),
                        Properties[key]
                      )
                    return O
                  }

              /***/
            },

            /***/ 3070: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_73525__
            ) {
              var DESCRIPTORS = __nested_webpack_require_73525__(9781)
              var IE8_DOM_DEFINE = __nested_webpack_require_73525__(4664)
              var anObject = __nested_webpack_require_73525__(9670)
              var toPrimitive = __nested_webpack_require_73525__(7593)

              var nativeDefineProperty = Object.defineProperty

              // `Object.defineProperty` method
              // https://tc39.es/ecma262/#sec-object.defineproperty
              exports.f = DESCRIPTORS
                ? nativeDefineProperty
                : function defineProperty(O, P, Attributes) {
                    anObject(O)
                    P = toPrimitive(P, true)
                    anObject(Attributes)
                    if (IE8_DOM_DEFINE)
                      try {
                        return nativeDefineProperty(O, P, Attributes)
                      } catch (error) {
                        /* empty */
                      }
                    if ('get' in Attributes || 'set' in Attributes)
                      throw TypeError('Accessors not supported')
                    if ('value' in Attributes) O[P] = Attributes.value
                    return O
                  }

              /***/
            },

            /***/ 1236: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_74380__
            ) {
              var DESCRIPTORS = __nested_webpack_require_74380__(9781)
              var propertyIsEnumerableModule =
                __nested_webpack_require_74380__(5296)
              var createPropertyDescriptor =
                __nested_webpack_require_74380__(9114)
              var toIndexedObject = __nested_webpack_require_74380__(5656)
              var toPrimitive = __nested_webpack_require_74380__(7593)
              var has = __nested_webpack_require_74380__(6656)
              var IE8_DOM_DEFINE = __nested_webpack_require_74380__(4664)

              var nativeGetOwnPropertyDescriptor =
                Object.getOwnPropertyDescriptor

              // `Object.getOwnPropertyDescriptor` method
              // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
              exports.f = DESCRIPTORS
                ? nativeGetOwnPropertyDescriptor
                : function getOwnPropertyDescriptor(O, P) {
                    O = toIndexedObject(O)
                    P = toPrimitive(P, true)
                    if (IE8_DOM_DEFINE)
                      try {
                        return nativeGetOwnPropertyDescriptor(O, P)
                      } catch (error) {
                        /* empty */
                      }
                    if (has(O, P))
                      return createPropertyDescriptor(
                        !propertyIsEnumerableModule.f.call(O, P),
                        O[P]
                      )
                  }

              /***/
            },

            /***/ 8006: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_75368__
            ) {
              var internalObjectKeys = __nested_webpack_require_75368__(6324)
              var enumBugKeys = __nested_webpack_require_75368__(748)

              var hiddenKeys = enumBugKeys.concat('length', 'prototype')

              // `Object.getOwnPropertyNames` method
              // https://tc39.es/ecma262/#sec-object.getownpropertynames
              exports.f =
                Object.getOwnPropertyNames ||
                function getOwnPropertyNames(O) {
                  return internalObjectKeys(O, hiddenKeys)
                }

              /***/
            },

            /***/ 5181: /***/ function (__unused_webpack_module, exports) {
              exports.f = Object.getOwnPropertySymbols

              /***/
            },

            /***/ 9518: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_75966__
            ) {
              var has = __nested_webpack_require_75966__(6656)
              var toObject = __nested_webpack_require_75966__(7908)
              var sharedKey = __nested_webpack_require_75966__(6200)
              var CORRECT_PROTOTYPE_GETTER =
                __nested_webpack_require_75966__(8544)

              var IE_PROTO = sharedKey('IE_PROTO')
              var ObjectPrototype = Object.prototype

              // `Object.getPrototypeOf` method
              // https://tc39.es/ecma262/#sec-object.getprototypeof
              module.exports = CORRECT_PROTOTYPE_GETTER
                ? Object.getPrototypeOf
                : function (O) {
                    O = toObject(O)
                    if (has(O, IE_PROTO)) return O[IE_PROTO]
                    if (
                      typeof O.constructor == 'function' &&
                      O instanceof O.constructor
                    ) {
                      return O.constructor.prototype
                    }
                    return O instanceof Object ? ObjectPrototype : null
                  }

              /***/
            },

            /***/ 6324: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_76729__
            ) {
              var has = __nested_webpack_require_76729__(6656)
              var toIndexedObject = __nested_webpack_require_76729__(5656)
              var indexOf = __nested_webpack_require_76729__(1318).indexOf
              var hiddenKeys = __nested_webpack_require_76729__(3501)

              module.exports = function (object, names) {
                var O = toIndexedObject(object)
                var i = 0
                var result = []
                var key
                for (key in O)
                  !has(hiddenKeys, key) && has(O, key) && result.push(key)
                // Don't enum bug & hidden keys
                while (names.length > i)
                  if (has(O, (key = names[i++]))) {
                    ~indexOf(result, key) || result.push(key)
                  }
                return result
              }

              /***/
            },

            /***/ 1956: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_77369__
            ) {
              var internalObjectKeys = __nested_webpack_require_77369__(6324)
              var enumBugKeys = __nested_webpack_require_77369__(748)

              // `Object.keys` method
              // https://tc39.es/ecma262/#sec-object.keys
              module.exports =
                Object.keys ||
                function keys(O) {
                  return internalObjectKeys(O, enumBugKeys)
                }

              /***/
            },

            /***/ 5296: /***/ function (__unused_webpack_module, exports) {
              'use strict'

              var nativePropertyIsEnumerable = {}.propertyIsEnumerable
              var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor

              // Nashorn ~ JDK8 bug
              var NASHORN_BUG =
                getOwnPropertyDescriptor &&
                !nativePropertyIsEnumerable.call({ 1: 2 }, 1)

              // `Object.prototype.propertyIsEnumerable` method implementation
              // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
              exports.f = NASHORN_BUG
                ? function propertyIsEnumerable(V) {
                    var descriptor = getOwnPropertyDescriptor(this, V)
                    return !!descriptor && descriptor.enumerable
                  }
                : nativePropertyIsEnumerable

              /***/
            },

            /***/ 7674: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_78394__
            ) {
              /* eslint-disable no-proto -- safe */
              var anObject = __nested_webpack_require_78394__(9670)
              var aPossiblePrototype = __nested_webpack_require_78394__(6077)

              // `Object.setPrototypeOf` method
              // https://tc39.es/ecma262/#sec-object.setprototypeof
              // Works with __proto__ only. Old v8 can't work with null proto objects.
              module.exports =
                Object.setPrototypeOf ||
                ('__proto__' in {}
                  ? (function () {
                      var CORRECT_SETTER = false
                      var test = {}
                      var setter
                      try {
                        setter = Object.getOwnPropertyDescriptor(
                          Object.prototype,
                          '__proto__'
                        ).set
                        setter.call(test, [])
                        CORRECT_SETTER = test instanceof Array
                      } catch (error) {
                        /* empty */
                      }
                      return function setPrototypeOf(O, proto) {
                        anObject(O)
                        aPossiblePrototype(proto)
                        if (CORRECT_SETTER) setter.call(O, proto)
                        else O.__proto__ = proto
                        return O
                      }
                    })()
                  : undefined)

              /***/
            },

            /***/ 288: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_79325__
            ) {
              'use strict'

              var TO_STRING_TAG_SUPPORT = __nested_webpack_require_79325__(1694)
              var classof = __nested_webpack_require_79325__(648)

              // `Object.prototype.toString` method implementation
              // https://tc39.es/ecma262/#sec-object.prototype.tostring
              module.exports = TO_STRING_TAG_SUPPORT
                ? {}.toString
                : function toString() {
                    return '[object ' + classof(this) + ']'
                  }

              /***/
            },

            /***/ 3887: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_79769__
            ) {
              var getBuiltIn = __nested_webpack_require_79769__(5005)
              var getOwnPropertyNamesModule =
                __nested_webpack_require_79769__(8006)
              var getOwnPropertySymbolsModule =
                __nested_webpack_require_79769__(5181)
              var anObject = __nested_webpack_require_79769__(9670)

              // all object keys, includes non-enumerable and symbols
              module.exports =
                getBuiltIn('Reflect', 'ownKeys') ||
                function ownKeys(it) {
                  var keys = getOwnPropertyNamesModule.f(anObject(it))
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f
                  return getOwnPropertySymbols
                    ? keys.concat(getOwnPropertySymbols(it))
                    : keys
                }

              /***/
            },

            /***/ 857: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_80406__
            ) {
              var global = __nested_webpack_require_80406__(7854)

              module.exports = global

              /***/
            },

            /***/ 2248: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_80571__
            ) {
              var redefine = __nested_webpack_require_80571__(1320)

              module.exports = function (target, src, options) {
                for (var key in src) redefine(target, key, src[key], options)
                return target
              }

              /***/
            },

            /***/ 1320: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_80849__
            ) {
              var global = __nested_webpack_require_80849__(7854)
              var createNonEnumerableProperty =
                __nested_webpack_require_80849__(8880)
              var has = __nested_webpack_require_80849__(6656)
              var setGlobal = __nested_webpack_require_80849__(3505)
              var inspectSource = __nested_webpack_require_80849__(2788)
              var InternalStateModule = __nested_webpack_require_80849__(9909)

              var getInternalState = InternalStateModule.get
              var enforceInternalState = InternalStateModule.enforce
              var TEMPLATE = String(String).split('String')

              ;(module.exports = function (O, key, value, options) {
                var unsafe = options ? !!options.unsafe : false
                var simple = options ? !!options.enumerable : false
                var noTargetGet = options ? !!options.noTargetGet : false
                var state
                if (typeof value == 'function') {
                  if (typeof key == 'string' && !has(value, 'name')) {
                    createNonEnumerableProperty(value, 'name', key)
                  }
                  state = enforceInternalState(value)
                  if (!state.source) {
                    state.source = TEMPLATE.join(
                      typeof key == 'string' ? key : ''
                    )
                  }
                }
                if (O === global) {
                  if (simple) O[key] = value
                  else setGlobal(key, value)
                  return
                } else if (!unsafe) {
                  delete O[key]
                } else if (!noTargetGet && O[key]) {
                  simple = true
                }
                if (simple) O[key] = value
                else createNonEnumerableProperty(O, key, value)
                // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
              })(Function.prototype, 'toString', function toString() {
                return (
                  (typeof this == 'function' &&
                    getInternalState(this).source) ||
                  inspectSource(this)
                )
              })

              /***/
            },

            /***/ 7651: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_82466__
            ) {
              var classof = __nested_webpack_require_82466__(4326)
              var regexpExec = __nested_webpack_require_82466__(2261)

              // `RegExpExec` abstract operation
              // https://tc39.es/ecma262/#sec-regexpexec
              module.exports = function (R, S) {
                var exec = R.exec
                if (typeof exec === 'function') {
                  var result = exec.call(R, S)
                  if (typeof result !== 'object') {
                    throw TypeError(
                      'RegExp exec method returned something other than an Object or null'
                    )
                  }
                  return result
                }

                if (classof(R) !== 'RegExp') {
                  throw TypeError('RegExp#exec called on incompatible receiver')
                }

                return regexpExec.call(R, S)
              }

              /***/
            },

            /***/ 2261: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_83158__
            ) {
              'use strict'

              var regexpFlags = __nested_webpack_require_83158__(7066)
              var stickyHelpers = __nested_webpack_require_83158__(2999)

              var nativeExec = RegExp.prototype.exec
              // This always refers to the native implementation, because the
              // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
              // which loads this file before patching the method.
              var nativeReplace = String.prototype.replace

              var patchedExec = nativeExec

              var UPDATES_LAST_INDEX_WRONG = (function () {
                var re1 = /a/
                var re2 = /b*/g
                nativeExec.call(re1, 'a')
                nativeExec.call(re2, 'a')
                return re1.lastIndex !== 0 || re2.lastIndex !== 0
              })()

              var UNSUPPORTED_Y =
                stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET

              // nonparticipating capturing group, copied from es5-shim's String#split patch.
              // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
              var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined

              var PATCH =
                UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y

              if (PATCH) {
                patchedExec = function exec(str) {
                  var re = this
                  var lastIndex, reCopy, match, i
                  var sticky = UNSUPPORTED_Y && re.sticky
                  var flags = regexpFlags.call(re)
                  var source = re.source
                  var charsAdded = 0
                  var strCopy = str

                  if (sticky) {
                    flags = flags.replace('y', '')
                    if (flags.indexOf('g') === -1) {
                      flags += 'g'
                    }

                    strCopy = String(str).slice(re.lastIndex)
                    // Support anchored sticky behavior.
                    if (
                      re.lastIndex > 0 &&
                      (!re.multiline ||
                        (re.multiline && str[re.lastIndex - 1] !== '\n'))
                    ) {
                      source = '(?: ' + source + ')'
                      strCopy = ' ' + strCopy
                      charsAdded++
                    }
                    // ^(? + rx + ) is needed, in combination with some str slicing, to
                    // simulate the 'y' flag.
                    reCopy = new RegExp('^(?:' + source + ')', flags)
                  }

                  if (NPCG_INCLUDED) {
                    reCopy = new RegExp('^' + source + '$(?!\\s)', flags)
                  }
                  if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex

                  match = nativeExec.call(sticky ? reCopy : re, strCopy)

                  if (sticky) {
                    if (match) {
                      match.input = match.input.slice(charsAdded)
                      match[0] = match[0].slice(charsAdded)
                      match.index = re.lastIndex
                      re.lastIndex += match[0].length
                    } else re.lastIndex = 0
                  } else if (UPDATES_LAST_INDEX_WRONG && match) {
                    re.lastIndex = re.global
                      ? match.index + match[0].length
                      : lastIndex
                  }
                  if (NPCG_INCLUDED && match && match.length > 1) {
                    // Fix browsers whose `exec` methods don't consistently return `undefined`
                    // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
                    nativeReplace.call(match[0], reCopy, function () {
                      for (i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) match[i] = undefined
                      }
                    })
                  }

                  return match
                }
              }

              module.exports = patchedExec

              /***/
            },

            /***/ 7066: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_86176__
            ) {
              'use strict'

              var anObject = __nested_webpack_require_86176__(9670)

              // `RegExp.prototype.flags` getter implementation
              // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
              module.exports = function () {
                var that = anObject(this)
                var result = ''
                if (that.global) result += 'g'
                if (that.ignoreCase) result += 'i'
                if (that.multiline) result += 'm'
                if (that.dotAll) result += 's'
                if (that.unicode) result += 'u'
                if (that.sticky) result += 'y'
                return result
              }

              /***/
            },

            /***/ 2999: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_86753__
            ) {
              'use strict'

              var fails = __nested_webpack_require_86753__(7293)

              // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
              // so we use an intermediate function.
              function RE(s, f) {
                return RegExp(s, f)
              }

              exports.UNSUPPORTED_Y = fails(function () {
                // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
                var re = RE('a', 'y')
                re.lastIndex = 2
                return re.exec('abcd') != null
              })

              exports.BROKEN_CARET = fails(function () {
                // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
                var re = RE('^r', 'gy')
                re.lastIndex = 2
                return re.exec('str') != null
              })

              /***/
            },

            /***/ 4488: /***/ function (module) {
              // `RequireObjectCoercible` abstract operation
              // https://tc39.es/ecma262/#sec-requireobjectcoercible
              module.exports = function (it) {
                if (it == undefined)
                  throw TypeError("Can't call method on " + it)
                return it
              }

              /***/
            },

            /***/ 3505: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_87737__
            ) {
              var global = __nested_webpack_require_87737__(7854)
              var createNonEnumerableProperty =
                __nested_webpack_require_87737__(8880)

              module.exports = function (key, value) {
                try {
                  createNonEnumerableProperty(global, key, value)
                } catch (error) {
                  global[key] = value
                }
                return value
              }

              /***/
            },

            /***/ 6340: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_88106__
            ) {
              'use strict'

              var getBuiltIn = __nested_webpack_require_88106__(5005)
              var definePropertyModule = __nested_webpack_require_88106__(3070)
              var wellKnownSymbol = __nested_webpack_require_88106__(5112)
              var DESCRIPTORS = __nested_webpack_require_88106__(9781)

              var SPECIES = wellKnownSymbol('species')

              module.exports = function (CONSTRUCTOR_NAME) {
                var Constructor = getBuiltIn(CONSTRUCTOR_NAME)
                var defineProperty = definePropertyModule.f

                if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                  defineProperty(Constructor, SPECIES, {
                    configurable: true,
                    get: function () {
                      return this
                    }
                  })
                }
              }

              /***/
            },

            /***/ 8003: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_88786__
            ) {
              var defineProperty = __nested_webpack_require_88786__(3070).f
              var has = __nested_webpack_require_88786__(6656)
              var wellKnownSymbol = __nested_webpack_require_88786__(5112)

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')

              module.exports = function (it, TAG, STATIC) {
                if (
                  it &&
                  !has((it = STATIC ? it : it.prototype), TO_STRING_TAG)
                ) {
                  defineProperty(it, TO_STRING_TAG, {
                    configurable: true,
                    value: TAG
                  })
                }
              }

              /***/
            },

            /***/ 6200: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_89271__
            ) {
              var shared = __nested_webpack_require_89271__(2309)
              var uid = __nested_webpack_require_89271__(9711)

              var keys = shared('keys')

              module.exports = function (key) {
                return keys[key] || (keys[key] = uid(key))
              }

              /***/
            },

            /***/ 5465: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_89559__
            ) {
              var global = __nested_webpack_require_89559__(7854)
              var setGlobal = __nested_webpack_require_89559__(3505)

              var SHARED = '__core-js_shared__'
              var store = global[SHARED] || setGlobal(SHARED, {})

              module.exports = store

              /***/
            },

            /***/ 2309: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_89855__
            ) {
              var IS_PURE = __nested_webpack_require_89855__(1913)
              var store = __nested_webpack_require_89855__(5465)

              ;(module.exports = function (key, value) {
                return (
                  store[key] || (store[key] = value !== undefined ? value : {})
                )
              })('versions', []).push({
                version: '3.9.0',
                mode: IS_PURE ? 'pure' : 'global',
                copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
              })

              /***/
            },

            /***/ 6707: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_90288__
            ) {
              var anObject = __nested_webpack_require_90288__(9670)
              var aFunction = __nested_webpack_require_90288__(3099)
              var wellKnownSymbol = __nested_webpack_require_90288__(5112)

              var SPECIES = wellKnownSymbol('species')

              // `SpeciesConstructor` abstract operation
              // https://tc39.es/ecma262/#sec-speciesconstructor
              module.exports = function (O, defaultConstructor) {
                var C = anObject(O).constructor
                var S
                return C === undefined ||
                  (S = anObject(C)[SPECIES]) == undefined
                  ? defaultConstructor
                  : aFunction(S)
              }

              /***/
            },

            /***/ 8710: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_90863__
            ) {
              var toInteger = __nested_webpack_require_90863__(9958)
              var requireObjectCoercible =
                __nested_webpack_require_90863__(4488)

              // `String.prototype.{ codePointAt, at }` methods implementation
              var createMethod = function (CONVERT_TO_STRING) {
                return function ($this, pos) {
                  var S = String(requireObjectCoercible($this))
                  var position = toInteger(pos)
                  var size = S.length
                  var first, second
                  if (position < 0 || position >= size)
                    return CONVERT_TO_STRING ? '' : undefined
                  first = S.charCodeAt(position)
                  return first < 0xd800 ||
                    first > 0xdbff ||
                    position + 1 === size ||
                    (second = S.charCodeAt(position + 1)) < 0xdc00 ||
                    second > 0xdfff
                    ? CONVERT_TO_STRING
                      ? S.charAt(position)
                      : first
                    : CONVERT_TO_STRING
                    ? S.slice(position, position + 2)
                    : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000
                }
              }

              module.exports = {
                // `String.prototype.codePointAt` method
                // https://tc39.es/ecma262/#sec-string.prototype.codepointat
                codeAt: createMethod(false),
                // `String.prototype.at` method
                // https://github.com/mathiasbynens/String.prototype.at
                charAt: createMethod(true)
              }

              /***/
            },

            /***/ 3197: /***/ function (module) {
              'use strict'

              // based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
              var maxInt = 2147483647 // aka. 0x7FFFFFFF or 2^31-1
              var base = 36
              var tMin = 1
              var tMax = 26
              var skew = 38
              var damp = 700
              var initialBias = 72
              var initialN = 128 // 0x80
              var delimiter = '-' // '\x2D'
              var regexNonASCII = /[^\0-\u007E]/ // non-ASCII chars
              var regexSeparators = /[.\u3002\uFF0E\uFF61]/g // RFC 3490 separators
              var OVERFLOW_ERROR =
                'Overflow: input needs wider integers to process'
              var baseMinusTMin = base - tMin
              var floor = Math.floor
              var stringFromCharCode = String.fromCharCode

              /**
               * Creates an array containing the numeric code points of each Unicode
               * character in the string. While JavaScript uses UCS-2 internally,
               * this function will convert a pair of surrogate halves (each of which
               * UCS-2 exposes as separate characters) into a single code point,
               * matching UTF-16.
               */
              var ucs2decode = function (string) {
                var output = []
                var counter = 0
                var length = string.length
                while (counter < length) {
                  var value = string.charCodeAt(counter++)
                  if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                    // It's a high surrogate, and there is a next character.
                    var extra = string.charCodeAt(counter++)
                    if ((extra & 0xfc00) == 0xdc00) {
                      // Low surrogate.
                      output.push(
                        ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                      )
                    } else {
                      // It's an unmatched surrogate; only append this code unit, in case the
                      // next code unit is the high surrogate of a surrogate pair.
                      output.push(value)
                      counter--
                    }
                  } else {
                    output.push(value)
                  }
                }
                return output
              }

              /**
               * Converts a digit/integer into a basic code point.
               */
              var digitToBasic = function (digit) {
                //  0..25 map to ASCII a..z or A..Z
                // 26..35 map to ASCII 0..9
                return digit + 22 + 75 * (digit < 26)
              }

              /**
               * Bias adaptation function as per section 3.4 of RFC 3492.
               * https://tools.ietf.org/html/rfc3492#section-3.4
               */
              var adapt = function (delta, numPoints, firstTime) {
                var k = 0
                delta = firstTime ? floor(delta / damp) : delta >> 1
                delta += floor(delta / numPoints)
                for (; delta > (baseMinusTMin * tMax) >> 1; k += base) {
                  delta = floor(delta / baseMinusTMin)
                }
                return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew))
              }

              /**
               * Converts a string of Unicode symbols (e.g. a domain name label) to a
               * Punycode string of ASCII-only symbols.
               */
              // eslint-disable-next-line max-statements -- TODO
              var encode = function (input) {
                var output = []

                // Convert the input in UCS-2 to an array of Unicode code points.
                input = ucs2decode(input)

                // Cache the length.
                var inputLength = input.length

                // Initialize the state.
                var n = initialN
                var delta = 0
                var bias = initialBias
                var i, currentValue

                // Handle the basic code points.
                for (i = 0; i < input.length; i++) {
                  currentValue = input[i]
                  if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue))
                  }
                }

                var basicLength = output.length // number of basic code points.
                var handledCPCount = basicLength // number of code points that have been handled;

                // Finish the basic string with a delimiter unless it's empty.
                if (basicLength) {
                  output.push(delimiter)
                }

                // Main encoding loop:
                while (handledCPCount < inputLength) {
                  // All non-basic code points < n have been handled already. Find the next larger one:
                  var m = maxInt
                  for (i = 0; i < input.length; i++) {
                    currentValue = input[i]
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue
                    }
                  }

                  // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
                  var handledCPCountPlusOne = handledCPCount + 1
                  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    throw RangeError(OVERFLOW_ERROR)
                  }

                  delta += (m - n) * handledCPCountPlusOne
                  n = m

                  for (i = 0; i < input.length; i++) {
                    currentValue = input[i]
                    if (currentValue < n && ++delta > maxInt) {
                      throw RangeError(OVERFLOW_ERROR)
                    }
                    if (currentValue == n) {
                      // Represent delta as a generalized variable-length integer.
                      var q = delta
                      for (var k = base /* no condition */; ; k += base) {
                        var t =
                          k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
                        if (q < t) break
                        var qMinusT = q - t
                        var baseMinusT = base - t
                        output.push(
                          stringFromCharCode(
                            digitToBasic(t + (qMinusT % baseMinusT))
                          )
                        )
                        q = floor(qMinusT / baseMinusT)
                      }

                      output.push(stringFromCharCode(digitToBasic(q)))
                      bias = adapt(
                        delta,
                        handledCPCountPlusOne,
                        handledCPCount == basicLength
                      )
                      delta = 0
                      ++handledCPCount
                    }
                  }

                  ++delta
                  ++n
                }
                return output.join('')
              }

              module.exports = function (input) {
                var encoded = []
                var labels = input
                  .toLowerCase()
                  .replace(regexSeparators, '\u002E')
                  .split('.')
                var i, label
                for (i = 0; i < labels.length; i++) {
                  label = labels[i]
                  encoded.push(
                    regexNonASCII.test(label) ? 'xn--' + encode(label) : label
                  )
                }
                return encoded.join('.')
              }

              /***/
            },

            /***/ 6091: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_97360__
            ) {
              var fails = __nested_webpack_require_97360__(7293)
              var whitespaces = __nested_webpack_require_97360__(1361)

              var non = '\u200B\u0085\u180E'

              // check that a method works with the correct list
              // of whitespaces and has a correct name
              module.exports = function (METHOD_NAME) {
                return fails(function () {
                  return (
                    !!whitespaces[METHOD_NAME]() ||
                    non[METHOD_NAME]() != non ||
                    whitespaces[METHOD_NAME].name !== METHOD_NAME
                  )
                })
              }

              /***/
            },

            /***/ 3111: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_97868__
            ) {
              var requireObjectCoercible =
                __nested_webpack_require_97868__(4488)
              var whitespaces = __nested_webpack_require_97868__(1361)

              var whitespace = '[' + whitespaces + ']'
              var ltrim = RegExp('^' + whitespace + whitespace + '*')
              var rtrim = RegExp(whitespace + whitespace + '*$')

              // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
              var createMethod = function (TYPE) {
                return function ($this) {
                  var string = String(requireObjectCoercible($this))
                  if (TYPE & 1) string = string.replace(ltrim, '')
                  if (TYPE & 2) string = string.replace(rtrim, '')
                  return string
                }
              }

              module.exports = {
                // `String.prototype.{ trimLeft, trimStart }` methods
                // https://tc39.es/ecma262/#sec-string.prototype.trimstart
                start: createMethod(1),
                // `String.prototype.{ trimRight, trimEnd }` methods
                // https://tc39.es/ecma262/#sec-string.prototype.trimend
                end: createMethod(2),
                // `String.prototype.trim` method
                // https://tc39.es/ecma262/#sec-string.prototype.trim
                trim: createMethod(3)
              }

              /***/
            },

            /***/ 1400: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_98992__
            ) {
              var toInteger = __nested_webpack_require_98992__(9958)

              var max = Math.max
              var min = Math.min

              // Helper for a popular repeating case of the spec:
              // Let integer be ? ToInteger(index).
              // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
              module.exports = function (index, length) {
                var integer = toInteger(index)
                return integer < 0
                  ? max(integer + length, 0)
                  : min(integer, length)
              }

              /***/
            },

            /***/ 7067: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_99521__
            ) {
              var toInteger = __nested_webpack_require_99521__(9958)
              var toLength = __nested_webpack_require_99521__(7466)

              // `ToIndex` abstract operation
              // https://tc39.es/ecma262/#sec-toindex
              module.exports = function (it) {
                if (it === undefined) return 0
                var number = toInteger(it)
                var length = toLength(number)
                if (number !== length) throw RangeError('Wrong length or index')
                return length
              }

              /***/
            },

            /***/ 5656: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_99996__
            ) {
              // toObject with fallback for non-array-like ES3 strings
              var IndexedObject = __nested_webpack_require_99996__(8361)
              var requireObjectCoercible =
                __nested_webpack_require_99996__(4488)

              module.exports = function (it) {
                return IndexedObject(requireObjectCoercible(it))
              }

              /***/
            },

            /***/ 9958: /***/ function (module) {
              var ceil = Math.ceil
              var floor = Math.floor

              // `ToInteger` abstract operation
              // https://tc39.es/ecma262/#sec-tointeger
              module.exports = function (argument) {
                return isNaN((argument = +argument))
                  ? 0
                  : (argument > 0 ? floor : ceil)(argument)
              }

              /***/
            },

            /***/ 7466: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_100645__
            ) {
              var toInteger = __nested_webpack_require_100645__(9958)

              var min = Math.min

              // `ToLength` abstract operation
              // https://tc39.es/ecma262/#sec-tolength
              module.exports = function (argument) {
                return argument > 0
                  ? min(toInteger(argument), 0x1fffffffffffff)
                  : 0 // 2 ** 53 - 1 == 9007199254740991
              }

              /***/
            },

            /***/ 7908: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101032__
            ) {
              var requireObjectCoercible =
                __nested_webpack_require_101032__(4488)

              // `ToObject` abstract operation
              // https://tc39.es/ecma262/#sec-toobject
              module.exports = function (argument) {
                return Object(requireObjectCoercible(argument))
              }

              /***/
            },

            /***/ 4590: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101355__
            ) {
              var toPositiveInteger = __nested_webpack_require_101355__(3002)

              module.exports = function (it, BYTES) {
                var offset = toPositiveInteger(it)
                if (offset % BYTES) throw RangeError('Wrong offset')
                return offset
              }

              /***/
            },

            /***/ 3002: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101660__
            ) {
              var toInteger = __nested_webpack_require_101660__(9958)

              module.exports = function (it) {
                var result = toInteger(it)
                if (result < 0)
                  throw RangeError("The argument can't be less than 0")
                return result
              }

              /***/
            },

            /***/ 7593: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101959__
            ) {
              var isObject = __nested_webpack_require_101959__(111)

              // `ToPrimitive` abstract operation
              // https://tc39.es/ecma262/#sec-toprimitive
              // instead of the ES6 spec version, we didn't implement @@toPrimitive case
              // and the second argument - flag - preferred type is a string
              module.exports = function (input, PREFERRED_STRING) {
                if (!isObject(input)) return input
                var fn, val
                if (
                  PREFERRED_STRING &&
                  typeof (fn = input.toString) == 'function' &&
                  !isObject((val = fn.call(input)))
                )
                  return val
                if (
                  typeof (fn = input.valueOf) == 'function' &&
                  !isObject((val = fn.call(input)))
                )
                  return val
                if (
                  !PREFERRED_STRING &&
                  typeof (fn = input.toString) == 'function' &&
                  !isObject((val = fn.call(input)))
                )
                  return val
                throw TypeError("Can't convert object to primitive value")
              }

              /***/
            },

            /***/ 1694: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_102821__
            ) {
              var wellKnownSymbol = __nested_webpack_require_102821__(5112)

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              var test = {}

              test[TO_STRING_TAG] = 'z'

              module.exports = String(test) === '[object z]'

              /***/
            },

            /***/ 9843: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_103114__
            ) {
              'use strict'

              var $ = __nested_webpack_require_103114__(2109)
              var global = __nested_webpack_require_103114__(7854)
              var DESCRIPTORS = __nested_webpack_require_103114__(9781)
              var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS =
                __nested_webpack_require_103114__(3832)
              var ArrayBufferViewCore = __nested_webpack_require_103114__(260)
              var ArrayBufferModule = __nested_webpack_require_103114__(3331)
              var anInstance = __nested_webpack_require_103114__(5787)
              var createPropertyDescriptor =
                __nested_webpack_require_103114__(9114)
              var createNonEnumerableProperty =
                __nested_webpack_require_103114__(8880)
              var toLength = __nested_webpack_require_103114__(7466)
              var toIndex = __nested_webpack_require_103114__(7067)
              var toOffset = __nested_webpack_require_103114__(4590)
              var toPrimitive = __nested_webpack_require_103114__(7593)
              var has = __nested_webpack_require_103114__(6656)
              var classof = __nested_webpack_require_103114__(648)
              var isObject = __nested_webpack_require_103114__(111)
              var create = __nested_webpack_require_103114__(30)
              var setPrototypeOf = __nested_webpack_require_103114__(7674)
              var getOwnPropertyNames =
                __nested_webpack_require_103114__(8006).f
              var typedArrayFrom = __nested_webpack_require_103114__(7321)
              var forEach = __nested_webpack_require_103114__(2092).forEach
              var setSpecies = __nested_webpack_require_103114__(6340)
              var definePropertyModule = __nested_webpack_require_103114__(3070)
              var getOwnPropertyDescriptorModule =
                __nested_webpack_require_103114__(1236)
              var InternalStateModule = __nested_webpack_require_103114__(9909)
              var inheritIfRequired = __nested_webpack_require_103114__(9587)

              var getInternalState = InternalStateModule.get
              var setInternalState = InternalStateModule.set
              var nativeDefineProperty = definePropertyModule.f
              var nativeGetOwnPropertyDescriptor =
                getOwnPropertyDescriptorModule.f
              var round = Math.round
              var RangeError = global.RangeError
              var ArrayBuffer = ArrayBufferModule.ArrayBuffer
              var DataView = ArrayBufferModule.DataView
              var NATIVE_ARRAY_BUFFER_VIEWS =
                ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS
              var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG
              var TypedArray = ArrayBufferViewCore.TypedArray
              var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype
              var aTypedArrayConstructor =
                ArrayBufferViewCore.aTypedArrayConstructor
              var isTypedArray = ArrayBufferViewCore.isTypedArray
              var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT'
              var WRONG_LENGTH = 'Wrong length'

              var fromList = function (C, list) {
                var index = 0
                var length = list.length
                var result = new (aTypedArrayConstructor(C))(length)
                while (length > index) result[index] = list[index++]
                return result
              }

              var addGetter = function (it, key) {
                nativeDefineProperty(it, key, {
                  get: function () {
                    return getInternalState(this)[key]
                  }
                })
              }

              var isArrayBuffer = function (it) {
                var klass
                return (
                  it instanceof ArrayBuffer ||
                  (klass = classof(it)) == 'ArrayBuffer' ||
                  klass == 'SharedArrayBuffer'
                )
              }

              var isTypedArrayIndex = function (target, key) {
                return (
                  isTypedArray(target) &&
                  typeof key != 'symbol' &&
                  key in target &&
                  String(+key) == String(key)
                )
              }

              var wrappedGetOwnPropertyDescriptor =
                function getOwnPropertyDescriptor(target, key) {
                  return isTypedArrayIndex(
                    target,
                    (key = toPrimitive(key, true))
                  )
                    ? createPropertyDescriptor(2, target[key])
                    : nativeGetOwnPropertyDescriptor(target, key)
                }

              var wrappedDefineProperty = function defineProperty(
                target,
                key,
                descriptor
              ) {
                if (
                  isTypedArrayIndex(target, (key = toPrimitive(key, true))) &&
                  isObject(descriptor) &&
                  has(descriptor, 'value') &&
                  !has(descriptor, 'get') &&
                  !has(descriptor, 'set') &&
                  // TODO: add validation descriptor w/o calling accessors
                  !descriptor.configurable &&
                  (!has(descriptor, 'writable') || descriptor.writable) &&
                  (!has(descriptor, 'enumerable') || descriptor.enumerable)
                ) {
                  target[key] = descriptor.value
                  return target
                }
                return nativeDefineProperty(target, key, descriptor)
              }

              if (DESCRIPTORS) {
                if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                  getOwnPropertyDescriptorModule.f =
                    wrappedGetOwnPropertyDescriptor
                  definePropertyModule.f = wrappedDefineProperty
                  addGetter(TypedArrayPrototype, 'buffer')
                  addGetter(TypedArrayPrototype, 'byteOffset')
                  addGetter(TypedArrayPrototype, 'byteLength')
                  addGetter(TypedArrayPrototype, 'length')
                }

                $(
                  {
                    target: 'Object',
                    stat: true,
                    forced: !NATIVE_ARRAY_BUFFER_VIEWS
                  },
                  {
                    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
                    defineProperty: wrappedDefineProperty
                  }
                )

                module.exports = function (TYPE, wrapper, CLAMPED) {
                  var BYTES = TYPE.match(/\d+$/)[0] / 8
                  var CONSTRUCTOR_NAME =
                    TYPE + (CLAMPED ? 'Clamped' : '') + 'Array'
                  var GETTER = 'get' + TYPE
                  var SETTER = 'set' + TYPE
                  var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME]
                  var TypedArrayConstructor = NativeTypedArrayConstructor
                  var TypedArrayConstructorPrototype =
                    TypedArrayConstructor && TypedArrayConstructor.prototype
                  var exported = {}

                  var getter = function (that, index) {
                    var data = getInternalState(that)
                    return data.view[GETTER](
                      index * BYTES + data.byteOffset,
                      true
                    )
                  }

                  var setter = function (that, index, value) {
                    var data = getInternalState(that)
                    if (CLAMPED)
                      value =
                        (value = round(value)) < 0
                          ? 0
                          : value > 0xff
                          ? 0xff
                          : value & 0xff
                    data.view[SETTER](
                      index * BYTES + data.byteOffset,
                      value,
                      true
                    )
                  }

                  var addElement = function (that, index) {
                    nativeDefineProperty(that, index, {
                      get: function () {
                        return getter(this, index)
                      },
                      set: function (value) {
                        return setter(this, index, value)
                      },
                      enumerable: true
                    })
                  }

                  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                    TypedArrayConstructor = wrapper(function (
                      that,
                      data,
                      offset,
                      $length
                    ) {
                      anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME)
                      var index = 0
                      var byteOffset = 0
                      var buffer, byteLength, length
                      if (!isObject(data)) {
                        length = toIndex(data)
                        byteLength = length * BYTES
                        buffer = new ArrayBuffer(byteLength)
                      } else if (isArrayBuffer(data)) {
                        buffer = data
                        byteOffset = toOffset(offset, BYTES)
                        var $len = data.byteLength
                        if ($length === undefined) {
                          if ($len % BYTES) throw RangeError(WRONG_LENGTH)
                          byteLength = $len - byteOffset
                          if (byteLength < 0) throw RangeError(WRONG_LENGTH)
                        } else {
                          byteLength = toLength($length) * BYTES
                          if (byteLength + byteOffset > $len)
                            throw RangeError(WRONG_LENGTH)
                        }
                        length = byteLength / BYTES
                      } else if (isTypedArray(data)) {
                        return fromList(TypedArrayConstructor, data)
                      } else {
                        return typedArrayFrom.call(TypedArrayConstructor, data)
                      }
                      setInternalState(that, {
                        buffer: buffer,
                        byteOffset: byteOffset,
                        byteLength: byteLength,
                        length: length,
                        view: new DataView(buffer)
                      })
                      while (index < length) addElement(that, index++)
                    })

                    if (setPrototypeOf)
                      setPrototypeOf(TypedArrayConstructor, TypedArray)
                    TypedArrayConstructorPrototype =
                      TypedArrayConstructor.prototype =
                        create(TypedArrayPrototype)
                  } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
                    TypedArrayConstructor = wrapper(function (
                      dummy,
                      data,
                      typedArrayOffset,
                      $length
                    ) {
                      anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME)
                      return inheritIfRequired(
                        (function () {
                          if (!isObject(data))
                            return new NativeTypedArrayConstructor(
                              toIndex(data)
                            )
                          if (isArrayBuffer(data))
                            return $length !== undefined
                              ? new NativeTypedArrayConstructor(
                                  data,
                                  toOffset(typedArrayOffset, BYTES),
                                  $length
                                )
                              : typedArrayOffset !== undefined
                              ? new NativeTypedArrayConstructor(
                                  data,
                                  toOffset(typedArrayOffset, BYTES)
                                )
                              : new NativeTypedArrayConstructor(data)
                          if (isTypedArray(data))
                            return fromList(TypedArrayConstructor, data)
                          return typedArrayFrom.call(
                            TypedArrayConstructor,
                            data
                          )
                        })(),
                        dummy,
                        TypedArrayConstructor
                      )
                    })

                    if (setPrototypeOf)
                      setPrototypeOf(TypedArrayConstructor, TypedArray)
                    forEach(
                      getOwnPropertyNames(NativeTypedArrayConstructor),
                      function (key) {
                        if (!(key in TypedArrayConstructor)) {
                          createNonEnumerableProperty(
                            TypedArrayConstructor,
                            key,
                            NativeTypedArrayConstructor[key]
                          )
                        }
                      }
                    )
                    TypedArrayConstructor.prototype =
                      TypedArrayConstructorPrototype
                  }

                  if (
                    TypedArrayConstructorPrototype.constructor !==
                    TypedArrayConstructor
                  ) {
                    createNonEnumerableProperty(
                      TypedArrayConstructorPrototype,
                      'constructor',
                      TypedArrayConstructor
                    )
                  }

                  if (TYPED_ARRAY_TAG) {
                    createNonEnumerableProperty(
                      TypedArrayConstructorPrototype,
                      TYPED_ARRAY_TAG,
                      CONSTRUCTOR_NAME
                    )
                  }

                  exported[CONSTRUCTOR_NAME] = TypedArrayConstructor

                  $(
                    {
                      global: true,
                      forced:
                        TypedArrayConstructor != NativeTypedArrayConstructor,
                      sham: !NATIVE_ARRAY_BUFFER_VIEWS
                    },
                    exported
                  )

                  if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
                    createNonEnumerableProperty(
                      TypedArrayConstructor,
                      BYTES_PER_ELEMENT,
                      BYTES
                    )
                  }

                  if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
                    createNonEnumerableProperty(
                      TypedArrayConstructorPrototype,
                      BYTES_PER_ELEMENT,
                      BYTES
                    )
                  }

                  setSpecies(CONSTRUCTOR_NAME)
                }
              } else
                module.exports = function () {
                  /* empty */
                }

              /***/
            },

            /***/ 3832: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_112503__
            ) {
              /* eslint-disable no-new -- required for testing */
              var global = __nested_webpack_require_112503__(7854)
              var fails = __nested_webpack_require_112503__(7293)
              var checkCorrectnessOfIteration =
                __nested_webpack_require_112503__(7072)
              var NATIVE_ARRAY_BUFFER_VIEWS =
                __nested_webpack_require_112503__(260).NATIVE_ARRAY_BUFFER_VIEWS

              var ArrayBuffer = global.ArrayBuffer
              var Int8Array = global.Int8Array

              module.exports =
                !NATIVE_ARRAY_BUFFER_VIEWS ||
                !fails(function () {
                  Int8Array(1)
                }) ||
                !fails(function () {
                  new Int8Array(-1)
                }) ||
                !checkCorrectnessOfIteration(function (iterable) {
                  new Int8Array()
                  new Int8Array(null)
                  new Int8Array(1.5)
                  new Int8Array(iterable)
                }, true) ||
                fails(function () {
                  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
                  return (
                    new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1
                  )
                })

              /***/
            },

            /***/ 3074: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_113426__
            ) {
              var aTypedArrayConstructor =
                __nested_webpack_require_113426__(260).aTypedArrayConstructor
              var speciesConstructor = __nested_webpack_require_113426__(6707)

              module.exports = function (instance, list) {
                var C = speciesConstructor(instance, instance.constructor)
                var index = 0
                var length = list.length
                var result = new (aTypedArrayConstructor(C))(length)
                while (length > index) result[index] = list[index++]
                return result
              }

              /***/
            },

            /***/ 7321: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_113940__
            ) {
              var toObject = __nested_webpack_require_113940__(7908)
              var toLength = __nested_webpack_require_113940__(7466)
              var getIteratorMethod = __nested_webpack_require_113940__(1246)
              var isArrayIteratorMethod =
                __nested_webpack_require_113940__(7659)
              var bind = __nested_webpack_require_113940__(9974)
              var aTypedArrayConstructor =
                __nested_webpack_require_113940__(260).aTypedArrayConstructor

              module.exports = function from(source /* , mapfn, thisArg */) {
                var O = toObject(source)
                var argumentsLength = arguments.length
                var mapfn = argumentsLength > 1 ? arguments[1] : undefined
                var mapping = mapfn !== undefined
                var iteratorMethod = getIteratorMethod(O)
                var i, length, result, step, iterator, next
                if (
                  iteratorMethod != undefined &&
                  !isArrayIteratorMethod(iteratorMethod)
                ) {
                  iterator = iteratorMethod.call(O)
                  next = iterator.next
                  O = []
                  while (!(step = next.call(iterator)).done) {
                    O.push(step.value)
                  }
                }
                if (mapping && argumentsLength > 2) {
                  mapfn = bind(mapfn, arguments[2], 2)
                }
                length = toLength(O.length)
                result = new (aTypedArrayConstructor(this))(length)
                for (i = 0; length > i; i++) {
                  result[i] = mapping ? mapfn(O[i], i) : O[i]
                }
                return result
              }

              /***/
            },

            /***/ 9711: /***/ function (module) {
              var id = 0
              var postfix = Math.random()

              module.exports = function (key) {
                return (
                  'Symbol(' +
                  String(key === undefined ? '' : key) +
                  ')_' +
                  (++id + postfix).toString(36)
                )
              }

              /***/
            },

            /***/ 3307: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_115419__
            ) {
              var NATIVE_SYMBOL = __nested_webpack_require_115419__(133)

              module.exports =
                NATIVE_SYMBOL &&
                /* global Symbol -- safe */
                !Symbol.sham &&
                typeof Symbol.iterator == 'symbol'

              /***/
            },

            /***/ 5112: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_115685__
            ) {
              var global = __nested_webpack_require_115685__(7854)
              var shared = __nested_webpack_require_115685__(2309)
              var has = __nested_webpack_require_115685__(6656)
              var uid = __nested_webpack_require_115685__(9711)
              var NATIVE_SYMBOL = __nested_webpack_require_115685__(133)
              var USE_SYMBOL_AS_UID = __nested_webpack_require_115685__(3307)

              var WellKnownSymbolsStore = shared('wks')
              var Symbol = global.Symbol
              var createWellKnownSymbol = USE_SYMBOL_AS_UID
                ? Symbol
                : (Symbol && Symbol.withoutSetter) || uid

              module.exports = function (name) {
                if (!has(WellKnownSymbolsStore, name)) {
                  if (NATIVE_SYMBOL && has(Symbol, name))
                    WellKnownSymbolsStore[name] = Symbol[name]
                  else
                    WellKnownSymbolsStore[name] = createWellKnownSymbol(
                      'Symbol.' + name
                    )
                }
                return WellKnownSymbolsStore[name]
              }

              /***/
            },

            /***/ 1361: /***/ function (module) {
              // a string of all valid unicode whitespaces
              module.exports =
                '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
                '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'

              /***/
            },

            /***/ 8264: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_116785__
            ) {
              'use strict'

              var $ = __nested_webpack_require_116785__(2109)
              var global = __nested_webpack_require_116785__(7854)
              var arrayBufferModule = __nested_webpack_require_116785__(3331)
              var setSpecies = __nested_webpack_require_116785__(6340)

              var ARRAY_BUFFER = 'ArrayBuffer'
              var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER]
              var NativeArrayBuffer = global[ARRAY_BUFFER]

              // `ArrayBuffer` constructor
              // https://tc39.es/ecma262/#sec-arraybuffer-constructor
              $(
                { global: true, forced: NativeArrayBuffer !== ArrayBuffer },
                {
                  ArrayBuffer: ArrayBuffer
                }
              )

              setSpecies(ARRAY_BUFFER)

              /***/
            },

            /***/ 2222: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_117427__
            ) {
              'use strict'

              var $ = __nested_webpack_require_117427__(2109)
              var fails = __nested_webpack_require_117427__(7293)
              var isArray = __nested_webpack_require_117427__(3157)
              var isObject = __nested_webpack_require_117427__(111)
              var toObject = __nested_webpack_require_117427__(7908)
              var toLength = __nested_webpack_require_117427__(7466)
              var createProperty = __nested_webpack_require_117427__(6135)
              var arraySpeciesCreate = __nested_webpack_require_117427__(5417)
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_117427__(1194)
              var wellKnownSymbol = __nested_webpack_require_117427__(5112)
              var V8_VERSION = __nested_webpack_require_117427__(7392)

              var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable')
              var MAX_SAFE_INTEGER = 0x1fffffffffffff
              var MAXIMUM_ALLOWED_INDEX_EXCEEDED =
                'Maximum allowed index exceeded'

              // We can't use this feature detection in V8 since it causes
              // deoptimization and serious performance degradation
              // https://github.com/zloirock/core-js/issues/679
              var IS_CONCAT_SPREADABLE_SUPPORT =
                V8_VERSION >= 51 ||
                !fails(function () {
                  var array = []
                  array[IS_CONCAT_SPREADABLE] = false
                  return array.concat()[0] !== array
                })

              var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat')

              var isConcatSpreadable = function (O) {
                if (!isObject(O)) return false
                var spreadable = O[IS_CONCAT_SPREADABLE]
                return spreadable !== undefined ? !!spreadable : isArray(O)
              }

              var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT

              // `Array.prototype.concat` method
              // https://tc39.es/ecma262/#sec-array.prototype.concat
              // with adding support of @@isConcatSpreadable and @@species
              $(
                { target: 'Array', proto: true, forced: FORCED },
                {
                  // eslint-disable-next-line no-unused-vars -- required for `.length`
                  concat: function concat(arg) {
                    var O = toObject(this)
                    var A = arraySpeciesCreate(O, 0)
                    var n = 0
                    var i, k, length, len, E
                    for (i = -1, length = arguments.length; i < length; i++) {
                      E = i === -1 ? O : arguments[i]
                      if (isConcatSpreadable(E)) {
                        len = toLength(E.length)
                        if (n + len > MAX_SAFE_INTEGER)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED)
                        for (k = 0; k < len; k++, n++)
                          if (k in E) createProperty(A, n, E[k])
                      } else {
                        if (n >= MAX_SAFE_INTEGER)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED)
                        createProperty(A, n++, E)
                      }
                    }
                    A.length = n
                    return A
                  }
                }
              )

              /***/
            },

            /***/ 7327: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_119834__
            ) {
              'use strict'

              var $ = __nested_webpack_require_119834__(2109)
              var $filter = __nested_webpack_require_119834__(2092).filter
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_119834__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter')

              // `Array.prototype.filter` method
              // https://tc39.es/ecma262/#sec-array.prototype.filter
              // with adding support of @@species
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  filter: function filter(callbackfn /* , thisArg */) {
                    return $filter(
                      this,
                      callbackfn,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                  }
                }
              )

              /***/
            },

            /***/ 2772: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_120523__
            ) {
              'use strict'

              var $ = __nested_webpack_require_120523__(2109)
              var $indexOf = __nested_webpack_require_120523__(1318).indexOf
              var arrayMethodIsStrict = __nested_webpack_require_120523__(9341)

              var nativeIndexOf = [].indexOf

              var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0
              var STRICT_METHOD = arrayMethodIsStrict('indexOf')

              // `Array.prototype.indexOf` method
              // https://tc39.es/ecma262/#sec-array.prototype.indexof
              $(
                {
                  target: 'Array',
                  proto: true,
                  forced: NEGATIVE_ZERO || !STRICT_METHOD
                },
                {
                  indexOf: function indexOf(
                    searchElement /* , fromIndex = 0 */
                  ) {
                    return NEGATIVE_ZERO
                      ? // convert -0 to +0
                        nativeIndexOf.apply(this, arguments) || 0
                      : $indexOf(
                          this,
                          searchElement,
                          arguments.length > 1 ? arguments[1] : undefined
                        )
                  }
                }
              )

              /***/
            },

            /***/ 6992: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_121364__
            ) {
              'use strict'

              var toIndexedObject = __nested_webpack_require_121364__(5656)
              var addToUnscopables = __nested_webpack_require_121364__(1223)
              var Iterators = __nested_webpack_require_121364__(7497)
              var InternalStateModule = __nested_webpack_require_121364__(9909)
              var defineIterator = __nested_webpack_require_121364__(654)

              var ARRAY_ITERATOR = 'Array Iterator'
              var setInternalState = InternalStateModule.set
              var getInternalState =
                InternalStateModule.getterFor(ARRAY_ITERATOR)

              // `Array.prototype.entries` method
              // https://tc39.es/ecma262/#sec-array.prototype.entries
              // `Array.prototype.keys` method
              // https://tc39.es/ecma262/#sec-array.prototype.keys
              // `Array.prototype.values` method
              // https://tc39.es/ecma262/#sec-array.prototype.values
              // `Array.prototype[@@iterator]` method
              // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
              // `CreateArrayIterator` internal method
              // https://tc39.es/ecma262/#sec-createarrayiterator
              module.exports = defineIterator(
                Array,
                'Array',
                function (iterated, kind) {
                  setInternalState(this, {
                    type: ARRAY_ITERATOR,
                    target: toIndexedObject(iterated), // target
                    index: 0, // next index
                    kind: kind // kind
                  })
                  // `%ArrayIteratorPrototype%.next` method
                  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
                },
                function () {
                  var state = getInternalState(this)
                  var target = state.target
                  var kind = state.kind
                  var index = state.index++
                  if (!target || index >= target.length) {
                    state.target = undefined
                    return { value: undefined, done: true }
                  }
                  if (kind == 'keys') return { value: index, done: false }
                  if (kind == 'values')
                    return { value: target[index], done: false }
                  return { value: [index, target[index]], done: false }
                },
                'values'
              )

              // argumentsList[@@iterator] is %ArrayProto_values%
              // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
              // https://tc39.es/ecma262/#sec-createmappedargumentsobject
              Iterators.Arguments = Iterators.Array

              // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
              addToUnscopables('keys')
              addToUnscopables('values')
              addToUnscopables('entries')

              /***/
            },

            /***/ 1249: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_123565__
            ) {
              'use strict'

              var $ = __nested_webpack_require_123565__(2109)
              var $map = __nested_webpack_require_123565__(2092).map
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_123565__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map')

              // `Array.prototype.map` method
              // https://tc39.es/ecma262/#sec-array.prototype.map
              // with adding support of @@species
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  map: function map(callbackfn /* , thisArg */) {
                    return $map(
                      this,
                      callbackfn,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                  }
                }
              )

              /***/
            },

            /***/ 7042: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_124230__
            ) {
              'use strict'

              var $ = __nested_webpack_require_124230__(2109)
              var isObject = __nested_webpack_require_124230__(111)
              var isArray = __nested_webpack_require_124230__(3157)
              var toAbsoluteIndex = __nested_webpack_require_124230__(1400)
              var toLength = __nested_webpack_require_124230__(7466)
              var toIndexedObject = __nested_webpack_require_124230__(5656)
              var createProperty = __nested_webpack_require_124230__(6135)
              var wellKnownSymbol = __nested_webpack_require_124230__(5112)
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_124230__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice')

              var SPECIES = wellKnownSymbol('species')
              var nativeSlice = [].slice
              var max = Math.max

              // `Array.prototype.slice` method
              // https://tc39.es/ecma262/#sec-array.prototype.slice
              // fallback for not array-like ES3 strings and DOM objects
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  slice: function slice(start, end) {
                    var O = toIndexedObject(this)
                    var length = toLength(O.length)
                    var k = toAbsoluteIndex(start, length)
                    var fin = toAbsoluteIndex(
                      end === undefined ? length : end,
                      length
                    )
                    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
                    var Constructor, result, n
                    if (isArray(O)) {
                      Constructor = O.constructor
                      // cross-realm fallback
                      if (
                        typeof Constructor == 'function' &&
                        (Constructor === Array ||
                          isArray(Constructor.prototype))
                      ) {
                        Constructor = undefined
                      } else if (isObject(Constructor)) {
                        Constructor = Constructor[SPECIES]
                        if (Constructor === null) Constructor = undefined
                      }
                      if (Constructor === Array || Constructor === undefined) {
                        return nativeSlice.call(O, k, fin)
                      }
                    }
                    result = new (
                      Constructor === undefined ? Array : Constructor
                    )(max(fin - k, 0))
                    for (n = 0; k < fin; k++, n++)
                      if (k in O) createProperty(result, n, O[k])
                    result.length = n
                    return result
                  }
                }
              )

              /***/
            },

            /***/ 561: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_126211__
            ) {
              'use strict'

              var $ = __nested_webpack_require_126211__(2109)
              var toAbsoluteIndex = __nested_webpack_require_126211__(1400)
              var toInteger = __nested_webpack_require_126211__(9958)
              var toLength = __nested_webpack_require_126211__(7466)
              var toObject = __nested_webpack_require_126211__(7908)
              var arraySpeciesCreate = __nested_webpack_require_126211__(5417)
              var createProperty = __nested_webpack_require_126211__(6135)
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_126211__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice')

              var max = Math.max
              var min = Math.min
              var MAX_SAFE_INTEGER = 0x1fffffffffffff
              var MAXIMUM_ALLOWED_LENGTH_EXCEEDED =
                'Maximum allowed length exceeded'

              // `Array.prototype.splice` method
              // https://tc39.es/ecma262/#sec-array.prototype.splice
              // with adding support of @@species
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  splice: function splice(start, deleteCount /* , ...items */) {
                    var O = toObject(this)
                    var len = toLength(O.length)
                    var actualStart = toAbsoluteIndex(start, len)
                    var argumentsLength = arguments.length
                    var insertCount, actualDeleteCount, A, k, from, to
                    if (argumentsLength === 0) {
                      insertCount = actualDeleteCount = 0
                    } else if (argumentsLength === 1) {
                      insertCount = 0
                      actualDeleteCount = len - actualStart
                    } else {
                      insertCount = argumentsLength - 2
                      actualDeleteCount = min(
                        max(toInteger(deleteCount), 0),
                        len - actualStart
                      )
                    }
                    if (
                      len + insertCount - actualDeleteCount >
                      MAX_SAFE_INTEGER
                    ) {
                      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED)
                    }
                    A = arraySpeciesCreate(O, actualDeleteCount)
                    for (k = 0; k < actualDeleteCount; k++) {
                      from = actualStart + k
                      if (from in O) createProperty(A, k, O[from])
                    }
                    A.length = actualDeleteCount
                    if (insertCount < actualDeleteCount) {
                      for (k = actualStart; k < len - actualDeleteCount; k++) {
                        from = k + actualDeleteCount
                        to = k + insertCount
                        if (from in O) O[to] = O[from]
                        else delete O[to]
                      }
                      for (
                        k = len;
                        k > len - actualDeleteCount + insertCount;
                        k--
                      )
                        delete O[k - 1]
                    } else if (insertCount > actualDeleteCount) {
                      for (k = len - actualDeleteCount; k > actualStart; k--) {
                        from = k + actualDeleteCount - 1
                        to = k + insertCount - 1
                        if (from in O) O[to] = O[from]
                        else delete O[to]
                      }
                    }
                    for (k = 0; k < insertCount; k++) {
                      O[k + actualStart] = arguments[k + 2]
                    }
                    O.length = len - actualDeleteCount + insertCount
                    return A
                  }
                }
              )

              /***/
            },

            /***/ 8309: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_128857__
            ) {
              var DESCRIPTORS = __nested_webpack_require_128857__(9781)
              var defineProperty = __nested_webpack_require_128857__(3070).f

              var FunctionPrototype = Function.prototype
              var FunctionPrototypeToString = FunctionPrototype.toString
              var nameRE = /^\s*function ([^ (]*)/
              var NAME = 'name'

              // Function instances `.name` property
              // https://tc39.es/ecma262/#sec-function-instances-name
              if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
                defineProperty(FunctionPrototype, NAME, {
                  configurable: true,
                  get: function () {
                    try {
                      return FunctionPrototypeToString.call(this).match(
                        nameRE
                      )[1]
                    } catch (error) {
                      return ''
                    }
                  }
                })
              }

              /***/
            },

            /***/ 489: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_129614__
            ) {
              var $ = __nested_webpack_require_129614__(2109)
              var fails = __nested_webpack_require_129614__(7293)
              var toObject = __nested_webpack_require_129614__(7908)
              var nativeGetPrototypeOf = __nested_webpack_require_129614__(9518)
              var CORRECT_PROTOTYPE_GETTER =
                __nested_webpack_require_129614__(8544)

              var FAILS_ON_PRIMITIVES = fails(function () {
                nativeGetPrototypeOf(1)
              })

              // `Object.getPrototypeOf` method
              // https://tc39.es/ecma262/#sec-object.getprototypeof
              $(
                {
                  target: 'Object',
                  stat: true,
                  forced: FAILS_ON_PRIMITIVES,
                  sham: !CORRECT_PROTOTYPE_GETTER
                },
                {
                  getPrototypeOf: function getPrototypeOf(it) {
                    return nativeGetPrototypeOf(toObject(it))
                  }
                }
              )

              /***/
            },

            /***/ 1539: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_130327__
            ) {
              var TO_STRING_TAG_SUPPORT =
                __nested_webpack_require_130327__(1694)
              var redefine = __nested_webpack_require_130327__(1320)
              var toString = __nested_webpack_require_130327__(288)

              // `Object.prototype.toString` method
              // https://tc39.es/ecma262/#sec-object.prototype.tostring
              if (!TO_STRING_TAG_SUPPORT) {
                redefine(Object.prototype, 'toString', toString, {
                  unsafe: true
                })
              }

              /***/
            },

            /***/ 4916: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_130780__
            ) {
              'use strict'

              var $ = __nested_webpack_require_130780__(2109)
              var exec = __nested_webpack_require_130780__(2261)

              // `RegExp.prototype.exec` method
              // https://tc39.es/ecma262/#sec-regexp.prototype.exec
              $(
                { target: 'RegExp', proto: true, forced: /./.exec !== exec },
                {
                  exec: exec
                }
              )

              /***/
            },

            /***/ 9714: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_131156__
            ) {
              'use strict'

              var redefine = __nested_webpack_require_131156__(1320)
              var anObject = __nested_webpack_require_131156__(9670)
              var fails = __nested_webpack_require_131156__(7293)
              var flags = __nested_webpack_require_131156__(7066)

              var TO_STRING = 'toString'
              var RegExpPrototype = RegExp.prototype
              var nativeToString = RegExpPrototype[TO_STRING]

              var NOT_GENERIC = fails(function () {
                return (
                  nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'
                )
              })
              // FF44- RegExp#toString has a wrong name
              var INCORRECT_NAME = nativeToString.name != TO_STRING

              // `RegExp.prototype.toString` method
              // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
              if (NOT_GENERIC || INCORRECT_NAME) {
                redefine(
                  RegExp.prototype,
                  TO_STRING,
                  function toString() {
                    var R = anObject(this)
                    var p = String(R.source)
                    var rf = R.flags
                    var f = String(
                      rf === undefined &&
                        R instanceof RegExp &&
                        !('flags' in RegExpPrototype)
                        ? flags.call(R)
                        : rf
                    )
                    return '/' + p + '/' + f
                  },
                  { unsafe: true }
                )
              }

              /***/
            },

            /***/ 8783: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_132221__
            ) {
              'use strict'

              var charAt = __nested_webpack_require_132221__(8710).charAt
              var InternalStateModule = __nested_webpack_require_132221__(9909)
              var defineIterator = __nested_webpack_require_132221__(654)

              var STRING_ITERATOR = 'String Iterator'
              var setInternalState = InternalStateModule.set
              var getInternalState =
                InternalStateModule.getterFor(STRING_ITERATOR)

              // `String.prototype[@@iterator]` method
              // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
              defineIterator(
                String,
                'String',
                function (iterated) {
                  setInternalState(this, {
                    type: STRING_ITERATOR,
                    string: String(iterated),
                    index: 0
                  })
                  // `%StringIteratorPrototype%.next` method
                  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
                },
                function next() {
                  var state = getInternalState(this)
                  var string = state.string
                  var index = state.index
                  var point
                  if (index >= string.length)
                    return { value: undefined, done: true }
                  point = charAt(string, index)
                  state.index += point.length
                  return { value: point, done: false }
                }
              )

              /***/
            },

            /***/ 4723: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_133333__
            ) {
              'use strict'

              var fixRegExpWellKnownSymbolLogic =
                __nested_webpack_require_133333__(7007)
              var anObject = __nested_webpack_require_133333__(9670)
              var toLength = __nested_webpack_require_133333__(7466)
              var requireObjectCoercible =
                __nested_webpack_require_133333__(4488)
              var advanceStringIndex = __nested_webpack_require_133333__(1530)
              var regExpExec = __nested_webpack_require_133333__(7651)

              // @@match logic
              fixRegExpWellKnownSymbolLogic(
                'match',
                1,
                function (MATCH, nativeMatch, maybeCallNative) {
                  return [
                    // `String.prototype.match` method
                    // https://tc39.es/ecma262/#sec-string.prototype.match
                    function match(regexp) {
                      var O = requireObjectCoercible(this)
                      var matcher =
                        regexp == undefined ? undefined : regexp[MATCH]
                      return matcher !== undefined
                        ? matcher.call(regexp, O)
                        : new RegExp(regexp)[MATCH](String(O))
                    },
                    // `RegExp.prototype[@@match]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
                    function (regexp) {
                      var res = maybeCallNative(nativeMatch, regexp, this)
                      if (res.done) return res.value

                      var rx = anObject(regexp)
                      var S = String(this)

                      if (!rx.global) return regExpExec(rx, S)

                      var fullUnicode = rx.unicode
                      rx.lastIndex = 0
                      var A = []
                      var n = 0
                      var result
                      while ((result = regExpExec(rx, S)) !== null) {
                        var matchStr = String(result[0])
                        A[n] = matchStr
                        if (matchStr === '')
                          rx.lastIndex = advanceStringIndex(
                            S,
                            toLength(rx.lastIndex),
                            fullUnicode
                          )
                        n++
                      }
                      return n === 0 ? null : A
                    }
                  ]
                }
              )

              /***/
            },

            /***/ 5306: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_134975__
            ) {
              'use strict'

              var fixRegExpWellKnownSymbolLogic =
                __nested_webpack_require_134975__(7007)
              var anObject = __nested_webpack_require_134975__(9670)
              var toLength = __nested_webpack_require_134975__(7466)
              var toInteger = __nested_webpack_require_134975__(9958)
              var requireObjectCoercible =
                __nested_webpack_require_134975__(4488)
              var advanceStringIndex = __nested_webpack_require_134975__(1530)
              var getSubstitution = __nested_webpack_require_134975__(647)
              var regExpExec = __nested_webpack_require_134975__(7651)

              var max = Math.max
              var min = Math.min

              var maybeToString = function (it) {
                return it === undefined ? it : String(it)
              }

              // @@replace logic
              fixRegExpWellKnownSymbolLogic(
                'replace',
                2,
                function (REPLACE, nativeReplace, maybeCallNative, reason) {
                  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE =
                    reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0
                  var UNSAFE_SUBSTITUTE =
                    REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0'

                  return [
                    // `String.prototype.replace` method
                    // https://tc39.es/ecma262/#sec-string.prototype.replace
                    function replace(searchValue, replaceValue) {
                      var O = requireObjectCoercible(this)
                      var replacer =
                        searchValue == undefined
                          ? undefined
                          : searchValue[REPLACE]
                      return replacer !== undefined
                        ? replacer.call(searchValue, O, replaceValue)
                        : nativeReplace.call(
                            String(O),
                            searchValue,
                            replaceValue
                          )
                    },
                    // `RegExp.prototype[@@replace]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
                    function (regexp, replaceValue) {
                      if (
                        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE &&
                          REPLACE_KEEPS_$0) ||
                        (typeof replaceValue === 'string' &&
                          replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
                      ) {
                        var res = maybeCallNative(
                          nativeReplace,
                          regexp,
                          this,
                          replaceValue
                        )
                        if (res.done) return res.value
                      }

                      var rx = anObject(regexp)
                      var S = String(this)

                      var functionalReplace = typeof replaceValue === 'function'
                      if (!functionalReplace)
                        replaceValue = String(replaceValue)

                      var global = rx.global
                      if (global) {
                        var fullUnicode = rx.unicode
                        rx.lastIndex = 0
                      }
                      var results = []
                      while (true) {
                        var result = regExpExec(rx, S)
                        if (result === null) break

                        results.push(result)
                        if (!global) break

                        var matchStr = String(result[0])
                        if (matchStr === '')
                          rx.lastIndex = advanceStringIndex(
                            S,
                            toLength(rx.lastIndex),
                            fullUnicode
                          )
                      }

                      var accumulatedResult = ''
                      var nextSourcePosition = 0
                      for (var i = 0; i < results.length; i++) {
                        result = results[i]

                        var matched = String(result[0])
                        var position = max(
                          min(toInteger(result.index), S.length),
                          0
                        )
                        var captures = []
                        // NOTE: This is equivalent to
                        //   captures = result.slice(1).map(maybeToString)
                        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                        for (var j = 1; j < result.length; j++)
                          captures.push(maybeToString(result[j]))
                        var namedCaptures = result.groups
                        if (functionalReplace) {
                          var replacerArgs = [matched].concat(
                            captures,
                            position,
                            S
                          )
                          if (namedCaptures !== undefined)
                            replacerArgs.push(namedCaptures)
                          var replacement = String(
                            replaceValue.apply(undefined, replacerArgs)
                          )
                        } else {
                          replacement = getSubstitution(
                            matched,
                            S,
                            position,
                            captures,
                            namedCaptures,
                            replaceValue
                          )
                        }
                        if (position >= nextSourcePosition) {
                          accumulatedResult +=
                            S.slice(nextSourcePosition, position) + replacement
                          nextSourcePosition = position + matched.length
                        }
                      }
                      return accumulatedResult + S.slice(nextSourcePosition)
                    }
                  ]
                }
              )

              /***/
            },

            /***/ 3123: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_139010__
            ) {
              'use strict'

              var fixRegExpWellKnownSymbolLogic =
                __nested_webpack_require_139010__(7007)
              var isRegExp = __nested_webpack_require_139010__(7850)
              var anObject = __nested_webpack_require_139010__(9670)
              var requireObjectCoercible =
                __nested_webpack_require_139010__(4488)
              var speciesConstructor = __nested_webpack_require_139010__(6707)
              var advanceStringIndex = __nested_webpack_require_139010__(1530)
              var toLength = __nested_webpack_require_139010__(7466)
              var callRegExpExec = __nested_webpack_require_139010__(7651)
              var regexpExec = __nested_webpack_require_139010__(2261)
              var fails = __nested_webpack_require_139010__(7293)

              var arrayPush = [].push
              var min = Math.min
              var MAX_UINT32 = 0xffffffff

              // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
              var SUPPORTS_Y = !fails(function () {
                return !RegExp(MAX_UINT32, 'y')
              })

              // @@split logic
              fixRegExpWellKnownSymbolLogic(
                'split',
                2,
                function (SPLIT, nativeSplit, maybeCallNative) {
                  var internalSplit
                  if (
                    'abbc'.split(/(b)*/)[1] == 'c' ||
                    // eslint-disable-next-line regexp/no-empty-group -- required for testing
                    'test'.split(/(?:)/, -1).length != 4 ||
                    'ab'.split(/(?:ab)*/).length != 2 ||
                    '.'.split(/(.?)(.?)/).length != 4 ||
                    // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
                    '.'.split(/()()/).length > 1 ||
                    ''.split(/.?/).length
                  ) {
                    // based on es5-shim implementation, need to rework it
                    internalSplit = function (separator, limit) {
                      var string = String(requireObjectCoercible(this))
                      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0
                      if (lim === 0) return []
                      if (separator === undefined) return [string]
                      // If `separator` is not a regex, use native split
                      if (!isRegExp(separator)) {
                        return nativeSplit.call(string, separator, lim)
                      }
                      var output = []
                      var flags =
                        (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline ? 'm' : '') +
                        (separator.unicode ? 'u' : '') +
                        (separator.sticky ? 'y' : '')
                      var lastLastIndex = 0
                      // Make `global` and avoid `lastIndex` issues by working with a copy
                      var separatorCopy = new RegExp(
                        separator.source,
                        flags + 'g'
                      )
                      var match, lastIndex, lastLength
                      while ((match = regexpExec.call(separatorCopy, string))) {
                        lastIndex = separatorCopy.lastIndex
                        if (lastIndex > lastLastIndex) {
                          output.push(string.slice(lastLastIndex, match.index))
                          if (match.length > 1 && match.index < string.length)
                            arrayPush.apply(output, match.slice(1))
                          lastLength = match[0].length
                          lastLastIndex = lastIndex
                          if (output.length >= lim) break
                        }
                        if (separatorCopy.lastIndex === match.index)
                          separatorCopy.lastIndex++ // Avoid an infinite loop
                      }
                      if (lastLastIndex === string.length) {
                        if (lastLength || !separatorCopy.test(''))
                          output.push('')
                      } else output.push(string.slice(lastLastIndex))
                      return output.length > lim ? output.slice(0, lim) : output
                    }
                    // Chakra, V8
                  } else if ('0'.split(undefined, 0).length) {
                    internalSplit = function (separator, limit) {
                      return separator === undefined && limit === 0
                        ? []
                        : nativeSplit.call(this, separator, limit)
                    }
                  } else internalSplit = nativeSplit

                  return [
                    // `String.prototype.split` method
                    // https://tc39.es/ecma262/#sec-string.prototype.split
                    function split(separator, limit) {
                      var O = requireObjectCoercible(this)
                      var splitter =
                        separator == undefined ? undefined : separator[SPLIT]
                      return splitter !== undefined
                        ? splitter.call(separator, O, limit)
                        : internalSplit.call(String(O), separator, limit)
                    },
                    // `RegExp.prototype[@@split]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
                    //
                    // NOTE: This cannot be properly polyfilled in engines that don't support
                    // the 'y' flag.
                    function (regexp, limit) {
                      var res = maybeCallNative(
                        internalSplit,
                        regexp,
                        this,
                        limit,
                        internalSplit !== nativeSplit
                      )
                      if (res.done) return res.value

                      var rx = anObject(regexp)
                      var S = String(this)
                      var C = speciesConstructor(rx, RegExp)

                      var unicodeMatching = rx.unicode
                      var flags =
                        (rx.ignoreCase ? 'i' : '') +
                        (rx.multiline ? 'm' : '') +
                        (rx.unicode ? 'u' : '') +
                        (SUPPORTS_Y ? 'y' : 'g')

                      // ^(? + rx + ) is needed, in combination with some S slicing, to
                      // simulate the 'y' flag.
                      var splitter = new C(
                        SUPPORTS_Y ? rx : '^(?:' + rx.source + ')',
                        flags
                      )
                      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0
                      if (lim === 0) return []
                      if (S.length === 0)
                        return callRegExpExec(splitter, S) === null ? [S] : []
                      var p = 0
                      var q = 0
                      var A = []
                      while (q < S.length) {
                        splitter.lastIndex = SUPPORTS_Y ? q : 0
                        var z = callRegExpExec(
                          splitter,
                          SUPPORTS_Y ? S : S.slice(q)
                        )
                        var e
                        if (
                          z === null ||
                          (e = min(
                            toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)),
                            S.length
                          )) === p
                        ) {
                          q = advanceStringIndex(S, q, unicodeMatching)
                        } else {
                          A.push(S.slice(p, q))
                          if (A.length === lim) return A
                          for (var i = 1; i <= z.length - 1; i++) {
                            A.push(z[i])
                            if (A.length === lim) return A
                          }
                          q = p = e
                        }
                      }
                      A.push(S.slice(p))
                      return A
                    }
                  ]
                },
                !SUPPORTS_Y
              )

              /***/
            },

            /***/ 3210: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_144619__
            ) {
              'use strict'

              var $ = __nested_webpack_require_144619__(2109)
              var $trim = __nested_webpack_require_144619__(3111).trim
              var forcedStringTrimMethod =
                __nested_webpack_require_144619__(6091)

              // `String.prototype.trim` method
              // https://tc39.es/ecma262/#sec-string.prototype.trim
              $(
                {
                  target: 'String',
                  proto: true,
                  forced: forcedStringTrimMethod('trim')
                },
                {
                  trim: function trim() {
                    return $trim(this)
                  }
                }
              )

              /***/
            },

            /***/ 2990: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_145111__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_145111__(260)
              var $copyWithin = __nested_webpack_require_145111__(1048)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.copyWithin` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
              exportTypedArrayMethod(
                'copyWithin',
                function copyWithin(target, start /* , end */) {
                  return $copyWithin.call(
                    aTypedArray(this),
                    target,
                    start,
                    arguments.length > 2 ? arguments[2] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 8927: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_145777__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_145777__(260)
              var $every = __nested_webpack_require_145777__(2092).every

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.every` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
              exportTypedArrayMethod(
                'every',
                function every(callbackfn /* , thisArg */) {
                  return $every(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 3105: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_146412__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_146412__(260)
              var $fill = __nested_webpack_require_146412__(1285)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.fill` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              exportTypedArrayMethod(
                'fill',
                function fill(value /* , start, end */) {
                  return $fill.apply(aTypedArray(this), arguments)
                }
              )

              /***/
            },

            /***/ 5035: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_147058__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_147058__(260)
              var $filter = __nested_webpack_require_147058__(2092).filter
              var fromSpeciesAndList = __nested_webpack_require_147058__(3074)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.filter` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
              exportTypedArrayMethod(
                'filter',
                function filter(callbackfn /* , thisArg */) {
                  var list = $filter(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                  return fromSpeciesAndList(this, list)
                }
              )

              /***/
            },

            /***/ 7174: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_147797__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_147797__(260)
              var $findIndex = __nested_webpack_require_147797__(2092).findIndex

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.findIndex` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
              exportTypedArrayMethod(
                'findIndex',
                function findIndex(predicate /* , thisArg */) {
                  return $findIndex(
                    aTypedArray(this),
                    predicate,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 4345: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_148458__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_148458__(260)
              var $find = __nested_webpack_require_148458__(2092).find

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.find` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
              exportTypedArrayMethod(
                'find',
                function find(predicate /* , thisArg */) {
                  return $find(
                    aTypedArray(this),
                    predicate,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 2846: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_149084__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_149084__(260)
              var $forEach = __nested_webpack_require_149084__(2092).forEach

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.forEach` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
              exportTypedArrayMethod(
                'forEach',
                function forEach(callbackfn /* , thisArg */) {
                  $forEach(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 4731: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_149726__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_149726__(260)
              var $includes = __nested_webpack_require_149726__(1318).includes

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.includes` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
              exportTypedArrayMethod(
                'includes',
                function includes(searchElement /* , fromIndex */) {
                  return $includes(
                    aTypedArray(this),
                    searchElement,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 7209: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_150390__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_150390__(260)
              var $indexOf = __nested_webpack_require_150390__(1318).indexOf

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.indexOf` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
              exportTypedArrayMethod(
                'indexOf',
                function indexOf(searchElement /* , fromIndex */) {
                  return $indexOf(
                    aTypedArray(this),
                    searchElement,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 6319: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_151047__
            ) {
              'use strict'

              var global = __nested_webpack_require_151047__(7854)
              var ArrayBufferViewCore = __nested_webpack_require_151047__(260)
              var ArrayIterators = __nested_webpack_require_151047__(6992)
              var wellKnownSymbol = __nested_webpack_require_151047__(5112)

              var ITERATOR = wellKnownSymbol('iterator')
              var Uint8Array = global.Uint8Array
              var arrayValues = ArrayIterators.values
              var arrayKeys = ArrayIterators.keys
              var arrayEntries = ArrayIterators.entries
              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var nativeTypedArrayIterator =
                Uint8Array && Uint8Array.prototype[ITERATOR]

              var CORRECT_ITER_NAME =
                !!nativeTypedArrayIterator &&
                (nativeTypedArrayIterator.name == 'values' ||
                  nativeTypedArrayIterator.name == undefined)

              var typedArrayValues = function values() {
                return arrayValues.call(aTypedArray(this))
              }

              // `%TypedArray%.prototype.entries` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
              exportTypedArrayMethod('entries', function entries() {
                return arrayEntries.call(aTypedArray(this))
              })
              // `%TypedArray%.prototype.keys` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
              exportTypedArrayMethod('keys', function keys() {
                return arrayKeys.call(aTypedArray(this))
              })
              // `%TypedArray%.prototype.values` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
              exportTypedArrayMethod(
                'values',
                typedArrayValues,
                !CORRECT_ITER_NAME
              )
              // `%TypedArray%.prototype[@@iterator]` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
              exportTypedArrayMethod(
                ITERATOR,
                typedArrayValues,
                !CORRECT_ITER_NAME
              )

              /***/
            },

            /***/ 8867: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_152782__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_152782__(260)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $join = [].join

              // `%TypedArray%.prototype.join` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              exportTypedArrayMethod('join', function join(separator) {
                return $join.apply(aTypedArray(this), arguments)
              })

              /***/
            },

            /***/ 7789: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_153395__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_153395__(260)
              var $lastIndexOf = __nested_webpack_require_153395__(6583)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.lastIndexOf` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              exportTypedArrayMethod(
                'lastIndexOf',
                function lastIndexOf(searchElement /* , fromIndex */) {
                  return $lastIndexOf.apply(aTypedArray(this), arguments)
                }
              )

              /***/
            },

            /***/ 3739: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_154090__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_154090__(260)
              var $map = __nested_webpack_require_154090__(2092).map
              var speciesConstructor = __nested_webpack_require_154090__(6707)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var aTypedArrayConstructor =
                ArrayBufferViewCore.aTypedArrayConstructor
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.map` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
              exportTypedArrayMethod(
                'map',
                function map(mapfn /* , thisArg */) {
                  return $map(
                    aTypedArray(this),
                    mapfn,
                    arguments.length > 1 ? arguments[1] : undefined,
                    function (O, length) {
                      return new (aTypedArrayConstructor(
                        speciesConstructor(O, O.constructor)
                      ))(length)
                    }
                  )
                }
              )

              /***/
            },

            /***/ 4483: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_154941__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_154941__(260)
              var $reduceRight = __nested_webpack_require_154941__(3671).right

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.reduceRicht` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
              exportTypedArrayMethod(
                'reduceRight',
                function reduceRight(callbackfn /* , initialValue */) {
                  return $reduceRight(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 9368: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_155635__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_155635__(260)
              var $reduce = __nested_webpack_require_155635__(3671).left

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.reduce` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
              exportTypedArrayMethod(
                'reduce',
                function reduce(callbackfn /* , initialValue */) {
                  return $reduce(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 2056: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_156298__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_156298__(260)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var floor = Math.floor

              // `%TypedArray%.prototype.reverse` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
              exportTypedArrayMethod('reverse', function reverse() {
                var that = this
                var length = aTypedArray(that).length
                var middle = floor(length / 2)
                var index = 0
                var value
                while (index < middle) {
                  value = that[index]
                  that[index++] = that[--length]
                  that[length] = value
                }
                return that
              })

              /***/
            },

            /***/ 3462: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_157051__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_157051__(260)
              var toLength = __nested_webpack_require_157051__(7466)
              var toOffset = __nested_webpack_require_157051__(4590)
              var toObject = __nested_webpack_require_157051__(7908)
              var fails = __nested_webpack_require_157051__(7293)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              var FORCED = fails(function () {
                /* global Int8Array -- safe */
                new Int8Array(1).set({})
              })

              // `%TypedArray%.prototype.set` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
              exportTypedArrayMethod(
                'set',
                function set(arrayLike /* , offset */) {
                  aTypedArray(this)
                  var offset = toOffset(
                    arguments.length > 1 ? arguments[1] : undefined,
                    1
                  )
                  var length = this.length
                  var src = toObject(arrayLike)
                  var len = toLength(src.length)
                  var index = 0
                  if (len + offset > length) throw RangeError('Wrong length')
                  while (index < len) this[offset + index] = src[index++]
                },
                FORCED
              )

              /***/
            },

            /***/ 678: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_158136__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_158136__(260)
              var speciesConstructor = __nested_webpack_require_158136__(6707)
              var fails = __nested_webpack_require_158136__(7293)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var aTypedArrayConstructor =
                ArrayBufferViewCore.aTypedArrayConstructor
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $slice = [].slice

              var FORCED = fails(function () {
                /* global Int8Array -- safe */
                new Int8Array(1).slice()
              })

              // `%TypedArray%.prototype.slice` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
              exportTypedArrayMethod(
                'slice',
                function slice(start, end) {
                  var list = $slice.call(aTypedArray(this), start, end)
                  var C = speciesConstructor(this, this.constructor)
                  var index = 0
                  var length = list.length
                  var result = new (aTypedArrayConstructor(C))(length)
                  while (length > index) result[index] = list[index++]
                  return result
                },
                FORCED
              )

              /***/
            },

            /***/ 7462: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_159191__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_159191__(260)
              var $some = __nested_webpack_require_159191__(2092).some

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.some` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
              exportTypedArrayMethod(
                'some',
                function some(callbackfn /* , thisArg */) {
                  return $some(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 3824: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_159819__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_159819__(260)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $sort = [].sort

              // `%TypedArray%.prototype.sort` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
              exportTypedArrayMethod('sort', function sort(comparefn) {
                return $sort.call(aTypedArray(this), comparefn)
              })

              /***/
            },

            /***/ 5021: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_160362__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_160362__(260)
              var toLength = __nested_webpack_require_160362__(7466)
              var toAbsoluteIndex = __nested_webpack_require_160362__(1400)
              var speciesConstructor = __nested_webpack_require_160362__(6707)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.subarray` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
              exportTypedArrayMethod('subarray', function subarray(begin, end) {
                var O = aTypedArray(this)
                var length = O.length
                var beginIndex = toAbsoluteIndex(begin, length)
                return new (speciesConstructor(O, O.constructor))(
                  O.buffer,
                  O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
                  toLength(
                    (end === undefined
                      ? length
                      : toAbsoluteIndex(end, length)) - beginIndex
                  )
                )
              })

              /***/
            },

            /***/ 2974: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_161310__
            ) {
              'use strict'

              var global = __nested_webpack_require_161310__(7854)
              var ArrayBufferViewCore = __nested_webpack_require_161310__(260)
              var fails = __nested_webpack_require_161310__(7293)

              var Int8Array = global.Int8Array
              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $toLocaleString = [].toLocaleString
              var $slice = [].slice

              // iOS Safari 6.x fails here
              var TO_LOCALE_STRING_BUG =
                !!Int8Array &&
                fails(function () {
                  $toLocaleString.call(new Int8Array(1))
                })

              var FORCED =
                fails(function () {
                  return (
                    [1, 2].toLocaleString() !=
                    new Int8Array([1, 2]).toLocaleString()
                  )
                }) ||
                !fails(function () {
                  Int8Array.prototype.toLocaleString.call([1, 2])
                })

              // `%TypedArray%.prototype.toLocaleString` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
              exportTypedArrayMethod(
                'toLocaleString',
                function toLocaleString() {
                  return $toLocaleString.apply(
                    TO_LOCALE_STRING_BUG
                      ? $slice.call(aTypedArray(this))
                      : aTypedArray(this),
                    arguments
                  )
                },
                FORCED
              )

              /***/
            },

            /***/ 5016: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_162445__
            ) {
              'use strict'

              var exportTypedArrayMethod =
                __nested_webpack_require_162445__(260).exportTypedArrayMethod
              var fails = __nested_webpack_require_162445__(7293)
              var global = __nested_webpack_require_162445__(7854)

              var Uint8Array = global.Uint8Array
              var Uint8ArrayPrototype =
                (Uint8Array && Uint8Array.prototype) || {}
              var arrayToString = [].toString
              var arrayJoin = [].join

              if (
                fails(function () {
                  arrayToString.call({})
                })
              ) {
                arrayToString = function toString() {
                  return arrayJoin.call(this)
                }
              }

              var IS_NOT_ARRAY_METHOD =
                Uint8ArrayPrototype.toString != arrayToString

              // `%TypedArray%.prototype.toString` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
              exportTypedArrayMethod(
                'toString',
                arrayToString,
                IS_NOT_ARRAY_METHOD
              )

              /***/
            },

            /***/ 2472: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_163286__
            ) {
              var createTypedArrayConstructor =
                __nested_webpack_require_163286__(9843)

              // `Uint8Array` constructor
              // https://tc39.es/ecma262/#sec-typedarray-objects
              createTypedArrayConstructor('Uint8', function (init) {
                return function Uint8Array(data, byteOffset, length) {
                  return init(this, data, byteOffset, length)
                }
              })

              /***/
            },

            /***/ 4747: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_163713__
            ) {
              var global = __nested_webpack_require_163713__(7854)
              var DOMIterables = __nested_webpack_require_163713__(8324)
              var forEach = __nested_webpack_require_163713__(8533)
              var createNonEnumerableProperty =
                __nested_webpack_require_163713__(8880)

              for (var COLLECTION_NAME in DOMIterables) {
                var Collection = global[COLLECTION_NAME]
                var CollectionPrototype = Collection && Collection.prototype
                // some Chrome versions have non-configurable methods on DOMTokenList
                if (
                  CollectionPrototype &&
                  CollectionPrototype.forEach !== forEach
                )
                  try {
                    createNonEnumerableProperty(
                      CollectionPrototype,
                      'forEach',
                      forEach
                    )
                  } catch (error) {
                    CollectionPrototype.forEach = forEach
                  }
              }

              /***/
            },

            /***/ 3948: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_164461__
            ) {
              var global = __nested_webpack_require_164461__(7854)
              var DOMIterables = __nested_webpack_require_164461__(8324)
              var ArrayIteratorMethods = __nested_webpack_require_164461__(6992)
              var createNonEnumerableProperty =
                __nested_webpack_require_164461__(8880)
              var wellKnownSymbol = __nested_webpack_require_164461__(5112)

              var ITERATOR = wellKnownSymbol('iterator')
              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              var ArrayValues = ArrayIteratorMethods.values

              for (var COLLECTION_NAME in DOMIterables) {
                var Collection = global[COLLECTION_NAME]
                var CollectionPrototype = Collection && Collection.prototype
                if (CollectionPrototype) {
                  // some Chrome versions have non-configurable methods on DOMTokenList
                  if (CollectionPrototype[ITERATOR] !== ArrayValues)
                    try {
                      createNonEnumerableProperty(
                        CollectionPrototype,
                        ITERATOR,
                        ArrayValues
                      )
                    } catch (error) {
                      CollectionPrototype[ITERATOR] = ArrayValues
                    }
                  if (!CollectionPrototype[TO_STRING_TAG]) {
                    createNonEnumerableProperty(
                      CollectionPrototype,
                      TO_STRING_TAG,
                      COLLECTION_NAME
                    )
                  }
                  if (DOMIterables[COLLECTION_NAME])
                    for (var METHOD_NAME in ArrayIteratorMethods) {
                      // some Chrome versions have non-configurable methods on DOMTokenList
                      if (
                        CollectionPrototype[METHOD_NAME] !==
                        ArrayIteratorMethods[METHOD_NAME]
                      )
                        try {
                          createNonEnumerableProperty(
                            CollectionPrototype,
                            METHOD_NAME,
                            ArrayIteratorMethods[METHOD_NAME]
                          )
                        } catch (error) {
                          CollectionPrototype[METHOD_NAME] =
                            ArrayIteratorMethods[METHOD_NAME]
                        }
                    }
                }
              }

              /***/
            },

            /***/ 1637: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_166049__
            ) {
              'use strict'

              // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
              __nested_webpack_require_166049__(6992)
              var $ = __nested_webpack_require_166049__(2109)
              var getBuiltIn = __nested_webpack_require_166049__(5005)
              var USE_NATIVE_URL = __nested_webpack_require_166049__(590)
              var redefine = __nested_webpack_require_166049__(1320)
              var redefineAll = __nested_webpack_require_166049__(2248)
              var setToStringTag = __nested_webpack_require_166049__(8003)
              var createIteratorConstructor =
                __nested_webpack_require_166049__(4994)
              var InternalStateModule = __nested_webpack_require_166049__(9909)
              var anInstance = __nested_webpack_require_166049__(5787)
              var hasOwn = __nested_webpack_require_166049__(6656)
              var bind = __nested_webpack_require_166049__(9974)
              var classof = __nested_webpack_require_166049__(648)
              var anObject = __nested_webpack_require_166049__(9670)
              var isObject = __nested_webpack_require_166049__(111)
              var create = __nested_webpack_require_166049__(30)
              var createPropertyDescriptor =
                __nested_webpack_require_166049__(9114)
              var getIterator = __nested_webpack_require_166049__(8554)
              var getIteratorMethod = __nested_webpack_require_166049__(1246)
              var wellKnownSymbol = __nested_webpack_require_166049__(5112)

              var $fetch = getBuiltIn('fetch')
              var Headers = getBuiltIn('Headers')
              var ITERATOR = wellKnownSymbol('iterator')
              var URL_SEARCH_PARAMS = 'URLSearchParams'
              var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator'
              var setInternalState = InternalStateModule.set
              var getInternalParamsState =
                InternalStateModule.getterFor(URL_SEARCH_PARAMS)
              var getInternalIteratorState = InternalStateModule.getterFor(
                URL_SEARCH_PARAMS_ITERATOR
              )

              var plus = /\+/g
              var sequences = Array(4)

              var percentSequence = function (bytes) {
                return (
                  sequences[bytes - 1] ||
                  (sequences[bytes - 1] = RegExp(
                    '((?:%[\\da-f]{2}){' + bytes + '})',
                    'gi'
                  ))
                )
              }

              var percentDecode = function (sequence) {
                try {
                  return decodeURIComponent(sequence)
                } catch (error) {
                  return sequence
                }
              }

              var deserialize = function (it) {
                var result = it.replace(plus, ' ')
                var bytes = 4
                try {
                  return decodeURIComponent(result)
                } catch (error) {
                  while (bytes) {
                    result = result.replace(
                      percentSequence(bytes--),
                      percentDecode
                    )
                  }
                  return result
                }
              }

              var find = /[!'()~]|%20/g

              var replace = {
                '!': '%21',
                "'": '%27',
                '(': '%28',
                ')': '%29',
                '~': '%7E',
                '%20': '+'
              }

              var replacer = function (match) {
                return replace[match]
              }

              var serialize = function (it) {
                return encodeURIComponent(it).replace(find, replacer)
              }

              var parseSearchParams = function (result, query) {
                if (query) {
                  var attributes = query.split('&')
                  var index = 0
                  var attribute, entry
                  while (index < attributes.length) {
                    attribute = attributes[index++]
                    if (attribute.length) {
                      entry = attribute.split('=')
                      result.push({
                        key: deserialize(entry.shift()),
                        value: deserialize(entry.join('='))
                      })
                    }
                  }
                }
              }

              var updateSearchParams = function (query) {
                this.entries.length = 0
                parseSearchParams(this.entries, query)
              }

              var validateArgumentsLength = function (passed, required) {
                if (passed < required) throw TypeError('Not enough arguments')
              }

              var URLSearchParamsIterator = createIteratorConstructor(
                function Iterator(params, kind) {
                  setInternalState(this, {
                    type: URL_SEARCH_PARAMS_ITERATOR,
                    iterator: getIterator(
                      getInternalParamsState(params).entries
                    ),
                    kind: kind
                  })
                },
                'Iterator',
                function next() {
                  var state = getInternalIteratorState(this)
                  var kind = state.kind
                  var step = state.iterator.next()
                  var entry = step.value
                  if (!step.done) {
                    step.value =
                      kind === 'keys'
                        ? entry.key
                        : kind === 'values'
                        ? entry.value
                        : [entry.key, entry.value]
                  }
                  return step
                }
              )

              // `URLSearchParams` constructor
              // https://url.spec.whatwg.org/#interface-urlsearchparams
              var URLSearchParamsConstructor =
                function URLSearchParams(/* init */) {
                  anInstance(
                    this,
                    URLSearchParamsConstructor,
                    URL_SEARCH_PARAMS
                  )
                  var init = arguments.length > 0 ? arguments[0] : undefined
                  var that = this
                  var entries = []
                  var iteratorMethod,
                    iterator,
                    next,
                    step,
                    entryIterator,
                    entryNext,
                    first,
                    second,
                    key

                  setInternalState(that, {
                    type: URL_SEARCH_PARAMS,
                    entries: entries,
                    updateURL: function () {
                      /* empty */
                    },
                    updateSearchParams: updateSearchParams
                  })

                  if (init !== undefined) {
                    if (isObject(init)) {
                      iteratorMethod = getIteratorMethod(init)
                      if (typeof iteratorMethod === 'function') {
                        iterator = iteratorMethod.call(init)
                        next = iterator.next
                        while (!(step = next.call(iterator)).done) {
                          entryIterator = getIterator(anObject(step.value))
                          entryNext = entryIterator.next
                          if (
                            (first = entryNext.call(entryIterator)).done ||
                            (second = entryNext.call(entryIterator)).done ||
                            !entryNext.call(entryIterator).done
                          )
                            throw TypeError('Expected sequence with length 2')
                          entries.push({
                            key: first.value + '',
                            value: second.value + ''
                          })
                        }
                      } else
                        for (key in init)
                          if (hasOwn(init, key))
                            entries.push({ key: key, value: init[key] + '' })
                    } else {
                      parseSearchParams(
                        entries,
                        typeof init === 'string'
                          ? init.charAt(0) === '?'
                            ? init.slice(1)
                            : init
                          : init + ''
                      )
                    }
                  }
                }

              var URLSearchParamsPrototype =
                URLSearchParamsConstructor.prototype

              redefineAll(
                URLSearchParamsPrototype,
                {
                  // `URLSearchParams.prototype.append` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
                  append: function append(name, value) {
                    validateArgumentsLength(arguments.length, 2)
                    var state = getInternalParamsState(this)
                    state.entries.push({ key: name + '', value: value + '' })
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.delete` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
                  delete: function (name) {
                    validateArgumentsLength(arguments.length, 1)
                    var state = getInternalParamsState(this)
                    var entries = state.entries
                    var key = name + ''
                    var index = 0
                    while (index < entries.length) {
                      if (entries[index].key === key) entries.splice(index, 1)
                      else index++
                    }
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.get` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
                  get: function get(name) {
                    validateArgumentsLength(arguments.length, 1)
                    var entries = getInternalParamsState(this).entries
                    var key = name + ''
                    var index = 0
                    for (; index < entries.length; index++) {
                      if (entries[index].key === key)
                        return entries[index].value
                    }
                    return null
                  },
                  // `URLSearchParams.prototype.getAll` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
                  getAll: function getAll(name) {
                    validateArgumentsLength(arguments.length, 1)
                    var entries = getInternalParamsState(this).entries
                    var key = name + ''
                    var result = []
                    var index = 0
                    for (; index < entries.length; index++) {
                      if (entries[index].key === key)
                        result.push(entries[index].value)
                    }
                    return result
                  },
                  // `URLSearchParams.prototype.has` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
                  has: function has(name) {
                    validateArgumentsLength(arguments.length, 1)
                    var entries = getInternalParamsState(this).entries
                    var key = name + ''
                    var index = 0
                    while (index < entries.length) {
                      if (entries[index++].key === key) return true
                    }
                    return false
                  },
                  // `URLSearchParams.prototype.set` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
                  set: function set(name, value) {
                    validateArgumentsLength(arguments.length, 1)
                    var state = getInternalParamsState(this)
                    var entries = state.entries
                    var found = false
                    var key = name + ''
                    var val = value + ''
                    var index = 0
                    var entry
                    for (; index < entries.length; index++) {
                      entry = entries[index]
                      if (entry.key === key) {
                        if (found) entries.splice(index--, 1)
                        else {
                          found = true
                          entry.value = val
                        }
                      }
                    }
                    if (!found) entries.push({ key: key, value: val })
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.sort` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
                  sort: function sort() {
                    var state = getInternalParamsState(this)
                    var entries = state.entries
                    // Array#sort is not stable in some engines
                    var slice = entries.slice()
                    var entry, entriesIndex, sliceIndex
                    entries.length = 0
                    for (
                      sliceIndex = 0;
                      sliceIndex < slice.length;
                      sliceIndex++
                    ) {
                      entry = slice[sliceIndex]
                      for (
                        entriesIndex = 0;
                        entriesIndex < sliceIndex;
                        entriesIndex++
                      ) {
                        if (entries[entriesIndex].key > entry.key) {
                          entries.splice(entriesIndex, 0, entry)
                          break
                        }
                      }
                      if (entriesIndex === sliceIndex) entries.push(entry)
                    }
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.forEach` method
                  forEach: function forEach(callback /* , thisArg */) {
                    var entries = getInternalParamsState(this).entries
                    var boundFunction = bind(
                      callback,
                      arguments.length > 1 ? arguments[1] : undefined,
                      3
                    )
                    var index = 0
                    var entry
                    while (index < entries.length) {
                      entry = entries[index++]
                      boundFunction(entry.value, entry.key, this)
                    }
                  },
                  // `URLSearchParams.prototype.keys` method
                  keys: function keys() {
                    return new URLSearchParamsIterator(this, 'keys')
                  },
                  // `URLSearchParams.prototype.values` method
                  values: function values() {
                    return new URLSearchParamsIterator(this, 'values')
                  },
                  // `URLSearchParams.prototype.entries` method
                  entries: function entries() {
                    return new URLSearchParamsIterator(this, 'entries')
                  }
                },
                { enumerable: true }
              )

              // `URLSearchParams.prototype[@@iterator]` method
              redefine(
                URLSearchParamsPrototype,
                ITERATOR,
                URLSearchParamsPrototype.entries
              )

              // `URLSearchParams.prototype.toString` method
              // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
              redefine(
                URLSearchParamsPrototype,
                'toString',
                function toString() {
                  var entries = getInternalParamsState(this).entries
                  var result = []
                  var index = 0
                  var entry
                  while (index < entries.length) {
                    entry = entries[index++]
                    result.push(
                      serialize(entry.key) + '=' + serialize(entry.value)
                    )
                  }
                  return result.join('&')
                },
                { enumerable: true }
              )

              setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS)

              $(
                { global: true, forced: !USE_NATIVE_URL },
                {
                  URLSearchParams: URLSearchParamsConstructor
                }
              )

              // Wrap `fetch` for correct work with polyfilled `URLSearchParams`
              // https://github.com/zloirock/core-js/issues/674
              if (
                !USE_NATIVE_URL &&
                typeof $fetch == 'function' &&
                typeof Headers == 'function'
              ) {
                $(
                  { global: true, enumerable: true, forced: true },
                  {
                    fetch: function fetch(input /* , init */) {
                      var args = [input]
                      var init, body, headers
                      if (arguments.length > 1) {
                        init = arguments[1]
                        if (isObject(init)) {
                          body = init.body
                          if (classof(body) === URL_SEARCH_PARAMS) {
                            headers = init.headers
                              ? new Headers(init.headers)
                              : new Headers()
                            if (!headers.has('content-type')) {
                              headers.set(
                                'content-type',
                                'application/x-www-form-urlencoded;charset=UTF-8'
                              )
                            }
                            init = create(init, {
                              body: createPropertyDescriptor(0, String(body)),
                              headers: createPropertyDescriptor(0, headers)
                            })
                          }
                        }
                        args.push(init)
                      }
                      return $fetch.apply(this, args)
                    }
                  }
                )
              }

              module.exports = {
                URLSearchParams: URLSearchParamsConstructor,
                getState: getInternalParamsState
              }

              /***/
            },

            /***/ 285: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_177789__
            ) {
              'use strict'

              // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
              __nested_webpack_require_177789__(8783)
              var $ = __nested_webpack_require_177789__(2109)
              var DESCRIPTORS = __nested_webpack_require_177789__(9781)
              var USE_NATIVE_URL = __nested_webpack_require_177789__(590)
              var global = __nested_webpack_require_177789__(7854)
              var defineProperties = __nested_webpack_require_177789__(6048)
              var redefine = __nested_webpack_require_177789__(1320)
              var anInstance = __nested_webpack_require_177789__(5787)
              var has = __nested_webpack_require_177789__(6656)
              var assign = __nested_webpack_require_177789__(1574)
              var arrayFrom = __nested_webpack_require_177789__(8457)
              var codeAt = __nested_webpack_require_177789__(8710).codeAt
              var toASCII = __nested_webpack_require_177789__(3197)
              var setToStringTag = __nested_webpack_require_177789__(8003)
              var URLSearchParamsModule =
                __nested_webpack_require_177789__(1637)
              var InternalStateModule = __nested_webpack_require_177789__(9909)

              var NativeURL = global.URL
              var URLSearchParams = URLSearchParamsModule.URLSearchParams
              var getInternalSearchParamsState = URLSearchParamsModule.getState
              var setInternalState = InternalStateModule.set
              var getInternalURLState = InternalStateModule.getterFor('URL')
              var floor = Math.floor
              var pow = Math.pow

              var INVALID_AUTHORITY = 'Invalid authority'
              var INVALID_SCHEME = 'Invalid scheme'
              var INVALID_HOST = 'Invalid host'
              var INVALID_PORT = 'Invalid port'

              var ALPHA = /[A-Za-z]/
              var ALPHANUMERIC = /[\d+-.A-Za-z]/
              var DIGIT = /\d/
              var HEX_START = /^(0x|0X)/
              var OCT = /^[0-7]+$/
              var DEC = /^\d+$/
              var HEX = /^[\dA-Fa-f]+$/
              /* eslint-disable no-control-regex -- safe */
              var FORBIDDEN_HOST_CODE_POINT =
                /[\u0000\t\u000A\u000D #%/:?@[\\]]/
              var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT =
                /[\u0000\t\u000A\u000D #/:?@[\\]]/
              var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE =
                /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g
              var TAB_AND_NEW_LINE = /[\t\u000A\u000D]/g
              /* eslint-enable no-control-regex -- safe */
              var EOF

              var parseHost = function (url, input) {
                var result, codePoints, index
                if (input.charAt(0) == '[') {
                  if (input.charAt(input.length - 1) != ']') return INVALID_HOST
                  result = parseIPv6(input.slice(1, -1))
                  if (!result) return INVALID_HOST
                  url.host = result
                  // opaque host
                } else if (!isSpecial(url)) {
                  if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))
                    return INVALID_HOST
                  result = ''
                  codePoints = arrayFrom(input)
                  for (index = 0; index < codePoints.length; index++) {
                    result += percentEncode(
                      codePoints[index],
                      C0ControlPercentEncodeSet
                    )
                  }
                  url.host = result
                } else {
                  input = toASCII(input)
                  if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST
                  result = parseIPv4(input)
                  if (result === null) return INVALID_HOST
                  url.host = result
                }
              }

              var parseIPv4 = function (input) {
                var parts = input.split('.')
                var partsLength, numbers, index, part, radix, number, ipv4
                if (parts.length && parts[parts.length - 1] == '') {
                  parts.pop()
                }
                partsLength = parts.length
                if (partsLength > 4) return input
                numbers = []
                for (index = 0; index < partsLength; index++) {
                  part = parts[index]
                  if (part == '') return input
                  radix = 10
                  if (part.length > 1 && part.charAt(0) == '0') {
                    radix = HEX_START.test(part) ? 16 : 8
                    part = part.slice(radix == 8 ? 1 : 2)
                  }
                  if (part === '') {
                    number = 0
                  } else {
                    if (
                      !(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)
                    )
                      return input
                    number = parseInt(part, radix)
                  }
                  numbers.push(number)
                }
                for (index = 0; index < partsLength; index++) {
                  number = numbers[index]
                  if (index == partsLength - 1) {
                    if (number >= pow(256, 5 - partsLength)) return null
                  } else if (number > 255) return null
                }
                ipv4 = numbers.pop()
                for (index = 0; index < numbers.length; index++) {
                  ipv4 += numbers[index] * pow(256, 3 - index)
                }
                return ipv4
              }

              // eslint-disable-next-line max-statements -- TODO
              var parseIPv6 = function (input) {
                var address = [0, 0, 0, 0, 0, 0, 0, 0]
                var pieceIndex = 0
                var compress = null
                var pointer = 0
                var value, length, numbersSeen, ipv4Piece, number, swaps, swap

                var char = function () {
                  return input.charAt(pointer)
                }

                if (char() == ':') {
                  if (input.charAt(1) != ':') return
                  pointer += 2
                  pieceIndex++
                  compress = pieceIndex
                }
                while (char()) {
                  if (pieceIndex == 8) return
                  if (char() == ':') {
                    if (compress !== null) return
                    pointer++
                    pieceIndex++
                    compress = pieceIndex
                    continue
                  }
                  value = length = 0
                  while (length < 4 && HEX.test(char())) {
                    value = value * 16 + parseInt(char(), 16)
                    pointer++
                    length++
                  }
                  if (char() == '.') {
                    if (length == 0) return
                    pointer -= length
                    if (pieceIndex > 6) return
                    numbersSeen = 0
                    while (char()) {
                      ipv4Piece = null
                      if (numbersSeen > 0) {
                        if (char() == '.' && numbersSeen < 4) pointer++
                        else return
                      }
                      if (!DIGIT.test(char())) return
                      while (DIGIT.test(char())) {
                        number = parseInt(char(), 10)
                        if (ipv4Piece === null) ipv4Piece = number
                        else if (ipv4Piece == 0) return
                        else ipv4Piece = ipv4Piece * 10 + number
                        if (ipv4Piece > 255) return
                        pointer++
                      }
                      address[pieceIndex] =
                        address[pieceIndex] * 256 + ipv4Piece
                      numbersSeen++
                      if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++
                    }
                    if (numbersSeen != 4) return
                    break
                  } else if (char() == ':') {
                    pointer++
                    if (!char()) return
                  } else if (char()) return
                  address[pieceIndex++] = value
                }
                if (compress !== null) {
                  swaps = pieceIndex - compress
                  pieceIndex = 7
                  while (pieceIndex != 0 && swaps > 0) {
                    swap = address[pieceIndex]
                    address[pieceIndex--] = address[compress + swaps - 1]
                    address[compress + --swaps] = swap
                  }
                } else if (pieceIndex != 8) return
                return address
              }

              var findLongestZeroSequence = function (ipv6) {
                var maxIndex = null
                var maxLength = 1
                var currStart = null
                var currLength = 0
                var index = 0
                for (; index < 8; index++) {
                  if (ipv6[index] !== 0) {
                    if (currLength > maxLength) {
                      maxIndex = currStart
                      maxLength = currLength
                    }
                    currStart = null
                    currLength = 0
                  } else {
                    if (currStart === null) currStart = index
                    ++currLength
                  }
                }
                if (currLength > maxLength) {
                  maxIndex = currStart
                  maxLength = currLength
                }
                return maxIndex
              }

              var serializeHost = function (host) {
                var result, index, compress, ignore0
                // ipv4
                if (typeof host == 'number') {
                  result = []
                  for (index = 0; index < 4; index++) {
                    result.unshift(host % 256)
                    host = floor(host / 256)
                  }
                  return result.join('.')
                  // ipv6
                } else if (typeof host == 'object') {
                  result = ''
                  compress = findLongestZeroSequence(host)
                  for (index = 0; index < 8; index++) {
                    if (ignore0 && host[index] === 0) continue
                    if (ignore0) ignore0 = false
                    if (compress === index) {
                      result += index ? ':' : '::'
                      ignore0 = true
                    } else {
                      result += host[index].toString(16)
                      if (index < 7) result += ':'
                    }
                  }
                  return '[' + result + ']'
                }
                return host
              }

              var C0ControlPercentEncodeSet = {}
              var fragmentPercentEncodeSet = assign(
                {},
                C0ControlPercentEncodeSet,
                {
                  ' ': 1,
                  '"': 1,
                  '<': 1,
                  '>': 1,
                  '`': 1
                }
              )
              var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
                '#': 1,
                '?': 1,
                '{': 1,
                '}': 1
              })
              var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
                '/': 1,
                ':': 1,
                ';': 1,
                '=': 1,
                '@': 1,
                '[': 1,
                '\\': 1,
                ']': 1,
                '^': 1,
                '|': 1
              })

              var percentEncode = function (char, set) {
                var code = codeAt(char, 0)
                return code > 0x20 && code < 0x7f && !has(set, char)
                  ? char
                  : encodeURIComponent(char)
              }

              var specialSchemes = {
                ftp: 21,
                file: null,
                http: 80,
                https: 443,
                ws: 80,
                wss: 443
              }

              var isSpecial = function (url) {
                return has(specialSchemes, url.scheme)
              }

              var includesCredentials = function (url) {
                return url.username != '' || url.password != ''
              }

              var cannotHaveUsernamePasswordPort = function (url) {
                return !url.host || url.cannotBeABaseURL || url.scheme == 'file'
              }

              var isWindowsDriveLetter = function (string, normalized) {
                var second
                return (
                  string.length == 2 &&
                  ALPHA.test(string.charAt(0)) &&
                  ((second = string.charAt(1)) == ':' ||
                    (!normalized && second == '|'))
                )
              }

              var startsWithWindowsDriveLetter = function (string) {
                var third
                return (
                  string.length > 1 &&
                  isWindowsDriveLetter(string.slice(0, 2)) &&
                  (string.length == 2 ||
                    (third = string.charAt(2)) === '/' ||
                    third === '\\' ||
                    third === '?' ||
                    third === '#')
                )
              }

              var shortenURLsPath = function (url) {
                var path = url.path
                var pathSize = path.length
                if (
                  pathSize &&
                  (url.scheme != 'file' ||
                    pathSize != 1 ||
                    !isWindowsDriveLetter(path[0], true))
                ) {
                  path.pop()
                }
              }

              var isSingleDot = function (segment) {
                return segment === '.' || segment.toLowerCase() === '%2e'
              }

              var isDoubleDot = function (segment) {
                segment = segment.toLowerCase()
                return (
                  segment === '..' ||
                  segment === '%2e.' ||
                  segment === '.%2e' ||
                  segment === '%2e%2e'
                )
              }

              // States:
              var SCHEME_START = {}
              var SCHEME = {}
              var NO_SCHEME = {}
              var SPECIAL_RELATIVE_OR_AUTHORITY = {}
              var PATH_OR_AUTHORITY = {}
              var RELATIVE = {}
              var RELATIVE_SLASH = {}
              var SPECIAL_AUTHORITY_SLASHES = {}
              var SPECIAL_AUTHORITY_IGNORE_SLASHES = {}
              var AUTHORITY = {}
              var HOST = {}
              var HOSTNAME = {}
              var PORT = {}
              var FILE = {}
              var FILE_SLASH = {}
              var FILE_HOST = {}
              var PATH_START = {}
              var PATH = {}
              var CANNOT_BE_A_BASE_URL_PATH = {}
              var QUERY = {}
              var FRAGMENT = {}

              // eslint-disable-next-line max-statements -- TODO
              var parseURL = function (url, input, stateOverride, base) {
                var state = stateOverride || SCHEME_START
                var pointer = 0
                var buffer = ''
                var seenAt = false
                var seenBracket = false
                var seenPasswordToken = false
                var codePoints, char, bufferCodePoints, failure

                if (!stateOverride) {
                  url.scheme = ''
                  url.username = ''
                  url.password = ''
                  url.host = null
                  url.port = null
                  url.path = []
                  url.query = null
                  url.fragment = null
                  url.cannotBeABaseURL = false
                  input = input.replace(
                    LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE,
                    ''
                  )
                }

                input = input.replace(TAB_AND_NEW_LINE, '')

                codePoints = arrayFrom(input)

                while (pointer <= codePoints.length) {
                  char = codePoints[pointer]
                  switch (state) {
                    case SCHEME_START:
                      if (char && ALPHA.test(char)) {
                        buffer += char.toLowerCase()
                        state = SCHEME
                      } else if (!stateOverride) {
                        state = NO_SCHEME
                        continue
                      } else return INVALID_SCHEME
                      break

                    case SCHEME:
                      if (
                        char &&
                        (ALPHANUMERIC.test(char) ||
                          char == '+' ||
                          char == '-' ||
                          char == '.')
                      ) {
                        buffer += char.toLowerCase()
                      } else if (char == ':') {
                        if (
                          stateOverride &&
                          (isSpecial(url) != has(specialSchemes, buffer) ||
                            (buffer == 'file' &&
                              (includesCredentials(url) ||
                                url.port !== null)) ||
                            (url.scheme == 'file' && !url.host))
                        )
                          return
                        url.scheme = buffer
                        if (stateOverride) {
                          if (
                            isSpecial(url) &&
                            specialSchemes[url.scheme] == url.port
                          )
                            url.port = null
                          return
                        }
                        buffer = ''
                        if (url.scheme == 'file') {
                          state = FILE
                        } else if (
                          isSpecial(url) &&
                          base &&
                          base.scheme == url.scheme
                        ) {
                          state = SPECIAL_RELATIVE_OR_AUTHORITY
                        } else if (isSpecial(url)) {
                          state = SPECIAL_AUTHORITY_SLASHES
                        } else if (codePoints[pointer + 1] == '/') {
                          state = PATH_OR_AUTHORITY
                          pointer++
                        } else {
                          url.cannotBeABaseURL = true
                          url.path.push('')
                          state = CANNOT_BE_A_BASE_URL_PATH
                        }
                      } else if (!stateOverride) {
                        buffer = ''
                        state = NO_SCHEME
                        pointer = 0
                        continue
                      } else return INVALID_SCHEME
                      break

                    case NO_SCHEME:
                      if (!base || (base.cannotBeABaseURL && char != '#'))
                        return INVALID_SCHEME
                      if (base.cannotBeABaseURL && char == '#') {
                        url.scheme = base.scheme
                        url.path = base.path.slice()
                        url.query = base.query
                        url.fragment = ''
                        url.cannotBeABaseURL = true
                        state = FRAGMENT
                        break
                      }
                      state = base.scheme == 'file' ? FILE : RELATIVE
                      continue

                    case SPECIAL_RELATIVE_OR_AUTHORITY:
                      if (char == '/' && codePoints[pointer + 1] == '/') {
                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES
                        pointer++
                      } else {
                        state = RELATIVE
                        continue
                      }
                      break

                    case PATH_OR_AUTHORITY:
                      if (char == '/') {
                        state = AUTHORITY
                        break
                      } else {
                        state = PATH
                        continue
                      }

                    case RELATIVE:
                      url.scheme = base.scheme
                      if (char == EOF) {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.query = base.query
                      } else if (
                        char == '/' ||
                        (char == '\\' && isSpecial(url))
                      ) {
                        state = RELATIVE_SLASH
                      } else if (char == '?') {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.query = ''
                        state = QUERY
                      } else if (char == '#') {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.query = base.query
                        url.fragment = ''
                        state = FRAGMENT
                      } else {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.path.pop()
                        state = PATH
                        continue
                      }
                      break

                    case RELATIVE_SLASH:
                      if (isSpecial(url) && (char == '/' || char == '\\')) {
                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES
                      } else if (char == '/') {
                        state = AUTHORITY
                      } else {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        state = PATH
                        continue
                      }
                      break

                    case SPECIAL_AUTHORITY_SLASHES:
                      state = SPECIAL_AUTHORITY_IGNORE_SLASHES
                      if (char != '/' || buffer.charAt(pointer + 1) != '/')
                        continue
                      pointer++
                      break

                    case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                      if (char != '/' && char != '\\') {
                        state = AUTHORITY
                        continue
                      }
                      break

                    case AUTHORITY:
                      if (char == '@') {
                        if (seenAt) buffer = '%40' + buffer
                        seenAt = true
                        bufferCodePoints = arrayFrom(buffer)
                        for (var i = 0; i < bufferCodePoints.length; i++) {
                          var codePoint = bufferCodePoints[i]
                          if (codePoint == ':' && !seenPasswordToken) {
                            seenPasswordToken = true
                            continue
                          }
                          var encodedCodePoints = percentEncode(
                            codePoint,
                            userinfoPercentEncodeSet
                          )
                          if (seenPasswordToken)
                            url.password += encodedCodePoints
                          else url.username += encodedCodePoints
                        }
                        buffer = ''
                      } else if (
                        char == EOF ||
                        char == '/' ||
                        char == '?' ||
                        char == '#' ||
                        (char == '\\' && isSpecial(url))
                      ) {
                        if (seenAt && buffer == '') return INVALID_AUTHORITY
                        pointer -= arrayFrom(buffer).length + 1
                        buffer = ''
                        state = HOST
                      } else buffer += char
                      break

                    case HOST:
                    case HOSTNAME:
                      if (stateOverride && url.scheme == 'file') {
                        state = FILE_HOST
                        continue
                      } else if (char == ':' && !seenBracket) {
                        if (buffer == '') return INVALID_HOST
                        failure = parseHost(url, buffer)
                        if (failure) return failure
                        buffer = ''
                        state = PORT
                        if (stateOverride == HOSTNAME) return
                      } else if (
                        char == EOF ||
                        char == '/' ||
                        char == '?' ||
                        char == '#' ||
                        (char == '\\' && isSpecial(url))
                      ) {
                        if (isSpecial(url) && buffer == '') return INVALID_HOST
                        if (
                          stateOverride &&
                          buffer == '' &&
                          (includesCredentials(url) || url.port !== null)
                        )
                          return
                        failure = parseHost(url, buffer)
                        if (failure) return failure
                        buffer = ''
                        state = PATH_START
                        if (stateOverride) return
                        continue
                      } else {
                        if (char == '[') seenBracket = true
                        else if (char == ']') seenBracket = false
                        buffer += char
                      }
                      break

                    case PORT:
                      if (DIGIT.test(char)) {
                        buffer += char
                      } else if (
                        char == EOF ||
                        char == '/' ||
                        char == '?' ||
                        char == '#' ||
                        (char == '\\' && isSpecial(url)) ||
                        stateOverride
                      ) {
                        if (buffer != '') {
                          var port = parseInt(buffer, 10)
                          if (port > 0xffff) return INVALID_PORT
                          url.port =
                            isSpecial(url) &&
                            port === specialSchemes[url.scheme]
                              ? null
                              : port
                          buffer = ''
                        }
                        if (stateOverride) return
                        state = PATH_START
                        continue
                      } else return INVALID_PORT
                      break

                    case FILE:
                      url.scheme = 'file'
                      if (char == '/' || char == '\\') state = FILE_SLASH
                      else if (base && base.scheme == 'file') {
                        if (char == EOF) {
                          url.host = base.host
                          url.path = base.path.slice()
                          url.query = base.query
                        } else if (char == '?') {
                          url.host = base.host
                          url.path = base.path.slice()
                          url.query = ''
                          state = QUERY
                        } else if (char == '#') {
                          url.host = base.host
                          url.path = base.path.slice()
                          url.query = base.query
                          url.fragment = ''
                          state = FRAGMENT
                        } else {
                          if (
                            !startsWithWindowsDriveLetter(
                              codePoints.slice(pointer).join('')
                            )
                          ) {
                            url.host = base.host
                            url.path = base.path.slice()
                            shortenURLsPath(url)
                          }
                          state = PATH
                          continue
                        }
                      } else {
                        state = PATH
                        continue
                      }
                      break

                    case FILE_SLASH:
                      if (char == '/' || char == '\\') {
                        state = FILE_HOST
                        break
                      }
                      if (
                        base &&
                        base.scheme == 'file' &&
                        !startsWithWindowsDriveLetter(
                          codePoints.slice(pointer).join('')
                        )
                      ) {
                        if (isWindowsDriveLetter(base.path[0], true))
                          url.path.push(base.path[0])
                        else url.host = base.host
                      }
                      state = PATH
                      continue

                    case FILE_HOST:
                      if (
                        char == EOF ||
                        char == '/' ||
                        char == '\\' ||
                        char == '?' ||
                        char == '#'
                      ) {
                        if (!stateOverride && isWindowsDriveLetter(buffer)) {
                          state = PATH
                        } else if (buffer == '') {
                          url.host = ''
                          if (stateOverride) return
                          state = PATH_START
                        } else {
                          failure = parseHost(url, buffer)
                          if (failure) return failure
                          if (url.host == 'localhost') url.host = ''
                          if (stateOverride) return
                          buffer = ''
                          state = PATH_START
                        }
                        continue
                      } else buffer += char
                      break

                    case PATH_START:
                      if (isSpecial(url)) {
                        state = PATH
                        if (char != '/' && char != '\\') continue
                      } else if (!stateOverride && char == '?') {
                        url.query = ''
                        state = QUERY
                      } else if (!stateOverride && char == '#') {
                        url.fragment = ''
                        state = FRAGMENT
                      } else if (char != EOF) {
                        state = PATH
                        if (char != '/') continue
                      }
                      break

                    case PATH:
                      if (
                        char == EOF ||
                        char == '/' ||
                        (char == '\\' && isSpecial(url)) ||
                        (!stateOverride && (char == '?' || char == '#'))
                      ) {
                        if (isDoubleDot(buffer)) {
                          shortenURLsPath(url)
                          if (
                            char != '/' &&
                            !(char == '\\' && isSpecial(url))
                          ) {
                            url.path.push('')
                          }
                        } else if (isSingleDot(buffer)) {
                          if (
                            char != '/' &&
                            !(char == '\\' && isSpecial(url))
                          ) {
                            url.path.push('')
                          }
                        } else {
                          if (
                            url.scheme == 'file' &&
                            !url.path.length &&
                            isWindowsDriveLetter(buffer)
                          ) {
                            if (url.host) url.host = ''
                            buffer = buffer.charAt(0) + ':' // normalize windows drive letter
                          }
                          url.path.push(buffer)
                        }
                        buffer = ''
                        if (
                          url.scheme == 'file' &&
                          (char == EOF || char == '?' || char == '#')
                        ) {
                          while (url.path.length > 1 && url.path[0] === '') {
                            url.path.shift()
                          }
                        }
                        if (char == '?') {
                          url.query = ''
                          state = QUERY
                        } else if (char == '#') {
                          url.fragment = ''
                          state = FRAGMENT
                        }
                      } else {
                        buffer += percentEncode(char, pathPercentEncodeSet)
                      }
                      break

                    case CANNOT_BE_A_BASE_URL_PATH:
                      if (char == '?') {
                        url.query = ''
                        state = QUERY
                      } else if (char == '#') {
                        url.fragment = ''
                        state = FRAGMENT
                      } else if (char != EOF) {
                        url.path[0] += percentEncode(
                          char,
                          C0ControlPercentEncodeSet
                        )
                      }
                      break

                    case QUERY:
                      if (!stateOverride && char == '#') {
                        url.fragment = ''
                        state = FRAGMENT
                      } else if (char != EOF) {
                        if (char == "'" && isSpecial(url)) url.query += '%27'
                        else if (char == '#') url.query += '%23'
                        else
                          url.query += percentEncode(
                            char,
                            C0ControlPercentEncodeSet
                          )
                      }
                      break

                    case FRAGMENT:
                      if (char != EOF)
                        url.fragment += percentEncode(
                          char,
                          fragmentPercentEncodeSet
                        )
                      break
                  }

                  pointer++
                }
              }

              // `URL` constructor
              // https://url.spec.whatwg.org/#url-class
              var URLConstructor = function URL(url /* , base */) {
                var that = anInstance(this, URLConstructor, 'URL')
                var base = arguments.length > 1 ? arguments[1] : undefined
                var urlString = String(url)
                var state = setInternalState(that, { type: 'URL' })
                var baseState, failure
                if (base !== undefined) {
                  if (base instanceof URLConstructor)
                    baseState = getInternalURLState(base)
                  else {
                    failure = parseURL((baseState = {}), String(base))
                    if (failure) throw TypeError(failure)
                  }
                }
                failure = parseURL(state, urlString, null, baseState)
                if (failure) throw TypeError(failure)
                var searchParams = (state.searchParams = new URLSearchParams())
                var searchParamsState =
                  getInternalSearchParamsState(searchParams)
                searchParamsState.updateSearchParams(state.query)
                searchParamsState.updateURL = function () {
                  state.query = String(searchParams) || null
                }
                if (!DESCRIPTORS) {
                  that.href = serializeURL.call(that)
                  that.origin = getOrigin.call(that)
                  that.protocol = getProtocol.call(that)
                  that.username = getUsername.call(that)
                  that.password = getPassword.call(that)
                  that.host = getHost.call(that)
                  that.hostname = getHostname.call(that)
                  that.port = getPort.call(that)
                  that.pathname = getPathname.call(that)
                  that.search = getSearch.call(that)
                  that.searchParams = getSearchParams.call(that)
                  that.hash = getHash.call(that)
                }
              }

              var URLPrototype = URLConstructor.prototype

              var serializeURL = function () {
                var url = getInternalURLState(this)
                var scheme = url.scheme
                var username = url.username
                var password = url.password
                var host = url.host
                var port = url.port
                var path = url.path
                var query = url.query
                var fragment = url.fragment
                var output = scheme + ':'
                if (host !== null) {
                  output += '//'
                  if (includesCredentials(url)) {
                    output += username + (password ? ':' + password : '') + '@'
                  }
                  output += serializeHost(host)
                  if (port !== null) output += ':' + port
                } else if (scheme == 'file') output += '//'
                output += url.cannotBeABaseURL
                  ? path[0]
                  : path.length
                  ? '/' + path.join('/')
                  : ''
                if (query !== null) output += '?' + query
                if (fragment !== null) output += '#' + fragment
                return output
              }

              var getOrigin = function () {
                var url = getInternalURLState(this)
                var scheme = url.scheme
                var port = url.port
                if (scheme == 'blob')
                  try {
                    return new URL(scheme.path[0]).origin
                  } catch (error) {
                    return 'null'
                  }
                if (scheme == 'file' || !isSpecial(url)) return 'null'
                return (
                  scheme +
                  '://' +
                  serializeHost(url.host) +
                  (port !== null ? ':' + port : '')
                )
              }

              var getProtocol = function () {
                return getInternalURLState(this).scheme + ':'
              }

              var getUsername = function () {
                return getInternalURLState(this).username
              }

              var getPassword = function () {
                return getInternalURLState(this).password
              }

              var getHost = function () {
                var url = getInternalURLState(this)
                var host = url.host
                var port = url.port
                return host === null
                  ? ''
                  : port === null
                  ? serializeHost(host)
                  : serializeHost(host) + ':' + port
              }

              var getHostname = function () {
                var host = getInternalURLState(this).host
                return host === null ? '' : serializeHost(host)
              }

              var getPort = function () {
                var port = getInternalURLState(this).port
                return port === null ? '' : String(port)
              }

              var getPathname = function () {
                var url = getInternalURLState(this)
                var path = url.path
                return url.cannotBeABaseURL
                  ? path[0]
                  : path.length
                  ? '/' + path.join('/')
                  : ''
              }

              var getSearch = function () {
                var query = getInternalURLState(this).query
                return query ? '?' + query : ''
              }

              var getSearchParams = function () {
                return getInternalURLState(this).searchParams
              }

              var getHash = function () {
                var fragment = getInternalURLState(this).fragment
                return fragment ? '#' + fragment : ''
              }

              var accessorDescriptor = function (getter, setter) {
                return {
                  get: getter,
                  set: setter,
                  configurable: true,
                  enumerable: true
                }
              }

              if (DESCRIPTORS) {
                defineProperties(URLPrototype, {
                  // `URL.prototype.href` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-href
                  href: accessorDescriptor(serializeURL, function (href) {
                    var url = getInternalURLState(this)
                    var urlString = String(href)
                    var failure = parseURL(url, urlString)
                    if (failure) throw TypeError(failure)
                    getInternalSearchParamsState(
                      url.searchParams
                    ).updateSearchParams(url.query)
                  }),
                  // `URL.prototype.origin` getter
                  // https://url.spec.whatwg.org/#dom-url-origin
                  origin: accessorDescriptor(getOrigin),
                  // `URL.prototype.protocol` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-protocol
                  protocol: accessorDescriptor(
                    getProtocol,
                    function (protocol) {
                      var url = getInternalURLState(this)
                      parseURL(url, String(protocol) + ':', SCHEME_START)
                    }
                  ),
                  // `URL.prototype.username` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-username
                  username: accessorDescriptor(
                    getUsername,
                    function (username) {
                      var url = getInternalURLState(this)
                      var codePoints = arrayFrom(String(username))
                      if (cannotHaveUsernamePasswordPort(url)) return
                      url.username = ''
                      for (var i = 0; i < codePoints.length; i++) {
                        url.username += percentEncode(
                          codePoints[i],
                          userinfoPercentEncodeSet
                        )
                      }
                    }
                  ),
                  // `URL.prototype.password` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-password
                  password: accessorDescriptor(
                    getPassword,
                    function (password) {
                      var url = getInternalURLState(this)
                      var codePoints = arrayFrom(String(password))
                      if (cannotHaveUsernamePasswordPort(url)) return
                      url.password = ''
                      for (var i = 0; i < codePoints.length; i++) {
                        url.password += percentEncode(
                          codePoints[i],
                          userinfoPercentEncodeSet
                        )
                      }
                    }
                  ),
                  // `URL.prototype.host` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-host
                  host: accessorDescriptor(getHost, function (host) {
                    var url = getInternalURLState(this)
                    if (url.cannotBeABaseURL) return
                    parseURL(url, String(host), HOST)
                  }),
                  // `URL.prototype.hostname` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-hostname
                  hostname: accessorDescriptor(
                    getHostname,
                    function (hostname) {
                      var url = getInternalURLState(this)
                      if (url.cannotBeABaseURL) return
                      parseURL(url, String(hostname), HOSTNAME)
                    }
                  ),
                  // `URL.prototype.port` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-port
                  port: accessorDescriptor(getPort, function (port) {
                    var url = getInternalURLState(this)
                    if (cannotHaveUsernamePasswordPort(url)) return
                    port = String(port)
                    if (port == '') url.port = null
                    else parseURL(url, port, PORT)
                  }),
                  // `URL.prototype.pathname` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-pathname
                  pathname: accessorDescriptor(
                    getPathname,
                    function (pathname) {
                      var url = getInternalURLState(this)
                      if (url.cannotBeABaseURL) return
                      url.path = []
                      parseURL(url, pathname + '', PATH_START)
                    }
                  ),
                  // `URL.prototype.search` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-search
                  search: accessorDescriptor(getSearch, function (search) {
                    var url = getInternalURLState(this)
                    search = String(search)
                    if (search == '') {
                      url.query = null
                    } else {
                      if ('?' == search.charAt(0)) search = search.slice(1)
                      url.query = ''
                      parseURL(url, search, QUERY)
                    }
                    getInternalSearchParamsState(
                      url.searchParams
                    ).updateSearchParams(url.query)
                  }),
                  // `URL.prototype.searchParams` getter
                  // https://url.spec.whatwg.org/#dom-url-searchparams
                  searchParams: accessorDescriptor(getSearchParams),
                  // `URL.prototype.hash` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-hash
                  hash: accessorDescriptor(getHash, function (hash) {
                    var url = getInternalURLState(this)
                    hash = String(hash)
                    if (hash == '') {
                      url.fragment = null
                      return
                    }
                    if ('#' == hash.charAt(0)) hash = hash.slice(1)
                    url.fragment = ''
                    parseURL(url, hash, FRAGMENT)
                  })
                })
              }

              // `URL.prototype.toJSON` method
              // https://url.spec.whatwg.org/#dom-url-tojson
              redefine(
                URLPrototype,
                'toJSON',
                function toJSON() {
                  return serializeURL.call(this)
                },
                { enumerable: true }
              )

              // `URL.prototype.toString` method
              // https://url.spec.whatwg.org/#URL-stringification-behavior
              redefine(
                URLPrototype,
                'toString',
                function toString() {
                  return serializeURL.call(this)
                },
                { enumerable: true }
              )

              if (NativeURL) {
                var nativeCreateObjectURL = NativeURL.createObjectURL
                var nativeRevokeObjectURL = NativeURL.revokeObjectURL
                // `URL.createObjectURL` method
                // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
                // eslint-disable-next-line no-unused-vars -- required for `.length`
                if (nativeCreateObjectURL)
                  redefine(
                    URLConstructor,
                    'createObjectURL',
                    function createObjectURL(blob) {
                      return nativeCreateObjectURL.apply(NativeURL, arguments)
                    }
                  )
                // `URL.revokeObjectURL` method
                // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
                // eslint-disable-next-line no-unused-vars -- required for `.length`
                if (nativeRevokeObjectURL)
                  redefine(
                    URLConstructor,
                    'revokeObjectURL',
                    function revokeObjectURL(url) {
                      return nativeRevokeObjectURL.apply(NativeURL, arguments)
                    }
                  )
              }

              setToStringTag(URLConstructor, 'URL')

              $(
                { global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS },
                {
                  URL: URLConstructor
                }
              )

              /***/
            }

            /******/
          }
          /************************************************************************/
          /******/ // The module cache
          /******/ var __webpack_module_cache__ = {}
          /******/
          /******/ // The require function
          /******/ function __nested_webpack_require_210484__(moduleId) {
            /******/ // Check if module is in cache
            /******/ if (__webpack_module_cache__[moduleId]) {
              /******/ return __webpack_module_cache__[moduleId].exports
              /******/
            }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module = (__webpack_module_cache__[moduleId] = {
              /******/ // no module.id needed
              /******/ // no module.loaded needed
              /******/ exports: {}
              /******/
            })
            /******/
            /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](
              module,
              module.exports,
              __nested_webpack_require_210484__
            )
            /******/
            /******/ // Return the exports of the module
            /******/ return module.exports
            /******/
          }
          /******/
          /************************************************************************/
          /******/ /* webpack/runtime/define property getters */ /******/ !(function () {
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_210484__.d = function (
              exports,
              definition
            ) {
              /******/ for (var key in definition) {
                /******/ if (
                  __nested_webpack_require_210484__.o(definition, key) &&
                  !__nested_webpack_require_210484__.o(exports, key)
                ) {
                  /******/ Object.defineProperty(exports, key, {
                    enumerable: true,
                    get: definition[key]
                  })
                  /******/
                }
                /******/
              }
              /******/
            }
            /******/
          })()
          /******/
          /******/ /* webpack/runtime/global */ /******/ !(function () {
            /******/ __nested_webpack_require_210484__.g = (function () {
              /******/ if (typeof globalThis === 'object') return globalThis
              /******/ try {
                /******/ return this || new Function('return this')()
                /******/
              } catch (e) {
                /******/ if (typeof window === 'object') return window
                /******/
              }
              /******/
            })()
            /******/
          })()
          /******/
          /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !(function () {
            /******/ __nested_webpack_require_210484__.o = function (
              obj,
              prop
            ) {
              return Object.prototype.hasOwnProperty.call(obj, prop)
            }
            /******/
          })()
          /******/
          /******/ /* webpack/runtime/make namespace object */ /******/ !(function () {
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_210484__.r = function (exports) {
              /******/ if (
                typeof Symbol !== 'undefined' &&
                Symbol.toStringTag
              ) {
                /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                  value: 'Module'
                })
                /******/
              }
              /******/ Object.defineProperty(exports, '__esModule', {
                value: true
              })
              /******/
            }
            /******/
          })()
          /******/
          /************************************************************************/
          var __webpack_exports__ = {}
          // This entry need to be wrapped in an IIFE because it need to be in strict mode.
          !(function () {
            'use strict'
            // ESM COMPAT FLAG
            __nested_webpack_require_210484__.r(__webpack_exports__)

            // EXPORTS
            __nested_webpack_require_210484__.d(__webpack_exports__, {
              Dropzone: function () {
                return /* reexport */ Dropzone
              },
              default: function () {
                return /* binding */ dropzone_dist
              }
            })

            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
            var es_array_concat = __nested_webpack_require_210484__(2222)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
            var es_array_filter = __nested_webpack_require_210484__(7327)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
            var es_array_index_of = __nested_webpack_require_210484__(2772)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
            var es_array_iterator = __nested_webpack_require_210484__(6992)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
            var es_array_map = __nested_webpack_require_210484__(1249)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
            var es_array_slice = __nested_webpack_require_210484__(7042)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
            var es_array_splice = __nested_webpack_require_210484__(561)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.constructor.js
            var es_array_buffer_constructor =
              __nested_webpack_require_210484__(8264)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
            var es_function_name = __nested_webpack_require_210484__(8309)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
            var es_object_get_prototype_of =
              __nested_webpack_require_210484__(489)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
            var es_object_to_string = __nested_webpack_require_210484__(1539)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
            var es_regexp_exec = __nested_webpack_require_210484__(4916)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
            var es_regexp_to_string = __nested_webpack_require_210484__(9714)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
            var es_string_iterator = __nested_webpack_require_210484__(8783)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
            var es_string_match = __nested_webpack_require_210484__(4723)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
            var es_string_replace = __nested_webpack_require_210484__(5306)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
            var es_string_split = __nested_webpack_require_210484__(3123)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
            var es_string_trim = __nested_webpack_require_210484__(3210)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.uint8-array.js
            var es_typed_array_uint8_array =
              __nested_webpack_require_210484__(2472)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.copy-within.js
            var es_typed_array_copy_within =
              __nested_webpack_require_210484__(2990)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.every.js
            var es_typed_array_every = __nested_webpack_require_210484__(8927)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.fill.js
            var es_typed_array_fill = __nested_webpack_require_210484__(3105)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.filter.js
            var es_typed_array_filter = __nested_webpack_require_210484__(5035)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find.js
            var es_typed_array_find = __nested_webpack_require_210484__(4345)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find-index.js
            var es_typed_array_find_index =
              __nested_webpack_require_210484__(7174)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.for-each.js
            var es_typed_array_for_each =
              __nested_webpack_require_210484__(2846)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.includes.js
            var es_typed_array_includes =
              __nested_webpack_require_210484__(4731)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.index-of.js
            var es_typed_array_index_of =
              __nested_webpack_require_210484__(7209)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.iterator.js
            var es_typed_array_iterator =
              __nested_webpack_require_210484__(6319)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.join.js
            var es_typed_array_join = __nested_webpack_require_210484__(8867)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.last-index-of.js
            var es_typed_array_last_index_of =
              __nested_webpack_require_210484__(7789)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.map.js
            var es_typed_array_map = __nested_webpack_require_210484__(3739)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce.js
            var es_typed_array_reduce = __nested_webpack_require_210484__(9368)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce-right.js
            var es_typed_array_reduce_right =
              __nested_webpack_require_210484__(4483)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reverse.js
            var es_typed_array_reverse = __nested_webpack_require_210484__(2056)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
            var es_typed_array_set = __nested_webpack_require_210484__(3462)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.slice.js
            var es_typed_array_slice = __nested_webpack_require_210484__(678)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.some.js
            var es_typed_array_some = __nested_webpack_require_210484__(7462)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js
            var es_typed_array_sort = __nested_webpack_require_210484__(3824)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.subarray.js
            var es_typed_array_subarray =
              __nested_webpack_require_210484__(5021)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-locale-string.js
            var es_typed_array_to_locale_string =
              __nested_webpack_require_210484__(2974)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-string.js
            var es_typed_array_to_string =
              __nested_webpack_require_210484__(5016)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
            var web_dom_collections_for_each =
              __nested_webpack_require_210484__(4747)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
            var web_dom_collections_iterator =
              __nested_webpack_require_210484__(3948)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.js
            var web_url = __nested_webpack_require_210484__(285) // CONCATENATED MODULE: ./src/emitter.js
            function _createForOfIteratorHelper(o, allowArrayLike) {
              var it
              if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
                if (
                  Array.isArray(o) ||
                  (it = _unsupportedIterableToArray(o)) ||
                  (allowArrayLike && o && typeof o.length === 'number')
                ) {
                  if (it) o = it
                  var i = 0
                  var F = function F() {}
                  return {
                    s: F,
                    n: function n() {
                      if (i >= o.length) return { done: true }
                      return { done: false, value: o[i++] }
                    },
                    e: function e(_e) {
                      throw _e
                    },
                    f: F
                  }
                }
                throw new TypeError(
                  'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                )
              }
              var normalCompletion = true,
                didErr = false,
                err
              return {
                s: function s() {
                  it = o[Symbol.iterator]()
                },
                n: function n() {
                  var step = it.next()
                  normalCompletion = step.done
                  return step
                },
                e: function e(_e2) {
                  didErr = true
                  err = _e2
                },
                f: function f() {
                  try {
                    if (!normalCompletion && it.return != null) it.return()
                  } finally {
                    if (didErr) throw err
                  }
                }
              }
            }

            function _unsupportedIterableToArray(o, minLen) {
              if (!o) return
              if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
              var n = Object.prototype.toString.call(o).slice(8, -1)
              if (n === 'Object' && o.constructor) n = o.constructor.name
              if (n === 'Map' || n === 'Set') return Array.from(o)
              if (
                n === 'Arguments' ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return _arrayLikeToArray(o, minLen)
            }

            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
              }
              return arr2
            }

            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function')
              }
            }

            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }

            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps)
              if (staticProps) _defineProperties(Constructor, staticProps)
              return Constructor
            }

            // The Emitter class provides the ability to call `.on()` on Dropzone to listen
            // to events.
            // It is strongly based on component's emitter class, and I removed the
            // functionality because of the dependency hell with different frameworks.
            var Emitter = /*#__PURE__*/ (function () {
              function Emitter() {
                _classCallCheck(this, Emitter)
              }

              _createClass(Emitter, [
                {
                  key: 'on',
                  // Add an event listener for given event
                  value: function on(event, fn) {
                    this._callbacks = this._callbacks || {} // Create namespace for this event

                    if (!this._callbacks[event]) {
                      this._callbacks[event] = []
                    }

                    this._callbacks[event].push(fn)

                    return this
                  }
                },
                {
                  key: 'emit',
                  value: function emit(event) {
                    this._callbacks = this._callbacks || {}
                    var callbacks = this._callbacks[event]

                    for (
                      var _len = arguments.length,
                        args = new Array(_len > 1 ? _len - 1 : 0),
                        _key = 1;
                      _key < _len;
                      _key++
                    ) {
                      args[_key - 1] = arguments[_key]
                    }

                    if (callbacks) {
                      var _iterator = _createForOfIteratorHelper(
                          callbacks,
                          true
                        ),
                        _step

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var callback = _step.value
                          callback.apply(this, args)
                        }
                      } catch (err) {
                        _iterator.e(err)
                      } finally {
                        _iterator.f()
                      }
                    } // trigger a corresponding DOM event

                    if (this.element) {
                      this.element.dispatchEvent(
                        this.makeEvent('dropzone:' + event, {
                          args: args
                        })
                      )
                    }

                    return this
                  }
                },
                {
                  key: 'makeEvent',
                  value: function makeEvent(eventName, detail) {
                    var params = {
                      bubbles: true,
                      cancelable: true,
                      detail: detail
                    }

                    if (typeof window.CustomEvent === 'function') {
                      return new CustomEvent(eventName, params)
                    } else {
                      // IE 11 support
                      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
                      var evt = document.createEvent('CustomEvent')
                      evt.initCustomEvent(
                        eventName,
                        params.bubbles,
                        params.cancelable,
                        params.detail
                      )
                      return evt
                    }
                  } // Remove event listener for given event. If fn is not provided, all event
                  // listeners for that event will be removed. If neither is provided, all
                  // event listeners will be removed.
                },
                {
                  key: 'off',
                  value: function off(event, fn) {
                    if (!this._callbacks || arguments.length === 0) {
                      this._callbacks = {}
                      return this
                    } // specific event

                    var callbacks = this._callbacks[event]

                    if (!callbacks) {
                      return this
                    } // remove all handlers

                    if (arguments.length === 1) {
                      delete this._callbacks[event]
                      return this
                    } // remove specific handler

                    for (var i = 0; i < callbacks.length; i++) {
                      var callback = callbacks[i]

                      if (callback === fn) {
                        callbacks.splice(i, 1)
                        break
                      }
                    }

                    return this
                  }
                }
              ])

              return Emitter
            })() // CONCATENATED MODULE: ./src/preview-template.html

            // Module
            var code =
              '<div class="dz-preview dz-file-preview"> <div class="dz-image"><img data-dz-thumbnail/></div> <div class="dz-details"> <div class="dz-size"><span data-dz-size></span></div> <div class="dz-filename"><span data-dz-name></span></div> </div> <div class="dz-progress"> <span class="dz-upload" data-dz-uploadprogress></span> </div> <div class="dz-error-message"><span data-dz-errormessage></span></div> <div class="dz-success-mark"> <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <title>Check</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <path d="M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" stroke-opacity="0.198794158" stroke="#747474" fill-opacity="0.816519475" fill="#FFFFFF"></path> </g> </svg> </div> <div class="dz-error-mark"> <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <title>Error</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g stroke="#747474" stroke-opacity="0.198794158" fill="#FFFFFF" fill-opacity="0.816519475"> <path d="M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z"></path> </g> </g> </svg> </div> </div> '
            // Exports
            /* harmony default export */ var preview_template = code // CONCATENATED MODULE: ./src/options.js
            function options_createForOfIteratorHelper(o, allowArrayLike) {
              var it
              if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
                if (
                  Array.isArray(o) ||
                  (it = options_unsupportedIterableToArray(o)) ||
                  (allowArrayLike && o && typeof o.length === 'number')
                ) {
                  if (it) o = it
                  var i = 0
                  var F = function F() {}
                  return {
                    s: F,
                    n: function n() {
                      if (i >= o.length) return { done: true }
                      return { done: false, value: o[i++] }
                    },
                    e: function e(_e) {
                      throw _e
                    },
                    f: F
                  }
                }
                throw new TypeError(
                  'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                )
              }
              var normalCompletion = true,
                didErr = false,
                err
              return {
                s: function s() {
                  it = o[Symbol.iterator]()
                },
                n: function n() {
                  var step = it.next()
                  normalCompletion = step.done
                  return step
                },
                e: function e(_e2) {
                  didErr = true
                  err = _e2
                },
                f: function f() {
                  try {
                    if (!normalCompletion && it.return != null) it.return()
                  } finally {
                    if (didErr) throw err
                  }
                }
              }
            }

            function options_unsupportedIterableToArray(o, minLen) {
              if (!o) return
              if (typeof o === 'string')
                return options_arrayLikeToArray(o, minLen)
              var n = Object.prototype.toString.call(o).slice(8, -1)
              if (n === 'Object' && o.constructor) n = o.constructor.name
              if (n === 'Map' || n === 'Set') return Array.from(o)
              if (
                n === 'Arguments' ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return options_arrayLikeToArray(o, minLen)
            }

            function options_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
              }
              return arr2
            }

            var defaultOptions = {
              /**
               * Has to be specified on elements other than form (or when the form
               * doesn't have an `action` attribute). You can also
               * provide a function that will be called with `files` and
               * must return the url (since `v3.12.0`)
               */
              url: null,

              /**
               * Can be changed to `"put"` if necessary. You can also provide a function
               * that will be called with `files` and must return the method (since `v3.12.0`).
               */
              method: 'post',

              /**
               * Will be set on the XHRequest.
               */
              withCredentials: false,

              /**
               * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
               * If set to null or 0, no timeout is going to be set.
               */
              timeout: null,

              /**
               * How many file uploads to process in parallel (See the
               * Enqueuing file uploads documentation section for more info)
               */
              parallelUploads: 2,

              /**
               * Whether to send multiple files in one request. If
               * this it set to true, then the fallback file input element will
               * have the `multiple` attribute as well. This option will
               * also trigger additional events (like `processingmultiple`). See the events
               * documentation section for more information.
               */
              uploadMultiple: false,

              /**
               * Whether you want files to be uploaded in chunks to your server. This can't be
               * used in combination with `uploadMultiple`.
               *
               * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
               */
              chunking: false,

              /**
               * If `chunking` is enabled, this defines whether **every** file should be chunked,
               * even if the file size is below chunkSize. This means, that the additional chunk
               * form data will be submitted and the `chunksUploaded` callback will be invoked.
               */
              forceChunking: false,

              /**
               * If `chunking` is `true`, then this defines the chunk size in bytes.
               */
              chunkSize: 2000000,

              /**
               * If `true`, the individual chunks of a file are being uploaded simultaneously.
               */
              parallelChunkUploads: false,

              /**
               * Whether a chunk should be retried if it fails.
               */
              retryChunks: false,

              /**
               * If `retryChunks` is true, how many times should it be retried.
               */
              retryChunksLimit: 3,

              /**
               * The maximum filesize (in bytes) that is allowed to be uploaded.
               */
              maxFilesize: 256,

              /**
               * The name of the file param that gets transferred.
               * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
               * Dropzone will append `[]` to the name.
               */
              paramName: 'file',

              /**
               * Whether thumbnails for images should be generated
               */
              createImageThumbnails: true,

              /**
               * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
               */
              maxThumbnailFilesize: 10,

              /**
               * If `null`, the ratio of the image will be used to calculate it.
               */
              thumbnailWidth: 120,

              /**
               * The same as `thumbnailWidth`. If both are null, images will not be resized.
               */
              thumbnailHeight: 120,

              /**
               * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
               * Can be either `contain` or `crop`.
               */
              thumbnailMethod: 'crop',

              /**
               * If set, images will be resized to these dimensions before being **uploaded**.
               * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
               * ratio of the file will be preserved.
               *
               * The `options.transformFile` function uses these options, so if the `transformFile` function
               * is overridden, these options don't do anything.
               */
              resizeWidth: null,

              /**
               * See `resizeWidth`.
               */
              resizeHeight: null,

              /**
               * The mime type of the resized image (before it gets uploaded to the server).
               * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
               * See `resizeWidth` for more information.
               */
              resizeMimeType: null,

              /**
               * The quality of the resized images. See `resizeWidth`.
               */
              resizeQuality: 0.8,

              /**
               * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
               * Can be either `contain` or `crop`.
               */
              resizeMethod: 'contain',

              /**
               * The base that is used to calculate the **displayed** filesize. You can
               * change this to 1024 if you would rather display kibibytes, mebibytes,
               * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
               * not `1 kilobyte`. You can change this to `1024` if you don't care about
               * validity.
               */
              filesizeBase: 1000,

              /**
               * If not `null` defines how many files this Dropzone handles. If it exceeds,
               * the event `maxfilesexceeded` will be called. The dropzone element gets the
               * class `dz-max-files-reached` accordingly so you can provide visual
               * feedback.
               */
              maxFiles: null,

              /**
               * An optional object to send additional headers to the server. Eg:
               * `{ "My-Awesome-Header": "header value" }`
               */
              headers: null,

              /**
               * If `true`, the dropzone element itself will be clickable, if `false`
               * nothing will be clickable.
               *
               * You can also pass an HTML element, a CSS selector (for multiple elements)
               * or an array of those. In that case, all of those elements will trigger an
               * upload when clicked.
               */
              clickable: true,

              /**
               * Whether hidden files in directories should be ignored.
               */
              ignoreHiddenFiles: true,

              /**
               * The default implementation of `accept` checks the file's mime type or
               * extension against this list. This is a comma separated list of mime
               * types or file extensions.
               *
               * Eg.: `image/*,application/pdf,.psd`
               *
               * If the Dropzone is `clickable` this option will also be used as
               * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
               * parameter on the hidden file input as well.
               */
              acceptedFiles: null,

              /**
               * **Deprecated!**
               * Use acceptedFiles instead.
               */
              acceptedMimeTypes: null,

              /**
               * If false, files will be added to the queue but the queue will not be
               * processed automatically.
               * This can be useful if you need some additional user input before sending
               * files (or if you want want all files sent at once).
               * If you're ready to send the file simply call `myDropzone.processQueue()`.
               *
               * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
               * section for more information.
               */
              autoProcessQueue: true,

              /**
               * If false, files added to the dropzone will not be queued by default.
               * You'll have to call `enqueueFile(file)` manually.
               */
              autoQueue: true,

              /**
               * If `true`, this will add a link to every file preview to remove or cancel (if
               * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
               * and `dictRemoveFile` options are used for the wording.
               */
              addRemoveLinks: false,

              /**
               * Defines where to display the file previews  if `null` the
               * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
               * selector. The element should have the `dropzone-previews` class so
               * the previews are displayed properly.
               */
              previewsContainer: null,

              /**
               * Set this to `true` if you don't want previews to be shown.
               */
              disablePreviews: false,

              /**
               * This is the element the hidden input field (which is used when clicking on the
               * dropzone to trigger file selection) will be appended to. This might
               * be important in case you use frameworks to switch the content of your page.
               *
               * Can be a selector string, or an element directly.
               */
              hiddenInputContainer: 'body',

              /**
               * If null, no capture type will be specified
               * If camera, mobile devices will skip the file selection and choose camera
               * If microphone, mobile devices will skip the file selection and choose the microphone
               * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
               * On apple devices multiple must be set to false.  AcceptedFiles may need to
               * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
               */
              capture: null,

              /**
               * **Deprecated**. Use `renameFile` instead.
               */
              renameFilename: null,

              /**
               * A function that is invoked before the file is uploaded to the server and renames the file.
               * This function gets the `File` as argument and can use the `file.name`. The actual name of the
               * file that gets used during the upload can be accessed through `file.upload.filename`.
               */
              renameFile: null,

              /**
               * If `true` the fallback will be forced. This is very useful to test your server
               * implementations first and make sure that everything works as
               * expected without dropzone if you experience problems, and to test
               * how your fallbacks will look.
               */
              forceFallback: false,

              /**
               * The text used before any files are dropped.
               */
              dictDefaultMessage: 'Drop files here to upload',

              /**
               * The text that replaces the default message text it the browser is not supported.
               */
              dictFallbackMessage:
                "Your browser does not support drag'n'drop file uploads.",

              /**
               * The text that will be added before the fallback form.
               * If you provide a  fallback element yourself, or if this option is `null` this will
               * be ignored.
               */
              dictFallbackText:
                'Please use the fallback form below to upload your files like in the olden days.',

              /**
               * If the filesize is too big.
               * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
               */
              dictFileTooBig:
                'File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.',

              /**
               * If the file doesn't match the file type.
               */
              dictInvalidFileType: "You can't upload files of this type.",

              /**
               * If the server response was invalid.
               * `{{statusCode}}` will be replaced with the servers status code.
               */
              dictResponseError: 'Server responded with {{statusCode}} code.',

              /**
               * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
               */
              dictCancelUpload: 'Cancel upload',

              /**
               * The text that is displayed if an upload was manually canceled
               */
              dictUploadCanceled: 'Upload canceled.',

              /**
               * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
               */
              dictCancelUploadConfirmation:
                'Are you sure you want to cancel this upload?',

              /**
               * If `addRemoveLinks` is true, the text to be used to remove a file.
               */
              dictRemoveFile: 'Remove file',

              /**
               * If this is not null, then the user will be prompted before removing a file.
               */
              dictRemoveFileConfirmation: null,

              /**
               * Displayed if `maxFiles` is st and exceeded.
               * The string `{{maxFiles}}` will be replaced by the configuration value.
               */
              dictMaxFilesExceeded: 'You can not upload any more files.',

              /**
               * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
               * `b` for bytes.
               */
              dictFileSizeUnits: {
                tb: 'TB',
                gb: 'GB',
                mb: 'MB',
                kb: 'KB',
                b: 'b'
              },

              /**
               * Called when dropzone initialized
               * You can add event listeners here
               */
              init: function init() {},

              /**
               * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
               * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
               * of a function, this needs to return a map.
               *
               * The default implementation does nothing for normal uploads, but adds relevant information for
               * chunked uploads.
               *
               * This is the same as adding hidden input fields in the form element.
               */
              params: function params(files, xhr, chunk) {
                if (chunk) {
                  return {
                    dzuuid: chunk.file.upload.uuid,
                    dzchunkindex: chunk.index,
                    dztotalfilesize: chunk.file.size,
                    dzchunksize: this.options.chunkSize,
                    dztotalchunkcount: chunk.file.upload.totalChunkCount,
                    dzchunkbyteoffset: chunk.index * this.options.chunkSize
                  }
                }
              },

              /**
               * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
               * and a `done` function as parameters.
               *
               * If the done function is invoked without arguments, the file is "accepted" and will
               * be processed. If you pass an error message, the file is rejected, and the error
               * message will be displayed.
               * This function will not be called if the file is too big or doesn't match the mime types.
               */
              accept: function accept(file, done) {
                return done()
              },

              /**
               * The callback that will be invoked when all chunks have been uploaded for a file.
               * It gets the file for which the chunks have been uploaded as the first parameter,
               * and the `done` function as second. `done()` needs to be invoked when everything
               * needed to finish the upload process is done.
               */
              chunksUploaded: function chunksUploaded(file, done) {
                done()
              },

              /**
               * Gets called when the browser is not supported.
               * The default implementation shows the fallback input field and adds
               * a text.
               */
              fallback: function fallback() {
                // This code should pass in IE7... :(
                var messageElement
                this.element.className = ''.concat(
                  this.element.className,
                  ' dz-browser-not-supported'
                )

                var _iterator = options_createForOfIteratorHelper(
                    this.element.getElementsByTagName('div'),
                    true
                  ),
                  _step

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var child = _step.value

                    if (/(^| )dz-message($| )/.test(child.className)) {
                      messageElement = child
                      child.className = 'dz-message' // Removes the 'dz-default' class

                      break
                    }
                  }
                } catch (err) {
                  _iterator.e(err)
                } finally {
                  _iterator.f()
                }

                if (!messageElement) {
                  messageElement = Dropzone.createElement(
                    '<div class="dz-message"><span></span></div>'
                  )
                  this.element.appendChild(messageElement)
                }

                var span = messageElement.getElementsByTagName('span')[0]

                if (span) {
                  if (span.textContent != null) {
                    span.textContent = this.options.dictFallbackMessage
                  } else if (span.innerText != null) {
                    span.innerText = this.options.dictFallbackMessage
                  }
                }

                return this.element.appendChild(this.getFallbackForm())
              },

              /**
               * Gets called to calculate the thumbnail dimensions.
               *
               * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
               *
               *  - `srcWidth` & `srcHeight` (required)
               *  - `trgWidth` & `trgHeight` (required)
               *  - `srcX` & `srcY` (optional, default `0`)
               *  - `trgX` & `trgY` (optional, default `0`)
               *
               * Those values are going to be used by `ctx.drawImage()`.
               */
              resize: function resize(file, width, height, resizeMethod) {
                var info = {
                  srcX: 0,
                  srcY: 0,
                  srcWidth: file.width,
                  srcHeight: file.height
                }
                var srcRatio = file.width / file.height // Automatically calculate dimensions if not specified

                if (width == null && height == null) {
                  width = info.srcWidth
                  height = info.srcHeight
                } else if (width == null) {
                  width = height * srcRatio
                } else if (height == null) {
                  height = width / srcRatio
                } // Make sure images aren't upscaled

                width = Math.min(width, info.srcWidth)
                height = Math.min(height, info.srcHeight)
                var trgRatio = width / height

                if (info.srcWidth > width || info.srcHeight > height) {
                  // Image is bigger and needs rescaling
                  if (resizeMethod === 'crop') {
                    if (srcRatio > trgRatio) {
                      info.srcHeight = file.height
                      info.srcWidth = info.srcHeight * trgRatio
                    } else {
                      info.srcWidth = file.width
                      info.srcHeight = info.srcWidth / trgRatio
                    }
                  } else if (resizeMethod === 'contain') {
                    // Method 'contain'
                    if (srcRatio > trgRatio) {
                      height = width / srcRatio
                    } else {
                      width = height * srcRatio
                    }
                  } else {
                    throw new Error(
                      "Unknown resizeMethod '".concat(resizeMethod, "'")
                    )
                  }
                }

                info.srcX = (file.width - info.srcWidth) / 2
                info.srcY = (file.height - info.srcHeight) / 2
                info.trgWidth = width
                info.trgHeight = height
                return info
              },

              /**
               * Can be used to transform the file (for example, resize an image if necessary).
               *
               * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
               * images according to those dimensions.
               *
               * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
               * to be invoked with the file when the transformation is done.
               */
              transformFile: function transformFile(file, done) {
                if (
                  (this.options.resizeWidth || this.options.resizeHeight) &&
                  file.type.match(/image.*/)
                ) {
                  return this.resizeImage(
                    file,
                    this.options.resizeWidth,
                    this.options.resizeHeight,
                    this.options.resizeMethod,
                    done
                  )
                } else {
                  return done(file)
                }
              },

              /**
               * A string that contains the template used for each dropped
               * file. Change it to fulfill your needs but make sure to properly
               * provide all elements.
               *
               * If you want to use an actual HTML element instead of providing a String
               * as a config option, you could create a div with the id `tpl`,
               * put the template inside it and provide the element like this:
               *
               *     document
               *       .querySelector('#tpl')
               *       .innerHTML
               *
               */
              previewTemplate: preview_template,

              /*
   Those functions register themselves to the events on init and handle all
   the user interface specific stuff. Overwriting them won't break the upload
   but can break the way it's displayed.
   You can overwrite them if you don't like the default behavior. If you just
   want to add an additional event handler, register it on the dropzone object
   and don't overwrite those options.
   */
              // Those are self explanatory and simply concern the DragnDrop.
              drop: function drop(e) {
                return this.element.classList.remove('dz-drag-hover')
              },
              dragstart: function dragstart(e) {},
              dragend: function dragend(e) {
                return this.element.classList.remove('dz-drag-hover')
              },
              dragenter: function dragenter(e) {
                return this.element.classList.add('dz-drag-hover')
              },
              dragover: function dragover(e) {
                return this.element.classList.add('dz-drag-hover')
              },
              dragleave: function dragleave(e) {
                return this.element.classList.remove('dz-drag-hover')
              },
              paste: function paste(e) {},
              // Called whenever there are no files left in the dropzone anymore, and the
              // dropzone should be displayed as if in the initial state.
              reset: function reset() {
                return this.element.classList.remove('dz-started')
              },
              // Called when a file is added to the queue
              // Receives `file`
              addedfile: function addedfile(file) {
                var _this = this

                if (this.element === this.previewsContainer) {
                  this.element.classList.add('dz-started')
                }

                if (this.previewsContainer && !this.options.disablePreviews) {
                  file.previewElement = Dropzone.createElement(
                    this.options.previewTemplate.trim()
                  )
                  file.previewTemplate = file.previewElement // Backwards compatibility

                  this.previewsContainer.appendChild(file.previewElement)

                  var _iterator2 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll('[data-dz-name]'),
                      true
                    ),
                    _step2

                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var node = _step2.value
                      node.textContent = file.name
                    }
                  } catch (err) {
                    _iterator2.e(err)
                  } finally {
                    _iterator2.f()
                  }

                  var _iterator3 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll('[data-dz-size]'),
                      true
                    ),
                    _step3

                  try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                      node = _step3.value
                      node.innerHTML = this.filesize(file.size)
                    }
                  } catch (err) {
                    _iterator3.e(err)
                  } finally {
                    _iterator3.f()
                  }

                  if (this.options.addRemoveLinks) {
                    file._removeLink = Dropzone.createElement(
                      '<a class="dz-remove" href="javascript:undefined;" data-dz-remove>'.concat(
                        this.options.dictRemoveFile,
                        '</a>'
                      )
                    )
                    file.previewElement.appendChild(file._removeLink)
                  }

                  var removeFileEvent = function removeFileEvent(e) {
                    e.preventDefault()
                    e.stopPropagation()

                    if (file.status === Dropzone.UPLOADING) {
                      return Dropzone.confirm(
                        _this.options.dictCancelUploadConfirmation,
                        function () {
                          return _this.removeFile(file)
                        }
                      )
                    } else {
                      if (_this.options.dictRemoveFileConfirmation) {
                        return Dropzone.confirm(
                          _this.options.dictRemoveFileConfirmation,
                          function () {
                            return _this.removeFile(file)
                          }
                        )
                      } else {
                        return _this.removeFile(file)
                      }
                    }
                  }

                  var _iterator4 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll('[data-dz-remove]'),
                      true
                    ),
                    _step4

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                      var removeLink = _step4.value
                      removeLink.addEventListener('click', removeFileEvent)
                    }
                  } catch (err) {
                    _iterator4.e(err)
                  } finally {
                    _iterator4.f()
                  }
                }
              },
              // Called whenever a file is removed.
              removedfile: function removedfile(file) {
                if (
                  file.previewElement != null &&
                  file.previewElement.parentNode != null
                ) {
                  file.previewElement.parentNode.removeChild(
                    file.previewElement
                  )
                }

                return this._updateMaxFilesReachedClass()
              },
              // Called when a thumbnail has been generated
              // Receives `file` and `dataUrl`
              thumbnail: function thumbnail(file, dataUrl) {
                if (file.previewElement) {
                  file.previewElement.classList.remove('dz-file-preview')

                  var _iterator5 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll(
                        '[data-dz-thumbnail]'
                      ),
                      true
                    ),
                    _step5

                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                      var thumbnailElement = _step5.value
                      thumbnailElement.alt = file.name
                      thumbnailElement.src = dataUrl
                    }
                  } catch (err) {
                    _iterator5.e(err)
                  } finally {
                    _iterator5.f()
                  }

                  return setTimeout(function () {
                    return file.previewElement.classList.add('dz-image-preview')
                  }, 1)
                }
              },
              // Called whenever an error occurs
              // Receives `file` and `message`
              error: function error(file, message) {
                if (file.previewElement) {
                  file.previewElement.classList.add('dz-error')

                  if (typeof message !== 'string' && message.error) {
                    message = message.error
                  }

                  var _iterator6 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll(
                        '[data-dz-errormessage]'
                      ),
                      true
                    ),
                    _step6

                  try {
                    for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                      var node = _step6.value
                      node.textContent = message
                    }
                  } catch (err) {
                    _iterator6.e(err)
                  } finally {
                    _iterator6.f()
                  }
                }
              },
              errormultiple: function errormultiple() {},
              // Called when a file gets processed. Since there is a cue, not all added
              // files are processed immediately.
              // Receives `file`
              processing: function processing(file) {
                if (file.previewElement) {
                  file.previewElement.classList.add('dz-processing')

                  if (file._removeLink) {
                    return (file._removeLink.innerHTML =
                      this.options.dictCancelUpload)
                  }
                }
              },
              processingmultiple: function processingmultiple() {},
              // Called whenever the upload progress gets updated.
              // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
              // To get the total number of bytes of the file, use `file.size`
              uploadprogress: function uploadprogress(
                file,
                progress,
                bytesSent
              ) {
                if (file.previewElement) {
                  var _iterator7 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll(
                        '[data-dz-uploadprogress]'
                      ),
                      true
                    ),
                    _step7

                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                      var node = _step7.value
                      node.nodeName === 'PROGRESS'
                        ? (node.value = progress)
                        : (node.style.width = ''.concat(progress, '%'))
                    }
                  } catch (err) {
                    _iterator7.e(err)
                  } finally {
                    _iterator7.f()
                  }
                }
              },
              // Called whenever the total upload progress gets updated.
              // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
              totaluploadprogress: function totaluploadprogress() {},
              // Called just before the file is sent. Gets the `xhr` object as second
              // parameter, so you can modify it (for example to add a CSRF token) and a
              // `formData` object to add additional information.
              sending: function sending() {},
              sendingmultiple: function sendingmultiple() {},
              // When the complete upload is finished and successful
              // Receives `file`
              success: function success(file) {
                if (file.previewElement) {
                  return file.previewElement.classList.add('dz-success')
                }
              },
              successmultiple: function successmultiple() {},
              // When the upload is canceled.
              canceled: function canceled(file) {
                return this.emit('error', file, this.options.dictUploadCanceled)
              },
              canceledmultiple: function canceledmultiple() {},
              // When the upload is finished, either with success or an error.
              // Receives `file`
              complete: function complete(file) {
                if (file._removeLink) {
                  file._removeLink.innerHTML = this.options.dictRemoveFile
                }

                if (file.previewElement) {
                  return file.previewElement.classList.add('dz-complete')
                }
              },
              completemultiple: function completemultiple() {},
              maxfilesexceeded: function maxfilesexceeded() {},
              maxfilesreached: function maxfilesreached() {},
              queuecomplete: function queuecomplete() {},
              addedfiles: function addedfiles() {}
            }
            /* harmony default export */ var src_options = defaultOptions // CONCATENATED MODULE: ./src/dropzone.js
            function _typeof(obj) {
              '@babel/helpers - typeof'
              if (
                typeof Symbol === 'function' &&
                typeof Symbol.iterator === 'symbol'
              ) {
                _typeof = function _typeof(obj) {
                  return typeof obj
                }
              } else {
                _typeof = function _typeof(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj
                }
              }
              return _typeof(obj)
            }

            function dropzone_createForOfIteratorHelper(o, allowArrayLike) {
              var it
              if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
                if (
                  Array.isArray(o) ||
                  (it = dropzone_unsupportedIterableToArray(o)) ||
                  (allowArrayLike && o && typeof o.length === 'number')
                ) {
                  if (it) o = it
                  var i = 0
                  var F = function F() {}
                  return {
                    s: F,
                    n: function n() {
                      if (i >= o.length) return { done: true }
                      return { done: false, value: o[i++] }
                    },
                    e: function e(_e) {
                      throw _e
                    },
                    f: F
                  }
                }
                throw new TypeError(
                  'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                )
              }
              var normalCompletion = true,
                didErr = false,
                err
              return {
                s: function s() {
                  it = o[Symbol.iterator]()
                },
                n: function n() {
                  var step = it.next()
                  normalCompletion = step.done
                  return step
                },
                e: function e(_e2) {
                  didErr = true
                  err = _e2
                },
                f: function f() {
                  try {
                    if (!normalCompletion && it.return != null) it.return()
                  } finally {
                    if (didErr) throw err
                  }
                }
              }
            }

            function dropzone_unsupportedIterableToArray(o, minLen) {
              if (!o) return
              if (typeof o === 'string')
                return dropzone_arrayLikeToArray(o, minLen)
              var n = Object.prototype.toString.call(o).slice(8, -1)
              if (n === 'Object' && o.constructor) n = o.constructor.name
              if (n === 'Map' || n === 'Set') return Array.from(o)
              if (
                n === 'Arguments' ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return dropzone_arrayLikeToArray(o, minLen)
            }

            function dropzone_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
              }
              return arr2
            }

            function dropzone_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function')
              }
            }

            function dropzone_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }

            function dropzone_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              if (protoProps)
                dropzone_defineProperties(Constructor.prototype, protoProps)
              if (staticProps)
                dropzone_defineProperties(Constructor, staticProps)
              return Constructor
            }

            function _inherits(subClass, superClass) {
              if (typeof superClass !== 'function' && superClass !== null) {
                throw new TypeError(
                  'Super expression must either be null or a function'
                )
              }
              subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                  }
                }
              )
              if (superClass) _setPrototypeOf(subClass, superClass)
            }

            function _setPrototypeOf(o, p) {
              _setPrototypeOf =
                Object.setPrototypeOf ||
                function _setPrototypeOf(o, p) {
                  o.__proto__ = p
                  return o
                }
              return _setPrototypeOf(o, p)
            }

            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct()
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived),
                  result
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor
                  result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                  result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
              }
            }

            function _possibleConstructorReturn(self, call) {
              if (
                call &&
                (_typeof(call) === 'object' || typeof call === 'function')
              ) {
                return call
              }
              return _assertThisInitialized(self)
            }

            function _assertThisInitialized(self) {
              if (self === void 0) {
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                )
              }
              return self
            }

            function _isNativeReflectConstruct() {
              if (typeof Reflect === 'undefined' || !Reflect.construct)
                return false
              if (Reflect.construct.sham) return false
              if (typeof Proxy === 'function') return true
              try {
                Date.prototype.toString.call(
                  Reflect.construct(Date, [], function () {})
                )
                return true
              } catch (e) {
                return false
              }
            }

            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o)
                  }
              return _getPrototypeOf(o)
            }

            var Dropzone = /*#__PURE__*/ (function (_Emitter) {
              _inherits(Dropzone, _Emitter)

              var _super = _createSuper(Dropzone)

              function Dropzone(el, options) {
                var _this

                dropzone_classCallCheck(this, Dropzone)

                _this = _super.call(this)
                var fallback, left
                _this.element = el // For backwards compatibility since the version was in the prototype previously

                _this.version = Dropzone.version
                _this.clickableElements = []
                _this.listeners = []
                _this.files = [] // All files

                if (typeof _this.element === 'string') {
                  _this.element = document.querySelector(_this.element)
                } // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.

                if (!_this.element || _this.element.nodeType == null) {
                  throw new Error('Invalid dropzone element.')
                }

                if (_this.element.dropzone) {
                  throw new Error('Dropzone already attached.')
                } // Now add this dropzone to the instances.

                Dropzone.instances.push(_assertThisInitialized(_this)) // Put the dropzone inside the element itself.

                _this.element.dropzone = _assertThisInitialized(_this)
                var elementOptions =
                  (left = Dropzone.optionsForElement(_this.element)) != null
                    ? left
                    : {}
                _this.options = Dropzone.extend(
                  {},
                  src_options,
                  elementOptions,
                  options != null ? options : {}
                )
                _this.options.previewTemplate =
                  _this.options.previewTemplate.replace(/\n*/g, '') // If the browser failed, just call the fallback and leave

                if (
                  _this.options.forceFallback ||
                  !Dropzone.isBrowserSupported()
                ) {
                  return _possibleConstructorReturn(
                    _this,
                    _this.options.fallback.call(_assertThisInitialized(_this))
                  )
                } // @options.url = @element.getAttribute "action" unless @options.url?

                if (_this.options.url == null) {
                  _this.options.url = _this.element.getAttribute('action')
                }

                if (!_this.options.url) {
                  throw new Error('No URL provided.')
                }

                if (
                  _this.options.acceptedFiles &&
                  _this.options.acceptedMimeTypes
                ) {
                  throw new Error(
                    "You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated."
                  )
                }

                if (_this.options.uploadMultiple && _this.options.chunking) {
                  throw new Error(
                    'You cannot set both: uploadMultiple and chunking.'
                  )
                } // Backwards compatibility

                if (_this.options.acceptedMimeTypes) {
                  _this.options.acceptedFiles = _this.options.acceptedMimeTypes
                  delete _this.options.acceptedMimeTypes
                } // Backwards compatibility

                if (_this.options.renameFilename != null) {
                  _this.options.renameFile = function (file) {
                    return _this.options.renameFilename.call(
                      _assertThisInitialized(_this),
                      file.name,
                      file
                    )
                  }
                }

                if (typeof _this.options.method === 'string') {
                  _this.options.method = _this.options.method.toUpperCase()
                }

                if (
                  (fallback = _this.getExistingFallback()) &&
                  fallback.parentNode
                ) {
                  // Remove the fallback
                  fallback.parentNode.removeChild(fallback)
                } // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false

                if (_this.options.previewsContainer !== false) {
                  if (_this.options.previewsContainer) {
                    _this.previewsContainer = Dropzone.getElement(
                      _this.options.previewsContainer,
                      'previewsContainer'
                    )
                  } else {
                    _this.previewsContainer = _this.element
                  }
                }

                if (_this.options.clickable) {
                  if (_this.options.clickable === true) {
                    _this.clickableElements = [_this.element]
                  } else {
                    _this.clickableElements = Dropzone.getElements(
                      _this.options.clickable,
                      'clickable'
                    )
                  }
                }

                _this.init()

                return _this
              } // Returns all files that have been accepted

              dropzone_createClass(
                Dropzone,
                [
                  {
                    key: 'getAcceptedFiles',
                    value: function getAcceptedFiles() {
                      return this.files
                        .filter(function (file) {
                          return file.accepted
                        })
                        .map(function (file) {
                          return file
                        })
                    } // Returns all files that have been rejected
                    // Not sure when that's going to be useful, but added for completeness.
                  },
                  {
                    key: 'getRejectedFiles',
                    value: function getRejectedFiles() {
                      return this.files
                        .filter(function (file) {
                          return !file.accepted
                        })
                        .map(function (file) {
                          return file
                        })
                    }
                  },
                  {
                    key: 'getFilesWithStatus',
                    value: function getFilesWithStatus(status) {
                      return this.files
                        .filter(function (file) {
                          return file.status === status
                        })
                        .map(function (file) {
                          return file
                        })
                    } // Returns all files that are in the queue
                  },
                  {
                    key: 'getQueuedFiles',
                    value: function getQueuedFiles() {
                      return this.getFilesWithStatus(Dropzone.QUEUED)
                    }
                  },
                  {
                    key: 'getUploadingFiles',
                    value: function getUploadingFiles() {
                      return this.getFilesWithStatus(Dropzone.UPLOADING)
                    }
                  },
                  {
                    key: 'getAddedFiles',
                    value: function getAddedFiles() {
                      return this.getFilesWithStatus(Dropzone.ADDED)
                    } // Files that are either queued or uploading
                  },
                  {
                    key: 'getActiveFiles',
                    value: function getActiveFiles() {
                      return this.files
                        .filter(function (file) {
                          return (
                            file.status === Dropzone.UPLOADING ||
                            file.status === Dropzone.QUEUED
                          )
                        })
                        .map(function (file) {
                          return file
                        })
                    } // The function that gets called when Dropzone is initialized. You
                    // can (and should) setup event listeners inside this function.
                  },
                  {
                    key: 'init',
                    value: function init() {
                      var _this2 = this

                      // In case it isn't set already
                      if (this.element.tagName === 'form') {
                        this.element.setAttribute(
                          'enctype',
                          'multipart/form-data'
                        )
                      }

                      if (
                        this.element.classList.contains('dropzone') &&
                        !this.element.querySelector('.dz-message')
                      ) {
                        this.element.appendChild(
                          Dropzone.createElement(
                            '<div class="dz-default dz-message"><button class="dz-button" type="button">'.concat(
                              this.options.dictDefaultMessage,
                              '</button></div>'
                            )
                          )
                        )
                      }

                      if (this.clickableElements.length) {
                        var setupHiddenFileInput =
                          function setupHiddenFileInput() {
                            if (_this2.hiddenFileInput) {
                              _this2.hiddenFileInput.parentNode.removeChild(
                                _this2.hiddenFileInput
                              )
                            }

                            _this2.hiddenFileInput =
                              document.createElement('input')

                            _this2.hiddenFileInput.setAttribute('type', 'file')

                            if (
                              _this2.options.maxFiles === null ||
                              _this2.options.maxFiles > 1
                            ) {
                              _this2.hiddenFileInput.setAttribute(
                                'multiple',
                                'multiple'
                              )
                            }

                            _this2.hiddenFileInput.className = 'dz-hidden-input'

                            if (_this2.options.acceptedFiles !== null) {
                              _this2.hiddenFileInput.setAttribute(
                                'accept',
                                _this2.options.acceptedFiles
                              )
                            }

                            if (_this2.options.capture !== null) {
                              _this2.hiddenFileInput.setAttribute(
                                'capture',
                                _this2.options.capture
                              )
                            } // Making sure that no one can "tab" into this field.

                            _this2.hiddenFileInput.setAttribute(
                              'tabindex',
                              '-1'
                            ) // Not setting `display="none"` because some browsers don't accept clicks
                            // on elements that aren't displayed.

                            _this2.hiddenFileInput.style.visibility = 'hidden'
                            _this2.hiddenFileInput.style.position = 'absolute'
                            _this2.hiddenFileInput.style.top = '0'
                            _this2.hiddenFileInput.style.left = '0'
                            _this2.hiddenFileInput.style.height = '0'
                            _this2.hiddenFileInput.style.width = '0'
                            Dropzone.getElement(
                              _this2.options.hiddenInputContainer,
                              'hiddenInputContainer'
                            ).appendChild(_this2.hiddenFileInput)

                            _this2.hiddenFileInput.addEventListener(
                              'change',
                              function () {
                                var files = _this2.hiddenFileInput.files

                                if (files.length) {
                                  var _iterator =
                                      dropzone_createForOfIteratorHelper(
                                        files,
                                        true
                                      ),
                                    _step

                                  try {
                                    for (
                                      _iterator.s();
                                      !(_step = _iterator.n()).done;

                                    ) {
                                      var file = _step.value

                                      _this2.addFile(file)
                                    }
                                  } catch (err) {
                                    _iterator.e(err)
                                  } finally {
                                    _iterator.f()
                                  }
                                }

                                _this2.emit('addedfiles', files)

                                setupHiddenFileInput()
                              }
                            )
                          }

                        setupHiddenFileInput()
                      }

                      this.URL =
                        window.URL !== null ? window.URL : window.webkitURL // Setup all event listeners on the Dropzone object itself.
                      // They're not in @setupEventListeners() because they shouldn't be removed
                      // again when the dropzone gets disabled.

                      var _iterator2 = dropzone_createForOfIteratorHelper(
                          this.events,
                          true
                        ),
                        _step2

                      try {
                        for (
                          _iterator2.s();
                          !(_step2 = _iterator2.n()).done;

                        ) {
                          var eventName = _step2.value
                          this.on(eventName, this.options[eventName])
                        }
                      } catch (err) {
                        _iterator2.e(err)
                      } finally {
                        _iterator2.f()
                      }

                      this.on('uploadprogress', function () {
                        return _this2.updateTotalUploadProgress()
                      })
                      this.on('removedfile', function () {
                        return _this2.updateTotalUploadProgress()
                      })
                      this.on('canceled', function (file) {
                        return _this2.emit('complete', file)
                      }) // Emit a `queuecomplete` event if all files finished uploading.

                      this.on('complete', function (file) {
                        if (
                          _this2.getAddedFiles().length === 0 &&
                          _this2.getUploadingFiles().length === 0 &&
                          _this2.getQueuedFiles().length === 0
                        ) {
                          // This needs to be deferred so that `queuecomplete` really triggers after `complete`
                          return setTimeout(function () {
                            return _this2.emit('queuecomplete')
                          }, 0)
                        }
                      })

                      var containsFiles = function containsFiles(e) {
                        if (e.dataTransfer.types) {
                          // Because e.dataTransfer.types is an Object in
                          // IE, we need to iterate like this instead of
                          // using e.dataTransfer.types.some()
                          for (
                            var i = 0;
                            i < e.dataTransfer.types.length;
                            i++
                          ) {
                            if (e.dataTransfer.types[i] === 'Files') return true
                          }
                        }

                        return false
                      }

                      var noPropagation = function noPropagation(e) {
                        // If there are no files, we don't want to stop
                        // propagation so we don't interfere with other
                        // drag and drop behaviour.
                        if (!containsFiles(e)) return
                        e.stopPropagation()

                        if (e.preventDefault) {
                          return e.preventDefault()
                        } else {
                          return (e.returnValue = false)
                        }
                      } // Create the listeners

                      this.listeners = [
                        {
                          element: this.element,
                          events: {
                            dragstart: function dragstart(e) {
                              return _this2.emit('dragstart', e)
                            },
                            dragenter: function dragenter(e) {
                              noPropagation(e)
                              return _this2.emit('dragenter', e)
                            },
                            dragover: function dragover(e) {
                              // Makes it possible to drag files from chrome's download bar
                              // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                              // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                              var efct

                              try {
                                efct = e.dataTransfer.effectAllowed
                              } catch (error) {}

                              e.dataTransfer.dropEffect =
                                'move' === efct || 'linkMove' === efct
                                  ? 'move'
                                  : 'copy'
                              noPropagation(e)
                              return _this2.emit('dragover', e)
                            },
                            dragleave: function dragleave(e) {
                              return _this2.emit('dragleave', e)
                            },
                            drop: function drop(e) {
                              noPropagation(e)
                              return _this2.drop(e)
                            },
                            dragend: function dragend(e) {
                              return _this2.emit('dragend', e)
                            }
                          } // This is disabled right now, because the browsers don't implement it properly.
                          // "paste": (e) =>
                          //   noPropagation e
                          //   @paste e
                        }
                      ]
                      this.clickableElements.forEach(function (
                        clickableElement
                      ) {
                        return _this2.listeners.push({
                          element: clickableElement,
                          events: {
                            click: function click(evt) {
                              // Only the actual dropzone or the message element should trigger file selection
                              if (
                                clickableElement !== _this2.element ||
                                evt.target === _this2.element ||
                                Dropzone.elementInside(
                                  evt.target,
                                  _this2.element.querySelector('.dz-message')
                                )
                              ) {
                                _this2.hiddenFileInput.click() // Forward the click
                              }

                              return true
                            }
                          }
                        })
                      })
                      this.enable()
                      return this.options.init.call(this)
                    } // Not fully tested yet
                  },
                  {
                    key: 'destroy',
                    value: function destroy() {
                      this.disable()
                      this.removeAllFiles(true)

                      if (
                        this.hiddenFileInput != null
                          ? this.hiddenFileInput.parentNode
                          : undefined
                      ) {
                        this.hiddenFileInput.parentNode.removeChild(
                          this.hiddenFileInput
                        )
                        this.hiddenFileInput = null
                      }

                      delete this.element.dropzone
                      return Dropzone.instances.splice(
                        Dropzone.instances.indexOf(this),
                        1
                      )
                    }
                  },
                  {
                    key: 'updateTotalUploadProgress',
                    value: function updateTotalUploadProgress() {
                      var totalUploadProgress
                      var totalBytesSent = 0
                      var totalBytes = 0
                      var activeFiles = this.getActiveFiles()

                      if (activeFiles.length) {
                        var _iterator3 = dropzone_createForOfIteratorHelper(
                            this.getActiveFiles(),
                            true
                          ),
                          _step3

                        try {
                          for (
                            _iterator3.s();
                            !(_step3 = _iterator3.n()).done;

                          ) {
                            var file = _step3.value
                            totalBytesSent += file.upload.bytesSent
                            totalBytes += file.upload.total
                          }
                        } catch (err) {
                          _iterator3.e(err)
                        } finally {
                          _iterator3.f()
                        }

                        totalUploadProgress =
                          (100 * totalBytesSent) / totalBytes
                      } else {
                        totalUploadProgress = 100
                      }

                      return this.emit(
                        'totaluploadprogress',
                        totalUploadProgress,
                        totalBytes,
                        totalBytesSent
                      )
                    } // @options.paramName can be a function taking one parameter rather than a string.
                    // A parameter name for a file is obtained simply by calling this with an index number.
                  },
                  {
                    key: '_getParamName',
                    value: function _getParamName(n) {
                      if (typeof this.options.paramName === 'function') {
                        return this.options.paramName(n)
                      } else {
                        return ''
                          .concat(this.options.paramName)
                          .concat(
                            this.options.uploadMultiple
                              ? '['.concat(n, ']')
                              : ''
                          )
                      }
                    } // If @options.renameFile is a function,
                    // the function will be used to rename the file.name before appending it to the formData
                  },
                  {
                    key: '_renameFile',
                    value: function _renameFile(file) {
                      if (typeof this.options.renameFile !== 'function') {
                        return file.name
                      }

                      return this.options.renameFile(file)
                    } // Returns a form that can be used as fallback if the browser does not support DragnDrop
                    //
                    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
                    // This code has to pass in IE7 :(
                  },
                  {
                    key: 'getFallbackForm',
                    value: function getFallbackForm() {
                      var existingFallback, form

                      if ((existingFallback = this.getExistingFallback())) {
                        return existingFallback
                      }

                      var fieldsString = '<div class="dz-fallback">'

                      if (this.options.dictFallbackText) {
                        fieldsString += '<p>'.concat(
                          this.options.dictFallbackText,
                          '</p>'
                        )
                      }

                      fieldsString += '<input type="file" name="'
                        .concat(this._getParamName(0), '" ')
                        .concat(
                          this.options.uploadMultiple
                            ? 'multiple="multiple"'
                            : undefined,
                          ' /><input type="submit" value="Upload!"></div>'
                        )
                      var fields = Dropzone.createElement(fieldsString)

                      if (this.element.tagName !== 'FORM') {
                        form = Dropzone.createElement(
                          '<form action="'
                            .concat(
                              this.options.url,
                              '" enctype="multipart/form-data" method="'
                            )
                            .concat(this.options.method, '"></form>')
                        )
                        form.appendChild(fields)
                      } else {
                        // Make sure that the enctype and method attributes are set properly
                        this.element.setAttribute(
                          'enctype',
                          'multipart/form-data'
                        )
                        this.element.setAttribute('method', this.options.method)
                      }

                      return form != null ? form : fields
                    } // Returns the fallback elements if they exist already
                    //
                    // This code has to pass in IE7 :(
                  },
                  {
                    key: 'getExistingFallback',
                    value: function getExistingFallback() {
                      var getFallback = function getFallback(elements) {
                        var _iterator4 = dropzone_createForOfIteratorHelper(
                            elements,
                            true
                          ),
                          _step4

                        try {
                          for (
                            _iterator4.s();
                            !(_step4 = _iterator4.n()).done;

                          ) {
                            var el = _step4.value

                            if (/(^| )fallback($| )/.test(el.className)) {
                              return el
                            }
                          }
                        } catch (err) {
                          _iterator4.e(err)
                        } finally {
                          _iterator4.f()
                        }
                      }

                      for (
                        var _i = 0, _arr = ['div', 'form'];
                        _i < _arr.length;
                        _i++
                      ) {
                        var tagName = _arr[_i]
                        var fallback

                        if (
                          (fallback = getFallback(
                            this.element.getElementsByTagName(tagName)
                          ))
                        ) {
                          return fallback
                        }
                      }
                    } // Activates all listeners stored in @listeners
                  },
                  {
                    key: 'setupEventListeners',
                    value: function setupEventListeners() {
                      return this.listeners.map(function (elementListeners) {
                        return (function () {
                          var result = []

                          for (var event in elementListeners.events) {
                            var listener = elementListeners.events[event]
                            result.push(
                              elementListeners.element.addEventListener(
                                event,
                                listener,
                                false
                              )
                            )
                          }

                          return result
                        })()
                      })
                    } // Deactivates all listeners stored in @listeners
                  },
                  {
                    key: 'removeEventListeners',
                    value: function removeEventListeners() {
                      return this.listeners.map(function (elementListeners) {
                        return (function () {
                          var result = []

                          for (var event in elementListeners.events) {
                            var listener = elementListeners.events[event]
                            result.push(
                              elementListeners.element.removeEventListener(
                                event,
                                listener,
                                false
                              )
                            )
                          }

                          return result
                        })()
                      })
                    } // Removes all event listeners and cancels all files in the queue or being processed.
                  },
                  {
                    key: 'disable',
                    value: function disable() {
                      var _this3 = this

                      this.clickableElements.forEach(function (element) {
                        return element.classList.remove('dz-clickable')
                      })
                      this.removeEventListeners()
                      this.disabled = true
                      return this.files.map(function (file) {
                        return _this3.cancelUpload(file)
                      })
                    }
                  },
                  {
                    key: 'enable',
                    value: function enable() {
                      delete this.disabled
                      this.clickableElements.forEach(function (element) {
                        return element.classList.add('dz-clickable')
                      })
                      return this.setupEventListeners()
                    } // Returns a nicely formatted filesize
                  },
                  {
                    key: 'filesize',
                    value: function filesize(size) {
                      var selectedSize = 0
                      var selectedUnit = 'b'

                      if (size > 0) {
                        var units = ['tb', 'gb', 'mb', 'kb', 'b']

                        for (var i = 0; i < units.length; i++) {
                          var unit = units[i]
                          var cutoff =
                            Math.pow(this.options.filesizeBase, 4 - i) / 10

                          if (size >= cutoff) {
                            selectedSize =
                              size / Math.pow(this.options.filesizeBase, 4 - i)
                            selectedUnit = unit
                            break
                          }
                        }

                        selectedSize = Math.round(10 * selectedSize) / 10 // Cutting of digits
                      }

                      return '<strong>'
                        .concat(selectedSize, '</strong> ')
                        .concat(this.options.dictFileSizeUnits[selectedUnit])
                    } // Adds or removes the `dz-max-files-reached` class from the form.
                  },
                  {
                    key: '_updateMaxFilesReachedClass',
                    value: function _updateMaxFilesReachedClass() {
                      if (
                        this.options.maxFiles != null &&
                        this.getAcceptedFiles().length >= this.options.maxFiles
                      ) {
                        if (
                          this.getAcceptedFiles().length ===
                          this.options.maxFiles
                        ) {
                          this.emit('maxfilesreached', this.files)
                        }

                        return this.element.classList.add(
                          'dz-max-files-reached'
                        )
                      } else {
                        return this.element.classList.remove(
                          'dz-max-files-reached'
                        )
                      }
                    }
                  },
                  {
                    key: 'drop',
                    value: function drop(e) {
                      if (!e.dataTransfer) {
                        return
                      }

                      this.emit('drop', e) // Convert the FileList to an Array
                      // This is necessary for IE11

                      var files = []

                      for (var i = 0; i < e.dataTransfer.files.length; i++) {
                        files[i] = e.dataTransfer.files[i]
                      } // Even if it's a folder, files.length will contain the folders.

                      if (files.length) {
                        var items = e.dataTransfer.items

                        if (
                          items &&
                          items.length &&
                          items[0].webkitGetAsEntry != null
                        ) {
                          // The browser supports dropping of folders, so handle items instead of files
                          this._addFilesFromItems(items)
                        } else {
                          this.handleFiles(files)
                        }
                      }

                      this.emit('addedfiles', files)
                    }
                  },
                  {
                    key: 'paste',
                    value: function paste(e) {
                      if (
                        __guard__(
                          e != null ? e.clipboardData : undefined,
                          function (x) {
                            return x.items
                          }
                        ) == null
                      ) {
                        return
                      }

                      this.emit('paste', e)
                      var items = e.clipboardData.items

                      if (items.length) {
                        return this._addFilesFromItems(items)
                      }
                    }
                  },
                  {
                    key: 'handleFiles',
                    value: function handleFiles(files) {
                      var _iterator5 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step5

                      try {
                        for (
                          _iterator5.s();
                          !(_step5 = _iterator5.n()).done;

                        ) {
                          var file = _step5.value
                          this.addFile(file)
                        }
                      } catch (err) {
                        _iterator5.e(err)
                      } finally {
                        _iterator5.f()
                      }
                    } // When a folder is dropped (or files are pasted), items must be handled
                    // instead of files.
                  },
                  {
                    key: '_addFilesFromItems',
                    value: function _addFilesFromItems(items) {
                      var _this4 = this

                      return (function () {
                        var result = []

                        var _iterator6 = dropzone_createForOfIteratorHelper(
                            items,
                            true
                          ),
                          _step6

                        try {
                          for (
                            _iterator6.s();
                            !(_step6 = _iterator6.n()).done;

                          ) {
                            var item = _step6.value
                            var entry

                            if (
                              item.webkitGetAsEntry != null &&
                              (entry = item.webkitGetAsEntry())
                            ) {
                              if (entry.isFile) {
                                result.push(_this4.addFile(item.getAsFile()))
                              } else if (entry.isDirectory) {
                                // Append all files from that directory to files
                                result.push(
                                  _this4._addFilesFromDirectory(
                                    entry,
                                    entry.name
                                  )
                                )
                              } else {
                                result.push(undefined)
                              }
                            } else if (item.getAsFile != null) {
                              if (item.kind == null || item.kind === 'file') {
                                result.push(_this4.addFile(item.getAsFile()))
                              } else {
                                result.push(undefined)
                              }
                            } else {
                              result.push(undefined)
                            }
                          }
                        } catch (err) {
                          _iterator6.e(err)
                        } finally {
                          _iterator6.f()
                        }

                        return result
                      })()
                    } // Goes through the directory, and adds each file it finds recursively
                  },
                  {
                    key: '_addFilesFromDirectory',
                    value: function _addFilesFromDirectory(directory, path) {
                      var _this5 = this

                      var dirReader = directory.createReader()

                      var errorHandler = function errorHandler(error) {
                        return __guardMethod__(console, 'log', function (o) {
                          return o.log(error)
                        })
                      }

                      var readEntries = function readEntries() {
                        return dirReader.readEntries(function (entries) {
                          if (entries.length > 0) {
                            var _iterator7 = dropzone_createForOfIteratorHelper(
                                entries,
                                true
                              ),
                              _step7

                            try {
                              for (
                                _iterator7.s();
                                !(_step7 = _iterator7.n()).done;

                              ) {
                                var entry = _step7.value

                                if (entry.isFile) {
                                  entry.file(function (file) {
                                    if (
                                      _this5.options.ignoreHiddenFiles &&
                                      file.name.substring(0, 1) === '.'
                                    ) {
                                      return
                                    }

                                    file.fullPath = ''
                                      .concat(path, '/')
                                      .concat(file.name)
                                    return _this5.addFile(file)
                                  })
                                } else if (entry.isDirectory) {
                                  _this5._addFilesFromDirectory(
                                    entry,
                                    ''.concat(path, '/').concat(entry.name)
                                  )
                                }
                              } // Recursively call readEntries() again, since browser only handle
                              // the first 100 entries.
                              // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                            } catch (err) {
                              _iterator7.e(err)
                            } finally {
                              _iterator7.f()
                            }

                            readEntries()
                          }

                          return null
                        }, errorHandler)
                      }

                      return readEntries()
                    } // If `done()` is called without argument the file is accepted
                    // If you call it with an error message, the file is rejected
                    // (This allows for asynchronous validation)
                    //
                    // This function checks the filesize, and if the file.type passes the
                    // `acceptedFiles` check.
                  },
                  {
                    key: 'accept',
                    value: function accept(file, done) {
                      if (
                        this.options.maxFilesize &&
                        file.size > this.options.maxFilesize * 1024 * 1024
                      ) {
                        done(
                          this.options.dictFileTooBig
                            .replace(
                              '{{filesize}}',
                              Math.round(file.size / 1024 / 10.24) / 100
                            )
                            .replace(
                              '{{maxFilesize}}',
                              this.options.maxFilesize
                            )
                        )
                      } else if (
                        !Dropzone.isValidFile(file, this.options.acceptedFiles)
                      ) {
                        done(this.options.dictInvalidFileType)
                      } else if (
                        this.options.maxFiles != null &&
                        this.getAcceptedFiles().length >= this.options.maxFiles
                      ) {
                        done(
                          this.options.dictMaxFilesExceeded.replace(
                            '{{maxFiles}}',
                            this.options.maxFiles
                          )
                        )
                        this.emit('maxfilesexceeded', file)
                      } else {
                        this.options.accept.call(this, file, done)
                      }
                    }
                  },
                  {
                    key: 'addFile',
                    value: function addFile(file) {
                      var _this6 = this

                      file.upload = {
                        uuid: Dropzone.uuidv4(),
                        progress: 0,
                        // Setting the total upload size to file.size for the beginning
                        // It's actual different than the size to be transmitted.
                        total: file.size,
                        bytesSent: 0,
                        filename: this._renameFile(file) // Not setting chunking information here, because the acutal data  and
                        // thus the chunks  might change if `options.transformFile` is set
                        // and does something to the data.
                      }
                      this.files.push(file)
                      file.status = Dropzone.ADDED
                      this.emit('addedfile', file)

                      this._enqueueThumbnail(file)

                      this.accept(file, function (error) {
                        if (error) {
                          file.accepted = false

                          _this6._errorProcessing([file], error) // Will set the file.status
                        } else {
                          file.accepted = true

                          if (_this6.options.autoQueue) {
                            _this6.enqueueFile(file)
                          } // Will set .accepted = true
                        }

                        _this6._updateMaxFilesReachedClass()
                      })
                    } // Wrapper for enqueueFile
                  },
                  {
                    key: 'enqueueFiles',
                    value: function enqueueFiles(files) {
                      var _iterator8 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step8

                      try {
                        for (
                          _iterator8.s();
                          !(_step8 = _iterator8.n()).done;

                        ) {
                          var file = _step8.value
                          this.enqueueFile(file)
                        }
                      } catch (err) {
                        _iterator8.e(err)
                      } finally {
                        _iterator8.f()
                      }

                      return null
                    }
                  },
                  {
                    key: 'enqueueFile',
                    value: function enqueueFile(file) {
                      var _this7 = this

                      if (
                        file.status === Dropzone.ADDED &&
                        file.accepted === true
                      ) {
                        file.status = Dropzone.QUEUED

                        if (this.options.autoProcessQueue) {
                          return setTimeout(function () {
                            return _this7.processQueue()
                          }, 0) // Deferring the call
                        }
                      } else {
                        throw new Error(
                          "This file can't be queued because it has already been processed or was rejected."
                        )
                      }
                    }
                  },
                  {
                    key: '_enqueueThumbnail',
                    value: function _enqueueThumbnail(file) {
                      var _this8 = this

                      if (
                        this.options.createImageThumbnails &&
                        file.type.match(/image.*/) &&
                        file.size <=
                          this.options.maxThumbnailFilesize * 1024 * 1024
                      ) {
                        this._thumbnailQueue.push(file)

                        return setTimeout(function () {
                          return _this8._processThumbnailQueue()
                        }, 0) // Deferring the call
                      }
                    }
                  },
                  {
                    key: '_processThumbnailQueue',
                    value: function _processThumbnailQueue() {
                      var _this9 = this

                      if (
                        this._processingThumbnail ||
                        this._thumbnailQueue.length === 0
                      ) {
                        return
                      }

                      this._processingThumbnail = true

                      var file = this._thumbnailQueue.shift()

                      return this.createThumbnail(
                        file,
                        this.options.thumbnailWidth,
                        this.options.thumbnailHeight,
                        this.options.thumbnailMethod,
                        true,
                        function (dataUrl) {
                          _this9.emit('thumbnail', file, dataUrl)

                          _this9._processingThumbnail = false
                          return _this9._processThumbnailQueue()
                        }
                      )
                    } // Can be called by the user to remove a file
                  },
                  {
                    key: 'removeFile',
                    value: function removeFile(file) {
                      if (file.status === Dropzone.UPLOADING) {
                        this.cancelUpload(file)
                      }

                      this.files = without(this.files, file)
                      this.emit('removedfile', file)

                      if (this.files.length === 0) {
                        return this.emit('reset')
                      }
                    } // Removes all files that aren't currently processed from the list
                  },
                  {
                    key: 'removeAllFiles',
                    value: function removeAllFiles(cancelIfNecessary) {
                      // Create a copy of files since removeFile() changes the @files array.
                      if (cancelIfNecessary == null) {
                        cancelIfNecessary = false
                      }

                      var _iterator9 = dropzone_createForOfIteratorHelper(
                          this.files.slice(),
                          true
                        ),
                        _step9

                      try {
                        for (
                          _iterator9.s();
                          !(_step9 = _iterator9.n()).done;

                        ) {
                          var file = _step9.value

                          if (
                            file.status !== Dropzone.UPLOADING ||
                            cancelIfNecessary
                          ) {
                            this.removeFile(file)
                          }
                        }
                      } catch (err) {
                        _iterator9.e(err)
                      } finally {
                        _iterator9.f()
                      }

                      return null
                    } // Resizes an image before it gets sent to the server. This function is the default behavior of
                    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
                    // the resized blob.
                  },
                  {
                    key: 'resizeImage',
                    value: function resizeImage(
                      file,
                      width,
                      height,
                      resizeMethod,
                      callback
                    ) {
                      var _this10 = this

                      return this.createThumbnail(
                        file,
                        width,
                        height,
                        resizeMethod,
                        true,
                        function (dataUrl, canvas) {
                          if (canvas == null) {
                            // The image has not been resized
                            return callback(file)
                          } else {
                            var resizeMimeType = _this10.options.resizeMimeType

                            if (resizeMimeType == null) {
                              resizeMimeType = file.type
                            }

                            var resizedDataURL = canvas.toDataURL(
                              resizeMimeType,
                              _this10.options.resizeQuality
                            )

                            if (
                              resizeMimeType === 'image/jpeg' ||
                              resizeMimeType === 'image/jpg'
                            ) {
                              // Now add the original EXIF information
                              resizedDataURL = ExifRestore.restore(
                                file.dataURL,
                                resizedDataURL
                              )
                            }

                            return callback(
                              Dropzone.dataURItoBlob(resizedDataURL)
                            )
                          }
                        }
                      )
                    }
                  },
                  {
                    key: 'createThumbnail',
                    value: function createThumbnail(
                      file,
                      width,
                      height,
                      resizeMethod,
                      fixOrientation,
                      callback
                    ) {
                      var _this11 = this

                      var fileReader = new FileReader()

                      fileReader.onload = function () {
                        file.dataURL = fileReader.result // Don't bother creating a thumbnail for SVG images since they're vector

                        if (file.type === 'image/svg+xml') {
                          if (callback != null) {
                            callback(fileReader.result)
                          }

                          return
                        }

                        _this11.createThumbnailFromUrl(
                          file,
                          width,
                          height,
                          resizeMethod,
                          fixOrientation,
                          callback
                        )
                      }

                      fileReader.readAsDataURL(file)
                    } // `mockFile` needs to have these attributes:
                    //
                    //     { name: 'name', size: 12345, imageUrl: '' }
                    //
                    // `callback` will be invoked when the image has been downloaded and displayed.
                    // `crossOrigin` will be added to the `img` tag when accessing the file.
                  },
                  {
                    key: 'displayExistingFile',
                    value: function displayExistingFile(
                      mockFile,
                      imageUrl,
                      callback,
                      crossOrigin
                    ) {
                      var _this12 = this

                      var resizeThumbnail =
                        arguments.length > 4 && arguments[4] !== undefined
                          ? arguments[4]
                          : true
                      this.emit('addedfile', mockFile)
                      this.emit('complete', mockFile)

                      if (!resizeThumbnail) {
                        this.emit('thumbnail', mockFile, imageUrl)
                        if (callback) callback()
                      } else {
                        var onDone = function onDone(thumbnail) {
                          _this12.emit('thumbnail', mockFile, thumbnail)

                          if (callback) callback()
                        }

                        mockFile.dataURL = imageUrl
                        this.createThumbnailFromUrl(
                          mockFile,
                          this.options.thumbnailWidth,
                          this.options.thumbnailHeight,
                          this.options.thumbnailMethod,
                          this.options.fixOrientation,
                          onDone,
                          crossOrigin
                        )
                      }
                    }
                  },
                  {
                    key: 'createThumbnailFromUrl',
                    value: function createThumbnailFromUrl(
                      file,
                      width,
                      height,
                      resizeMethod,
                      fixOrientation,
                      callback,
                      crossOrigin
                    ) {
                      var _this13 = this

                      // Not using `new Image` here because of a bug in latest Chrome versions.
                      // See https://github.com/enyo/dropzone/pull/226
                      var img = document.createElement('img')

                      if (crossOrigin) {
                        img.crossOrigin = crossOrigin
                      } // fixOrientation is not needed anymore with browsers handling imageOrientation

                      fixOrientation =
                        getComputedStyle(document.body)['imageOrientation'] ==
                        'from-image'
                          ? false
                          : fixOrientation

                      img.onload = function () {
                        var loadExif = function loadExif(callback) {
                          return callback(1)
                        }

                        if (
                          typeof EXIF !== 'undefined' &&
                          EXIF !== null &&
                          fixOrientation
                        ) {
                          loadExif = function loadExif(callback) {
                            return EXIF.getData(img, function () {
                              return callback(EXIF.getTag(this, 'Orientation'))
                            })
                          }
                        }

                        return loadExif(function (orientation) {
                          file.width = img.width
                          file.height = img.height

                          var resizeInfo = _this13.options.resize.call(
                            _this13,
                            file,
                            width,
                            height,
                            resizeMethod
                          )

                          var canvas = document.createElement('canvas')
                          var ctx = canvas.getContext('2d')
                          canvas.width = resizeInfo.trgWidth
                          canvas.height = resizeInfo.trgHeight

                          if (orientation > 4) {
                            canvas.width = resizeInfo.trgHeight
                            canvas.height = resizeInfo.trgWidth
                          }

                          switch (orientation) {
                            case 2:
                              // horizontal flip
                              ctx.translate(canvas.width, 0)
                              ctx.scale(-1, 1)
                              break

                            case 3:
                              // 180 rotate left
                              ctx.translate(canvas.width, canvas.height)
                              ctx.rotate(Math.PI)
                              break

                            case 4:
                              // vertical flip
                              ctx.translate(0, canvas.height)
                              ctx.scale(1, -1)
                              break

                            case 5:
                              // vertical flip + 90 rotate right
                              ctx.rotate(0.5 * Math.PI)
                              ctx.scale(1, -1)
                              break

                            case 6:
                              // 90 rotate right
                              ctx.rotate(0.5 * Math.PI)
                              ctx.translate(0, -canvas.width)
                              break

                            case 7:
                              // horizontal flip + 90 rotate right
                              ctx.rotate(0.5 * Math.PI)
                              ctx.translate(canvas.height, -canvas.width)
                              ctx.scale(-1, 1)
                              break

                            case 8:
                              // 90 rotate left
                              ctx.rotate(-0.5 * Math.PI)
                              ctx.translate(-canvas.height, 0)
                              break
                          } // This is a bugfix for iOS' scaling bug.

                          drawImageIOSFix(
                            ctx,
                            img,
                            resizeInfo.srcX != null ? resizeInfo.srcX : 0,
                            resizeInfo.srcY != null ? resizeInfo.srcY : 0,
                            resizeInfo.srcWidth,
                            resizeInfo.srcHeight,
                            resizeInfo.trgX != null ? resizeInfo.trgX : 0,
                            resizeInfo.trgY != null ? resizeInfo.trgY : 0,
                            resizeInfo.trgWidth,
                            resizeInfo.trgHeight
                          )
                          var thumbnail = canvas.toDataURL('image/png')

                          if (callback != null) {
                            return callback(thumbnail, canvas)
                          }
                        })
                      }

                      if (callback != null) {
                        img.onerror = callback
                      }

                      return (img.src = file.dataURL)
                    } // Goes through the queue and processes files if there aren't too many already.
                  },
                  {
                    key: 'processQueue',
                    value: function processQueue() {
                      var parallelUploads = this.options.parallelUploads
                      var processingLength = this.getUploadingFiles().length
                      var i = processingLength // There are already at least as many files uploading than should be

                      if (processingLength >= parallelUploads) {
                        return
                      }

                      var queuedFiles = this.getQueuedFiles()

                      if (!(queuedFiles.length > 0)) {
                        return
                      }

                      if (this.options.uploadMultiple) {
                        // The files should be uploaded in one request
                        return this.processFiles(
                          queuedFiles.slice(
                            0,
                            parallelUploads - processingLength
                          )
                        )
                      } else {
                        while (i < parallelUploads) {
                          if (!queuedFiles.length) {
                            return
                          } // Nothing left to process

                          this.processFile(queuedFiles.shift())
                          i++
                        }
                      }
                    } // Wrapper for `processFiles`
                  },
                  {
                    key: 'processFile',
                    value: function processFile(file) {
                      return this.processFiles([file])
                    } // Loads the file, then calls finishedLoading()
                  },
                  {
                    key: 'processFiles',
                    value: function processFiles(files) {
                      var _iterator10 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step10

                      try {
                        for (
                          _iterator10.s();
                          !(_step10 = _iterator10.n()).done;

                        ) {
                          var file = _step10.value
                          file.processing = true // Backwards compatibility

                          file.status = Dropzone.UPLOADING
                          this.emit('processing', file)
                        }
                      } catch (err) {
                        _iterator10.e(err)
                      } finally {
                        _iterator10.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('processingmultiple', files)
                      }

                      return this.uploadFiles(files)
                    }
                  },
                  {
                    key: '_getFilesWithXhr',
                    value: function _getFilesWithXhr(xhr) {
                      var files
                      return (files = this.files
                        .filter(function (file) {
                          return file.xhr === xhr
                        })
                        .map(function (file) {
                          return file
                        }))
                    } // Cancels the file upload and sets the status to CANCELED
                    // **if** the file is actually being uploaded.
                    // If it's still in the queue, the file is being removed from it and the status
                    // set to CANCELED.
                  },
                  {
                    key: 'cancelUpload',
                    value: function cancelUpload(file) {
                      if (file.status === Dropzone.UPLOADING) {
                        var groupedFiles = this._getFilesWithXhr(file.xhr)

                        var _iterator11 = dropzone_createForOfIteratorHelper(
                            groupedFiles,
                            true
                          ),
                          _step11

                        try {
                          for (
                            _iterator11.s();
                            !(_step11 = _iterator11.n()).done;

                          ) {
                            var groupedFile = _step11.value
                            groupedFile.status = Dropzone.CANCELED
                          }
                        } catch (err) {
                          _iterator11.e(err)
                        } finally {
                          _iterator11.f()
                        }

                        if (typeof file.xhr !== 'undefined') {
                          file.xhr.abort()
                        }

                        var _iterator12 = dropzone_createForOfIteratorHelper(
                            groupedFiles,
                            true
                          ),
                          _step12

                        try {
                          for (
                            _iterator12.s();
                            !(_step12 = _iterator12.n()).done;

                          ) {
                            var _groupedFile = _step12.value
                            this.emit('canceled', _groupedFile)
                          }
                        } catch (err) {
                          _iterator12.e(err)
                        } finally {
                          _iterator12.f()
                        }

                        if (this.options.uploadMultiple) {
                          this.emit('canceledmultiple', groupedFiles)
                        }
                      } else if (
                        file.status === Dropzone.ADDED ||
                        file.status === Dropzone.QUEUED
                      ) {
                        file.status = Dropzone.CANCELED
                        this.emit('canceled', file)

                        if (this.options.uploadMultiple) {
                          this.emit('canceledmultiple', [file])
                        }
                      }

                      if (this.options.autoProcessQueue) {
                        return this.processQueue()
                      }
                    }
                  },
                  {
                    key: 'resolveOption',
                    value: function resolveOption(option) {
                      if (typeof option === 'function') {
                        for (
                          var _len = arguments.length,
                            args = new Array(_len > 1 ? _len - 1 : 0),
                            _key = 1;
                          _key < _len;
                          _key++
                        ) {
                          args[_key - 1] = arguments[_key]
                        }

                        return option.apply(this, args)
                      }

                      return option
                    }
                  },
                  {
                    key: 'uploadFile',
                    value: function uploadFile(file) {
                      return this.uploadFiles([file])
                    }
                  },
                  {
                    key: 'uploadFiles',
                    value: function uploadFiles(files) {
                      var _this14 = this

                      this._transformFiles(files, function (transformedFiles) {
                        if (_this14.options.chunking) {
                          // Chunking is not allowed to be used with `uploadMultiple` so we know
                          // that there is only __one__file.
                          var transformedFile = transformedFiles[0]
                          files[0].upload.chunked =
                            _this14.options.chunking &&
                            (_this14.options.forceChunking ||
                              transformedFile.size > _this14.options.chunkSize)
                          files[0].upload.totalChunkCount = Math.ceil(
                            transformedFile.size / _this14.options.chunkSize
                          )
                        }

                        if (files[0].upload.chunked) {
                          // This file should be sent in chunks!
                          // If the chunking option is set, we **know** that there can only be **one** file, since
                          // uploadMultiple is not allowed with this option.
                          var file = files[0]
                          var _transformedFile = transformedFiles[0]
                          var startedChunkCount = 0
                          file.upload.chunks = []

                          var handleNextChunk = function handleNextChunk() {
                            var chunkIndex = 0 // Find the next item in file.upload.chunks that is not defined yet.

                            while (
                              file.upload.chunks[chunkIndex] !== undefined
                            ) {
                              chunkIndex++
                            } // This means, that all chunks have already been started.

                            if (chunkIndex >= file.upload.totalChunkCount)
                              return
                            startedChunkCount++
                            var start = chunkIndex * _this14.options.chunkSize
                            var end = Math.min(
                              start + _this14.options.chunkSize,
                              _transformedFile.size
                            )
                            var dataBlock = {
                              name: _this14._getParamName(0),
                              data: _transformedFile.webkitSlice
                                ? _transformedFile.webkitSlice(start, end)
                                : _transformedFile.slice(start, end),
                              filename: file.upload.filename,
                              chunkIndex: chunkIndex
                            }
                            file.upload.chunks[chunkIndex] = {
                              file: file,
                              index: chunkIndex,
                              dataBlock: dataBlock,
                              // In case we want to retry.
                              status: Dropzone.UPLOADING,
                              progress: 0,
                              retries: 0 // The number of times this block has been retried.
                            }

                            _this14._uploadData(files, [dataBlock])
                          }

                          file.upload.finishedChunkUpload = function (
                            chunk,
                            response
                          ) {
                            var allFinished = true
                            chunk.status = Dropzone.SUCCESS // Clear the data from the chunk

                            chunk.dataBlock = null // Leaving this reference to xhr intact here will cause memory leaks in some browsers

                            chunk.xhr = null

                            for (
                              var i = 0;
                              i < file.upload.totalChunkCount;
                              i++
                            ) {
                              if (file.upload.chunks[i] === undefined) {
                                return handleNextChunk()
                              }

                              if (
                                file.upload.chunks[i].status !==
                                Dropzone.SUCCESS
                              ) {
                                allFinished = false
                              }
                            }

                            if (allFinished) {
                              _this14.options.chunksUploaded(file, function () {
                                _this14._finished(files, response, null)
                              })
                            }
                          }

                          if (_this14.options.parallelChunkUploads) {
                            for (
                              var i = 0;
                              i < file.upload.totalChunkCount;
                              i++
                            ) {
                              handleNextChunk()
                            }
                          } else {
                            handleNextChunk()
                          }
                        } else {
                          var dataBlocks = []

                          for (var _i2 = 0; _i2 < files.length; _i2++) {
                            dataBlocks[_i2] = {
                              name: _this14._getParamName(_i2),
                              data: transformedFiles[_i2],
                              filename: files[_i2].upload.filename
                            }
                          }

                          _this14._uploadData(files, dataBlocks)
                        }
                      })
                    } /// Returns the right chunk for given file and xhr
                  },
                  {
                    key: '_getChunk',
                    value: function _getChunk(file, xhr) {
                      for (var i = 0; i < file.upload.totalChunkCount; i++) {
                        if (
                          file.upload.chunks[i] !== undefined &&
                          file.upload.chunks[i].xhr === xhr
                        ) {
                          return file.upload.chunks[i]
                        }
                      }
                    } // This function actually uploads the file(s) to the server.
                    // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed
                    // files, or individual chunks for chunked upload).
                  },
                  {
                    key: '_uploadData',
                    value: function _uploadData(files, dataBlocks) {
                      var _this15 = this

                      var xhr = new XMLHttpRequest() // Put the xhr object in the file objects to be able to reference it later.

                      var _iterator13 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step13

                      try {
                        for (
                          _iterator13.s();
                          !(_step13 = _iterator13.n()).done;

                        ) {
                          var file = _step13.value
                          file.xhr = xhr
                        }
                      } catch (err) {
                        _iterator13.e(err)
                      } finally {
                        _iterator13.f()
                      }

                      if (files[0].upload.chunked) {
                        // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk
                        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr =
                          xhr
                      }

                      var method = this.resolveOption(
                        this.options.method,
                        files
                      )
                      var url = this.resolveOption(this.options.url, files)
                      xhr.open(method, url, true) // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8

                      var timeout = this.resolveOption(
                        this.options.timeout,
                        files
                      )
                      if (timeout)
                        xhr.timeout = this.resolveOption(
                          this.options.timeout,
                          files
                        ) // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179

                      xhr.withCredentials = !!this.options.withCredentials

                      xhr.onload = function (e) {
                        _this15._finishedUploading(files, xhr, e)
                      }

                      xhr.ontimeout = function () {
                        _this15._handleUploadError(
                          files,
                          xhr,
                          'Request timedout after '.concat(
                            _this15.options.timeout / 1000,
                            ' seconds'
                          )
                        )
                      }

                      xhr.onerror = function () {
                        _this15._handleUploadError(files, xhr)
                      } // Some browsers do not have the .upload property

                      var progressObj = xhr.upload != null ? xhr.upload : xhr

                      progressObj.onprogress = function (e) {
                        return _this15._updateFilesUploadProgress(files, xhr, e)
                      }

                      var headers = {
                        Accept: 'application/json',
                        'Cache-Control': 'no-cache',
                        'X-Requested-With': 'XMLHttpRequest'
                      }

                      if (this.options.headers) {
                        Dropzone.extend(headers, this.options.headers)
                      }

                      for (var headerName in headers) {
                        var headerValue = headers[headerName]

                        if (headerValue) {
                          xhr.setRequestHeader(headerName, headerValue)
                        }
                      }

                      var formData = new FormData() // Adding all @options parameters

                      if (this.options.params) {
                        var additionalParams = this.options.params

                        if (typeof additionalParams === 'function') {
                          additionalParams = additionalParams.call(
                            this,
                            files,
                            xhr,
                            files[0].upload.chunked
                              ? this._getChunk(files[0], xhr)
                              : null
                          )
                        }

                        for (var key in additionalParams) {
                          var value = additionalParams[key]

                          if (Array.isArray(value)) {
                            // The additional parameter contains an array,
                            // so lets iterate over it to attach each value
                            // individually.
                            for (var i = 0; i < value.length; i++) {
                              formData.append(key, value[i])
                            }
                          } else {
                            formData.append(key, value)
                          }
                        }
                      } // Let the user add additional data if necessary

                      var _iterator14 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step14

                      try {
                        for (
                          _iterator14.s();
                          !(_step14 = _iterator14.n()).done;

                        ) {
                          var _file = _step14.value
                          this.emit('sending', _file, xhr, formData)
                        }
                      } catch (err) {
                        _iterator14.e(err)
                      } finally {
                        _iterator14.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('sendingmultiple', files, xhr, formData)
                      }

                      this._addFormElementData(formData) // Finally add the files
                      // Has to be last because some servers (eg: S3) expect the file to be the last parameter

                      for (var _i3 = 0; _i3 < dataBlocks.length; _i3++) {
                        var dataBlock = dataBlocks[_i3]
                        formData.append(
                          dataBlock.name,
                          dataBlock.data,
                          dataBlock.filename
                        )
                      }

                      this.submitRequest(xhr, formData, files)
                    } // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
                  },
                  {
                    key: '_transformFiles',
                    value: function _transformFiles(files, done) {
                      var _this16 = this

                      var transformedFiles = [] // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.

                      var doneCounter = 0

                      var _loop = function _loop(i) {
                        _this16.options.transformFile.call(
                          _this16,
                          files[i],
                          function (transformedFile) {
                            transformedFiles[i] = transformedFile

                            if (++doneCounter === files.length) {
                              done(transformedFiles)
                            }
                          }
                        )
                      }

                      for (var i = 0; i < files.length; i++) {
                        _loop(i)
                      }
                    } // Takes care of adding other input elements of the form to the AJAX request
                  },
                  {
                    key: '_addFormElementData',
                    value: function _addFormElementData(formData) {
                      // Take care of other input elements
                      if (this.element.tagName === 'FORM') {
                        var _iterator15 = dropzone_createForOfIteratorHelper(
                            this.element.querySelectorAll(
                              'input, textarea, select, button'
                            ),
                            true
                          ),
                          _step15

                        try {
                          for (
                            _iterator15.s();
                            !(_step15 = _iterator15.n()).done;

                          ) {
                            var input = _step15.value
                            var inputName = input.getAttribute('name')
                            var inputType = input.getAttribute('type')
                            if (inputType) inputType = inputType.toLowerCase() // If the input doesn't have a name, we can't use it.

                            if (
                              typeof inputName === 'undefined' ||
                              inputName === null
                            )
                              continue

                            if (
                              input.tagName === 'SELECT' &&
                              input.hasAttribute('multiple')
                            ) {
                              // Possibly multiple values
                              var _iterator16 =
                                  dropzone_createForOfIteratorHelper(
                                    input.options,
                                    true
                                  ),
                                _step16

                              try {
                                for (
                                  _iterator16.s();
                                  !(_step16 = _iterator16.n()).done;

                                ) {
                                  var option = _step16.value

                                  if (option.selected) {
                                    formData.append(inputName, option.value)
                                  }
                                }
                              } catch (err) {
                                _iterator16.e(err)
                              } finally {
                                _iterator16.f()
                              }
                            } else if (
                              !inputType ||
                              (inputType !== 'checkbox' &&
                                inputType !== 'radio') ||
                              input.checked
                            ) {
                              formData.append(inputName, input.value)
                            }
                          }
                        } catch (err) {
                          _iterator15.e(err)
                        } finally {
                          _iterator15.f()
                        }
                      }
                    } // Invoked when there is new progress information about given files.
                    // If e is not provided, it is assumed that the upload is finished.
                  },
                  {
                    key: '_updateFilesUploadProgress',
                    value: function _updateFilesUploadProgress(files, xhr, e) {
                      if (!files[0].upload.chunked) {
                        // Handle file uploads without chunking
                        var _iterator17 = dropzone_createForOfIteratorHelper(
                            files,
                            true
                          ),
                          _step17

                        try {
                          for (
                            _iterator17.s();
                            !(_step17 = _iterator17.n()).done;

                          ) {
                            var file = _step17.value

                            if (
                              file.upload.total &&
                              file.upload.bytesSent &&
                              file.upload.bytesSent == file.upload.total
                            ) {
                              // If both, the `total` and `bytesSent` have already been set, and
                              // they are equal (meaning progress is at 100%), we can skip this
                              // file, since an upload progress shouldn't go down.
                              continue
                            }

                            if (e) {
                              file.upload.progress = (100 * e.loaded) / e.total
                              file.upload.total = e.total
                              file.upload.bytesSent = e.loaded
                            } else {
                              // No event, so we're at 100%
                              file.upload.progress = 100
                              file.upload.bytesSent = file.upload.total
                            }

                            this.emit(
                              'uploadprogress',
                              file,
                              file.upload.progress,
                              file.upload.bytesSent
                            )
                          }
                        } catch (err) {
                          _iterator17.e(err)
                        } finally {
                          _iterator17.f()
                        }
                      } else {
                        // Handle chunked file uploads
                        // Chunked upload is not compatible with uploading multiple files in one
                        // request, so we know there's only one file.
                        var _file2 = files[0] // Since this is a chunked upload, we need to update the appropriate chunk
                        // progress.

                        var chunk = this._getChunk(_file2, xhr)

                        if (e) {
                          chunk.progress = (100 * e.loaded) / e.total
                          chunk.total = e.total
                          chunk.bytesSent = e.loaded
                        } else {
                          // No event, so we're at 100%
                          chunk.progress = 100
                          chunk.bytesSent = chunk.total
                        } // Now tally the *file* upload progress from its individual chunks

                        _file2.upload.progress = 0
                        _file2.upload.total = 0
                        _file2.upload.bytesSent = 0

                        for (
                          var i = 0;
                          i < _file2.upload.totalChunkCount;
                          i++
                        ) {
                          if (
                            _file2.upload.chunks[i] &&
                            typeof _file2.upload.chunks[i].progress !==
                              'undefined'
                          ) {
                            _file2.upload.progress +=
                              _file2.upload.chunks[i].progress
                            _file2.upload.total += _file2.upload.chunks[i].total
                            _file2.upload.bytesSent +=
                              _file2.upload.chunks[i].bytesSent
                          }
                        } // Since the process is a percentage, we need to divide by the amount of
                        // chunks we've used.

                        _file2.upload.progress =
                          _file2.upload.progress / _file2.upload.totalChunkCount
                        this.emit(
                          'uploadprogress',
                          _file2,
                          _file2.upload.progress,
                          _file2.upload.bytesSent
                        )
                      }
                    }
                  },
                  {
                    key: '_finishedUploading',
                    value: function _finishedUploading(files, xhr, e) {
                      var response

                      if (files[0].status === Dropzone.CANCELED) {
                        return
                      }

                      if (xhr.readyState !== 4) {
                        return
                      }

                      if (
                        xhr.responseType !== 'arraybuffer' &&
                        xhr.responseType !== 'blob'
                      ) {
                        response = xhr.responseText

                        if (
                          xhr.getResponseHeader('content-type') &&
                          ~xhr
                            .getResponseHeader('content-type')
                            .indexOf('application/json')
                        ) {
                          try {
                            response = JSON.parse(response)
                          } catch (error) {
                            e = error
                            response = 'Invalid JSON response from server.'
                          }
                        }
                      }

                      this._updateFilesUploadProgress(files, xhr)

                      if (!(200 <= xhr.status && xhr.status < 300)) {
                        this._handleUploadError(files, xhr, response)
                      } else {
                        if (files[0].upload.chunked) {
                          files[0].upload.finishedChunkUpload(
                            this._getChunk(files[0], xhr),
                            response
                          )
                        } else {
                          this._finished(files, response, e)
                        }
                      }
                    }
                  },
                  {
                    key: '_handleUploadError',
                    value: function _handleUploadError(files, xhr, response) {
                      if (files[0].status === Dropzone.CANCELED) {
                        return
                      }

                      if (files[0].upload.chunked && this.options.retryChunks) {
                        var chunk = this._getChunk(files[0], xhr)

                        if (chunk.retries++ < this.options.retryChunksLimit) {
                          this._uploadData(files, [chunk.dataBlock])

                          return
                        } else {
                          console.warn(
                            'Retried this chunk too often. Giving up.'
                          )
                        }
                      }

                      this._errorProcessing(
                        files,
                        response ||
                          this.options.dictResponseError.replace(
                            '{{statusCode}}',
                            xhr.status
                          ),
                        xhr
                      )
                    }
                  },
                  {
                    key: 'submitRequest',
                    value: function submitRequest(xhr, formData, files) {
                      if (xhr.readyState != 1) {
                        console.warn(
                          'Cannot send this request because the XMLHttpRequest.readyState is not OPENED.'
                        )
                        return
                      }

                      xhr.send(formData)
                    } // Called internally when processing is finished.
                    // Individual callbacks have to be called in the appropriate sections.
                  },
                  {
                    key: '_finished',
                    value: function _finished(files, responseText, e) {
                      var _iterator18 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step18

                      try {
                        for (
                          _iterator18.s();
                          !(_step18 = _iterator18.n()).done;

                        ) {
                          var file = _step18.value
                          file.status = Dropzone.SUCCESS
                          this.emit('success', file, responseText, e)
                          this.emit('complete', file)
                        }
                      } catch (err) {
                        _iterator18.e(err)
                      } finally {
                        _iterator18.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('successmultiple', files, responseText, e)
                        this.emit('completemultiple', files)
                      }

                      if (this.options.autoProcessQueue) {
                        return this.processQueue()
                      }
                    } // Called internally when processing is finished.
                    // Individual callbacks have to be called in the appropriate sections.
                  },
                  {
                    key: '_errorProcessing',
                    value: function _errorProcessing(files, message, xhr) {
                      var _iterator19 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step19

                      try {
                        for (
                          _iterator19.s();
                          !(_step19 = _iterator19.n()).done;

                        ) {
                          var file = _step19.value
                          file.status = Dropzone.ERROR
                          this.emit('error', file, message, xhr)
                          this.emit('complete', file)
                        }
                      } catch (err) {
                        _iterator19.e(err)
                      } finally {
                        _iterator19.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('errormultiple', files, message, xhr)
                        this.emit('completemultiple', files)
                      }

                      if (this.options.autoProcessQueue) {
                        return this.processQueue()
                      }
                    }
                  }
                ],
                [
                  {
                    key: 'initClass',
                    value: function initClass() {
                      // Exposing the emitter class, mainly for tests
                      this.prototype.Emitter = Emitter
                      /*
       This is a list of all available events you can register on a dropzone object.
        You can register an event handler like this:
        dropzone.on("dragEnter", function() { });
        */

                      this.prototype.events = [
                        'drop',
                        'dragstart',
                        'dragend',
                        'dragenter',
                        'dragover',
                        'dragleave',
                        'addedfile',
                        'addedfiles',
                        'removedfile',
                        'thumbnail',
                        'error',
                        'errormultiple',
                        'processing',
                        'processingmultiple',
                        'uploadprogress',
                        'totaluploadprogress',
                        'sending',
                        'sendingmultiple',
                        'success',
                        'successmultiple',
                        'canceled',
                        'canceledmultiple',
                        'complete',
                        'completemultiple',
                        'reset',
                        'maxfilesexceeded',
                        'maxfilesreached',
                        'queuecomplete'
                      ]
                      this.prototype._thumbnailQueue = []
                      this.prototype._processingThumbnail = false
                    } // global utility
                  },
                  {
                    key: 'extend',
                    value: function extend(target) {
                      for (
                        var _len2 = arguments.length,
                          objects = new Array(_len2 > 1 ? _len2 - 1 : 0),
                          _key2 = 1;
                        _key2 < _len2;
                        _key2++
                      ) {
                        objects[_key2 - 1] = arguments[_key2]
                      }

                      for (
                        var _i4 = 0, _objects = objects;
                        _i4 < _objects.length;
                        _i4++
                      ) {
                        var object = _objects[_i4]

                        for (var key in object) {
                          var val = object[key]
                          target[key] = val
                        }
                      }

                      return target
                    }
                  },
                  {
                    key: 'uuidv4',
                    value: function uuidv4() {
                      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
                        /[xy]/g,
                        function (c) {
                          var r = (Math.random() * 16) | 0,
                            v = c === 'x' ? r : (r & 0x3) | 0x8
                          return v.toString(16)
                        }
                      )
                    }
                  }
                ]
              )

              return Dropzone
            })(Emitter)

            Dropzone.initClass()
            Dropzone.version = '5.9.3' // This is a map of options for your different dropzones. Add configurations
            // to this object for your different dropzone elemens.
            //
            // Example:
            //
            //     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
            //
            // To disable autoDiscover for a specific element, you can set `false` as an option:
            //
            //     Dropzone.options.myDisabledElementId = false;
            //
            // And in html:
            //
            //     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>

            Dropzone.options = {} // Returns the options for an element or undefined if none available.

            Dropzone.optionsForElement = function (element) {
              // Get the `Dropzone.options.elementId` for this element if it exists
              if (element.getAttribute('id')) {
                return Dropzone.options[camelize(element.getAttribute('id'))]
              } else {
                return undefined
              }
            } // Holds a list of all dropzone instances

            Dropzone.instances = [] // Returns the dropzone for given element if any

            Dropzone.forElement = function (element) {
              if (typeof element === 'string') {
                element = document.querySelector(element)
              }

              if ((element != null ? element.dropzone : undefined) == null) {
                throw new Error(
                  "No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone."
                )
              }

              return element.dropzone
            } // Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.

            Dropzone.autoDiscover = true // Looks for all .dropzone elements and creates a dropzone for them

            Dropzone.discover = function () {
              var dropzones

              if (document.querySelectorAll) {
                dropzones = document.querySelectorAll('.dropzone')
              } else {
                dropzones = [] // IE :(

                var checkElements = function checkElements(elements) {
                  return (function () {
                    var result = []

                    var _iterator20 = dropzone_createForOfIteratorHelper(
                        elements,
                        true
                      ),
                      _step20

                    try {
                      for (
                        _iterator20.s();
                        !(_step20 = _iterator20.n()).done;

                      ) {
                        var el = _step20.value

                        if (/(^| )dropzone($| )/.test(el.className)) {
                          result.push(dropzones.push(el))
                        } else {
                          result.push(undefined)
                        }
                      }
                    } catch (err) {
                      _iterator20.e(err)
                    } finally {
                      _iterator20.f()
                    }

                    return result
                  })()
                }

                checkElements(document.getElementsByTagName('div'))
                checkElements(document.getElementsByTagName('form'))
              }

              return (function () {
                var result = []

                var _iterator21 = dropzone_createForOfIteratorHelper(
                    dropzones,
                    true
                  ),
                  _step21

                try {
                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done; ) {
                    var dropzone = _step21.value

                    // Create a dropzone unless auto discover has been disabled for specific element
                    if (Dropzone.optionsForElement(dropzone) !== false) {
                      result.push(new Dropzone(dropzone))
                    } else {
                      result.push(undefined)
                    }
                  }
                } catch (err) {
                  _iterator21.e(err)
                } finally {
                  _iterator21.f()
                }

                return result
              })()
            } // Some browsers support drag and drog functionality, but not correctly.
            //
            // So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.
            // But what to do when browsers *theoretically* support an API, but crash
            // when using it.
            //
            // This is a list of regular expressions tested against navigator.userAgent
            //
            // ** It should only be used on browser that *do* support the API, but
            // incorrectly **

            Dropzone.blockedBrowsers = [
              // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
              /opera.*(Macintosh|Windows Phone).*version\/12/i
            ] // Checks if the browser is supported

            Dropzone.isBrowserSupported = function () {
              var capableBrowser = true

              if (
                window.File &&
                window.FileReader &&
                window.FileList &&
                window.Blob &&
                window.FormData &&
                document.querySelector
              ) {
                if (!('classList' in document.createElement('a'))) {
                  capableBrowser = false
                } else {
                  if (Dropzone.blacklistedBrowsers !== undefined) {
                    // Since this has been renamed, this makes sure we don't break older
                    // configuration.
                    Dropzone.blockedBrowsers = Dropzone.blacklistedBrowsers
                  } // The browser supports the API, but may be blocked.

                  var _iterator22 = dropzone_createForOfIteratorHelper(
                      Dropzone.blockedBrowsers,
                      true
                    ),
                    _step22

                  try {
                    for (_iterator22.s(); !(_step22 = _iterator22.n()).done; ) {
                      var regex = _step22.value

                      if (regex.test(navigator.userAgent)) {
                        capableBrowser = false
                        continue
                      }
                    }
                  } catch (err) {
                    _iterator22.e(err)
                  } finally {
                    _iterator22.f()
                  }
                }
              } else {
                capableBrowser = false
              }

              return capableBrowser
            }

            Dropzone.dataURItoBlob = function (dataURI) {
              // convert base64 to raw binary data held in a string
              // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
              var byteString = atob(dataURI.split(',')[1]) // separate out the mime component

              var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0] // write the bytes of the string to an ArrayBuffer

              var ab = new ArrayBuffer(byteString.length)
              var ia = new Uint8Array(ab)

              for (
                var i = 0, end = byteString.length, asc = 0 <= end;
                asc ? i <= end : i >= end;
                asc ? i++ : i--
              ) {
                ia[i] = byteString.charCodeAt(i)
              } // write the ArrayBuffer to a blob

              return new Blob([ab], {
                type: mimeString
              })
            } // Returns an array without the rejected item

            var without = function without(list, rejectedItem) {
              return list
                .filter(function (item) {
                  return item !== rejectedItem
                })
                .map(function (item) {
                  return item
                })
            } // abc-def_ghi -> abcDefGhi

            var camelize = function camelize(str) {
              return str.replace(/[\-_](\w)/g, function (match) {
                return match.charAt(1).toUpperCase()
              })
            } // Creates an element from string

            Dropzone.createElement = function (string) {
              var div = document.createElement('div')
              div.innerHTML = string
              return div.childNodes[0]
            } // Tests if given element is inside (or simply is) the container

            Dropzone.elementInside = function (element, container) {
              if (element === container) {
                return true
              } // Coffeescript doesn't support do/while loops

              while ((element = element.parentNode)) {
                if (element === container) {
                  return true
                }
              }

              return false
            }

            Dropzone.getElement = function (el, name) {
              var element

              if (typeof el === 'string') {
                element = document.querySelector(el)
              } else if (el.nodeType != null) {
                element = el
              }

              if (element == null) {
                throw new Error(
                  'Invalid `'.concat(
                    name,
                    '` option provided. Please provide a CSS selector or a plain HTML element.'
                  )
                )
              }

              return element
            }

            Dropzone.getElements = function (els, name) {
              var el, elements

              if (els instanceof Array) {
                elements = []

                try {
                  var _iterator23 = dropzone_createForOfIteratorHelper(
                      els,
                      true
                    ),
                    _step23

                  try {
                    for (_iterator23.s(); !(_step23 = _iterator23.n()).done; ) {
                      el = _step23.value
                      elements.push(this.getElement(el, name))
                    }
                  } catch (err) {
                    _iterator23.e(err)
                  } finally {
                    _iterator23.f()
                  }
                } catch (e) {
                  elements = null
                }
              } else if (typeof els === 'string') {
                elements = []

                var _iterator24 = dropzone_createForOfIteratorHelper(
                    document.querySelectorAll(els),
                    true
                  ),
                  _step24

                try {
                  for (_iterator24.s(); !(_step24 = _iterator24.n()).done; ) {
                    el = _step24.value
                    elements.push(el)
                  }
                } catch (err) {
                  _iterator24.e(err)
                } finally {
                  _iterator24.f()
                }
              } else if (els.nodeType != null) {
                elements = [els]
              }

              if (elements == null || !elements.length) {
                throw new Error(
                  'Invalid `'.concat(
                    name,
                    '` option provided. Please provide a CSS selector, a plain HTML element or a list of those.'
                  )
                )
              }

              return elements
            } // Asks the user the question and calls accepted or rejected accordingly
            //
            // The default implementation just uses `window.confirm` and then calls the
            // appropriate callback.

            Dropzone.confirm = function (question, accepted, rejected) {
              if (window.confirm(question)) {
                return accepted()
              } else if (rejected != null) {
                return rejected()
              }
            } // Validates the mime type like this:
            //
            // https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept

            Dropzone.isValidFile = function (file, acceptedFiles) {
              if (!acceptedFiles) {
                return true
              } // If there are no accepted mime types, it's OK

              acceptedFiles = acceptedFiles.split(',')
              var mimeType = file.type
              var baseMimeType = mimeType.replace(/\/.*$/, '')

              var _iterator25 = dropzone_createForOfIteratorHelper(
                  acceptedFiles,
                  true
                ),
                _step25

              try {
                for (_iterator25.s(); !(_step25 = _iterator25.n()).done; ) {
                  var validType = _step25.value
                  validType = validType.trim()

                  if (validType.charAt(0) === '.') {
                    if (
                      file.name
                        .toLowerCase()
                        .indexOf(
                          validType.toLowerCase(),
                          file.name.length - validType.length
                        ) !== -1
                    ) {
                      return true
                    }
                  } else if (/\/\*$/.test(validType)) {
                    // This is something like a image/* mime type
                    if (baseMimeType === validType.replace(/\/.*$/, '')) {
                      return true
                    }
                  } else {
                    if (mimeType === validType) {
                      return true
                    }
                  }
                }
              } catch (err) {
                _iterator25.e(err)
              } finally {
                _iterator25.f()
              }

              return false
            } // Augment jQuery

            if (typeof jQuery !== 'undefined' && jQuery !== null) {
              jQuery.fn.dropzone = function (options) {
                return this.each(function () {
                  return new Dropzone(this, options)
                })
              }
            } // Dropzone file status codes

            Dropzone.ADDED = 'added'
            Dropzone.QUEUED = 'queued' // For backwards compatibility. Now, if a file is accepted, it's either queued
            // or uploading.

            Dropzone.ACCEPTED = Dropzone.QUEUED
            Dropzone.UPLOADING = 'uploading'
            Dropzone.PROCESSING = Dropzone.UPLOADING // alias

            Dropzone.CANCELED = 'canceled'
            Dropzone.ERROR = 'error'
            Dropzone.SUCCESS = 'success'
            /*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */
            // Detecting vertical squash in loaded image.
            // Fixes a bug which squash image vertically while drawing into canvas for some images.
            // This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel

            var detectVerticalSquash = function detectVerticalSquash(img) {
              var iw = img.naturalWidth
              var ih = img.naturalHeight
              var canvas = document.createElement('canvas')
              canvas.width = 1
              canvas.height = ih
              var ctx = canvas.getContext('2d')
              ctx.drawImage(img, 0, 0)

              var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),
                data = _ctx$getImageData.data // search image edge pixel position in case it is squashed vertically.

              var sy = 0
              var ey = ih
              var py = ih

              while (py > sy) {
                var alpha = data[(py - 1) * 4 + 3]

                if (alpha === 0) {
                  ey = py
                } else {
                  sy = py
                }

                py = (ey + sy) >> 1
              }

              var ratio = py / ih

              if (ratio === 0) {
                return 1
              } else {
                return ratio
              }
            } // A replacement for context.drawImage
            // (args are for source and destination).

            var drawImageIOSFix = function drawImageIOSFix(
              ctx,
              img,
              sx,
              sy,
              sw,
              sh,
              dx,
              dy,
              dw,
              dh
            ) {
              var vertSquashRatio = detectVerticalSquash(img)
              return ctx.drawImage(
                img,
                sx,
                sy,
                sw,
                sh,
                dx,
                dy,
                dw,
                dh / vertSquashRatio
              )
            } // Based on MinifyJpeg
            // Source: http://www.perry.cz/files/ExifRestorer.js
            // http://elicon.blog57.fc2.com/blog-entry-206.html

            var ExifRestore = /*#__PURE__*/ (function () {
              function ExifRestore() {
                dropzone_classCallCheck(this, ExifRestore)
              }

              dropzone_createClass(ExifRestore, null, [
                {
                  key: 'initClass',
                  value: function initClass() {
                    this.KEY_STR =
                      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
                  }
                },
                {
                  key: 'encode64',
                  value: function encode64(input) {
                    var output = ''
                    var chr1 = undefined
                    var chr2 = undefined
                    var chr3 = ''
                    var enc1 = undefined
                    var enc2 = undefined
                    var enc3 = undefined
                    var enc4 = ''
                    var i = 0

                    while (true) {
                      chr1 = input[i++]
                      chr2 = input[i++]
                      chr3 = input[i++]
                      enc1 = chr1 >> 2
                      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4)
                      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6)
                      enc4 = chr3 & 63

                      if (isNaN(chr2)) {
                        enc3 = enc4 = 64
                      } else if (isNaN(chr3)) {
                        enc4 = 64
                      }

                      output =
                        output +
                        this.KEY_STR.charAt(enc1) +
                        this.KEY_STR.charAt(enc2) +
                        this.KEY_STR.charAt(enc3) +
                        this.KEY_STR.charAt(enc4)
                      chr1 = chr2 = chr3 = ''
                      enc1 = enc2 = enc3 = enc4 = ''

                      if (!(i < input.length)) {
                        break
                      }
                    }

                    return output
                  }
                },
                {
                  key: 'restore',
                  value: function restore(origFileBase64, resizedFileBase64) {
                    if (!origFileBase64.match('data:image/jpeg;base64,')) {
                      return resizedFileBase64
                    }

                    var rawImage = this.decode64(
                      origFileBase64.replace('data:image/jpeg;base64,', '')
                    )
                    var segments = this.slice2Segments(rawImage)
                    var image = this.exifManipulation(
                      resizedFileBase64,
                      segments
                    )
                    return 'data:image/jpeg;base64,'.concat(
                      this.encode64(image)
                    )
                  }
                },
                {
                  key: 'exifManipulation',
                  value: function exifManipulation(
                    resizedFileBase64,
                    segments
                  ) {
                    var exifArray = this.getExifArray(segments)
                    var newImageArray = this.insertExif(
                      resizedFileBase64,
                      exifArray
                    )
                    var aBuffer = new Uint8Array(newImageArray)
                    return aBuffer
                  }
                },
                {
                  key: 'getExifArray',
                  value: function getExifArray(segments) {
                    var seg = undefined
                    var x = 0

                    while (x < segments.length) {
                      seg = segments[x]

                      if ((seg[0] === 255) & (seg[1] === 225)) {
                        return seg
                      }

                      x++
                    }

                    return []
                  }
                },
                {
                  key: 'insertExif',
                  value: function insertExif(resizedFileBase64, exifArray) {
                    var imageData = resizedFileBase64.replace(
                      'data:image/jpeg;base64,',
                      ''
                    )
                    var buf = this.decode64(imageData)
                    var separatePoint = buf.indexOf(255, 3)
                    var mae = buf.slice(0, separatePoint)
                    var ato = buf.slice(separatePoint)
                    var array = mae
                    array = array.concat(exifArray)
                    array = array.concat(ato)
                    return array
                  }
                },
                {
                  key: 'slice2Segments',
                  value: function slice2Segments(rawImageArray) {
                    var head = 0
                    var segments = []

                    while (true) {
                      var length

                      if (
                        (rawImageArray[head] === 255) &
                        (rawImageArray[head + 1] === 218)
                      ) {
                        break
                      }

                      if (
                        (rawImageArray[head] === 255) &
                        (rawImageArray[head + 1] === 216)
                      ) {
                        head += 2
                      } else {
                        length =
                          rawImageArray[head + 2] * 256 +
                          rawImageArray[head + 3]
                        var endPoint = head + length + 2
                        var seg = rawImageArray.slice(head, endPoint)
                        segments.push(seg)
                        head = endPoint
                      }

                      if (head > rawImageArray.length) {
                        break
                      }
                    }

                    return segments
                  }
                },
                {
                  key: 'decode64',
                  value: function decode64(input) {
                    var output = ''
                    var chr1 = undefined
                    var chr2 = undefined
                    var chr3 = ''
                    var enc1 = undefined
                    var enc2 = undefined
                    var enc3 = undefined
                    var enc4 = ''
                    var i = 0
                    var buf = [] // remove all characters that are not A-Z, a-z, 0-9, +, /, or =

                    var base64test = /[^A-Za-z0-9\+\/\=]/g

                    if (base64test.exec(input)) {
                      console.warn(
                        "There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding."
                      )
                    }

                    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '')

                    while (true) {
                      enc1 = this.KEY_STR.indexOf(input.charAt(i++))
                      enc2 = this.KEY_STR.indexOf(input.charAt(i++))
                      enc3 = this.KEY_STR.indexOf(input.charAt(i++))
                      enc4 = this.KEY_STR.indexOf(input.charAt(i++))
                      chr1 = (enc1 << 2) | (enc2 >> 4)
                      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)
                      chr3 = ((enc3 & 3) << 6) | enc4
                      buf.push(chr1)

                      if (enc3 !== 64) {
                        buf.push(chr2)
                      }

                      if (enc4 !== 64) {
                        buf.push(chr3)
                      }

                      chr1 = chr2 = chr3 = ''
                      enc1 = enc2 = enc3 = enc4 = ''

                      if (!(i < input.length)) {
                        break
                      }
                    }

                    return buf
                  }
                }
              ])

              return ExifRestore
            })()

            ExifRestore.initClass()
            /*
             * contentloaded.js
             *
             * Author: Diego Perini (diego.perini at gmail.com)
             * Summary: cross-browser wrapper for DOMContentLoaded
             * Updated: 20101020
             * License: MIT
             * Version: 1.2
             *
             * URL:
             * http://javascript.nwbox.com/ContentLoaded/
             * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
             */
            // @win window reference
            // @fn function reference

            var contentLoaded = function contentLoaded(win, fn) {
              var done = false
              var top = true
              var doc = win.document
              var root = doc.documentElement
              var add = doc.addEventListener
                ? 'addEventListener'
                : 'attachEvent'
              var rem = doc.addEventListener
                ? 'removeEventListener'
                : 'detachEvent'
              var pre = doc.addEventListener ? '' : 'on'

              var init = function init(e) {
                if (
                  e.type === 'readystatechange' &&
                  doc.readyState !== 'complete'
                ) {
                  return
                }

                ;(e.type === 'load' ? win : doc)[rem](pre + e.type, init, false)

                if (!done && (done = true)) {
                  return fn.call(win, e.type || e)
                }
              }

              var poll = function poll() {
                try {
                  root.doScroll('left')
                } catch (e) {
                  setTimeout(poll, 50)
                  return
                }

                return init('poll')
              }

              if (doc.readyState !== 'complete') {
                if (doc.createEventObject && root.doScroll) {
                  try {
                    top = !win.frameElement
                  } catch (error) {}

                  if (top) {
                    poll()
                  }
                }

                doc[add](pre + 'DOMContentLoaded', init, false)
                doc[add](pre + 'readystatechange', init, false)
                return win[add](pre + 'load', init, false)
              }
            } // As a single function to be able to write tests.

            Dropzone._autoDiscoverFunction = function () {
              if (Dropzone.autoDiscover) {
                return Dropzone.discover()
              }
            }

            contentLoaded(window, Dropzone._autoDiscoverFunction)

            function __guard__(value, transform) {
              return typeof value !== 'undefined' && value !== null
                ? transform(value)
                : undefined
            }

            function __guardMethod__(obj, methodName, transform) {
              if (
                typeof obj !== 'undefined' &&
                obj !== null &&
                typeof obj[methodName] === 'function'
              ) {
                return transform(obj, methodName)
              } else {
                return undefined
              }
            } // CONCATENATED MODULE: ./tool/dropzone.dist.js

            /// Make Dropzone a global variable.

            window.Dropzone = Dropzone
            /* harmony default export */ var dropzone_dist = Dropzone
          })()
          /******/ return __webpack_exports__
          /******/
        })()
      })

      /***/
    },

    /***/ 4676: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      var Emitter = __webpack_require__(7187).EventEmitter

      function StateMachine(opts) {
        Emitter.call(this)

        opts = opts || {}
        this.states = opts.states || ['default']
        this.currentState = opts.defaultState || this.states[0]
        this.history = []
        this.configs = {}
        this.events = []

        var self = this
        this.on('transition', function (e) {
          self.events.forEach(function (condition) {
            if (condition.from === e.from && condition.to === e.to) {
              self.emit(condition.event)
            }
          })
        })
      }

      StateMachine.prototype = Object.create(Emitter.prototype)

      StateMachine.prototype.setState = function (to) {
        var from = this.currentState
        if (!this._validate(from, to)) {
          return false
        }

        this.history.push({
          state: from,
          args: this.currentArgs
        })

        var args = arguments.length > 1 ? [].slice.call(arguments, 1) : null

        this.currentArgs = args
        this.currentState = to
        this._emit(from, to, args)

        return true
      }

      StateMachine.prototype.back = function () {
        if (!this.history.length) {
          return false
        }

        var last = this.history[this.history.length - 1],
          from = this.currentState,
          to = last.state,
          args = last.args

        if (!this._validate(from, to)) {
          return false
        }

        this.history.pop()
        this.currentState = to
        this.currentArgs = args
        this._emit(from, to, args, true)

        return true
      }

      StateMachine.prototype.lock = function () {
        this.locked = true
      }

      StateMachine.prototype.unlock = function () {
        this.locked = false
      }

      StateMachine.prototype.config = function (state, options) {
        options.to = options.to || {}
        options.from = options.from || {}
        this.configs[state] = options
      }

      StateMachine.prototype.register = function (event, condition) {
        this.events.push({
          event: event,
          from: condition.from,
          to: condition.to
        })
      }

      StateMachine.prototype._emit = function (from, to, args, back) {
        var event = {
          from: from,
          to: to,
          args: args,
          back: back
        }

        this.emit('transition', event)
        this.emit('leave:' + from, event)
        this.emit('enter:' + to, event)
      }

      StateMachine.prototype._validate = function (from, to) {
        if (this.locked) return
        if (from === to) return
        if (this.states.indexOf(to) < 0) return

        var fromConf = this.configs[from]
        if (fromConf) {
          if (fromConf.to.only) {
            if (fromConf.to.only.indexOf(to) < 0) return
          } else if (fromConf.to.exclude) {
            if (fromConf.to.exclude.indexOf(to) > -1) return
          }
        }

        var toConf = this.configs[to]
        if (toConf) {
          if (toConf.from.only) {
            if (toConf.from.only.indexOf(from) < 0) return
          } else if (toConf.from.exclude) {
            if (toConf.from.exclude.indexOf(from) > -1) return
          }
        }

        return true
      }

      module.exports = StateMachine

      /***/
    },

    /***/ 4576: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      'use strict'

      var escape = __webpack_require__(8686)

      module.exports = function eskape(strs) {
        var out = strs[0]

        for (
          var _len = arguments.length,
            vals = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          vals[_key - 1] = arguments[_key]
        }

        for (var i = 0; i < vals.length; i++) {
          out = out + escape(vals[i]) + strs[i + 1]
        }

        return out
      }

      /***/
    },

    /***/ 7187: /***/ (module) => {
      'use strict'
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      var R = typeof Reflect === 'object' ? Reflect : null
      var ReflectApply =
        R && typeof R.apply === 'function'
          ? R.apply
          : function ReflectApply(target, receiver, args) {
              return Function.prototype.apply.call(target, receiver, args)
            }

      var ReflectOwnKeys
      if (R && typeof R.ownKeys === 'function') {
        ReflectOwnKeys = R.ownKeys
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target).concat(
            Object.getOwnPropertySymbols(target)
          )
        }
      } else {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target)
        }
      }

      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning)
      }

      var NumberIsNaN =
        Number.isNaN ||
        function NumberIsNaN(value) {
          return value !== value
        }

      function EventEmitter() {
        EventEmitter.init.call(this)
      }
      module.exports = EventEmitter
      module.exports.once = once

      // Backwards-compat with node 0.10.x
      EventEmitter.EventEmitter = EventEmitter

      EventEmitter.prototype._events = undefined
      EventEmitter.prototype._eventsCount = 0
      EventEmitter.prototype._maxListeners = undefined

      // By default EventEmitters will print a warning if more than 10 listeners are
      // added to it. This is a useful default which helps finding memory leaks.
      var defaultMaxListeners = 10

      function checkListener(listener) {
        if (typeof listener !== 'function') {
          throw new TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof listener
          )
        }
      }

      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
        enumerable: true,
        get: function () {
          return defaultMaxListeners
        },
        set: function (arg) {
          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                arg +
                '.'
            )
          }
          defaultMaxListeners = arg
        }
      })

      EventEmitter.init = function () {
        if (
          this._events === undefined ||
          this._events === Object.getPrototypeOf(this)._events
        ) {
          this._events = Object.create(null)
          this._eventsCount = 0
        }

        this._maxListeners = this._maxListeners || undefined
      }

      // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
          throw new RangeError(
            'The value of "n" is out of range. It must be a non-negative number. Received ' +
              n +
              '.'
          )
        }
        this._maxListeners = n
        return this
      }

      function _getMaxListeners(that) {
        if (that._maxListeners === undefined)
          return EventEmitter.defaultMaxListeners
        return that._maxListeners
      }

      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this)
      }

      EventEmitter.prototype.emit = function emit(type) {
        var args = []
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i])
        var doError = type === 'error'

        var events = this._events
        if (events !== undefined)
          doError = doError && events.error === undefined
        else if (!doError) return false

        // If there is no 'error' event listener then throw.
        if (doError) {
          var er
          if (args.length > 0) er = args[0]
          if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er // Unhandled 'error' event
          }
          // At least give some kind of context to the user
          var err = new Error(
            'Unhandled error.' + (er ? ' (' + er.message + ')' : '')
          )
          err.context = er
          throw err // Unhandled 'error' event
        }

        var handler = events[type]

        if (handler === undefined) return false

        if (typeof handler === 'function') {
          ReflectApply(handler, this, args)
        } else {
          var len = handler.length
          var listeners = arrayClone(handler, len)
          for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args)
        }

        return true
      }

      function _addListener(target, type, listener, prepend) {
        var m
        var events
        var existing

        checkListener(listener)

        events = target._events
        if (events === undefined) {
          events = target._events = Object.create(null)
          target._eventsCount = 0
        } else {
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (events.newListener !== undefined) {
            target.emit(
              'newListener',
              type,
              listener.listener ? listener.listener : listener
            )

            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events
          }
          existing = events[type]
        }

        if (existing === undefined) {
          // Optimize the case of one listener. Don't need the extra array object.
          existing = events[type] = listener
          ++target._eventsCount
        } else {
          if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend
              ? [listener, existing]
              : [existing, listener]
            // If we've already got an array, just append.
          } else if (prepend) {
            existing.unshift(listener)
          } else {
            existing.push(listener)
          }

          // Check for listener leak
          m = _getMaxListeners(target)
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error(
              'Possible EventEmitter memory leak detected. ' +
                existing.length +
                ' ' +
                String(type) +
                ' listeners ' +
                'added. Use emitter.setMaxListeners() to ' +
                'increase limit'
            )
            w.name = 'MaxListenersExceededWarning'
            w.emitter = target
            w.type = type
            w.count = existing.length
            ProcessEmitWarning(w)
          }
        }

        return target
      }

      EventEmitter.prototype.addListener = function addListener(
        type,
        listener
      ) {
        return _addListener(this, type, listener, false)
      }

      EventEmitter.prototype.on = EventEmitter.prototype.addListener

      EventEmitter.prototype.prependListener = function prependListener(
        type,
        listener
      ) {
        return _addListener(this, type, listener, true)
      }

      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn)
          this.fired = true
          if (arguments.length === 0) return this.listener.call(this.target)
          return this.listener.apply(this.target, arguments)
        }
      }

      function _onceWrap(target, type, listener) {
        var state = {
          fired: false,
          wrapFn: undefined,
          target: target,
          type: type,
          listener: listener
        }
        var wrapped = onceWrapper.bind(state)
        wrapped.listener = listener
        state.wrapFn = wrapped
        return wrapped
      }

      EventEmitter.prototype.once = function once(type, listener) {
        checkListener(listener)
        this.on(type, _onceWrap(this, type, listener))
        return this
      }

      EventEmitter.prototype.prependOnceListener = function prependOnceListener(
        type,
        listener
      ) {
        checkListener(listener)
        this.prependListener(type, _onceWrap(this, type, listener))
        return this
      }

      // Emits a 'removeListener' event if and only if the listener was removed.
      EventEmitter.prototype.removeListener = function removeListener(
        type,
        listener
      ) {
        var list, events, position, i, originalListener

        checkListener(listener)

        events = this._events
        if (events === undefined) return this

        list = events[type]
        if (list === undefined) return this

        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0) this._events = Object.create(null)
          else {
            delete events[type]
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener)
          }
        } else if (typeof list !== 'function') {
          position = -1

          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener
              position = i
              break
            }
          }

          if (position < 0) return this

          if (position === 0) list.shift()
          else {
            spliceOne(list, position)
          }

          if (list.length === 1) events[type] = list[0]

          if (events.removeListener !== undefined)
            this.emit('removeListener', type, originalListener || listener)
        }

        return this
      }

      EventEmitter.prototype.off = EventEmitter.prototype.removeListener

      EventEmitter.prototype.removeAllListeners = function removeAllListeners(
        type
      ) {
        var listeners, events, i

        events = this._events
        if (events === undefined) return this

        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null)
            this._eventsCount = 0
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null)
            else delete events[type]
          }
          return this
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events)
          var key
          for (i = 0; i < keys.length; ++i) {
            key = keys[i]
            if (key === 'removeListener') continue
            this.removeAllListeners(key)
          }
          this.removeAllListeners('removeListener')
          this._events = Object.create(null)
          this._eventsCount = 0
          return this
        }

        listeners = events[type]

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners)
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i])
          }
        }

        return this
      }

      function _listeners(target, type, unwrap) {
        var events = target._events

        if (events === undefined) return []

        var evlistener = events[type]
        if (evlistener === undefined) return []

        if (typeof evlistener === 'function')
          return unwrap ? [evlistener.listener || evlistener] : [evlistener]

        return unwrap
          ? unwrapListeners(evlistener)
          : arrayClone(evlistener, evlistener.length)
      }

      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true)
      }

      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false)
      }

      EventEmitter.listenerCount = function (emitter, type) {
        if (typeof emitter.listenerCount === 'function') {
          return emitter.listenerCount(type)
        } else {
          return listenerCount.call(emitter, type)
        }
      }

      EventEmitter.prototype.listenerCount = listenerCount
      function listenerCount(type) {
        var events = this._events

        if (events !== undefined) {
          var evlistener = events[type]

          if (typeof evlistener === 'function') {
            return 1
          } else if (evlistener !== undefined) {
            return evlistener.length
          }
        }

        return 0
      }

      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
      }

      function arrayClone(arr, n) {
        var copy = new Array(n)
        for (var i = 0; i < n; ++i) copy[i] = arr[i]
        return copy
      }

      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++) list[index] = list[index + 1]
        list.pop()
      }

      function unwrapListeners(arr) {
        var ret = new Array(arr.length)
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i]
        }
        return ret
      }

      function once(emitter, name) {
        return new Promise(function (resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver)
            reject(err)
          }

          function resolver() {
            if (typeof emitter.removeListener === 'function') {
              emitter.removeListener('error', errorListener)
            }
            resolve([].slice.call(arguments))
          }

          eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
          })
          if (name !== 'error') {
            addErrorHandlerIfEventEmitter(emitter, errorListener, {
              once: true
            })
          }
        })
      }

      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === 'function') {
          eventTargetAgnosticAddListener(emitter, 'error', handler, flags)
        }
      }

      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === 'function') {
          if (flags.once) {
            emitter.once(name, listener)
          } else {
            emitter.on(name, listener)
          }
        } else if (typeof emitter.addEventListener === 'function') {
          // EventTarget does not have `error` event semantics like Node
          // EventEmitters, we do not listen for `error` events here.
          emitter.addEventListener(name, function wrapListener(arg) {
            // IE does not have builtin `{ once: true }` support so we
            // have to do it manually.
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener)
            }
            listener(arg)
          })
        } else {
          throw new TypeError(
            'The "emitter" argument must be of type EventEmitter. Received type ' +
              typeof emitter
          )
        }
      }

      /***/
    },

    /***/ 4063: /***/ (module) => {
      'use strict'

      // do not edit .js files directly - edit src/index.jst

      module.exports = function equal(a, b) {
        if (a === b) return true

        if (a && b && typeof a == 'object' && typeof b == 'object') {
          if (a.constructor !== b.constructor) return false

          var length, i, keys
          if (Array.isArray(a)) {
            length = a.length
            if (length != b.length) return false
            for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false
            return true
          }

          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf()
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString()

          keys = Object.keys(a)
          length = keys.length
          if (length !== Object.keys(b).length) return false

          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false

          for (i = length; i-- !== 0; ) {
            var key = keys[i]

            if (!equal(a[key], b[key])) return false
          }

          return true
        }

        // true if both NaN, false otherwise
        return a !== a && b !== b
      }

      /***/
    },

    /***/ 6400: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI :data 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: :data Selector
      //>>group: Core
      //>>description: Selects elements which have data stored under the specified key.
      //>>docs: http://api.jqueryui.com/data-selector/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.extend($.expr.pseudos, {
          data: $.expr.createPseudo
            ? $.expr.createPseudo(function (dataName) {
                return function (elem) {
                  return !!$.data(elem, dataName)
                }
              })
            : // Support: jQuery <1.8
              function (elem, i, match) {
                return !!$.data(elem, match[3])
              }
        })
      })

      /***/
    },

    /***/ 2064: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Disable Selection 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: disableSelection
      //>>group: Core
      //>>description: Disable selection of text content within the set of matched elements.
      //>>docs: http://api.jqueryui.com/disableSelection/

      // This file is deprecated
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.fn.extend({
          disableSelection: (function () {
            var eventType =
              'onselectstart' in document.createElement('div')
                ? 'selectstart'
                : 'mousedown'

            return function () {
              return this.on(
                eventType + '.ui-disableSelection',
                function (event) {
                  event.preventDefault()
                }
              )
            }
          })(),

          enableSelection: function () {
            return this.off('.ui-disableSelection')
          }
        })
      })

      /***/
    },

    /***/ 5436: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Focusable 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: :focusable Selector
      //>>group: Core
      //>>description: Selects elements which can be focused.
      //>>docs: http://api.jqueryui.com/focusable-selector/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // Selectors
        $.ui.focusable = function (element, hasTabindex) {
          var map,
            mapName,
            img,
            focusableIfVisible,
            fieldset,
            nodeName = element.nodeName.toLowerCase()

          if ('area' === nodeName) {
            map = element.parentNode
            mapName = map.name
            if (
              !element.href ||
              !mapName ||
              map.nodeName.toLowerCase() !== 'map'
            ) {
              return false
            }
            img = $("img[usemap='#" + mapName + "']")
            return img.length > 0 && img.is(':visible')
          }

          if (/^(input|select|textarea|button|object)$/.test(nodeName)) {
            focusableIfVisible = !element.disabled

            if (focusableIfVisible) {
              // Form controls within a disabled fieldset are disabled.
              // However, controls within the fieldset's legend do not get disabled.
              // Since controls generally aren't placed inside legends, we skip
              // this portion of the check.
              fieldset = $(element).closest('fieldset')[0]
              if (fieldset) {
                focusableIfVisible = !fieldset.disabled
              }
            }
          } else if ('a' === nodeName) {
            focusableIfVisible = element.href || hasTabindex
          } else {
            focusableIfVisible = hasTabindex
          }

          return (
            focusableIfVisible &&
            $(element).is(':visible') &&
            visible($(element))
          )
        }

        // Support: IE 8 only
        // IE 8 doesn't resolve inherit to visible/hidden for computed values
        function visible(element) {
          var visibility = element.css('visibility')
          while (visibility === 'inherit') {
            element = element.parent()
            visibility = element.css('visibility')
          }
          return visibility === 'visible'
        }

        $.extend($.expr.pseudos, {
          focusable: function (element) {
            return $.ui.focusable(element, $.attr(element, 'tabindex') != null)
          }
        })

        return $.ui.focusable
      })

      /***/
    },

    /***/ 7808: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Form Reset Mixin 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Form Reset Mixin
      //>>group: Core
      //>>description: Refresh input widgets when their form is reset
      //>>docs: http://api.jqueryui.com/form-reset-mixin/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5588),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.formResetMixin = {
          _formResetHandler: function () {
            var form = $(this)

            // Wait for the form reset to actually happen before refreshing
            setTimeout(function () {
              var instances = form.data('ui-form-reset-instances')
              $.each(instances, function () {
                this.refresh()
              })
            })
          },

          _bindFormResetHandler: function () {
            this.form = this.element._form()
            if (!this.form.length) {
              return
            }

            var instances = this.form.data('ui-form-reset-instances') || []
            if (!instances.length) {
              // We don't use _on() here because we use a single event handler per form
              this.form.on('reset.ui-form-reset', this._formResetHandler)
            }
            instances.push(this)
            this.form.data('ui-form-reset-instances', instances)
          },

          _unbindFormResetHandler: function () {
            if (!this.form.length) {
              return
            }

            var instances = this.form.data('ui-form-reset-instances')
            instances.splice($.inArray(this, instances), 1)
            if (instances.length) {
              this.form.data('ui-form-reset-instances', instances)
            } else {
              this.form
                .removeData('ui-form-reset-instances')
                .off('reset.ui-form-reset')
            }
          }
        })
      })

      /***/
    },

    /***/ 5588: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // Support: IE8 Only
        // IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
        // with a string, so we need to find the proper form.
        return ($.fn._form = function () {
          return typeof this[0].form === 'string'
            ? this.closest('form')
            : $(this[0].form)
        })
      })

      /***/
    },

    /***/ 1870: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // This file is deprecated
        return ($.ui.ie = !!/msie [\w.]+/.exec(
          navigator.userAgent.toLowerCase()
        ))
      })

      /***/
    },

    /***/ 7053: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Keycode 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Keycode
      //>>group: Core
      //>>description: Provide keycodes as keynames
      //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.keyCode = {
          BACKSPACE: 8,
          COMMA: 188,
          DELETE: 46,
          DOWN: 40,
          END: 35,
          ENTER: 13,
          ESCAPE: 27,
          HOME: 36,
          LEFT: 37,
          PAGE_DOWN: 34,
          PAGE_UP: 33,
          PERIOD: 190,
          RIGHT: 39,
          SPACE: 32,
          TAB: 9,
          UP: 38
        })
      })

      /***/
    },

    /***/ 6575: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Labels 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: labels
      //>>group: Core
      //>>description: Find all the labels associated with a given input
      //>>docs: http://api.jqueryui.com/labels/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.fn.labels = function () {
          var ancestor, selector, id, labels, ancestors

          if (!this.length) {
            return this.pushStack([])
          }

          // Check control.labels first
          if (this[0].labels && this[0].labels.length) {
            return this.pushStack(this[0].labels)
          }

          // Support: IE <= 11, FF <= 37, Android <= 2.3 only
          // Above browsers do not support control.labels. Everything below is to support them
          // as well as document fragments. control.labels does not work on document fragments
          labels = this.eq(0).parents('label')

          // Look for the label based on the id
          id = this.attr('id')
          if (id) {
            // We don't search against the document in case the element
            // is disconnected from the DOM
            ancestor = this.eq(0).parents().last()

            // Get a full set of top level ancestors
            ancestors = ancestor.add(
              ancestor.length ? ancestor.siblings() : this.siblings()
            )

            // Create a selector for the label based on the id
            selector = "label[for='" + $.escapeSelector(id) + "']"

            labels = labels.add(ancestors.find(selector).addBack(selector))
          }

          // Return whatever we have found for labels
          return this.pushStack(labels)
        })
      })

      /***/
    },

    /***/ 1624: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // $.ui.plugin is deprecated. Use $.widget() extensions instead.
        return ($.ui.plugin = {
          add: function (module, option, set) {
            var i,
              proto = $.ui[module].prototype
            for (i in set) {
              proto.plugins[i] = proto.plugins[i] || []
              proto.plugins[i].push([option, set[i]])
            }
          },
          call: function (instance, name, args, allowDisconnected) {
            var i,
              set = instance.plugins[name]

            if (!set) {
              return
            }

            if (
              !allowDisconnected &&
              (!instance.element[0].parentNode ||
                instance.element[0].parentNode.nodeType === 11)
            ) {
              return
            }

            for (i = 0; i < set.length; i++) {
              if (instance.options[set[i][0]]) {
                set[i][1].apply(instance.element, args)
              }
            }
          }
        })
      })

      /***/
    },

    /***/ 1822: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Position 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/position/
       */

      //>>label: Position
      //>>group: Core
      //>>description: Positions elements relative to other elements.
      //>>docs: http://api.jqueryui.com/position/
      //>>demos: http://jqueryui.com/position/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        ;(function () {
          var cachedScrollbarWidth,
            max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position

          function getOffsets(offsets, width, height) {
            return [
              parseFloat(offsets[0]) *
                (rpercent.test(offsets[0]) ? width / 100 : 1),
              parseFloat(offsets[1]) *
                (rpercent.test(offsets[1]) ? height / 100 : 1)
            ]
          }

          function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0
          }

          function isWindow(obj) {
            return obj != null && obj === obj.window
          }

          function getDimensions(elem) {
            var raw = elem[0]
            if (raw.nodeType === 9) {
              return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: 0, left: 0 }
              }
            }
            if (isWindow(raw)) {
              return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
              }
            }
            if (raw.preventDefault) {
              return {
                width: 0,
                height: 0,
                offset: { top: raw.pageY, left: raw.pageX }
              }
            }
            return {
              width: elem.outerWidth(),
              height: elem.outerHeight(),
              offset: elem.offset()
            }
          }

          $.position = {
            scrollbarWidth: function () {
              if (cachedScrollbarWidth !== undefined) {
                return cachedScrollbarWidth
              }
              var w1,
                w2,
                div = $(
                  '<div style=' +
                    "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                    "<div style='height:300px;width:auto;'></div></div>"
                ),
                innerDiv = div.children()[0]

              $('body').append(div)
              w1 = innerDiv.offsetWidth
              div.css('overflow', 'scroll')

              w2 = innerDiv.offsetWidth

              if (w1 === w2) {
                w2 = div[0].clientWidth
              }

              div.remove()

              return (cachedScrollbarWidth = w1 - w2)
            },
            getScrollInfo: function (within) {
              var overflowX =
                  within.isWindow || within.isDocument
                    ? ''
                    : within.element.css('overflow-x'),
                overflowY =
                  within.isWindow || within.isDocument
                    ? ''
                    : within.element.css('overflow-y'),
                hasOverflowX =
                  overflowX === 'scroll' ||
                  (overflowX === 'auto' &&
                    within.width < within.element[0].scrollWidth),
                hasOverflowY =
                  overflowY === 'scroll' ||
                  (overflowY === 'auto' &&
                    within.height < within.element[0].scrollHeight)
              return {
                width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                height: hasOverflowX ? $.position.scrollbarWidth() : 0
              }
            },
            getWithinInfo: function (element) {
              var withinElement = $(element || window),
                isElemWindow = isWindow(withinElement[0]),
                isDocument =
                  !!withinElement[0] && withinElement[0].nodeType === 9,
                hasOffset = !isElemWindow && !isDocument
              return {
                element: withinElement,
                isWindow: isElemWindow,
                isDocument: isDocument,
                offset: hasOffset ? $(element).offset() : { left: 0, top: 0 },
                scrollLeft: withinElement.scrollLeft(),
                scrollTop: withinElement.scrollTop(),
                width: withinElement.outerWidth(),
                height: withinElement.outerHeight()
              }
            }
          }

          $.fn.position = function (options) {
            if (!options || !options.of) {
              return _position.apply(this, arguments)
            }

            // Make a copy, we don't want to modify arguments
            options = $.extend({}, options)

            var atOffset,
              targetWidth,
              targetHeight,
              targetOffset,
              basePosition,
              dimensions,
              // Make sure string options are treated as CSS selectors
              target =
                typeof options.of === 'string'
                  ? $(document).find(options.of)
                  : $(options.of),
              within = $.position.getWithinInfo(options.within),
              scrollInfo = $.position.getScrollInfo(within),
              collision = (options.collision || 'flip').split(' '),
              offsets = {}

            dimensions = getDimensions(target)
            if (target[0].preventDefault) {
              // Force left top to allow flipping
              options.at = 'left top'
            }
            targetWidth = dimensions.width
            targetHeight = dimensions.height
            targetOffset = dimensions.offset

            // Clone to reuse original targetOffset later
            basePosition = $.extend({}, targetOffset)

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each(['my', 'at'], function () {
              var pos = (options[this] || '').split(' '),
                horizontalOffset,
                verticalOffset

              if (pos.length === 1) {
                pos = rhorizontal.test(pos[0])
                  ? pos.concat(['center'])
                  : rvertical.test(pos[0])
                  ? ['center'].concat(pos)
                  : ['center', 'center']
              }
              pos[0] = rhorizontal.test(pos[0]) ? pos[0] : 'center'
              pos[1] = rvertical.test(pos[1]) ? pos[1] : 'center'

              // Calculate offsets
              horizontalOffset = roffset.exec(pos[0])
              verticalOffset = roffset.exec(pos[1])
              offsets[this] = [
                horizontalOffset ? horizontalOffset[0] : 0,
                verticalOffset ? verticalOffset[0] : 0
              ]

              // Reduce to just the positions without the offsets
              options[this] = [
                rposition.exec(pos[0])[0],
                rposition.exec(pos[1])[0]
              ]
            })

            // Normalize collision option
            if (collision.length === 1) {
              collision[1] = collision[0]
            }

            if (options.at[0] === 'right') {
              basePosition.left += targetWidth
            } else if (options.at[0] === 'center') {
              basePosition.left += targetWidth / 2
            }

            if (options.at[1] === 'bottom') {
              basePosition.top += targetHeight
            } else if (options.at[1] === 'center') {
              basePosition.top += targetHeight / 2
            }

            atOffset = getOffsets(offsets.at, targetWidth, targetHeight)
            basePosition.left += atOffset[0]
            basePosition.top += atOffset[1]

            return this.each(function () {
              var collisionPosition,
                using,
                elem = $(this),
                elemWidth = elem.outerWidth(),
                elemHeight = elem.outerHeight(),
                marginLeft = parseCss(this, 'marginLeft'),
                marginTop = parseCss(this, 'marginTop'),
                collisionWidth =
                  elemWidth +
                  marginLeft +
                  parseCss(this, 'marginRight') +
                  scrollInfo.width,
                collisionHeight =
                  elemHeight +
                  marginTop +
                  parseCss(this, 'marginBottom') +
                  scrollInfo.height,
                position = $.extend({}, basePosition),
                myOffset = getOffsets(
                  offsets.my,
                  elem.outerWidth(),
                  elem.outerHeight()
                )

              if (options.my[0] === 'right') {
                position.left -= elemWidth
              } else if (options.my[0] === 'center') {
                position.left -= elemWidth / 2
              }

              if (options.my[1] === 'bottom') {
                position.top -= elemHeight
              } else if (options.my[1] === 'center') {
                position.top -= elemHeight / 2
              }

              position.left += myOffset[0]
              position.top += myOffset[1]

              collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
              }

              $.each(['left', 'top'], function (i, dir) {
                if ($.ui.position[collision[i]]) {
                  $.ui.position[collision[i]][dir](position, {
                    targetWidth: targetWidth,
                    targetHeight: targetHeight,
                    elemWidth: elemWidth,
                    elemHeight: elemHeight,
                    collisionPosition: collisionPosition,
                    collisionWidth: collisionWidth,
                    collisionHeight: collisionHeight,
                    offset: [
                      atOffset[0] + myOffset[0],
                      atOffset[1] + myOffset[1]
                    ],
                    my: options.my,
                    at: options.at,
                    within: within,
                    elem: elem
                  })
                }
              })

              if (options.using) {
                // Adds feedback as second argument to using callback, if present
                using = function (props) {
                  var left = targetOffset.left - position.left,
                    right = left + targetWidth - elemWidth,
                    top = targetOffset.top - position.top,
                    bottom = top + targetHeight - elemHeight,
                    feedback = {
                      target: {
                        element: target,
                        left: targetOffset.left,
                        top: targetOffset.top,
                        width: targetWidth,
                        height: targetHeight
                      },
                      element: {
                        element: elem,
                        left: position.left,
                        top: position.top,
                        width: elemWidth,
                        height: elemHeight
                      },
                      horizontal:
                        right < 0 ? 'left' : left > 0 ? 'right' : 'center',
                      vertical:
                        bottom < 0 ? 'top' : top > 0 ? 'bottom' : 'middle'
                    }
                  if (
                    targetWidth < elemWidth &&
                    abs(left + right) < targetWidth
                  ) {
                    feedback.horizontal = 'center'
                  }
                  if (
                    targetHeight < elemHeight &&
                    abs(top + bottom) < targetHeight
                  ) {
                    feedback.vertical = 'middle'
                  }
                  if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                    feedback.important = 'horizontal'
                  } else {
                    feedback.important = 'vertical'
                  }
                  options.using.call(this, props, feedback)
                }
              }

              elem.offset($.extend(position, { using: using }))
            })
          }

          $.ui.position = {
            fit: {
              left: function (position, data) {
                var within = data.within,
                  withinOffset = within.isWindow
                    ? within.scrollLeft
                    : within.offset.left,
                  outerWidth = within.width,
                  collisionPosLeft =
                    position.left - data.collisionPosition.marginLeft,
                  overLeft = withinOffset - collisionPosLeft,
                  overRight =
                    collisionPosLeft +
                    data.collisionWidth -
                    outerWidth -
                    withinOffset,
                  newOverRight

                // Element is wider than within
                if (data.collisionWidth > outerWidth) {
                  // Element is initially over the left side of within
                  if (overLeft > 0 && overRight <= 0) {
                    newOverRight =
                      position.left +
                      overLeft +
                      data.collisionWidth -
                      outerWidth -
                      withinOffset
                    position.left += overLeft - newOverRight

                    // Element is initially over right side of within
                  } else if (overRight > 0 && overLeft <= 0) {
                    position.left = withinOffset

                    // Element is initially over both left and right sides of within
                  } else {
                    if (overLeft > overRight) {
                      position.left =
                        withinOffset + outerWidth - data.collisionWidth
                    } else {
                      position.left = withinOffset
                    }
                  }

                  // Too far left -> align with left edge
                } else if (overLeft > 0) {
                  position.left += overLeft

                  // Too far right -> align with right edge
                } else if (overRight > 0) {
                  position.left -= overRight

                  // Adjust based on position and margin
                } else {
                  position.left = max(
                    position.left - collisionPosLeft,
                    position.left
                  )
                }
              },
              top: function (position, data) {
                var within = data.within,
                  withinOffset = within.isWindow
                    ? within.scrollTop
                    : within.offset.top,
                  outerHeight = data.within.height,
                  collisionPosTop =
                    position.top - data.collisionPosition.marginTop,
                  overTop = withinOffset - collisionPosTop,
                  overBottom =
                    collisionPosTop +
                    data.collisionHeight -
                    outerHeight -
                    withinOffset,
                  newOverBottom

                // Element is taller than within
                if (data.collisionHeight > outerHeight) {
                  // Element is initially over the top of within
                  if (overTop > 0 && overBottom <= 0) {
                    newOverBottom =
                      position.top +
                      overTop +
                      data.collisionHeight -
                      outerHeight -
                      withinOffset
                    position.top += overTop - newOverBottom

                    // Element is initially over bottom of within
                  } else if (overBottom > 0 && overTop <= 0) {
                    position.top = withinOffset

                    // Element is initially over both top and bottom of within
                  } else {
                    if (overTop > overBottom) {
                      position.top =
                        withinOffset + outerHeight - data.collisionHeight
                    } else {
                      position.top = withinOffset
                    }
                  }

                  // Too far up -> align with top
                } else if (overTop > 0) {
                  position.top += overTop

                  // Too far down -> align with bottom edge
                } else if (overBottom > 0) {
                  position.top -= overBottom

                  // Adjust based on position and margin
                } else {
                  position.top = max(
                    position.top - collisionPosTop,
                    position.top
                  )
                }
              }
            },
            flip: {
              left: function (position, data) {
                var within = data.within,
                  withinOffset = within.offset.left + within.scrollLeft,
                  outerWidth = within.width,
                  offsetLeft = within.isWindow
                    ? within.scrollLeft
                    : within.offset.left,
                  collisionPosLeft =
                    position.left - data.collisionPosition.marginLeft,
                  overLeft = collisionPosLeft - offsetLeft,
                  overRight =
                    collisionPosLeft +
                    data.collisionWidth -
                    outerWidth -
                    offsetLeft,
                  myOffset =
                    data.my[0] === 'left'
                      ? -data.elemWidth
                      : data.my[0] === 'right'
                      ? data.elemWidth
                      : 0,
                  atOffset =
                    data.at[0] === 'left'
                      ? data.targetWidth
                      : data.at[0] === 'right'
                      ? -data.targetWidth
                      : 0,
                  offset = -2 * data.offset[0],
                  newOverRight,
                  newOverLeft

                if (overLeft < 0) {
                  newOverRight =
                    position.left +
                    myOffset +
                    atOffset +
                    offset +
                    data.collisionWidth -
                    outerWidth -
                    withinOffset
                  if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                    position.left += myOffset + atOffset + offset
                  }
                } else if (overRight > 0) {
                  newOverLeft =
                    position.left -
                    data.collisionPosition.marginLeft +
                    myOffset +
                    atOffset +
                    offset -
                    offsetLeft
                  if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                    position.left += myOffset + atOffset + offset
                  }
                }
              },
              top: function (position, data) {
                var within = data.within,
                  withinOffset = within.offset.top + within.scrollTop,
                  outerHeight = within.height,
                  offsetTop = within.isWindow
                    ? within.scrollTop
                    : within.offset.top,
                  collisionPosTop =
                    position.top - data.collisionPosition.marginTop,
                  overTop = collisionPosTop - offsetTop,
                  overBottom =
                    collisionPosTop +
                    data.collisionHeight -
                    outerHeight -
                    offsetTop,
                  top = data.my[1] === 'top',
                  myOffset = top
                    ? -data.elemHeight
                    : data.my[1] === 'bottom'
                    ? data.elemHeight
                    : 0,
                  atOffset =
                    data.at[1] === 'top'
                      ? data.targetHeight
                      : data.at[1] === 'bottom'
                      ? -data.targetHeight
                      : 0,
                  offset = -2 * data.offset[1],
                  newOverTop,
                  newOverBottom
                if (overTop < 0) {
                  newOverBottom =
                    position.top +
                    myOffset +
                    atOffset +
                    offset +
                    data.collisionHeight -
                    outerHeight -
                    withinOffset
                  if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                    position.top += myOffset + atOffset + offset
                  }
                } else if (overBottom > 0) {
                  newOverTop =
                    position.top -
                    data.collisionPosition.marginTop +
                    myOffset +
                    atOffset +
                    offset -
                    offsetTop
                  if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                    position.top += myOffset + atOffset + offset
                  }
                }
              }
            },
            flipfit: {
              left: function () {
                $.ui.position.flip.left.apply(this, arguments)
                $.ui.position.fit.left.apply(this, arguments)
              },
              top: function () {
                $.ui.position.flip.top.apply(this, arguments)
                $.ui.position.fit.top.apply(this, arguments)
              }
            }
          }
        })()

        return $.ui.position
      })

      /***/
    },

    /***/ 1440: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.safeActiveElement = function (document) {
          var activeElement

          // Support: IE 9 only
          // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
          try {
            activeElement = document.activeElement
          } catch (error) {
            activeElement = document.body
          }

          // Support: IE 9 - 11 only
          // IE may return null instead of an element
          // Interestingly, this only seems to occur when NOT in an iframe
          if (!activeElement) {
            activeElement = document.body
          }

          // Support: IE 11 only
          // IE11 returns a seemingly empty object in some cases when accessing
          // document.activeElement from an <iframe>
          if (!activeElement.nodeName) {
            activeElement = document.body
          }

          return activeElement
        })
      })

      /***/
    },

    /***/ 192: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.safeBlur = function (element) {
          // Support: IE9 - 10 only
          // If the <body> is blurred, IE will switch windows, see #9420
          if (element && element.nodeName.toLowerCase() !== 'body') {
            $(element).trigger('blur')
          }
        })
      })

      /***/
    },

    /***/ 464: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Scroll Parent 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: scrollParent
      //>>group: Core
      //>>description: Get the closest ancestor element that is scrollable.
      //>>docs: http://api.jqueryui.com/scrollParent/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.fn.scrollParent = function (includeHidden) {
          var position = this.css('position'),
            excludeStaticParent = position === 'absolute',
            overflowRegex = includeHidden
              ? /(auto|scroll|hidden)/
              : /(auto|scroll)/,
            scrollParent = this.parents()
              .filter(function () {
                var parent = $(this)
                if (
                  excludeStaticParent &&
                  parent.css('position') === 'static'
                ) {
                  return false
                }
                return overflowRegex.test(
                  parent.css('overflow') +
                    parent.css('overflow-y') +
                    parent.css('overflow-x')
                )
              })
              .eq(0)

          return position === 'fixed' || !scrollParent.length
            ? $(this[0].ownerDocument || document)
            : scrollParent
        })
      })

      /***/
    },

    /***/ 3614: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Tabbable 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: :tabbable Selector
      //>>group: Core
      //>>description: Selects elements which can be tabbed to.
      //>>docs: http://api.jqueryui.com/tabbable-selector/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592),
            __webpack_require__(5436)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.extend($.expr.pseudos, {
          tabbable: function (element) {
            var tabIndex = $.attr(element, 'tabindex'),
              hasTabindex = tabIndex != null
            return (
              (!hasTabindex || tabIndex >= 0) &&
              $.ui.focusable(element, hasTabindex)
            )
          }
        })
      })

      /***/
    },

    /***/ 9138: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Unique ID 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: uniqueId
      //>>group: Core
      //>>description: Functions to generate and remove uniqueId's
      //>>docs: http://api.jqueryui.com/uniqueId/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.fn.extend({
          uniqueId: (function () {
            var uuid = 0

            return function () {
              return this.each(function () {
                if (!this.id) {
                  this.id = 'ui-id-' + ++uuid
                }
              })
            }
          })(),

          removeUniqueId: function () {
            return this.each(function () {
              if (/^ui-id-\d+$/.test(this.id)) {
                $(this).removeAttr('id')
              }
            })
          }
        })
      })

      /***/
    },

    /***/ 5592: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9755)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.ui = $.ui || {}

        return ($.ui.version = '1.13.1')
      })

      /***/
    },

    /***/ 6891: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Widget 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Widget
      //>>group: Core
      //>>description: Provides a factory for creating stateful widgets with a common API.
      //>>docs: http://api.jqueryui.com/jQuery.widget/
      //>>demos: http://jqueryui.com/widget/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        var widgetUuid = 0
        var widgetHasOwnProperty = Array.prototype.hasOwnProperty
        var widgetSlice = Array.prototype.slice

        $.cleanData = (function (orig) {
          return function (elems) {
            var events, elem, i
            for (i = 0; (elem = elems[i]) != null; i++) {
              // Only trigger remove when necessary to save time
              events = $._data(elem, 'events')
              if (events && events.remove) {
                $(elem).triggerHandler('remove')
              }
            }
            orig(elems)
          }
        })($.cleanData)

        $.widget = function (name, base, prototype) {
          var existingConstructor, constructor, basePrototype

          // ProxiedPrototype allows the provided prototype to remain unmodified
          // so that it can be used as a mixin for multiple widgets (#8876)
          var proxiedPrototype = {}

          var namespace = name.split('.')[0]
          name = name.split('.')[1]
          var fullName = namespace + '-' + name

          if (!prototype) {
            prototype = base
            base = $.Widget
          }

          if (Array.isArray(prototype)) {
            prototype = $.extend.apply(null, [{}].concat(prototype))
          }

          // Create selector for plugin
          $.expr.pseudos[fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName)
          }

          $[namespace] = $[namespace] || {}
          existingConstructor = $[namespace][name]
          constructor = $[namespace][name] = function (options, element) {
            // Allow instantiation without "new" keyword
            if (!this || !this._createWidget) {
              return new constructor(options, element)
            }

            // Allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
              this._createWidget(options, element)
            }
          }

          // Extend with the existing constructor to carry over any static properties
          $.extend(constructor, existingConstructor, {
            version: prototype.version,

            // Copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),

            // Track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
          })

          basePrototype = new base()

          // We need to make the options hash a property directly on the new instance
          // otherwise we'll modify the options hash on the prototype that we're
          // inheriting from
          basePrototype.options = $.widget.extend({}, basePrototype.options)
          $.each(prototype, function (prop, value) {
            if (typeof value !== 'function') {
              proxiedPrototype[prop] = value
              return
            }
            proxiedPrototype[prop] = (function () {
              function _super() {
                return base.prototype[prop].apply(this, arguments)
              }

              function _superApply(args) {
                return base.prototype[prop].apply(this, args)
              }

              return function () {
                var __super = this._super
                var __superApply = this._superApply
                var returnValue

                this._super = _super
                this._superApply = _superApply

                returnValue = value.apply(this, arguments)

                this._super = __super
                this._superApply = __superApply

                return returnValue
              }
            })()
          })
          constructor.prototype = $.widget.extend(
            basePrototype,
            {
              // TODO: remove support for widgetEventPrefix
              // always use the name + a colon as the prefix, e.g., draggable:start
              // don't prefix for widgets that aren't DOM-based
              widgetEventPrefix: existingConstructor
                ? basePrototype.widgetEventPrefix || name
                : name
            },
            proxiedPrototype,
            {
              constructor: constructor,
              namespace: namespace,
              widgetName: name,
              widgetFullName: fullName
            }
          )

          // If this widget is being redefined then we need to find all widgets that
          // are inheriting from it and redefine all of them so that they inherit from
          // the new version of this widget. We're essentially trying to replace one
          // level in the prototype chain.
          if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
              var childPrototype = child.prototype

              // Redefine the child widget using the same prototype that was
              // originally used, but inherit from the new version of the base
              $.widget(
                childPrototype.namespace + '.' + childPrototype.widgetName,
                constructor,
                child._proto
              )
            })

            // Remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors
          } else {
            base._childConstructors.push(constructor)
          }

          $.widget.bridge(name, constructor)

          return constructor
        }

        $.widget.extend = function (target) {
          var input = widgetSlice.call(arguments, 1)
          var inputIndex = 0
          var inputLength = input.length
          var key
          var value

          for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
              value = input[inputIndex][key]
              if (
                widgetHasOwnProperty.call(input[inputIndex], key) &&
                value !== undefined
              ) {
                // Clone objects
                if ($.isPlainObject(value)) {
                  target[key] = $.isPlainObject(target[key])
                    ? $.widget.extend({}, target[key], value)
                    : // Don't extend strings, arrays, etc. with objects
                      $.widget.extend({}, value)

                  // Copy everything else by reference
                } else {
                  target[key] = value
                }
              }
            }
          }
          return target
        }

        $.widget.bridge = function (name, object) {
          var fullName = object.prototype.widgetFullName || name
          $.fn[name] = function (options) {
            var isMethodCall = typeof options === 'string'
            var args = widgetSlice.call(arguments, 1)
            var returnValue = this

            if (isMethodCall) {
              // If this is an empty collection, we need to have the instance method
              // return undefined instead of the jQuery instance
              if (!this.length && options === 'instance') {
                returnValue = undefined
              } else {
                this.each(function () {
                  var methodValue
                  var instance = $.data(this, fullName)

                  if (options === 'instance') {
                    returnValue = instance
                    return false
                  }

                  if (!instance) {
                    return $.error(
                      'cannot call methods on ' +
                        name +
                        ' prior to initialization; ' +
                        "attempted to call method '" +
                        options +
                        "'"
                    )
                  }

                  if (
                    typeof instance[options] !== 'function' ||
                    options.charAt(0) === '_'
                  ) {
                    return $.error(
                      "no such method '" +
                        options +
                        "' for " +
                        name +
                        ' widget instance'
                    )
                  }

                  methodValue = instance[options].apply(instance, args)

                  if (methodValue !== instance && methodValue !== undefined) {
                    returnValue =
                      methodValue && methodValue.jquery
                        ? returnValue.pushStack(methodValue.get())
                        : methodValue
                    return false
                  }
                })
              }
            } else {
              // Allow multiple hashes to be passed on init
              if (args.length) {
                options = $.widget.extend.apply(null, [options].concat(args))
              }

              this.each(function () {
                var instance = $.data(this, fullName)
                if (instance) {
                  instance.option(options || {})
                  if (instance._init) {
                    instance._init()
                  }
                } else {
                  $.data(this, fullName, new object(options, this))
                }
              })
            }

            return returnValue
          }
        }

        $.Widget = function (/* options, element */) {}
        $.Widget._childConstructors = []

        $.Widget.prototype = {
          widgetName: 'widget',
          widgetEventPrefix: '',
          defaultElement: '<div>',

          options: {
            classes: {},
            disabled: false,

            // Callbacks
            create: null
          },

          _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0]
            this.element = $(element)
            this.uuid = widgetUuid++
            this.eventNamespace = '.' + this.widgetName + this.uuid

            this.bindings = $()
            this.hoverable = $()
            this.focusable = $()
            this.classesElementLookup = {}

            if (element !== this) {
              $.data(element, this.widgetFullName, this)
              this._on(true, this.element, {
                remove: function (event) {
                  if (event.target === element) {
                    this.destroy()
                  }
                }
              })
              this.document = $(
                element.style
                  ? // Element within the document
                    element.ownerDocument
                  : // Element is window or document
                    element.document || element
              )
              this.window = $(
                this.document[0].defaultView || this.document[0].parentWindow
              )
            }

            this.options = $.widget.extend(
              {},
              this.options,
              this._getCreateOptions(),
              options
            )

            this._create()

            if (this.options.disabled) {
              this._setOptionDisabled(this.options.disabled)
            }

            this._trigger('create', null, this._getCreateEventData())
            this._init()
          },

          _getCreateOptions: function () {
            return {}
          },

          _getCreateEventData: $.noop,

          _create: $.noop,

          _init: $.noop,

          destroy: function () {
            var that = this

            this._destroy()
            $.each(this.classesElementLookup, function (key, value) {
              that._removeClass(value, key)
            })

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
              .off(this.eventNamespace)
              .removeData(this.widgetFullName)
            this.widget().off(this.eventNamespace).removeAttr('aria-disabled')

            // Clean up events and states
            this.bindings.off(this.eventNamespace)
          },

          _destroy: $.noop,

          widget: function () {
            return this.element
          },

          option: function (key, value) {
            var options = key
            var parts
            var curOption
            var i

            if (arguments.length === 0) {
              // Don't return a reference to the internal hash
              return $.widget.extend({}, this.options)
            }

            if (typeof key === 'string') {
              // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
              options = {}
              parts = key.split('.')
              key = parts.shift()
              if (parts.length) {
                curOption = options[key] = $.widget.extend(
                  {},
                  this.options[key]
                )
                for (i = 0; i < parts.length - 1; i++) {
                  curOption[parts[i]] = curOption[parts[i]] || {}
                  curOption = curOption[parts[i]]
                }
                key = parts.pop()
                if (arguments.length === 1) {
                  return curOption[key] === undefined ? null : curOption[key]
                }
                curOption[key] = value
              } else {
                if (arguments.length === 1) {
                  return this.options[key] === undefined
                    ? null
                    : this.options[key]
                }
                options[key] = value
              }
            }

            this._setOptions(options)

            return this
          },

          _setOptions: function (options) {
            var key

            for (key in options) {
              this._setOption(key, options[key])
            }

            return this
          },

          _setOption: function (key, value) {
            if (key === 'classes') {
              this._setOptionClasses(value)
            }

            this.options[key] = value

            if (key === 'disabled') {
              this._setOptionDisabled(value)
            }

            return this
          },

          _setOptionClasses: function (value) {
            var classKey, elements, currentElements

            for (classKey in value) {
              currentElements = this.classesElementLookup[classKey]
              if (
                value[classKey] === this.options.classes[classKey] ||
                !currentElements ||
                !currentElements.length
              ) {
                continue
              }

              // We are doing this to create a new jQuery object because the _removeClass() call
              // on the next line is going to destroy the reference to the current elements being
              // tracked. We need to save a copy of this collection so that we can add the new classes
              // below.
              elements = $(currentElements.get())
              this._removeClass(currentElements, classKey)

              // We don't use _addClass() here, because that uses this.options.classes
              // for generating the string of classes. We want to use the value passed in from
              // _setOption(), this is the new value of the classes option which was passed to
              // _setOption(). We pass this value directly to _classes().
              elements.addClass(
                this._classes({
                  element: elements,
                  keys: classKey,
                  classes: value,
                  add: true
                })
              )
            }
          },

          _setOptionDisabled: function (value) {
            this._toggleClass(
              this.widget(),
              this.widgetFullName + '-disabled',
              null,
              !!value
            )

            // If the widget is becoming disabled, then nothing is interactive
            if (value) {
              this._removeClass(this.hoverable, null, 'ui-state-hover')
              this._removeClass(this.focusable, null, 'ui-state-focus')
            }
          },

          enable: function () {
            return this._setOptions({ disabled: false })
          },

          disable: function () {
            return this._setOptions({ disabled: true })
          },

          _classes: function (options) {
            var full = []
            var that = this

            options = $.extend(
              {
                element: this.element,
                classes: this.options.classes || {}
              },
              options
            )

            function bindRemoveEvent() {
              var nodesToBind = []

              options.element.each(function (_, element) {
                var isTracked = $.map(
                  that.classesElementLookup,
                  function (elements) {
                    return elements
                  }
                ).some(function (elements) {
                  return elements.is(element)
                })

                if (!isTracked) {
                  nodesToBind.push(element)
                }
              })

              that._on($(nodesToBind), {
                remove: '_untrackClassesElement'
              })
            }

            function processClassString(classes, checkOption) {
              var current, i
              for (i = 0; i < classes.length; i++) {
                current = that.classesElementLookup[classes[i]] || $()
                if (options.add) {
                  bindRemoveEvent()
                  current = $(
                    $.uniqueSort(current.get().concat(options.element.get()))
                  )
                } else {
                  current = $(current.not(options.element).get())
                }
                that.classesElementLookup[classes[i]] = current
                full.push(classes[i])
                if (checkOption && options.classes[classes[i]]) {
                  full.push(options.classes[classes[i]])
                }
              }
            }

            if (options.keys) {
              processClassString(options.keys.match(/\S+/g) || [], true)
            }
            if (options.extra) {
              processClassString(options.extra.match(/\S+/g) || [])
            }

            return full.join(' ')
          },

          _untrackClassesElement: function (event) {
            var that = this
            $.each(that.classesElementLookup, function (key, value) {
              if ($.inArray(event.target, value) !== -1) {
                that.classesElementLookup[key] = $(
                  value.not(event.target).get()
                )
              }
            })

            this._off($(event.target))
          },

          _removeClass: function (element, keys, extra) {
            return this._toggleClass(element, keys, extra, false)
          },

          _addClass: function (element, keys, extra) {
            return this._toggleClass(element, keys, extra, true)
          },

          _toggleClass: function (element, keys, extra, add) {
            add = typeof add === 'boolean' ? add : extra
            var shift = typeof element === 'string' || element === null,
              options = {
                extra: shift ? keys : extra,
                keys: shift ? element : keys,
                element: shift ? this.element : element,
                add: add
              }
            options.element.toggleClass(this._classes(options), add)
            return this
          },

          _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement
            var instance = this

            // No suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== 'boolean') {
              handlers = element
              element = suppressDisabledCheck
              suppressDisabledCheck = false
            }

            // No element argument, shuffle and use this.element
            if (!handlers) {
              handlers = element
              element = this.element
              delegateElement = this.widget()
            } else {
              element = delegateElement = $(element)
              this.bindings = this.bindings.add(element)
            }

            $.each(handlers, function (event, handler) {
              function handlerProxy() {
                // Allow widgets to customize the disabled handling
                // - disabled as an array instead of boolean
                // - disabled class as method for disabling individual parts
                if (
                  !suppressDisabledCheck &&
                  (instance.options.disabled === true ||
                    $(this).hasClass('ui-state-disabled'))
                ) {
                  return
                }
                return (
                  typeof handler === 'string' ? instance[handler] : handler
                ).apply(instance, arguments)
              }

              // Copy the guid so direct unbinding works
              if (typeof handler !== 'string') {
                handlerProxy.guid = handler.guid =
                  handler.guid || handlerProxy.guid || $.guid++
              }

              var match = event.match(/^([\w:-]*)\s*(.*)$/)
              var eventName = match[1] + instance.eventNamespace
              var selector = match[2]

              if (selector) {
                delegateElement.on(eventName, selector, handlerProxy)
              } else {
                element.on(eventName, handlerProxy)
              }
            })
          },

          _off: function (element, eventName) {
            eventName =
              (eventName || '').split(' ').join(this.eventNamespace + ' ') +
              this.eventNamespace
            element.off(eventName)

            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $(this.bindings.not(element).get())
            this.focusable = $(this.focusable.not(element).get())
            this.hoverable = $(this.hoverable.not(element).get())
          },

          _delay: function (handler, delay) {
            function handlerProxy() {
              return (
                typeof handler === 'string' ? instance[handler] : handler
              ).apply(instance, arguments)
            }
            var instance = this
            return setTimeout(handlerProxy, delay || 0)
          },

          _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element)
            this._on(element, {
              mouseenter: function (event) {
                this._addClass($(event.currentTarget), null, 'ui-state-hover')
              },
              mouseleave: function (event) {
                this._removeClass(
                  $(event.currentTarget),
                  null,
                  'ui-state-hover'
                )
              }
            })
          },

          _focusable: function (element) {
            this.focusable = this.focusable.add(element)
            this._on(element, {
              focusin: function (event) {
                this._addClass($(event.currentTarget), null, 'ui-state-focus')
              },
              focusout: function (event) {
                this._removeClass(
                  $(event.currentTarget),
                  null,
                  'ui-state-focus'
                )
              }
            })
          },

          _trigger: function (type, event, data) {
            var prop, orig
            var callback = this.options[type]

            data = data || {}
            event = $.Event(event)
            event.type = (
              type === this.widgetEventPrefix
                ? type
                : this.widgetEventPrefix + type
            ).toLowerCase()

            // The original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0]

            // Copy original event properties over to the new event
            orig = event.originalEvent
            if (orig) {
              for (prop in orig) {
                if (!(prop in event)) {
                  event[prop] = orig[prop]
                }
              }
            }

            this.element.trigger(event, data)
            return !(
              (typeof callback === 'function' &&
                callback.apply(this.element[0], [event].concat(data)) ===
                  false) ||
              event.isDefaultPrevented()
            )
          }
        }

        $.each(
          { show: 'fadeIn', hide: 'fadeOut' },
          function (method, defaultEffect) {
            $.Widget.prototype['_' + method] = function (
              element,
              options,
              callback
            ) {
              if (typeof options === 'string') {
                options = { effect: options }
              }

              var hasOptions
              var effectName = !options
                ? method
                : options === true || typeof options === 'number'
                ? defaultEffect
                : options.effect || defaultEffect

              options = options || {}
              if (typeof options === 'number') {
                options = { duration: options }
              } else if (options === true) {
                options = {}
              }

              hasOptions = !$.isEmptyObject(options)
              options.complete = callback

              if (options.delay) {
                element.delay(options.delay)
              }

              if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options)
              } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback)
              } else {
                element.queue(function (next) {
                  $(this)[method]()
                  if (callback) {
                    callback.call(element[0])
                  }
                  next()
                })
              }
            }
          }
        )

        return $.widget
      })

      /***/
    },

    /***/ 2993: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Autocomplete 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Autocomplete
      //>>group: Widgets
      //>>description: Lists suggested words as the user is typing.
      //>>docs: http://api.jqueryui.com/autocomplete/
      //>>demos: http://jqueryui.com/autocomplete/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/autocomplete.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(8851),
            __webpack_require__(7053),
            __webpack_require__(1822),
            __webpack_require__(1440),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.autocomplete', {
          version: '1.13.1',
          defaultElement: '<input>',
          options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
              my: 'left top',
              at: 'left bottom',
              collision: 'none'
            },
            source: null,

            // Callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
          },

          requestIndex: 0,
          pending: 0,
          liveRegionTimer: null,

          _create: function () {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress,
              suppressKeyPressRepeat,
              suppressInput,
              nodeName = this.element[0].nodeName.toLowerCase(),
              isTextarea = nodeName === 'textarea',
              isInput = nodeName === 'input'

            // Textareas are always multi-line
            // Inputs are always single-line, even if inside a contentEditable element
            // IE also treats inputs as contentEditable
            // All other element types are determined by whether or not they're contentEditable
            this.isMultiLine =
              isTextarea || (!isInput && this._isContentEditable(this.element))

            this.valueMethod =
              this.element[isTextarea || isInput ? 'val' : 'text']
            this.isNewMenu = true

            this._addClass('ui-autocomplete-input')
            this.element.attr('autocomplete', 'off')

            this._on(this.element, {
              keydown: function (event) {
                if (this.element.prop('readOnly')) {
                  suppressKeyPress = true
                  suppressInput = true
                  suppressKeyPressRepeat = true
                  return
                }

                suppressKeyPress = false
                suppressInput = false
                suppressKeyPressRepeat = false
                var keyCode = $.ui.keyCode
                switch (event.keyCode) {
                  case keyCode.PAGE_UP:
                    suppressKeyPress = true
                    this._move('previousPage', event)
                    break
                  case keyCode.PAGE_DOWN:
                    suppressKeyPress = true
                    this._move('nextPage', event)
                    break
                  case keyCode.UP:
                    suppressKeyPress = true
                    this._keyEvent('previous', event)
                    break
                  case keyCode.DOWN:
                    suppressKeyPress = true
                    this._keyEvent('next', event)
                    break
                  case keyCode.ENTER:
                    // when menu is open and has focus
                    if (this.menu.active) {
                      // #6055 - Opera still allows the keypress to occur
                      // which causes forms to submit
                      suppressKeyPress = true
                      event.preventDefault()
                      this.menu.select(event)
                    }
                    break
                  case keyCode.TAB:
                    if (this.menu.active) {
                      this.menu.select(event)
                    }
                    break
                  case keyCode.ESCAPE:
                    if (this.menu.element.is(':visible')) {
                      if (!this.isMultiLine) {
                        this._value(this.term)
                      }
                      this.close(event)

                      // Different browsers have different default behavior for escape
                      // Single press can mean undo or clear
                      // Double press in IE means clear the whole form
                      event.preventDefault()
                    }
                    break
                  default:
                    suppressKeyPressRepeat = true

                    // search timeout should be triggered before the input value is changed
                    this._searchTimeout(event)
                    break
                }
              },
              keypress: function (event) {
                if (suppressKeyPress) {
                  suppressKeyPress = false
                  if (!this.isMultiLine || this.menu.element.is(':visible')) {
                    event.preventDefault()
                  }
                  return
                }
                if (suppressKeyPressRepeat) {
                  return
                }

                // Replicate some key handlers to allow them to repeat in Firefox and Opera
                var keyCode = $.ui.keyCode
                switch (event.keyCode) {
                  case keyCode.PAGE_UP:
                    this._move('previousPage', event)
                    break
                  case keyCode.PAGE_DOWN:
                    this._move('nextPage', event)
                    break
                  case keyCode.UP:
                    this._keyEvent('previous', event)
                    break
                  case keyCode.DOWN:
                    this._keyEvent('next', event)
                    break
                }
              },
              input: function (event) {
                if (suppressInput) {
                  suppressInput = false
                  event.preventDefault()
                  return
                }
                this._searchTimeout(event)
              },
              focus: function () {
                this.selectedItem = null
                this.previous = this._value()
              },
              blur: function (event) {
                clearTimeout(this.searching)
                this.close(event)
                this._change(event)
              }
            })

            this._initSource()
            this.menu = $('<ul>')
              .appendTo(this._appendTo())
              .menu({
                // disable ARIA support, the live region takes care of that
                role: null
              })
              .hide()

              // Support: IE 11 only, Edge <= 14
              // For other browsers, we preventDefault() on the mousedown event
              // to keep the dropdown from taking focus from the input. This doesn't
              // work for IE/Edge, causing problems with selection and scrolling (#9638)
              // Happily, IE and Edge support an "unselectable" attribute that
              // prevents an element from receiving focus, exactly what we want here.
              .attr({
                unselectable: 'on'
              })
              .menu('instance')

            this._addClass(this.menu.element, 'ui-autocomplete', 'ui-front')
            this._on(this.menu.element, {
              mousedown: function (event) {
                // Prevent moving focus out of the text field
                event.preventDefault()
              },
              menufocus: function (event, ui) {
                var label, item

                // support: Firefox
                // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                if (this.isNewMenu) {
                  this.isNewMenu = false
                  if (
                    event.originalEvent &&
                    /^mouse/.test(event.originalEvent.type)
                  ) {
                    this.menu.blur()

                    this.document.one('mousemove', function () {
                      $(event.target).trigger(event.originalEvent)
                    })

                    return
                  }
                }

                item = ui.item.data('ui-autocomplete-item')
                if (false !== this._trigger('focus', event, { item: item })) {
                  // use value to match what will end up in the input, if it was a key event
                  if (
                    event.originalEvent &&
                    /^key/.test(event.originalEvent.type)
                  ) {
                    this._value(item.value)
                  }
                }

                // Announce the value in the liveRegion
                label = ui.item.attr('aria-label') || item.value
                if (label && String.prototype.trim.call(label).length) {
                  clearTimeout(this.liveRegionTimer)
                  this.liveRegionTimer = this._delay(function () {
                    this.liveRegion.html($('<div>').text(label))
                  }, 100)
                }
              },
              menuselect: function (event, ui) {
                var item = ui.item.data('ui-autocomplete-item'),
                  previous = this.previous

                // Only trigger when focus was lost (click on menu)
                if (
                  this.element[0] !== $.ui.safeActiveElement(this.document[0])
                ) {
                  this.element.trigger('focus')
                  this.previous = previous

                  // #6109 - IE triggers two focus events and the second
                  // is asynchronous, so we need to reset the previous
                  // term synchronously and asynchronously :-(
                  this._delay(function () {
                    this.previous = previous
                    this.selectedItem = item
                  })
                }

                if (false !== this._trigger('select', event, { item: item })) {
                  this._value(item.value)
                }

                // reset the term after the select event
                // this allows custom select handling to work properly
                this.term = this._value()

                this.close(event)
                this.selectedItem = item
              }
            })

            this.liveRegion = $('<div>', {
              role: 'status',
              'aria-live': 'assertive',
              'aria-relevant': 'additions'
            }).appendTo(this.document[0].body)

            this._addClass(this.liveRegion, null, 'ui-helper-hidden-accessible')

            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
              beforeunload: function () {
                this.element.removeAttr('autocomplete')
              }
            })
          },

          _destroy: function () {
            clearTimeout(this.searching)
            this.element.removeAttr('autocomplete')
            this.menu.element.remove()
            this.liveRegion.remove()
          },

          _setOption: function (key, value) {
            this._super(key, value)
            if (key === 'source') {
              this._initSource()
            }
            if (key === 'appendTo') {
              this.menu.element.appendTo(this._appendTo())
            }
            if (key === 'disabled' && value && this.xhr) {
              this.xhr.abort()
            }
          },

          _isEventTargetInWidget: function (event) {
            var menuElement = this.menu.element[0]

            return (
              event.target === this.element[0] ||
              event.target === menuElement ||
              $.contains(menuElement, event.target)
            )
          },

          _closeOnClickOutside: function (event) {
            if (!this._isEventTargetInWidget(event)) {
              this.close()
            }
          },

          _appendTo: function () {
            var element = this.options.appendTo

            if (element) {
              element =
                element.jquery || element.nodeType
                  ? $(element)
                  : this.document.find(element).eq(0)
            }

            if (!element || !element[0]) {
              element = this.element.closest('.ui-front, dialog')
            }

            if (!element.length) {
              element = this.document[0].body
            }

            return element
          },

          _initSource: function () {
            var array,
              url,
              that = this
            if (Array.isArray(this.options.source)) {
              array = this.options.source
              this.source = function (request, response) {
                response($.ui.autocomplete.filter(array, request.term))
              }
            } else if (typeof this.options.source === 'string') {
              url = this.options.source
              this.source = function (request, response) {
                if (that.xhr) {
                  that.xhr.abort()
                }
                that.xhr = $.ajax({
                  url: url,
                  data: request,
                  dataType: 'json',
                  success: function (data) {
                    response(data)
                  },
                  error: function () {
                    response([])
                  }
                })
              }
            } else {
              this.source = this.options.source
            }
          },

          _searchTimeout: function (event) {
            clearTimeout(this.searching)
            this.searching = this._delay(function () {
              // Search if the value has changed, or if the user retypes the same value (see #7434)
              var equalValues = this.term === this._value(),
                menuVisible = this.menu.element.is(':visible'),
                modifierKey =
                  event.altKey ||
                  event.ctrlKey ||
                  event.metaKey ||
                  event.shiftKey

              if (
                !equalValues ||
                (equalValues && !menuVisible && !modifierKey)
              ) {
                this.selectedItem = null
                this.search(null, event)
              }
            }, this.options.delay)
          },

          search: function (value, event) {
            value = value != null ? value : this._value()

            // Always save the actual value, not the one passed as an argument
            this.term = this._value()

            if (value.length < this.options.minLength) {
              return this.close(event)
            }

            if (this._trigger('search', event) === false) {
              return
            }

            return this._search(value)
          },

          _search: function (value) {
            this.pending++
            this._addClass('ui-autocomplete-loading')
            this.cancelSearch = false

            this.source({ term: value }, this._response())
          },

          _response: function () {
            var index = ++this.requestIndex

            return function (content) {
              if (index === this.requestIndex) {
                this.__response(content)
              }

              this.pending--
              if (!this.pending) {
                this._removeClass('ui-autocomplete-loading')
              }
            }.bind(this)
          },

          __response: function (content) {
            if (content) {
              content = this._normalize(content)
            }
            this._trigger('response', null, { content: content })
            if (
              !this.options.disabled &&
              content &&
              content.length &&
              !this.cancelSearch
            ) {
              this._suggest(content)
              this._trigger('open')
            } else {
              // use ._close() instead of .close() so we don't cancel future searches
              this._close()
            }
          },

          close: function (event) {
            this.cancelSearch = true
            this._close(event)
          },

          _close: function (event) {
            // Remove the handler that closes the menu on outside clicks
            this._off(this.document, 'mousedown')

            if (this.menu.element.is(':visible')) {
              this.menu.element.hide()
              this.menu.blur()
              this.isNewMenu = true
              this._trigger('close', event)
            }
          },

          _change: function (event) {
            if (this.previous !== this._value()) {
              this._trigger('change', event, { item: this.selectedItem })
            }
          },

          _normalize: function (items) {
            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
              return items
            }
            return $.map(items, function (item) {
              if (typeof item === 'string') {
                return {
                  label: item,
                  value: item
                }
              }
              return $.extend({}, item, {
                label: item.label || item.value,
                value: item.value || item.label
              })
            })
          },

          _suggest: function (items) {
            var ul = this.menu.element.empty()
            this._renderMenu(ul, items)
            this.isNewMenu = true
            this.menu.refresh()

            // Size and position menu
            ul.show()
            this._resizeMenu()
            ul.position(
              $.extend(
                {
                  of: this.element
                },
                this.options.position
              )
            )

            if (this.options.autoFocus) {
              this.menu.next()
            }

            // Listen for interactions outside of the widget (#6642)
            this._on(this.document, {
              mousedown: '_closeOnClickOutside'
            })
          },

          _resizeMenu: function () {
            var ul = this.menu.element
            ul.outerWidth(
              Math.max(
                // Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width('').outerWidth() + 1,
                this.element.outerWidth()
              )
            )
          },

          _renderMenu: function (ul, items) {
            var that = this
            $.each(items, function (index, item) {
              that._renderItemData(ul, item)
            })
          },

          _renderItemData: function (ul, item) {
            return this._renderItem(ul, item).data('ui-autocomplete-item', item)
          },

          _renderItem: function (ul, item) {
            return $('<li>').append($('<div>').text(item.label)).appendTo(ul)
          },

          _move: function (direction, event) {
            if (!this.menu.element.is(':visible')) {
              this.search(null, event)
              return
            }
            if (
              (this.menu.isFirstItem() && /^previous/.test(direction)) ||
              (this.menu.isLastItem() && /^next/.test(direction))
            ) {
              if (!this.isMultiLine) {
                this._value(this.term)
              }

              this.menu.blur()
              return
            }
            this.menu[direction](event)
          },

          widget: function () {
            return this.menu.element
          },

          _value: function () {
            return this.valueMethod.apply(this.element, arguments)
          },

          _keyEvent: function (keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(':visible')) {
              this._move(keyEvent, event)

              // Prevents moving cursor to beginning/end of the text field in some browsers
              event.preventDefault()
            }
          },

          // Support: Chrome <=50
          // We should be able to just use this.element.prop( "isContentEditable" )
          // but hidden elements always report false in Chrome.
          // https://code.google.com/p/chromium/issues/detail?id=313082
          _isContentEditable: function (element) {
            if (!element.length) {
              return false
            }

            var editable = element.prop('contentEditable')

            if (editable === 'inherit') {
              return this._isContentEditable(element.parent())
            }

            return editable === 'true'
          }
        })

        $.extend($.ui.autocomplete, {
          escapeRegex: function (value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
          },
          filter: function (array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), 'i')
            return $.grep(array, function (value) {
              return matcher.test(value.label || value.value || value)
            })
          }
        })

        // Live region extension, adding a `messages` option
        // NOTE: This is an experimental API. We are still investigating
        // a full solution for string manipulation and internationalization.
        $.widget('ui.autocomplete', $.ui.autocomplete, {
          options: {
            messages: {
              noResults: 'No search results.',
              results: function (amount) {
                return (
                  amount +
                  (amount > 1 ? ' results are' : ' result is') +
                  ' available, use up and down arrow keys to navigate.'
                )
              }
            }
          },

          __response: function (content) {
            var message
            this._superApply(arguments)
            if (this.options.disabled || this.cancelSearch) {
              return
            }
            if (content && content.length) {
              message = this.options.messages.results(content.length)
            } else {
              message = this.options.messages.noResults
            }
            clearTimeout(this.liveRegionTimer)
            this.liveRegionTimer = this._delay(function () {
              this.liveRegion.html($('<div>').text(message))
            }, 100)
          }
        })

        return $.ui.autocomplete
      })

      /***/
    },

    /***/ 9366: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Button 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Button
      //>>group: Widgets
      //>>description: Enhances a form with themeable buttons.
      //>>docs: http://api.jqueryui.com/button/
      //>>demos: http://jqueryui.com/button/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/button.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),

            // These are only for backcompat
            // TODO: Remove after 1.12
            __webpack_require__(341),
            __webpack_require__(1193),

            __webpack_require__(7053),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.button', {
          version: '1.13.1',
          defaultElement: '<button>',
          options: {
            classes: {
              'ui-button': 'ui-corner-all'
            },
            disabled: null,
            icon: null,
            iconPosition: 'beginning',
            label: null,
            showLabel: true
          },

          _getCreateOptions: function () {
            var disabled,
              // This is to support cases like in jQuery Mobile where the base widget does have
              // an implementation of _getCreateOptions
              options = this._super() || {}

            this.isInput = this.element.is('input')

            disabled = this.element[0].disabled
            if (disabled != null) {
              options.disabled = disabled
            }

            this.originalLabel = this.isInput
              ? this.element.val()
              : this.element.html()
            if (this.originalLabel) {
              options.label = this.originalLabel
            }

            return options
          },

          _create: function () {
            if (!this.option.showLabel & !this.options.icon) {
              this.options.showLabel = true
            }

            // We have to check the option again here even though we did in _getCreateOptions,
            // because null may have been passed on init which would override what was set in
            // _getCreateOptions
            if (this.options.disabled == null) {
              this.options.disabled = this.element[0].disabled || false
            }

            this.hasTitle = !!this.element.attr('title')

            // Check to see if the label needs to be set or if its already correct
            if (
              this.options.label &&
              this.options.label !== this.originalLabel
            ) {
              if (this.isInput) {
                this.element.val(this.options.label)
              } else {
                this.element.html(this.options.label)
              }
            }
            this._addClass('ui-button', 'ui-widget')
            this._setOption('disabled', this.options.disabled)
            this._enhance()

            if (this.element.is('a')) {
              this._on({
                keyup: function (event) {
                  if (event.keyCode === $.ui.keyCode.SPACE) {
                    event.preventDefault()

                    // Support: PhantomJS <= 1.9, IE 8 Only
                    // If a native click is available use it so we actually cause navigation
                    // otherwise just trigger a click event
                    if (this.element[0].click) {
                      this.element[0].click()
                    } else {
                      this.element.trigger('click')
                    }
                  }
                }
              })
            }
          },

          _enhance: function () {
            if (!this.element.is('button')) {
              this.element.attr('role', 'button')
            }

            if (this.options.icon) {
              this._updateIcon('icon', this.options.icon)
              this._updateTooltip()
            }
          },

          _updateTooltip: function () {
            this.title = this.element.attr('title')

            if (!this.options.showLabel && !this.title) {
              this.element.attr('title', this.options.label)
            }
          },

          _updateIcon: function (option, value) {
            var icon = option !== 'iconPosition',
              position = icon ? this.options.iconPosition : value,
              displayBlock = position === 'top' || position === 'bottom'

            // Create icon
            if (!this.icon) {
              this.icon = $('<span>')

              this._addClass(this.icon, 'ui-button-icon', 'ui-icon')

              if (!this.options.showLabel) {
                this._addClass('ui-button-icon-only')
              }
            } else if (icon) {
              // If we are updating the icon remove the old icon class
              this._removeClass(this.icon, null, this.options.icon)
            }

            // If we are updating the icon add the new icon class
            if (icon) {
              this._addClass(this.icon, null, value)
            }

            this._attachIcon(position)

            // If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
            // the iconSpace if there is one.
            if (displayBlock) {
              this._addClass(this.icon, null, 'ui-widget-icon-block')
              if (this.iconSpace) {
                this.iconSpace.remove()
              }
            } else {
              // Position is beginning or end so remove the ui-widget-icon-block class and add the
              // space if it does not exist
              if (!this.iconSpace) {
                this.iconSpace = $('<span> </span>')
                this._addClass(this.iconSpace, 'ui-button-icon-space')
              }
              this._removeClass(this.icon, null, 'ui-wiget-icon-block')
              this._attachIconSpace(position)
            }
          },

          _destroy: function () {
            this.element.removeAttr('role')

            if (this.icon) {
              this.icon.remove()
            }
            if (this.iconSpace) {
              this.iconSpace.remove()
            }
            if (!this.hasTitle) {
              this.element.removeAttr('title')
            }
          },

          _attachIconSpace: function (iconPosition) {
            this.icon[
              /^(?:end|bottom)/.test(iconPosition) ? 'before' : 'after'
            ](this.iconSpace)
          },

          _attachIcon: function (iconPosition) {
            this.element[
              /^(?:end|bottom)/.test(iconPosition) ? 'append' : 'prepend'
            ](this.icon)
          },

          _setOptions: function (options) {
            var newShowLabel =
                options.showLabel === undefined
                  ? this.options.showLabel
                  : options.showLabel,
              newIcon =
                options.icon === undefined ? this.options.icon : options.icon

            if (!newShowLabel && !newIcon) {
              options.showLabel = true
            }
            this._super(options)
          },

          _setOption: function (key, value) {
            if (key === 'icon') {
              if (value) {
                this._updateIcon(key, value)
              } else if (this.icon) {
                this.icon.remove()
                if (this.iconSpace) {
                  this.iconSpace.remove()
                }
              }
            }

            if (key === 'iconPosition') {
              this._updateIcon(key, value)
            }

            // Make sure we can't end up with a button that has neither text nor icon
            if (key === 'showLabel') {
              this._toggleClass('ui-button-icon-only', null, !value)
              this._updateTooltip()
            }

            if (key === 'label') {
              if (this.isInput) {
                this.element.val(value)
              } else {
                // If there is an icon, append it, else nothing then append the value
                // this avoids removal of the icon when setting label text
                this.element.html(value)
                if (this.icon) {
                  this._attachIcon(this.options.iconPosition)
                  this._attachIconSpace(this.options.iconPosition)
                }
              }
            }

            this._super(key, value)

            if (key === 'disabled') {
              this._toggleClass(null, 'ui-state-disabled', value)
              this.element[0].disabled = value
              if (value) {
                this.element.trigger('blur')
              }
            }
          },

          refresh: function () {
            // Make sure to only check disabled if its an element that supports this otherwise
            // check for the disabled class to determine state
            var isDisabled = this.element.is('input, button')
              ? this.element[0].disabled
              : this.element.hasClass('ui-button-disabled')

            if (isDisabled !== this.options.disabled) {
              this._setOptions({ disabled: isDisabled })
            }

            this._updateTooltip()
          }
        })

        // DEPRECATED
        if ($.uiBackCompat !== false) {
          // Text and Icons options
          $.widget('ui.button', $.ui.button, {
            options: {
              text: true,
              icons: {
                primary: null,
                secondary: null
              }
            },

            _create: function () {
              if (this.options.showLabel && !this.options.text) {
                this.options.showLabel = this.options.text
              }
              if (!this.options.showLabel && this.options.text) {
                this.options.text = this.options.showLabel
              }
              if (
                !this.options.icon &&
                (this.options.icons.primary || this.options.icons.secondary)
              ) {
                if (this.options.icons.primary) {
                  this.options.icon = this.options.icons.primary
                } else {
                  this.options.icon = this.options.icons.secondary
                  this.options.iconPosition = 'end'
                }
              } else if (this.options.icon) {
                this.options.icons.primary = this.options.icon
              }
              this._super()
            },

            _setOption: function (key, value) {
              if (key === 'text') {
                this._super('showLabel', value)
                return
              }
              if (key === 'showLabel') {
                this.options.text = value
              }
              if (key === 'icon') {
                this.options.icons.primary = value
              }
              if (key === 'icons') {
                if (value.primary) {
                  this._super('icon', value.primary)
                  this._super('iconPosition', 'beginning')
                } else if (value.secondary) {
                  this._super('icon', value.secondary)
                  this._super('iconPosition', 'end')
                }
              }
              this._superApply(arguments)
            }
          })

          $.fn.button = (function (orig) {
            return function (options) {
              var isMethodCall = typeof options === 'string'
              var args = Array.prototype.slice.call(arguments, 1)
              var returnValue = this

              if (isMethodCall) {
                // If this is an empty collection, we need to have the instance method
                // return undefined instead of the jQuery instance
                if (!this.length && options === 'instance') {
                  returnValue = undefined
                } else {
                  this.each(function () {
                    var methodValue
                    var type = $(this).attr('type')
                    var name =
                      type !== 'checkbox' && type !== 'radio'
                        ? 'button'
                        : 'checkboxradio'
                    var instance = $.data(this, 'ui-' + name)

                    if (options === 'instance') {
                      returnValue = instance
                      return false
                    }

                    if (!instance) {
                      return $.error(
                        'cannot call methods on button' +
                          ' prior to initialization; ' +
                          "attempted to call method '" +
                          options +
                          "'"
                      )
                    }

                    if (
                      typeof instance[options] !== 'function' ||
                      options.charAt(0) === '_'
                    ) {
                      return $.error(
                        "no such method '" +
                          options +
                          "' for button" +
                          ' widget instance'
                      )
                    }

                    methodValue = instance[options].apply(instance, args)

                    if (methodValue !== instance && methodValue !== undefined) {
                      returnValue =
                        methodValue && methodValue.jquery
                          ? returnValue.pushStack(methodValue.get())
                          : methodValue
                      return false
                    }
                  })
                }
              } else {
                // Allow multiple hashes to be passed on init
                if (args.length) {
                  options = $.widget.extend.apply(null, [options].concat(args))
                }

                this.each(function () {
                  var type = $(this).attr('type')
                  var name =
                    type !== 'checkbox' && type !== 'radio'
                      ? 'button'
                      : 'checkboxradio'
                  var instance = $.data(this, 'ui-' + name)

                  if (instance) {
                    instance.option(options || {})
                    if (instance._init) {
                      instance._init()
                    }
                  } else {
                    if (name === 'button') {
                      orig.call($(this), options)
                      return
                    }

                    $(this).checkboxradio($.extend({ icon: false }, options))
                  }
                })
              }

              return returnValue
            }
          })($.fn.button)

          $.fn.buttonset = function () {
            if (!$.ui.controlgroup) {
              $.error('Controlgroup widget missing')
            }
            if (
              arguments[0] === 'option' &&
              arguments[1] === 'items' &&
              arguments[2]
            ) {
              return this.controlgroup.apply(this, [
                arguments[0],
                'items.button',
                arguments[2]
              ])
            }
            if (arguments[0] === 'option' && arguments[1] === 'items') {
              return this.controlgroup.apply(this, [
                arguments[0],
                'items.button'
              ])
            }
            if (typeof arguments[0] === 'object' && arguments[0].items) {
              arguments[0].items = {
                button: arguments[0].items
              }
            }
            return this.controlgroup.apply(this, arguments)
          }
        }

        return $.ui.button
      })

      /***/
    },

    /***/ 1193: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Checkboxradio 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Checkboxradio
      //>>group: Widgets
      //>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
      //>>docs: http://api.jqueryui.com/checkboxradio/
      //>>demos: http://jqueryui.com/checkboxradio/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/button.css
      //>>css.structure: ../../themes/base/checkboxradio.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(7808),
            __webpack_require__(6575),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.checkboxradio', [
          $.ui.formResetMixin,
          {
            version: '1.13.1',
            options: {
              disabled: null,
              label: null,
              icon: true,
              classes: {
                'ui-checkboxradio-label': 'ui-corner-all',
                'ui-checkboxradio-icon': 'ui-corner-all'
              }
            },

            _getCreateOptions: function () {
              var disabled, labels
              var that = this
              var options = this._super() || {}

              // We read the type here, because it makes more sense to throw a element type error first,
              // rather then the error for lack of a label. Often if its the wrong type, it
              // won't have a label (e.g. calling on a div, btn, etc)
              this._readType()

              labels = this.element.labels()

              // If there are multiple labels, use the last one
              this.label = $(labels[labels.length - 1])
              if (!this.label.length) {
                $.error('No label found for checkboxradio widget')
              }

              this.originalLabel = ''

              // We need to get the label text but this may also need to make sure it does not contain the
              // input itself.
              this.label
                .contents()
                .not(this.element[0])
                .each(function () {
                  // The label contents could be text, html, or a mix. We concat each element to get a
                  // string representation of the label, without the input as part of it.
                  that.originalLabel +=
                    this.nodeType === 3 ? $(this).text() : this.outerHTML
                })

              // Set the label option if we found label text
              if (this.originalLabel) {
                options.label = this.originalLabel
              }

              disabled = this.element[0].disabled
              if (disabled != null) {
                options.disabled = disabled
              }
              return options
            },

            _create: function () {
              var checked = this.element[0].checked

              this._bindFormResetHandler()

              if (this.options.disabled == null) {
                this.options.disabled = this.element[0].disabled
              }

              this._setOption('disabled', this.options.disabled)
              this._addClass('ui-checkboxradio', 'ui-helper-hidden-accessible')
              this._addClass(
                this.label,
                'ui-checkboxradio-label',
                'ui-button ui-widget'
              )

              if (this.type === 'radio') {
                this._addClass(this.label, 'ui-checkboxradio-radio-label')
              }

              if (
                this.options.label &&
                this.options.label !== this.originalLabel
              ) {
                this._updateLabel()
              } else if (this.originalLabel) {
                this.options.label = this.originalLabel
              }

              this._enhance()

              if (checked) {
                this._addClass(
                  this.label,
                  'ui-checkboxradio-checked',
                  'ui-state-active'
                )
              }

              this._on({
                change: '_toggleClasses',
                focus: function () {
                  this._addClass(
                    this.label,
                    null,
                    'ui-state-focus ui-visual-focus'
                  )
                },
                blur: function () {
                  this._removeClass(
                    this.label,
                    null,
                    'ui-state-focus ui-visual-focus'
                  )
                }
              })
            },

            _readType: function () {
              var nodeName = this.element[0].nodeName.toLowerCase()
              this.type = this.element[0].type
              if (nodeName !== 'input' || !/radio|checkbox/.test(this.type)) {
                $.error(
                  "Can't create checkboxradio on element.nodeName=" +
                    nodeName +
                    ' and element.type=' +
                    this.type
                )
              }
            },

            // Support jQuery Mobile enhanced option
            _enhance: function () {
              this._updateIcon(this.element[0].checked)
            },

            widget: function () {
              return this.label
            },

            _getRadioGroup: function () {
              var group
              var name = this.element[0].name
              var nameSelector = "input[name='" + $.escapeSelector(name) + "']"

              if (!name) {
                return $([])
              }

              if (this.form.length) {
                group = $(this.form[0].elements).filter(nameSelector)
              } else {
                // Not inside a form, check all inputs that also are not inside a form
                group = $(nameSelector).filter(function () {
                  return $(this)._form().length === 0
                })
              }

              return group.not(this.element)
            },

            _toggleClasses: function () {
              var checked = this.element[0].checked
              this._toggleClass(
                this.label,
                'ui-checkboxradio-checked',
                'ui-state-active',
                checked
              )

              if (this.options.icon && this.type === 'checkbox') {
                this._toggleClass(
                  this.icon,
                  null,
                  'ui-icon-check ui-state-checked',
                  checked
                )._toggleClass(this.icon, null, 'ui-icon-blank', !checked)
              }

              if (this.type === 'radio') {
                this._getRadioGroup().each(function () {
                  var instance = $(this).checkboxradio('instance')

                  if (instance) {
                    instance._removeClass(
                      instance.label,
                      'ui-checkboxradio-checked',
                      'ui-state-active'
                    )
                  }
                })
              }
            },

            _destroy: function () {
              this._unbindFormResetHandler()

              if (this.icon) {
                this.icon.remove()
                this.iconSpace.remove()
              }
            },

            _setOption: function (key, value) {
              // We don't allow the value to be set to nothing
              if (key === 'label' && !value) {
                return
              }

              this._super(key, value)

              if (key === 'disabled') {
                this._toggleClass(this.label, null, 'ui-state-disabled', value)
                this.element[0].disabled = value

                // Don't refresh when setting disabled
                return
              }
              this.refresh()
            },

            _updateIcon: function (checked) {
              var toAdd = 'ui-icon ui-icon-background '

              if (this.options.icon) {
                if (!this.icon) {
                  this.icon = $('<span>')
                  this.iconSpace = $('<span> </span>')
                  this._addClass(this.iconSpace, 'ui-checkboxradio-icon-space')
                }

                if (this.type === 'checkbox') {
                  toAdd += checked
                    ? 'ui-icon-check ui-state-checked'
                    : 'ui-icon-blank'
                  this._removeClass(
                    this.icon,
                    null,
                    checked ? 'ui-icon-blank' : 'ui-icon-check'
                  )
                } else {
                  toAdd += 'ui-icon-blank'
                }
                this._addClass(this.icon, 'ui-checkboxradio-icon', toAdd)
                if (!checked) {
                  this._removeClass(
                    this.icon,
                    null,
                    'ui-icon-check ui-state-checked'
                  )
                }
                this.icon.prependTo(this.label).after(this.iconSpace)
              } else if (this.icon !== undefined) {
                this.icon.remove()
                this.iconSpace.remove()
                delete this.icon
              }
            },

            _updateLabel: function () {
              // Remove the contents of the label ( minus the icon, icon space, and input )
              var contents = this.label.contents().not(this.element[0])
              if (this.icon) {
                contents = contents.not(this.icon[0])
              }
              if (this.iconSpace) {
                contents = contents.not(this.iconSpace[0])
              }
              contents.remove()

              this.label.append(this.options.label)
            },

            refresh: function () {
              var checked = this.element[0].checked,
                isDisabled = this.element[0].disabled

              this._updateIcon(checked)
              this._toggleClass(
                this.label,
                'ui-checkboxradio-checked',
                'ui-state-active',
                checked
              )
              if (this.options.label !== null) {
                this._updateLabel()
              }

              if (isDisabled !== this.options.disabled) {
                this._setOptions({ disabled: isDisabled })
              }
            }
          }
        ])

        return $.ui.checkboxradio
      })

      /***/
    },

    /***/ 341: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Controlgroup 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Controlgroup
      //>>group: Widgets
      //>>description: Visually groups form control widgets
      //>>docs: http://api.jqueryui.com/controlgroup/
      //>>demos: http://jqueryui.com/controlgroup/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/controlgroup.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g

        return $.widget('ui.controlgroup', {
          version: '1.13.1',
          defaultElement: '<div>',
          options: {
            direction: 'horizontal',
            disabled: null,
            onlyVisible: true,
            items: {
              button:
                'input[type=button], input[type=submit], input[type=reset], button, a',
              controlgroupLabel: '.ui-controlgroup-label',
              checkboxradio: "input[type='checkbox'], input[type='radio']",
              selectmenu: 'select',
              spinner: '.ui-spinner-input'
            }
          },

          _create: function () {
            this._enhance()
          },

          // To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
          _enhance: function () {
            this.element.attr('role', 'toolbar')
            this.refresh()
          },

          _destroy: function () {
            this._callChildMethod('destroy')
            this.childWidgets.removeData('ui-controlgroup-data')
            this.element.removeAttr('role')
            if (this.options.items.controlgroupLabel) {
              this.element
                .find(this.options.items.controlgroupLabel)
                .find('.ui-controlgroup-label-contents')
                .contents()
                .unwrap()
            }
          },

          _initWidgets: function () {
            var that = this,
              childWidgets = []

            // First we iterate over each of the items options
            $.each(this.options.items, function (widget, selector) {
              var labels
              var options = {}

              // Make sure the widget has a selector set
              if (!selector) {
                return
              }

              if (widget === 'controlgroupLabel') {
                labels = that.element.find(selector)
                labels.each(function () {
                  var element = $(this)

                  if (
                    element.children('.ui-controlgroup-label-contents').length
                  ) {
                    return
                  }
                  element
                    .contents()
                    .wrapAll(
                      "<span class='ui-controlgroup-label-contents'></span>"
                    )
                })
                that._addClass(
                  labels,
                  null,
                  'ui-widget ui-widget-content ui-state-default'
                )
                childWidgets = childWidgets.concat(labels.get())
                return
              }

              // Make sure the widget actually exists
              if (!$.fn[widget]) {
                return
              }

              // We assume everything is in the middle to start because we can't determine
              // first / last elements until all enhancments are done.
              if (that['_' + widget + 'Options']) {
                options = that['_' + widget + 'Options']('middle')
              } else {
                options = { classes: {} }
              }

              // Find instances of this widget inside controlgroup and init them
              that.element.find(selector).each(function () {
                var element = $(this)
                var instance = element[widget]('instance')

                // We need to clone the default options for this type of widget to avoid
                // polluting the variable options which has a wider scope than a single widget.
                var instanceOptions = $.widget.extend({}, options)

                // If the button is the child of a spinner ignore it
                // TODO: Find a more generic solution
                if (
                  widget === 'button' &&
                  element.parent('.ui-spinner').length
                ) {
                  return
                }

                // Create the widget if it doesn't exist
                if (!instance) {
                  instance = element[widget]()[widget]('instance')
                }
                if (instance) {
                  instanceOptions.classes = that._resolveClassesValues(
                    instanceOptions.classes,
                    instance
                  )
                }
                element[widget](instanceOptions)

                // Store an instance of the controlgroup to be able to reference
                // from the outermost element for changing options and refresh
                var widgetElement = element[widget]('widget')
                $.data(
                  widgetElement[0],
                  'ui-controlgroup-data',
                  instance ? instance : element[widget]('instance')
                )

                childWidgets.push(widgetElement[0])
              })
            })

            this.childWidgets = $($.uniqueSort(childWidgets))
            this._addClass(this.childWidgets, 'ui-controlgroup-item')
          },

          _callChildMethod: function (method) {
            this.childWidgets.each(function () {
              var element = $(this),
                data = element.data('ui-controlgroup-data')
              if (data && data[method]) {
                data[method]()
              }
            })
          },

          _updateCornerClass: function (element, position) {
            var remove =
              'ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all'
            var add = this._buildSimpleOptions(position, 'label').classes.label

            this._removeClass(element, null, remove)
            this._addClass(element, null, add)
          },

          _buildSimpleOptions: function (position, key) {
            var direction = this.options.direction === 'vertical'
            var result = {
              classes: {}
            }
            result.classes[key] = {
              middle: '',
              first: 'ui-corner-' + (direction ? 'top' : 'left'),
              last: 'ui-corner-' + (direction ? 'bottom' : 'right'),
              only: 'ui-corner-all'
            }[position]

            return result
          },

          _spinnerOptions: function (position) {
            var options = this._buildSimpleOptions(position, 'ui-spinner')

            options.classes['ui-spinner-up'] = ''
            options.classes['ui-spinner-down'] = ''

            return options
          },

          _buttonOptions: function (position) {
            return this._buildSimpleOptions(position, 'ui-button')
          },

          _checkboxradioOptions: function (position) {
            return this._buildSimpleOptions(position, 'ui-checkboxradio-label')
          },

          _selectmenuOptions: function (position) {
            var direction = this.options.direction === 'vertical'
            return {
              width: direction ? 'auto' : false,
              classes: {
                middle: {
                  'ui-selectmenu-button-open': '',
                  'ui-selectmenu-button-closed': ''
                },
                first: {
                  'ui-selectmenu-button-open':
                    'ui-corner-' + (direction ? 'top' : 'tl'),
                  'ui-selectmenu-button-closed':
                    'ui-corner-' + (direction ? 'top' : 'left')
                },
                last: {
                  'ui-selectmenu-button-open': direction ? '' : 'ui-corner-tr',
                  'ui-selectmenu-button-closed':
                    'ui-corner-' + (direction ? 'bottom' : 'right')
                },
                only: {
                  'ui-selectmenu-button-open': 'ui-corner-top',
                  'ui-selectmenu-button-closed': 'ui-corner-all'
                }
              }[position]
            }
          },

          _resolveClassesValues: function (classes, instance) {
            var result = {}
            $.each(classes, function (key) {
              var current = instance.options.classes[key] || ''
              current = String.prototype.trim.call(
                current.replace(controlgroupCornerRegex, '')
              )
              result[key] = (current + ' ' + classes[key]).replace(/\s+/g, ' ')
            })
            return result
          },

          _setOption: function (key, value) {
            if (key === 'direction') {
              this._removeClass('ui-controlgroup-' + this.options.direction)
            }

            this._super(key, value)
            if (key === 'disabled') {
              this._callChildMethod(value ? 'disable' : 'enable')
              return
            }

            this.refresh()
          },

          refresh: function () {
            var children,
              that = this

            this._addClass(
              'ui-controlgroup ui-controlgroup-' + this.options.direction
            )

            if (this.options.direction === 'horizontal') {
              this._addClass(null, 'ui-helper-clearfix')
            }
            this._initWidgets()

            children = this.childWidgets

            // We filter here because we need to track all childWidgets not just the visible ones
            if (this.options.onlyVisible) {
              children = children.filter(':visible')
            }

            if (children.length) {
              // We do this last because we need to make sure all enhancment is done
              // before determining first and last
              $.each(['first', 'last'], function (index, value) {
                var instance = children[value]().data('ui-controlgroup-data')

                if (instance && that['_' + instance.widgetName + 'Options']) {
                  var options = that['_' + instance.widgetName + 'Options'](
                    children.length === 1 ? 'only' : value
                  )
                  options.classes = that._resolveClassesValues(
                    options.classes,
                    instance
                  )
                  instance.element[instance.widgetName](options)
                } else {
                  that._updateCornerClass(children[value](), value)
                }
              })

              // Finally call the refresh method on each of the child widgets.
              this._callChildMethod('refresh')
            }
          }
        })
      })

      /***/
    },

    /***/ 2466: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Dialog 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Dialog
      //>>group: Widgets
      //>>description: Displays customizable dialog windows.
      //>>docs: http://api.jqueryui.com/dialog/
      //>>demos: http://jqueryui.com/dialog/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/dialog.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(9366),
            __webpack_require__(7285),
            __webpack_require__(6177),
            __webpack_require__(1707),
            __webpack_require__(5436),
            __webpack_require__(7053),
            __webpack_require__(1822),
            __webpack_require__(1440),
            __webpack_require__(192),
            __webpack_require__(3614),
            __webpack_require__(9138),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.dialog', {
          version: '1.13.1',
          options: {
            appendTo: 'body',
            autoOpen: true,
            buttons: [],
            classes: {
              'ui-dialog': 'ui-corner-all',
              'ui-dialog-titlebar': 'ui-corner-all'
            },
            closeOnEscape: true,
            closeText: 'Close',
            draggable: true,
            hide: null,
            height: 'auto',
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
              my: 'center',
              at: 'center',
              of: window,
              collision: 'fit',

              // Ensure the titlebar is always visible
              using: function (pos) {
                var topOffset = $(this).css(pos).offset().top
                if (topOffset < 0) {
                  $(this).css('top', pos.top - topOffset)
                }
              }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,

            // Callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
          },

          sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
          },

          resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
          },

          _create: function () {
            this.originalCss = {
              display: this.element[0].style.display,
              width: this.element[0].style.width,
              minHeight: this.element[0].style.minHeight,
              maxHeight: this.element[0].style.maxHeight,
              height: this.element[0].style.height
            }
            this.originalPosition = {
              parent: this.element.parent(),
              index: this.element.parent().children().index(this.element)
            }
            this.originalTitle = this.element.attr('title')
            if (this.options.title == null && this.originalTitle != null) {
              this.options.title = this.originalTitle
            }

            // Dialogs can't be disabled
            if (this.options.disabled) {
              this.options.disabled = false
            }

            this._createWrapper()

            this.element.show().removeAttr('title').appendTo(this.uiDialog)

            this._addClass('ui-dialog-content', 'ui-widget-content')

            this._createTitlebar()
            this._createButtonPane()

            if (this.options.draggable && $.fn.draggable) {
              this._makeDraggable()
            }
            if (this.options.resizable && $.fn.resizable) {
              this._makeResizable()
            }

            this._isOpen = false

            this._trackFocus()
          },

          _init: function () {
            if (this.options.autoOpen) {
              this.open()
            }
          },

          _appendTo: function () {
            var element = this.options.appendTo
            if (element && (element.jquery || element.nodeType)) {
              return $(element)
            }
            return this.document.find(element || 'body').eq(0)
          },

          _destroy: function () {
            var next,
              originalPosition = this.originalPosition

            this._untrackInstance()
            this._destroyOverlay()

            this.element
              .removeUniqueId()
              .css(this.originalCss)

              // Without detaching first, the following becomes really slow
              .detach()

            this.uiDialog.remove()

            if (this.originalTitle) {
              this.element.attr('title', this.originalTitle)
            }

            next = originalPosition.parent.children().eq(originalPosition.index)

            // Don't try to place the dialog next to itself (#8613)
            if (next.length && next[0] !== this.element[0]) {
              next.before(this.element)
            } else {
              originalPosition.parent.append(this.element)
            }
          },

          widget: function () {
            return this.uiDialog
          },

          disable: $.noop,
          enable: $.noop,

          close: function (event) {
            var that = this

            if (
              !this._isOpen ||
              this._trigger('beforeClose', event) === false
            ) {
              return
            }

            this._isOpen = false
            this._focusedElement = null
            this._destroyOverlay()
            this._untrackInstance()

            if (!this.opener.filter(':focusable').trigger('focus').length) {
              // Hiding a focused element doesn't trigger blur in WebKit
              // so in case we have nothing to focus on, explicitly blur the active element
              // https://bugs.webkit.org/show_bug.cgi?id=47182
              $.ui.safeBlur($.ui.safeActiveElement(this.document[0]))
            }

            this._hide(this.uiDialog, this.options.hide, function () {
              that._trigger('close', event)
            })
          },

          isOpen: function () {
            return this._isOpen
          },

          moveToTop: function () {
            this._moveToTop()
          },

          _moveToTop: function (event, silent) {
            var moved = false,
              zIndices = this.uiDialog
                .siblings('.ui-front:visible')
                .map(function () {
                  return +$(this).css('z-index')
                })
                .get(),
              zIndexMax = Math.max.apply(null, zIndices)

            if (zIndexMax >= +this.uiDialog.css('z-index')) {
              this.uiDialog.css('z-index', zIndexMax + 1)
              moved = true
            }

            if (moved && !silent) {
              this._trigger('focus', event)
            }
            return moved
          },

          open: function () {
            var that = this
            if (this._isOpen) {
              if (this._moveToTop()) {
                this._focusTabbable()
              }
              return
            }

            this._isOpen = true
            this.opener = $($.ui.safeActiveElement(this.document[0]))

            this._size()
            this._position()
            this._createOverlay()
            this._moveToTop(null, true)

            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            if (this.overlay) {
              this.overlay.css('z-index', this.uiDialog.css('z-index') - 1)
            }

            this._show(this.uiDialog, this.options.show, function () {
              that._focusTabbable()
              that._trigger('focus')
            })

            // Track the dialog immediately upon opening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            this._makeFocusTarget()

            this._trigger('open')
          },

          _focusTabbable: function () {
            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement
            if (!hasFocus) {
              hasFocus = this.element.find('[autofocus]')
            }
            if (!hasFocus.length) {
              hasFocus = this.element.find(':tabbable')
            }
            if (!hasFocus.length) {
              hasFocus = this.uiDialogButtonPane.find(':tabbable')
            }
            if (!hasFocus.length) {
              hasFocus = this.uiDialogTitlebarClose.filter(':tabbable')
            }
            if (!hasFocus.length) {
              hasFocus = this.uiDialog
            }
            hasFocus.eq(0).trigger('focus')
          },

          _restoreTabbableFocus: function () {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
              isActive =
                this.uiDialog[0] === activeElement ||
                $.contains(this.uiDialog[0], activeElement)
            if (!isActive) {
              this._focusTabbable()
            }
          },

          _keepFocus: function (event) {
            event.preventDefault()
            this._restoreTabbableFocus()

            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(this._restoreTabbableFocus)
          },

          _createWrapper: function () {
            this.uiDialog = $('<div>')
              .hide()
              .attr({
                // Setting tabIndex makes the div focusable
                tabIndex: -1,
                role: 'dialog'
              })
              .appendTo(this._appendTo())

            this._addClass(
              this.uiDialog,
              'ui-dialog',
              'ui-widget ui-widget-content ui-front'
            )
            this._on(this.uiDialog, {
              keydown: function (event) {
                if (
                  this.options.closeOnEscape &&
                  !event.isDefaultPrevented() &&
                  event.keyCode &&
                  event.keyCode === $.ui.keyCode.ESCAPE
                ) {
                  event.preventDefault()
                  this.close(event)
                  return
                }

                // Prevent tabbing out of dialogs
                if (
                  event.keyCode !== $.ui.keyCode.TAB ||
                  event.isDefaultPrevented()
                ) {
                  return
                }
                var tabbables = this.uiDialog.find(':tabbable'),
                  first = tabbables.first(),
                  last = tabbables.last()

                if (
                  (event.target === last[0] ||
                    event.target === this.uiDialog[0]) &&
                  !event.shiftKey
                ) {
                  this._delay(function () {
                    first.trigger('focus')
                  })
                  event.preventDefault()
                } else if (
                  (event.target === first[0] ||
                    event.target === this.uiDialog[0]) &&
                  event.shiftKey
                ) {
                  this._delay(function () {
                    last.trigger('focus')
                  })
                  event.preventDefault()
                }
              },
              mousedown: function (event) {
                if (this._moveToTop(event)) {
                  this._focusTabbable()
                }
              }
            })

            // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            if (!this.element.find('[aria-describedby]').length) {
              this.uiDialog.attr({
                'aria-describedby': this.element.uniqueId().attr('id')
              })
            }
          },

          _createTitlebar: function () {
            var uiDialogTitle

            this.uiDialogTitlebar = $('<div>')
            this._addClass(
              this.uiDialogTitlebar,
              'ui-dialog-titlebar',
              'ui-widget-header ui-helper-clearfix'
            )
            this._on(this.uiDialogTitlebar, {
              mousedown: function (event) {
                // Don't prevent click on close button (#8838)
                // Focusing a dialog that is partially scrolled out of view
                // causes the browser to scroll it into view, preventing the click event
                if (!$(event.target).closest('.ui-dialog-titlebar-close')) {
                  // Dialog isn't getting focus when dragging (#8063)
                  this.uiDialog.trigger('focus')
                }
              }
            })

            // Support: IE
            // Use type="button" to prevent enter keypresses in textboxes from closing the
            // dialog in IE (#9312)
            this.uiDialogTitlebarClose = $("<button type='button'></button>")
              .button({
                label: $('<a>').text(this.options.closeText).html(),
                icon: 'ui-icon-closethick',
                showLabel: false
              })
              .appendTo(this.uiDialogTitlebar)

            this._addClass(
              this.uiDialogTitlebarClose,
              'ui-dialog-titlebar-close'
            )
            this._on(this.uiDialogTitlebarClose, {
              click: function (event) {
                event.preventDefault()
                this.close(event)
              }
            })

            uiDialogTitle = $('<span>')
              .uniqueId()
              .prependTo(this.uiDialogTitlebar)
            this._addClass(uiDialogTitle, 'ui-dialog-title')
            this._title(uiDialogTitle)

            this.uiDialogTitlebar.prependTo(this.uiDialog)

            this.uiDialog.attr({
              'aria-labelledby': uiDialogTitle.attr('id')
            })
          },

          _title: function (title) {
            if (this.options.title) {
              title.text(this.options.title)
            } else {
              title.html('&#160;')
            }
          },

          _createButtonPane: function () {
            this.uiDialogButtonPane = $('<div>')
            this._addClass(
              this.uiDialogButtonPane,
              'ui-dialog-buttonpane',
              'ui-widget-content ui-helper-clearfix'
            )

            this.uiButtonSet = $('<div>').appendTo(this.uiDialogButtonPane)
            this._addClass(this.uiButtonSet, 'ui-dialog-buttonset')

            this._createButtons()
          },

          _createButtons: function () {
            var that = this,
              buttons = this.options.buttons

            // If we already have a button pane, remove it
            this.uiDialogButtonPane.remove()
            this.uiButtonSet.empty()

            if (
              $.isEmptyObject(buttons) ||
              (Array.isArray(buttons) && !buttons.length)
            ) {
              this._removeClass(this.uiDialog, 'ui-dialog-buttons')
              return
            }

            $.each(buttons, function (name, props) {
              var click, buttonOptions
              props =
                typeof props === 'function'
                  ? { click: props, text: name }
                  : props

              // Default to a non-submitting button
              props = $.extend({ type: 'button' }, props)

              // Change the context for the click callback to be the main element
              click = props.click
              buttonOptions = {
                icon: props.icon,
                iconPosition: props.iconPosition,
                showLabel: props.showLabel,

                // Deprecated options
                icons: props.icons,
                text: props.text
              }

              delete props.click
              delete props.icon
              delete props.iconPosition
              delete props.showLabel

              // Deprecated options
              delete props.icons
              if (typeof props.text === 'boolean') {
                delete props.text
              }

              $('<button></button>', props)
                .button(buttonOptions)
                .appendTo(that.uiButtonSet)
                .on('click', function () {
                  click.apply(that.element[0], arguments)
                })
            })
            this._addClass(this.uiDialog, 'ui-dialog-buttons')
            this.uiDialogButtonPane.appendTo(this.uiDialog)
          },

          _makeDraggable: function () {
            var that = this,
              options = this.options

            function filteredUi(ui) {
              return {
                position: ui.position,
                offset: ui.offset
              }
            }

            this.uiDialog.draggable({
              cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
              handle: '.ui-dialog-titlebar',
              containment: 'document',
              start: function (event, ui) {
                that._addClass($(this), 'ui-dialog-dragging')
                that._blockFrames()
                that._trigger('dragStart', event, filteredUi(ui))
              },
              drag: function (event, ui) {
                that._trigger('drag', event, filteredUi(ui))
              },
              stop: function (event, ui) {
                var left = ui.offset.left - that.document.scrollLeft(),
                  top = ui.offset.top - that.document.scrollTop()

                options.position = {
                  my: 'left top',
                  at:
                    'left' +
                    (left >= 0 ? '+' : '') +
                    left +
                    ' ' +
                    'top' +
                    (top >= 0 ? '+' : '') +
                    top,
                  of: that.window
                }
                that._removeClass($(this), 'ui-dialog-dragging')
                that._unblockFrames()
                that._trigger('dragStop', event, filteredUi(ui))
              }
            })
          },

          _makeResizable: function () {
            var that = this,
              options = this.options,
              handles = options.resizable,
              // .ui-resizable has position: relative defined in the stylesheet
              // but dialogs have to use absolute or fixed positioning
              position = this.uiDialog.css('position'),
              resizeHandles =
                typeof handles === 'string' ? handles : 'n,e,s,w,se,sw,ne,nw'

            function filteredUi(ui) {
              return {
                originalPosition: ui.originalPosition,
                originalSize: ui.originalSize,
                position: ui.position,
                size: ui.size
              }
            }

            this.uiDialog
              .resizable({
                cancel: '.ui-dialog-content',
                containment: 'document',
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function (event, ui) {
                  that._addClass($(this), 'ui-dialog-resizing')
                  that._blockFrames()
                  that._trigger('resizeStart', event, filteredUi(ui))
                },
                resize: function (event, ui) {
                  that._trigger('resize', event, filteredUi(ui))
                },
                stop: function (event, ui) {
                  var offset = that.uiDialog.offset(),
                    left = offset.left - that.document.scrollLeft(),
                    top = offset.top - that.document.scrollTop()

                  options.height = that.uiDialog.height()
                  options.width = that.uiDialog.width()
                  options.position = {
                    my: 'left top',
                    at:
                      'left' +
                      (left >= 0 ? '+' : '') +
                      left +
                      ' ' +
                      'top' +
                      (top >= 0 ? '+' : '') +
                      top,
                    of: that.window
                  }
                  that._removeClass($(this), 'ui-dialog-resizing')
                  that._unblockFrames()
                  that._trigger('resizeStop', event, filteredUi(ui))
                }
              })
              .css('position', position)
          },

          _trackFocus: function () {
            this._on(this.widget(), {
              focusin: function (event) {
                this._makeFocusTarget()
                this._focusedElement = $(event.target)
              }
            })
          },

          _makeFocusTarget: function () {
            this._untrackInstance()
            this._trackingInstances().unshift(this)
          },

          _untrackInstance: function () {
            var instances = this._trackingInstances(),
              exists = $.inArray(this, instances)
            if (exists !== -1) {
              instances.splice(exists, 1)
            }
          },

          _trackingInstances: function () {
            var instances = this.document.data('ui-dialog-instances')
            if (!instances) {
              instances = []
              this.document.data('ui-dialog-instances', instances)
            }
            return instances
          },

          _minHeight: function () {
            var options = this.options

            return options.height === 'auto'
              ? options.minHeight
              : Math.min(options.minHeight, options.height)
          },

          _position: function () {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(':visible')
            if (!isVisible) {
              this.uiDialog.show()
            }
            this.uiDialog.position(this.options.position)
            if (!isVisible) {
              this.uiDialog.hide()
            }
          },

          _setOptions: function (options) {
            var that = this,
              resize = false,
              resizableOptions = {}

            $.each(options, function (key, value) {
              that._setOption(key, value)

              if (key in that.sizeRelatedOptions) {
                resize = true
              }
              if (key in that.resizableRelatedOptions) {
                resizableOptions[key] = value
              }
            })

            if (resize) {
              this._size()
              this._position()
            }
            if (this.uiDialog.is(':data(ui-resizable)')) {
              this.uiDialog.resizable('option', resizableOptions)
            }
          },

          _setOption: function (key, value) {
            var isDraggable,
              isResizable,
              uiDialog = this.uiDialog

            if (key === 'disabled') {
              return
            }

            this._super(key, value)

            if (key === 'appendTo') {
              this.uiDialog.appendTo(this._appendTo())
            }

            if (key === 'buttons') {
              this._createButtons()
            }

            if (key === 'closeText') {
              this.uiDialogTitlebarClose.button({
                // Ensure that we always pass a string
                label: $('<a>')
                  .text('' + this.options.closeText)
                  .html()
              })
            }

            if (key === 'draggable') {
              isDraggable = uiDialog.is(':data(ui-draggable)')
              if (isDraggable && !value) {
                uiDialog.draggable('destroy')
              }

              if (!isDraggable && value) {
                this._makeDraggable()
              }
            }

            if (key === 'position') {
              this._position()
            }

            if (key === 'resizable') {
              // currently resizable, becoming non-resizable
              isResizable = uiDialog.is(':data(ui-resizable)')
              if (isResizable && !value) {
                uiDialog.resizable('destroy')
              }

              // Currently resizable, changing handles
              if (isResizable && typeof value === 'string') {
                uiDialog.resizable('option', 'handles', value)
              }

              // Currently non-resizable, becoming resizable
              if (!isResizable && value !== false) {
                this._makeResizable()
              }
            }

            if (key === 'title') {
              this._title(this.uiDialogTitlebar.find('.ui-dialog-title'))
            }
          },

          _size: function () {
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight,
              minContentHeight,
              maxContentHeight,
              options = this.options

            // Reset content sizing
            this.element.show().css({
              width: 'auto',
              minHeight: 0,
              maxHeight: 'none',
              height: 0
            })

            if (options.minWidth > options.width) {
              options.width = options.minWidth
            }

            // Reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog
              .css({
                height: 'auto',
                width: options.width
              })
              .outerHeight()
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight)
            maxContentHeight =
              typeof options.maxHeight === 'number'
                ? Math.max(0, options.maxHeight - nonContentHeight)
                : 'none'

            if (options.height === 'auto') {
              this.element.css({
                minHeight: minContentHeight,
                maxHeight: maxContentHeight,
                height: 'auto'
              })
            } else {
              this.element.height(
                Math.max(0, options.height - nonContentHeight)
              )
            }

            if (this.uiDialog.is(':data(ui-resizable)')) {
              this.uiDialog.resizable('option', 'minHeight', this._minHeight())
            }
          },

          _blockFrames: function () {
            this.iframeBlocks = this.document.find('iframe').map(function () {
              var iframe = $(this)

              return $('<div>')
                .css({
                  position: 'absolute',
                  width: iframe.outerWidth(),
                  height: iframe.outerHeight()
                })
                .appendTo(iframe.parent())
                .offset(iframe.offset())[0]
            })
          },

          _unblockFrames: function () {
            if (this.iframeBlocks) {
              this.iframeBlocks.remove()
              delete this.iframeBlocks
            }
          },

          _allowInteraction: function (event) {
            if ($(event.target).closest('.ui-dialog').length) {
              return true
            }

            // TODO: Remove hack when datepicker implements
            // the .ui-front logic (#8989)
            return !!$(event.target).closest('.ui-datepicker').length
          },

          _createOverlay: function () {
            if (!this.options.modal) {
              return
            }

            var jqMinor = $.fn.jquery.substring(0, 4)

            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling (#2804)
            var isOpening = true
            this._delay(function () {
              isOpening = false
            })

            if (!this.document.data('ui-dialog-overlays')) {
              // Prevent use of anchors and inputs
              // This doesn't use `_on()` because it is a shared event handler
              // across all open modal dialogs.
              this.document.on(
                'focusin.ui-dialog',
                function (event) {
                  if (isOpening) {
                    return
                  }

                  var instance = this._trackingInstances()[0]
                  if (!instance._allowInteraction(event)) {
                    event.preventDefault()
                    instance._focusTabbable()

                    // Support: jQuery >=3.4 <3.6 only
                    // Focus re-triggering in jQuery 3.4/3.5 makes the original element
                    // have its focus event propagated last, breaking the re-targeting.
                    // Trigger focus in a delay in addition if needed to avoid the issue
                    // See https://github.com/jquery/jquery/issues/4382
                    if (jqMinor === '3.4.' || jqMinor === '3.5.') {
                      instance._delay(instance._restoreTabbableFocus)
                    }
                  }
                }.bind(this)
              )
            }

            this.overlay = $('<div>').appendTo(this._appendTo())

            this._addClass(this.overlay, null, 'ui-widget-overlay ui-front')
            this._on(this.overlay, {
              mousedown: '_keepFocus'
            })
            this.document.data(
              'ui-dialog-overlays',
              (this.document.data('ui-dialog-overlays') || 0) + 1
            )
          },

          _destroyOverlay: function () {
            if (!this.options.modal) {
              return
            }

            if (this.overlay) {
              var overlays = this.document.data('ui-dialog-overlays') - 1

              if (!overlays) {
                this.document.off('focusin.ui-dialog')
                this.document.removeData('ui-dialog-overlays')
              } else {
                this.document.data('ui-dialog-overlays', overlays)
              }

              this.overlay.remove()
              this.overlay = null
            }
          }
        })

        // DEPRECATED
        // TODO: switch return back to widget declaration at top of file when this is removed
        if ($.uiBackCompat !== false) {
          // Backcompat for dialogClass option
          $.widget('ui.dialog', $.ui.dialog, {
            options: {
              dialogClass: ''
            },
            _createWrapper: function () {
              this._super()
              this.uiDialog.addClass(this.options.dialogClass)
            },
            _setOption: function (key, value) {
              if (key === 'dialogClass') {
                this.uiDialog
                  .removeClass(this.options.dialogClass)
                  .addClass(value)
              }
              this._superApply(arguments)
            }
          })
        }

        return $.ui.dialog
      })

      /***/
    },

    /***/ 7285: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Draggable 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Draggable
      //>>group: Interactions
      //>>description: Enables dragging functionality for any element.
      //>>docs: http://api.jqueryui.com/draggable/
      //>>demos: http://jqueryui.com/draggable/
      //>>css.structure: ../../themes/base/draggable.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(6177),
            __webpack_require__(6400),
            __webpack_require__(1624),
            __webpack_require__(1440),
            __webpack_require__(192),
            __webpack_require__(464),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.draggable', $.ui.mouse, {
          version: '1.13.1',
          widgetEventPrefix: 'drag',
          options: {
            addClasses: true,
            appendTo: 'parent',
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: 'auto',
            cursorAt: false,
            grid: false,
            handle: false,
            helper: 'original',
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: 'default',
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: 'both',
            snapTolerance: 20,
            stack: false,
            zIndex: false,

            // Callbacks
            drag: null,
            start: null,
            stop: null
          },
          _create: function () {
            if (this.options.helper === 'original') {
              this._setPositionRelative()
            }
            if (this.options.addClasses) {
              this._addClass('ui-draggable')
            }
            this._setHandleClassName()

            this._mouseInit()
          },

          _setOption: function (key, value) {
            this._super(key, value)
            if (key === 'handle') {
              this._removeHandleClassName()
              this._setHandleClassName()
            }
          },

          _destroy: function () {
            if ((this.helper || this.element).is('.ui-draggable-dragging')) {
              this.destroyOnClear = true
              return
            }
            this._removeHandleClassName()
            this._mouseDestroy()
          },

          _mouseCapture: function (event) {
            var o = this.options

            // Among others, prevent a drag on a resizable-handle
            if (
              this.helper ||
              o.disabled ||
              $(event.target).closest('.ui-resizable-handle').length > 0
            ) {
              return false
            }

            //Quit if we're not on a valid handle
            this.handle = this._getHandle(event)
            if (!this.handle) {
              return false
            }

            this._blurActiveElement(event)

            this._blockFrames(o.iframeFix === true ? 'iframe' : o.iframeFix)

            return true
          },

          _blockFrames: function (selector) {
            this.iframeBlocks = this.document.find(selector).map(function () {
              var iframe = $(this)

              return $('<div>')
                .css('position', 'absolute')
                .appendTo(iframe.parent())
                .outerWidth(iframe.outerWidth())
                .outerHeight(iframe.outerHeight())
                .offset(iframe.offset())[0]
            })
          },

          _unblockFrames: function () {
            if (this.iframeBlocks) {
              this.iframeBlocks.remove()
              delete this.iframeBlocks
            }
          },

          _blurActiveElement: function (event) {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
              target = $(event.target)

            // Don't blur if the event occurred on an element that is within
            // the currently focused element
            // See #10527, #12472
            if (target.closest(activeElement).length) {
              return
            }

            // Blur any element that currently has focus, see #4261
            $.ui.safeBlur(activeElement)
          },

          _mouseStart: function (event) {
            var o = this.options

            //Create and append the visible helper
            this.helper = this._createHelper(event)

            this._addClass(this.helper, 'ui-draggable-dragging')

            //Cache the helper size
            this._cacheHelperProportions()

            //If ddmanager is used for droppables, set the global draggable
            if ($.ui.ddmanager) {
              $.ui.ddmanager.current = this
            }

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins()

            //Store the helper's css position
            this.cssPosition = this.helper.css('position')
            this.scrollParent = this.helper.scrollParent(true)
            this.offsetParent = this.helper.offsetParent()
            this.hasFixedAncestor =
              this.helper.parents().filter(function () {
                return $(this).css('position') === 'fixed'
              }).length > 0

            //The element's absolute position on the page minus margins
            this.positionAbs = this.element.offset()
            this._refreshOffsets(event)

            //Generate the original position
            this.originalPosition = this.position = this._generatePosition(
              event,
              false
            )
            this.originalPageX = event.pageX
            this.originalPageY = event.pageY

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            if (o.cursorAt) {
              this._adjustOffsetFromHelper(o.cursorAt)
            }

            //Set a containment if given in the options
            this._setContainment()

            //Trigger event + callbacks
            if (this._trigger('start', event) === false) {
              this._clear()
              return false
            }

            //Recache the helper size
            this._cacheHelperProportions()

            //Prepare the droppable offsets
            if ($.ui.ddmanager && !o.dropBehaviour) {
              $.ui.ddmanager.prepareOffsets(this, event)
            }

            // Execute the drag once - this causes the helper not to be visible before getting its
            // correct position
            this._mouseDrag(event, true)

            // If the ddmanager is used for droppables, inform the manager that dragging has started
            // (see #5003)
            if ($.ui.ddmanager) {
              $.ui.ddmanager.dragStart(this, event)
            }

            return true
          },

          _refreshOffsets: function (event) {
            this.offset = {
              top: this.positionAbs.top - this.margins.top,
              left: this.positionAbs.left - this.margins.left,
              scroll: false,
              parent: this._getParentOffset(),
              relative: this._getRelativeOffset()
            }

            this.offset.click = {
              left: event.pageX - this.offset.left,
              top: event.pageY - this.offset.top
            }
          },

          _mouseDrag: function (event, noPropagation) {
            // reset any necessary cached properties (see #5009)
            if (this.hasFixedAncestor) {
              this.offset.parent = this._getParentOffset()
            }

            //Compute the helpers position
            this.position = this._generatePosition(event, true)
            this.positionAbs = this._convertPositionTo('absolute')

            //Call plugins and callbacks and use the resulting position if something is returned
            if (!noPropagation) {
              var ui = this._uiHash()
              if (this._trigger('drag', event, ui) === false) {
                this._mouseUp(new $.Event('mouseup', event))
                return false
              }
              this.position = ui.position
            }

            this.helper[0].style.left = this.position.left + 'px'
            this.helper[0].style.top = this.position.top + 'px'

            if ($.ui.ddmanager) {
              $.ui.ddmanager.drag(this, event)
            }

            return false
          },

          _mouseStop: function (event) {
            //If we are using droppables, inform the manager about the drop
            var that = this,
              dropped = false
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
              dropped = $.ui.ddmanager.drop(this, event)
            }

            //if a drop comes from outside (a sortable)
            if (this.dropped) {
              dropped = this.dropped
              this.dropped = false
            }

            if (
              (this.options.revert === 'invalid' && !dropped) ||
              (this.options.revert === 'valid' && dropped) ||
              this.options.revert === true ||
              (typeof this.options.revert === 'function' &&
                this.options.revert.call(this.element, dropped))
            ) {
              $(this.helper).animate(
                this.originalPosition,
                parseInt(this.options.revertDuration, 10),
                function () {
                  if (that._trigger('stop', event) !== false) {
                    that._clear()
                  }
                }
              )
            } else {
              if (this._trigger('stop', event) !== false) {
                this._clear()
              }
            }

            return false
          },

          _mouseUp: function (event) {
            this._unblockFrames()

            // If the ddmanager is used for droppables, inform the manager that dragging has stopped
            // (see #5003)
            if ($.ui.ddmanager) {
              $.ui.ddmanager.dragStop(this, event)
            }

            // Only need to focus if the event occurred on the draggable itself, see #10527
            if (this.handleElement.is(event.target)) {
              // The interaction is over; whether or not the click resulted in a drag,
              // focus the element
              this.element.trigger('focus')
            }

            return $.ui.mouse.prototype._mouseUp.call(this, event)
          },

          cancel: function () {
            if (this.helper.is('.ui-draggable-dragging')) {
              this._mouseUp(new $.Event('mouseup', { target: this.element[0] }))
            } else {
              this._clear()
            }

            return this
          },

          _getHandle: function (event) {
            return this.options.handle
              ? !!$(event.target).closest(
                  this.element.find(this.options.handle)
                ).length
              : true
          },

          _setHandleClassName: function () {
            this.handleElement = this.options.handle
              ? this.element.find(this.options.handle)
              : this.element
            this._addClass(this.handleElement, 'ui-draggable-handle')
          },

          _removeHandleClassName: function () {
            this._removeClass(this.handleElement, 'ui-draggable-handle')
          },

          _createHelper: function (event) {
            var o = this.options,
              helperIsFunction = typeof o.helper === 'function',
              helper = helperIsFunction
                ? $(o.helper.apply(this.element[0], [event]))
                : o.helper === 'clone'
                ? this.element.clone().removeAttr('id')
                : this.element

            if (!helper.parents('body').length) {
              helper.appendTo(
                o.appendTo === 'parent'
                  ? this.element[0].parentNode
                  : o.appendTo
              )
            }

            // Http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            if (helperIsFunction && helper[0] === this.element[0]) {
              this._setPositionRelative()
            }

            if (
              helper[0] !== this.element[0] &&
              !/(fixed|absolute)/.test(helper.css('position'))
            ) {
              helper.css('position', 'absolute')
            }

            return helper
          },

          _setPositionRelative: function () {
            if (!/^(?:r|a|f)/.test(this.element.css('position'))) {
              this.element[0].style.position = 'relative'
            }
          },

          _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === 'string') {
              obj = obj.split(' ')
            }
            if (Array.isArray(obj)) {
              obj = { left: +obj[0], top: +obj[1] || 0 }
            }
            if ('left' in obj) {
              this.offset.click.left = obj.left + this.margins.left
            }
            if ('right' in obj) {
              this.offset.click.left =
                this.helperProportions.width - obj.right + this.margins.left
            }
            if ('top' in obj) {
              this.offset.click.top = obj.top + this.margins.top
            }
            if ('bottom' in obj) {
              this.offset.click.top =
                this.helperProportions.height - obj.bottom + this.margins.top
            }
          },

          _isRootNode: function (element) {
            return (
              /(html|body)/i.test(element.tagName) ||
              element === this.document[0]
            )
          },

          _getParentOffset: function () {
            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(),
              document = this.document[0]

            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if (
              this.cssPosition === 'absolute' &&
              this.scrollParent[0] !== document &&
              $.contains(this.scrollParent[0], this.offsetParent[0])
            ) {
              po.left += this.scrollParent.scrollLeft()
              po.top += this.scrollParent.scrollTop()
            }

            if (this._isRootNode(this.offsetParent[0])) {
              po = { top: 0, left: 0 }
            }

            return {
              top:
                po.top +
                (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
              left:
                po.left +
                (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
            }
          },

          _getRelativeOffset: function () {
            if (this.cssPosition !== 'relative') {
              return { top: 0, left: 0 }
            }

            var p = this.element.position(),
              scrollIsRootNode = this._isRootNode(this.scrollParent[0])

            return {
              top:
                p.top -
                (parseInt(this.helper.css('top'), 10) || 0) +
                (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
              left:
                p.left -
                (parseInt(this.helper.css('left'), 10) || 0) +
                (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
            }
          },

          _cacheMargins: function () {
            this.margins = {
              left: parseInt(this.element.css('marginLeft'), 10) || 0,
              top: parseInt(this.element.css('marginTop'), 10) || 0,
              right: parseInt(this.element.css('marginRight'), 10) || 0,
              bottom: parseInt(this.element.css('marginBottom'), 10) || 0
            }
          },

          _cacheHelperProportions: function () {
            this.helperProportions = {
              width: this.helper.outerWidth(),
              height: this.helper.outerHeight()
            }
          },

          _setContainment: function () {
            var isUserScrollable,
              c,
              ce,
              o = this.options,
              document = this.document[0]

            this.relativeContainer = null

            if (!o.containment) {
              this.containment = null
              return
            }

            if (o.containment === 'window') {
              this.containment = [
                $(window).scrollLeft() -
                  this.offset.relative.left -
                  this.offset.parent.left,
                $(window).scrollTop() -
                  this.offset.relative.top -
                  this.offset.parent.top,
                $(window).scrollLeft() +
                  $(window).width() -
                  this.helperProportions.width -
                  this.margins.left,
                $(window).scrollTop() +
                  ($(window).height() ||
                    document.body.parentNode.scrollHeight) -
                  this.helperProportions.height -
                  this.margins.top
              ]
              return
            }

            if (o.containment === 'document') {
              this.containment = [
                0,
                0,
                $(document).width() -
                  this.helperProportions.width -
                  this.margins.left,
                ($(document).height() ||
                  document.body.parentNode.scrollHeight) -
                  this.helperProportions.height -
                  this.margins.top
              ]
              return
            }

            if (o.containment.constructor === Array) {
              this.containment = o.containment
              return
            }

            if (o.containment === 'parent') {
              o.containment = this.helper[0].parentNode
            }

            c = $(o.containment)
            ce = c[0]

            if (!ce) {
              return
            }

            isUserScrollable = /(scroll|auto)/.test(c.css('overflow'))

            this.containment = [
              (parseInt(c.css('borderLeftWidth'), 10) || 0) +
                (parseInt(c.css('paddingLeft'), 10) || 0),
              (parseInt(c.css('borderTopWidth'), 10) || 0) +
                (parseInt(c.css('paddingTop'), 10) || 0),
              (isUserScrollable
                ? Math.max(ce.scrollWidth, ce.offsetWidth)
                : ce.offsetWidth) -
                (parseInt(c.css('borderRightWidth'), 10) || 0) -
                (parseInt(c.css('paddingRight'), 10) || 0) -
                this.helperProportions.width -
                this.margins.left -
                this.margins.right,
              (isUserScrollable
                ? Math.max(ce.scrollHeight, ce.offsetHeight)
                : ce.offsetHeight) -
                (parseInt(c.css('borderBottomWidth'), 10) || 0) -
                (parseInt(c.css('paddingBottom'), 10) || 0) -
                this.helperProportions.height -
                this.margins.top -
                this.margins.bottom
            ]
            this.relativeContainer = c
          },

          _convertPositionTo: function (d, pos) {
            if (!pos) {
              pos = this.position
            }

            var mod = d === 'absolute' ? 1 : -1,
              scrollIsRootNode = this._isRootNode(this.scrollParent[0])

            return {
              top:
                // The absolute mouse position
                pos.top +
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.top * mod +
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.top * mod -
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.top
                  : scrollIsRootNode
                  ? 0
                  : this.offset.scroll.top) *
                  mod,
              left:
                // The absolute mouse position
                pos.left +
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.left * mod +
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.left * mod -
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.left
                  : scrollIsRootNode
                  ? 0
                  : this.offset.scroll.left) *
                  mod
            }
          },

          _generatePosition: function (event, constrainPosition) {
            var containment,
              co,
              top,
              left,
              o = this.options,
              scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
              pageX = event.pageX,
              pageY = event.pageY

            // Cache the scroll
            if (!scrollIsRootNode || !this.offset.scroll) {
              this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
              }
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            // If we are not dragging yet, we won't check for options
            if (constrainPosition) {
              if (this.containment) {
                if (this.relativeContainer) {
                  co = this.relativeContainer.offset()
                  containment = [
                    this.containment[0] + co.left,
                    this.containment[1] + co.top,
                    this.containment[2] + co.left,
                    this.containment[3] + co.top
                  ]
                } else {
                  containment = this.containment
                }

                if (event.pageX - this.offset.click.left < containment[0]) {
                  pageX = containment[0] + this.offset.click.left
                }
                if (event.pageY - this.offset.click.top < containment[1]) {
                  pageY = containment[1] + this.offset.click.top
                }
                if (event.pageX - this.offset.click.left > containment[2]) {
                  pageX = containment[2] + this.offset.click.left
                }
                if (event.pageY - this.offset.click.top > containment[3]) {
                  pageY = containment[3] + this.offset.click.top
                }
              }

              if (o.grid) {
                //Check for grid elements set to 0 to prevent divide by 0 error causing invalid
                // argument errors in IE (see ticket #6950)
                top = o.grid[1]
                  ? this.originalPageY +
                    Math.round((pageY - this.originalPageY) / o.grid[1]) *
                      o.grid[1]
                  : this.originalPageY
                pageY = containment
                  ? top - this.offset.click.top >= containment[1] ||
                    top - this.offset.click.top > containment[3]
                    ? top
                    : top - this.offset.click.top >= containment[1]
                    ? top - o.grid[1]
                    : top + o.grid[1]
                  : top

                left = o.grid[0]
                  ? this.originalPageX +
                    Math.round((pageX - this.originalPageX) / o.grid[0]) *
                      o.grid[0]
                  : this.originalPageX
                pageX = containment
                  ? left - this.offset.click.left >= containment[0] ||
                    left - this.offset.click.left > containment[2]
                    ? left
                    : left - this.offset.click.left >= containment[0]
                    ? left - o.grid[0]
                    : left + o.grid[0]
                  : left
              }

              if (o.axis === 'y') {
                pageX = this.originalPageX
              }

              if (o.axis === 'x') {
                pageY = this.originalPageY
              }
            }

            return {
              top:
                // The absolute mouse position
                pageY -
                // Click offset (relative to the element)
                this.offset.click.top -
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.top -
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.top +
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.top
                  : scrollIsRootNode
                  ? 0
                  : this.offset.scroll.top),
              left:
                // The absolute mouse position
                pageX -
                // Click offset (relative to the element)
                this.offset.click.left -
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.left -
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.left +
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.left
                  : scrollIsRootNode
                  ? 0
                  : this.offset.scroll.left)
            }
          },

          _clear: function () {
            this._removeClass(this.helper, 'ui-draggable-dragging')
            if (
              this.helper[0] !== this.element[0] &&
              !this.cancelHelperRemoval
            ) {
              this.helper.remove()
            }
            this.helper = null
            this.cancelHelperRemoval = false
            if (this.destroyOnClear) {
              this.destroy()
            }
          },

          // From now on bulk stuff - mainly helpers

          _trigger: function (type, event, ui) {
            ui = ui || this._uiHash()
            $.ui.plugin.call(this, type, [event, ui, this], true)

            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            if (/^(drag|start|stop)/.test(type)) {
              this.positionAbs = this._convertPositionTo('absolute')
              ui.offset = this.positionAbs
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui)
          },

          plugins: {},

          _uiHash: function () {
            return {
              helper: this.helper,
              position: this.position,
              originalPosition: this.originalPosition,
              offset: this.positionAbs
            }
          }
        })

        $.ui.plugin.add('draggable', 'connectToSortable', {
          start: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
              item: draggable.element
            })

            draggable.sortables = []
            $(draggable.options.connectToSortable).each(function () {
              var sortable = $(this).sortable('instance')

              if (sortable && !sortable.options.disabled) {
                draggable.sortables.push(sortable)

                // RefreshPositions is called at drag start to refresh the containerCache
                // which is used in drag. This ensures it's initialized and synchronized
                // with any changes that might have happened on the page since initialization.
                sortable.refreshPositions()
                sortable._trigger('activate', event, uiSortable)
              }
            })
          },
          stop: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
              item: draggable.element
            })

            draggable.cancelHelperRemoval = false

            $.each(draggable.sortables, function () {
              var sortable = this

              if (sortable.isOver) {
                sortable.isOver = 0

                // Allow this sortable to handle removing the helper
                draggable.cancelHelperRemoval = true
                sortable.cancelHelperRemoval = false

                // Use _storedCSS To restore properties in the sortable,
                // as this also handles revert (#9675) since the draggable
                // may have modified them in unexpected ways (#8809)
                sortable._storedCSS = {
                  position: sortable.placeholder.css('position'),
                  top: sortable.placeholder.css('top'),
                  left: sortable.placeholder.css('left')
                }

                sortable._mouseStop(event)

                // Once drag has ended, the sortable should return to using
                // its original helper, not the shared helper from draggable
                sortable.options.helper = sortable.options._helper
              } else {
                // Prevent this Sortable from removing the helper.
                // However, don't set the draggable to remove the helper
                // either as another connected Sortable may yet handle the removal.
                sortable.cancelHelperRemoval = true

                sortable._trigger('deactivate', event, uiSortable)
              }
            })
          },
          drag: function (event, ui, draggable) {
            $.each(draggable.sortables, function () {
              var innermostIntersecting = false,
                sortable = this

              // Copy over variables that sortable's _intersectsWith uses
              sortable.positionAbs = draggable.positionAbs
              sortable.helperProportions = draggable.helperProportions
              sortable.offset.click = draggable.offset.click

              if (sortable._intersectsWith(sortable.containerCache)) {
                innermostIntersecting = true

                $.each(draggable.sortables, function () {
                  // Copy over variables that sortable's _intersectsWith uses
                  this.positionAbs = draggable.positionAbs
                  this.helperProportions = draggable.helperProportions
                  this.offset.click = draggable.offset.click

                  if (
                    this !== sortable &&
                    this._intersectsWith(this.containerCache) &&
                    $.contains(sortable.element[0], this.element[0])
                  ) {
                    innermostIntersecting = false
                  }

                  return innermostIntersecting
                })
              }

              if (innermostIntersecting) {
                // If it intersects, we use a little isOver variable and set it once,
                // so that the move-in stuff gets fired only once.
                if (!sortable.isOver) {
                  sortable.isOver = 1

                  // Store draggable's parent in case we need to reappend to it later.
                  draggable._parent = ui.helper.parent()

                  sortable.currentItem = ui.helper
                    .appendTo(sortable.element)
                    .data('ui-sortable-item', true)

                  // Store helper option to later restore it
                  sortable.options._helper = sortable.options.helper

                  sortable.options.helper = function () {
                    return ui.helper[0]
                  }

                  // Fire the start events of the sortable with our passed browser event,
                  // and our own helper (so it doesn't create a new one)
                  event.target = sortable.currentItem[0]
                  sortable._mouseCapture(event, true)
                  sortable._mouseStart(event, true, true)

                  // Because the browser event is way off the new appended portlet,
                  // modify necessary variables to reflect the changes
                  sortable.offset.click.top = draggable.offset.click.top
                  sortable.offset.click.left = draggable.offset.click.left
                  sortable.offset.parent.left -=
                    draggable.offset.parent.left - sortable.offset.parent.left
                  sortable.offset.parent.top -=
                    draggable.offset.parent.top - sortable.offset.parent.top

                  draggable._trigger('toSortable', event)

                  // Inform draggable that the helper is in a valid drop zone,
                  // used solely in the revert option to handle "valid/invalid".
                  draggable.dropped = sortable.element

                  // Need to refreshPositions of all sortables in the case that
                  // adding to one sortable changes the location of the other sortables (#9675)
                  $.each(draggable.sortables, function () {
                    this.refreshPositions()
                  })

                  // Hack so receive/update callbacks work (mostly)
                  draggable.currentItem = draggable.element
                  sortable.fromOutside = draggable
                }

                if (sortable.currentItem) {
                  sortable._mouseDrag(event)

                  // Copy the sortable's position because the draggable's can potentially reflect
                  // a relative position, while sortable is always absolute, which the dragged
                  // element has now become. (#8809)
                  ui.position = sortable.position
                }
              } else {
                // If it doesn't intersect with the sortable, and it intersected before,
                // we fake the drag stop of the sortable, but make sure it doesn't remove
                // the helper by using cancelHelperRemoval.
                if (sortable.isOver) {
                  sortable.isOver = 0
                  sortable.cancelHelperRemoval = true

                  // Calling sortable's mouseStop would trigger a revert,
                  // so revert must be temporarily false until after mouseStop is called.
                  sortable.options._revert = sortable.options.revert
                  sortable.options.revert = false

                  sortable._trigger('out', event, sortable._uiHash(sortable))
                  sortable._mouseStop(event, true)

                  // Restore sortable behaviors that were modfied
                  // when the draggable entered the sortable area (#9481)
                  sortable.options.revert = sortable.options._revert
                  sortable.options.helper = sortable.options._helper

                  if (sortable.placeholder) {
                    sortable.placeholder.remove()
                  }

                  // Restore and recalculate the draggable's offset considering the sortable
                  // may have modified them in unexpected ways. (#8809, #10669)
                  ui.helper.appendTo(draggable._parent)
                  draggable._refreshOffsets(event)
                  ui.position = draggable._generatePosition(event, true)

                  draggable._trigger('fromSortable', event)

                  // Inform draggable that the helper is no longer in a valid drop zone
                  draggable.dropped = false

                  // Need to refreshPositions of all sortables just in case removing
                  // from one sortable changes the location of other sortables (#9675)
                  $.each(draggable.sortables, function () {
                    this.refreshPositions()
                  })
                }
              }
            })
          }
        })

        $.ui.plugin.add('draggable', 'cursor', {
          start: function (event, ui, instance) {
            var t = $('body'),
              o = instance.options

            if (t.css('cursor')) {
              o._cursor = t.css('cursor')
            }
            t.css('cursor', o.cursor)
          },
          stop: function (event, ui, instance) {
            var o = instance.options
            if (o._cursor) {
              $('body').css('cursor', o._cursor)
            }
          }
        })

        $.ui.plugin.add('draggable', 'opacity', {
          start: function (event, ui, instance) {
            var t = $(ui.helper),
              o = instance.options
            if (t.css('opacity')) {
              o._opacity = t.css('opacity')
            }
            t.css('opacity', o.opacity)
          },
          stop: function (event, ui, instance) {
            var o = instance.options
            if (o._opacity) {
              $(ui.helper).css('opacity', o._opacity)
            }
          }
        })

        $.ui.plugin.add('draggable', 'scroll', {
          start: function (event, ui, i) {
            if (!i.scrollParentNotHidden) {
              i.scrollParentNotHidden = i.helper.scrollParent(false)
            }

            if (
              i.scrollParentNotHidden[0] !== i.document[0] &&
              i.scrollParentNotHidden[0].tagName !== 'HTML'
            ) {
              i.overflowOffset = i.scrollParentNotHidden.offset()
            }
          },
          drag: function (event, ui, i) {
            var o = i.options,
              scrolled = false,
              scrollParent = i.scrollParentNotHidden[0],
              document = i.document[0]

            if (scrollParent !== document && scrollParent.tagName !== 'HTML') {
              if (!o.axis || o.axis !== 'x') {
                if (
                  i.overflowOffset.top +
                    scrollParent.offsetHeight -
                    event.pageY <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollTop = scrolled =
                    scrollParent.scrollTop + o.scrollSpeed
                } else if (
                  event.pageY - i.overflowOffset.top <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollTop = scrolled =
                    scrollParent.scrollTop - o.scrollSpeed
                }
              }

              if (!o.axis || o.axis !== 'y') {
                if (
                  i.overflowOffset.left +
                    scrollParent.offsetWidth -
                    event.pageX <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollLeft = scrolled =
                    scrollParent.scrollLeft + o.scrollSpeed
                } else if (
                  event.pageX - i.overflowOffset.left <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollLeft = scrolled =
                    scrollParent.scrollLeft - o.scrollSpeed
                }
              }
            } else {
              if (!o.axis || o.axis !== 'x') {
                if (
                  event.pageY - $(document).scrollTop() <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollTop(
                    $(document).scrollTop() - o.scrollSpeed
                  )
                } else if (
                  $(window).height() - (event.pageY - $(document).scrollTop()) <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollTop(
                    $(document).scrollTop() + o.scrollSpeed
                  )
                }
              }

              if (!o.axis || o.axis !== 'y') {
                if (
                  event.pageX - $(document).scrollLeft() <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollLeft(
                    $(document).scrollLeft() - o.scrollSpeed
                  )
                } else if (
                  $(window).width() - (event.pageX - $(document).scrollLeft()) <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollLeft(
                    $(document).scrollLeft() + o.scrollSpeed
                  )
                }
              }
            }

            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
              $.ui.ddmanager.prepareOffsets(i, event)
            }
          }
        })

        $.ui.plugin.add('draggable', 'snap', {
          start: function (event, ui, i) {
            var o = i.options

            i.snapElements = []

            $(
              o.snap.constructor !== String
                ? o.snap.items || ':data(ui-draggable)'
                : o.snap
            ).each(function () {
              var $t = $(this),
                $o = $t.offset()
              if (this !== i.element[0]) {
                i.snapElements.push({
                  item: this,
                  width: $t.outerWidth(),
                  height: $t.outerHeight(),
                  top: $o.top,
                  left: $o.left
                })
              }
            })
          },
          drag: function (event, ui, inst) {
            var ts,
              bs,
              ls,
              rs,
              l,
              r,
              t,
              b,
              i,
              first,
              o = inst.options,
              d = o.snapTolerance,
              x1 = ui.offset.left,
              x2 = x1 + inst.helperProportions.width,
              y1 = ui.offset.top,
              y2 = y1 + inst.helperProportions.height

            for (i = inst.snapElements.length - 1; i >= 0; i--) {
              l = inst.snapElements[i].left - inst.margins.left
              r = l + inst.snapElements[i].width
              t = inst.snapElements[i].top - inst.margins.top
              b = t + inst.snapElements[i].height

              if (
                x2 < l - d ||
                x1 > r + d ||
                y2 < t - d ||
                y1 > b + d ||
                !$.contains(
                  inst.snapElements[i].item.ownerDocument,
                  inst.snapElements[i].item
                )
              ) {
                if (inst.snapElements[i].snapping) {
                  if (inst.options.snap.release) {
                    inst.options.snap.release.call(
                      inst.element,
                      event,
                      $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                      })
                    )
                  }
                }
                inst.snapElements[i].snapping = false
                continue
              }

              if (o.snapMode !== 'inner') {
                ts = Math.abs(t - y2) <= d
                bs = Math.abs(b - y1) <= d
                ls = Math.abs(l - x2) <= d
                rs = Math.abs(r - x1) <= d
                if (ts) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: t - inst.helperProportions.height,
                    left: 0
                  }).top
                }
                if (bs) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: b,
                    left: 0
                  }).top
                }
                if (ls) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: l - inst.helperProportions.width
                  }).left
                }
                if (rs) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: r
                  }).left
                }
              }

              first = ts || bs || ls || rs

              if (o.snapMode !== 'outer') {
                ts = Math.abs(t - y1) <= d
                bs = Math.abs(b - y2) <= d
                ls = Math.abs(l - x1) <= d
                rs = Math.abs(r - x2) <= d
                if (ts) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: t,
                    left: 0
                  }).top
                }
                if (bs) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: b - inst.helperProportions.height,
                    left: 0
                  }).top
                }
                if (ls) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: l
                  }).left
                }
                if (rs) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: r - inst.helperProportions.width
                  }).left
                }
              }

              if (
                !inst.snapElements[i].snapping &&
                (ts || bs || ls || rs || first)
              ) {
                if (inst.options.snap.snap) {
                  inst.options.snap.snap.call(
                    inst.element,
                    event,
                    $.extend(inst._uiHash(), {
                      snapItem: inst.snapElements[i].item
                    })
                  )
                }
              }
              inst.snapElements[i].snapping = ts || bs || ls || rs || first
            }
          }
        })

        $.ui.plugin.add('draggable', 'stack', {
          start: function (event, ui, instance) {
            var min,
              o = instance.options,
              group = $.makeArray($(o.stack)).sort(function (a, b) {
                return (
                  (parseInt($(a).css('zIndex'), 10) || 0) -
                  (parseInt($(b).css('zIndex'), 10) || 0)
                )
              })

            if (!group.length) {
              return
            }

            min = parseInt($(group[0]).css('zIndex'), 10) || 0
            $(group).each(function (i) {
              $(this).css('zIndex', min + i)
            })
            this.css('zIndex', min + group.length)
          }
        })

        $.ui.plugin.add('draggable', 'zIndex', {
          start: function (event, ui, instance) {
            var t = $(ui.helper),
              o = instance.options

            if (t.css('zIndex')) {
              o._zIndex = t.css('zIndex')
            }
            t.css('zIndex', o.zIndex)
          },
          stop: function (event, ui, instance) {
            var o = instance.options

            if (o._zIndex) {
              $(ui.helper).css('zIndex', o._zIndex)
            }
          }
        })

        return $.ui.draggable
      })

      /***/
    },

    /***/ 8851: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Menu 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Menu
      //>>group: Widgets
      //>>description: Creates nestable menus.
      //>>docs: http://api.jqueryui.com/menu/
      //>>demos: http://jqueryui.com/menu/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/menu.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(7053),
            __webpack_require__(1822),
            __webpack_require__(1440),
            __webpack_require__(9138),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.widget('ui.menu', {
          version: '1.13.1',
          defaultElement: '<ul>',
          delay: 300,
          options: {
            icons: {
              submenu: 'ui-icon-caret-1-e'
            },
            items: '> *',
            menus: 'ul',
            position: {
              my: 'left top',
              at: 'right top'
            },
            role: 'menu',

            // Callbacks
            blur: null,
            focus: null,
            select: null
          },

          _create: function () {
            this.activeMenu = this.element

            // Flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = false
            this.lastMousePosition = { x: null, y: null }
            this.element.uniqueId().attr({
              role: this.options.role,
              tabIndex: 0
            })

            this._addClass('ui-menu', 'ui-widget ui-widget-content')
            this._on({
              // Prevent focus from sticking to links inside menu after clicking
              // them (focus should always stay on UL during navigation).
              'mousedown .ui-menu-item': function (event) {
                event.preventDefault()

                this._activateItem(event)
              },
              'click .ui-menu-item': function (event) {
                var target = $(event.target)
                var active = $($.ui.safeActiveElement(this.document[0]))
                if (
                  !this.mouseHandled &&
                  target.not('.ui-state-disabled').length
                ) {
                  this.select(event)

                  // Only set the mouseHandled flag if the event will bubble, see #9469.
                  if (!event.isPropagationStopped()) {
                    this.mouseHandled = true
                  }

                  // Open submenu on click
                  if (target.has('.ui-menu').length) {
                    this.expand(event)
                  } else if (
                    !this.element.is(':focus') &&
                    active.closest('.ui-menu').length
                  ) {
                    // Redirect focus to the menu
                    this.element.trigger('focus', [true])

                    // If the active item is on the top level, let it stay active.
                    // Otherwise, blur the active item since it is no longer visible.
                    if (
                      this.active &&
                      this.active.parents('.ui-menu').length === 1
                    ) {
                      clearTimeout(this.timer)
                    }
                  }
                }
              },
              'mouseenter .ui-menu-item': '_activateItem',
              'mousemove .ui-menu-item': '_activateItem',
              mouseleave: 'collapseAll',
              'mouseleave .ui-menu': 'collapseAll',
              focus: function (event, keepActiveItem) {
                // If there's already an active item, keep it active
                // If not, activate the first item
                var item = this.active || this._menuItems().first()

                if (!keepActiveItem) {
                  this.focus(event, item)
                }
              },
              blur: function (event) {
                this._delay(function () {
                  var notContained = !$.contains(
                    this.element[0],
                    $.ui.safeActiveElement(this.document[0])
                  )
                  if (notContained) {
                    this.collapseAll(event)
                  }
                })
              },
              keydown: '_keydown'
            })

            this.refresh()

            // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
              click: function (event) {
                if (this._closeOnDocumentClick(event)) {
                  this.collapseAll(event, true)
                }

                // Reset the mouseHandled flag
                this.mouseHandled = false
              }
            })
          },

          _activateItem: function (event) {
            // Ignore mouse events while typeahead is active, see #10458.
            // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
            // is over an item in the menu
            if (this.previousFilter) {
              return
            }

            // If the mouse didn't actually move, but the page was scrolled, ignore the event (#9356)
            if (
              event.clientX === this.lastMousePosition.x &&
              event.clientY === this.lastMousePosition.y
            ) {
              return
            }

            this.lastMousePosition = {
              x: event.clientX,
              y: event.clientY
            }

            var actualTarget = $(event.target).closest('.ui-menu-item'),
              target = $(event.currentTarget)

            // Ignore bubbled events on parent items, see #11641
            if (actualTarget[0] !== target[0]) {
              return
            }

            // If the item is already active, there's nothing to do
            if (target.is('.ui-state-active')) {
              return
            }

            // Remove ui-state-active class from siblings of the newly focused menu item
            // to avoid a jump caused by adjacent elements both having a class with a border
            this._removeClass(
              target.siblings().children('.ui-state-active'),
              null,
              'ui-state-active'
            )
            this.focus(event, target)
          },

          _destroy: function () {
            var items = this.element
                .find('.ui-menu-item')
                .removeAttr('role aria-disabled'),
              submenus = items
                .children('.ui-menu-item-wrapper')
                .removeUniqueId()
                .removeAttr('tabIndex role aria-haspopup')

            // Destroy (sub)menus
            this.element
              .removeAttr('aria-activedescendant')
              .find('.ui-menu')
              .addBack()
              .removeAttr(
                'role aria-labelledby aria-expanded aria-hidden aria-disabled ' +
                  'tabIndex'
              )
              .removeUniqueId()
              .show()

            submenus.children().each(function () {
              var elem = $(this)
              if (elem.data('ui-menu-submenu-caret')) {
                elem.remove()
              }
            })
          },

          _keydown: function (event) {
            var match,
              prev,
              character,
              skip,
              preventDefault = true

            switch (event.keyCode) {
              case $.ui.keyCode.PAGE_UP:
                this.previousPage(event)
                break
              case $.ui.keyCode.PAGE_DOWN:
                this.nextPage(event)
                break
              case $.ui.keyCode.HOME:
                this._move('first', 'first', event)
                break
              case $.ui.keyCode.END:
                this._move('last', 'last', event)
                break
              case $.ui.keyCode.UP:
                this.previous(event)
                break
              case $.ui.keyCode.DOWN:
                this.next(event)
                break
              case $.ui.keyCode.LEFT:
                this.collapse(event)
                break
              case $.ui.keyCode.RIGHT:
                if (this.active && !this.active.is('.ui-state-disabled')) {
                  this.expand(event)
                }
                break
              case $.ui.keyCode.ENTER:
              case $.ui.keyCode.SPACE:
                this._activate(event)
                break
              case $.ui.keyCode.ESCAPE:
                this.collapse(event)
                break
              default:
                preventDefault = false
                prev = this.previousFilter || ''
                skip = false

                // Support number pad values
                character =
                  event.keyCode >= 96 && event.keyCode <= 105
                    ? (event.keyCode - 96).toString()
                    : String.fromCharCode(event.keyCode)

                clearTimeout(this.filterTimer)

                if (character === prev) {
                  skip = true
                } else {
                  character = prev + character
                }

                match = this._filterMenuItems(character)
                match =
                  skip && match.index(this.active.next()) !== -1
                    ? this.active.nextAll('.ui-menu-item')
                    : match

                // If no matches on the current filter, reset to the last character pressed
                // to move down the menu to the first item that starts with that character
                if (!match.length) {
                  character = String.fromCharCode(event.keyCode)
                  match = this._filterMenuItems(character)
                }

                if (match.length) {
                  this.focus(event, match)
                  this.previousFilter = character
                  this.filterTimer = this._delay(function () {
                    delete this.previousFilter
                  }, 1000)
                } else {
                  delete this.previousFilter
                }
            }

            if (preventDefault) {
              event.preventDefault()
            }
          },

          _activate: function (event) {
            if (this.active && !this.active.is('.ui-state-disabled')) {
              if (this.active.children("[aria-haspopup='true']").length) {
                this.expand(event)
              } else {
                this.select(event)
              }
            }
          },

          refresh: function () {
            var menus,
              items,
              newSubmenus,
              newItems,
              newWrappers,
              that = this,
              icon = this.options.icons.submenu,
              submenus = this.element.find(this.options.menus)

            this._toggleClass(
              'ui-menu-icons',
              null,
              !!this.element.find('.ui-icon').length
            )

            // Initialize nested menus
            newSubmenus = submenus
              .filter(':not(.ui-menu)')
              .hide()
              .attr({
                role: this.options.role,
                'aria-hidden': 'true',
                'aria-expanded': 'false'
              })
              .each(function () {
                var menu = $(this),
                  item = menu.prev(),
                  submenuCaret = $('<span>').data('ui-menu-submenu-caret', true)

                that._addClass(submenuCaret, 'ui-menu-icon', 'ui-icon ' + icon)
                item.attr('aria-haspopup', 'true').prepend(submenuCaret)
                menu.attr('aria-labelledby', item.attr('id'))
              })

            this._addClass(
              newSubmenus,
              'ui-menu',
              'ui-widget ui-widget-content ui-front'
            )

            menus = submenus.add(this.element)
            items = menus.find(this.options.items)

            // Initialize menu-items containing spaces and/or dashes only as dividers
            items.not('.ui-menu-item').each(function () {
              var item = $(this)
              if (that._isDivider(item)) {
                that._addClass(item, 'ui-menu-divider', 'ui-widget-content')
              }
            })

            // Don't refresh list items that are already adapted
            newItems = items.not('.ui-menu-item, .ui-menu-divider')
            newWrappers = newItems.children().not('.ui-menu').uniqueId().attr({
              tabIndex: -1,
              role: this._itemRole()
            })
            this._addClass(newItems, 'ui-menu-item')._addClass(
              newWrappers,
              'ui-menu-item-wrapper'
            )

            // Add aria-disabled attribute to any disabled menu item
            items.filter('.ui-state-disabled').attr('aria-disabled', 'true')

            // If the active item has been removed, blur the menu
            if (this.active && !$.contains(this.element[0], this.active[0])) {
              this.blur()
            }
          },

          _itemRole: function () {
            return {
              menu: 'menuitem',
              listbox: 'option'
            }[this.options.role]
          },

          _setOption: function (key, value) {
            if (key === 'icons') {
              var icons = this.element.find('.ui-menu-icon')
              this._removeClass(
                icons,
                null,
                this.options.icons.submenu
              )._addClass(icons, null, value.submenu)
            }
            this._super(key, value)
          },

          _setOptionDisabled: function (value) {
            this._super(value)

            this.element.attr('aria-disabled', String(value))
            this._toggleClass(null, 'ui-state-disabled', !!value)
          },

          focus: function (event, item) {
            var nested, focused, activeParent
            this.blur(event, event && event.type === 'focus')

            this._scrollIntoView(item)

            this.active = item.first()

            focused = this.active.children('.ui-menu-item-wrapper')
            this._addClass(focused, null, 'ui-state-active')

            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if (this.options.role) {
              this.element.attr('aria-activedescendant', focused.attr('id'))
            }

            // Highlight active parent menu item, if any
            activeParent = this.active
              .parent()
              .closest('.ui-menu-item')
              .children('.ui-menu-item-wrapper')
            this._addClass(activeParent, null, 'ui-state-active')

            if (event && event.type === 'keydown') {
              this._close()
            } else {
              this.timer = this._delay(function () {
                this._close()
              }, this.delay)
            }

            nested = item.children('.ui-menu')
            if (nested.length && event && /^mouse/.test(event.type)) {
              this._startOpening(nested)
            }
            this.activeMenu = item.parent()

            this._trigger('focus', event, { item: item })
          },

          _scrollIntoView: function (item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight
            if (this._hasScroll()) {
              borderTop =
                parseFloat($.css(this.activeMenu[0], 'borderTopWidth')) || 0
              paddingTop =
                parseFloat($.css(this.activeMenu[0], 'paddingTop')) || 0
              offset =
                item.offset().top -
                this.activeMenu.offset().top -
                borderTop -
                paddingTop
              scroll = this.activeMenu.scrollTop()
              elementHeight = this.activeMenu.height()
              itemHeight = item.outerHeight()

              if (offset < 0) {
                this.activeMenu.scrollTop(scroll + offset)
              } else if (offset + itemHeight > elementHeight) {
                this.activeMenu.scrollTop(
                  scroll + offset - elementHeight + itemHeight
                )
              }
            }
          },

          blur: function (event, fromFocus) {
            if (!fromFocus) {
              clearTimeout(this.timer)
            }

            if (!this.active) {
              return
            }

            this._removeClass(
              this.active.children('.ui-menu-item-wrapper'),
              null,
              'ui-state-active'
            )

            this._trigger('blur', event, { item: this.active })
            this.active = null
          },

          _startOpening: function (submenu) {
            clearTimeout(this.timer)

            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the caret icon
            if (submenu.attr('aria-hidden') !== 'true') {
              return
            }

            this.timer = this._delay(function () {
              this._close()
              this._open(submenu)
            }, this.delay)
          },

          _open: function (submenu) {
            var position = $.extend(
              {
                of: this.active
              },
              this.options.position
            )

            clearTimeout(this.timer)
            this.element
              .find('.ui-menu')
              .not(submenu.parents('.ui-menu'))
              .hide()
              .attr('aria-hidden', 'true')

            submenu
              .show()
              .removeAttr('aria-hidden')
              .attr('aria-expanded', 'true')
              .position(position)
          },

          collapseAll: function (event, all) {
            clearTimeout(this.timer)
            this.timer = this._delay(
              function () {
                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all
                  ? this.element
                  : $(event && event.target).closest(
                      this.element.find('.ui-menu')
                    )

                // If we found no valid submenu ancestor, use the main menu to close all
                // sub menus anyway
                if (!currentMenu.length) {
                  currentMenu = this.element
                }

                this._close(currentMenu)

                this.blur(event)

                // Work around active item staying active after menu is blurred
                this._removeClass(
                  currentMenu.find('.ui-state-active'),
                  null,
                  'ui-state-active'
                )

                this.activeMenu = currentMenu
              },
              all ? 0 : this.delay
            )
          },

          // With no arguments, closes the currently active menu - if nothing is active
          // it closes all menus.  If passed an argument, it will search for menus BELOW
          _close: function (startMenu) {
            if (!startMenu) {
              startMenu = this.active ? this.active.parent() : this.element
            }

            startMenu
              .find('.ui-menu')
              .hide()
              .attr('aria-hidden', 'true')
              .attr('aria-expanded', 'false')
          },

          _closeOnDocumentClick: function (event) {
            return !$(event.target).closest('.ui-menu').length
          },

          _isDivider: function (item) {
            // Match hyphen, em dash, en dash
            return !/[^\-\u2014\u2013\s]/.test(item.text())
          },

          collapse: function (event) {
            var newItem =
              this.active &&
              this.active.parent().closest('.ui-menu-item', this.element)
            if (newItem && newItem.length) {
              this._close()
              this.focus(event, newItem)
            }
          },

          expand: function (event) {
            var newItem =
              this.active &&
              this._menuItems(this.active.children('.ui-menu')).first()

            if (newItem && newItem.length) {
              this._open(newItem.parent())

              // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
              this._delay(function () {
                this.focus(event, newItem)
              })
            }
          },

          next: function (event) {
            this._move('next', 'first', event)
          },

          previous: function (event) {
            this._move('prev', 'last', event)
          },

          isFirstItem: function () {
            return this.active && !this.active.prevAll('.ui-menu-item').length
          },

          isLastItem: function () {
            return this.active && !this.active.nextAll('.ui-menu-item').length
          },

          _menuItems: function (menu) {
            return (menu || this.element)
              .find(this.options.items)
              .filter('.ui-menu-item')
          },

          _move: function (direction, filter, event) {
            var next
            if (this.active) {
              if (direction === 'first' || direction === 'last') {
                next =
                  this.active[direction === 'first' ? 'prevAll' : 'nextAll'](
                    '.ui-menu-item'
                  ).last()
              } else {
                next = this.active[direction + 'All']('.ui-menu-item').first()
              }
            }
            if (!next || !next.length || !this.active) {
              next = this._menuItems(this.activeMenu)[filter]()
            }

            this.focus(event, next)
          },

          nextPage: function (event) {
            var item, base, height

            if (!this.active) {
              this.next(event)
              return
            }
            if (this.isLastItem()) {
              return
            }
            if (this._hasScroll()) {
              base = this.active.offset().top
              height = this.element.innerHeight()

              // jQuery 3.2 doesn't include scrollbars in innerHeight, add it back.
              if ($.fn.jquery.indexOf('3.2.') === 0) {
                height +=
                  this.element[0].offsetHeight - this.element.outerHeight()
              }

              this.active.nextAll('.ui-menu-item').each(function () {
                item = $(this)
                return item.offset().top - base - height < 0
              })

              this.focus(event, item)
            } else {
              this.focus(
                event,
                this._menuItems(this.activeMenu)[
                  !this.active ? 'first' : 'last'
                ]()
              )
            }
          },

          previousPage: function (event) {
            var item, base, height
            if (!this.active) {
              this.next(event)
              return
            }
            if (this.isFirstItem()) {
              return
            }
            if (this._hasScroll()) {
              base = this.active.offset().top
              height = this.element.innerHeight()

              // jQuery 3.2 doesn't include scrollbars in innerHeight, add it back.
              if ($.fn.jquery.indexOf('3.2.') === 0) {
                height +=
                  this.element[0].offsetHeight - this.element.outerHeight()
              }

              this.active.prevAll('.ui-menu-item').each(function () {
                item = $(this)
                return item.offset().top - base + height > 0
              })

              this.focus(event, item)
            } else {
              this.focus(event, this._menuItems(this.activeMenu).first())
            }
          },

          _hasScroll: function () {
            return (
              this.element.outerHeight() < this.element.prop('scrollHeight')
            )
          },

          select: function (event) {
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active =
              this.active || $(event.target).closest('.ui-menu-item')
            var ui = { item: this.active }
            if (!this.active.has('.ui-menu').length) {
              this.collapseAll(event, true)
            }
            this._trigger('select', event, ui)
          },

          _filterMenuItems: function (character) {
            var escapedCharacter = character.replace(
                /[\-\[\]{}()*+?.,\\\^$|#\s]/g,
                '\\$&'
              ),
              regex = new RegExp('^' + escapedCharacter, 'i')

            return (
              this.activeMenu
                .find(this.options.items)

                // Only match on items, not dividers or other content (#10571)
                .filter('.ui-menu-item')
                .filter(function () {
                  return regex.test(
                    String.prototype.trim.call(
                      $(this).children('.ui-menu-item-wrapper').text()
                    )
                  )
                })
            )
          }
        })
      })

      /***/
    },

    /***/ 6177: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Mouse 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Mouse
      //>>group: Widgets
      //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
      //>>docs: http://api.jqueryui.com/mouse/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(1870),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        var mouseHandled = false
        $(document).on('mouseup', function () {
          mouseHandled = false
        })

        return $.widget('ui.mouse', {
          version: '1.13.1',
          options: {
            cancel: 'input, textarea, button, select, option',
            distance: 1,
            delay: 0
          },
          _mouseInit: function () {
            var that = this

            this.element
              .on('mousedown.' + this.widgetName, function (event) {
                return that._mouseDown(event)
              })
              .on('click.' + this.widgetName, function (event) {
                if (
                  true ===
                  $.data(event.target, that.widgetName + '.preventClickEvent')
                ) {
                  $.removeData(
                    event.target,
                    that.widgetName + '.preventClickEvent'
                  )
                  event.stopImmediatePropagation()
                  return false
                }
              })

            this.started = false
          },

          // TODO: make sure destroying one instance of mouse doesn't mess with
          // other instances of mouse
          _mouseDestroy: function () {
            this.element.off('.' + this.widgetName)
            if (this._mouseMoveDelegate) {
              this.document
                .off('mousemove.' + this.widgetName, this._mouseMoveDelegate)
                .off('mouseup.' + this.widgetName, this._mouseUpDelegate)
            }
          },

          _mouseDown: function (event) {
            // don't let more than one widget handle mouseStart
            if (mouseHandled) {
              return
            }

            this._mouseMoved = false

            // We may have missed mouseup (out of window)
            if (this._mouseStarted) {
              this._mouseUp(event)
            }

            this._mouseDownEvent = event

            var that = this,
              btnIsLeft = event.which === 1,
              // event.target.nodeName works around a bug in IE 8 with
              // disabled inputs (#7620)
              elIsCancel =
                typeof this.options.cancel === 'string' && event.target.nodeName
                  ? $(event.target).closest(this.options.cancel).length
                  : false
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
              return true
            }

            this.mouseDelayMet = !this.options.delay
            if (!this.mouseDelayMet) {
              this._mouseDelayTimer = setTimeout(function () {
                that.mouseDelayMet = true
              }, this.options.delay)
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
              this._mouseStarted = this._mouseStart(event) !== false
              if (!this._mouseStarted) {
                event.preventDefault()
                return true
              }
            }

            // Click event may never have fired (Gecko & Opera)
            if (
              true ===
              $.data(event.target, this.widgetName + '.preventClickEvent')
            ) {
              $.removeData(event.target, this.widgetName + '.preventClickEvent')
            }

            // These delegates are required to keep context
            this._mouseMoveDelegate = function (event) {
              return that._mouseMove(event)
            }
            this._mouseUpDelegate = function (event) {
              return that._mouseUp(event)
            }

            this.document
              .on('mousemove.' + this.widgetName, this._mouseMoveDelegate)
              .on('mouseup.' + this.widgetName, this._mouseUpDelegate)

            event.preventDefault()

            mouseHandled = true
            return true
          },

          _mouseMove: function (event) {
            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if (this._mouseMoved) {
              // IE mouseup check - mouseup happened when mouse was out of window
              if (
                $.ui.ie &&
                (!document.documentMode || document.documentMode < 9) &&
                !event.button
              ) {
                return this._mouseUp(event)

                // Iframe mouseup check - mouseup occurred in another document
              } else if (!event.which) {
                // Support: Safari <=8 - 9
                // Safari sets which to 0 if you press any of the following keys
                // during a drag (#14461)
                if (
                  event.originalEvent.altKey ||
                  event.originalEvent.ctrlKey ||
                  event.originalEvent.metaKey ||
                  event.originalEvent.shiftKey
                ) {
                  this.ignoreMissingWhich = true
                } else if (!this.ignoreMissingWhich) {
                  return this._mouseUp(event)
                }
              }
            }

            if (event.which || event.button) {
              this._mouseMoved = true
            }

            if (this._mouseStarted) {
              this._mouseDrag(event)
              return event.preventDefault()
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
              this._mouseStarted =
                this._mouseStart(this._mouseDownEvent, event) !== false
              if (this._mouseStarted) {
                this._mouseDrag(event)
              } else {
                this._mouseUp(event)
              }
            }

            return !this._mouseStarted
          },

          _mouseUp: function (event) {
            this.document
              .off('mousemove.' + this.widgetName, this._mouseMoveDelegate)
              .off('mouseup.' + this.widgetName, this._mouseUpDelegate)

            if (this._mouseStarted) {
              this._mouseStarted = false

              if (event.target === this._mouseDownEvent.target) {
                $.data(
                  event.target,
                  this.widgetName + '.preventClickEvent',
                  true
                )
              }

              this._mouseStop(event)
            }

            if (this._mouseDelayTimer) {
              clearTimeout(this._mouseDelayTimer)
              delete this._mouseDelayTimer
            }

            this.ignoreMissingWhich = false
            mouseHandled = false
            event.preventDefault()
          },

          _mouseDistanceMet: function (event) {
            return (
              Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
              ) >= this.options.distance
            )
          },

          _mouseDelayMet: function (/* event */) {
            return this.mouseDelayMet
          },

          // These are placeholder methods, to be overriden by extending plugin
          _mouseStart: function (/* event */) {},
          _mouseDrag: function (/* event */) {},
          _mouseStop: function (/* event */) {},
          _mouseCapture: function (/* event */) {
            return true
          }
        })
      })

      /***/
    },

    /***/ 1707: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery UI Resizable 1.13.1
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Resizable
      //>>group: Interactions
      //>>description: Enables resize functionality for any element.
      //>>docs: http://api.jqueryui.com/resizable/
      //>>demos: http://jqueryui.com/resizable/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/resizable.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(6177),
            __webpack_require__(2064),
            __webpack_require__(1624),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.resizable', $.ui.mouse, {
          version: '1.13.1',
          widgetEventPrefix: 'resize',
          options: {
            alsoResize: false,
            animate: false,
            animateDuration: 'slow',
            animateEasing: 'swing',
            aspectRatio: false,
            autoHide: false,
            classes: {
              'ui-resizable-se': 'ui-icon ui-icon-gripsmall-diagonal-se'
            },
            containment: false,
            ghost: false,
            grid: false,
            handles: 'e,s,se',
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,

            // See #7960
            zIndex: 90,

            // Callbacks
            resize: null,
            start: null,
            stop: null
          },

          _num: function (value) {
            return parseFloat(value) || 0
          },

          _isNumber: function (value) {
            return !isNaN(parseFloat(value))
          },

          _hasScroll: function (el, a) {
            if ($(el).css('overflow') === 'hidden') {
              return false
            }

            var scroll = a && a === 'left' ? 'scrollLeft' : 'scrollTop',
              has = false

            if (el[scroll] > 0) {
              return true
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            try {
              el[scroll] = 1
              has = el[scroll] > 0
              el[scroll] = 0
            } catch (e) {
              // `el` might be a string, then setting `scroll` will throw
              // an error in strict mode; ignore it.
            }
            return has
          },

          _create: function () {
            var margins,
              o = this.options,
              that = this
            this._addClass('ui-resizable')

            $.extend(this, {
              _aspectRatio: !!o.aspectRatio,
              aspectRatio: o.aspectRatio,
              originalElement: this.element,
              _proportionallyResizeElements: [],
              _helper:
                o.helper || o.ghost || o.animate
                  ? o.helper || 'ui-resizable-helper'
                  : null
            })

            // Wrap the element if it cannot hold child nodes
            if (
              this.element[0].nodeName.match(
                /^(canvas|textarea|input|select|button|img)$/i
              )
            ) {
              this.element.wrap(
                $("<div class='ui-wrapper'></div>").css({
                  overflow: 'hidden',
                  position: this.element.css('position'),
                  width: this.element.outerWidth(),
                  height: this.element.outerHeight(),
                  top: this.element.css('top'),
                  left: this.element.css('left')
                })
              )

              this.element = this.element
                .parent()
                .data('ui-resizable', this.element.resizable('instance'))

              this.elementIsWrapper = true

              margins = {
                marginTop: this.originalElement.css('marginTop'),
                marginRight: this.originalElement.css('marginRight'),
                marginBottom: this.originalElement.css('marginBottom'),
                marginLeft: this.originalElement.css('marginLeft')
              }

              this.element.css(margins)
              this.originalElement.css('margin', 0)

              // support: Safari
              // Prevent Safari textarea resize
              this.originalResizeStyle = this.originalElement.css('resize')
              this.originalElement.css('resize', 'none')

              this._proportionallyResizeElements.push(
                this.originalElement.css({
                  position: 'static',
                  zoom: 1,
                  display: 'block'
                })
              )

              // Support: IE9
              // avoid IE jump (hard set the margin)
              this.originalElement.css(margins)

              this._proportionallyResize()
            }

            this._setupHandles()

            if (o.autoHide) {
              $(this.element)
                .on('mouseenter', function () {
                  if (o.disabled) {
                    return
                  }
                  that._removeClass('ui-resizable-autohide')
                  that._handles.show()
                })
                .on('mouseleave', function () {
                  if (o.disabled) {
                    return
                  }
                  if (!that.resizing) {
                    that._addClass('ui-resizable-autohide')
                    that._handles.hide()
                  }
                })
            }

            this._mouseInit()
          },

          _destroy: function () {
            this._mouseDestroy()
            this._addedHandles.remove()

            var wrapper,
              _destroy = function (exp) {
                $(exp)
                  .removeData('resizable')
                  .removeData('ui-resizable')
                  .off('.resizable')
              }

            // TODO: Unwrap at same DOM position
            if (this.elementIsWrapper) {
              _destroy(this.element)
              wrapper = this.element
              this.originalElement
                .css({
                  position: wrapper.css('position'),
                  width: wrapper.outerWidth(),
                  height: wrapper.outerHeight(),
                  top: wrapper.css('top'),
                  left: wrapper.css('left')
                })
                .insertAfter(wrapper)
              wrapper.remove()
            }

            this.originalElement.css('resize', this.originalResizeStyle)
            _destroy(this.originalElement)

            return this
          },

          _setOption: function (key, value) {
            this._super(key, value)

            switch (key) {
              case 'handles':
                this._removeHandles()
                this._setupHandles()
                break
              case 'aspectRatio':
                this._aspectRatio = !!value
                break
              default:
                break
            }
          },

          _setupHandles: function () {
            var o = this.options,
              handle,
              i,
              n,
              hname,
              axis,
              that = this
            this.handles =
              o.handles ||
              (!$('.ui-resizable-handle', this.element).length
                ? 'e,s,se'
                : {
                    n: '.ui-resizable-n',
                    e: '.ui-resizable-e',
                    s: '.ui-resizable-s',
                    w: '.ui-resizable-w',
                    se: '.ui-resizable-se',
                    sw: '.ui-resizable-sw',
                    ne: '.ui-resizable-ne',
                    nw: '.ui-resizable-nw'
                  })

            this._handles = $()
            this._addedHandles = $()
            if (this.handles.constructor === String) {
              if (this.handles === 'all') {
                this.handles = 'n,e,s,w,se,sw,ne,nw'
              }

              n = this.handles.split(',')
              this.handles = {}

              for (i = 0; i < n.length; i++) {
                handle = String.prototype.trim.call(n[i])
                hname = 'ui-resizable-' + handle
                axis = $('<div>')
                this._addClass(axis, 'ui-resizable-handle ' + hname)

                axis.css({ zIndex: o.zIndex })

                this.handles[handle] = '.ui-resizable-' + handle
                if (!this.element.children(this.handles[handle]).length) {
                  this.element.append(axis)
                  this._addedHandles = this._addedHandles.add(axis)
                }
              }
            }

            this._renderAxis = function (target) {
              var i, axis, padPos, padWrapper

              target = target || this.element

              for (i in this.handles) {
                if (this.handles[i].constructor === String) {
                  this.handles[i] = this.element
                    .children(this.handles[i])
                    .first()
                    .show()
                } else if (this.handles[i].jquery || this.handles[i].nodeType) {
                  this.handles[i] = $(this.handles[i])
                  this._on(this.handles[i], { mousedown: that._mouseDown })
                }

                if (
                  this.elementIsWrapper &&
                  this.originalElement[0].nodeName.match(
                    /^(textarea|input|select|button)$/i
                  )
                ) {
                  axis = $(this.handles[i], this.element)

                  padWrapper = /sw|ne|nw|se|n|s/.test(i)
                    ? axis.outerHeight()
                    : axis.outerWidth()

                  padPos = [
                    'padding',
                    /ne|nw|n/.test(i)
                      ? 'Top'
                      : /se|sw|s/.test(i)
                      ? 'Bottom'
                      : /^e$/.test(i)
                      ? 'Right'
                      : 'Left'
                  ].join('')

                  target.css(padPos, padWrapper)

                  this._proportionallyResize()
                }

                this._handles = this._handles.add(this.handles[i])
              }
            }

            // TODO: make renderAxis a prototype function
            this._renderAxis(this.element)

            this._handles = this._handles.add(
              this.element.find('.ui-resizable-handle')
            )
            this._handles.disableSelection()

            this._handles.on('mouseover', function () {
              if (!that.resizing) {
                if (this.className) {
                  axis = this.className.match(
                    /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i
                  )
                }
                that.axis = axis && axis[1] ? axis[1] : 'se'
              }
            })

            if (o.autoHide) {
              this._handles.hide()
              this._addClass('ui-resizable-autohide')
            }
          },

          _removeHandles: function () {
            this._addedHandles.remove()
          },

          _mouseCapture: function (event) {
            var i,
              handle,
              capture = false

            for (i in this.handles) {
              handle = $(this.handles[i])[0]
              if (handle === event.target || $.contains(handle, event.target)) {
                capture = true
              }
            }

            return !this.options.disabled && capture
          },

          _mouseStart: function (event) {
            var curleft,
              curtop,
              cursor,
              o = this.options,
              el = this.element

            this.resizing = true

            this._renderProxy()

            curleft = this._num(this.helper.css('left'))
            curtop = this._num(this.helper.css('top'))

            if (o.containment) {
              curleft += $(o.containment).scrollLeft() || 0
              curtop += $(o.containment).scrollTop() || 0
            }

            this.offset = this.helper.offset()
            this.position = { left: curleft, top: curtop }

            this.size = this._helper
              ? {
                  width: this.helper.width(),
                  height: this.helper.height()
                }
              : {
                  width: el.width(),
                  height: el.height()
                }

            this.originalSize = this._helper
              ? {
                  width: el.outerWidth(),
                  height: el.outerHeight()
                }
              : {
                  width: el.width(),
                  height: el.height()
                }

            this.sizeDiff = {
              width: el.outerWidth() - el.width(),
              height: el.outerHeight() - el.height()
            }

            this.originalPosition = { left: curleft, top: curtop }
            this.originalMousePosition = { left: event.pageX, top: event.pageY }

            this.aspectRatio =
              typeof o.aspectRatio === 'number'
                ? o.aspectRatio
                : this.originalSize.width / this.originalSize.height || 1

            cursor = $('.ui-resizable-' + this.axis).css('cursor')
            $('body').css(
              'cursor',
              cursor === 'auto' ? this.axis + '-resize' : cursor
            )

            this._addClass('ui-resizable-resizing')
            this._propagate('start', event)
            return true
          },

          _mouseDrag: function (event) {
            var data,
              props,
              smp = this.originalMousePosition,
              a = this.axis,
              dx = event.pageX - smp.left || 0,
              dy = event.pageY - smp.top || 0,
              trigger = this._change[a]

            this._updatePrevProperties()

            if (!trigger) {
              return false
            }

            data = trigger.apply(this, [event, dx, dy])

            this._updateVirtualBoundaries(event.shiftKey)
            if (this._aspectRatio || event.shiftKey) {
              data = this._updateRatio(data, event)
            }

            data = this._respectSize(data, event)

            this._updateCache(data)

            this._propagate('resize', event)

            props = this._applyChanges()

            if (!this._helper && this._proportionallyResizeElements.length) {
              this._proportionallyResize()
            }

            if (!$.isEmptyObject(props)) {
              this._updatePrevProperties()
              this._trigger('resize', event, this.ui())
              this._applyChanges()
            }

            return false
          },

          _mouseStop: function (event) {
            this.resizing = false
            var pr,
              ista,
              soffseth,
              soffsetw,
              s,
              left,
              top,
              o = this.options,
              that = this

            if (this._helper) {
              pr = this._proportionallyResizeElements
              ista = pr.length && /textarea/i.test(pr[0].nodeName)
              soffseth =
                ista && this._hasScroll(pr[0], 'left')
                  ? 0
                  : that.sizeDiff.height
              soffsetw = ista ? 0 : that.sizeDiff.width

              s = {
                width: that.helper.width() - soffsetw,
                height: that.helper.height() - soffseth
              }
              left =
                parseFloat(that.element.css('left')) +
                  (that.position.left - that.originalPosition.left) || null
              top =
                parseFloat(that.element.css('top')) +
                  (that.position.top - that.originalPosition.top) || null

              if (!o.animate) {
                this.element.css($.extend(s, { top: top, left: left }))
              }

              that.helper.height(that.size.height)
              that.helper.width(that.size.width)

              if (this._helper && !o.animate) {
                this._proportionallyResize()
              }
            }

            $('body').css('cursor', 'auto')

            this._removeClass('ui-resizable-resizing')

            this._propagate('stop', event)

            if (this._helper) {
              this.helper.remove()
            }

            return false
          },

          _updatePrevProperties: function () {
            this.prevPosition = {
              top: this.position.top,
              left: this.position.left
            }
            this.prevSize = {
              width: this.size.width,
              height: this.size.height
            }
          },

          _applyChanges: function () {
            var props = {}

            if (this.position.top !== this.prevPosition.top) {
              props.top = this.position.top + 'px'
            }
            if (this.position.left !== this.prevPosition.left) {
              props.left = this.position.left + 'px'
            }
            if (this.size.width !== this.prevSize.width) {
              props.width = this.size.width + 'px'
            }
            if (this.size.height !== this.prevSize.height) {
              props.height = this.size.height + 'px'
            }

            this.helper.css(props)

            return props
          },

          _updateVirtualBoundaries: function (forceAspectRatio) {
            var pMinWidth,
              pMaxWidth,
              pMinHeight,
              pMaxHeight,
              b,
              o = this.options

            b = {
              minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
              maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
              minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
              maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            }

            if (this._aspectRatio || forceAspectRatio) {
              pMinWidth = b.minHeight * this.aspectRatio
              pMinHeight = b.minWidth / this.aspectRatio
              pMaxWidth = b.maxHeight * this.aspectRatio
              pMaxHeight = b.maxWidth / this.aspectRatio

              if (pMinWidth > b.minWidth) {
                b.minWidth = pMinWidth
              }
              if (pMinHeight > b.minHeight) {
                b.minHeight = pMinHeight
              }
              if (pMaxWidth < b.maxWidth) {
                b.maxWidth = pMaxWidth
              }
              if (pMaxHeight < b.maxHeight) {
                b.maxHeight = pMaxHeight
              }
            }
            this._vBoundaries = b
          },

          _updateCache: function (data) {
            this.offset = this.helper.offset()
            if (this._isNumber(data.left)) {
              this.position.left = data.left
            }
            if (this._isNumber(data.top)) {
              this.position.top = data.top
            }
            if (this._isNumber(data.height)) {
              this.size.height = data.height
            }
            if (this._isNumber(data.width)) {
              this.size.width = data.width
            }
          },

          _updateRatio: function (data) {
            var cpos = this.position,
              csize = this.size,
              a = this.axis

            if (this._isNumber(data.height)) {
              data.width = data.height * this.aspectRatio
            } else if (this._isNumber(data.width)) {
              data.height = data.width / this.aspectRatio
            }

            if (a === 'sw') {
              data.left = cpos.left + (csize.width - data.width)
              data.top = null
            }
            if (a === 'nw') {
              data.top = cpos.top + (csize.height - data.height)
              data.left = cpos.left + (csize.width - data.width)
            }

            return data
          },

          _respectSize: function (data) {
            var o = this._vBoundaries,
              a = this.axis,
              ismaxw =
                this._isNumber(data.width) &&
                o.maxWidth &&
                o.maxWidth < data.width,
              ismaxh =
                this._isNumber(data.height) &&
                o.maxHeight &&
                o.maxHeight < data.height,
              isminw =
                this._isNumber(data.width) &&
                o.minWidth &&
                o.minWidth > data.width,
              isminh =
                this._isNumber(data.height) &&
                o.minHeight &&
                o.minHeight > data.height,
              dw = this.originalPosition.left + this.originalSize.width,
              dh = this.originalPosition.top + this.originalSize.height,
              cw = /sw|nw|w/.test(a),
              ch = /nw|ne|n/.test(a)
            if (isminw) {
              data.width = o.minWidth
            }
            if (isminh) {
              data.height = o.minHeight
            }
            if (ismaxw) {
              data.width = o.maxWidth
            }
            if (ismaxh) {
              data.height = o.maxHeight
            }

            if (isminw && cw) {
              data.left = dw - o.minWidth
            }
            if (ismaxw && cw) {
              data.left = dw - o.maxWidth
            }
            if (isminh && ch) {
              data.top = dh - o.minHeight
            }
            if (ismaxh && ch) {
              data.top = dh - o.maxHeight
            }

            // Fixing jump error on top/left - bug #2330
            if (!data.width && !data.height && !data.left && data.top) {
              data.top = null
            } else if (!data.width && !data.height && !data.top && data.left) {
              data.left = null
            }

            return data
          },

          _getPaddingPlusBorderDimensions: function (element) {
            var i = 0,
              widths = [],
              borders = [
                element.css('borderTopWidth'),
                element.css('borderRightWidth'),
                element.css('borderBottomWidth'),
                element.css('borderLeftWidth')
              ],
              paddings = [
                element.css('paddingTop'),
                element.css('paddingRight'),
                element.css('paddingBottom'),
                element.css('paddingLeft')
              ]

            for (; i < 4; i++) {
              widths[i] = parseFloat(borders[i]) || 0
              widths[i] += parseFloat(paddings[i]) || 0
            }

            return {
              height: widths[0] + widths[2],
              width: widths[1] + widths[3]
            }
          },

          _proportionallyResize: function () {
            if (!this._proportionallyResizeElements.length) {
              return
            }

            var prel,
              i = 0,
              element = this.helper || this.element

            for (; i < this._proportionallyResizeElements.length; i++) {
              prel = this._proportionallyResizeElements[i]

              // TODO: Seems like a bug to cache this.outerDimensions
              // considering that we are in a loop.
              if (!this.outerDimensions) {
                this.outerDimensions =
                  this._getPaddingPlusBorderDimensions(prel)
              }

              prel.css({
                height: element.height() - this.outerDimensions.height || 0,
                width: element.width() - this.outerDimensions.width || 0
              })
            }
          },

          _renderProxy: function () {
            var el = this.element,
              o = this.options
            this.elementOffset = el.offset()

            if (this._helper) {
              this.helper =
                this.helper || $('<div></div>').css({ overflow: 'hidden' })

              this._addClass(this.helper, this._helper)
              this.helper.css({
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
                position: 'absolute',
                left: this.elementOffset.left + 'px',
                top: this.elementOffset.top + 'px',
                zIndex: ++o.zIndex //TODO: Don't modify option
              })

              this.helper.appendTo('body').disableSelection()
            } else {
              this.helper = this.element
            }
          },

          _change: {
            e: function (event, dx) {
              return { width: this.originalSize.width + dx }
            },
            w: function (event, dx) {
              var cs = this.originalSize,
                sp = this.originalPosition
              return { left: sp.left + dx, width: cs.width - dx }
            },
            n: function (event, dx, dy) {
              var cs = this.originalSize,
                sp = this.originalPosition
              return { top: sp.top + dy, height: cs.height - dy }
            },
            s: function (event, dx, dy) {
              return { height: this.originalSize.height + dy }
            },
            se: function (event, dx, dy) {
              return $.extend(
                this._change.s.apply(this, arguments),
                this._change.e.apply(this, [event, dx, dy])
              )
            },
            sw: function (event, dx, dy) {
              return $.extend(
                this._change.s.apply(this, arguments),
                this._change.w.apply(this, [event, dx, dy])
              )
            },
            ne: function (event, dx, dy) {
              return $.extend(
                this._change.n.apply(this, arguments),
                this._change.e.apply(this, [event, dx, dy])
              )
            },
            nw: function (event, dx, dy) {
              return $.extend(
                this._change.n.apply(this, arguments),
                this._change.w.apply(this, [event, dx, dy])
              )
            }
          },

          _propagate: function (n, event) {
            $.ui.plugin.call(this, n, [event, this.ui()])
            if (n !== 'resize') {
              this._trigger(n, event, this.ui())
            }
          },

          plugins: {},

          ui: function () {
            return {
              originalElement: this.originalElement,
              element: this.element,
              helper: this.helper,
              position: this.position,
              size: this.size,
              originalSize: this.originalSize,
              originalPosition: this.originalPosition
            }
          }
        })

        /*
         * Resizable Extensions
         */

        $.ui.plugin.add('resizable', 'animate', {
          stop: function (event) {
            var that = $(this).resizable('instance'),
              o = that.options,
              pr = that._proportionallyResizeElements,
              ista = pr.length && /textarea/i.test(pr[0].nodeName),
              soffseth =
                ista && that._hasScroll(pr[0], 'left')
                  ? 0
                  : that.sizeDiff.height,
              soffsetw = ista ? 0 : that.sizeDiff.width,
              style = {
                width: that.size.width - soffsetw,
                height: that.size.height - soffseth
              },
              left =
                parseFloat(that.element.css('left')) +
                  (that.position.left - that.originalPosition.left) || null,
              top =
                parseFloat(that.element.css('top')) +
                  (that.position.top - that.originalPosition.top) || null

            that.element.animate(
              $.extend(style, top && left ? { top: top, left: left } : {}),
              {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function () {
                  var data = {
                    width: parseFloat(that.element.css('width')),
                    height: parseFloat(that.element.css('height')),
                    top: parseFloat(that.element.css('top')),
                    left: parseFloat(that.element.css('left'))
                  }

                  if (pr && pr.length) {
                    $(pr[0]).css({ width: data.width, height: data.height })
                  }

                  // Propagating resize, and updating values for each animation step
                  that._updateCache(data)
                  that._propagate('resize', event)
                }
              }
            )
          }
        })

        $.ui.plugin.add('resizable', 'containment', {
          start: function () {
            var element,
              p,
              co,
              ch,
              cw,
              width,
              height,
              that = $(this).resizable('instance'),
              o = that.options,
              el = that.element,
              oc = o.containment,
              ce =
                oc instanceof $
                  ? oc.get(0)
                  : /parent/.test(oc)
                  ? el.parent().get(0)
                  : oc

            if (!ce) {
              return
            }

            that.containerElement = $(ce)

            if (/document/.test(oc) || oc === document) {
              that.containerOffset = {
                left: 0,
                top: 0
              }
              that.containerPosition = {
                left: 0,
                top: 0
              }

              that.parentData = {
                element: $(document),
                left: 0,
                top: 0,
                width: $(document).width(),
                height:
                  $(document).height() || document.body.parentNode.scrollHeight
              }
            } else {
              element = $(ce)
              p = []
              $(['Top', 'Right', 'Left', 'Bottom']).each(function (i, name) {
                p[i] = that._num(element.css('padding' + name))
              })

              that.containerOffset = element.offset()
              that.containerPosition = element.position()
              that.containerSize = {
                height: element.innerHeight() - p[3],
                width: element.innerWidth() - p[1]
              }

              co = that.containerOffset
              ch = that.containerSize.height
              cw = that.containerSize.width
              width = that._hasScroll(ce, 'left') ? ce.scrollWidth : cw
              height = that._hasScroll(ce) ? ce.scrollHeight : ch

              that.parentData = {
                element: ce,
                left: co.left,
                top: co.top,
                width: width,
                height: height
              }
            }
          },

          resize: function (event) {
            var woset,
              hoset,
              isParent,
              isOffsetRelative,
              that = $(this).resizable('instance'),
              o = that.options,
              co = that.containerOffset,
              cp = that.position,
              pRatio = that._aspectRatio || event.shiftKey,
              cop = {
                top: 0,
                left: 0
              },
              ce = that.containerElement,
              continueResize = true

            if (ce[0] !== document && /static/.test(ce.css('position'))) {
              cop = co
            }

            if (cp.left < (that._helper ? co.left : 0)) {
              that.size.width =
                that.size.width +
                (that._helper
                  ? that.position.left - co.left
                  : that.position.left - cop.left)

              if (pRatio) {
                that.size.height = that.size.width / that.aspectRatio
                continueResize = false
              }
              that.position.left = o.helper ? co.left : 0
            }

            if (cp.top < (that._helper ? co.top : 0)) {
              that.size.height =
                that.size.height +
                (that._helper ? that.position.top - co.top : that.position.top)

              if (pRatio) {
                that.size.width = that.size.height * that.aspectRatio
                continueResize = false
              }
              that.position.top = that._helper ? co.top : 0
            }

            isParent =
              that.containerElement.get(0) === that.element.parent().get(0)
            isOffsetRelative = /relative|absolute/.test(
              that.containerElement.css('position')
            )

            if (isParent && isOffsetRelative) {
              that.offset.left = that.parentData.left + that.position.left
              that.offset.top = that.parentData.top + that.position.top
            } else {
              that.offset.left = that.element.offset().left
              that.offset.top = that.element.offset().top
            }

            woset = Math.abs(
              that.sizeDiff.width +
                (that._helper
                  ? that.offset.left - cop.left
                  : that.offset.left - co.left)
            )

            hoset = Math.abs(
              that.sizeDiff.height +
                (that._helper
                  ? that.offset.top - cop.top
                  : that.offset.top - co.top)
            )

            if (woset + that.size.width >= that.parentData.width) {
              that.size.width = that.parentData.width - woset
              if (pRatio) {
                that.size.height = that.size.width / that.aspectRatio
                continueResize = false
              }
            }

            if (hoset + that.size.height >= that.parentData.height) {
              that.size.height = that.parentData.height - hoset
              if (pRatio) {
                that.size.width = that.size.height * that.aspectRatio
                continueResize = false
              }
            }

            if (!continueResize) {
              that.position.left = that.prevPosition.left
              that.position.top = that.prevPosition.top
              that.size.width = that.prevSize.width
              that.size.height = that.prevSize.height
            }
          },

          stop: function () {
            var that = $(this).resizable('instance'),
              o = that.options,
              co = that.containerOffset,
              cop = that.containerPosition,
              ce = that.containerElement,
              helper = $(that.helper),
              ho = helper.offset(),
              w = helper.outerWidth() - that.sizeDiff.width,
              h = helper.outerHeight() - that.sizeDiff.height

            if (
              that._helper &&
              !o.animate &&
              /relative/.test(ce.css('position'))
            ) {
              $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
              })
            }

            if (
              that._helper &&
              !o.animate &&
              /static/.test(ce.css('position'))
            ) {
              $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
              })
            }
          }
        })

        $.ui.plugin.add('resizable', 'alsoResize', {
          start: function () {
            var that = $(this).resizable('instance'),
              o = that.options

            $(o.alsoResize).each(function () {
              var el = $(this)
              el.data('ui-resizable-alsoresize', {
                width: parseFloat(el.width()),
                height: parseFloat(el.height()),
                left: parseFloat(el.css('left')),
                top: parseFloat(el.css('top'))
              })
            })
          },

          resize: function (event, ui) {
            var that = $(this).resizable('instance'),
              o = that.options,
              os = that.originalSize,
              op = that.originalPosition,
              delta = {
                height: that.size.height - os.height || 0,
                width: that.size.width - os.width || 0,
                top: that.position.top - op.top || 0,
                left: that.position.left - op.left || 0
              }

            $(o.alsoResize).each(function () {
              var el = $(this),
                start = $(this).data('ui-resizable-alsoresize'),
                style = {},
                css = el.parents(ui.originalElement[0]).length
                  ? ['width', 'height']
                  : ['width', 'height', 'top', 'left']

              $.each(css, function (i, prop) {
                var sum = (start[prop] || 0) + (delta[prop] || 0)
                if (sum && sum >= 0) {
                  style[prop] = sum || null
                }
              })

              el.css(style)
            })
          },

          stop: function () {
            $(this).removeData('ui-resizable-alsoresize')
          }
        })

        $.ui.plugin.add('resizable', 'ghost', {
          start: function () {
            var that = $(this).resizable('instance'),
              cs = that.size

            that.ghost = that.originalElement.clone()
            that.ghost.css({
              opacity: 0.25,
              display: 'block',
              position: 'relative',
              height: cs.height,
              width: cs.width,
              margin: 0,
              left: 0,
              top: 0
            })

            that._addClass(that.ghost, 'ui-resizable-ghost')

            // DEPRECATED
            // TODO: remove after 1.12
            if (
              $.uiBackCompat !== false &&
              typeof that.options.ghost === 'string'
            ) {
              // Ghost option
              that.ghost.addClass(this.options.ghost)
            }

            that.ghost.appendTo(that.helper)
          },

          resize: function () {
            var that = $(this).resizable('instance')
            if (that.ghost) {
              that.ghost.css({
                position: 'relative',
                height: that.size.height,
                width: that.size.width
              })
            }
          },

          stop: function () {
            var that = $(this).resizable('instance')
            if (that.ghost && that.helper) {
              that.helper.get(0).removeChild(that.ghost.get(0))
            }
          }
        })

        $.ui.plugin.add('resizable', 'grid', {
          resize: function () {
            var outerDimensions,
              that = $(this).resizable('instance'),
              o = that.options,
              cs = that.size,
              os = that.originalSize,
              op = that.originalPosition,
              a = that.axis,
              grid = typeof o.grid === 'number' ? [o.grid, o.grid] : o.grid,
              gridX = grid[0] || 1,
              gridY = grid[1] || 1,
              ox = Math.round((cs.width - os.width) / gridX) * gridX,
              oy = Math.round((cs.height - os.height) / gridY) * gridY,
              newWidth = os.width + ox,
              newHeight = os.height + oy,
              isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
              isMaxHeight = o.maxHeight && o.maxHeight < newHeight,
              isMinWidth = o.minWidth && o.minWidth > newWidth,
              isMinHeight = o.minHeight && o.minHeight > newHeight

            o.grid = grid

            if (isMinWidth) {
              newWidth += gridX
            }
            if (isMinHeight) {
              newHeight += gridY
            }
            if (isMaxWidth) {
              newWidth -= gridX
            }
            if (isMaxHeight) {
              newHeight -= gridY
            }

            if (/^(se|s|e)$/.test(a)) {
              that.size.width = newWidth
              that.size.height = newHeight
            } else if (/^(ne)$/.test(a)) {
              that.size.width = newWidth
              that.size.height = newHeight
              that.position.top = op.top - oy
            } else if (/^(sw)$/.test(a)) {
              that.size.width = newWidth
              that.size.height = newHeight
              that.position.left = op.left - ox
            } else {
              if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                outerDimensions = that._getPaddingPlusBorderDimensions(this)
              }

              if (newHeight - gridY > 0) {
                that.size.height = newHeight
                that.position.top = op.top - oy
              } else {
                newHeight = gridY - outerDimensions.height
                that.size.height = newHeight
                that.position.top = op.top + os.height - newHeight
              }
              if (newWidth - gridX > 0) {
                that.size.width = newWidth
                that.position.left = op.left - ox
              } else {
                newWidth = gridX - outerDimensions.width
                that.size.width = newWidth
                that.position.left = op.left + os.width - newWidth
              }
            }
          }
        })

        return $.ui.resizable
      })

      /***/
    },

    /***/ 9755: /***/ function (module, exports) {
      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__
      /*!
       * jQuery JavaScript Library v3.6.0
       * https://jquery.com/
       *
       * Includes Sizzle.js
       * https://sizzlejs.com/
       *
       * Copyright OpenJS Foundation and other contributors
       * Released under the MIT license
       * https://jquery.org/license
       *
       * Date: 2021-03-02T17:08Z
       */
      ;(function (global, factory) {
        'use strict'

        if (true && typeof module.exports === 'object') {
          // For CommonJS and CommonJS-like environments where a proper `window`
          // is present, execute the factory and get jQuery.
          // For environments that do not have a `window` with a `document`
          // (such as Node.js), expose a factory as module.exports.
          // This accentuates the need for the creation of a real `window`.
          // e.g. var jQuery = require("jquery")(window);
          // See ticket #14549 for more info.
          module.exports = global.document
            ? factory(global, true)
            : function (w) {
                if (!w.document) {
                  throw new Error('jQuery requires a window with a document')
                }
                return factory(w)
              }
        } else {
          factory(global)
        }

        // Pass this if window is not defined yet
      })(
        typeof window !== 'undefined' ? window : this,
        function (window, noGlobal) {
          // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
          // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
          // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
          // enough that all such attempts are guarded in a try block.
          'use strict'

          var arr = []

          var getProto = Object.getPrototypeOf

          var slice = arr.slice

          var flat = arr.flat
            ? function (array) {
                return arr.flat.call(array)
              }
            : function (array) {
                return arr.concat.apply([], array)
              }

          var push = arr.push

          var indexOf = arr.indexOf

          var class2type = {}

          var toString = class2type.toString

          var hasOwn = class2type.hasOwnProperty

          var fnToString = hasOwn.toString

          var ObjectFunctionString = fnToString.call(Object)

          var support = {}

          var isFunction = function isFunction(obj) {
            // Support: Chrome <=57, Firefox <=52
            // In some browsers, typeof returns "function" for HTML <object> elements
            // (i.e., `typeof document.createElement( "object" ) === "function"`).
            // We don't want to classify *any* DOM node as a function.
            // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
            // Plus for old WebKit, typeof returns "function" for HTML collections
            // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
            return (
              typeof obj === 'function' &&
              typeof obj.nodeType !== 'number' &&
              typeof obj.item !== 'function'
            )
          }

          var isWindow = function isWindow(obj) {
            return obj != null && obj === obj.window
          }

          var document = window.document

          var preservedScriptAttributes = {
            type: true,
            src: true,
            nonce: true,
            noModule: true
          }

          function DOMEval(code, node, doc) {
            doc = doc || document

            var i,
              val,
              script = doc.createElement('script')

            script.text = code
            if (node) {
              for (i in preservedScriptAttributes) {
                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[i] || (node.getAttribute && node.getAttribute(i))
                if (val) {
                  script.setAttribute(i, val)
                }
              }
            }
            doc.head.appendChild(script).parentNode.removeChild(script)
          }

          function toType(obj) {
            if (obj == null) {
              return obj + ''
            }

            // Support: Android <=2.3 only (functionish RegExp)
            return typeof obj === 'object' || typeof obj === 'function'
              ? class2type[toString.call(obj)] || 'object'
              : typeof obj
          }
          /* global Symbol */
          // Defining this global in .eslintrc.json would create a danger of using the global
          // unguarded in another place, it seems safer to define global only for this module

          var version = '3.6.0',
            // Define a local copy of jQuery
            jQuery = function (selector, context) {
              // The jQuery object is actually just the init constructor 'enhanced'
              // Need init if jQuery is called (just allow error to be thrown if not included)
              return new jQuery.fn.init(selector, context)
            }

          jQuery.fn = jQuery.prototype = {
            // The current version of jQuery being used
            jquery: version,

            constructor: jQuery,

            // The default length of a jQuery object is 0
            length: 0,

            toArray: function () {
              return slice.call(this)
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
              // Return all the elements in a clean array
              if (num == null) {
                return slice.call(this)
              }

              // Return just the one element from the set
              return num < 0 ? this[num + this.length] : this[num]
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems) {
              // Build a new jQuery matched element set
              var ret = jQuery.merge(this.constructor(), elems)

              // Add the old object onto the stack (as a reference)
              ret.prevObject = this

              // Return the newly-formed element set
              return ret
            },

            // Execute a callback for every element in the matched set.
            each: function (callback) {
              return jQuery.each(this, callback)
            },

            map: function (callback) {
              return this.pushStack(
                jQuery.map(this, function (elem, i) {
                  return callback.call(elem, i, elem)
                })
              )
            },

            slice: function () {
              return this.pushStack(slice.apply(this, arguments))
            },

            first: function () {
              return this.eq(0)
            },

            last: function () {
              return this.eq(-1)
            },

            even: function () {
              return this.pushStack(
                jQuery.grep(this, function (_elem, i) {
                  return (i + 1) % 2
                })
              )
            },

            odd: function () {
              return this.pushStack(
                jQuery.grep(this, function (_elem, i) {
                  return i % 2
                })
              )
            },

            eq: function (i) {
              var len = this.length,
                j = +i + (i < 0 ? len : 0)
              return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
            },

            end: function () {
              return this.prevObject || this.constructor()
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: arr.sort,
            splice: arr.splice
          }

          jQuery.extend = jQuery.fn.extend = function () {
            var options,
              name,
              src,
              copy,
              copyIsArray,
              clone,
              target = arguments[0] || {},
              i = 1,
              length = arguments.length,
              deep = false

            // Handle a deep copy situation
            if (typeof target === 'boolean') {
              deep = target

              // Skip the boolean and the target
              target = arguments[i] || {}
              i++
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== 'object' && !isFunction(target)) {
              target = {}
            }

            // Extend jQuery itself if only one argument is passed
            if (i === length) {
              target = this
              i--
            }

            for (; i < length; i++) {
              // Only deal with non-null/undefined values
              if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                  copy = options[name]

                  // Prevent Object.prototype pollution
                  // Prevent never-ending loop
                  if (name === '__proto__' || target === copy) {
                    continue
                  }

                  // Recurse if we're merging plain objects or arrays
                  if (
                    deep &&
                    copy &&
                    (jQuery.isPlainObject(copy) ||
                      (copyIsArray = Array.isArray(copy)))
                  ) {
                    src = target[name]

                    // Ensure proper type for the source value
                    if (copyIsArray && !Array.isArray(src)) {
                      clone = []
                    } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                      clone = {}
                    } else {
                      clone = src
                    }
                    copyIsArray = false

                    // Never move original objects, clone them
                    target[name] = jQuery.extend(deep, clone, copy)

                    // Don't bring in undefined values
                  } else if (copy !== undefined) {
                    target[name] = copy
                  }
                }
              }
            }

            // Return the modified object
            return target
          }

          jQuery.extend({
            // Unique for each copy of jQuery on the page
            expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),

            // Assume jQuery is ready without the ready module
            isReady: true,

            error: function (msg) {
              throw new Error(msg)
            },

            noop: function () {},

            isPlainObject: function (obj) {
              var proto, Ctor

              // Detect obvious negatives
              // Use toString instead of jQuery.type to catch host objects
              if (!obj || toString.call(obj) !== '[object Object]') {
                return false
              }

              proto = getProto(obj)

              // Objects with no prototype (e.g., `Object.create( null )`) are plain
              if (!proto) {
                return true
              }

              // Objects with prototype are plain iff they were constructed by a global Object function
              Ctor = hasOwn.call(proto, 'constructor') && proto.constructor
              return (
                typeof Ctor === 'function' &&
                fnToString.call(Ctor) === ObjectFunctionString
              )
            },

            isEmptyObject: function (obj) {
              var name

              for (name in obj) {
                return false
              }
              return true
            },

            // Evaluates a script in a provided context; falls back to the global one
            // if not specified.
            globalEval: function (code, options, doc) {
              DOMEval(code, { nonce: options && options.nonce }, doc)
            },

            each: function (obj, callback) {
              var length,
                i = 0

              if (isArrayLike(obj)) {
                length = obj.length
                for (; i < length; i++) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break
                  }
                }
              } else {
                for (i in obj) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break
                  }
                }
              }

              return obj
            },

            // results is for internal usage only
            makeArray: function (arr, results) {
              var ret = results || []

              if (arr != null) {
                if (isArrayLike(Object(arr))) {
                  jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr)
                } else {
                  push.call(ret, arr)
                }
              }

              return ret
            },

            inArray: function (elem, arr, i) {
              return arr == null ? -1 : indexOf.call(arr, elem, i)
            },

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            merge: function (first, second) {
              var len = +second.length,
                j = 0,
                i = first.length

              for (; j < len; j++) {
                first[i++] = second[j]
              }

              first.length = i

              return first
            },

            grep: function (elems, callback, invert) {
              var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert

              // Go through the array, only saving the items
              // that pass the validator function
              for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i)
                if (callbackInverse !== callbackExpect) {
                  matches.push(elems[i])
                }
              }

              return matches
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
              var length,
                value,
                i = 0,
                ret = []

              // Go through the array, translating each of the items to their new values
              if (isArrayLike(elems)) {
                length = elems.length
                for (; i < length; i++) {
                  value = callback(elems[i], i, arg)

                  if (value != null) {
                    ret.push(value)
                  }
                }

                // Go through every key on the object,
              } else {
                for (i in elems) {
                  value = callback(elems[i], i, arg)

                  if (value != null) {
                    ret.push(value)
                  }
                }
              }

              // Flatten any nested arrays
              return flat(ret)
            },

            // A global GUID counter for objects
            guid: 1,

            // jQuery.support is not used in Core but other projects attach their
            // properties to it so it needs to exist.
            support: support
          })

          if (typeof Symbol === 'function') {
            jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]
          }

          // Populate the class2type map
          jQuery.each(
            'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(
              ' '
            ),
            function (_i, name) {
              class2type['[object ' + name + ']'] = name.toLowerCase()
            }
          )

          function isArrayLike(obj) {
            // Support: real iOS 8.2 only (not reproducible in simulator)
            // `in` check used to prevent JIT error (gh-2145)
            // hasOwn isn't used here due to false negatives
            // regarding Nodelist length in IE
            var length = !!obj && 'length' in obj && obj.length,
              type = toType(obj)

            if (isFunction(obj) || isWindow(obj)) {
              return false
            }

            return (
              type === 'array' ||
              length === 0 ||
              (typeof length === 'number' && length > 0 && length - 1 in obj)
            )
          }
          var Sizzle =
            /*!
             * Sizzle CSS Selector Engine v2.3.6
             * https://sizzlejs.com/
             *
             * Copyright JS Foundation and other contributors
             * Released under the MIT license
             * https://js.foundation/
             *
             * Date: 2021-02-16
             */
            (function (window) {
              var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,
                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,
                // Instance-specific data
                expando = 'sizzle' + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                nonnativeSelectorCache = createCache(),
                sortOrder = function (a, b) {
                  if (a === b) {
                    hasDuplicate = true
                  }
                  return 0
                },
                // Instance methods
                hasOwn = {}.hasOwnProperty,
                arr = [],
                pop = arr.pop,
                pushNative = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf as it's faster than native
                // https://jsperf.com/thor-indexof-vs-for/5
                indexOf = function (list, elem) {
                  var i = 0,
                    len = list.length
                  for (; i < len; i++) {
                    if (list[i] === elem) {
                      return i
                    }
                  }
                  return -1
                },
                booleans =
                  'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|' +
                  'ismap|loop|multiple|open|readonly|required|scoped',
                // Regular expressions

                // http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = '[\\x20\\t\\r\\n\\f]',
                // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
                identifier =
                  '(?:\\\\[\\da-fA-F]{1,6}' +
                  whitespace +
                  '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+',
                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes =
                  '\\[' +
                  whitespace +
                  '*(' +
                  identifier +
                  ')(?:' +
                  whitespace +
                  // Operator (capture 2)
                  '*([*^$|!~]?=)' +
                  whitespace +
                  // "Attribute values must be CSS identifiers [capture 5]
                  // or strings [capture 3 or capture 4]"
                  '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' +
                  identifier +
                  '))|)' +
                  whitespace +
                  '*\\]',
                pseudos =
                  ':(' +
                  identifier +
                  ')(?:\\((' +
                  // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                  // 1. quoted (capture 3; capture 4 or capture 5)
                  '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' +
                  // 2. simple (capture 6)
                  '((?:\\\\.|[^\\\\()[\\]]|' +
                  attributes +
                  ')*)|' +
                  // 3. anything else (capture 2)
                  '.*' +
                  ')\\)|)',
                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp(whitespace + '+', 'g'),
                rtrim = new RegExp(
                  '^' +
                    whitespace +
                    '+|((?:^|[^\\\\])(?:\\\\.)*)' +
                    whitespace +
                    '+$',
                  'g'
                ),
                rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),
                rcombinators = new RegExp(
                  '^' +
                    whitespace +
                    '*([>+~]|' +
                    whitespace +
                    ')' +
                    whitespace +
                    '*'
                ),
                rdescend = new RegExp(whitespace + '|>'),
                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp('^' + identifier + '$'),
                matchExpr = {
                  ID: new RegExp('^#(' + identifier + ')'),
                  CLASS: new RegExp('^\\.(' + identifier + ')'),
                  TAG: new RegExp('^(' + identifier + '|[*])'),
                  ATTR: new RegExp('^' + attributes),
                  PSEUDO: new RegExp('^' + pseudos),
                  CHILD: new RegExp(
                    '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' +
                      whitespace +
                      '*(even|odd|(([+-]|)(\\d*)n|)' +
                      whitespace +
                      '*(?:([+-]|)' +
                      whitespace +
                      '*(\\d+)|))' +
                      whitespace +
                      '*\\)|)',
                    'i'
                  ),
                  bool: new RegExp('^(?:' + booleans + ')$', 'i'),

                  // For use in libraries implementing .is()
                  // We use this for POS matching in `select`
                  needsContext: new RegExp(
                    '^' +
                      whitespace +
                      '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' +
                      whitespace +
                      '*((?:-\\d)?\\d*)' +
                      whitespace +
                      '*\\)|)(?=[^-]|$)',
                    'i'
                  )
                },
                rhtml = /HTML$/i,
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,
                rnative = /^[^{]+\{\s*\[native \w/,
                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                rsibling = /[+~]/,
                // CSS escapes
                // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp(
                  '\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\([^\\r\\n\\f])',
                  'g'
                ),
                funescape = function (escape, nonHex) {
                  var high = '0x' + escape.slice(1) - 0x10000

                  return nonHex
                    ? // Strip the backslash prefix from a non-hex escape sequence
                      nonHex
                    : // Replace a hexadecimal escape sequence with the encoded Unicode code point
                    // Support: IE <=11+
                    // For values outside the Basic Multilingual Plane (BMP), manually construct a
                    // surrogate pair
                    high < 0
                    ? String.fromCharCode(high + 0x10000)
                    : String.fromCharCode(
                        (high >> 10) | 0xd800,
                        (high & 0x3ff) | 0xdc00
                      )
                },
                // CSS string/identifier serialization
                // https://drafts.csswg.org/cssom/#common-serializing-idioms
                rcssescape =
                  /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                fcssescape = function (ch, asCodePoint) {
                  if (asCodePoint) {
                    // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                    if (ch === '\0') {
                      return '\uFFFD'
                    }

                    // Control characters and (dependent upon position) numbers get escaped as code points
                    return (
                      ch.slice(0, -1) +
                      '\\' +
                      ch.charCodeAt(ch.length - 1).toString(16) +
                      ' '
                    )
                  }

                  // Other potentially-special ASCII characters get backslash-escaped
                  return '\\' + ch
                },
                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function () {
                  setDocument()
                },
                inDisabledFieldset = addCombinator(
                  function (elem) {
                    return (
                      elem.disabled === true &&
                      elem.nodeName.toLowerCase() === 'fieldset'
                    )
                  },
                  { dir: 'parentNode', next: 'legend' }
                )

              // Optimize for push.apply( _, NodeList )
              try {
                push.apply(
                  (arr = slice.call(preferredDoc.childNodes)),
                  preferredDoc.childNodes
                )

                // Support: Android<4.0
                // Detect silently failing push.apply
                // eslint-disable-next-line no-unused-expressions
                arr[preferredDoc.childNodes.length].nodeType
              } catch (e) {
                push = {
                  apply: arr.length
                    ? // Leverage slice if possible
                      function (target, els) {
                        pushNative.apply(target, slice.call(els))
                      }
                    : // Support: IE<9
                      // Otherwise append directly
                      function (target, els) {
                        var j = target.length,
                          i = 0

                        // Can't trust NodeList.length
                        while ((target[j++] = els[i++])) {}
                        target.length = j - 1
                      }
                }
              }

              function Sizzle(selector, context, results, seed) {
                var m,
                  i,
                  elem,
                  nid,
                  match,
                  groups,
                  newSelector,
                  newContext = context && context.ownerDocument,
                  // nodeType defaults to 9, since context defaults to document
                  nodeType = context ? context.nodeType : 9

                results = results || []

                // Return early from calls with invalid selector or context
                if (
                  typeof selector !== 'string' ||
                  !selector ||
                  (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
                ) {
                  return results
                }

                // Try to shortcut find operations (as opposed to filters) in HTML documents
                if (!seed) {
                  setDocument(context)
                  context = context || document

                  if (documentIsHTML) {
                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                    // (excepting DocumentFragment context, where the methods don't exist)
                    if (
                      nodeType !== 11 &&
                      (match = rquickExpr.exec(selector))
                    ) {
                      // ID selector
                      if ((m = match[1])) {
                        // Document context
                        if (nodeType === 9) {
                          if ((elem = context.getElementById(m))) {
                            // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if (elem.id === m) {
                              results.push(elem)
                              return results
                            }
                          } else {
                            return results
                          }

                          // Element context
                        } else {
                          // Support: IE, Opera, Webkit
                          // TODO: identify versions
                          // getElementById can match elements by name instead of ID
                          if (
                            newContext &&
                            (elem = newContext.getElementById(m)) &&
                            contains(context, elem) &&
                            elem.id === m
                          ) {
                            results.push(elem)
                            return results
                          }
                        }

                        // Type selector
                      } else if (match[2]) {
                        push.apply(
                          results,
                          context.getElementsByTagName(selector)
                        )
                        return results

                        // Class selector
                      } else if (
                        (m = match[3]) &&
                        support.getElementsByClassName &&
                        context.getElementsByClassName
                      ) {
                        push.apply(results, context.getElementsByClassName(m))
                        return results
                      }
                    }

                    // Take advantage of querySelectorAll
                    if (
                      support.qsa &&
                      !nonnativeSelectorCache[selector + ' '] &&
                      (!rbuggyQSA || !rbuggyQSA.test(selector)) &&
                      // Support: IE 8 only
                      // Exclude object elements
                      (nodeType !== 1 ||
                        context.nodeName.toLowerCase() !== 'object')
                    ) {
                      newSelector = selector
                      newContext = context

                      // qSA considers elements outside a scoping root when evaluating child or
                      // descendant combinators, which is not what we want.
                      // In such cases, we work around the behavior by prefixing every selector in the
                      // list with an ID selector referencing the scope context.
                      // The technique has to be used as well when a leading combinator is used
                      // as such selectors are not recognized by querySelectorAll.
                      // Thanks to Andrew Dupont for this technique.
                      if (
                        nodeType === 1 &&
                        (rdescend.test(selector) || rcombinators.test(selector))
                      ) {
                        // Expand context for sibling selectors
                        newContext =
                          (rsibling.test(selector) &&
                            testContext(context.parentNode)) ||
                          context

                        // We can use :scope instead of the ID hack if the browser
                        // supports it & if we're not changing the context.
                        if (newContext !== context || !support.scope) {
                          // Capture the context ID, setting it first if necessary
                          if ((nid = context.getAttribute('id'))) {
                            nid = nid.replace(rcssescape, fcssescape)
                          } else {
                            context.setAttribute('id', (nid = expando))
                          }
                        }

                        // Prefix every selector in the list
                        groups = tokenize(selector)
                        i = groups.length
                        while (i--) {
                          groups[i] =
                            (nid ? '#' + nid : ':scope') +
                            ' ' +
                            toSelector(groups[i])
                        }
                        newSelector = groups.join(',')
                      }

                      try {
                        push.apply(
                          results,
                          newContext.querySelectorAll(newSelector)
                        )
                        return results
                      } catch (qsaError) {
                        nonnativeSelectorCache(selector, true)
                      } finally {
                        if (nid === expando) {
                          context.removeAttribute('id')
                        }
                      }
                    }
                  }
                }

                // All others
                return select(
                  selector.replace(rtrim, '$1'),
                  context,
                  results,
                  seed
                )
              }

              /**
               * Create key-value caches of limited size
               * @returns {function(string, object)} Returns the Object data after storing it on itself with
               *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
               *	deleting the oldest entry
               */
              function createCache() {
                var keys = []

                function cache(key, value) {
                  // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                  if (keys.push(key + ' ') > Expr.cacheLength) {
                    // Only keep the most recent entries
                    delete cache[keys.shift()]
                  }
                  return (cache[key + ' '] = value)
                }
                return cache
              }

              /**
               * Mark a function for special use by Sizzle
               * @param {Function} fn The function to mark
               */
              function markFunction(fn) {
                fn[expando] = true
                return fn
              }

              /**
               * Support testing using an element
               * @param {Function} fn Passed the created element and returns a boolean result
               */
              function assert(fn) {
                var el = document.createElement('fieldset')

                try {
                  return !!fn(el)
                } catch (e) {
                  return false
                } finally {
                  // Remove from its parent by default
                  if (el.parentNode) {
                    el.parentNode.removeChild(el)
                  }

                  // release memory in IE
                  el = null
                }
              }

              /**
               * Adds the same handler for all of the specified attrs
               * @param {String} attrs Pipe-separated list of attributes
               * @param {Function} handler The method that will be applied
               */
              function addHandle(attrs, handler) {
                var arr = attrs.split('|'),
                  i = arr.length

                while (i--) {
                  Expr.attrHandle[arr[i]] = handler
                }
              }

              /**
               * Checks document order of two siblings
               * @param {Element} a
               * @param {Element} b
               * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
               */
              function siblingCheck(a, b) {
                var cur = b && a,
                  diff =
                    cur &&
                    a.nodeType === 1 &&
                    b.nodeType === 1 &&
                    a.sourceIndex - b.sourceIndex

                // Use IE sourceIndex if available on both nodes
                if (diff) {
                  return diff
                }

                // Check if b follows a
                if (cur) {
                  while ((cur = cur.nextSibling)) {
                    if (cur === b) {
                      return -1
                    }
                  }
                }

                return a ? 1 : -1
              }

              /**
               * Returns a function to use in pseudos for input types
               * @param {String} type
               */
              function createInputPseudo(type) {
                return function (elem) {
                  var name = elem.nodeName.toLowerCase()
                  return name === 'input' && elem.type === type
                }
              }

              /**
               * Returns a function to use in pseudos for buttons
               * @param {String} type
               */
              function createButtonPseudo(type) {
                return function (elem) {
                  var name = elem.nodeName.toLowerCase()
                  return (
                    (name === 'input' || name === 'button') &&
                    elem.type === type
                  )
                }
              }

              /**
               * Returns a function to use in pseudos for :enabled/:disabled
               * @param {Boolean} disabled true for :disabled; false for :enabled
               */
              function createDisabledPseudo(disabled) {
                // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                return function (elem) {
                  // Only certain elements can match :enabled or :disabled
                  // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                  // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                  if ('form' in elem) {
                    // Check for inherited disabledness on relevant non-disabled elements:
                    // * listed form-associated elements in a disabled fieldset
                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                    // * option elements in a disabled optgroup
                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                    // All such elements have a "form" property.
                    if (elem.parentNode && elem.disabled === false) {
                      // Option elements defer to a parent optgroup if present
                      if ('label' in elem) {
                        if ('label' in elem.parentNode) {
                          return elem.parentNode.disabled === disabled
                        } else {
                          return elem.disabled === disabled
                        }
                      }

                      // Support: IE 6 - 11
                      // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                      return (
                        elem.isDisabled === disabled ||
                        // Where there is no isDisabled, check manually
                        /* jshint -W018 */
                        (elem.isDisabled !== !disabled &&
                          inDisabledFieldset(elem) === disabled)
                      )
                    }

                    return elem.disabled === disabled

                    // Try to winnow out elements that can't be disabled before trusting the disabled property.
                    // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                    // even exist on them, let alone have a boolean value.
                  } else if ('label' in elem) {
                    return elem.disabled === disabled
                  }

                  // Remaining elements are neither :enabled nor :disabled
                  return false
                }
              }

              /**
               * Returns a function to use in pseudos for positionals
               * @param {Function} fn
               */
              function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                  argument = +argument
                  return markFunction(function (seed, matches) {
                    var j,
                      matchIndexes = fn([], seed.length, argument),
                      i = matchIndexes.length

                    // Match elements found at the specified indexes
                    while (i--) {
                      if (seed[(j = matchIndexes[i])]) {
                        seed[j] = !(matches[j] = seed[j])
                      }
                    }
                  })
                })
              }

              /**
               * Checks a node for validity as a Sizzle context
               * @param {Element|Object=} context
               * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
               */
              function testContext(context) {
                return (
                  context &&
                  typeof context.getElementsByTagName !== 'undefined' &&
                  context
                )
              }

              // Expose support vars for convenience
              support = Sizzle.support = {}

              /**
               * Detects XML nodes
               * @param {Element|Object} elem An element or a document
               * @returns {Boolean} True iff elem is a non-HTML XML node
               */
              isXML = Sizzle.isXML = function (elem) {
                var namespace = elem && elem.namespaceURI,
                  docElem = elem && (elem.ownerDocument || elem).documentElement

                // Support: IE <=8
                // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
                // https://bugs.jquery.com/ticket/4833
                return !rhtml.test(
                  namespace || (docElem && docElem.nodeName) || 'HTML'
                )
              }

              /**
               * Sets document-related variables once based on the current document
               * @param {Element|Object} [doc] An element or document object to use to set the document
               * @returns {Object} Returns the current document
               */
              setDocument = Sizzle.setDocument = function (node) {
                var hasCompare,
                  subWindow,
                  doc = node ? node.ownerDocument || node : preferredDoc

                // Return early if doc is invalid or already selected
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if (
                  doc == document ||
                  doc.nodeType !== 9 ||
                  !doc.documentElement
                ) {
                  return document
                }

                // Update global variables
                document = doc
                docElem = document.documentElement
                documentIsHTML = !isXML(document)

                // Support: IE 9 - 11+, Edge 12 - 18+
                // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if (
                  preferredDoc != document &&
                  (subWindow = document.defaultView) &&
                  subWindow.top !== subWindow
                ) {
                  // Support: IE 11, Edge
                  if (subWindow.addEventListener) {
                    subWindow.addEventListener('unload', unloadHandler, false)

                    // Support: IE 9 - 10 only
                  } else if (subWindow.attachEvent) {
                    subWindow.attachEvent('onunload', unloadHandler)
                  }
                }

                // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
                // Safari 4 - 5 only, Opera <=11.6 - 12.x only
                // IE/Edge & older browsers don't support the :scope pseudo-class.
                // Support: Safari 6.0 only
                // Safari 6.0 supports :scope but it's an alias of :root there.
                support.scope = assert(function (el) {
                  docElem
                    .appendChild(el)
                    .appendChild(document.createElement('div'))
                  return (
                    typeof el.querySelectorAll !== 'undefined' &&
                    !el.querySelectorAll(':scope fieldset div').length
                  )
                })

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function (el) {
                  el.className = 'i'
                  return !el.getAttribute('className')
                })

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function (el) {
                  el.appendChild(document.createComment(''))
                  return !el.getElementsByTagName('*').length
                })

                // Support: IE<9
                support.getElementsByClassName = rnative.test(
                  document.getElementsByClassName
                )

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programmatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function (el) {
                  docElem.appendChild(el).id = expando
                  return (
                    !document.getElementsByName ||
                    !document.getElementsByName(expando).length
                  )
                })

                // ID filter and find
                if (support.getById) {
                  Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape)
                    return function (elem) {
                      return elem.getAttribute('id') === attrId
                    }
                  }
                  Expr.find['ID'] = function (id, context) {
                    if (
                      typeof context.getElementById !== 'undefined' &&
                      documentIsHTML
                    ) {
                      var elem = context.getElementById(id)
                      return elem ? [elem] : []
                    }
                  }
                } else {
                  Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape)
                    return function (elem) {
                      var node =
                        typeof elem.getAttributeNode !== 'undefined' &&
                        elem.getAttributeNode('id')
                      return node && node.value === attrId
                    }
                  }

                  // Support: IE 6 - 7 only
                  // getElementById is not reliable as a find shortcut
                  Expr.find['ID'] = function (id, context) {
                    if (
                      typeof context.getElementById !== 'undefined' &&
                      documentIsHTML
                    ) {
                      var node,
                        i,
                        elems,
                        elem = context.getElementById(id)

                      if (elem) {
                        // Verify the id attribute
                        node = elem.getAttributeNode('id')
                        if (node && node.value === id) {
                          return [elem]
                        }

                        // Fall back on getElementsByName
                        elems = context.getElementsByName(id)
                        i = 0
                        while ((elem = elems[i++])) {
                          node = elem.getAttributeNode('id')
                          if (node && node.value === id) {
                            return [elem]
                          }
                        }
                      }

                      return []
                    }
                  }
                }

                // Tag
                Expr.find['TAG'] = support.getElementsByTagName
                  ? function (tag, context) {
                      if (typeof context.getElementsByTagName !== 'undefined') {
                        return context.getElementsByTagName(tag)

                        // DocumentFragment nodes don't have gEBTN
                      } else if (support.qsa) {
                        return context.querySelectorAll(tag)
                      }
                    }
                  : function (tag, context) {
                      var elem,
                        tmp = [],
                        i = 0,
                        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                        results = context.getElementsByTagName(tag)

                      // Filter out possible comments
                      if (tag === '*') {
                        while ((elem = results[i++])) {
                          if (elem.nodeType === 1) {
                            tmp.push(elem)
                          }
                        }

                        return tmp
                      }
                      return results
                    }

                // Class
                Expr.find['CLASS'] =
                  support.getElementsByClassName &&
                  function (className, context) {
                    if (
                      typeof context.getElementsByClassName !== 'undefined' &&
                      documentIsHTML
                    ) {
                      return context.getElementsByClassName(className)
                    }
                  }

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = []

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See https://bugs.jquery.com/ticket/13378
                rbuggyQSA = []

                if ((support.qsa = rnative.test(document.querySelectorAll))) {
                  // Build QSA regex
                  // Regex strategy adopted from Diego Perini
                  assert(function (el) {
                    var input

                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // https://bugs.jquery.com/ticket/12359
                    docElem.appendChild(el).innerHTML =
                      "<a id='" +
                      expando +
                      "'></a>" +
                      "<select id='" +
                      expando +
                      "-\r\\' msallowcapture=''>" +
                      "<option selected=''></option></select>"

                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (el.querySelectorAll("[msallowcapture^='']").length) {
                      rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")')
                    }

                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!el.querySelectorAll('[selected]').length) {
                      rbuggyQSA.push(
                        '\\[' + whitespace + '*(?:value|' + booleans + ')'
                      )
                    }

                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                    if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
                      rbuggyQSA.push('~=')
                    }

                    // Support: IE 11+, Edge 15 - 18+
                    // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                    // Adding a temporary attribute to the document before the selection works
                    // around the issue.
                    // Interestingly, IE 10 & older don't seem to have the issue.
                    input = document.createElement('input')
                    input.setAttribute('name', '')
                    el.appendChild(input)
                    if (!el.querySelectorAll("[name='']").length) {
                      rbuggyQSA.push(
                        '\\[' +
                          whitespace +
                          '*name' +
                          whitespace +
                          '*=' +
                          whitespace +
                          '*(?:\'\'|"")'
                      )
                    }

                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!el.querySelectorAll(':checked').length) {
                      rbuggyQSA.push(':checked')
                    }

                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibling-combinator selector` fails
                    if (!el.querySelectorAll('a#' + expando + '+*').length) {
                      rbuggyQSA.push('.#.+[+~]')
                    }

                    // Support: Firefox <=3.6 - 5 only
                    // Old Firefox doesn't throw on a badly-escaped identifier.
                    el.querySelectorAll('\\\f')
                    rbuggyQSA.push('[\\r\\n\\f]')
                  })

                  assert(function (el) {
                    el.innerHTML =
                      "<a href='' disabled='disabled'></a>" +
                      "<select disabled='disabled'><option/></select>"

                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = document.createElement('input')
                    input.setAttribute('type', 'hidden')
                    el.appendChild(input).setAttribute('name', 'D')

                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (el.querySelectorAll('[name=d]').length) {
                      rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=')
                    }

                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (el.querySelectorAll(':enabled').length !== 2) {
                      rbuggyQSA.push(':enabled', ':disabled')
                    }

                    // Support: IE9-11+
                    // IE's :disabled selector does not pick up the children of disabled fieldsets
                    docElem.appendChild(el).disabled = true
                    if (el.querySelectorAll(':disabled').length !== 2) {
                      rbuggyQSA.push(':enabled', ':disabled')
                    }

                    // Support: Opera 10 - 11 only
                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    el.querySelectorAll('*,:x')
                    rbuggyQSA.push(',.*:')
                  })
                }

                if (
                  (support.matchesSelector = rnative.test(
                    (matches =
                      docElem.matches ||
                      docElem.webkitMatchesSelector ||
                      docElem.mozMatchesSelector ||
                      docElem.oMatchesSelector ||
                      docElem.msMatchesSelector)
                  ))
                ) {
                  assert(function (el) {
                    // Check to see if it's possible to do matchesSelector
                    // on a disconnected node (IE 9)
                    support.disconnectedMatch = matches.call(el, '*')

                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(el, "[s!='']:x")
                    rbuggyMatches.push('!=', pseudos)
                  })
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'))
                rbuggyMatches =
                  rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'))

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test(docElem.compareDocumentPosition)

                // Element contains another
                // Purposefully self-exclusive
                // As in, an element does not contain itself
                contains =
                  hasCompare || rnative.test(docElem.contains)
                    ? function (a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                          bup = b && b.parentNode
                        return (
                          a === bup ||
                          !!(
                            bup &&
                            bup.nodeType === 1 &&
                            (adown.contains
                              ? adown.contains(bup)
                              : a.compareDocumentPosition &&
                                a.compareDocumentPosition(bup) & 16)
                          )
                        )
                      }
                    : function (a, b) {
                        if (b) {
                          while ((b = b.parentNode)) {
                            if (b === a) {
                              return true
                            }
                          }
                        }
                        return false
                      }

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare
                  ? function (a, b) {
                      // Flag for duplicate removal
                      if (a === b) {
                        hasDuplicate = true
                        return 0
                      }

                      // Sort on method existence if only one input has compareDocumentPosition
                      var compare =
                        !a.compareDocumentPosition - !b.compareDocumentPosition
                      if (compare) {
                        return compare
                      }

                      // Calculate position if both inputs belong to the same document
                      // Support: IE 11+, Edge 17 - 18+
                      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                      // two documents; shallow comparisons work.
                      // eslint-disable-next-line eqeqeq
                      compare =
                        (a.ownerDocument || a) == (b.ownerDocument || b)
                          ? a.compareDocumentPosition(b)
                          : // Otherwise we know they are disconnected
                            1

                      // Disconnected nodes
                      if (
                        compare & 1 ||
                        (!support.sortDetached &&
                          b.compareDocumentPosition(a) === compare)
                      ) {
                        // Choose the first element that is related to our preferred document
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if (
                          a == document ||
                          (a.ownerDocument == preferredDoc &&
                            contains(preferredDoc, a))
                        ) {
                          return -1
                        }

                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if (
                          b == document ||
                          (b.ownerDocument == preferredDoc &&
                            contains(preferredDoc, b))
                        ) {
                          return 1
                        }

                        // Maintain original order
                        return sortInput
                          ? indexOf(sortInput, a) - indexOf(sortInput, b)
                          : 0
                      }

                      return compare & 4 ? -1 : 1
                    }
                  : function (a, b) {
                      // Exit early if the nodes are identical
                      if (a === b) {
                        hasDuplicate = true
                        return 0
                      }

                      var cur,
                        i = 0,
                        aup = a.parentNode,
                        bup = b.parentNode,
                        ap = [a],
                        bp = [b]

                      // Parentless nodes are either documents or disconnected
                      if (!aup || !bup) {
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        /* eslint-disable eqeqeq */
                        return a == document
                          ? -1
                          : b == document
                          ? 1
                          : /* eslint-enable eqeqeq */
                          aup
                          ? -1
                          : bup
                          ? 1
                          : sortInput
                          ? indexOf(sortInput, a) - indexOf(sortInput, b)
                          : 0

                        // If the nodes are siblings, we can do a quick check
                      } else if (aup === bup) {
                        return siblingCheck(a, b)
                      }

                      // Otherwise we need full lists of their ancestors for comparison
                      cur = a
                      while ((cur = cur.parentNode)) {
                        ap.unshift(cur)
                      }
                      cur = b
                      while ((cur = cur.parentNode)) {
                        bp.unshift(cur)
                      }

                      // Walk down the tree looking for a discrepancy
                      while (ap[i] === bp[i]) {
                        i++
                      }

                      return i
                        ? // Do a sibling check if the nodes have a common ancestor
                          siblingCheck(ap[i], bp[i])
                        : // Otherwise nodes in our document sort first
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        /* eslint-disable eqeqeq */
                        ap[i] == preferredDoc
                        ? -1
                        : bp[i] == preferredDoc
                        ? 1
                        : /* eslint-enable eqeqeq */
                          0
                    }

                return document
              }

              Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements)
              }

              Sizzle.matchesSelector = function (elem, expr) {
                setDocument(elem)

                if (
                  support.matchesSelector &&
                  documentIsHTML &&
                  !nonnativeSelectorCache[expr + ' '] &&
                  (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                  (!rbuggyQSA || !rbuggyQSA.test(expr))
                ) {
                  try {
                    var ret = matches.call(elem, expr)

                    // IE 9's matchesSelector returns false on disconnected nodes
                    if (
                      ret ||
                      support.disconnectedMatch ||
                      // As well, disconnected nodes are said to be in a document
                      // fragment in IE 9
                      (elem.document && elem.document.nodeType !== 11)
                    ) {
                      return ret
                    }
                  } catch (e) {
                    nonnativeSelectorCache(expr, true)
                  }
                }

                return Sizzle(expr, document, null, [elem]).length > 0
              }

              Sizzle.contains = function (context, elem) {
                // Set document vars if needed
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if ((context.ownerDocument || context) != document) {
                  setDocument(context)
                }
                return contains(context, elem)
              }

              Sizzle.attr = function (elem, name) {
                // Set document vars if needed
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if ((elem.ownerDocument || elem) != document) {
                  setDocument(elem)
                }

                var fn = Expr.attrHandle[name.toLowerCase()],
                  // Don't get fooled by Object.prototype properties (jQuery #13807)
                  val =
                    fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
                      ? fn(elem, name, !documentIsHTML)
                      : undefined

                return val !== undefined
                  ? val
                  : support.attributes || !documentIsHTML
                  ? elem.getAttribute(name)
                  : (val = elem.getAttributeNode(name)) && val.specified
                  ? val.value
                  : null
              }

              Sizzle.escape = function (sel) {
                return (sel + '').replace(rcssescape, fcssescape)
              }

              Sizzle.error = function (msg) {
                throw new Error('Syntax error, unrecognized expression: ' + msg)
              }

              /**
               * Document sorting and removing duplicates
               * @param {ArrayLike} results
               */
              Sizzle.uniqueSort = function (results) {
                var elem,
                  duplicates = [],
                  j = 0,
                  i = 0

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates
                sortInput = !support.sortStable && results.slice(0)
                results.sort(sortOrder)

                if (hasDuplicate) {
                  while ((elem = results[i++])) {
                    if (elem === results[i]) {
                      j = duplicates.push(i)
                    }
                  }
                  while (j--) {
                    results.splice(duplicates[j], 1)
                  }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null

                return results
              }

              /**
               * Utility function for retrieving the text value of an array of DOM nodes
               * @param {Array|Element} elem
               */
              getText = Sizzle.getText = function (elem) {
                var node,
                  ret = '',
                  i = 0,
                  nodeType = elem.nodeType

                if (!nodeType) {
                  // If no nodeType, this is expected to be an array
                  while ((node = elem[i++])) {
                    // Do not traverse comment nodes
                    ret += getText(node)
                  }
                } else if (
                  nodeType === 1 ||
                  nodeType === 9 ||
                  nodeType === 11
                ) {
                  // Use textContent for elements
                  // innerText usage removed for consistency of new lines (jQuery #11153)
                  if (typeof elem.textContent === 'string') {
                    return elem.textContent
                  } else {
                    // Traverse its children
                    for (
                      elem = elem.firstChild;
                      elem;
                      elem = elem.nextSibling
                    ) {
                      ret += getText(elem)
                    }
                  }
                } else if (nodeType === 3 || nodeType === 4) {
                  return elem.nodeValue
                }

                // Do not include comment or processing instruction nodes

                return ret
              }

              Expr = Sizzle.selectors = {
                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                  '>': { dir: 'parentNode', first: true },
                  ' ': { dir: 'parentNode' },
                  '+': { dir: 'previousSibling', first: true },
                  '~': { dir: 'previousSibling' }
                },

                preFilter: {
                  ATTR: function (match) {
                    match[1] = match[1].replace(runescape, funescape)

                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || '').replace(
                      runescape,
                      funescape
                    )

                    if (match[2] === '~=') {
                      match[3] = ' ' + match[3] + ' '
                    }

                    return match.slice(0, 4)
                  },

                  CHILD: function (match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                    match[1] = match[1].toLowerCase()

                    if (match[1].slice(0, 3) === 'nth') {
                      // nth-* requires argument
                      if (!match[3]) {
                        Sizzle.error(match[0])
                      }

                      // numeric x and y parameters for Expr.filter.CHILD
                      // remember that false/true cast respectively to 0/1
                      match[4] = +(match[4]
                        ? match[5] + (match[6] || 1)
                        : 2 * (match[3] === 'even' || match[3] === 'odd'))
                      match[5] = +(match[7] + match[8] || match[3] === 'odd')

                      // other types prohibit arguments
                    } else if (match[3]) {
                      Sizzle.error(match[0])
                    }

                    return match
                  },

                  PSEUDO: function (match) {
                    var excess,
                      unquoted = !match[6] && match[2]

                    if (matchExpr['CHILD'].test(match[0])) {
                      return null
                    }

                    // Accept quoted arguments as-is
                    if (match[3]) {
                      match[2] = match[4] || match[5] || ''

                      // Strip excess characters from unquoted arguments
                    } else if (
                      unquoted &&
                      rpseudo.test(unquoted) &&
                      // Get excess from tokenize (recursively)
                      (excess = tokenize(unquoted, true)) &&
                      // advance to the next closing parenthesis
                      (excess =
                        unquoted.indexOf(')', unquoted.length - excess) -
                        unquoted.length)
                    ) {
                      // excess is a negative index
                      match[0] = match[0].slice(0, excess)
                      match[2] = unquoted.slice(0, excess)
                    }

                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3)
                  }
                },

                filter: {
                  TAG: function (nodeNameSelector) {
                    var nodeName = nodeNameSelector
                      .replace(runescape, funescape)
                      .toLowerCase()
                    return nodeNameSelector === '*'
                      ? function () {
                          return true
                        }
                      : function (elem) {
                          return (
                            elem.nodeName &&
                            elem.nodeName.toLowerCase() === nodeName
                          )
                        }
                  },

                  CLASS: function (className) {
                    var pattern = classCache[className + ' ']

                    return (
                      pattern ||
                      ((pattern = new RegExp(
                        '(^|' +
                          whitespace +
                          ')' +
                          className +
                          '(' +
                          whitespace +
                          '|$)'
                      )) &&
                        classCache(className, function (elem) {
                          return pattern.test(
                            (typeof elem.className === 'string' &&
                              elem.className) ||
                              (typeof elem.getAttribute !== 'undefined' &&
                                elem.getAttribute('class')) ||
                              ''
                          )
                        }))
                    )
                  },

                  ATTR: function (name, operator, check) {
                    return function (elem) {
                      var result = Sizzle.attr(elem, name)

                      if (result == null) {
                        return operator === '!='
                      }
                      if (!operator) {
                        return true
                      }

                      result += ''

                      /* eslint-disable max-len */

                      return operator === '='
                        ? result === check
                        : operator === '!='
                        ? result !== check
                        : operator === '^='
                        ? check && result.indexOf(check) === 0
                        : operator === '*='
                        ? check && result.indexOf(check) > -1
                        : operator === '$='
                        ? check && result.slice(-check.length) === check
                        : operator === '~='
                        ? (
                            ' ' +
                            result.replace(rwhitespace, ' ') +
                            ' '
                          ).indexOf(check) > -1
                        : operator === '|='
                        ? result === check ||
                          result.slice(0, check.length + 1) === check + '-'
                        : false
                      /* eslint-enable max-len */
                    }
                  },

                  CHILD: function (type, what, _argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth',
                      forward = type.slice(-4) !== 'last',
                      ofType = what === 'of-type'

                    return first === 1 && last === 0
                      ? // Shortcut for :nth-*(n)
                        function (elem) {
                          return !!elem.parentNode
                        }
                      : function (elem, _context, xml) {
                          var cache,
                            uniqueCache,
                            outerCache,
                            node,
                            nodeIndex,
                            start,
                            dir =
                              simple !== forward
                                ? 'nextSibling'
                                : 'previousSibling',
                            parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(),
                            useCache = !xml && !ofType,
                            diff = false

                          if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                              while (dir) {
                                node = elem
                                while ((node = node[dir])) {
                                  if (
                                    ofType
                                      ? node.nodeName.toLowerCase() === name
                                      : node.nodeType === 1
                                  ) {
                                    return false
                                  }
                                }

                                // Reverse direction for :only-* (if we haven't yet done so)
                                start = dir =
                                  type === 'only' && !start && 'nextSibling'
                              }
                              return true
                            }

                            start = [
                              forward ? parent.firstChild : parent.lastChild
                            ]

                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                              // Seek `elem` from a previously-cached index

                              // ...in a gzip-friendly way
                              node = parent
                              outerCache = node[expando] || (node[expando] = {})

                              // Support: IE <9 only
                              // Defend against cloned attroperties (jQuery gh-1709)
                              uniqueCache =
                                outerCache[node.uniqueID] ||
                                (outerCache[node.uniqueID] = {})

                              cache = uniqueCache[type] || []
                              nodeIndex = cache[0] === dirruns && cache[1]
                              diff = nodeIndex && cache[2]
                              node = nodeIndex && parent.childNodes[nodeIndex]

                              while (
                                (node =
                                  (++nodeIndex && node && node[dir]) ||
                                  // Fallback to seeking `elem` from the start
                                  (diff = nodeIndex = 0) ||
                                  start.pop())
                              ) {
                                // When found, cache indexes on `parent` and break
                                if (
                                  node.nodeType === 1 &&
                                  ++diff &&
                                  node === elem
                                ) {
                                  uniqueCache[type] = [dirruns, nodeIndex, diff]
                                  break
                                }
                              }
                            } else {
                              // Use previously-cached element index if available
                              if (useCache) {
                                // ...in a gzip-friendly way
                                node = elem
                                outerCache =
                                  node[expando] || (node[expando] = {})

                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache =
                                  outerCache[node.uniqueID] ||
                                  (outerCache[node.uniqueID] = {})

                                cache = uniqueCache[type] || []
                                nodeIndex = cache[0] === dirruns && cache[1]
                                diff = nodeIndex
                              }

                              // xml :nth-child(...)
                              // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                              if (diff === false) {
                                // Use the same loop as above to seek `elem` from the start
                                while (
                                  (node =
                                    (++nodeIndex && node && node[dir]) ||
                                    (diff = nodeIndex = 0) ||
                                    start.pop())
                                ) {
                                  if (
                                    (ofType
                                      ? node.nodeName.toLowerCase() === name
                                      : node.nodeType === 1) &&
                                    ++diff
                                  ) {
                                    // Cache the index of each encountered element
                                    if (useCache) {
                                      outerCache =
                                        node[expando] || (node[expando] = {})

                                      // Support: IE <9 only
                                      // Defend against cloned attroperties (jQuery gh-1709)
                                      uniqueCache =
                                        outerCache[node.uniqueID] ||
                                        (outerCache[node.uniqueID] = {})

                                      uniqueCache[type] = [dirruns, diff]
                                    }

                                    if (node === elem) {
                                      break
                                    }
                                  }
                                }
                              }
                            }

                            // Incorporate the offset, then check against cycle size
                            diff -= last
                            return (
                              diff === first ||
                              (diff % first === 0 && diff / first >= 0)
                            )
                          }
                        }
                  },

                  PSEUDO: function (pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args,
                      fn =
                        Expr.pseudos[pseudo] ||
                        Expr.setFilters[pseudo.toLowerCase()] ||
                        Sizzle.error('unsupported pseudo: ' + pseudo)

                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                      return fn(argument)
                    }

                    // But maintain support for old signatures
                    if (fn.length > 1) {
                      args = [pseudo, pseudo, '', argument]
                      return Expr.setFilters.hasOwnProperty(
                        pseudo.toLowerCase()
                      )
                        ? markFunction(function (seed, matches) {
                            var idx,
                              matched = fn(seed, argument),
                              i = matched.length
                            while (i--) {
                              idx = indexOf(seed, matched[i])
                              seed[idx] = !(matches[idx] = matched[i])
                            }
                          })
                        : function (elem) {
                            return fn(elem, 0, args)
                          }
                    }

                    return fn
                  }
                },

                pseudos: {
                  // Potentially complex pseudos
                  not: markFunction(function (selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [],
                      results = [],
                      matcher = compile(selector.replace(rtrim, '$1'))

                    return matcher[expando]
                      ? markFunction(function (seed, matches, _context, xml) {
                          var elem,
                            unmatched = matcher(seed, null, xml, []),
                            i = seed.length

                          // Match elements unmatched by `matcher`
                          while (i--) {
                            if ((elem = unmatched[i])) {
                              seed[i] = !(matches[i] = elem)
                            }
                          }
                        })
                      : function (elem, _context, xml) {
                          input[0] = elem
                          matcher(input, null, xml, results)

                          // Don't keep the element (issue #299)
                          input[0] = null
                          return !results.pop()
                        }
                  }),

                  has: markFunction(function (selector) {
                    return function (elem) {
                      return Sizzle(selector, elem).length > 0
                    }
                  }),

                  contains: markFunction(function (text) {
                    text = text.replace(runescape, funescape)
                    return function (elem) {
                      return (
                        (elem.textContent || getText(elem)).indexOf(text) > -1
                      )
                    }
                  }),

                  // "Whether an element is represented by a :lang() selector
                  // is based solely on the element's language value
                  // being equal to the identifier C,
                  // or beginning with the identifier C immediately followed by "-".
                  // The matching of C against the element's language value is performed case-insensitively.
                  // The identifier C does not have to be a valid language name."
                  // http://www.w3.org/TR/selectors/#lang-pseudo
                  lang: markFunction(function (lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || '')) {
                      Sizzle.error('unsupported lang: ' + lang)
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase()
                    return function (elem) {
                      var elemLang
                      do {
                        if (
                          (elemLang = documentIsHTML
                            ? elem.lang
                            : elem.getAttribute('xml:lang') ||
                              elem.getAttribute('lang'))
                        ) {
                          elemLang = elemLang.toLowerCase()
                          return (
                            elemLang === lang ||
                            elemLang.indexOf(lang + '-') === 0
                          )
                        }
                      } while ((elem = elem.parentNode) && elem.nodeType === 1)
                      return false
                    }
                  }),

                  // Miscellaneous
                  target: function (elem) {
                    var hash = window.location && window.location.hash
                    return hash && hash.slice(1) === elem.id
                  },

                  root: function (elem) {
                    return elem === docElem
                  },

                  focus: function (elem) {
                    return (
                      elem === document.activeElement &&
                      (!document.hasFocus || document.hasFocus()) &&
                      !!(elem.type || elem.href || ~elem.tabIndex)
                    )
                  },

                  // Boolean properties
                  enabled: createDisabledPseudo(false),
                  disabled: createDisabledPseudo(true),

                  checked: function (elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase()
                    return (
                      (nodeName === 'input' && !!elem.checked) ||
                      (nodeName === 'option' && !!elem.selected)
                    )
                  },

                  selected: function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                      // eslint-disable-next-line no-unused-expressions
                      elem.parentNode.selectedIndex
                    }

                    return elem.selected === true
                  },

                  // Contents
                  empty: function (elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for (
                      elem = elem.firstChild;
                      elem;
                      elem = elem.nextSibling
                    ) {
                      if (elem.nodeType < 6) {
                        return false
                      }
                    }
                    return true
                  },

                  parent: function (elem) {
                    return !Expr.pseudos['empty'](elem)
                  },

                  // Element/input types
                  header: function (elem) {
                    return rheader.test(elem.nodeName)
                  },

                  input: function (elem) {
                    return rinputs.test(elem.nodeName)
                  },

                  button: function (elem) {
                    var name = elem.nodeName.toLowerCase()
                    return (
                      (name === 'input' && elem.type === 'button') ||
                      name === 'button'
                    )
                  },

                  text: function (elem) {
                    var attr
                    return (
                      elem.nodeName.toLowerCase() === 'input' &&
                      elem.type === 'text' &&
                      // Support: IE<8
                      // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                      ((attr = elem.getAttribute('type')) == null ||
                        attr.toLowerCase() === 'text')
                    )
                  },

                  // Position-in-collection
                  first: createPositionalPseudo(function () {
                    return [0]
                  }),

                  last: createPositionalPseudo(function (
                    _matchIndexes,
                    length
                  ) {
                    return [length - 1]
                  }),

                  eq: createPositionalPseudo(function (
                    _matchIndexes,
                    length,
                    argument
                  ) {
                    return [argument < 0 ? argument + length : argument]
                  }),

                  even: createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0
                    for (; i < length; i += 2) {
                      matchIndexes.push(i)
                    }
                    return matchIndexes
                  }),

                  odd: createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1
                    for (; i < length; i += 2) {
                      matchIndexes.push(i)
                    }
                    return matchIndexes
                  }),

                  lt: createPositionalPseudo(function (
                    matchIndexes,
                    length,
                    argument
                  ) {
                    var i =
                      argument < 0
                        ? argument + length
                        : argument > length
                        ? length
                        : argument
                    for (; --i >= 0; ) {
                      matchIndexes.push(i)
                    }
                    return matchIndexes
                  }),

                  gt: createPositionalPseudo(function (
                    matchIndexes,
                    length,
                    argument
                  ) {
                    var i = argument < 0 ? argument + length : argument
                    for (; ++i < length; ) {
                      matchIndexes.push(i)
                    }
                    return matchIndexes
                  })
                }
              }

              Expr.pseudos['nth'] = Expr.pseudos['eq']

              // Add button/input type pseudos
              for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
              }) {
                Expr.pseudos[i] = createInputPseudo(i)
              }
              for (i in { submit: true, reset: true }) {
                Expr.pseudos[i] = createButtonPseudo(i)
              }

              // Easy API for creating new setFilters
              function setFilters() {}
              setFilters.prototype = Expr.filters = Expr.pseudos
              Expr.setFilters = new setFilters()

              tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched,
                  match,
                  tokens,
                  type,
                  soFar,
                  groups,
                  preFilters,
                  cached = tokenCache[selector + ' ']

                if (cached) {
                  return parseOnly ? 0 : cached.slice(0)
                }

                soFar = selector
                groups = []
                preFilters = Expr.preFilter

                while (soFar) {
                  // Comma and first run
                  if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                      // Don't consume trailing commas as valid
                      soFar = soFar.slice(match[0].length) || soFar
                    }
                    groups.push((tokens = []))
                  }

                  matched = false

                  // Combinators
                  if ((match = rcombinators.exec(soFar))) {
                    matched = match.shift()
                    tokens.push({
                      value: matched,

                      // Cast descendant combinators to space
                      type: match[0].replace(rtrim, ' ')
                    })
                    soFar = soFar.slice(matched.length)
                  }

                  // Filters
                  for (type in Expr.filter) {
                    if (
                      (match = matchExpr[type].exec(soFar)) &&
                      (!preFilters[type] || (match = preFilters[type](match)))
                    ) {
                      matched = match.shift()
                      tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                      })
                      soFar = soFar.slice(matched.length)
                    }
                  }

                  if (!matched) {
                    break
                  }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly
                  ? soFar.length
                  : soFar
                  ? Sizzle.error(selector)
                  : // Cache the tokens
                    tokenCache(selector, groups).slice(0)
              }

              function toSelector(tokens) {
                var i = 0,
                  len = tokens.length,
                  selector = ''
                for (; i < len; i++) {
                  selector += tokens[i].value
                }
                return selector
              }

              function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                  skip = combinator.next,
                  key = skip || dir,
                  checkNonElements = base && key === 'parentNode',
                  doneName = done++

                return combinator.first
                  ? // Check against closest ancestor/preceding element
                    function (elem, context, xml) {
                      while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                          return matcher(elem, context, xml)
                        }
                      }
                      return false
                    }
                  : // Check against all ancestor/preceding elements
                    function (elem, context, xml) {
                      var oldCache,
                        uniqueCache,
                        outerCache,
                        newCache = [dirruns, doneName]

                      // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                      if (xml) {
                        while ((elem = elem[dir])) {
                          if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                              return true
                            }
                          }
                        }
                      } else {
                        while ((elem = elem[dir])) {
                          if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {})

                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            uniqueCache =
                              outerCache[elem.uniqueID] ||
                              (outerCache[elem.uniqueID] = {})

                            if (skip && skip === elem.nodeName.toLowerCase()) {
                              elem = elem[dir] || elem
                            } else if (
                              (oldCache = uniqueCache[key]) &&
                              oldCache[0] === dirruns &&
                              oldCache[1] === doneName
                            ) {
                              // Assign to newCache so results back-propagate to previous elements
                              return (newCache[2] = oldCache[2])
                            } else {
                              // Reuse newcache so results back-propagate to previous elements
                              uniqueCache[key] = newCache

                              // A match means we're done; a fail means we have to keep checking
                              if ((newCache[2] = matcher(elem, context, xml))) {
                                return true
                              }
                            }
                          }
                        }
                      }
                      return false
                    }
              }

              function elementMatcher(matchers) {
                return matchers.length > 1
                  ? function (elem, context, xml) {
                      var i = matchers.length
                      while (i--) {
                        if (!matchers[i](elem, context, xml)) {
                          return false
                        }
                      }
                      return true
                    }
                  : matchers[0]
              }

              function multipleContexts(selector, contexts, results) {
                var i = 0,
                  len = contexts.length
                for (; i < len; i++) {
                  Sizzle(selector, contexts[i], results)
                }
                return results
              }

              function condense(unmatched, map, filter, context, xml) {
                var elem,
                  newUnmatched = [],
                  i = 0,
                  len = unmatched.length,
                  mapped = map != null

                for (; i < len; i++) {
                  if ((elem = unmatched[i])) {
                    if (!filter || filter(elem, context, xml)) {
                      newUnmatched.push(elem)
                      if (mapped) {
                        map.push(i)
                      }
                    }
                  }
                }

                return newUnmatched
              }

              function setMatcher(
                preFilter,
                selector,
                matcher,
                postFilter,
                postFinder,
                postSelector
              ) {
                if (postFilter && !postFilter[expando]) {
                  postFilter = setMatcher(postFilter)
                }
                if (postFinder && !postFinder[expando]) {
                  postFinder = setMatcher(postFinder, postSelector)
                }
                return markFunction(function (seed, results, context, xml) {
                  var temp,
                    i,
                    elem,
                    preMap = [],
                    postMap = [],
                    preexisting = results.length,
                    // Get initial elements from seed or context
                    elems =
                      seed ||
                      multipleContexts(
                        selector || '*',
                        context.nodeType ? [context] : context,
                        []
                      ),
                    // Prefilter to get matcher input, preserving a map for seed-results synchronization
                    matcherIn =
                      preFilter && (seed || !selector)
                        ? condense(elems, preMap, preFilter, context, xml)
                        : elems,
                    matcherOut = matcher
                      ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                        postFinder ||
                        (seed ? preFilter : preexisting || postFilter)
                        ? // ...intermediate processing is necessary
                          []
                        : // ...otherwise use results directly
                          results
                      : matcherIn

                  // Find primary matches
                  if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml)
                  }

                  // Apply postFilter
                  if (postFilter) {
                    temp = condense(matcherOut, postMap)
                    postFilter(temp, [], context, xml)

                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length
                    while (i--) {
                      if ((elem = temp[i])) {
                        matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
                      }
                    }
                  }

                  if (seed) {
                    if (postFinder || preFilter) {
                      if (postFinder) {
                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                        temp = []
                        i = matcherOut.length
                        while (i--) {
                          if ((elem = matcherOut[i])) {
                            // Restore matcherIn since elem is not yet a final match
                            temp.push((matcherIn[i] = elem))
                          }
                        }
                        postFinder(null, (matcherOut = []), temp, xml)
                      }

                      // Move matched elements from seed to results to keep them synchronized
                      i = matcherOut.length
                      while (i--) {
                        if (
                          (elem = matcherOut[i]) &&
                          (temp = postFinder
                            ? indexOf(seed, elem)
                            : preMap[i]) > -1
                        ) {
                          seed[temp] = !(results[temp] = elem)
                        }
                      }
                    }

                    // Add elements to results, through postFinder if defined
                  } else {
                    matcherOut = condense(
                      matcherOut === results
                        ? matcherOut.splice(preexisting, matcherOut.length)
                        : matcherOut
                    )
                    if (postFinder) {
                      postFinder(null, results, matcherOut, xml)
                    } else {
                      push.apply(results, matcherOut)
                    }
                  }
                })
              }

              function matcherFromTokens(tokens) {
                var checkContext,
                  matcher,
                  j,
                  len = tokens.length,
                  leadingRelative = Expr.relative[tokens[0].type],
                  implicitRelative = leadingRelative || Expr.relative[' '],
                  i = leadingRelative ? 1 : 0,
                  // The foundational matcher ensures that elements are reachable from top-level context(s)
                  matchContext = addCombinator(
                    function (elem) {
                      return elem === checkContext
                    },
                    implicitRelative,
                    true
                  ),
                  matchAnyContext = addCombinator(
                    function (elem) {
                      return indexOf(checkContext, elem) > -1
                    },
                    implicitRelative,
                    true
                  ),
                  matchers = [
                    function (elem, context, xml) {
                      var ret =
                        (!leadingRelative &&
                          (xml || context !== outermostContext)) ||
                        ((checkContext = context).nodeType
                          ? matchContext(elem, context, xml)
                          : matchAnyContext(elem, context, xml))

                      // Avoid hanging onto element (issue #299)
                      checkContext = null
                      return ret
                    }
                  ]

                for (; i < len; i++) {
                  if ((matcher = Expr.relative[tokens[i].type])) {
                    matchers = [
                      addCombinator(elementMatcher(matchers), matcher)
                    ]
                  } else {
                    matcher = Expr.filter[tokens[i].type].apply(
                      null,
                      tokens[i].matches
                    )

                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                      // Find the next relative operator (if any) for proper handling
                      j = ++i
                      for (; j < len; j++) {
                        if (Expr.relative[tokens[j].type]) {
                          break
                        }
                      }
                      return setMatcher(
                        i > 1 && elementMatcher(matchers),
                        i > 1 &&
                          toSelector(
                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                            tokens
                              .slice(0, i - 1)
                              .concat({
                                value: tokens[i - 2].type === ' ' ? '*' : ''
                              })
                          ).replace(rtrim, '$1'),
                        matcher,
                        i < j && matcherFromTokens(tokens.slice(i, j)),
                        j < len &&
                          matcherFromTokens((tokens = tokens.slice(j))),
                        j < len && toSelector(tokens)
                      )
                    }
                    matchers.push(matcher)
                  }
                }

                return elementMatcher(matchers)
              }

              function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0,
                  byElement = elementMatchers.length > 0,
                  superMatcher = function (
                    seed,
                    context,
                    xml,
                    results,
                    outermost
                  ) {
                    var elem,
                      j,
                      matcher,
                      matchedCount = 0,
                      i = '0',
                      unmatched = seed && [],
                      setMatched = [],
                      contextBackup = outermostContext,
                      // We must always have either seed elements or outermost context
                      elems =
                        seed || (byElement && Expr.find['TAG']('*', outermost)),
                      // Use integer dirruns iff this is the outermost matcher
                      dirrunsUnique = (dirruns +=
                        contextBackup == null ? 1 : Math.random() || 0.1),
                      len = elems.length

                    if (outermost) {
                      // Support: IE 11+, Edge 17 - 18+
                      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                      // two documents; shallow comparisons work.
                      // eslint-disable-next-line eqeqeq
                      outermostContext =
                        context == document || context || outermost
                    }

                    // Add elements passing elementMatchers directly to results
                    // Support: IE<9, Safari
                    // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                      if (byElement && elem) {
                        j = 0

                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if (!context && elem.ownerDocument != document) {
                          setDocument(elem)
                          xml = !documentIsHTML
                        }
                        while ((matcher = elementMatchers[j++])) {
                          if (matcher(elem, context || document, xml)) {
                            results.push(elem)
                            break
                          }
                        }
                        if (outermost) {
                          dirruns = dirrunsUnique
                        }
                      }

                      // Track unmatched elements for set filters
                      if (bySet) {
                        // They will have gone through all possible matchers
                        if ((elem = !matcher && elem)) {
                          matchedCount--
                        }

                        // Lengthen the array for every element, matched or not
                        if (seed) {
                          unmatched.push(elem)
                        }
                      }
                    }

                    // `i` is now the count of elements visited above, and adding it to `matchedCount`
                    // makes the latter nonnegative.
                    matchedCount += i

                    // Apply set filters to unmatched elements
                    // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                    // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                    // no element matchers and no seed.
                    // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                    // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                    // numerically zero.
                    if (bySet && i !== matchedCount) {
                      j = 0
                      while ((matcher = setMatchers[j++])) {
                        matcher(unmatched, setMatched, context, xml)
                      }

                      if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                          while (i--) {
                            if (!(unmatched[i] || setMatched[i])) {
                              setMatched[i] = pop.call(results)
                            }
                          }
                        }

                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched)
                      }

                      // Add matches to results
                      push.apply(results, setMatched)

                      // Seedless set matches succeeding multiple successful matchers stipulate sorting
                      if (
                        outermost &&
                        !seed &&
                        setMatched.length > 0 &&
                        matchedCount + setMatchers.length > 1
                      ) {
                        Sizzle.uniqueSort(results)
                      }
                    }

                    // Override manipulation of globals by nested matchers
                    if (outermost) {
                      dirruns = dirrunsUnique
                      outermostContext = contextBackup
                    }

                    return unmatched
                  }

                return bySet ? markFunction(superMatcher) : superMatcher
              }

              compile = Sizzle.compile = function (
                selector,
                match /* Internal Use Only */
              ) {
                var i,
                  setMatchers = [],
                  elementMatchers = [],
                  cached = compilerCache[selector + ' ']

                if (!cached) {
                  // Generate a function of recursive functions that can be used to check each element
                  if (!match) {
                    match = tokenize(selector)
                  }
                  i = match.length
                  while (i--) {
                    cached = matcherFromTokens(match[i])
                    if (cached[expando]) {
                      setMatchers.push(cached)
                    } else {
                      elementMatchers.push(cached)
                    }
                  }

                  // Cache the compiled function
                  cached = compilerCache(
                    selector,
                    matcherFromGroupMatchers(elementMatchers, setMatchers)
                  )

                  // Save selector and tokenization
                  cached.selector = selector
                }
                return cached
              }

              /**
               * A low-level selection function that works with Sizzle's compiled
               *  selector functions
               * @param {String|Function} selector A selector or a pre-compiled
               *  selector function built with Sizzle.compile
               * @param {Element} context
               * @param {Array} [results]
               * @param {Array} [seed] A set of elements to match against
               */
              select = Sizzle.select = function (
                selector,
                context,
                results,
                seed
              ) {
                var i,
                  tokens,
                  token,
                  type,
                  find,
                  compiled = typeof selector === 'function' && selector,
                  match =
                    !seed &&
                    tokenize((selector = compiled.selector || selector))

                results = results || []

                // Try to minimize operations if there is only one selector in the list and no seed
                // (the latter of which guarantees us context)
                if (match.length === 1) {
                  // Reduce context if the leading compound selector is an ID
                  tokens = match[0] = match[0].slice(0)
                  if (
                    tokens.length > 2 &&
                    (token = tokens[0]).type === 'ID' &&
                    context.nodeType === 9 &&
                    documentIsHTML &&
                    Expr.relative[tokens[1].type]
                  ) {
                    context = (Expr.find['ID'](
                      token.matches[0].replace(runescape, funescape),
                      context
                    ) || [])[0]
                    if (!context) {
                      return results

                      // Precompiled matchers will still verify ancestry, so step up a level
                    } else if (compiled) {
                      context = context.parentNode
                    }

                    selector = selector.slice(tokens.shift().value.length)
                  }

                  // Fetch a seed set for right-to-left matching
                  i = matchExpr['needsContext'].test(selector)
                    ? 0
                    : tokens.length
                  while (i--) {
                    token = tokens[i]

                    // Abort if we hit a combinator
                    if (Expr.relative[(type = token.type)]) {
                      break
                    }
                    if ((find = Expr.find[type])) {
                      // Search, expanding context for leading sibling combinators
                      if (
                        (seed = find(
                          token.matches[0].replace(runescape, funescape),
                          (rsibling.test(tokens[0].type) &&
                            testContext(context.parentNode)) ||
                            context
                        ))
                      ) {
                        // If seed is empty or no tokens remain, we can return early
                        tokens.splice(i, 1)
                        selector = seed.length && toSelector(tokens)
                        if (!selector) {
                          push.apply(results, seed)
                          return results
                        }

                        break
                      }
                    }
                  }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                ;(compiled || compile(selector, match))(
                  seed,
                  context,
                  !documentIsHTML,
                  results,
                  !context ||
                    (rsibling.test(selector) &&
                      testContext(context.parentNode)) ||
                    context
                )
                return results
              }

              // One-time assignments

              // Sort stability
              support.sortStable =
                expando.split('').sort(sortOrder).join('') === expando

              // Support: Chrome 14-35+
              // Always assume duplicates if they aren't passed to the comparison function
              support.detectDuplicates = !!hasDuplicate

              // Initialize against the default document
              setDocument()

              // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
              // Detached nodes confoundingly follow *each other*
              support.sortDetached = assert(function (el) {
                // Should return 1, but returns 4 (following)
                return (
                  el.compareDocumentPosition(
                    document.createElement('fieldset')
                  ) & 1
                )
              })

              // Support: IE<8
              // Prevent attribute/property "interpolation"
              // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
              if (
                !assert(function (el) {
                  el.innerHTML = "<a href='#'></a>"
                  return el.firstChild.getAttribute('href') === '#'
                })
              ) {
                addHandle(
                  'type|href|height|width',
                  function (elem, name, isXML) {
                    if (!isXML) {
                      return elem.getAttribute(
                        name,
                        name.toLowerCase() === 'type' ? 1 : 2
                      )
                    }
                  }
                )
              }

              // Support: IE<9
              // Use defaultValue in place of getAttribute("value")
              if (
                !support.attributes ||
                !assert(function (el) {
                  el.innerHTML = '<input/>'
                  el.firstChild.setAttribute('value', '')
                  return el.firstChild.getAttribute('value') === ''
                })
              ) {
                addHandle('value', function (elem, _name, isXML) {
                  if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue
                  }
                })
              }

              // Support: IE<9
              // Use getAttributeNode to fetch booleans when getAttribute lies
              if (
                !assert(function (el) {
                  return el.getAttribute('disabled') == null
                })
              ) {
                addHandle(booleans, function (elem, name, isXML) {
                  var val
                  if (!isXML) {
                    return elem[name] === true
                      ? name.toLowerCase()
                      : (val = elem.getAttributeNode(name)) && val.specified
                      ? val.value
                      : null
                  }
                })
              }

              return Sizzle
            })(window)

          jQuery.find = Sizzle
          jQuery.expr = Sizzle.selectors

          // Deprecated
          jQuery.expr[':'] = jQuery.expr.pseudos
          jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort
          jQuery.text = Sizzle.getText
          jQuery.isXMLDoc = Sizzle.isXML
          jQuery.contains = Sizzle.contains
          jQuery.escapeSelector = Sizzle.escape

          var dir = function (elem, dir, until) {
            var matched = [],
              truncate = until !== undefined

            while ((elem = elem[dir]) && elem.nodeType !== 9) {
              if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                  break
                }
                matched.push(elem)
              }
            }
            return matched
          }

          var siblings = function (n, elem) {
            var matched = []

            for (; n; n = n.nextSibling) {
              if (n.nodeType === 1 && n !== elem) {
                matched.push(n)
              }
            }

            return matched
          }

          var rneedsContext = jQuery.expr.match.needsContext

          function nodeName(elem, name) {
            return (
              elem.nodeName &&
              elem.nodeName.toLowerCase() === name.toLowerCase()
            )
          }
          var rsingleTag =
            /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i

          // Implement the identical functionality for filter and not
          function winnow(elements, qualifier, not) {
            if (isFunction(qualifier)) {
              return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
              })
            }

            // Single element
            if (qualifier.nodeType) {
              return jQuery.grep(elements, function (elem) {
                return (elem === qualifier) !== not
              })
            }

            // Arraylike of elements (jQuery, arguments, Array)
            if (typeof qualifier !== 'string') {
              return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not
              })
            }

            // Filtered directly for both simple and complex selectors
            return jQuery.filter(qualifier, elements, not)
          }

          jQuery.filter = function (expr, elems, not) {
            var elem = elems[0]

            if (not) {
              expr = ':not(' + expr + ')'
            }

            if (elems.length === 1 && elem.nodeType === 1) {
              return jQuery.find.matchesSelector(elem, expr) ? [elem] : []
            }

            return jQuery.find.matches(
              expr,
              jQuery.grep(elems, function (elem) {
                return elem.nodeType === 1
              })
            )
          }

          jQuery.fn.extend({
            find: function (selector) {
              var i,
                ret,
                len = this.length,
                self = this

              if (typeof selector !== 'string') {
                return this.pushStack(
                  jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                      if (jQuery.contains(self[i], this)) {
                        return true
                      }
                    }
                  })
                )
              }

              ret = this.pushStack([])

              for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret)
              }

              return len > 1 ? jQuery.uniqueSort(ret) : ret
            },
            filter: function (selector) {
              return this.pushStack(winnow(this, selector || [], false))
            },
            not: function (selector) {
              return this.pushStack(winnow(this, selector || [], true))
            },
            is: function (selector) {
              return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === 'string' && rneedsContext.test(selector)
                  ? jQuery(selector)
                  : selector || [],
                false
              ).length
            }
          })

          // Initialize a jQuery object

          // A central reference to the root jQuery(document)
          var rootjQuery,
            // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            // Strict HTML recognition (#11290: must start with <)
            // Shortcut simple #id case for speed
            rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
            init = (jQuery.fn.init = function (selector, context, root) {
              var match, elem

              // HANDLE: $(""), $(null), $(undefined), $(false)
              if (!selector) {
                return this
              }

              // Method init() accepts an alternate rootjQuery
              // so migrate can support jQuery.sub (gh-2101)
              root = root || rootjQuery

              // Handle HTML strings
              if (typeof selector === 'string') {
                if (
                  selector[0] === '<' &&
                  selector[selector.length - 1] === '>' &&
                  selector.length >= 3
                ) {
                  // Assume that strings that start and end with <> are HTML and skip the regex check
                  match = [null, selector, null]
                } else {
                  match = rquickExpr.exec(selector)
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {
                  // HANDLE: $(html) -> $(array)
                  if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context

                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(
                      this,
                      jQuery.parseHTML(
                        match[1],
                        context && context.nodeType
                          ? context.ownerDocument || context
                          : document,
                        true
                      )
                    )

                    // HANDLE: $(html, props)
                    if (
                      rsingleTag.test(match[1]) &&
                      jQuery.isPlainObject(context)
                    ) {
                      for (match in context) {
                        // Properties of context are called as methods if possible
                        if (isFunction(this[match])) {
                          this[match](context[match])

                          // ...and otherwise set as attributes
                        } else {
                          this.attr(match, context[match])
                        }
                      }
                    }

                    return this

                    // HANDLE: $(#id)
                  } else {
                    elem = document.getElementById(match[2])

                    if (elem) {
                      // Inject the element directly into the jQuery object
                      this[0] = elem
                      this.length = 1
                    }
                    return this
                  }

                  // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                  return (context || root).find(selector)

                  // HANDLE: $(expr, context)
                  // (which is just equivalent to: $(context).find(expr)
                } else {
                  return this.constructor(context).find(selector)
                }

                // HANDLE: $(DOMElement)
              } else if (selector.nodeType) {
                this[0] = selector
                this.length = 1
                return this

                // HANDLE: $(function)
                // Shortcut for document ready
              } else if (isFunction(selector)) {
                return root.ready !== undefined
                  ? root.ready(selector)
                  : // Execute immediately if ready is not present
                    selector(jQuery)
              }

              return jQuery.makeArray(selector, this)
            })

          // Give the init function the jQuery prototype for later instantiation
          init.prototype = jQuery.fn

          // Initialize central reference
          rootjQuery = jQuery(document)

          var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            // Methods guaranteed to produce a unique set when starting from a unique set
            guaranteedUnique = {
              children: true,
              contents: true,
              next: true,
              prev: true
            }

          jQuery.fn.extend({
            has: function (target) {
              var targets = jQuery(target, this),
                l = targets.length

              return this.filter(function () {
                var i = 0
                for (; i < l; i++) {
                  if (jQuery.contains(this, targets[i])) {
                    return true
                  }
                }
              })
            },

            closest: function (selectors, context) {
              var cur,
                i = 0,
                l = this.length,
                matched = [],
                targets = typeof selectors !== 'string' && jQuery(selectors)

              // Positional selectors never match, since there's no _selection_ context
              if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                  for (
                    cur = this[i];
                    cur && cur !== context;
                    cur = cur.parentNode
                  ) {
                    // Always skip document fragments
                    if (
                      cur.nodeType < 11 &&
                      (targets
                        ? targets.index(cur) > -1
                        : // Don't pass non-elements to Sizzle
                          cur.nodeType === 1 &&
                          jQuery.find.matchesSelector(cur, selectors))
                    ) {
                      matched.push(cur)
                      break
                    }
                  }
                }
              }

              return this.pushStack(
                matched.length > 1 ? jQuery.uniqueSort(matched) : matched
              )
            },

            // Determine the position of an element within the set
            index: function (elem) {
              // No argument, return index in parent
              if (!elem) {
                return this[0] && this[0].parentNode
                  ? this.first().prevAll().length
                  : -1
              }

              // Index in selector
              if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0])
              }

              // Locate the position of the desired element
              return indexOf.call(
                this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
              )
            },

            add: function (selector, context) {
              return this.pushStack(
                jQuery.uniqueSort(
                  jQuery.merge(this.get(), jQuery(selector, context))
                )
              )
            },

            addBack: function (selector) {
              return this.add(
                selector == null
                  ? this.prevObject
                  : this.prevObject.filter(selector)
              )
            }
          })

          function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {}
            return cur
          }

          jQuery.each(
            {
              parent: function (elem) {
                var parent = elem.parentNode
                return parent && parent.nodeType !== 11 ? parent : null
              },
              parents: function (elem) {
                return dir(elem, 'parentNode')
              },
              parentsUntil: function (elem, _i, until) {
                return dir(elem, 'parentNode', until)
              },
              next: function (elem) {
                return sibling(elem, 'nextSibling')
              },
              prev: function (elem) {
                return sibling(elem, 'previousSibling')
              },
              nextAll: function (elem) {
                return dir(elem, 'nextSibling')
              },
              prevAll: function (elem) {
                return dir(elem, 'previousSibling')
              },
              nextUntil: function (elem, _i, until) {
                return dir(elem, 'nextSibling', until)
              },
              prevUntil: function (elem, _i, until) {
                return dir(elem, 'previousSibling', until)
              },
              siblings: function (elem) {
                return siblings((elem.parentNode || {}).firstChild, elem)
              },
              children: function (elem) {
                return siblings(elem.firstChild)
              },
              contents: function (elem) {
                if (
                  elem.contentDocument != null &&
                  // Support: IE 11+
                  // <object> elements with no `data` attribute has an object
                  // `contentDocument` with a `null` prototype.
                  getProto(elem.contentDocument)
                ) {
                  return elem.contentDocument
                }

                // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
                // Treat the template element as a regular one in browsers that
                // don't support it.
                if (nodeName(elem, 'template')) {
                  elem = elem.content || elem
                }

                return jQuery.merge([], elem.childNodes)
              }
            },
            function (name, fn) {
              jQuery.fn[name] = function (until, selector) {
                var matched = jQuery.map(this, fn, until)

                if (name.slice(-5) !== 'Until') {
                  selector = until
                }

                if (selector && typeof selector === 'string') {
                  matched = jQuery.filter(selector, matched)
                }

                if (this.length > 1) {
                  // Remove duplicates
                  if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched)
                  }

                  // Reverse order for parents* and prev-derivatives
                  if (rparentsprev.test(name)) {
                    matched.reverse()
                  }
                }

                return this.pushStack(matched)
              }
            }
          )
          var rnothtmlwhite = /[^\x20\t\r\n\f]+/g

          // Convert String-formatted options into Object-formatted ones
          function createOptions(options) {
            var object = {}
            jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
              object[flag] = true
            })
            return object
          }

          /*
           * Create a callback list using the following parameters:
           *
           *	options: an optional list of space-separated options that will change how
           *			the callback list behaves or a more traditional option object
           *
           * By default a callback list will act like an event callback list and can be
           * "fired" multiple times.
           *
           * Possible options:
           *
           *	once:			will ensure the callback list can only be fired once (like a Deferred)
           *
           *	memory:			will keep track of previous values and will call any callback added
           *					after the list has been fired right away with the latest "memorized"
           *					values (like a Deferred)
           *
           *	unique:			will ensure a callback can only be added once (no duplicate in the list)
           *
           *	stopOnFalse:	interrupt callings when a callback returns false
           *
           */
          jQuery.Callbacks = function (options) {
            // Convert options from String-formatted to Object-formatted if needed
            // (we check in cache first)
            options =
              typeof options === 'string'
                ? createOptions(options)
                : jQuery.extend({}, options)

            var // Flag to know if list is currently firing
              firing,
              // Last fire value for non-forgettable lists
              memory,
              // Flag to know if list was already fired
              fired,
              // Flag to prevent firing
              locked,
              // Actual callback list
              list = [],
              // Queue of execution data for repeatable lists
              queue = [],
              // Index of currently firing callback (modified by add/remove as needed)
              firingIndex = -1,
              // Fire callbacks
              fire = function () {
                // Enforce single-firing
                locked = locked || options.once

                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true
                for (; queue.length; firingIndex = -1) {
                  memory = queue.shift()
                  while (++firingIndex < list.length) {
                    // Run callback and check for early termination
                    if (
                      list[firingIndex].apply(memory[0], memory[1]) === false &&
                      options.stopOnFalse
                    ) {
                      // Jump to end and forget the data so .add doesn't re-fire
                      firingIndex = list.length
                      memory = false
                    }
                  }
                }

                // Forget the data if we're done with it
                if (!options.memory) {
                  memory = false
                }

                firing = false

                // Clean up if we're done firing for good
                if (locked) {
                  // Keep an empty list if we have data for future add calls
                  if (memory) {
                    list = []

                    // Otherwise, this object is spent
                  } else {
                    list = ''
                  }
                }
              },
              // Actual Callbacks object
              self = {
                // Add a callback or a collection of callbacks to the list
                add: function () {
                  if (list) {
                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                      firingIndex = list.length - 1
                      queue.push(memory)
                    }

                    ;(function add(args) {
                      jQuery.each(args, function (_, arg) {
                        if (isFunction(arg)) {
                          if (!options.unique || !self.has(arg)) {
                            list.push(arg)
                          }
                        } else if (
                          arg &&
                          arg.length &&
                          toType(arg) !== 'string'
                        ) {
                          // Inspect recursively
                          add(arg)
                        }
                      })
                    })(arguments)

                    if (memory && !firing) {
                      fire()
                    }
                  }
                  return this
                },

                // Remove a callback from the list
                remove: function () {
                  jQuery.each(arguments, function (_, arg) {
                    var index
                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                      list.splice(index, 1)

                      // Handle firing indexes
                      if (index <= firingIndex) {
                        firingIndex--
                      }
                    }
                  })
                  return this
                },

                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function (fn) {
                  return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
                },

                // Remove all callbacks from the list
                empty: function () {
                  if (list) {
                    list = []
                  }
                  return this
                },

                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function () {
                  locked = queue = []
                  list = memory = ''
                  return this
                },
                disabled: function () {
                  return !list
                },

                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function () {
                  locked = queue = []
                  if (!memory && !firing) {
                    list = memory = ''
                  }
                  return this
                },
                locked: function () {
                  return !!locked
                },

                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                  if (!locked) {
                    args = args || []
                    args = [context, args.slice ? args.slice() : args]
                    queue.push(args)
                    if (!firing) {
                      fire()
                    }
                  }
                  return this
                },

                // Call all the callbacks with the given arguments
                fire: function () {
                  self.fireWith(this, arguments)
                  return this
                },

                // To know if the callbacks have already been called at least once
                fired: function () {
                  return !!fired
                }
              }

            return self
          }

          function Identity(v) {
            return v
          }
          function Thrower(ex) {
            throw ex
          }

          function adoptValue(value, resolve, reject, noValue) {
            var method

            try {
              // Check for promise aspect first to privilege synchronous behavior
              if (value && isFunction((method = value.promise))) {
                method.call(value).done(resolve).fail(reject)

                // Other thenables
              } else if (value && isFunction((method = value.then))) {
                method.call(value, resolve, reject)

                // Other non-thenables
              } else {
                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                // * false: [ value ].slice( 0 ) => resolve( value )
                // * true: [ value ].slice( 1 ) => resolve()
                resolve.apply(undefined, [value].slice(noValue))
              }

              // For Promises/A+, convert exceptions into rejections
              // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
              // Deferred#then to conditionally suppress rejection.
            } catch (value) {
              // Support: Android 4.0 only
              // Strict mode functions invoked without .call/.apply get global-object context
              reject.apply(undefined, [value])
            }
          }

          jQuery.extend({
            Deferred: function (func) {
              var tuples = [
                  // action, add listener, callbacks,
                  // ... .then handlers, argument index, [final state]
                  [
                    'notify',
                    'progress',
                    jQuery.Callbacks('memory'),
                    jQuery.Callbacks('memory'),
                    2
                  ],
                  [
                    'resolve',
                    'done',
                    jQuery.Callbacks('once memory'),
                    jQuery.Callbacks('once memory'),
                    0,
                    'resolved'
                  ],
                  [
                    'reject',
                    'fail',
                    jQuery.Callbacks('once memory'),
                    jQuery.Callbacks('once memory'),
                    1,
                    'rejected'
                  ]
                ],
                state = 'pending',
                promise = {
                  state: function () {
                    return state
                  },
                  always: function () {
                    deferred.done(arguments).fail(arguments)
                    return this
                  },
                  catch: function (fn) {
                    return promise.then(null, fn)
                  },

                  // Keep pipe for back-compat
                  pipe: function (/* fnDone, fnFail, fnProgress */) {
                    var fns = arguments

                    return jQuery
                      .Deferred(function (newDefer) {
                        jQuery.each(tuples, function (_i, tuple) {
                          // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                          var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]

                          // deferred.progress(function() { bind to newDefer or newDefer.notify })
                          // deferred.done(function() { bind to newDefer or newDefer.resolve })
                          // deferred.fail(function() { bind to newDefer or newDefer.reject })
                          deferred[tuple[1]](function () {
                            var returned = fn && fn.apply(this, arguments)
                            if (returned && isFunction(returned.promise)) {
                              returned
                                .promise()
                                .progress(newDefer.notify)
                                .done(newDefer.resolve)
                                .fail(newDefer.reject)
                            } else {
                              newDefer[tuple[0] + 'With'](
                                this,
                                fn ? [returned] : arguments
                              )
                            }
                          })
                        })
                        fns = null
                      })
                      .promise()
                  },
                  then: function (onFulfilled, onRejected, onProgress) {
                    var maxDepth = 0
                    function resolve(depth, deferred, handler, special) {
                      return function () {
                        var that = this,
                          args = arguments,
                          mightThrow = function () {
                            var returned, then

                            // Support: Promises/A+ section 2.3.3.3.3
                            // https://promisesaplus.com/#point-59
                            // Ignore double-resolution attempts
                            if (depth < maxDepth) {
                              return
                            }

                            returned = handler.apply(that, args)

                            // Support: Promises/A+ section 2.3.1
                            // https://promisesaplus.com/#point-48
                            if (returned === deferred.promise()) {
                              throw new TypeError('Thenable self-resolution')
                            }

                            // Support: Promises/A+ sections 2.3.3.1, 3.5
                            // https://promisesaplus.com/#point-54
                            // https://promisesaplus.com/#point-75
                            // Retrieve `then` only once
                            then =
                              returned &&
                              // Support: Promises/A+ section 2.3.4
                              // https://promisesaplus.com/#point-64
                              // Only check objects and functions for thenability
                              (typeof returned === 'object' ||
                                typeof returned === 'function') &&
                              returned.then

                            // Handle a returned thenable
                            if (isFunction(then)) {
                              // Special processors (notify) just wait for resolution
                              if (special) {
                                then.call(
                                  returned,
                                  resolve(
                                    maxDepth,
                                    deferred,
                                    Identity,
                                    special
                                  ),
                                  resolve(maxDepth, deferred, Thrower, special)
                                )

                                // Normal processors (resolve) also hook into progress
                              } else {
                                // ...and disregard older resolution values
                                maxDepth++

                                then.call(
                                  returned,
                                  resolve(
                                    maxDepth,
                                    deferred,
                                    Identity,
                                    special
                                  ),
                                  resolve(maxDepth, deferred, Thrower, special),
                                  resolve(
                                    maxDepth,
                                    deferred,
                                    Identity,
                                    deferred.notifyWith
                                  )
                                )
                              }

                              // Handle all other returned values
                            } else {
                              // Only substitute handlers pass on context
                              // and multiple values (non-spec behavior)
                              if (handler !== Identity) {
                                that = undefined
                                args = [returned]
                              }

                              // Process the value(s)
                              // Default process is resolve
                              ;(special || deferred.resolveWith)(that, args)
                            }
                          },
                          // Only normal processors (resolve) catch and reject exceptions
                          process = special
                            ? mightThrow
                            : function () {
                                try {
                                  mightThrow()
                                } catch (e) {
                                  if (jQuery.Deferred.exceptionHook) {
                                    jQuery.Deferred.exceptionHook(
                                      e,
                                      process.stackTrace
                                    )
                                  }

                                  // Support: Promises/A+ section 2.3.3.3.4.1
                                  // https://promisesaplus.com/#point-61
                                  // Ignore post-resolution exceptions
                                  if (depth + 1 >= maxDepth) {
                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if (handler !== Thrower) {
                                      that = undefined
                                      args = [e]
                                    }

                                    deferred.rejectWith(that, args)
                                  }
                                }
                              }

                        // Support: Promises/A+ section 2.3.3.3.1
                        // https://promisesaplus.com/#point-57
                        // Re-resolve promises immediately to dodge false rejection from
                        // subsequent errors
                        if (depth) {
                          process()
                        } else {
                          // Call an optional hook to record the stack, in case of exception
                          // since it's otherwise lost when execution goes async
                          if (jQuery.Deferred.getStackHook) {
                            process.stackTrace = jQuery.Deferred.getStackHook()
                          }
                          window.setTimeout(process)
                        }
                      }
                    }

                    return jQuery
                      .Deferred(function (newDefer) {
                        // progress_handlers.add( ... )
                        tuples[0][3].add(
                          resolve(
                            0,
                            newDefer,
                            isFunction(onProgress) ? onProgress : Identity,
                            newDefer.notifyWith
                          )
                        )

                        // fulfilled_handlers.add( ... )
                        tuples[1][3].add(
                          resolve(
                            0,
                            newDefer,
                            isFunction(onFulfilled) ? onFulfilled : Identity
                          )
                        )

                        // rejected_handlers.add( ... )
                        tuples[2][3].add(
                          resolve(
                            0,
                            newDefer,
                            isFunction(onRejected) ? onRejected : Thrower
                          )
                        )
                      })
                      .promise()
                  },

                  // Get a promise for this deferred
                  // If obj is provided, the promise aspect is added to the object
                  promise: function (obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise
                  }
                },
                deferred = {}

              // Add list-specific methods
              jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                  stateString = tuple[5]

                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add

                // Handle state
                if (stateString) {
                  list.add(
                    function () {
                      // state = "resolved" (i.e., fulfilled)
                      // state = "rejected"
                      state = stateString
                    },

                    // rejected_callbacks.disable
                    // fulfilled_callbacks.disable
                    tuples[3 - i][2].disable,

                    // rejected_handlers.disable
                    // fulfilled_handlers.disable
                    tuples[3 - i][3].disable,

                    // progress_callbacks.lock
                    tuples[0][2].lock,

                    // progress_handlers.lock
                    tuples[0][3].lock
                  )
                }

                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire)

                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function () {
                  deferred[tuple[0] + 'With'](
                    this === deferred ? undefined : this,
                    arguments
                  )
                  return this
                }

                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + 'With'] = list.fireWith
              })

              // Make the deferred a promise
              promise.promise(deferred)

              // Call given func if any
              if (func) {
                func.call(deferred, deferred)
              }

              // All done!
              return deferred
            },

            // Deferred helper
            when: function (singleValue) {
              var // count of uncompleted subordinates
                remaining = arguments.length,
                // count of unprocessed arguments
                i = remaining,
                // subordinate fulfillment data
                resolveContexts = Array(i),
                resolveValues = slice.call(arguments),
                // the primary Deferred
                primary = jQuery.Deferred(),
                // subordinate callback factory
                updateFunc = function (i) {
                  return function (value) {
                    resolveContexts[i] = this
                    resolveValues[i] =
                      arguments.length > 1 ? slice.call(arguments) : value
                    if (!--remaining) {
                      primary.resolveWith(resolveContexts, resolveValues)
                    }
                  }
                }

              // Single- and empty arguments are adopted like Promise.resolve
              if (remaining <= 1) {
                adoptValue(
                  singleValue,
                  primary.done(updateFunc(i)).resolve,
                  primary.reject,
                  !remaining
                )

                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (
                  primary.state() === 'pending' ||
                  isFunction(resolveValues[i] && resolveValues[i].then)
                ) {
                  return primary.then()
                }
              }

              // Multiple arguments are aggregated like Promise.all array elements
              while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), primary.reject)
              }

              return primary.promise()
            }
          })

          // These usually indicate a programmer mistake during development,
          // warn about them ASAP rather than swallowing them by default.
          var rerrorNames =
            /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/

          jQuery.Deferred.exceptionHook = function (error, stack) {
            // Support: IE 8 - 9 only
            // Console exists when dev tools are open, which can happen at any time
            if (
              window.console &&
              window.console.warn &&
              error &&
              rerrorNames.test(error.name)
            ) {
              window.console.warn(
                'jQuery.Deferred exception: ' + error.message,
                error.stack,
                stack
              )
            }
          }

          jQuery.readyException = function (error) {
            window.setTimeout(function () {
              throw error
            })
          }

          // The deferred used on DOM ready
          var readyList = jQuery.Deferred()

          jQuery.fn.ready = function (fn) {
            readyList
              .then(fn)

              // Wrap jQuery.readyException in a function so that the lookup
              // happens at the time of error handling instead of callback
              // registration.
              .catch(function (error) {
                jQuery.readyException(error)
              })

            return this
          }

          jQuery.extend({
            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Handle when the DOM is ready
            ready: function (wait) {
              // Abort if there are pending holds or we're already ready
              if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return
              }

              // Remember that the DOM is ready
              jQuery.isReady = true

              // If a normal DOM Ready event fired, decrement, and wait if need be
              if (wait !== true && --jQuery.readyWait > 0) {
                return
              }

              // If there are functions bound, to execute
              readyList.resolveWith(document, [jQuery])
            }
          })

          jQuery.ready.then = readyList.then

          // The ready event handler and self cleanup method
          function completed() {
            document.removeEventListener('DOMContentLoaded', completed)
            window.removeEventListener('load', completed)
            jQuery.ready()
          }

          // Catch cases where $(document).ready() is called
          // after the browser event has already occurred.
          // Support: IE <=9 - 10 only
          // Older IE sometimes signals "interactive" too soon
          if (
            document.readyState === 'complete' ||
            (document.readyState !== 'loading' &&
              !document.documentElement.doScroll)
          ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            window.setTimeout(jQuery.ready)
          } else {
            // Use the handy event callback
            document.addEventListener('DOMContentLoaded', completed)

            // A fallback to window.onload, that will always work
            window.addEventListener('load', completed)
          }

          // Multifunctional method to get and set values of a collection
          // The value/s can optionally be executed if it's a function
          var access = function (
            elems,
            fn,
            key,
            value,
            chainable,
            emptyGet,
            raw
          ) {
            var i = 0,
              len = elems.length,
              bulk = key == null

            // Sets many values
            if (toType(key) === 'object') {
              chainable = true
              for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw)
              }

              // Sets one value
            } else if (value !== undefined) {
              chainable = true

              if (!isFunction(value)) {
                raw = true
              }

              if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                  fn.call(elems, value)
                  fn = null

                  // ...except when executing function values
                } else {
                  bulk = fn
                  fn = function (elem, _key, value) {
                    return bulk.call(jQuery(elem), value)
                  }
                }
              }

              if (fn) {
                for (; i < len; i++) {
                  fn(
                    elems[i],
                    key,
                    raw ? value : value.call(elems[i], i, fn(elems[i], key))
                  )
                }
              }
            }

            if (chainable) {
              return elems
            }

            // Gets
            if (bulk) {
              return fn.call(elems)
            }

            return len ? fn(elems[0], key) : emptyGet
          }

          // Matches dashed string for camelizing
          var rmsPrefix = /^-ms-/,
            rdashAlpha = /-([a-z])/g

          // Used by camelCase as callback to replace()
          function fcamelCase(_all, letter) {
            return letter.toUpperCase()
          }

          // Convert dashed to camelCase; used by the css and data modules
          // Support: IE <=9 - 11, Edge 12 - 15
          // Microsoft forgot to hump their vendor prefix (#9572)
          function camelCase(string) {
            return string
              .replace(rmsPrefix, 'ms-')
              .replace(rdashAlpha, fcamelCase)
          }
          var acceptData = function (owner) {
            // Accepts only:
            //  - Node
            //    - Node.ELEMENT_NODE
            //    - Node.DOCUMENT_NODE
            //  - Object
            //    - Any
            return (
              owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType
            )
          }

          function Data() {
            this.expando = jQuery.expando + Data.uid++
          }

          Data.uid = 1

          Data.prototype = {
            cache: function (owner) {
              // Check if the owner object already has a cache
              var value = owner[this.expando]

              // If not, create one
              if (!value) {
                value = {}

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {
                  // If it is a node unlikely to be stringify-ed or looped over
                  // use plain assignment
                  if (owner.nodeType) {
                    owner[this.expando] = value

                    // Otherwise secure it in a non-enumerable property
                    // configurable must be true to allow the property to be
                    // deleted when data is removed
                  } else {
                    Object.defineProperty(owner, this.expando, {
                      value: value,
                      configurable: true
                    })
                  }
                }
              }

              return value
            },
            set: function (owner, data, value) {
              var prop,
                cache = this.cache(owner)

              // Handle: [ owner, key, value ] args
              // Always use camelCase key (gh-2257)
              if (typeof data === 'string') {
                cache[camelCase(data)] = value

                // Handle: [ owner, { properties } ] args
              } else {
                // Copy the properties one-by-one to the cache object
                for (prop in data) {
                  cache[camelCase(prop)] = data[prop]
                }
              }
              return cache
            },
            get: function (owner, key) {
              return key === undefined
                ? this.cache(owner)
                : // Always use camelCase key (gh-2257)
                  owner[this.expando] && owner[this.expando][camelCase(key)]
            },
            access: function (owner, key, value) {
              // In cases where either:
              //
              //   1. No key was specified
              //   2. A string key was specified, but no value provided
              //
              // Take the "read" path and allow the get method to determine
              // which value to return, respectively either:
              //
              //   1. The entire cache object
              //   2. The data stored at the key
              //
              if (
                key === undefined ||
                (key && typeof key === 'string' && value === undefined)
              ) {
                return this.get(owner, key)
              }

              // When the key is not a string, or both a key and value
              // are specified, set or extend (existing objects) with either:
              //
              //   1. An object of properties
              //   2. A key and value
              //
              this.set(owner, key, value)

              // Since the "set" path can have two possible entry points
              // return the expected data based on which path was taken[*]
              return value !== undefined ? value : key
            },
            remove: function (owner, key) {
              var i,
                cache = owner[this.expando]

              if (cache === undefined) {
                return
              }

              if (key !== undefined) {
                // Support array or space separated string of keys
                if (Array.isArray(key)) {
                  // If key is an array of keys...
                  // We always set camelCase keys, so remove that.
                  key = key.map(camelCase)
                } else {
                  key = camelCase(key)

                  // If a key with the spaces exists, use it.
                  // Otherwise, create an array by matching non-whitespace
                  key = key in cache ? [key] : key.match(rnothtmlwhite) || []
                }

                i = key.length

                while (i--) {
                  delete cache[key[i]]
                }
              }

              // Remove the expando if there's no more data
              if (key === undefined || jQuery.isEmptyObject(cache)) {
                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) {
                  owner[this.expando] = undefined
                } else {
                  delete owner[this.expando]
                }
              }
            },
            hasData: function (owner) {
              var cache = owner[this.expando]
              return cache !== undefined && !jQuery.isEmptyObject(cache)
            }
          }
          var dataPriv = new Data()

          var dataUser = new Data()

          //	Implementation Summary
          //
          //	1. Enforce API surface and semantic compatibility with 1.9.x branch
          //	2. Improve the module's maintainability by reducing the storage
          //		paths to a single mechanism.
          //	3. Use the same single mechanism to support "private" and "user" data.
          //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
          //	5. Avoid exposing implementation details on user objects (eg. expando properties)
          //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

          var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /[A-Z]/g

          function getData(data) {
            if (data === 'true') {
              return true
            }

            if (data === 'false') {
              return false
            }

            if (data === 'null') {
              return null
            }

            // Only convert to a number if it doesn't change the string
            if (data === +data + '') {
              return +data
            }

            if (rbrace.test(data)) {
              return JSON.parse(data)
            }

            return data
          }

          function dataAttr(elem, key, data) {
            var name

            // If nothing was found internally, try to fetch any
            // data from the HTML5 data-* attribute
            if (data === undefined && elem.nodeType === 1) {
              name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase()
              data = elem.getAttribute(name)

              if (typeof data === 'string') {
                try {
                  data = getData(data)
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data)
              } else {
                data = undefined
              }
            }
            return data
          }

          jQuery.extend({
            hasData: function (elem) {
              return dataUser.hasData(elem) || dataPriv.hasData(elem)
            },

            data: function (elem, name, data) {
              return dataUser.access(elem, name, data)
            },

            removeData: function (elem, name) {
              dataUser.remove(elem, name)
            },

            // TODO: Now that all calls to _data and _removeData have been replaced
            // with direct calls to dataPriv methods, these can be deprecated.
            _data: function (elem, name, data) {
              return dataPriv.access(elem, name, data)
            },

            _removeData: function (elem, name) {
              dataPriv.remove(elem, name)
            }
          })

          jQuery.fn.extend({
            data: function (key, value) {
              var i,
                name,
                data,
                elem = this[0],
                attrs = elem && elem.attributes

              // Gets all values
              if (key === undefined) {
                if (this.length) {
                  data = dataUser.get(elem)

                  if (
                    elem.nodeType === 1 &&
                    !dataPriv.get(elem, 'hasDataAttrs')
                  ) {
                    i = attrs.length
                    while (i--) {
                      // Support: IE 11 only
                      // The attrs elements can be null (#14894)
                      if (attrs[i]) {
                        name = attrs[i].name
                        if (name.indexOf('data-') === 0) {
                          name = camelCase(name.slice(5))
                          dataAttr(elem, name, data[name])
                        }
                      }
                    }
                    dataPriv.set(elem, 'hasDataAttrs', true)
                  }
                }

                return data
              }

              // Sets multiple values
              if (typeof key === 'object') {
                return this.each(function () {
                  dataUser.set(this, key)
                })
              }

              return access(
                this,
                function (value) {
                  var data

                  // The calling jQuery object (element matches) is not empty
                  // (and therefore has an element appears at this[ 0 ]) and the
                  // `value` parameter was not undefined. An empty jQuery object
                  // will result in `undefined` for elem = this[ 0 ] which will
                  // throw an exception if an attempt to read a data cache is made.
                  if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key)
                    if (data !== undefined) {
                      return data
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key)
                    if (data !== undefined) {
                      return data
                    }

                    // We tried really hard, but the data doesn't exist.
                    return
                  }

                  // Set the data...
                  this.each(function () {
                    // We always store the camelCased key
                    dataUser.set(this, key, value)
                  })
                },
                null,
                value,
                arguments.length > 1,
                null,
                true
              )
            },

            removeData: function (key) {
              return this.each(function () {
                dataUser.remove(this, key)
              })
            }
          })

          jQuery.extend({
            queue: function (elem, type, data) {
              var queue

              if (elem) {
                type = (type || 'fx') + 'queue'
                queue = dataPriv.get(elem, type)

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                  if (!queue || Array.isArray(data)) {
                    queue = dataPriv.access(elem, type, jQuery.makeArray(data))
                  } else {
                    queue.push(data)
                  }
                }
                return queue || []
              }
            },

            dequeue: function (elem, type) {
              type = type || 'fx'

              var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function () {
                  jQuery.dequeue(elem, type)
                }

              // If the fx queue is dequeued, always remove the progress sentinel
              if (fn === 'inprogress') {
                fn = queue.shift()
                startLength--
              }

              if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === 'fx') {
                  queue.unshift('inprogress')
                }

                // Clear up the last queue stop function
                delete hooks.stop
                fn.call(elem, next, hooks)
              }

              if (!startLength && hooks) {
                hooks.empty.fire()
              }
            },

            // Not public - generate a queueHooks object, or return the current one
            _queueHooks: function (elem, type) {
              var key = type + 'queueHooks'
              return (
                dataPriv.get(elem, key) ||
                dataPriv.access(elem, key, {
                  empty: jQuery.Callbacks('once memory').add(function () {
                    dataPriv.remove(elem, [type + 'queue', key])
                  })
                })
              )
            }
          })

          jQuery.fn.extend({
            queue: function (type, data) {
              var setter = 2

              if (typeof type !== 'string') {
                data = type
                type = 'fx'
                setter--
              }

              if (arguments.length < setter) {
                return jQuery.queue(this[0], type)
              }

              return data === undefined
                ? this
                : this.each(function () {
                    var queue = jQuery.queue(this, type, data)

                    // Ensure a hooks for this queue
                    jQuery._queueHooks(this, type)

                    if (type === 'fx' && queue[0] !== 'inprogress') {
                      jQuery.dequeue(this, type)
                    }
                  })
            },
            dequeue: function (type) {
              return this.each(function () {
                jQuery.dequeue(this, type)
              })
            },
            clearQueue: function (type) {
              return this.queue(type || 'fx', [])
            },

            // Get a promise resolved when queues of a certain type
            // are emptied (fx is the type by default)
            promise: function (type, obj) {
              var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function () {
                  if (!--count) {
                    defer.resolveWith(elements, [elements])
                  }
                }

              if (typeof type !== 'string') {
                obj = type
                type = undefined
              }
              type = type || 'fx'

              while (i--) {
                tmp = dataPriv.get(elements[i], type + 'queueHooks')
                if (tmp && tmp.empty) {
                  count++
                  tmp.empty.add(resolve)
                }
              }
              resolve()
              return defer.promise(obj)
            }
          })
          var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source

          var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i')

          var cssExpand = ['Top', 'Right', 'Bottom', 'Left']

          var documentElement = document.documentElement

          var isAttached = function (elem) {
              return jQuery.contains(elem.ownerDocument, elem)
            },
            composed = { composed: true }

          // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
          // Check attachment across shadow DOM boundaries when possible (gh-3504)
          // Support: iOS 10.0-10.2 only
          // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
          // leading to errors. We need to check for `getRootNode`.
          if (documentElement.getRootNode) {
            isAttached = function (elem) {
              return (
                jQuery.contains(elem.ownerDocument, elem) ||
                elem.getRootNode(composed) === elem.ownerDocument
              )
            }
          }
          var isHiddenWithinTree = function (elem, el) {
            // isHiddenWithinTree might be called from jQuery#filter function;
            // in that case, element will be second argument
            elem = el || elem

            // Inline style trumps all
            return (
              elem.style.display === 'none' ||
              (elem.style.display === '' &&
                // Otherwise, check computed style
                // Support: Firefox <=43 - 45
                // Disconnected elements can have computed display: none, so first confirm that elem is
                // in the document.
                isAttached(elem) &&
                jQuery.css(elem, 'display') === 'none')
            )
          }

          function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted,
              scale,
              maxIterations = 20,
              currentValue = tween
                ? function () {
                    return tween.cur()
                  }
                : function () {
                    return jQuery.css(elem, prop, '')
                  },
              initial = currentValue(),
              unit =
                (valueParts && valueParts[3]) ||
                (jQuery.cssNumber[prop] ? '' : 'px'),
              // Starting value computation is required for potential unit mismatches
              initialInUnit =
                elem.nodeType &&
                (jQuery.cssNumber[prop] || (unit !== 'px' && +initial)) &&
                rcssNum.exec(jQuery.css(elem, prop))

            if (initialInUnit && initialInUnit[3] !== unit) {
              // Support: Firefox <=54
              // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
              initial = initial / 2

              // Trust units reported by jQuery.css
              unit = unit || initialInUnit[3]

              // Iteratively approximate from a nonzero starting point
              initialInUnit = +initial || 1

              while (maxIterations--) {
                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit)
                if (
                  (1 - scale) *
                    (1 - (scale = currentValue() / initial || 0.5)) <=
                  0
                ) {
                  maxIterations = 0
                }
                initialInUnit = initialInUnit / scale
              }

              initialInUnit = initialInUnit * 2
              jQuery.style(elem, prop, initialInUnit + unit)

              // Make sure we update the tween properties later on
              valueParts = valueParts || []
            }

            if (valueParts) {
              initialInUnit = +initialInUnit || +initial || 0

              // Apply relative offset (+=/-=) if specified
              adjusted = valueParts[1]
                ? initialInUnit + (valueParts[1] + 1) * valueParts[2]
                : +valueParts[2]
              if (tween) {
                tween.unit = unit
                tween.start = initialInUnit
                tween.end = adjusted
              }
            }
            return adjusted
          }

          var defaultDisplayMap = {}

          function getDefaultDisplay(elem) {
            var temp,
              doc = elem.ownerDocument,
              nodeName = elem.nodeName,
              display = defaultDisplayMap[nodeName]

            if (display) {
              return display
            }

            temp = doc.body.appendChild(doc.createElement(nodeName))
            display = jQuery.css(temp, 'display')

            temp.parentNode.removeChild(temp)

            if (display === 'none') {
              display = 'block'
            }
            defaultDisplayMap[nodeName] = display

            return display
          }

          function showHide(elements, show) {
            var display,
              elem,
              values = [],
              index = 0,
              length = elements.length

            // Determine new display value for elements that need to change
            for (; index < length; index++) {
              elem = elements[index]
              if (!elem.style) {
                continue
              }

              display = elem.style.display
              if (show) {
                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === 'none') {
                  values[index] = dataPriv.get(elem, 'display') || null
                  if (!values[index]) {
                    elem.style.display = ''
                  }
                }
                if (elem.style.display === '' && isHiddenWithinTree(elem)) {
                  values[index] = getDefaultDisplay(elem)
                }
              } else {
                if (display !== 'none') {
                  values[index] = 'none'

                  // Remember what we're overwriting
                  dataPriv.set(elem, 'display', display)
                }
              }
            }

            // Set the display of the elements in a second loop to avoid constant reflow
            for (index = 0; index < length; index++) {
              if (values[index] != null) {
                elements[index].style.display = values[index]
              }
            }

            return elements
          }

          jQuery.fn.extend({
            show: function () {
              return showHide(this, true)
            },
            hide: function () {
              return showHide(this)
            },
            toggle: function (state) {
              if (typeof state === 'boolean') {
                return state ? this.show() : this.hide()
              }

              return this.each(function () {
                if (isHiddenWithinTree(this)) {
                  jQuery(this).show()
                } else {
                  jQuery(this).hide()
                }
              })
            }
          })
          var rcheckableType = /^(?:checkbox|radio)$/i

          var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i

          var rscriptType = /^$|^module$|\/(?:java|ecma)script/i

          ;(function () {
            var fragment = document.createDocumentFragment(),
              div = fragment.appendChild(document.createElement('div')),
              input = document.createElement('input')

            // Support: Android 4.0 - 4.3 only
            // Check state lost if the name is set (#11217)
            // Support: Windows Web Apps (WWA)
            // `name` and `type` must use .setAttribute for WWA (#14901)
            input.setAttribute('type', 'radio')
            input.setAttribute('checked', 'checked')
            input.setAttribute('name', 't')

            div.appendChild(input)

            // Support: Android <=4.1 only
            // Older WebKit doesn't clone checked state correctly in fragments
            support.checkClone = div
              .cloneNode(true)
              .cloneNode(true).lastChild.checked

            // Support: IE <=11 only
            // Make sure textarea (and checkbox) defaultValue is properly cloned
            div.innerHTML = '<textarea>x</textarea>'
            support.noCloneChecked =
              !!div.cloneNode(true).lastChild.defaultValue

            // Support: IE <=9 only
            // IE <=9 replaces <option> tags with their contents when inserted outside of
            // the select element.
            div.innerHTML = '<option></option>'
            support.option = !!div.lastChild
          })()

          // We have to close these tags to support XHTML (#13200)
          var wrapMap = {
            // XHTML parsers do not magically insert elements in the
            // same way that tag soup parsers do. So we cannot shorten
            // this by omitting <tbody> or other required elements.
            thead: [1, '<table>', '</table>'],
            col: [2, '<table><colgroup>', '</colgroup></table>'],
            tr: [2, '<table><tbody>', '</tbody></table>'],
            td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],

            _default: [0, '', '']
          }

          wrapMap.tbody =
            wrapMap.tfoot =
            wrapMap.colgroup =
            wrapMap.caption =
              wrapMap.thead
          wrapMap.th = wrapMap.td

          // Support: IE <=9 only
          if (!support.option) {
            wrapMap.optgroup = wrapMap.option = [
              1,
              "<select multiple='multiple'>",
              '</select>'
            ]
          }

          function getAll(context, tag) {
            // Support: IE <=9 - 11 only
            // Use typeof to avoid zero-argument method invocation on host objects (#15151)
            var ret

            if (typeof context.getElementsByTagName !== 'undefined') {
              ret = context.getElementsByTagName(tag || '*')
            } else if (typeof context.querySelectorAll !== 'undefined') {
              ret = context.querySelectorAll(tag || '*')
            } else {
              ret = []
            }

            if (tag === undefined || (tag && nodeName(context, tag))) {
              return jQuery.merge([context], ret)
            }

            return ret
          }

          // Mark scripts as having already been evaluated
          function setGlobalEval(elems, refElements) {
            var i = 0,
              l = elems.length

            for (; i < l; i++) {
              dataPriv.set(
                elems[i],
                'globalEval',
                !refElements || dataPriv.get(refElements[i], 'globalEval')
              )
            }
          }

          var rhtml = /<|&#?\w+;/

          function buildFragment(elems, context, scripts, selection, ignored) {
            var elem,
              tmp,
              tag,
              wrap,
              attached,
              j,
              fragment = context.createDocumentFragment(),
              nodes = [],
              i = 0,
              l = elems.length

            for (; i < l; i++) {
              elem = elems[i]

              if (elem || elem === 0) {
                // Add nodes directly
                if (toType(elem) === 'object') {
                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // push.apply(_, arraylike) throws on ancient WebKit
                  jQuery.merge(nodes, elem.nodeType ? [elem] : elem)

                  // Convert non-html into a text node
                } else if (!rhtml.test(elem)) {
                  nodes.push(context.createTextNode(elem))

                  // Convert html into DOM nodes
                } else {
                  tmp =
                    tmp || fragment.appendChild(context.createElement('div'))

                  // Deserialize a standard representation
                  tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase()
                  wrap = wrapMap[tag] || wrapMap._default
                  tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]

                  // Descend through wrappers to the right content
                  j = wrap[0]
                  while (j--) {
                    tmp = tmp.lastChild
                  }

                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // push.apply(_, arraylike) throws on ancient WebKit
                  jQuery.merge(nodes, tmp.childNodes)

                  // Remember the top-level container
                  tmp = fragment.firstChild

                  // Ensure the created nodes are orphaned (#12392)
                  tmp.textContent = ''
                }
              }
            }

            // Remove wrapper from fragment
            fragment.textContent = ''

            i = 0
            while ((elem = nodes[i++])) {
              // Skip elements already in the context collection (trac-4087)
              if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                  ignored.push(elem)
                }
                continue
              }

              attached = isAttached(elem)

              // Append to fragment
              tmp = getAll(fragment.appendChild(elem), 'script')

              // Preserve script evaluation history
              if (attached) {
                setGlobalEval(tmp)
              }

              // Capture executables
              if (scripts) {
                j = 0
                while ((elem = tmp[j++])) {
                  if (rscriptType.test(elem.type || '')) {
                    scripts.push(elem)
                  }
                }
              }
            }

            return fragment
          }

          var rtypenamespace = /^([^.]*)(?:\.(.+)|)/

          function returnTrue() {
            return true
          }

          function returnFalse() {
            return false
          }

          // Support: IE <=9 - 11+
          // focus() and blur() are asynchronous, except when they are no-op.
          // So expect focus to be synchronous when the element is already active,
          // and blur to be synchronous when the element is not already active.
          // (focus and blur are always synchronous in other supported browsers,
          // this just defines when we can count on it).
          function expectSync(elem, type) {
            return (elem === safeActiveElement()) === (type === 'focus')
          }

          // Support: IE <=9 only
          // Accessing document.activeElement can throw unexpectedly
          // https://bugs.jquery.com/ticket/13393
          function safeActiveElement() {
            try {
              return document.activeElement
            } catch (err) {}
          }

          function on(elem, types, selector, data, fn, one) {
            var origFn, type

            // Types can be a map of types/handlers
            if (typeof types === 'object') {
              // ( types-Object, selector, data )
              if (typeof selector !== 'string') {
                // ( types-Object, data )
                data = data || selector
                selector = undefined
              }
              for (type in types) {
                on(elem, type, selector, data, types[type], one)
              }
              return elem
            }

            if (data == null && fn == null) {
              // ( types, fn )
              fn = selector
              data = selector = undefined
            } else if (fn == null) {
              if (typeof selector === 'string') {
                // ( types, selector, fn )
                fn = data
                data = undefined
              } else {
                // ( types, data, fn )
                fn = data
                data = selector
                selector = undefined
              }
            }
            if (fn === false) {
              fn = returnFalse
            } else if (!fn) {
              return elem
            }

            if (one === 1) {
              origFn = fn
              fn = function (event) {
                // Can use an empty set, since event contains the info
                jQuery().off(event)
                return origFn.apply(this, arguments)
              }

              // Use same guid so caller can remove using origFn
              fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
            }
            return elem.each(function () {
              jQuery.event.add(this, types, fn, data, selector)
            })
          }

          /*
           * Helper functions for managing events -- not part of the public interface.
           * Props to Dean Edwards' addEvent library for many of the ideas.
           */
          jQuery.event = {
            global: {},

            add: function (elem, types, handler, data, selector) {
              var handleObjIn,
                eventHandle,
                tmp,
                events,
                t,
                handleObj,
                special,
                handlers,
                type,
                namespaces,
                origType,
                elemData = dataPriv.get(elem)

              // Only attach events to objects that accept data
              if (!acceptData(elem)) {
                return
              }

              // Caller can pass in an object of custom data in lieu of the handler
              if (handler.handler) {
                handleObjIn = handler
                handler = handleObjIn.handler
                selector = handleObjIn.selector
              }

              // Ensure that invalid selectors throw exceptions at attach time
              // Evaluate against documentElement in case elem is a non-element node (e.g., document)
              if (selector) {
                jQuery.find.matchesSelector(documentElement, selector)
              }

              // Make sure that the handler has a unique ID, used to find/remove it later
              if (!handler.guid) {
                handler.guid = jQuery.guid++
              }

              // Init the element's event structure and main handler, if this is the first
              if (!(events = elemData.events)) {
                events = elemData.events = Object.create(null)
              }
              if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                  // Discard the second event of a jQuery.event.trigger() and
                  // when an event is called after a page has unloaded
                  return typeof jQuery !== 'undefined' &&
                    jQuery.event.triggered !== e.type
                    ? jQuery.event.dispatch.apply(elem, arguments)
                    : undefined
                }
              }

              // Handle multiple events separated by a space
              types = (types || '').match(rnothtmlwhite) || ['']
              t = types.length
              while (t--) {
                tmp = rtypenamespace.exec(types[t]) || []
                type = origType = tmp[1]
                namespaces = (tmp[2] || '').split('.').sort()

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                  continue
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {}

                // If selector defined, determine special event api type, otherwise given type
                type =
                  (selector ? special.delegateType : special.bindType) || type

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {}

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend(
                  {
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext:
                      selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                  },
                  handleObjIn
                )

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                  handlers = events[type] = []
                  handlers.delegateCount = 0

                  // Only use addEventListener if the special events handler returns false
                  if (
                    !special.setup ||
                    special.setup.call(elem, data, namespaces, eventHandle) ===
                      false
                  ) {
                    if (elem.addEventListener) {
                      elem.addEventListener(type, eventHandle)
                    }
                  }
                }

                if (special.add) {
                  special.add.call(elem, handleObj)

                  if (!handleObj.handler.guid) {
                    handleObj.handler.guid = handler.guid
                  }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                  handlers.splice(handlers.delegateCount++, 0, handleObj)
                } else {
                  handlers.push(handleObj)
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true
              }
            },

            // Detach an event or set of events from an element
            remove: function (elem, types, handler, selector, mappedTypes) {
              var j,
                origCount,
                tmp,
                events,
                t,
                handleObj,
                special,
                handlers,
                type,
                namespaces,
                origType,
                elemData = dataPriv.hasData(elem) && dataPriv.get(elem)

              if (!elemData || !(events = elemData.events)) {
                return
              }

              // Once for each type.namespace in types; type may be omitted
              types = (types || '').match(rnothtmlwhite) || ['']
              t = types.length
              while (t--) {
                tmp = rtypenamespace.exec(types[t]) || []
                type = origType = tmp[1]
                namespaces = (tmp[2] || '').split('.').sort()

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                  for (type in events) {
                    jQuery.event.remove(
                      elem,
                      type + types[t],
                      handler,
                      selector,
                      true
                    )
                  }
                  continue
                }

                special = jQuery.event.special[type] || {}
                type =
                  (selector ? special.delegateType : special.bindType) || type
                handlers = events[type] || []
                tmp =
                  tmp[2] &&
                  new RegExp(
                    '(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)'
                  )

                // Remove matching events
                origCount = j = handlers.length
                while (j--) {
                  handleObj = handlers[j]

                  if (
                    (mappedTypes || origType === handleObj.origType) &&
                    (!handler || handler.guid === handleObj.guid) &&
                    (!tmp || tmp.test(handleObj.namespace)) &&
                    (!selector ||
                      selector === handleObj.selector ||
                      (selector === '**' && handleObj.selector))
                  ) {
                    handlers.splice(j, 1)

                    if (handleObj.selector) {
                      handlers.delegateCount--
                    }
                    if (special.remove) {
                      special.remove.call(elem, handleObj)
                    }
                  }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                  if (
                    !special.teardown ||
                    special.teardown.call(elem, namespaces, elemData.handle) ===
                      false
                  ) {
                    jQuery.removeEvent(elem, type, elemData.handle)
                  }

                  delete events[type]
                }
              }

              // Remove data and the expando if it's no longer used
              if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, 'handle events')
              }
            },

            dispatch: function (nativeEvent) {
              var i,
                j,
                ret,
                matched,
                handleObj,
                handlerQueue,
                args = new Array(arguments.length),
                // Make a writable jQuery.Event from the native event object
                event = jQuery.event.fix(nativeEvent),
                handlers =
                  (dataPriv.get(this, 'events') || Object.create(null))[
                    event.type
                  ] || [],
                special = jQuery.event.special[event.type] || {}

              // Use the fix-ed jQuery.Event rather than the (read-only) native event
              args[0] = event

              for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i]
              }

              event.delegateTarget = this

              // Call the preDispatch hook for the mapped type, and let it bail if desired
              if (
                special.preDispatch &&
                special.preDispatch.call(this, event) === false
              ) {
                return
              }

              // Determine handlers
              handlerQueue = jQuery.event.handlers.call(this, event, handlers)

              // Run delegates first; they may want to stop propagation beneath us
              i = 0
              while (
                (matched = handlerQueue[i++]) &&
                !event.isPropagationStopped()
              ) {
                event.currentTarget = matched.elem

                j = 0
                while (
                  (handleObj = matched.handlers[j++]) &&
                  !event.isImmediatePropagationStopped()
                ) {
                  // If the event is namespaced, then each handler is only invoked if it is
                  // specially universal or its namespaces are a superset of the event's.
                  if (
                    !event.rnamespace ||
                    handleObj.namespace === false ||
                    event.rnamespace.test(handleObj.namespace)
                  ) {
                    event.handleObj = handleObj
                    event.data = handleObj.data

                    ret = (
                      (jQuery.event.special[handleObj.origType] || {}).handle ||
                      handleObj.handler
                    ).apply(matched.elem, args)

                    if (ret !== undefined) {
                      if ((event.result = ret) === false) {
                        event.preventDefault()
                        event.stopPropagation()
                      }
                    }
                  }
                }
              }

              // Call the postDispatch hook for the mapped type
              if (special.postDispatch) {
                special.postDispatch.call(this, event)
              }

              return event.result
            },

            handlers: function (event, handlers) {
              var i,
                handleObj,
                sel,
                matchedHandlers,
                matchedSelectors,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target

              // Find delegate handlers
              if (
                delegateCount &&
                // Support: IE <=9
                // Black-hole SVG <use> instance trees (trac-13180)
                cur.nodeType &&
                // Support: Firefox <=42
                // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                // Support: IE 11 only
                // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                !(event.type === 'click' && event.button >= 1)
              ) {
                for (; cur !== this; cur = cur.parentNode || this) {
                  // Don't check non-elements (#13208)
                  // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                  if (
                    cur.nodeType === 1 &&
                    !(event.type === 'click' && cur.disabled === true)
                  ) {
                    matchedHandlers = []
                    matchedSelectors = {}
                    for (i = 0; i < delegateCount; i++) {
                      handleObj = handlers[i]

                      // Don't conflict with Object.prototype properties (#13203)
                      sel = handleObj.selector + ' '

                      if (matchedSelectors[sel] === undefined) {
                        matchedSelectors[sel] = handleObj.needsContext
                          ? jQuery(sel, this).index(cur) > -1
                          : jQuery.find(sel, this, null, [cur]).length
                      }
                      if (matchedSelectors[sel]) {
                        matchedHandlers.push(handleObj)
                      }
                    }
                    if (matchedHandlers.length) {
                      handlerQueue.push({
                        elem: cur,
                        handlers: matchedHandlers
                      })
                    }
                  }
                }
              }

              // Add the remaining (directly-bound) handlers
              cur = this
              if (delegateCount < handlers.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: handlers.slice(delegateCount)
                })
              }

              return handlerQueue
            },

            addProp: function (name, hook) {
              Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,

                get: isFunction(hook)
                  ? function () {
                      if (this.originalEvent) {
                        return hook(this.originalEvent)
                      }
                    }
                  : function () {
                      if (this.originalEvent) {
                        return this.originalEvent[name]
                      }
                    },

                set: function (value) {
                  Object.defineProperty(this, name, {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: value
                  })
                }
              })
            },

            fix: function (originalEvent) {
              return originalEvent[jQuery.expando]
                ? originalEvent
                : new jQuery.Event(originalEvent)
            },

            special: {
              load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
              },
              click: {
                // Utilize native event to ensure correct state for checkable inputs
                setup: function (data) {
                  // For mutual compressibility with _default, replace `this` access with a local var.
                  // `|| data` is dead code meant only to preserve the variable through minification.
                  var el = this || data

                  // Claim the first handler
                  if (
                    rcheckableType.test(el.type) &&
                    el.click &&
                    nodeName(el, 'input')
                  ) {
                    // dataPriv.set( el, "click", ... )
                    leverageNative(el, 'click', returnTrue)
                  }

                  // Return false to allow normal processing in the caller
                  return false
                },
                trigger: function (data) {
                  // For mutual compressibility with _default, replace `this` access with a local var.
                  // `|| data` is dead code meant only to preserve the variable through minification.
                  var el = this || data

                  // Force setup before triggering a click
                  if (
                    rcheckableType.test(el.type) &&
                    el.click &&
                    nodeName(el, 'input')
                  ) {
                    leverageNative(el, 'click')
                  }

                  // Return non-false to allow normal event-path propagation
                  return true
                },

                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function (event) {
                  var target = event.target
                  return (
                    (rcheckableType.test(target.type) &&
                      target.click &&
                      nodeName(target, 'input') &&
                      dataPriv.get(target, 'click')) ||
                    nodeName(target, 'a')
                  )
                }
              },

              beforeunload: {
                postDispatch: function (event) {
                  // Support: Firefox 20+
                  // Firefox doesn't alert if the returnValue field is not set.
                  if (event.result !== undefined && event.originalEvent) {
                    event.originalEvent.returnValue = event.result
                  }
                }
              }
            }
          }

          // Ensure the presence of an event listener that handles manually-triggered
          // synthetic events by interrupting progress until reinvoked in response to
          // *native* events that it fires directly, ensuring that state changes have
          // already occurred before other listeners are invoked.
          function leverageNative(el, type, expectSync) {
            // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
            if (!expectSync) {
              if (dataPriv.get(el, type) === undefined) {
                jQuery.event.add(el, type, returnTrue)
              }
              return
            }

            // Register the controller as a special universal handler for all event namespaces
            dataPriv.set(el, type, false)
            jQuery.event.add(el, type, {
              namespace: false,
              handler: function (event) {
                var notAsync,
                  result,
                  saved = dataPriv.get(this, type)

                if (event.isTrigger & 1 && this[type]) {
                  // Interrupt processing of the outer synthetic .trigger()ed event
                  // Saved data should be false in such cases, but might be a leftover capture object
                  // from an async native handler (gh-4350)
                  if (!saved.length) {
                    // Store arguments for use when handling the inner native event
                    // There will always be at least one argument (an event object), so this array
                    // will not be confused with a leftover capture object.
                    saved = slice.call(arguments)
                    dataPriv.set(this, type, saved)

                    // Trigger the native event and capture its result
                    // Support: IE <=9 - 11+
                    // focus() and blur() are asynchronous
                    notAsync = expectSync(this, type)
                    this[type]()
                    result = dataPriv.get(this, type)
                    if (saved !== result || notAsync) {
                      dataPriv.set(this, type, false)
                    } else {
                      result = {}
                    }
                    if (saved !== result) {
                      // Cancel the outer synthetic event
                      event.stopImmediatePropagation()
                      event.preventDefault()

                      // Support: Chrome 86+
                      // In Chrome, if an element having a focusout handler is blurred by
                      // clicking outside of it, it invokes the handler synchronously. If
                      // that handler calls `.remove()` on the element, the data is cleared,
                      // leaving `result` undefined. We need to guard against this.
                      return result && result.value
                    }

                    // If this is an inner synthetic event for an event with a bubbling surrogate
                    // (focus or blur), assume that the surrogate already propagated from triggering the
                    // native event and prevent that from happening again here.
                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                    // less bad than duplication.
                  } else if ((jQuery.event.special[type] || {}).delegateType) {
                    event.stopPropagation()
                  }

                  // If this is a native event triggered above, everything is now in order
                  // Fire an inner synthetic event with the original arguments
                } else if (saved.length) {
                  // ...and capture the result
                  dataPriv.set(this, type, {
                    value: jQuery.event.trigger(
                      // Support: IE <=9 - 11+
                      // Extend with the prototype to reset the above stopImmediatePropagation()
                      jQuery.extend(saved[0], jQuery.Event.prototype),
                      saved.slice(1),
                      this
                    )
                  })

                  // Abort handling of the native event
                  event.stopImmediatePropagation()
                }
              }
            })
          }

          jQuery.removeEvent = function (elem, type, handle) {
            // This "if" is needed for plain objects
            if (elem.removeEventListener) {
              elem.removeEventListener(type, handle)
            }
          }

          jQuery.Event = function (src, props) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof jQuery.Event)) {
              return new jQuery.Event(src, props)
            }

            // Event object
            if (src && src.type) {
              this.originalEvent = src
              this.type = src.type

              // Events bubbling up the document may have been marked as prevented
              // by a handler lower down the tree; reflect the correct value.
              this.isDefaultPrevented =
                src.defaultPrevented ||
                (src.defaultPrevented === undefined &&
                  // Support: Android <=2.3 only
                  src.returnValue === false)
                  ? returnTrue
                  : returnFalse

              // Create target properties
              // Support: Safari <=6 - 7 only
              // Target should not be a text node (#504, #13143)
              this.target =
                src.target && src.target.nodeType === 3
                  ? src.target.parentNode
                  : src.target

              this.currentTarget = src.currentTarget
              this.relatedTarget = src.relatedTarget

              // Event type
            } else {
              this.type = src
            }

            // Put explicitly provided properties onto the event object
            if (props) {
              jQuery.extend(this, props)
            }

            // Create a timestamp if incoming event doesn't have one
            this.timeStamp = (src && src.timeStamp) || Date.now()

            // Mark it as fixed
            this[jQuery.expando] = true
          }

          // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
          // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
          jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: false,

            preventDefault: function () {
              var e = this.originalEvent

              this.isDefaultPrevented = returnTrue

              if (e && !this.isSimulated) {
                e.preventDefault()
              }
            },
            stopPropagation: function () {
              var e = this.originalEvent

              this.isPropagationStopped = returnTrue

              if (e && !this.isSimulated) {
                e.stopPropagation()
              }
            },
            stopImmediatePropagation: function () {
              var e = this.originalEvent

              this.isImmediatePropagationStopped = returnTrue

              if (e && !this.isSimulated) {
                e.stopImmediatePropagation()
              }

              this.stopPropagation()
            }
          }

          // Includes all common event props including KeyEvent and MouseEvent specific props
          jQuery.each(
            {
              altKey: true,
              bubbles: true,
              cancelable: true,
              changedTouches: true,
              ctrlKey: true,
              detail: true,
              eventPhase: true,
              metaKey: true,
              pageX: true,
              pageY: true,
              shiftKey: true,
              view: true,
              char: true,
              code: true,
              charCode: true,
              key: true,
              keyCode: true,
              button: true,
              buttons: true,
              clientX: true,
              clientY: true,
              offsetX: true,
              offsetY: true,
              pointerId: true,
              pointerType: true,
              screenX: true,
              screenY: true,
              targetTouches: true,
              toElement: true,
              touches: true,
              which: true
            },
            jQuery.event.addProp
          )

          jQuery.each(
            { focus: 'focusin', blur: 'focusout' },
            function (type, delegateType) {
              jQuery.event.special[type] = {
                // Utilize native event if possible so blur/focus sequence is correct
                setup: function () {
                  // Claim the first handler
                  // dataPriv.set( this, "focus", ... )
                  // dataPriv.set( this, "blur", ... )
                  leverageNative(this, type, expectSync)

                  // Return false to allow normal processing in the caller
                  return false
                },
                trigger: function () {
                  // Force setup before trigger
                  leverageNative(this, type)

                  // Return non-false to allow normal event-path propagation
                  return true
                },

                // Suppress native focus or blur as it's already being fired
                // in leverageNative.
                _default: function () {
                  return true
                },

                delegateType: delegateType
              }
            }
          )

          // Create mouseenter/leave events using mouseover/out and event-time checks
          // so that event delegation works in jQuery.
          // Do the same for pointerenter/pointerleave and pointerover/pointerout
          //
          // Support: Safari 7 only
          // Safari sends mouseenter too often; see:
          // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
          // for the description of the bug (it existed in older Chrome versions as well).
          jQuery.each(
            {
              mouseenter: 'mouseover',
              mouseleave: 'mouseout',
              pointerenter: 'pointerover',
              pointerleave: 'pointerout'
            },
            function (orig, fix) {
              jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,

                handle: function (event) {
                  var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj

                  // For mouseenter/leave call the handler if related is outside the target.
                  // NB: No relatedTarget if the mouse left/entered the browser window
                  if (
                    !related ||
                    (related !== target && !jQuery.contains(target, related))
                  ) {
                    event.type = handleObj.origType
                    ret = handleObj.handler.apply(this, arguments)
                    event.type = fix
                  }
                  return ret
                }
              }
            }
          )

          jQuery.fn.extend({
            on: function (types, selector, data, fn) {
              return on(this, types, selector, data, fn)
            },
            one: function (types, selector, data, fn) {
              return on(this, types, selector, data, fn, 1)
            },
            off: function (types, selector, fn) {
              var handleObj, type
              if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj
                jQuery(types.delegateTarget).off(
                  handleObj.namespace
                    ? handleObj.origType + '.' + handleObj.namespace
                    : handleObj.origType,
                  handleObj.selector,
                  handleObj.handler
                )
                return this
              }
              if (typeof types === 'object') {
                // ( types-object [, selector] )
                for (type in types) {
                  this.off(type, selector, types[type])
                }
                return this
              }
              if (selector === false || typeof selector === 'function') {
                // ( types [, fn] )
                fn = selector
                selector = undefined
              }
              if (fn === false) {
                fn = returnFalse
              }
              return this.each(function () {
                jQuery.event.remove(this, types, fn, selector)
              })
            }
          })

          var // Support: IE <=10 - 11, Edge 12 - 13 only
            // In IE/Edge using regex groups here causes severe slowdowns.
            // See https://connect.microsoft.com/IE/feedback/details/1736512/
            rnoInnerhtml = /<script|<style|<link/i,
            // checked="checked" or checked
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g

          // Prefer a tbody over its parent table for containing new rows
          function manipulationTarget(elem, content) {
            if (
              nodeName(elem, 'table') &&
              nodeName(
                content.nodeType !== 11 ? content : content.firstChild,
                'tr'
              )
            ) {
              return jQuery(elem).children('tbody')[0] || elem
            }

            return elem
          }

          // Replace/restore the type attribute of script elements for safe DOM manipulation
          function disableScript(elem) {
            elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type
            return elem
          }
          function restoreScript(elem) {
            if ((elem.type || '').slice(0, 5) === 'true/') {
              elem.type = elem.type.slice(5)
            } else {
              elem.removeAttribute('type')
            }

            return elem
          }

          function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, udataOld, udataCur, events

            if (dest.nodeType !== 1) {
              return
            }

            // 1. Copy private data: events, handlers, etc.
            if (dataPriv.hasData(src)) {
              pdataOld = dataPriv.get(src)
              events = pdataOld.events

              if (events) {
                dataPriv.remove(dest, 'handle events')

                for (type in events) {
                  for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i])
                  }
                }
              }
            }

            // 2. Copy user data
            if (dataUser.hasData(src)) {
              udataOld = dataUser.access(src)
              udataCur = jQuery.extend({}, udataOld)

              dataUser.set(dest, udataCur)
            }
          }

          // Fix IE bugs, see support tests
          function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase()

            // Fails to persist the checked state of a cloned checkbox or radio button.
            if (nodeName === 'input' && rcheckableType.test(src.type)) {
              dest.checked = src.checked

              // Fails to return the selected option to the default selected state when cloning options
            } else if (nodeName === 'input' || nodeName === 'textarea') {
              dest.defaultValue = src.defaultValue
            }
          }

          function domManip(collection, args, callback, ignored) {
            // Flatten any nested arrays
            args = flat(args)

            var fragment,
              first,
              scripts,
              hasScripts,
              node,
              doc,
              i = 0,
              l = collection.length,
              iNoClone = l - 1,
              value = args[0],
              valueIsFunction = isFunction(value)

            // We can't cloneNode fragments that contain checked, in WebKit
            if (
              valueIsFunction ||
              (l > 1 &&
                typeof value === 'string' &&
                !support.checkClone &&
                rchecked.test(value))
            ) {
              return collection.each(function (index) {
                var self = collection.eq(index)
                if (valueIsFunction) {
                  args[0] = value.call(this, index, self.html())
                }
                domManip(self, args, callback, ignored)
              })
            }

            if (l) {
              fragment = buildFragment(
                args,
                collection[0].ownerDocument,
                false,
                collection,
                ignored
              )
              first = fragment.firstChild

              if (fragment.childNodes.length === 1) {
                fragment = first
              }

              // Require either new content or an interest in ignored elements to invoke the callback
              if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, 'script'), disableScript)
                hasScripts = scripts.length

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for (; i < l; i++) {
                  node = fragment

                  if (i !== iNoClone) {
                    node = jQuery.clone(node, true, true)

                    // Keep references to cloned scripts for later restoration
                    if (hasScripts) {
                      // Support: Android <=4.0 only, PhantomJS 1 only
                      // push.apply(_, arraylike) throws on ancient WebKit
                      jQuery.merge(scripts, getAll(node, 'script'))
                    }
                  }

                  callback.call(collection[i], node, i)
                }

                if (hasScripts) {
                  doc = scripts[scripts.length - 1].ownerDocument

                  // Reenable scripts
                  jQuery.map(scripts, restoreScript)

                  // Evaluate executable scripts on first document insertion
                  for (i = 0; i < hasScripts; i++) {
                    node = scripts[i]
                    if (
                      rscriptType.test(node.type || '') &&
                      !dataPriv.access(node, 'globalEval') &&
                      jQuery.contains(doc, node)
                    ) {
                      if (
                        node.src &&
                        (node.type || '').toLowerCase() !== 'module'
                      ) {
                        // Optional AJAX dependency, but won't run scripts if not present
                        if (jQuery._evalUrl && !node.noModule) {
                          jQuery._evalUrl(
                            node.src,
                            {
                              nonce: node.nonce || node.getAttribute('nonce')
                            },
                            doc
                          )
                        }
                      } else {
                        DOMEval(
                          node.textContent.replace(rcleanScript, ''),
                          node,
                          doc
                        )
                      }
                    }
                  }
                }
              }
            }

            return collection
          }

          function remove(elem, selector, keepData) {
            var node,
              nodes = selector ? jQuery.filter(selector, elem) : elem,
              i = 0

            for (; (node = nodes[i]) != null; i++) {
              if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node))
              }

              if (node.parentNode) {
                if (keepData && isAttached(node)) {
                  setGlobalEval(getAll(node, 'script'))
                }
                node.parentNode.removeChild(node)
              }
            }

            return elem
          }

          jQuery.extend({
            htmlPrefilter: function (html) {
              return html
            },

            clone: function (elem, dataAndEvents, deepDataAndEvents) {
              var i,
                l,
                srcElements,
                destElements,
                clone = elem.cloneNode(true),
                inPage = isAttached(elem)

              // Fix IE cloning issues
              if (
                !support.noCloneChecked &&
                (elem.nodeType === 1 || elem.nodeType === 11) &&
                !jQuery.isXMLDoc(elem)
              ) {
                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone)
                srcElements = getAll(elem)

                for (i = 0, l = srcElements.length; i < l; i++) {
                  fixInput(srcElements[i], destElements[i])
                }
              }

              // Copy the events from the original to the clone
              if (dataAndEvents) {
                if (deepDataAndEvents) {
                  srcElements = srcElements || getAll(elem)
                  destElements = destElements || getAll(clone)

                  for (i = 0, l = srcElements.length; i < l; i++) {
                    cloneCopyEvent(srcElements[i], destElements[i])
                  }
                } else {
                  cloneCopyEvent(elem, clone)
                }
              }

              // Preserve script evaluation history
              destElements = getAll(clone, 'script')
              if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'))
              }

              // Return the cloned set
              return clone
            },

            cleanData: function (elems) {
              var data,
                elem,
                type,
                special = jQuery.event.special,
                i = 0

              for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                  if ((data = elem[dataPriv.expando])) {
                    if (data.events) {
                      for (type in data.events) {
                        if (special[type]) {
                          jQuery.event.remove(elem, type)

                          // This is a shortcut to avoid jQuery.event.remove's overhead
                        } else {
                          jQuery.removeEvent(elem, type, data.handle)
                        }
                      }
                    }

                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataPriv.expando] = undefined
                  }
                  if (elem[dataUser.expando]) {
                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataUser.expando] = undefined
                  }
                }
              }
            }
          })

          jQuery.fn.extend({
            detach: function (selector) {
              return remove(this, selector, true)
            },

            remove: function (selector) {
              return remove(this, selector)
            },

            text: function (value) {
              return access(
                this,
                function (value) {
                  return value === undefined
                    ? jQuery.text(this)
                    : this.empty().each(function () {
                        if (
                          this.nodeType === 1 ||
                          this.nodeType === 11 ||
                          this.nodeType === 9
                        ) {
                          this.textContent = value
                        }
                      })
                },
                null,
                value,
                arguments.length
              )
            },

            append: function () {
              return domManip(this, arguments, function (elem) {
                if (
                  this.nodeType === 1 ||
                  this.nodeType === 11 ||
                  this.nodeType === 9
                ) {
                  var target = manipulationTarget(this, elem)
                  target.appendChild(elem)
                }
              })
            },

            prepend: function () {
              return domManip(this, arguments, function (elem) {
                if (
                  this.nodeType === 1 ||
                  this.nodeType === 11 ||
                  this.nodeType === 9
                ) {
                  var target = manipulationTarget(this, elem)
                  target.insertBefore(elem, target.firstChild)
                }
              })
            },

            before: function () {
              return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this)
                }
              })
            },

            after: function () {
              return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this.nextSibling)
                }
              })
            },

            empty: function () {
              var elem,
                i = 0

              for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                  // Prevent memory leaks
                  jQuery.cleanData(getAll(elem, false))

                  // Remove any remaining nodes
                  elem.textContent = ''
                }
              }

              return this
            },

            clone: function (dataAndEvents, deepDataAndEvents) {
              dataAndEvents = dataAndEvents == null ? false : dataAndEvents
              deepDataAndEvents =
                deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents

              return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
              })
            },

            html: function (value) {
              return access(
                this,
                function (value) {
                  var elem = this[0] || {},
                    i = 0,
                    l = this.length

                  if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML
                  }

                  // See if we can take a shortcut and just use innerHTML
                  if (
                    typeof value === 'string' &&
                    !rnoInnerhtml.test(value) &&
                    !wrapMap[
                      (rtagName.exec(value) || ['', ''])[1].toLowerCase()
                    ]
                  ) {
                    value = jQuery.htmlPrefilter(value)

                    try {
                      for (; i < l; i++) {
                        elem = this[i] || {}

                        // Remove element nodes and prevent memory leaks
                        if (elem.nodeType === 1) {
                          jQuery.cleanData(getAll(elem, false))
                          elem.innerHTML = value
                        }
                      }

                      elem = 0

                      // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                  }

                  if (elem) {
                    this.empty().append(value)
                  }
                },
                null,
                value,
                arguments.length
              )
            },

            replaceWith: function () {
              var ignored = []

              // Make the changes, replacing each non-ignored context element with the new content
              return domManip(
                this,
                arguments,
                function (elem) {
                  var parent = this.parentNode

                  if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this))
                    if (parent) {
                      parent.replaceChild(elem, this)
                    }
                  }

                  // Force callback invocation
                },
                ignored
              )
            }
          })

          jQuery.each(
            {
              appendTo: 'append',
              prependTo: 'prepend',
              insertBefore: 'before',
              insertAfter: 'after',
              replaceAll: 'replaceWith'
            },
            function (name, original) {
              jQuery.fn[name] = function (selector) {
                var elems,
                  ret = [],
                  insert = jQuery(selector),
                  last = insert.length - 1,
                  i = 0

                for (; i <= last; i++) {
                  elems = i === last ? this : this.clone(true)
                  jQuery(insert[i])[original](elems)

                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // .get() because push.apply(_, arraylike) throws on ancient WebKit
                  push.apply(ret, elems.get())
                }

                return this.pushStack(ret)
              }
            }
          )
          var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i')

          var getStyles = function (elem) {
            // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
            // IE throws on elements created in popups
            // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
            var view = elem.ownerDocument.defaultView

            if (!view || !view.opener) {
              view = window
            }

            return view.getComputedStyle(elem)
          }

          var swap = function (elem, options, callback) {
            var ret,
              name,
              old = {}

            // Remember the old values, and insert the new ones
            for (name in options) {
              old[name] = elem.style[name]
              elem.style[name] = options[name]
            }

            ret = callback.call(elem)

            // Revert the old values
            for (name in options) {
              elem.style[name] = old[name]
            }

            return ret
          }

          var rboxStyle = new RegExp(cssExpand.join('|'), 'i')

          ;(function () {
            // Executing both pixelPosition & boxSizingReliable tests require only one layout
            // so they're executed at the same time to save the second computation.
            function computeStyleTests() {
              // This is a singleton, we need to execute it only once
              if (!div) {
                return
              }

              container.style.cssText =
                'position:absolute;left:-11111px;width:60px;' +
                'margin-top:1px;padding:0;border:0'
              div.style.cssText =
                'position:relative;display:block;box-sizing:border-box;overflow:scroll;' +
                'margin:auto;border:1px;padding:1px;' +
                'width:60%;top:1%'
              documentElement.appendChild(container).appendChild(div)

              var divStyle = window.getComputedStyle(div)
              pixelPositionVal = divStyle.top !== '1%'

              // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
              reliableMarginLeftVal =
                roundPixelMeasures(divStyle.marginLeft) === 12

              // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
              // Some styles come back with percentage values, even though they shouldn't
              div.style.right = '60%'
              pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36

              // Support: IE 9 - 11 only
              // Detect misreporting of content dimensions for box-sizing:border-box elements
              boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36

              // Support: IE 9 only
              // Detect overflow:scroll screwiness (gh-3699)
              // Support: Chrome <=64
              // Don't get tricked when zoom affects offsetWidth (gh-4029)
              div.style.position = 'absolute'
              scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12

              documentElement.removeChild(container)

              // Nullify the div so it wouldn't be stored in the memory and
              // it will also be a sign that checks already performed
              div = null
            }

            function roundPixelMeasures(measure) {
              return Math.round(parseFloat(measure))
            }

            var pixelPositionVal,
              boxSizingReliableVal,
              scrollboxSizeVal,
              pixelBoxStylesVal,
              reliableTrDimensionsVal,
              reliableMarginLeftVal,
              container = document.createElement('div'),
              div = document.createElement('div')

            // Finish early in limited (non-browser) environments
            if (!div.style) {
              return
            }

            // Support: IE <=9 - 11 only
            // Style of cloned element affects source element cloned (#8908)
            div.style.backgroundClip = 'content-box'
            div.cloneNode(true).style.backgroundClip = ''
            support.clearCloneStyle = div.style.backgroundClip === 'content-box'

            jQuery.extend(support, {
              boxSizingReliable: function () {
                computeStyleTests()
                return boxSizingReliableVal
              },
              pixelBoxStyles: function () {
                computeStyleTests()
                return pixelBoxStylesVal
              },
              pixelPosition: function () {
                computeStyleTests()
                return pixelPositionVal
              },
              reliableMarginLeft: function () {
                computeStyleTests()
                return reliableMarginLeftVal
              },
              scrollboxSize: function () {
                computeStyleTests()
                return scrollboxSizeVal
              },

              // Support: IE 9 - 11+, Edge 15 - 18+
              // IE/Edge misreport `getComputedStyle` of table rows with width/height
              // set in CSS while `offset*` properties report correct values.
              // Behavior in IE 9 is more subtle than in newer versions & it passes
              // some versions of this test; make sure not to make it pass there!
              //
              // Support: Firefox 70+
              // Only Firefox includes border widths
              // in computed dimensions. (gh-4529)
              reliableTrDimensions: function () {
                var table, tr, trChild, trStyle
                if (reliableTrDimensionsVal == null) {
                  table = document.createElement('table')
                  tr = document.createElement('tr')
                  trChild = document.createElement('div')

                  table.style.cssText =
                    'position:absolute;left:-11111px;border-collapse:separate'
                  tr.style.cssText = 'border:1px solid'

                  // Support: Chrome 86+
                  // Height set through cssText does not get applied.
                  // Computed height then comes back as 0.
                  tr.style.height = '1px'
                  trChild.style.height = '9px'

                  // Support: Android 8 Chrome 86+
                  // In our bodyBackground.html iframe,
                  // display for all div elements is set to "inline",
                  // which causes a problem only in Android 8 Chrome 86.
                  // Ensuring the div is display: block
                  // gets around this issue.
                  trChild.style.display = 'block'

                  documentElement
                    .appendChild(table)
                    .appendChild(tr)
                    .appendChild(trChild)

                  trStyle = window.getComputedStyle(tr)
                  reliableTrDimensionsVal =
                    parseInt(trStyle.height, 10) +
                      parseInt(trStyle.borderTopWidth, 10) +
                      parseInt(trStyle.borderBottomWidth, 10) ===
                    tr.offsetHeight

                  documentElement.removeChild(table)
                }
                return reliableTrDimensionsVal
              }
            })
          })()

          function curCSS(elem, name, computed) {
            var width,
              minWidth,
              maxWidth,
              ret,
              // Support: Firefox 51+
              // Retrieving style before computed somehow
              // fixes an issue with getting wrong values
              // on detached elements
              style = elem.style

            computed = computed || getStyles(elem)

            // getPropertyValue is needed for:
            //   .css('filter') (IE 9 only, #12537)
            //   .css('--customProperty) (#3144)
            if (computed) {
              ret = computed.getPropertyValue(name) || computed[name]

              if (ret === '' && !isAttached(elem)) {
                ret = jQuery.style(elem, name)
              }

              // A tribute to the "awesome hack by Dean Edwards"
              // Android Browser returns percentage for some values,
              // but width seems to be reliably pixels.
              // This is against the CSSOM draft spec:
              // https://drafts.csswg.org/cssom/#resolved-values
              if (
                !support.pixelBoxStyles() &&
                rnumnonpx.test(ret) &&
                rboxStyle.test(name)
              ) {
                // Remember the original values
                width = style.width
                minWidth = style.minWidth
                maxWidth = style.maxWidth

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret
                ret = computed.width

                // Revert the changed values
                style.width = width
                style.minWidth = minWidth
                style.maxWidth = maxWidth
              }
            }

            return ret !== undefined
              ? // Support: IE <=9 - 11 only
                // IE returns zIndex value as an integer.
                ret + ''
              : ret
          }

          function addGetHookIf(conditionFn, hookFn) {
            // Define the hook, we'll check on the first run if it's really needed.
            return {
              get: function () {
                if (conditionFn()) {
                  // Hook not needed (or it's not possible to use it due
                  // to missing dependency), remove it.
                  delete this.get
                  return
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments)
              }
            }
          }

          var cssPrefixes = ['Webkit', 'Moz', 'ms'],
            emptyStyle = document.createElement('div').style,
            vendorProps = {}

          // Return a vendor-prefixed property or undefined
          function vendorPropName(name) {
            // Check for vendor prefixed names
            var capName = name[0].toUpperCase() + name.slice(1),
              i = cssPrefixes.length

            while (i--) {
              name = cssPrefixes[i] + capName
              if (name in emptyStyle) {
                return name
              }
            }
          }

          // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
          function finalPropName(name) {
            var final = jQuery.cssProps[name] || vendorProps[name]

            if (final) {
              return final
            }
            if (name in emptyStyle) {
              return name
            }
            return (vendorProps[name] = vendorPropName(name) || name)
          }

          var // Swappable if display is none or starts with table
            // except "table", "table-cell", or "table-caption"
            // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
            rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            rcustomProp = /^--/,
            cssShow = {
              position: 'absolute',
              visibility: 'hidden',
              display: 'block'
            },
            cssNormalTransform = {
              letterSpacing: '0',
              fontWeight: '400'
            }

          function setPositiveNumber(_elem, value, subtract) {
            // Any relative (+/-) values have already been
            // normalized at this point
            var matches = rcssNum.exec(value)
            return matches
              ? // Guard against undefined "subtract", e.g., when used as in cssHooks
                Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px')
              : value
          }

          function boxModelAdjustment(
            elem,
            dimension,
            box,
            isBorderBox,
            styles,
            computedVal
          ) {
            var i = dimension === 'width' ? 1 : 0,
              extra = 0,
              delta = 0

            // Adjustment may not be necessary
            if (box === (isBorderBox ? 'border' : 'content')) {
              return 0
            }

            for (; i < 4; i += 2) {
              // Both box models exclude margin
              if (box === 'margin') {
                delta += jQuery.css(elem, box + cssExpand[i], true, styles)
              }

              // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
              if (!isBorderBox) {
                // Add padding
                delta += jQuery.css(
                  elem,
                  'padding' + cssExpand[i],
                  true,
                  styles
                )

                // For "border" or "margin", add border
                if (box !== 'padding') {
                  delta += jQuery.css(
                    elem,
                    'border' + cssExpand[i] + 'Width',
                    true,
                    styles
                  )

                  // But still keep track of it otherwise
                } else {
                  extra += jQuery.css(
                    elem,
                    'border' + cssExpand[i] + 'Width',
                    true,
                    styles
                  )
                }

                // If we get here with a border-box (content + padding + border), we're seeking "content" or
                // "padding" or "margin"
              } else {
                // For "content", subtract padding
                if (box === 'content') {
                  delta -= jQuery.css(
                    elem,
                    'padding' + cssExpand[i],
                    true,
                    styles
                  )
                }

                // For "content" or "padding", subtract border
                if (box !== 'margin') {
                  delta -= jQuery.css(
                    elem,
                    'border' + cssExpand[i] + 'Width',
                    true,
                    styles
                  )
                }
              }
            }

            // Account for positive content-box scroll gutter when requested by providing computedVal
            if (!isBorderBox && computedVal >= 0) {
              // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
              // Assuming integer scroll gutter, subtract the rest and round down
              delta +=
                Math.max(
                  0,
                  Math.ceil(
                    elem[
                      'offset' + dimension[0].toUpperCase() + dimension.slice(1)
                    ] -
                      computedVal -
                      delta -
                      extra -
                      0.5

                    // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                    // Use an explicit zero to avoid NaN (gh-3964)
                  )
                ) || 0
            }

            return delta
          }

          function getWidthOrHeight(elem, dimension, extra) {
            // Start with computed style
            var styles = getStyles(elem),
              // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
              // Fake content-box until we know it's needed to know the true value.
              boxSizingNeeded = !support.boxSizingReliable() || extra,
              isBorderBox =
                boxSizingNeeded &&
                jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',
              valueIsBorderBox = isBorderBox,
              val = curCSS(elem, dimension, styles),
              offsetProp =
                'offset' + dimension[0].toUpperCase() + dimension.slice(1)

            // Support: Firefox <=54
            // Return a confounding non-pixel value or feign ignorance, as appropriate.
            if (rnumnonpx.test(val)) {
              if (!extra) {
                return val
              }
              val = 'auto'
            }

            // Support: IE 9 - 11 only
            // Use offsetWidth/offsetHeight for when box sizing is unreliable.
            // In those cases, the computed value can be trusted to be border-box.
            if (
              ((!support.boxSizingReliable() && isBorderBox) ||
                // Support: IE 10 - 11+, Edge 15 - 18+
                // IE/Edge misreport `getComputedStyle` of table rows with width/height
                // set in CSS while `offset*` properties report correct values.
                // Interestingly, in some cases IE 9 doesn't suffer from this issue.
                (!support.reliableTrDimensions() && nodeName(elem, 'tr')) ||
                // Fall back to offsetWidth/offsetHeight when value is "auto"
                // This happens for inline elements with no explicit setting (gh-3571)
                val === 'auto' ||
                // Support: Android <=4.1 - 4.3 only
                // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
                (!parseFloat(val) &&
                  jQuery.css(elem, 'display', false, styles) === 'inline')) &&
              // Make sure the element is visible & connected
              elem.getClientRects().length
            ) {
              isBorderBox =
                jQuery.css(elem, 'boxSizing', false, styles) === 'border-box'

              // Where available, offsetWidth/offsetHeight approximate border box dimensions.
              // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
              // retrieved value as a content box dimension.
              valueIsBorderBox = offsetProp in elem
              if (valueIsBorderBox) {
                val = elem[offsetProp]
              }
            }

            // Normalize "" and auto
            val = parseFloat(val) || 0

            // Adjust for the element's box model
            return (
              val +
              boxModelAdjustment(
                elem,
                dimension,
                extra || (isBorderBox ? 'border' : 'content'),
                valueIsBorderBox,
                styles,

                // Provide the current computed size to request scroll gutter calculation (gh-3589)
                val
              ) +
              'px'
            )
          }

          jQuery.extend({
            // Add in style property hooks for overriding the default
            // behavior of getting and setting a style property
            cssHooks: {
              opacity: {
                get: function (elem, computed) {
                  if (computed) {
                    // We should always get a number back from opacity
                    var ret = curCSS(elem, 'opacity')
                    return ret === '' ? '1' : ret
                  }
                }
              }
            },

            // Don't automatically add "px" to these possibly-unitless properties
            cssNumber: {
              animationIterationCount: true,
              columnCount: true,
              fillOpacity: true,
              flexGrow: true,
              flexShrink: true,
              fontWeight: true,
              gridArea: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnStart: true,
              gridRow: true,
              gridRowEnd: true,
              gridRowStart: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              widows: true,
              zIndex: true,
              zoom: true
            },

            // Add in properties whose names you wish to fix before
            // setting or getting the value
            cssProps: {},

            // Get and set the style property on a DOM Node
            style: function (elem, name, value, extra) {
              // Don't set styles on text and comment nodes
              if (
                !elem ||
                elem.nodeType === 3 ||
                elem.nodeType === 8 ||
                !elem.style
              ) {
                return
              }

              // Make sure that we're working with the right name
              var ret,
                type,
                hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name),
                style = elem.style

              // Make sure that we're working with the right name. We don't
              // want to query the value if it is a CSS custom property
              // since they are user-defined.
              if (!isCustomProp) {
                name = finalPropName(origName)
              }

              // Gets hook for the prefixed version, then unprefixed version
              hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

              // Check if we're setting a value
              if (value !== undefined) {
                type = typeof value

                // Convert "+=" or "-=" to relative numbers (#7345)
                if (
                  type === 'string' &&
                  (ret = rcssNum.exec(value)) &&
                  ret[1]
                ) {
                  value = adjustCSS(elem, name, ret)

                  // Fixes bug #9237
                  type = 'number'
                }

                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                  return
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if (type === 'number' && !isCustomProp) {
                  value +=
                    (ret && ret[3]) || (jQuery.cssNumber[origName] ? '' : 'px')
                }

                // background-* props affect original clone's values
                if (
                  !support.clearCloneStyle &&
                  value === '' &&
                  name.indexOf('background') === 0
                ) {
                  style[name] = 'inherit'
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (
                  !hooks ||
                  !('set' in hooks) ||
                  (value = hooks.set(elem, value, extra)) !== undefined
                ) {
                  if (isCustomProp) {
                    style.setProperty(name, value)
                  } else {
                    style[name] = value
                  }
                }
              } else {
                // If a hook was provided get the non-computed value from there
                if (
                  hooks &&
                  'get' in hooks &&
                  (ret = hooks.get(elem, false, extra)) !== undefined
                ) {
                  return ret
                }

                // Otherwise just get the value from the style object
                return style[name]
              }
            },

            css: function (elem, name, extra, styles) {
              var val,
                num,
                hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name)

              // Make sure that we're working with the right name. We don't
              // want to modify the value if it is a CSS custom property
              // since they are user-defined.
              if (!isCustomProp) {
                name = finalPropName(origName)
              }

              // Try prefixed name followed by the unprefixed name
              hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

              // If a hook was provided get the computed value from there
              if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra)
              }

              // Otherwise, if a way to get the computed value exists, use that
              if (val === undefined) {
                val = curCSS(elem, name, styles)
              }

              // Convert "normal" to computed value
              if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name]
              }

              // Make numeric if forced or a qualifier was provided and val looks numeric
              if (extra === '' || extra) {
                num = parseFloat(val)
                return extra === true || isFinite(num) ? num || 0 : val
              }

              return val
            }
          })

          jQuery.each(['height', 'width'], function (_i, dimension) {
            jQuery.cssHooks[dimension] = {
              get: function (elem, computed, extra) {
                if (computed) {
                  // Certain elements can have dimension info if we invisibly show them
                  // but it must have a current display style that would benefit
                  return rdisplayswap.test(jQuery.css(elem, 'display')) &&
                    // Support: Safari 8+
                    // Table columns in Safari have non-zero offsetWidth & zero
                    // getBoundingClientRect().width unless display is changed.
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a disconnected node
                    // in IE throws an error.
                    (!elem.getClientRects().length ||
                      !elem.getBoundingClientRect().width)
                    ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, dimension, extra)
                      })
                    : getWidthOrHeight(elem, dimension, extra)
                }
              },

              set: function (elem, value, extra) {
                var matches,
                  styles = getStyles(elem),
                  // Only read styles.position if the test has a chance to fail
                  // to avoid forcing a reflow.
                  scrollboxSizeBuggy =
                    !support.scrollboxSize() && styles.position === 'absolute',
                  // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                  boxSizingNeeded = scrollboxSizeBuggy || extra,
                  isBorderBox =
                    boxSizingNeeded &&
                    jQuery.css(elem, 'boxSizing', false, styles) ===
                      'border-box',
                  subtract = extra
                    ? boxModelAdjustment(
                        elem,
                        dimension,
                        extra,
                        isBorderBox,
                        styles
                      )
                    : 0

                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && scrollboxSizeBuggy) {
                  subtract -= Math.ceil(
                    elem[
                      'offset' + dimension[0].toUpperCase() + dimension.slice(1)
                    ] -
                      parseFloat(styles[dimension]) -
                      boxModelAdjustment(
                        elem,
                        dimension,
                        'border',
                        false,
                        styles
                      ) -
                      0.5
                  )
                }

                // Convert to pixels if value adjustment is needed
                if (
                  subtract &&
                  (matches = rcssNum.exec(value)) &&
                  (matches[3] || 'px') !== 'px'
                ) {
                  elem.style[dimension] = value
                  value = jQuery.css(elem, dimension)
                }

                return setPositiveNumber(elem, value, subtract)
              }
            }
          })

          jQuery.cssHooks.marginLeft = addGetHookIf(
            support.reliableMarginLeft,
            function (elem, computed) {
              if (computed) {
                return (
                  (parseFloat(curCSS(elem, 'marginLeft')) ||
                    elem.getBoundingClientRect().left -
                      swap(elem, { marginLeft: 0 }, function () {
                        return elem.getBoundingClientRect().left
                      })) + 'px'
                )
              }
            }
          )

          // These hooks are used by animate to expand properties
          jQuery.each(
            {
              margin: '',
              padding: '',
              border: 'Width'
            },
            function (prefix, suffix) {
              jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                  var i = 0,
                    expanded = {},
                    // Assumes a single number if not a string
                    parts =
                      typeof value === 'string' ? value.split(' ') : [value]

                  for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
                      parts[i] || parts[i - 2] || parts[0]
                  }

                  return expanded
                }
              }

              if (prefix !== 'margin') {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber
              }
            }
          )

          jQuery.fn.extend({
            css: function (name, value) {
              return access(
                this,
                function (elem, name, value) {
                  var styles,
                    len,
                    map = {},
                    i = 0

                  if (Array.isArray(name)) {
                    styles = getStyles(elem)
                    len = name.length

                    for (; i < len; i++) {
                      map[name[i]] = jQuery.css(elem, name[i], false, styles)
                    }

                    return map
                  }

                  return value !== undefined
                    ? jQuery.style(elem, name, value)
                    : jQuery.css(elem, name)
                },
                name,
                value,
                arguments.length > 1
              )
            }
          })

          function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing)
          }
          jQuery.Tween = Tween

          Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
              this.elem = elem
              this.prop = prop
              this.easing = easing || jQuery.easing._default
              this.options = options
              this.start = this.now = this.cur()
              this.end = end
              this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px')
            },
            cur: function () {
              var hooks = Tween.propHooks[this.prop]

              return hooks && hooks.get
                ? hooks.get(this)
                : Tween.propHooks._default.get(this)
            },
            run: function (percent) {
              var eased,
                hooks = Tween.propHooks[this.prop]

              if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                  percent,
                  this.options.duration * percent,
                  0,
                  1,
                  this.options.duration
                )
              } else {
                this.pos = eased = percent
              }
              this.now = (this.end - this.start) * eased + this.start

              if (this.options.step) {
                this.options.step.call(this.elem, this.now, this)
              }

              if (hooks && hooks.set) {
                hooks.set(this)
              } else {
                Tween.propHooks._default.set(this)
              }
              return this
            }
          }

          Tween.prototype.init.prototype = Tween.prototype

          Tween.propHooks = {
            _default: {
              get: function (tween) {
                var result

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (
                  tween.elem.nodeType !== 1 ||
                  (tween.elem[tween.prop] != null &&
                    tween.elem.style[tween.prop] == null)
                ) {
                  return tween.elem[tween.prop]
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, '')

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === 'auto' ? 0 : result
              },
              set: function (tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                  jQuery.fx.step[tween.prop](tween)
                } else if (
                  tween.elem.nodeType === 1 &&
                  (jQuery.cssHooks[tween.prop] ||
                    tween.elem.style[finalPropName(tween.prop)] != null)
                ) {
                  jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
                } else {
                  tween.elem[tween.prop] = tween.now
                }
              }
            }
          }

          // Support: IE <=9 only
          // Panic based approach to setting things on disconnected nodes
          Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
              if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now
              }
            }
          }

          jQuery.easing = {
            linear: function (p) {
              return p
            },
            swing: function (p) {
              return 0.5 - Math.cos(p * Math.PI) / 2
            },
            _default: 'swing'
          }

          jQuery.fx = Tween.prototype.init

          // Back compat <1.8 extension point
          jQuery.fx.step = {}

          var fxNow,
            inProgress,
            rfxtypes = /^(?:toggle|show|hide)$/,
            rrun = /queueHooks$/

          function schedule() {
            if (inProgress) {
              if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule)
              } else {
                window.setTimeout(schedule, jQuery.fx.interval)
              }

              jQuery.fx.tick()
            }
          }

          // Animations created synchronously will run synchronously
          function createFxNow() {
            window.setTimeout(function () {
              fxNow = undefined
            })
            return (fxNow = Date.now())
          }

          // Generate parameters to create a standard animation
          function genFx(type, includeWidth) {
            var which,
              i = 0,
              attrs = { height: type }

            // If we include width, step value is 1 to do all cssExpand values,
            // otherwise step value is 2 to skip over Left and Right
            includeWidth = includeWidth ? 1 : 0
            for (; i < 4; i += 2 - includeWidth) {
              which = cssExpand[i]
              attrs['margin' + which] = attrs['padding' + which] = type
            }

            if (includeWidth) {
              attrs.opacity = attrs.width = type
            }

            return attrs
          }

          function createTween(value, prop, animation) {
            var tween,
              collection = (Animation.tweeners[prop] || []).concat(
                Animation.tweeners['*']
              ),
              index = 0,
              length = collection.length
            for (; index < length; index++) {
              if ((tween = collection[index].call(animation, prop, value))) {
                // We're done with this property
                return tween
              }
            }
          }

          function defaultPrefilter(elem, props, opts) {
            var prop,
              value,
              toggle,
              hooks,
              oldfire,
              propTween,
              restoreDisplay,
              display,
              isBox = 'width' in props || 'height' in props,
              anim = this,
              orig = {},
              style = elem.style,
              hidden = elem.nodeType && isHiddenWithinTree(elem),
              dataShow = dataPriv.get(elem, 'fxshow')

            // Queue-skipping animations hijack the fx hooks
            if (!opts.queue) {
              hooks = jQuery._queueHooks(elem, 'fx')
              if (hooks.unqueued == null) {
                hooks.unqueued = 0
                oldfire = hooks.empty.fire
                hooks.empty.fire = function () {
                  if (!hooks.unqueued) {
                    oldfire()
                  }
                }
              }
              hooks.unqueued++

              anim.always(function () {
                // Ensure the complete handler is called before this completes
                anim.always(function () {
                  hooks.unqueued--
                  if (!jQuery.queue(elem, 'fx').length) {
                    hooks.empty.fire()
                  }
                })
              })
            }

            // Detect show/hide animations
            for (prop in props) {
              value = props[prop]
              if (rfxtypes.test(value)) {
                delete props[prop]
                toggle = toggle || value === 'toggle'
                if (value === (hidden ? 'hide' : 'show')) {
                  // Pretend to be hidden if this is a "show" and
                  // there is still data from a stopped show/hide
                  if (
                    value === 'show' &&
                    dataShow &&
                    dataShow[prop] !== undefined
                  ) {
                    hidden = true

                    // Ignore all other no-op show/hide data
                  } else {
                    continue
                  }
                }
                orig[prop] =
                  (dataShow && dataShow[prop]) || jQuery.style(elem, prop)
              }
            }

            // Bail out if this is a no-op like .hide().hide()
            propTween = !jQuery.isEmptyObject(props)
            if (!propTween && jQuery.isEmptyObject(orig)) {
              return
            }

            // Restrict "overflow" and "display" styles during box animations
            if (isBox && elem.nodeType === 1) {
              // Support: IE <=9 - 11, Edge 12 - 15
              // Record all 3 overflow attributes because IE does not infer the shorthand
              // from identically-valued overflowX and overflowY and Edge just mirrors
              // the overflowX value there.
              opts.overflow = [style.overflow, style.overflowX, style.overflowY]

              // Identify a display type, preferring old show/hide data over the CSS cascade
              restoreDisplay = dataShow && dataShow.display
              if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, 'display')
              }
              display = jQuery.css(elem, 'display')
              if (display === 'none') {
                if (restoreDisplay) {
                  display = restoreDisplay
                } else {
                  // Get nonempty value(s) by temporarily forcing visibility
                  showHide([elem], true)
                  restoreDisplay = elem.style.display || restoreDisplay
                  display = jQuery.css(elem, 'display')
                  showHide([elem])
                }
              }

              // Animate inline elements as inline-block
              if (
                display === 'inline' ||
                (display === 'inline-block' && restoreDisplay != null)
              ) {
                if (jQuery.css(elem, 'float') === 'none') {
                  // Restore the original display value at the end of pure show/hide animations
                  if (!propTween) {
                    anim.done(function () {
                      style.display = restoreDisplay
                    })
                    if (restoreDisplay == null) {
                      display = style.display
                      restoreDisplay = display === 'none' ? '' : display
                    }
                  }
                  style.display = 'inline-block'
                }
              }
            }

            if (opts.overflow) {
              style.overflow = 'hidden'
              anim.always(function () {
                style.overflow = opts.overflow[0]
                style.overflowX = opts.overflow[1]
                style.overflowY = opts.overflow[2]
              })
            }

            // Implement show/hide animations
            propTween = false
            for (prop in orig) {
              // General show/hide setup for this element animation
              if (!propTween) {
                if (dataShow) {
                  if ('hidden' in dataShow) {
                    hidden = dataShow.hidden
                  }
                } else {
                  dataShow = dataPriv.access(elem, 'fxshow', {
                    display: restoreDisplay
                  })
                }

                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) {
                  dataShow.hidden = !hidden
                }

                // Show elements before animating them
                if (hidden) {
                  showHide([elem], true)
                }

                /* eslint-disable no-loop-func */

                anim.done(function () {
                  /* eslint-enable no-loop-func */

                  // The final step of a "hide" animation is actually hiding the element
                  if (!hidden) {
                    showHide([elem])
                  }
                  dataPriv.remove(elem, 'fxshow')
                  for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop])
                  }
                })
              }

              // Per-property setup
              propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim)
              if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start
                if (hidden) {
                  propTween.end = propTween.start
                  propTween.start = 0
                }
              }
            }
          }

          function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks

            // camelCase, specialEasing and expand cssHook pass
            for (index in props) {
              name = camelCase(index)
              easing = specialEasing[name]
              value = props[index]
              if (Array.isArray(value)) {
                easing = value[1]
                value = props[index] = value[0]
              }

              if (index !== name) {
                props[name] = value
                delete props[index]
              }

              hooks = jQuery.cssHooks[name]
              if (hooks && 'expand' in hooks) {
                value = hooks.expand(value)
                delete props[name]

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                  if (!(index in props)) {
                    props[index] = value[index]
                    specialEasing[index] = easing
                  }
                }
              } else {
                specialEasing[name] = easing
              }
            }
          }

          function Animation(elem, properties, options) {
            var result,
              stopped,
              index = 0,
              length = Animation.prefilters.length,
              deferred = jQuery.Deferred().always(function () {
                // Don't match elem in the :animated selector
                delete tick.elem
              }),
              tick = function () {
                if (stopped) {
                  return false
                }
                var currentTime = fxNow || createFxNow(),
                  remaining = Math.max(
                    0,
                    animation.startTime + animation.duration - currentTime
                  ),
                  // Support: Android 2.3 only
                  // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                  temp = remaining / animation.duration || 0,
                  percent = 1 - temp,
                  index = 0,
                  length = animation.tweens.length

                for (; index < length; index++) {
                  animation.tweens[index].run(percent)
                }

                deferred.notifyWith(elem, [animation, percent, remaining])

                // If there's more to do, yield
                if (percent < 1 && length) {
                  return remaining
                }

                // If this was an empty animation, synthesize a final progress notification
                if (!length) {
                  deferred.notifyWith(elem, [animation, 1, 0])
                }

                // Resolve the animation and report its conclusion
                deferred.resolveWith(elem, [animation])
                return false
              },
              animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(
                  true,
                  {
                    specialEasing: {},
                    easing: jQuery.easing._default
                  },
                  options
                ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                  var tween = jQuery.Tween(
                    elem,
                    animation.opts,
                    prop,
                    end,
                    animation.opts.specialEasing[prop] || animation.opts.easing
                  )
                  animation.tweens.push(tween)
                  return tween
                },
                stop: function (gotoEnd) {
                  var index = 0,
                    // If we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation.tweens.length : 0
                  if (stopped) {
                    return this
                  }
                  stopped = true
                  for (; index < length; index++) {
                    animation.tweens[index].run(1)
                  }

                  // Resolve when we played the last frame; otherwise, reject
                  if (gotoEnd) {
                    deferred.notifyWith(elem, [animation, 1, 0])
                    deferred.resolveWith(elem, [animation, gotoEnd])
                  } else {
                    deferred.rejectWith(elem, [animation, gotoEnd])
                  }
                  return this
                }
              }),
              props = animation.props

            propFilter(props, animation.opts.specialEasing)

            for (; index < length; index++) {
              result = Animation.prefilters[index].call(
                animation,
                elem,
                props,
                animation.opts
              )
              if (result) {
                if (isFunction(result.stop)) {
                  jQuery._queueHooks(
                    animation.elem,
                    animation.opts.queue
                  ).stop = result.stop.bind(result)
                }
                return result
              }
            }

            jQuery.map(props, createTween, animation)

            if (isFunction(animation.opts.start)) {
              animation.opts.start.call(elem, animation)
            }

            // Attach callbacks from options
            animation
              .progress(animation.opts.progress)
              .done(animation.opts.done, animation.opts.complete)
              .fail(animation.opts.fail)
              .always(animation.opts.always)

            jQuery.fx.timer(
              jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
              })
            )

            return animation
          }

          jQuery.Animation = jQuery.extend(Animation, {
            tweeners: {
              '*': [
                function (prop, value) {
                  var tween = this.createTween(prop, value)
                  adjustCSS(tween.elem, prop, rcssNum.exec(value), tween)
                  return tween
                }
              ]
            },

            tweener: function (props, callback) {
              if (isFunction(props)) {
                callback = props
                props = ['*']
              } else {
                props = props.match(rnothtmlwhite)
              }

              var prop,
                index = 0,
                length = props.length

              for (; index < length; index++) {
                prop = props[index]
                Animation.tweeners[prop] = Animation.tweeners[prop] || []
                Animation.tweeners[prop].unshift(callback)
              }
            },

            prefilters: [defaultPrefilter],

            prefilter: function (callback, prepend) {
              if (prepend) {
                Animation.prefilters.unshift(callback)
              } else {
                Animation.prefilters.push(callback)
              }
            }
          })

          jQuery.speed = function (speed, easing, fn) {
            var opt =
              speed && typeof speed === 'object'
                ? jQuery.extend({}, speed)
                : {
                    complete:
                      fn || (!fn && easing) || (isFunction(speed) && speed),
                    duration: speed,
                    easing:
                      (fn && easing) ||
                      (easing && !isFunction(easing) && easing)
                  }

            // Go to the end state if fx are off
            if (jQuery.fx.off) {
              opt.duration = 0
            } else {
              if (typeof opt.duration !== 'number') {
                if (opt.duration in jQuery.fx.speeds) {
                  opt.duration = jQuery.fx.speeds[opt.duration]
                } else {
                  opt.duration = jQuery.fx.speeds._default
                }
              }
            }

            // Normalize opt.queue - true/undefined/null -> "fx"
            if (opt.queue == null || opt.queue === true) {
              opt.queue = 'fx'
            }

            // Queueing
            opt.old = opt.complete

            opt.complete = function () {
              if (isFunction(opt.old)) {
                opt.old.call(this)
              }

              if (opt.queue) {
                jQuery.dequeue(this, opt.queue)
              }
            }

            return opt
          }

          jQuery.fn.extend({
            fadeTo: function (speed, to, easing, callback) {
              // Show any hidden elements after setting opacity to 0
              return (
                this.filter(isHiddenWithinTree)
                  .css('opacity', 0)
                  .show()

                  // Animate to the value specified
                  .end()
                  .animate({ opacity: to }, speed, easing, callback)
              )
            },
            animate: function (prop, speed, easing, callback) {
              var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {
                  // Operate on a copy of prop so per-property easing won't be lost
                  var anim = Animation(this, jQuery.extend({}, prop), optall)

                  // Empty animations, or finishing resolves immediately
                  if (empty || dataPriv.get(this, 'finish')) {
                    anim.stop(true)
                  }
                }

              doAnimation.finish = doAnimation

              return empty || optall.queue === false
                ? this.each(doAnimation)
                : this.queue(optall.queue, doAnimation)
            },
            stop: function (type, clearQueue, gotoEnd) {
              var stopQueue = function (hooks) {
                var stop = hooks.stop
                delete hooks.stop
                stop(gotoEnd)
              }

              if (typeof type !== 'string') {
                gotoEnd = clearQueue
                clearQueue = type
                type = undefined
              }
              if (clearQueue) {
                this.queue(type || 'fx', [])
              }

              return this.each(function () {
                var dequeue = true,
                  index = type != null && type + 'queueHooks',
                  timers = jQuery.timers,
                  data = dataPriv.get(this)

                if (index) {
                  if (data[index] && data[index].stop) {
                    stopQueue(data[index])
                  }
                } else {
                  for (index in data) {
                    if (data[index] && data[index].stop && rrun.test(index)) {
                      stopQueue(data[index])
                    }
                  }
                }

                for (index = timers.length; index--; ) {
                  if (
                    timers[index].elem === this &&
                    (type == null || timers[index].queue === type)
                  ) {
                    timers[index].anim.stop(gotoEnd)
                    dequeue = false
                    timers.splice(index, 1)
                  }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                  jQuery.dequeue(this, type)
                }
              })
            },
            finish: function (type) {
              if (type !== false) {
                type = type || 'fx'
              }
              return this.each(function () {
                var index,
                  data = dataPriv.get(this),
                  queue = data[type + 'queue'],
                  hooks = data[type + 'queueHooks'],
                  timers = jQuery.timers,
                  length = queue ? queue.length : 0

                // Enable finishing flag on private data
                data.finish = true

                // Empty the queue first
                jQuery.queue(this, type, [])

                if (hooks && hooks.stop) {
                  hooks.stop.call(this, true)
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--; ) {
                  if (
                    timers[index].elem === this &&
                    timers[index].queue === type
                  ) {
                    timers[index].anim.stop(true)
                    timers.splice(index, 1)
                  }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                  if (queue[index] && queue[index].finish) {
                    queue[index].finish.call(this)
                  }
                }

                // Turn off finishing flag
                delete data.finish
              })
            }
          })

          jQuery.each(['toggle', 'show', 'hide'], function (_i, name) {
            var cssFn = jQuery.fn[name]
            jQuery.fn[name] = function (speed, easing, callback) {
              return speed == null || typeof speed === 'boolean'
                ? cssFn.apply(this, arguments)
                : this.animate(genFx(name, true), speed, easing, callback)
            }
          })

          // Generate shortcuts for custom animations
          jQuery.each(
            {
              slideDown: genFx('show'),
              slideUp: genFx('hide'),
              slideToggle: genFx('toggle'),
              fadeIn: { opacity: 'show' },
              fadeOut: { opacity: 'hide' },
              fadeToggle: { opacity: 'toggle' }
            },
            function (name, props) {
              jQuery.fn[name] = function (speed, easing, callback) {
                return this.animate(props, speed, easing, callback)
              }
            }
          )

          jQuery.timers = []
          jQuery.fx.tick = function () {
            var timer,
              i = 0,
              timers = jQuery.timers

            fxNow = Date.now()

            for (; i < timers.length; i++) {
              timer = timers[i]

              // Run the timer and safely remove it when done (allowing for external removal)
              if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1)
              }
            }

            if (!timers.length) {
              jQuery.fx.stop()
            }
            fxNow = undefined
          }

          jQuery.fx.timer = function (timer) {
            jQuery.timers.push(timer)
            jQuery.fx.start()
          }

          jQuery.fx.interval = 13
          jQuery.fx.start = function () {
            if (inProgress) {
              return
            }

            inProgress = true
            schedule()
          }

          jQuery.fx.stop = function () {
            inProgress = null
          }

          jQuery.fx.speeds = {
            slow: 600,
            fast: 200,

            // Default speed
            _default: 400
          }

          // Based off of the plugin by Clint Helfers, with permission.
          // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
          jQuery.fn.delay = function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time
            type = type || 'fx'

            return this.queue(type, function (next, hooks) {
              var timeout = window.setTimeout(next, time)
              hooks.stop = function () {
                window.clearTimeout(timeout)
              }
            })
          }

          ;(function () {
            var input = document.createElement('input'),
              select = document.createElement('select'),
              opt = select.appendChild(document.createElement('option'))

            input.type = 'checkbox'

            // Support: Android <=4.3 only
            // Default value for a checkbox should be "on"
            support.checkOn = input.value !== ''

            // Support: IE <=11 only
            // Must access selectedIndex to make default options select
            support.optSelected = opt.selected

            // Support: IE <=11 only
            // An input loses its value after becoming a radio
            input = document.createElement('input')
            input.value = 't'
            input.type = 'radio'
            support.radioValue = input.value === 't'
          })()

          var boolHook,
            attrHandle = jQuery.expr.attrHandle

          jQuery.fn.extend({
            attr: function (name, value) {
              return access(
                this,
                jQuery.attr,
                name,
                value,
                arguments.length > 1
              )
            },

            removeAttr: function (name) {
              return this.each(function () {
                jQuery.removeAttr(this, name)
              })
            }
          })

          jQuery.extend({
            attr: function (elem, name, value) {
              var ret,
                hooks,
                nType = elem.nodeType

              // Don't get/set attributes on text, comment and attribute nodes
              if (nType === 3 || nType === 8 || nType === 2) {
                return
              }

              // Fallback to prop when attributes are not supported
              if (typeof elem.getAttribute === 'undefined') {
                return jQuery.prop(elem, name, value)
              }

              // Attribute hooks are determined by the lowercase version
              // Grab necessary hook if one is defined
              if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks =
                  jQuery.attrHooks[name.toLowerCase()] ||
                  (jQuery.expr.match.bool.test(name) ? boolHook : undefined)
              }

              if (value !== undefined) {
                if (value === null) {
                  jQuery.removeAttr(elem, name)
                  return
                }

                if (
                  hooks &&
                  'set' in hooks &&
                  (ret = hooks.set(elem, value, name)) !== undefined
                ) {
                  return ret
                }

                elem.setAttribute(name, value + '')
                return value
              }

              if (
                hooks &&
                'get' in hooks &&
                (ret = hooks.get(elem, name)) !== null
              ) {
                return ret
              }

              ret = jQuery.find.attr(elem, name)

              // Non-existent attributes return null, we normalize to undefined
              return ret == null ? undefined : ret
            },

            attrHooks: {
              type: {
                set: function (elem, value) {
                  if (
                    !support.radioValue &&
                    value === 'radio' &&
                    nodeName(elem, 'input')
                  ) {
                    var val = elem.value
                    elem.setAttribute('type', value)
                    if (val) {
                      elem.value = val
                    }
                    return value
                  }
                }
              }
            },

            removeAttr: function (elem, value) {
              var name,
                i = 0,
                // Attribute names can contain non-HTML whitespace characters
                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                attrNames = value && value.match(rnothtmlwhite)

              if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                  elem.removeAttribute(name)
                }
              }
            }
          })

          // Hooks for boolean attributes
          boolHook = {
            set: function (elem, value, name) {
              if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name)
              } else {
                elem.setAttribute(name, name)
              }
              return name
            }
          }

          jQuery.each(
            jQuery.expr.match.bool.source.match(/\w+/g),
            function (_i, name) {
              var getter = attrHandle[name] || jQuery.find.attr

              attrHandle[name] = function (elem, name, isXML) {
                var ret,
                  handle,
                  lowercaseName = name.toLowerCase()

                if (!isXML) {
                  // Avoid an infinite loop by temporarily removing this function from the getter
                  handle = attrHandle[lowercaseName]
                  attrHandle[lowercaseName] = ret
                  ret = getter(elem, name, isXML) != null ? lowercaseName : null
                  attrHandle[lowercaseName] = handle
                }
                return ret
              }
            }
          )

          var rfocusable = /^(?:input|select|textarea|button)$/i,
            rclickable = /^(?:a|area)$/i

          jQuery.fn.extend({
            prop: function (name, value) {
              return access(
                this,
                jQuery.prop,
                name,
                value,
                arguments.length > 1
              )
            },

            removeProp: function (name) {
              return this.each(function () {
                delete this[jQuery.propFix[name] || name]
              })
            }
          })

          jQuery.extend({
            prop: function (elem, name, value) {
              var ret,
                hooks,
                nType = elem.nodeType

              // Don't get/set properties on text, comment and attribute nodes
              if (nType === 3 || nType === 8 || nType === 2) {
                return
              }

              if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name
                hooks = jQuery.propHooks[name]
              }

              if (value !== undefined) {
                if (
                  hooks &&
                  'set' in hooks &&
                  (ret = hooks.set(elem, value, name)) !== undefined
                ) {
                  return ret
                }

                return (elem[name] = value)
              }

              if (
                hooks &&
                'get' in hooks &&
                (ret = hooks.get(elem, name)) !== null
              ) {
                return ret
              }

              return elem[name]
            },

            propHooks: {
              tabIndex: {
                get: function (elem) {
                  // Support: IE <=9 - 11 only
                  // elem.tabIndex doesn't always return the
                  // correct value when it hasn't been explicitly set
                  // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                  // Use proper attribute retrieval(#12072)
                  var tabindex = jQuery.find.attr(elem, 'tabindex')

                  if (tabindex) {
                    return parseInt(tabindex, 10)
                  }

                  if (
                    rfocusable.test(elem.nodeName) ||
                    (rclickable.test(elem.nodeName) && elem.href)
                  ) {
                    return 0
                  }

                  return -1
                }
              }
            },

            propFix: {
              for: 'htmlFor',
              class: 'className'
            }
          })

          // Support: IE <=11 only
          // Accessing the selectedIndex property
          // forces the browser to respect setting selected
          // on the option
          // The getter ensures a default option is selected
          // when in an optgroup
          // eslint rule "no-unused-expressions" is disabled for this code
          // since it considers such accessions noop
          if (!support.optSelected) {
            jQuery.propHooks.selected = {
              get: function (elem) {
                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode
                if (parent && parent.parentNode) {
                  parent.parentNode.selectedIndex
                }
                return null
              },
              set: function (elem) {
                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode
                if (parent) {
                  parent.selectedIndex

                  if (parent.parentNode) {
                    parent.parentNode.selectedIndex
                  }
                }
              }
            }
          }

          jQuery.each(
            [
              'tabIndex',
              'readOnly',
              'maxLength',
              'cellSpacing',
              'cellPadding',
              'rowSpan',
              'colSpan',
              'useMap',
              'frameBorder',
              'contentEditable'
            ],
            function () {
              jQuery.propFix[this.toLowerCase()] = this
            }
          )

          // Strip and collapse whitespace according to HTML spec
          // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
          function stripAndCollapse(value) {
            var tokens = value.match(rnothtmlwhite) || []
            return tokens.join(' ')
          }

          function getClass(elem) {
            return (elem.getAttribute && elem.getAttribute('class')) || ''
          }

          function classesToArray(value) {
            if (Array.isArray(value)) {
              return value
            }
            if (typeof value === 'string') {
              return value.match(rnothtmlwhite) || []
            }
            return []
          }

          jQuery.fn.extend({
            addClass: function (value) {
              var classes,
                elem,
                cur,
                curValue,
                clazz,
                j,
                finalValue,
                i = 0

              if (isFunction(value)) {
                return this.each(function (j) {
                  jQuery(this).addClass(value.call(this, j, getClass(this)))
                })
              }

              classes = classesToArray(value)

              if (classes.length) {
                while ((elem = this[i++])) {
                  curValue = getClass(elem)
                  cur =
                    elem.nodeType === 1 &&
                    ' ' + stripAndCollapse(curValue) + ' '

                  if (cur) {
                    j = 0
                    while ((clazz = classes[j++])) {
                      if (cur.indexOf(' ' + clazz + ' ') < 0) {
                        cur += clazz + ' '
                      }
                    }

                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur)
                    if (curValue !== finalValue) {
                      elem.setAttribute('class', finalValue)
                    }
                  }
                }
              }

              return this
            },

            removeClass: function (value) {
              var classes,
                elem,
                cur,
                curValue,
                clazz,
                j,
                finalValue,
                i = 0

              if (isFunction(value)) {
                return this.each(function (j) {
                  jQuery(this).removeClass(value.call(this, j, getClass(this)))
                })
              }

              if (!arguments.length) {
                return this.attr('class', '')
              }

              classes = classesToArray(value)

              if (classes.length) {
                while ((elem = this[i++])) {
                  curValue = getClass(elem)

                  // This expression is here for better compressibility (see addClass)
                  cur =
                    elem.nodeType === 1 &&
                    ' ' + stripAndCollapse(curValue) + ' '

                  if (cur) {
                    j = 0
                    while ((clazz = classes[j++])) {
                      // Remove *all* instances
                      while (cur.indexOf(' ' + clazz + ' ') > -1) {
                        cur = cur.replace(' ' + clazz + ' ', ' ')
                      }
                    }

                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur)
                    if (curValue !== finalValue) {
                      elem.setAttribute('class', finalValue)
                    }
                  }
                }
              }

              return this
            },

            toggleClass: function (value, stateVal) {
              var type = typeof value,
                isValidValue = type === 'string' || Array.isArray(value)

              if (typeof stateVal === 'boolean' && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value)
              }

              if (isFunction(value)) {
                return this.each(function (i) {
                  jQuery(this).toggleClass(
                    value.call(this, i, getClass(this), stateVal),
                    stateVal
                  )
                })
              }

              return this.each(function () {
                var className, i, self, classNames

                if (isValidValue) {
                  // Toggle individual class names
                  i = 0
                  self = jQuery(this)
                  classNames = classesToArray(value)

                  while ((className = classNames[i++])) {
                    // Check each className given, space separated list
                    if (self.hasClass(className)) {
                      self.removeClass(className)
                    } else {
                      self.addClass(className)
                    }
                  }

                  // Toggle whole class name
                } else if (value === undefined || type === 'boolean') {
                  className = getClass(this)
                  if (className) {
                    // Store className if set
                    dataPriv.set(this, '__className__', className)
                  }

                  // If the element has a class name or if we're passed `false`,
                  // then remove the whole classname (if there was one, the above saved it).
                  // Otherwise bring back whatever was previously saved (if anything),
                  // falling back to the empty string if nothing was stored.
                  if (this.setAttribute) {
                    this.setAttribute(
                      'class',
                      className || value === false
                        ? ''
                        : dataPriv.get(this, '__className__') || ''
                    )
                  }
                }
              })
            },

            hasClass: function (selector) {
              var className,
                elem,
                i = 0

              className = ' ' + selector + ' '
              while ((elem = this[i++])) {
                if (
                  elem.nodeType === 1 &&
                  (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(
                    className
                  ) > -1
                ) {
                  return true
                }
              }

              return false
            }
          })

          var rreturn = /\r/g

          jQuery.fn.extend({
            val: function (value) {
              var hooks,
                ret,
                valueIsFunction,
                elem = this[0]

              if (!arguments.length) {
                if (elem) {
                  hooks =
                    jQuery.valHooks[elem.type] ||
                    jQuery.valHooks[elem.nodeName.toLowerCase()]

                  if (
                    hooks &&
                    'get' in hooks &&
                    (ret = hooks.get(elem, 'value')) !== undefined
                  ) {
                    return ret
                  }

                  ret = elem.value

                  // Handle most common string cases
                  if (typeof ret === 'string') {
                    return ret.replace(rreturn, '')
                  }

                  // Handle cases where value is null/undef or number
                  return ret == null ? '' : ret
                }

                return
              }

              valueIsFunction = isFunction(value)

              return this.each(function (i) {
                var val

                if (this.nodeType !== 1) {
                  return
                }

                if (valueIsFunction) {
                  val = value.call(this, i, jQuery(this).val())
                } else {
                  val = value
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                  val = ''
                } else if (typeof val === 'number') {
                  val += ''
                } else if (Array.isArray(val)) {
                  val = jQuery.map(val, function (value) {
                    return value == null ? '' : value + ''
                  })
                }

                hooks =
                  jQuery.valHooks[this.type] ||
                  jQuery.valHooks[this.nodeName.toLowerCase()]

                // If set returns undefined, fall back to normal setting
                if (
                  !hooks ||
                  !('set' in hooks) ||
                  hooks.set(this, val, 'value') === undefined
                ) {
                  this.value = val
                }
              })
            }
          })

          jQuery.extend({
            valHooks: {
              option: {
                get: function (elem) {
                  var val = jQuery.find.attr(elem, 'value')
                  return val != null
                    ? val
                    : // Support: IE <=10 - 11 only
                      // option.text throws exceptions (#14686, #14858)
                      // Strip and collapse whitespace
                      // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                      stripAndCollapse(jQuery.text(elem))
                }
              },
              select: {
                get: function (elem) {
                  var value,
                    option,
                    i,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === 'select-one',
                    values = one ? null : [],
                    max = one ? index + 1 : options.length

                  if (index < 0) {
                    i = max
                  } else {
                    i = one ? index : 0
                  }

                  // Loop through all the selected options
                  for (; i < max; i++) {
                    option = options[i]

                    // Support: IE <=9 only
                    // IE8-9 doesn't update selected after form reset (#2551)
                    if (
                      (option.selected || i === index) &&
                      // Don't return options that are disabled or in a disabled optgroup
                      !option.disabled &&
                      (!option.parentNode.disabled ||
                        !nodeName(option.parentNode, 'optgroup'))
                    ) {
                      // Get the specific value for the option
                      value = jQuery(option).val()

                      // We don't need an array for one selects
                      if (one) {
                        return value
                      }

                      // Multi-Selects return an array
                      values.push(value)
                    }
                  }

                  return values
                },

                set: function (elem, value) {
                  var optionSet,
                    option,
                    options = elem.options,
                    values = jQuery.makeArray(value),
                    i = options.length

                  while (i--) {
                    option = options[i]

                    /* eslint-disable no-cond-assign */

                    if (
                      (option.selected =
                        jQuery.inArray(
                          jQuery.valHooks.option.get(option),
                          values
                        ) > -1)
                    ) {
                      optionSet = true
                    }

                    /* eslint-enable no-cond-assign */
                  }

                  // Force browsers to behave consistently when non-matching value is set
                  if (!optionSet) {
                    elem.selectedIndex = -1
                  }
                  return values
                }
              }
            }
          })

          // Radios and checkboxes getter/setter
          jQuery.each(['radio', 'checkbox'], function () {
            jQuery.valHooks[this] = {
              set: function (elem, value) {
                if (Array.isArray(value)) {
                  return (elem.checked =
                    jQuery.inArray(jQuery(elem).val(), value) > -1)
                }
              }
            }
            if (!support.checkOn) {
              jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value
              }
            }
          })

          // Return jQuery for attributes-only inclusion

          support.focusin = 'onfocusin' in window

          var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            stopPropagationCallback = function (e) {
              e.stopPropagation()
            }

          jQuery.extend(jQuery.event, {
            trigger: function (event, data, elem, onlyHandlers) {
              var i,
                cur,
                tmp,
                bubbleType,
                ontype,
                handle,
                special,
                lastElement,
                eventPath = [elem || document],
                type = hasOwn.call(event, 'type') ? event.type : event,
                namespaces = hasOwn.call(event, 'namespace')
                  ? event.namespace.split('.')
                  : []

              cur = lastElement = tmp = elem = elem || document

              // Don't do events on text and comment nodes
              if (elem.nodeType === 3 || elem.nodeType === 8) {
                return
              }

              // focus/blur morphs to focusin/out; ensure we're not firing them right now
              if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return
              }

              if (type.indexOf('.') > -1) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split('.')
                type = namespaces.shift()
                namespaces.sort()
              }
              ontype = type.indexOf(':') < 0 && 'on' + type

              // Caller can pass in a jQuery.Event object, Object, or just an event type string
              event = event[jQuery.expando]
                ? event
                : new jQuery.Event(type, typeof event === 'object' && event)

              // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
              event.isTrigger = onlyHandlers ? 2 : 3
              event.namespace = namespaces.join('.')
              event.rnamespace = event.namespace
                ? new RegExp(
                    '(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)'
                  )
                : null

              // Clean up the event in case it is being reused
              event.result = undefined
              if (!event.target) {
                event.target = elem
              }

              // Clone any incoming data and prepend the event, creating the handler arg list
              data = data == null ? [event] : jQuery.makeArray(data, [event])

              // Allow special events to draw outside the lines
              special = jQuery.event.special[type] || {}
              if (
                !onlyHandlers &&
                special.trigger &&
                special.trigger.apply(elem, data) === false
              ) {
                return
              }

              // Determine event propagation path in advance, per W3C events spec (#9951)
              // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
              if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type
                if (!rfocusMorph.test(bubbleType + type)) {
                  cur = cur.parentNode
                }
                for (; cur; cur = cur.parentNode) {
                  eventPath.push(cur)
                  tmp = cur
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                  eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                }
              }

              // Fire handlers on the event path
              i = 0
              while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur
                event.type = i > 1 ? bubbleType : special.bindType || type

                // jQuery handler
                handle =
                  (dataPriv.get(cur, 'events') || Object.create(null))[
                    event.type
                  ] && dataPriv.get(cur, 'handle')
                if (handle) {
                  handle.apply(cur, data)
                }

                // Native handler
                handle = ontype && cur[ontype]
                if (handle && handle.apply && acceptData(cur)) {
                  event.result = handle.apply(cur, data)
                  if (event.result === false) {
                    event.preventDefault()
                  }
                }
              }
              event.type = type

              // If nobody prevented the default action, do it now
              if (!onlyHandlers && !event.isDefaultPrevented()) {
                if (
                  (!special._default ||
                    special._default.apply(eventPath.pop(), data) === false) &&
                  acceptData(elem)
                ) {
                  // Call a native DOM method on the target with the same name as the event.
                  // Don't do default actions on window, that's where global variables be (#6170)
                  if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                    // Don't re-trigger an onFOO event when we call its FOO() method
                    tmp = elem[ontype]

                    if (tmp) {
                      elem[ontype] = null
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type

                    if (event.isPropagationStopped()) {
                      lastElement.addEventListener(
                        type,
                        stopPropagationCallback
                      )
                    }

                    elem[type]()

                    if (event.isPropagationStopped()) {
                      lastElement.removeEventListener(
                        type,
                        stopPropagationCallback
                      )
                    }

                    jQuery.event.triggered = undefined

                    if (tmp) {
                      elem[ontype] = tmp
                    }
                  }
                }
              }

              return event.result
            },

            // Piggyback on a donor event to simulate a different one
            // Used only for `focus(in | out)` events
            simulate: function (type, elem, event) {
              var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
              })

              jQuery.event.trigger(e, null, elem)
            }
          })

          jQuery.fn.extend({
            trigger: function (type, data) {
              return this.each(function () {
                jQuery.event.trigger(type, data, this)
              })
            },
            triggerHandler: function (type, data) {
              var elem = this[0]
              if (elem) {
                return jQuery.event.trigger(type, data, elem, true)
              }
            }
          })

          // Support: Firefox <=44
          // Firefox doesn't have focus(in | out) events
          // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
          //
          // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
          // focus(in | out) events fire after focus & blur events,
          // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
          // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
          if (!support.focusin) {
            jQuery.each(
              { focus: 'focusin', blur: 'focusout' },
              function (orig, fix) {
                // Attach a single capturing handler on the document while someone wants focusin/focusout
                var handler = function (event) {
                  jQuery.event.simulate(
                    fix,
                    event.target,
                    jQuery.event.fix(event)
                  )
                }

                jQuery.event.special[fix] = {
                  setup: function () {
                    // Handle: regular nodes (via `this.ownerDocument`), window
                    // (via `this.document`) & document (via `this`).
                    var doc = this.ownerDocument || this.document || this,
                      attaches = dataPriv.access(doc, fix)

                    if (!attaches) {
                      doc.addEventListener(orig, handler, true)
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1)
                  },
                  teardown: function () {
                    var doc = this.ownerDocument || this.document || this,
                      attaches = dataPriv.access(doc, fix) - 1

                    if (!attaches) {
                      doc.removeEventListener(orig, handler, true)
                      dataPriv.remove(doc, fix)
                    } else {
                      dataPriv.access(doc, fix, attaches)
                    }
                  }
                }
              }
            )
          }
          var location = window.location

          var nonce = { guid: Date.now() }

          var rquery = /\?/

          // Cross-browser xml parsing
          jQuery.parseXML = function (data) {
            var xml, parserErrorElem
            if (!data || typeof data !== 'string') {
              return null
            }

            // Support: IE 9 - 11 only
            // IE throws on parseFromString with invalid input.
            try {
              xml = new window.DOMParser().parseFromString(data, 'text/xml')
            } catch (e) {}

            parserErrorElem = xml && xml.getElementsByTagName('parsererror')[0]
            if (!xml || parserErrorElem) {
              jQuery.error(
                'Invalid XML: ' +
                  (parserErrorElem
                    ? jQuery
                        .map(parserErrorElem.childNodes, function (el) {
                          return el.textContent
                        })
                        .join('\n')
                    : data)
              )
            }
            return xml
          }

          var rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i

          function buildParams(prefix, obj, traditional, add) {
            var name

            if (Array.isArray(obj)) {
              // Serialize array item.
              jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                  // Treat each array item as a scalar.
                  add(prefix, v)
                } else {
                  // Item is non-scalar (array or object), encode its numeric index.
                  buildParams(
                    prefix +
                      '[' +
                      (typeof v === 'object' && v != null ? i : '') +
                      ']',
                    v,
                    traditional,
                    add
                  )
                }
              })
            } else if (!traditional && toType(obj) === 'object') {
              // Serialize object item.
              for (name in obj) {
                buildParams(
                  prefix + '[' + name + ']',
                  obj[name],
                  traditional,
                  add
                )
              }
            } else {
              // Serialize scalar item.
              add(prefix, obj)
            }
          }

          // Serialize an array of form elements or a set of
          // key/values into a query string
          jQuery.param = function (a, traditional) {
            var prefix,
              s = [],
              add = function (key, valueOrFunction) {
                // If value is a function, invoke it and use its return value
                var value = isFunction(valueOrFunction)
                  ? valueOrFunction()
                  : valueOrFunction

                s[s.length] =
                  encodeURIComponent(key) +
                  '=' +
                  encodeURIComponent(value == null ? '' : value)
              }

            if (a == null) {
              return ''
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
              // Serialize the form elements
              jQuery.each(a, function () {
                add(this.name, this.value)
              })
            } else {
              // If traditional, encode the "old" way (the way 1.3.2 or older
              // did it), otherwise encode params recursively.
              for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add)
              }
            }

            // Return the resulting serialization
            return s.join('&')
          }

          jQuery.fn.extend({
            serialize: function () {
              return jQuery.param(this.serializeArray())
            },
            serializeArray: function () {
              return this.map(function () {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, 'elements')
                return elements ? jQuery.makeArray(elements) : this
              })
                .filter(function () {
                  var type = this.type

                  // Use .is( ":disabled" ) so that fieldset[disabled] works
                  return (
                    this.name &&
                    !jQuery(this).is(':disabled') &&
                    rsubmittable.test(this.nodeName) &&
                    !rsubmitterTypes.test(type) &&
                    (this.checked || !rcheckableType.test(type))
                  )
                })
                .map(function (_i, elem) {
                  var val = jQuery(this).val()

                  if (val == null) {
                    return null
                  }

                  if (Array.isArray(val)) {
                    return jQuery.map(val, function (val) {
                      return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                      }
                    })
                  }

                  return { name: elem.name, value: val.replace(rCRLF, '\r\n') }
                })
                .get()
            }
          })

          var r20 = /%20/g,
            rhash = /#.*$/,
            rantiCache = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            // #7653, #8125, #8152: local protocol detection
            rlocalProtocol =
              /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            /* Prefilters
             * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
             * 2) These are called:
             *    - BEFORE asking for a transport
             *    - AFTER param serialization (s.data is a string if s.processData is true)
             * 3) key is the dataType
             * 4) the catchall symbol "*" can be used
             * 5) execution will start with transport dataType and THEN continue down to "*" if needed
             */
            prefilters = {},
            /* Transports bindings
             * 1) key is the dataType
             * 2) the catchall symbol "*" can be used
             * 3) selection will start with transport dataType and THEN go to "*" if needed
             */
            transports = {},
            // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
            allTypes = '*/'.concat('*'),
            // Anchor tag for parsing the document origin
            originAnchor = document.createElement('a')

          originAnchor.href = location.href

          // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
          function addToPrefiltersOrTransports(structure) {
            // dataTypeExpression is optional and defaults to "*"
            return function (dataTypeExpression, func) {
              if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression
                dataTypeExpression = '*'
              }

              var dataType,
                i = 0,
                dataTypes =
                  dataTypeExpression.toLowerCase().match(rnothtmlwhite) || []

              if (isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {
                  // Prepend if requested
                  if (dataType[0] === '+') {
                    dataType = dataType.slice(1) || '*'
                    ;(structure[dataType] = structure[dataType] || []).unshift(
                      func
                    )

                    // Otherwise append
                  } else {
                    ;(structure[dataType] = structure[dataType] || []).push(
                      func
                    )
                  }
                }
              }
            }
          }

          // Base inspection function for prefilters and transports
          function inspectPrefiltersOrTransports(
            structure,
            options,
            originalOptions,
            jqXHR
          ) {
            var inspected = {},
              seekingTransport = structure === transports

            function inspect(dataType) {
              var selected
              inspected[dataType] = true
              jQuery.each(
                structure[dataType] || [],
                function (_, prefilterOrFactory) {
                  var dataTypeOrTransport = prefilterOrFactory(
                    options,
                    originalOptions,
                    jqXHR
                  )
                  if (
                    typeof dataTypeOrTransport === 'string' &&
                    !seekingTransport &&
                    !inspected[dataTypeOrTransport]
                  ) {
                    options.dataTypes.unshift(dataTypeOrTransport)
                    inspect(dataTypeOrTransport)
                    return false
                  } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport)
                  }
                }
              )
              return selected
            }

            return (
              inspect(options.dataTypes[0]) || (!inspected['*'] && inspect('*'))
            )
          }

          // A special extend for ajax options
          // that takes "flat" options (not to be deep extended)
          // Fixes #9887
          function ajaxExtend(target, src) {
            var key,
              deep,
              flatOptions = jQuery.ajaxSettings.flatOptions || {}

            for (key in src) {
              if (src[key] !== undefined) {
                ;(flatOptions[key] ? target : deep || (deep = {}))[key] =
                  src[key]
              }
            }
            if (deep) {
              jQuery.extend(true, target, deep)
            }

            return target
          }

          /* Handles responses to an ajax request:
           * - finds the right dataType (mediates between content-type and expected dataType)
           * - returns the corresponding response
           */
          function ajaxHandleResponses(s, jqXHR, responses) {
            var ct,
              type,
              finalDataType,
              firstDataType,
              contents = s.contents,
              dataTypes = s.dataTypes

            // Remove auto dataType and get content-type in the process
            while (dataTypes[0] === '*') {
              dataTypes.shift()
              if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type')
              }
            }

            // Check if we're dealing with a known content-type
            if (ct) {
              for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                  dataTypes.unshift(type)
                  break
                }
              }
            }

            // Check to see if we have a response for the expected dataType
            if (dataTypes[0] in responses) {
              finalDataType = dataTypes[0]
            } else {
              // Try convertible dataTypes
              for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                  finalDataType = type
                  break
                }
                if (!firstDataType) {
                  firstDataType = type
                }
              }

              // Or just use first one
              finalDataType = finalDataType || firstDataType
            }

            // If we found a dataType
            // We add the dataType to the list if needed
            // and return the corresponding response
            if (finalDataType) {
              if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType)
              }
              return responses[finalDataType]
            }
          }

          /* Chain conversions given the request and the original response
           * Also sets the responseXXX fields on the jqXHR instance
           */
          function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2,
              current,
              conv,
              tmp,
              prev,
              converters = {},
              // Work with a copy of dataTypes in case we need to modify it for conversion
              dataTypes = s.dataTypes.slice()

            // Create converters map with lowercased keys
            if (dataTypes[1]) {
              for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv]
              }
            }

            current = dataTypes.shift()

            // Convert to each sequential dataType
            while (current) {
              if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response
              }

              // Apply the dataFilter if provided
              if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType)
              }

              prev = current
              current = dataTypes.shift()

              if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === '*') {
                  current = prev

                  // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== '*' && prev !== current) {
                  // Seek a direct converter
                  conv =
                    converters[prev + ' ' + current] ||
                    converters['* ' + current]

                  // If none found, seek a pair
                  if (!conv) {
                    for (conv2 in converters) {
                      // If conv2 outputs current
                      tmp = conv2.split(' ')
                      if (tmp[1] === current) {
                        // If prev can be converted to accepted input
                        conv =
                          converters[prev + ' ' + tmp[0]] ||
                          converters['* ' + tmp[0]]
                        if (conv) {
                          // Condense equivalence converters
                          if (conv === true) {
                            conv = converters[conv2]

                            // Otherwise, insert the intermediate dataType
                          } else if (converters[conv2] !== true) {
                            current = tmp[0]
                            dataTypes.unshift(tmp[1])
                          }
                          break
                        }
                      }
                    }
                  }

                  // Apply converter (if not an equivalence)
                  if (conv !== true) {
                    // Unless errors are allowed to bubble, catch and return them
                    if (conv && s.throws) {
                      response = conv(response)
                    } else {
                      try {
                        response = conv(response)
                      } catch (e) {
                        return {
                          state: 'parsererror',
                          error: conv
                            ? e
                            : 'No conversion from ' + prev + ' to ' + current
                        }
                      }
                    }
                  }
                }
              }
            }

            return { state: 'success', data: response }
          }

          jQuery.extend({
            // Counter for holding the number of active queries
            active: 0,

            // Last-Modified header cache for next request
            lastModified: {},
            etag: {},

            ajaxSettings: {
              url: location.href,
              type: 'GET',
              isLocal: rlocalProtocol.test(location.protocol),
              global: true,
              processData: true,
              async: true,
              contentType: 'application/x-www-form-urlencoded; charset=UTF-8',

              /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

              accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
              },

              contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
              },

              responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
              },

              // Data converters
              // Keys separate source (or catchall "*") and destination types with a single space
              converters: {
                // Convert anything to text
                '* text': String,

                // Text to html (true = no transformation)
                'text html': true,

                // Evaluate text as a json expression
                'text json': JSON.parse,

                // Parse text as xml
                'text xml': jQuery.parseXML
              },

              // For options that shouldn't be deep extended:
              // you can add your own custom options here if
              // and when you create one that shouldn't be
              // deep extended (see ajaxExtend)
              flatOptions: {
                url: true,
                context: true
              }
            },

            // Creates a full fledged settings object into target
            // with both ajaxSettings and settings fields.
            // If target is omitted, writes into ajaxSettings.
            ajaxSetup: function (target, settings) {
              return settings
                ? // Building a settings object
                  ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
                : // Extending ajaxSettings
                  ajaxExtend(jQuery.ajaxSettings, target)
            },

            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),

            // Main method
            ajax: function (url, options) {
              // If url is an object, simulate pre-1.5 signature
              if (typeof url === 'object') {
                options = url
                url = undefined
              }

              // Force options to be an object
              options = options || {}

              var transport,
                // URL without anti-cache param
                cacheURL,
                // Response headers
                responseHeadersString,
                responseHeaders,
                // timeout handle
                timeoutTimer,
                // Url cleanup var
                urlAnchor,
                // Request state (becomes false upon send and true upon completion)
                completed,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // uncached part of the url
                uncached,
                // Create the final options object
                s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext =
                  s.context &&
                  (callbackContext.nodeType || callbackContext.jquery)
                    ? jQuery(callbackContext)
                    : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks('once memory'),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // Default abort message
                strAbort = 'canceled',
                // Fake xhr
                jqXHR = {
                  readyState: 0,

                  // Builds headers hashtable if needed
                  getResponseHeader: function (key) {
                    var match
                    if (completed) {
                      if (!responseHeaders) {
                        responseHeaders = {}
                        while ((match = rheaders.exec(responseHeadersString))) {
                          responseHeaders[match[1].toLowerCase() + ' '] = (
                            responseHeaders[match[1].toLowerCase() + ' '] || []
                          ).concat(match[2])
                        }
                      }
                      match = responseHeaders[key.toLowerCase() + ' ']
                    }
                    return match == null ? null : match.join(', ')
                  },

                  // Raw string
                  getAllResponseHeaders: function () {
                    return completed ? responseHeadersString : null
                  },

                  // Caches the header
                  setRequestHeader: function (name, value) {
                    if (completed == null) {
                      name = requestHeadersNames[name.toLowerCase()] =
                        requestHeadersNames[name.toLowerCase()] || name
                      requestHeaders[name] = value
                    }
                    return this
                  },

                  // Overrides response content-type header
                  overrideMimeType: function (type) {
                    if (completed == null) {
                      s.mimeType = type
                    }
                    return this
                  },

                  // Status-dependent callbacks
                  statusCode: function (map) {
                    var code
                    if (map) {
                      if (completed) {
                        // Execute the appropriate callbacks
                        jqXHR.always(map[jqXHR.status])
                      } else {
                        // Lazy-add the new callbacks in a way that preserves old ones
                        for (code in map) {
                          statusCode[code] = [statusCode[code], map[code]]
                        }
                      }
                    }
                    return this
                  },

                  // Cancel the request
                  abort: function (statusText) {
                    var finalText = statusText || strAbort
                    if (transport) {
                      transport.abort(finalText)
                    }
                    done(0, finalText)
                    return this
                  }
                }

              // Attach deferreds
              deferred.promise(jqXHR)

              // Add protocol if not provided (prefilters might expect it)
              // Handle falsy url in the settings object (#10093: consistency with old signature)
              // We also use the url parameter if available
              s.url = ((url || s.url || location.href) + '').replace(
                rprotocol,
                location.protocol + '//'
              )

              // Alias method option to type as per ticket #12004
              s.type = options.method || options.type || s.method || s.type

              // Extract dataTypes list
              s.dataTypes = (s.dataType || '*')
                .toLowerCase()
                .match(rnothtmlwhite) || ['']

              // A cross-domain request is in order when the origin doesn't match the current origin.
              if (s.crossDomain == null) {
                urlAnchor = document.createElement('a')

                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                  urlAnchor.href = s.url

                  // Support: IE <=8 - 11 only
                  // Anchor's host property isn't correctly set when s.url is relative
                  urlAnchor.href = urlAnchor.href
                  s.crossDomain =
                    originAnchor.protocol + '//' + originAnchor.host !==
                    urlAnchor.protocol + '//' + urlAnchor.host
                } catch (e) {
                  // If there is an error parsing the URL, assume it is crossDomain,
                  // it can be rejected by the transport if it is invalid
                  s.crossDomain = true
                }
              }

              // Convert data if not already a string
              if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional)
              }

              // Apply prefilters
              inspectPrefiltersOrTransports(prefilters, s, options, jqXHR)

              // If request was aborted inside a prefilter, stop there
              if (completed) {
                return jqXHR
              }

              // We can fire global events as of now if asked to
              // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
              fireGlobals = jQuery.event && s.global

              // Watch for a new set of requests
              if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart')
              }

              // Uppercase the type
              s.type = s.type.toUpperCase()

              // Determine if request has content
              s.hasContent = !rnoContent.test(s.type)

              // Save the URL in case we're toying with the If-Modified-Since
              // and/or If-None-Match header later on
              // Remove hash to simplify url manipulation
              cacheURL = s.url.replace(rhash, '')

              // More options handling for requests with no content
              if (!s.hasContent) {
                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length)

                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === 'string')) {
                  cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data

                  // #9682: remove data so that it's not used in an eventual retry
                  delete s.data
                }

                // Add or update anti-cache param if needed
                if (s.cache === false) {
                  cacheURL = cacheURL.replace(rantiCache, '$1')
                  uncached =
                    (rquery.test(cacheURL) ? '&' : '?') +
                    '_=' +
                    nonce.guid++ +
                    uncached
                }

                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached

                // Change '%20' to '+' if this is encoded form body content (gh-2658)
              } else if (
                s.data &&
                s.processData &&
                (s.contentType || '').indexOf(
                  'application/x-www-form-urlencoded'
                ) === 0
              ) {
                s.data = s.data.replace(r20, '+')
              }

              // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
              if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                  jqXHR.setRequestHeader(
                    'If-Modified-Since',
                    jQuery.lastModified[cacheURL]
                  )
                }
                if (jQuery.etag[cacheURL]) {
                  jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL])
                }
              }

              // Set the correct header, if data is being sent
              if (
                (s.data && s.hasContent && s.contentType !== false) ||
                options.contentType
              ) {
                jqXHR.setRequestHeader('Content-Type', s.contentType)
              }

              // Set the Accepts header for the server, depending on the dataType
              jqXHR.setRequestHeader(
                'Accept',
                s.dataTypes[0] && s.accepts[s.dataTypes[0]]
                  ? s.accepts[s.dataTypes[0]] +
                      (s.dataTypes[0] !== '*'
                        ? ', ' + allTypes + '; q=0.01'
                        : '')
                  : s.accepts['*']
              )

              // Check for headers option
              for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i])
              }

              // Allow custom headers/mimetypes and early abort
              if (
                s.beforeSend &&
                (s.beforeSend.call(callbackContext, jqXHR, s) === false ||
                  completed)
              ) {
                // Abort if not done already and return
                return jqXHR.abort()
              }

              // Aborting is no longer a cancellation
              strAbort = 'abort'

              // Install callbacks on deferreds
              completeDeferred.add(s.complete)
              jqXHR.done(s.success)
              jqXHR.fail(s.error)

              // Get transport
              transport = inspectPrefiltersOrTransports(
                transports,
                s,
                options,
                jqXHR
              )

              // If no transport, we auto-abort
              if (!transport) {
                done(-1, 'No Transport')
              } else {
                jqXHR.readyState = 1

                // Send global event
                if (fireGlobals) {
                  globalEventContext.trigger('ajaxSend', [jqXHR, s])
                }

                // If request was aborted inside ajaxSend, stop there
                if (completed) {
                  return jqXHR
                }

                // Timeout
                if (s.async && s.timeout > 0) {
                  timeoutTimer = window.setTimeout(function () {
                    jqXHR.abort('timeout')
                  }, s.timeout)
                }

                try {
                  completed = false
                  transport.send(requestHeaders, done)
                } catch (e) {
                  // Rethrow post-completion exceptions
                  if (completed) {
                    throw e
                  }

                  // Propagate others as results
                  done(-1, e)
                }
              }

              // Callback for when everything is done
              function done(status, nativeStatusText, responses, headers) {
                var isSuccess,
                  success,
                  error,
                  response,
                  modified,
                  statusText = nativeStatusText

                // Ignore repeat invocations
                if (completed) {
                  return
                }

                completed = true

                // Clear timeout if it exists
                if (timeoutTimer) {
                  window.clearTimeout(timeoutTimer)
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined

                // Cache response headers
                responseHeadersString = headers || ''

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0

                // Determine if successful
                isSuccess = (status >= 200 && status < 300) || status === 304

                // Get response data
                if (responses) {
                  response = ajaxHandleResponses(s, jqXHR, responses)
                }

                // Use a noop converter for missing script but not if jsonp
                if (
                  !isSuccess &&
                  jQuery.inArray('script', s.dataTypes) > -1 &&
                  jQuery.inArray('json', s.dataTypes) < 0
                ) {
                  s.converters['text script'] = function () {}
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess)

                // If successful, handle type chaining
                if (isSuccess) {
                  // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                  if (s.ifModified) {
                    modified = jqXHR.getResponseHeader('Last-Modified')
                    if (modified) {
                      jQuery.lastModified[cacheURL] = modified
                    }
                    modified = jqXHR.getResponseHeader('etag')
                    if (modified) {
                      jQuery.etag[cacheURL] = modified
                    }
                  }

                  // if no content
                  if (status === 204 || s.type === 'HEAD') {
                    statusText = 'nocontent'

                    // if not modified
                  } else if (status === 304) {
                    statusText = 'notmodified'

                    // If we have data, let's convert it
                  } else {
                    statusText = response.state
                    success = response.data
                    error = response.error
                    isSuccess = !error
                  }
                } else {
                  // Extract error from statusText and normalize for non-aborts
                  error = statusText
                  if (status || !statusText) {
                    statusText = 'error'
                    if (status < 0) {
                      status = 0
                    }
                  }
                }

                // Set data for the fake xhr object
                jqXHR.status = status
                jqXHR.statusText = (nativeStatusText || statusText) + ''

                // Success/Error
                if (isSuccess) {
                  deferred.resolveWith(callbackContext, [
                    success,
                    statusText,
                    jqXHR
                  ])
                } else {
                  deferred.rejectWith(callbackContext, [
                    jqXHR,
                    statusText,
                    error
                  ])
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode)
                statusCode = undefined

                if (fireGlobals) {
                  globalEventContext.trigger(
                    isSuccess ? 'ajaxSuccess' : 'ajaxError',
                    [jqXHR, s, isSuccess ? success : error]
                  )
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText])

                if (fireGlobals) {
                  globalEventContext.trigger('ajaxComplete', [jqXHR, s])

                  // Handle the global AJAX counter
                  if (!--jQuery.active) {
                    jQuery.event.trigger('ajaxStop')
                  }
                }
              }

              return jqXHR
            },

            getJSON: function (url, data, callback) {
              return jQuery.get(url, data, callback, 'json')
            },

            getScript: function (url, callback) {
              return jQuery.get(url, undefined, callback, 'script')
            }
          })

          jQuery.each(['get', 'post'], function (_i, method) {
            jQuery[method] = function (url, data, callback, type) {
              // Shift arguments if data argument was omitted
              if (isFunction(data)) {
                type = type || callback
                callback = data
                data = undefined
              }

              // The url can be an options object (which then must have .url)
              return jQuery.ajax(
                jQuery.extend(
                  {
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                  },
                  jQuery.isPlainObject(url) && url
                )
              )
            }
          })

          jQuery.ajaxPrefilter(function (s) {
            var i
            for (i in s.headers) {
              if (i.toLowerCase() === 'content-type') {
                s.contentType = s.headers[i] || ''
              }
            }
          })

          jQuery._evalUrl = function (url, options, doc) {
            return jQuery.ajax({
              url: url,

              // Make this explicit, since user can override this through ajaxSetup (#11264)
              type: 'GET',
              dataType: 'script',
              cache: true,
              async: false,
              global: false,

              // Only evaluate the response if it is successful (gh-4126)
              // dataFilter is not invoked for failure responses, so using it instead
              // of the default converter is kludgy but it works.
              converters: {
                'text script': function () {}
              },
              dataFilter: function (response) {
                jQuery.globalEval(response, options, doc)
              }
            })
          }

          jQuery.fn.extend({
            wrapAll: function (html) {
              var wrap

              if (this[0]) {
                if (isFunction(html)) {
                  html = html.call(this[0])
                }

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true)

                if (this[0].parentNode) {
                  wrap.insertBefore(this[0])
                }

                wrap
                  .map(function () {
                    var elem = this

                    while (elem.firstElementChild) {
                      elem = elem.firstElementChild
                    }

                    return elem
                  })
                  .append(this)
              }

              return this
            },

            wrapInner: function (html) {
              if (isFunction(html)) {
                return this.each(function (i) {
                  jQuery(this).wrapInner(html.call(this, i))
                })
              }

              return this.each(function () {
                var self = jQuery(this),
                  contents = self.contents()

                if (contents.length) {
                  contents.wrapAll(html)
                } else {
                  self.append(html)
                }
              })
            },

            wrap: function (html) {
              var htmlIsFunction = isFunction(html)

              return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
              })
            },

            unwrap: function (selector) {
              this.parent(selector)
                .not('body')
                .each(function () {
                  jQuery(this).replaceWith(this.childNodes)
                })
              return this
            }
          })

          jQuery.expr.pseudos.hidden = function (elem) {
            return !jQuery.expr.pseudos.visible(elem)
          }
          jQuery.expr.pseudos.visible = function (elem) {
            return !!(
              elem.offsetWidth ||
              elem.offsetHeight ||
              elem.getClientRects().length
            )
          }

          jQuery.ajaxSettings.xhr = function () {
            try {
              return new window.XMLHttpRequest()
            } catch (e) {}
          }

          var xhrSuccessStatus = {
              // File protocol always yields status code 0, assume 200
              0: 200,

              // Support: IE <=9 only
              // #1450: sometimes IE returns 1223 when it should be 204
              1223: 204
            },
            xhrSupported = jQuery.ajaxSettings.xhr()

          support.cors = !!xhrSupported && 'withCredentials' in xhrSupported
          support.ajax = xhrSupported = !!xhrSupported

          jQuery.ajaxTransport(function (options) {
            var callback, errorCallback

            // Cross domain only allowed if supported through XMLHttpRequest
            if (support.cors || (xhrSupported && !options.crossDomain)) {
              return {
                send: function (headers, complete) {
                  var i,
                    xhr = options.xhr()

                  xhr.open(
                    options.type,
                    options.url,
                    options.async,
                    options.username,
                    options.password
                  )

                  // Apply custom fields if provided
                  if (options.xhrFields) {
                    for (i in options.xhrFields) {
                      xhr[i] = options.xhrFields[i]
                    }
                  }

                  // Override mime type if needed
                  if (options.mimeType && xhr.overrideMimeType) {
                    xhr.overrideMimeType(options.mimeType)
                  }

                  // X-Requested-With header
                  // For cross-domain requests, seeing as conditions for a preflight are
                  // akin to a jigsaw puzzle, we simply never set it to be sure.
                  // (it can always be set on a per-request basis or even using ajaxSetup)
                  // For same-domain requests, won't change header if already provided.
                  if (!options.crossDomain && !headers['X-Requested-With']) {
                    headers['X-Requested-With'] = 'XMLHttpRequest'
                  }

                  // Set headers
                  for (i in headers) {
                    xhr.setRequestHeader(i, headers[i])
                  }

                  // Callback
                  callback = function (type) {
                    return function () {
                      if (callback) {
                        callback =
                          errorCallback =
                          xhr.onload =
                          xhr.onerror =
                          xhr.onabort =
                          xhr.ontimeout =
                          xhr.onreadystatechange =
                            null

                        if (type === 'abort') {
                          xhr.abort()
                        } else if (type === 'error') {
                          // Support: IE <=9 only
                          // On a manual native abort, IE9 throws
                          // errors on any property access that is not readyState
                          if (typeof xhr.status !== 'number') {
                            complete(0, 'error')
                          } else {
                            complete(
                              // File: protocol always yields status 0; see #8605, #14207
                              xhr.status,
                              xhr.statusText
                            )
                          }
                        } else {
                          complete(
                            xhrSuccessStatus[xhr.status] || xhr.status,
                            xhr.statusText,

                            // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || 'text') !== 'text' ||
                              typeof xhr.responseText !== 'string'
                              ? { binary: xhr.response }
                              : { text: xhr.responseText },
                            xhr.getAllResponseHeaders()
                          )
                        }
                      }
                    }
                  }

                  // Listen to events
                  xhr.onload = callback()
                  errorCallback =
                    xhr.onerror =
                    xhr.ontimeout =
                      callback('error')

                  // Support: IE 9 only
                  // Use onreadystatechange to replace onabort
                  // to handle uncaught aborts
                  if (xhr.onabort !== undefined) {
                    xhr.onabort = errorCallback
                  } else {
                    xhr.onreadystatechange = function () {
                      // Check readyState before timeout as it changes
                      if (xhr.readyState === 4) {
                        // Allow onerror to be called first,
                        // but that will not handle a native abort
                        // Also, save errorCallback to a variable
                        // as xhr.onerror cannot be accessed
                        window.setTimeout(function () {
                          if (callback) {
                            errorCallback()
                          }
                        })
                      }
                    }
                  }

                  // Create the abort callback
                  callback = callback('abort')

                  try {
                    // Do send the request (this may raise an exception)
                    xhr.send((options.hasContent && options.data) || null)
                  } catch (e) {
                    // #14683: Only rethrow if this hasn't been notified as an error yet
                    if (callback) {
                      throw e
                    }
                  }
                },

                abort: function () {
                  if (callback) {
                    callback()
                  }
                }
              }
            }
          })

          // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
          jQuery.ajaxPrefilter(function (s) {
            if (s.crossDomain) {
              s.contents.script = false
            }
          })

          // Install script dataType
          jQuery.ajaxSetup({
            accepts: {
              script:
                'text/javascript, application/javascript, ' +
                'application/ecmascript, application/x-ecmascript'
            },
            contents: {
              script: /\b(?:java|ecma)script\b/
            },
            converters: {
              'text script': function (text) {
                jQuery.globalEval(text)
                return text
              }
            }
          })

          // Handle cache's special case and crossDomain
          jQuery.ajaxPrefilter('script', function (s) {
            if (s.cache === undefined) {
              s.cache = false
            }
            if (s.crossDomain) {
              s.type = 'GET'
            }
          })

          // Bind script tag hack transport
          jQuery.ajaxTransport('script', function (s) {
            // This transport only deals with cross domain or forced-by-attrs requests
            if (s.crossDomain || s.scriptAttrs) {
              var script, callback
              return {
                send: function (_, complete) {
                  script = jQuery('<script>')
                    .attr(s.scriptAttrs || {})
                    .prop({ charset: s.scriptCharset, src: s.url })
                    .on(
                      'load error',
                      (callback = function (evt) {
                        script.remove()
                        callback = null
                        if (evt) {
                          complete(evt.type === 'error' ? 404 : 200, evt.type)
                        }
                      })
                    )

                  // Use native DOM manipulation to avoid our domManip AJAX trickery
                  document.head.appendChild(script[0])
                },
                abort: function () {
                  if (callback) {
                    callback()
                  }
                }
              }
            }
          })

          var oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/

          // Default jsonp settings
          jQuery.ajaxSetup({
            jsonp: 'callback',
            jsonpCallback: function () {
              var callback =
                oldCallbacks.pop() || jQuery.expando + '_' + nonce.guid++
              this[callback] = true
              return callback
            }
          })

          // Detect, normalize options and install callbacks for jsonp requests
          jQuery.ajaxPrefilter(
            'json jsonp',
            function (s, originalSettings, jqXHR) {
              var callbackName,
                overwritten,
                responseContainer,
                jsonProp =
                  s.jsonp !== false &&
                  (rjsonp.test(s.url)
                    ? 'url'
                    : typeof s.data === 'string' &&
                      (s.contentType || '').indexOf(
                        'application/x-www-form-urlencoded'
                      ) === 0 &&
                      rjsonp.test(s.data) &&
                      'data')

              // Handle iff the expected data type is "jsonp" or we have a parameter to set
              if (jsonProp || s.dataTypes[0] === 'jsonp') {
                // Get callback name, remembering preexisting value associated with it
                callbackName = s.jsonpCallback = isFunction(s.jsonpCallback)
                  ? s.jsonpCallback()
                  : s.jsonpCallback

                // Insert callback into url or form data
                if (jsonProp) {
                  s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName)
                } else if (s.jsonp !== false) {
                  s.url +=
                    (rquery.test(s.url) ? '&' : '?') +
                    s.jsonp +
                    '=' +
                    callbackName
                }

                // Use data converter to retrieve json after script execution
                s.converters['script json'] = function () {
                  if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called')
                  }
                  return responseContainer[0]
                }

                // Force json dataType
                s.dataTypes[0] = 'json'

                // Install callback
                overwritten = window[callbackName]
                window[callbackName] = function () {
                  responseContainer = arguments
                }

                // Clean-up function (fires after converters)
                jqXHR.always(function () {
                  // If previous value didn't exist - remove it
                  if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName)

                    // Otherwise restore preexisting value
                  } else {
                    window[callbackName] = overwritten
                  }

                  // Save back as free
                  if (s[callbackName]) {
                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback

                    // Save the callback name for future use
                    oldCallbacks.push(callbackName)
                  }

                  // Call if it was a function and we have a response
                  if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0])
                  }

                  responseContainer = overwritten = undefined
                })

                // Delegate to script
                return 'script'
              }
            }
          )

          // Support: Safari 8 only
          // In Safari 8 documents created via document.implementation.createHTMLDocument
          // collapse sibling forms: the second one becomes a child of the first one.
          // Because of that, this security measure has to be disabled in Safari 8.
          // https://bugs.webkit.org/show_bug.cgi?id=137337
          support.createHTMLDocument = (function () {
            var body = document.implementation.createHTMLDocument('').body
            body.innerHTML = '<form></form><form></form>'
            return body.childNodes.length === 2
          })()

          // Argument "data" should be string of html
          // context (optional): If specified, the fragment will be created in this context,
          // defaults to document
          // keepScripts (optional): If true, will include scripts passed in the html string
          jQuery.parseHTML = function (data, context, keepScripts) {
            if (typeof data !== 'string') {
              return []
            }
            if (typeof context === 'boolean') {
              keepScripts = context
              context = false
            }

            var base, parsed, scripts

            if (!context) {
              // Stop scripts or inline event handlers from being executed immediately
              // by using document.implementation
              if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument('')

                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement('base')
                base.href = document.location.href
                context.head.appendChild(base)
              } else {
                context = document
              }
            }

            parsed = rsingleTag.exec(data)
            scripts = !keepScripts && []

            // Single tag
            if (parsed) {
              return [context.createElement(parsed[1])]
            }

            parsed = buildFragment([data], context, scripts)

            if (scripts && scripts.length) {
              jQuery(scripts).remove()
            }

            return jQuery.merge([], parsed.childNodes)
          }

          /**
           * Load a url into a page
           */
          jQuery.fn.load = function (url, params, callback) {
            var selector,
              type,
              response,
              self = this,
              off = url.indexOf(' ')

            if (off > -1) {
              selector = stripAndCollapse(url.slice(off))
              url = url.slice(0, off)
            }

            // If it's a function
            if (isFunction(params)) {
              // We assume that it's the callback
              callback = params
              params = undefined

              // Otherwise, build a param string
            } else if (params && typeof params === 'object') {
              type = 'POST'
            }

            // If we have elements to modify, make the request
            if (self.length > 0) {
              jQuery
                .ajax({
                  url: url,

                  // If "type" variable is undefined, then "GET" method will be used.
                  // Make value of this field explicit since
                  // user can override it through ajaxSetup method
                  type: type || 'GET',
                  dataType: 'html',
                  data: params
                })
                .done(function (responseText) {
                  // Save response for use in complete callback
                  response = arguments

                  self.html(
                    selector
                      ? // If a selector was specified, locate the right elements in a dummy div
                        // Exclude scripts to avoid IE 'Permission Denied' errors
                        jQuery('<div>')
                          .append(jQuery.parseHTML(responseText))
                          .find(selector)
                      : // Otherwise use the full result
                        responseText
                  )

                  // If the request succeeds, this function gets "data", "status", "jqXHR"
                  // but they are ignored because response was set above.
                  // If it fails, this function gets "jqXHR", "status", "error"
                })
                .always(
                  callback &&
                    function (jqXHR, status) {
                      self.each(function () {
                        callback.apply(
                          this,
                          response || [jqXHR.responseText, status, jqXHR]
                        )
                      })
                    }
                )
            }

            return this
          }

          jQuery.expr.pseudos.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
              return elem === fn.elem
            }).length
          }

          jQuery.offset = {
            setOffset: function (elem, options, i) {
              var curPosition,
                curLeft,
                curCSSTop,
                curTop,
                curOffset,
                curCSSLeft,
                calculatePosition,
                position = jQuery.css(elem, 'position'),
                curElem = jQuery(elem),
                props = {}

              // Set position first, in-case top/left are set even on static elem
              if (position === 'static') {
                elem.style.position = 'relative'
              }

              curOffset = curElem.offset()
              curCSSTop = jQuery.css(elem, 'top')
              curCSSLeft = jQuery.css(elem, 'left')
              calculatePosition =
                (position === 'absolute' || position === 'fixed') &&
                (curCSSTop + curCSSLeft).indexOf('auto') > -1

              // Need to be able to calculate position if either
              // top or left is auto and position is either absolute or fixed
              if (calculatePosition) {
                curPosition = curElem.position()
                curTop = curPosition.top
                curLeft = curPosition.left
              } else {
                curTop = parseFloat(curCSSTop) || 0
                curLeft = parseFloat(curCSSLeft) || 0
              }

              if (isFunction(options)) {
                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call(elem, i, jQuery.extend({}, curOffset))
              }

              if (options.top != null) {
                props.top = options.top - curOffset.top + curTop
              }
              if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft
              }

              if ('using' in options) {
                options.using.call(elem, props)
              } else {
                curElem.css(props)
              }
            }
          }

          jQuery.fn.extend({
            // offset() relates an element's border box to the document origin
            offset: function (options) {
              // Preserve chaining for setter
              if (arguments.length) {
                return options === undefined
                  ? this
                  : this.each(function (i) {
                      jQuery.offset.setOffset(this, options, i)
                    })
              }

              var rect,
                win,
                elem = this[0]

              if (!elem) {
                return
              }

              // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
              // Support: IE <=11 only
              // Running getBoundingClientRect on a
              // disconnected node in IE throws an error
              if (!elem.getClientRects().length) {
                return { top: 0, left: 0 }
              }

              // Get document-relative position by adding viewport scroll to viewport-relative gBCR
              rect = elem.getBoundingClientRect()
              win = elem.ownerDocument.defaultView
              return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
              }
            },

            // position() relates an element's margin box to its offset parent's padding box
            // This corresponds to the behavior of CSS absolute positioning
            position: function () {
              if (!this[0]) {
                return
              }

              var offsetParent,
                offset,
                doc,
                elem = this[0],
                parentOffset = { top: 0, left: 0 }

              // position:fixed elements are offset from the viewport, which itself always has zero offset
              if (jQuery.css(elem, 'position') === 'fixed') {
                // Assume position:fixed implies availability of getBoundingClientRect
                offset = elem.getBoundingClientRect()
              } else {
                offset = this.offset()

                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument
                offsetParent = elem.offsetParent || doc.documentElement
                while (
                  offsetParent &&
                  (offsetParent === doc.body ||
                    offsetParent === doc.documentElement) &&
                  jQuery.css(offsetParent, 'position') === 'static'
                ) {
                  offsetParent = offsetParent.parentNode
                }
                if (
                  offsetParent &&
                  offsetParent !== elem &&
                  offsetParent.nodeType === 1
                ) {
                  // Incorporate borders into its offset, since they are outside its content origin
                  parentOffset = jQuery(offsetParent).offset()
                  parentOffset.top += jQuery.css(
                    offsetParent,
                    'borderTopWidth',
                    true
                  )
                  parentOffset.left += jQuery.css(
                    offsetParent,
                    'borderLeftWidth',
                    true
                  )
                }
              }

              // Subtract parent offsets and element margins
              return {
                top:
                  offset.top -
                  parentOffset.top -
                  jQuery.css(elem, 'marginTop', true),
                left:
                  offset.left -
                  parentOffset.left -
                  jQuery.css(elem, 'marginLeft', true)
              }
            },

            // This method will return documentElement in the following cases:
            // 1) For the element inside the iframe without offsetParent, this method will return
            //    documentElement of the parent window
            // 2) For the hidden or detached element
            // 3) For body or html element, i.e. in case of the html node - it will return itself
            //
            // but those exceptions were never presented as a real life use-cases
            // and might be considered as more preferable results.
            //
            // This logic, however, is not guaranteed and can change at any point in the future
            offsetParent: function () {
              return this.map(function () {
                var offsetParent = this.offsetParent

                while (
                  offsetParent &&
                  jQuery.css(offsetParent, 'position') === 'static'
                ) {
                  offsetParent = offsetParent.offsetParent
                }

                return offsetParent || documentElement
              })
            }
          })

          // Create scrollLeft and scrollTop methods
          jQuery.each(
            { scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' },
            function (method, prop) {
              var top = 'pageYOffset' === prop

              jQuery.fn[method] = function (val) {
                return access(
                  this,
                  function (elem, method, val) {
                    // Coalesce documents and windows
                    var win
                    if (isWindow(elem)) {
                      win = elem
                    } else if (elem.nodeType === 9) {
                      win = elem.defaultView
                    }

                    if (val === undefined) {
                      return win ? win[prop] : elem[method]
                    }

                    if (win) {
                      win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                      )
                    } else {
                      elem[method] = val
                    }
                  },
                  method,
                  val,
                  arguments.length
                )
              }
            }
          )

          // Support: Safari <=7 - 9.1, Chrome <=37 - 49
          // Add the top/left cssHooks using jQuery.fn.position
          // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
          // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
          // getComputedStyle returns percent when specified for top/left/bottom/right;
          // rather than make the css module depend on the offset module, just check for it here
          jQuery.each(['top', 'left'], function (_i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(
              support.pixelPosition,
              function (elem, computed) {
                if (computed) {
                  computed = curCSS(elem, prop)

                  // If curCSS returns percentage, fallback to offset
                  return rnumnonpx.test(computed)
                    ? jQuery(elem).position()[prop] + 'px'
                    : computed
                }
              }
            )
          })

          // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
          jQuery.each(
            { Height: 'height', Width: 'width' },
            function (name, type) {
              jQuery.each(
                {
                  padding: 'inner' + name,
                  content: type,
                  '': 'outer' + name
                },
                function (defaultExtra, funcName) {
                  // Margin is only for outerHeight, outerWidth
                  jQuery.fn[funcName] = function (margin, value) {
                    var chainable =
                        arguments.length &&
                        (defaultExtra || typeof margin !== 'boolean'),
                      extra =
                        defaultExtra ||
                        (margin === true || value === true
                          ? 'margin'
                          : 'border')

                    return access(
                      this,
                      function (elem, type, value) {
                        var doc

                        if (isWindow(elem)) {
                          // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                          return funcName.indexOf('outer') === 0
                            ? elem['inner' + name]
                            : elem.document.documentElement['client' + name]
                        }

                        // Get document width or height
                        if (elem.nodeType === 9) {
                          doc = elem.documentElement

                          // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                          // whichever is greatest
                          return Math.max(
                            elem.body['scroll' + name],
                            doc['scroll' + name],
                            elem.body['offset' + name],
                            doc['offset' + name],
                            doc['client' + name]
                          )
                        }

                        return value === undefined
                          ? // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css(elem, type, extra)
                          : // Set width or height on the element
                            jQuery.style(elem, type, value, extra)
                      },
                      type,
                      chainable ? margin : undefined,
                      chainable
                    )
                  }
                }
              )
            }
          )

          jQuery.each(
            [
              'ajaxStart',
              'ajaxStop',
              'ajaxComplete',
              'ajaxError',
              'ajaxSuccess',
              'ajaxSend'
            ],
            function (_i, type) {
              jQuery.fn[type] = function (fn) {
                return this.on(type, fn)
              }
            }
          )

          jQuery.fn.extend({
            bind: function (types, data, fn) {
              return this.on(types, null, data, fn)
            },
            unbind: function (types, fn) {
              return this.off(types, null, fn)
            },

            delegate: function (selector, types, data, fn) {
              return this.on(types, selector, data, fn)
            },
            undelegate: function (selector, types, fn) {
              // ( namespace ) or ( selector, types [, fn] )
              return arguments.length === 1
                ? this.off(selector, '**')
                : this.off(types, selector || '**', fn)
            },

            hover: function (fnOver, fnOut) {
              return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
            }
          })

          jQuery.each(
            (
              'blur focus focusin focusout resize scroll click dblclick ' +
              'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
              'change select submit keydown keypress keyup contextmenu'
            ).split(' '),
            function (_i, name) {
              // Handle event binding
              jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0
                  ? this.on(name, null, data, fn)
                  : this.trigger(name)
              }
            }
          )

          // Support: Android <=4.0 only
          // Make sure we trim BOM and NBSP
          var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g

          // Bind a function to a context, optionally partially applying any
          // arguments.
          // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
          // However, it is not slated for removal any time soon
          jQuery.proxy = function (fn, context) {
            var tmp, args, proxy

            if (typeof context === 'string') {
              tmp = fn[context]
              context = fn
              fn = tmp
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!isFunction(fn)) {
              return undefined
            }

            // Simulated bind
            args = slice.call(arguments, 2)
            proxy = function () {
              return fn.apply(
                context || this,
                args.concat(slice.call(arguments))
              )
            }

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++

            return proxy
          }

          jQuery.holdReady = function (hold) {
            if (hold) {
              jQuery.readyWait++
            } else {
              jQuery.ready(true)
            }
          }
          jQuery.isArray = Array.isArray
          jQuery.parseJSON = JSON.parse
          jQuery.nodeName = nodeName
          jQuery.isFunction = isFunction
          jQuery.isWindow = isWindow
          jQuery.camelCase = camelCase
          jQuery.type = toType

          jQuery.now = Date.now

          jQuery.isNumeric = function (obj) {
            // As of jQuery 3.0, isNumeric is limited to
            // strings and numbers (primitives or objects)
            // that can be coerced to finite numbers (gh-2662)
            var type = jQuery.type(obj)
            return (
              (type === 'number' || type === 'string') &&
              // parseFloat NaNs numeric-cast false positives ("")
              // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
              // subtraction forces infinities to NaN
              !isNaN(obj - parseFloat(obj))
            )
          }

          jQuery.trim = function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '')
          }

          // Register as a named AMD module, since jQuery can be concatenated with other
          // files that may use define, but not via a proper concatenation script that
          // understands anonymous AMD modules. A named AMD is safest and most robust
          // way to register. Lowercase jquery is used because AMD module names are
          // derived from file names, and jQuery is normally delivered in a lowercase
          // file name. Do this after creating the global so that if an AMD module wants
          // to call noConflict to hide this version of jQuery, it will work.

          // Note that for maximum portability, libraries that are not jQuery should
          // declare themselves as anonymous modules, and avoid setting a global if an
          // AMD loader is present. jQuery is a special case. For more information, see
          // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

          if (true) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
              return jQuery
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
          }

          var // Map over jQuery in case of overwrite
            _jQuery = window.jQuery,
            // Map over the $ in case of overwrite
            _$ = window.$

          jQuery.noConflict = function (deep) {
            if (window.$ === jQuery) {
              window.$ = _$
            }

            if (deep && window.jQuery === jQuery) {
              window.jQuery = _jQuery
            }

            return jQuery
          }

          // Expose jQuery and $ identifiers, even in AMD
          // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
          // and CommonJS for browser emulators (#13566)
          if (typeof noGlobal === 'undefined') {
            window.jQuery = window.$ = jQuery
          }

          return jQuery
        }
      )

      /***/
    },

    /***/ 9461: /***/ (module) => {
      'use strict'

      var traverse = (module.exports = function (schema, opts, cb) {
        // Legacy support for v0.3.1 and earlier.
        if (typeof opts == 'function') {
          cb = opts
          opts = {}
        }

        cb = opts.cb || cb
        var pre = typeof cb == 'function' ? cb : cb.pre || function () {}
        var post = cb.post || function () {}

        _traverse(opts, pre, post, schema, '', schema)
      })

      traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
        if: true,
        then: true,
        else: true
      }

      traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      }

      traverse.propsKeywords = {
        $defs: true,
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      }

      traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      }

      function _traverse(
        opts,
        pre,
        post,
        schema,
        jsonPtr,
        rootSchema,
        parentJsonPtr,
        parentKeyword,
        parentSchema,
        keyIndex
      ) {
        if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
          pre(
            schema,
            jsonPtr,
            rootSchema,
            parentJsonPtr,
            parentKeyword,
            parentSchema,
            keyIndex
          )
          for (var key in schema) {
            var sch = schema[key]
            if (Array.isArray(sch)) {
              if (key in traverse.arrayKeywords) {
                for (var i = 0; i < sch.length; i++)
                  _traverse(
                    opts,
                    pre,
                    post,
                    sch[i],
                    jsonPtr + '/' + key + '/' + i,
                    rootSchema,
                    jsonPtr,
                    key,
                    schema,
                    i
                  )
              }
            } else if (key in traverse.propsKeywords) {
              if (sch && typeof sch == 'object') {
                for (var prop in sch)
                  _traverse(
                    opts,
                    pre,
                    post,
                    sch[prop],
                    jsonPtr + '/' + key + '/' + escapeJsonPtr(prop),
                    rootSchema,
                    jsonPtr,
                    key,
                    schema,
                    prop
                  )
              }
            } else if (
              key in traverse.keywords ||
              (opts.allKeys && !(key in traverse.skipKeywords))
            ) {
              _traverse(
                opts,
                pre,
                post,
                sch,
                jsonPtr + '/' + key,
                rootSchema,
                jsonPtr,
                key,
                schema
              )
            }
          }
          post(
            schema,
            jsonPtr,
            rootSchema,
            parentJsonPtr,
            parentKeyword,
            parentSchema,
            keyIndex
          )
        }
      }

      function escapeJsonPtr(str) {
        return str.replace(/~/g, '~0').replace(/\//g, '~1')
      }

      /***/
    },

    /***/ 2837: /***/ () => {
      /***/
    },

    /***/ 5311: /***/ function (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      ;(function (global, factory) {
        true ? factory(exports, __webpack_require__(2837)) : 0
      })(this, function (exports, chalk) {
        'use strict'

        chalk =
          chalk && chalk.hasOwnProperty('default') ? chalk['default'] : chalk

        var _typeof =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (obj) {
                return typeof obj
              }
            : function (obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }

        var classCallCheck = function (instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function')
          }
        }

        var createClass = (function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i]
              descriptor.enumerable = descriptor.enumerable || false
              descriptor.configurable = true
              if ('value' in descriptor) descriptor.writable = true
              Object.defineProperty(target, descriptor.key, descriptor)
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps)
            if (staticProps) defineProperties(Constructor, staticProps)
            return Constructor
          }
        })()

        var get = function get(object, property, receiver) {
          if (object === null) object = Function.prototype
          var desc = Object.getOwnPropertyDescriptor(object, property)

          if (desc === undefined) {
            var parent = Object.getPrototypeOf(object)

            if (parent === null) {
              return undefined
            } else {
              return get(parent, property, receiver)
            }
          } else if ('value' in desc) {
            return desc.value
          } else {
            var getter = desc.get

            if (getter === undefined) {
              return undefined
            }

            return getter.call(receiver)
          }
        }

        var inherits = function (subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError(
              'Super expression must either be null or a function, not ' +
                typeof superClass
            )
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            }
          )
          if (superClass)
            Object.setPrototypeOf
              ? Object.setPrototypeOf(subClass, superClass)
              : (subClass.__proto__ = superClass)
        }

        var possibleConstructorReturn = function (self, call) {
          if (!self) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            )
          }

          return call &&
            (typeof call === 'object' || typeof call === 'function')
            ? call
            : self
        }

        var slicedToArray = (function () {
          function sliceIterator(arr, i) {
            var _arr = []
            var _n = true
            var _d = false
            var _e = undefined

            try {
              for (
                var _i = arr[Symbol.iterator](), _s;
                !(_n = (_s = _i.next()).done);
                _n = true
              ) {
                _arr.push(_s.value)

                if (i && _arr.length === i) break
              }
            } catch (err) {
              _d = true
              _e = err
            } finally {
              try {
                if (!_n && _i['return']) _i['return']()
              } finally {
                if (_d) throw _e
              }
            }

            return _arr
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i)
            } else {
              throw new TypeError(
                'Invalid attempt to destructure non-iterable instance'
              )
            }
          }
        })()

        var toConsumableArray = function (arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
              arr2[i] = arr[i]

            return arr2
          } else {
            return Array.from(arr)
          }
        }

        var Processor = (function () {
          function Processor(options) {
            classCallCheck(this, Processor)

            this.selfOptions = options || {}
            this.pipes = {}
          }

          createClass(Processor, [
            {
              key: 'options',
              value: function options(_options) {
                if (_options) {
                  this.selfOptions = _options
                }
                return this.selfOptions
              }
            },
            {
              key: 'pipe',
              value: function pipe(name, pipeArg) {
                var pipe = pipeArg
                if (typeof name === 'string') {
                  if (typeof pipe === 'undefined') {
                    return this.pipes[name]
                  } else {
                    this.pipes[name] = pipe
                  }
                }
                if (name && name.name) {
                  pipe = name
                  if (pipe.processor === this) {
                    return pipe
                  }
                  this.pipes[pipe.name] = pipe
                }
                pipe.processor = this
                return pipe
              }
            },
            {
              key: 'process',
              value: function process(input, pipe) {
                var context = input
                context.options = this.options()
                var nextPipe = pipe || input.pipe || 'default'
                var lastPipe = void 0
                var lastContext = void 0
                while (nextPipe) {
                  if (typeof context.nextAfterChildren !== 'undefined') {
                    // children processed and coming back to parent
                    context.next = context.nextAfterChildren
                    context.nextAfterChildren = null
                  }

                  if (typeof nextPipe === 'string') {
                    nextPipe = this.pipe(nextPipe)
                  }
                  nextPipe.process(context)
                  lastContext = context
                  lastPipe = nextPipe
                  nextPipe = null
                  if (context) {
                    if (context.next) {
                      context = context.next
                      nextPipe =
                        lastContext.nextPipe || context.pipe || lastPipe
                    }
                  }
                }
                return context.hasResult ? context.result : undefined
              }
            }
          ])
          return Processor
        })()

        var Pipe = (function () {
          function Pipe(name) {
            classCallCheck(this, Pipe)

            this.name = name
            this.filters = []
          }

          createClass(Pipe, [
            {
              key: 'process',
              value: function process(input) {
                if (!this.processor) {
                  throw new Error(
                    'add this pipe to a processor before using it'
                  )
                }
                var debug = this.debug
                var length = this.filters.length
                var context = input
                for (var index = 0; index < length; index++) {
                  var filter = this.filters[index]
                  if (debug) {
                    this.log('filter: ' + filter.filterName)
                  }
                  filter(context)
                  if (
                    (typeof context === 'undefined'
                      ? 'undefined'
                      : _typeof(context)) === 'object' &&
                    context.exiting
                  ) {
                    context.exiting = false
                    break
                  }
                }
                if (!context.next && this.resultCheck) {
                  this.resultCheck(context)
                }
              }
            },
            {
              key: 'log',
              value: function log(msg) {
                console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg)
              }
            },
            {
              key: 'append',
              value: function append() {
                var _filters

                ;(_filters = this.filters).push.apply(_filters, arguments)
                return this
              }
            },
            {
              key: 'prepend',
              value: function prepend() {
                var _filters2

                ;(_filters2 = this.filters).unshift.apply(_filters2, arguments)
                return this
              }
            },
            {
              key: 'indexOf',
              value: function indexOf(filterName) {
                if (!filterName) {
                  throw new Error('a filter name is required')
                }
                for (var index = 0; index < this.filters.length; index++) {
                  var filter = this.filters[index]
                  if (filter.filterName === filterName) {
                    return index
                  }
                }
                throw new Error('filter not found: ' + filterName)
              }
            },
            {
              key: 'list',
              value: function list() {
                return this.filters.map(function (f) {
                  return f.filterName
                })
              }
            },
            {
              key: 'after',
              value: function after(filterName) {
                var index = this.indexOf(filterName)
                var params = Array.prototype.slice.call(arguments, 1)
                if (!params.length) {
                  throw new Error('a filter is required')
                }
                params.unshift(index + 1, 0)
                Array.prototype.splice.apply(this.filters, params)
                return this
              }
            },
            {
              key: 'before',
              value: function before(filterName) {
                var index = this.indexOf(filterName)
                var params = Array.prototype.slice.call(arguments, 1)
                if (!params.length) {
                  throw new Error('a filter is required')
                }
                params.unshift(index, 0)
                Array.prototype.splice.apply(this.filters, params)
                return this
              }
            },
            {
              key: 'replace',
              value: function replace(filterName) {
                var index = this.indexOf(filterName)
                var params = Array.prototype.slice.call(arguments, 1)
                if (!params.length) {
                  throw new Error('a filter is required')
                }
                params.unshift(index, 1)
                Array.prototype.splice.apply(this.filters, params)
                return this
              }
            },
            {
              key: 'remove',
              value: function remove(filterName) {
                var index = this.indexOf(filterName)
                this.filters.splice(index, 1)
                return this
              }
            },
            {
              key: 'clear',
              value: function clear() {
                this.filters.length = 0
                return this
              }
            },
            {
              key: 'shouldHaveResult',
              value: function shouldHaveResult(should) {
                if (should === false) {
                  this.resultCheck = null
                  return
                }
                if (this.resultCheck) {
                  return
                }
                var pipe = this
                this.resultCheck = function (context) {
                  if (!context.hasResult) {
                    console.log(context)
                    var error = new Error(pipe.name + ' failed')
                    error.noResult = true
                    throw error
                  }
                }
                return this
              }
            }
          ])
          return Pipe
        })()

        var Context = (function () {
          function Context() {
            classCallCheck(this, Context)
          }

          createClass(Context, [
            {
              key: 'setResult',
              value: function setResult(result) {
                this.result = result
                this.hasResult = true
                return this
              }
            },
            {
              key: 'exit',
              value: function exit() {
                this.exiting = true
                return this
              }
            },
            {
              key: 'switchTo',
              value: function switchTo(next, pipe) {
                if (typeof next === 'string' || next instanceof Pipe) {
                  this.nextPipe = next
                } else {
                  this.next = next
                  if (pipe) {
                    this.nextPipe = pipe
                  }
                }
                return this
              }
            },
            {
              key: 'push',
              value: function push(child, name) {
                child.parent = this
                if (typeof name !== 'undefined') {
                  child.childName = name
                }
                child.root = this.root || this
                child.options = child.options || this.options
                if (!this.children) {
                  this.children = [child]
                  this.nextAfterChildren = this.next || null
                  this.next = child
                } else {
                  this.children[this.children.length - 1].next = child
                  this.children.push(child)
                }
                child.next = this
                return this
              }
            }
          ])
          return Context
        })()

        var isArray =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : function (a) {
                return a instanceof Array
              }

        function cloneRegExp(re) {
          var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString())
          return new RegExp(regexMatch[1], regexMatch[2])
        }

        function clone(arg) {
          if (
            (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !==
            'object'
          ) {
            return arg
          }
          if (arg === null) {
            return null
          }
          if (isArray(arg)) {
            return arg.map(clone)
          }
          if (arg instanceof Date) {
            return new Date(arg.getTime())
          }
          if (arg instanceof RegExp) {
            return cloneRegExp(arg)
          }
          var cloned = {}
          for (var name in arg) {
            if (Object.prototype.hasOwnProperty.call(arg, name)) {
              cloned[name] = clone(arg[name])
            }
          }
          return cloned
        }

        var DiffContext = (function (_Context) {
          inherits(DiffContext, _Context)

          function DiffContext(left, right) {
            classCallCheck(this, DiffContext)

            var _this = possibleConstructorReturn(
              this,
              (
                DiffContext.__proto__ || Object.getPrototypeOf(DiffContext)
              ).call(this)
            )

            _this.left = left
            _this.right = right
            _this.pipe = 'diff'
            return _this
          }

          createClass(DiffContext, [
            {
              key: 'setResult',
              value: function setResult(result) {
                if (
                  this.options.cloneDiffValues &&
                  (typeof result === 'undefined'
                    ? 'undefined'
                    : _typeof(result)) === 'object'
                ) {
                  var clone$$1 =
                    typeof this.options.cloneDiffValues === 'function'
                      ? this.options.cloneDiffValues
                      : clone
                  if (_typeof(result[0]) === 'object') {
                    result[0] = clone$$1(result[0])
                  }
                  if (_typeof(result[1]) === 'object') {
                    result[1] = clone$$1(result[1])
                  }
                }
                return Context.prototype.setResult.apply(this, arguments)
              }
            }
          ])
          return DiffContext
        })(Context)

        var PatchContext = (function (_Context) {
          inherits(PatchContext, _Context)

          function PatchContext(left, delta) {
            classCallCheck(this, PatchContext)

            var _this = possibleConstructorReturn(
              this,
              (
                PatchContext.__proto__ || Object.getPrototypeOf(PatchContext)
              ).call(this)
            )

            _this.left = left
            _this.delta = delta
            _this.pipe = 'patch'
            return _this
          }

          return PatchContext
        })(Context)

        var ReverseContext = (function (_Context) {
          inherits(ReverseContext, _Context)

          function ReverseContext(delta) {
            classCallCheck(this, ReverseContext)

            var _this = possibleConstructorReturn(
              this,
              (
                ReverseContext.__proto__ ||
                Object.getPrototypeOf(ReverseContext)
              ).call(this)
            )

            _this.delta = delta
            _this.pipe = 'reverse'
            return _this
          }

          return ReverseContext
        })(Context)

        var isArray$1 =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : function (a) {
                return a instanceof Array
              }

        var diffFilter = function trivialMatchesDiffFilter(context) {
          if (context.left === context.right) {
            context.setResult(undefined).exit()
            return
          }
          if (typeof context.left === 'undefined') {
            if (typeof context.right === 'function') {
              throw new Error('functions are not supported')
            }
            context.setResult([context.right]).exit()
            return
          }
          if (typeof context.right === 'undefined') {
            context.setResult([context.left, 0, 0]).exit()
            return
          }
          if (
            typeof context.left === 'function' ||
            typeof context.right === 'function'
          ) {
            throw new Error('functions are not supported')
          }
          context.leftType =
            context.left === null ? 'null' : _typeof(context.left)
          context.rightType =
            context.right === null ? 'null' : _typeof(context.right)
          if (context.leftType !== context.rightType) {
            context.setResult([context.left, context.right]).exit()
            return
          }
          if (context.leftType === 'boolean' || context.leftType === 'number') {
            context.setResult([context.left, context.right]).exit()
            return
          }
          if (context.leftType === 'object') {
            context.leftIsArray = isArray$1(context.left)
          }
          if (context.rightType === 'object') {
            context.rightIsArray = isArray$1(context.right)
          }
          if (context.leftIsArray !== context.rightIsArray) {
            context.setResult([context.left, context.right]).exit()
            return
          }

          if (context.left instanceof RegExp) {
            if (context.right instanceof RegExp) {
              context
                .setResult([context.left.toString(), context.right.toString()])
                .exit()
            } else {
              context.setResult([context.left, context.right]).exit()
            }
          }
        }
        diffFilter.filterName = 'trivial'

        var patchFilter = function trivialMatchesPatchFilter(context) {
          if (typeof context.delta === 'undefined') {
            context.setResult(context.left).exit()
            return
          }
          context.nested = !isArray$1(context.delta)
          if (context.nested) {
            return
          }
          if (context.delta.length === 1) {
            context.setResult(context.delta[0]).exit()
            return
          }
          if (context.delta.length === 2) {
            if (context.left instanceof RegExp) {
              var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1])
              if (regexArgs) {
                context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit()
                return
              }
            }
            context.setResult(context.delta[1]).exit()
            return
          }
          if (context.delta.length === 3 && context.delta[2] === 0) {
            context.setResult(undefined).exit()
          }
        }
        patchFilter.filterName = 'trivial'

        var reverseFilter = function trivialReferseFilter(context) {
          if (typeof context.delta === 'undefined') {
            context.setResult(context.delta).exit()
            return
          }
          context.nested = !isArray$1(context.delta)
          if (context.nested) {
            return
          }
          if (context.delta.length === 1) {
            context.setResult([context.delta[0], 0, 0]).exit()
            return
          }
          if (context.delta.length === 2) {
            context.setResult([context.delta[1], context.delta[0]]).exit()
            return
          }
          if (context.delta.length === 3 && context.delta[2] === 0) {
            context.setResult([context.delta[0]]).exit()
          }
        }
        reverseFilter.filterName = 'trivial'

        function collectChildrenDiffFilter(context) {
          if (!context || !context.children) {
            return
          }
          var length = context.children.length
          var child = void 0
          var result = context.result
          for (var index = 0; index < length; index++) {
            child = context.children[index]
            if (typeof child.result === 'undefined') {
              continue
            }
            result = result || {}
            result[child.childName] = child.result
          }
          if (result && context.leftIsArray) {
            result._t = 'a'
          }
          context.setResult(result).exit()
        }
        collectChildrenDiffFilter.filterName = 'collectChildren'

        function objectsDiffFilter(context) {
          if (context.leftIsArray || context.leftType !== 'object') {
            return
          }

          var name = void 0
          var child = void 0
          var propertyFilter = context.options.propertyFilter
          for (name in context.left) {
            if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
              continue
            }
            if (propertyFilter && !propertyFilter(name, context)) {
              continue
            }
            child = new DiffContext(context.left[name], context.right[name])
            context.push(child, name)
          }
          for (name in context.right) {
            if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
              continue
            }
            if (propertyFilter && !propertyFilter(name, context)) {
              continue
            }
            if (typeof context.left[name] === 'undefined') {
              child = new DiffContext(undefined, context.right[name])
              context.push(child, name)
            }
          }

          if (!context.children || context.children.length === 0) {
            context.setResult(undefined).exit()
            return
          }
          context.exit()
        }
        objectsDiffFilter.filterName = 'objects'

        var patchFilter$1 = function nestedPatchFilter(context) {
          if (!context.nested) {
            return
          }
          if (context.delta._t) {
            return
          }
          var name = void 0
          var child = void 0
          for (name in context.delta) {
            child = new PatchContext(context.left[name], context.delta[name])
            context.push(child, name)
          }
          context.exit()
        }
        patchFilter$1.filterName = 'objects'

        var collectChildrenPatchFilter = function collectChildrenPatchFilter(
          context
        ) {
          if (!context || !context.children) {
            return
          }
          if (context.delta._t) {
            return
          }
          var length = context.children.length
          var child = void 0
          for (var index = 0; index < length; index++) {
            child = context.children[index]
            if (
              Object.prototype.hasOwnProperty.call(
                context.left,
                child.childName
              ) &&
              child.result === undefined
            ) {
              delete context.left[child.childName]
            } else if (context.left[child.childName] !== child.result) {
              context.left[child.childName] = child.result
            }
          }
          context.setResult(context.left).exit()
        }
        collectChildrenPatchFilter.filterName = 'collectChildren'

        var reverseFilter$1 = function nestedReverseFilter(context) {
          if (!context.nested) {
            return
          }
          if (context.delta._t) {
            return
          }
          var name = void 0
          var child = void 0
          for (name in context.delta) {
            child = new ReverseContext(context.delta[name])
            context.push(child, name)
          }
          context.exit()
        }
        reverseFilter$1.filterName = 'objects'

        function collectChildrenReverseFilter(context) {
          if (!context || !context.children) {
            return
          }
          if (context.delta._t) {
            return
          }
          var length = context.children.length
          var child = void 0
          var delta = {}
          for (var index = 0; index < length; index++) {
            child = context.children[index]
            if (delta[child.childName] !== child.result) {
              delta[child.childName] = child.result
            }
          }
          context.setResult(delta).exit()
        }
        collectChildrenReverseFilter.filterName = 'collectChildren'

        /*

LCS implementation that supports arrays or strings

reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

*/

        var defaultMatch = function defaultMatch(
          array1,
          array2,
          index1,
          index2
        ) {
          return array1[index1] === array2[index2]
        }

        var lengthMatrix = function lengthMatrix(
          array1,
          array2,
          match,
          context
        ) {
          var len1 = array1.length
          var len2 = array2.length
          var x = void 0,
            y = void 0

          // initialize empty matrix of len1+1 x len2+1
          var matrix = [len1 + 1]
          for (x = 0; x < len1 + 1; x++) {
            matrix[x] = [len2 + 1]
            for (y = 0; y < len2 + 1; y++) {
              matrix[x][y] = 0
            }
          }
          matrix.match = match
          // save sequence lengths for each coordinate
          for (x = 1; x < len1 + 1; x++) {
            for (y = 1; y < len2 + 1; y++) {
              if (match(array1, array2, x - 1, y - 1, context)) {
                matrix[x][y] = matrix[x - 1][y - 1] + 1
              } else {
                matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1])
              }
            }
          }
          return matrix
        }

        var backtrack = function backtrack(matrix, array1, array2, context) {
          var index1 = array1.length
          var index2 = array2.length
          var subsequence = {
            sequence: [],
            indices1: [],
            indices2: []
          }

          while (index1 !== 0 && index2 !== 0) {
            var sameLetter = matrix.match(
              array1,
              array2,
              index1 - 1,
              index2 - 1,
              context
            )
            if (sameLetter) {
              subsequence.sequence.unshift(array1[index1 - 1])
              subsequence.indices1.unshift(index1 - 1)
              subsequence.indices2.unshift(index2 - 1)
              --index1
              --index2
            } else {
              var valueAtMatrixAbove = matrix[index1][index2 - 1]
              var valueAtMatrixLeft = matrix[index1 - 1][index2]
              if (valueAtMatrixAbove > valueAtMatrixLeft) {
                --index2
              } else {
                --index1
              }
            }
          }
          return subsequence
        }

        var get$1 = function get(array1, array2, match, context) {
          var innerContext = context || {}
          var matrix = lengthMatrix(
            array1,
            array2,
            match || defaultMatch,
            innerContext
          )
          var result = backtrack(matrix, array1, array2, innerContext)
          if (typeof array1 === 'string' && typeof array2 === 'string') {
            result.sequence = result.sequence.join('')
          }
          return result
        }

        var lcs = {
          get: get$1
        }

        var ARRAY_MOVE = 3

        var isArray$2 =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : function (a) {
                return a instanceof Array
              }

        var arrayIndexOf =
          typeof Array.prototype.indexOf === 'function'
            ? function (array, item) {
                return array.indexOf(item)
              }
            : function (array, item) {
                var length = array.length
                for (var i = 0; i < length; i++) {
                  if (array[i] === item) {
                    return i
                  }
                }
                return -1
              }

        function arraysHaveMatchByRef(array1, array2, len1, len2) {
          for (var index1 = 0; index1 < len1; index1++) {
            var val1 = array1[index1]
            for (var index2 = 0; index2 < len2; index2++) {
              var val2 = array2[index2]
              if (index1 !== index2 && val1 === val2) {
                return true
              }
            }
          }
        }

        function matchItems(array1, array2, index1, index2, context) {
          var value1 = array1[index1]
          var value2 = array2[index2]
          if (value1 === value2) {
            return true
          }
          if (
            (typeof value1 === 'undefined' ? 'undefined' : _typeof(value1)) !==
              'object' ||
            (typeof value2 === 'undefined' ? 'undefined' : _typeof(value2)) !==
              'object'
          ) {
            return false
          }
          var objectHash = context.objectHash
          if (!objectHash) {
            // no way to match objects was provided, try match by position
            return context.matchByPosition && index1 === index2
          }
          var hash1 = void 0
          var hash2 = void 0
          if (typeof index1 === 'number') {
            context.hashCache1 = context.hashCache1 || []
            hash1 = context.hashCache1[index1]
            if (typeof hash1 === 'undefined') {
              context.hashCache1[index1] = hash1 = objectHash(value1, index1)
            }
          } else {
            hash1 = objectHash(value1)
          }
          if (typeof hash1 === 'undefined') {
            return false
          }
          if (typeof index2 === 'number') {
            context.hashCache2 = context.hashCache2 || []
            hash2 = context.hashCache2[index2]
            if (typeof hash2 === 'undefined') {
              context.hashCache2[index2] = hash2 = objectHash(value2, index2)
            }
          } else {
            hash2 = objectHash(value2)
          }
          if (typeof hash2 === 'undefined') {
            return false
          }
          return hash1 === hash2
        }

        var diffFilter$1 = function arraysDiffFilter(context) {
          if (!context.leftIsArray) {
            return
          }

          var matchContext = {
            objectHash: context.options && context.options.objectHash,
            matchByPosition: context.options && context.options.matchByPosition
          }
          var commonHead = 0
          var commonTail = 0
          var index = void 0
          var index1 = void 0
          var index2 = void 0
          var array1 = context.left
          var array2 = context.right
          var len1 = array1.length
          var len2 = array2.length

          var child = void 0

          if (
            len1 > 0 &&
            len2 > 0 &&
            !matchContext.objectHash &&
            typeof matchContext.matchByPosition !== 'boolean'
          ) {
            matchContext.matchByPosition = !arraysHaveMatchByRef(
              array1,
              array2,
              len1,
              len2
            )
          }

          // separate common head
          while (
            commonHead < len1 &&
            commonHead < len2 &&
            matchItems(array1, array2, commonHead, commonHead, matchContext)
          ) {
            index = commonHead
            child = new DiffContext(context.left[index], context.right[index])
            context.push(child, index)
            commonHead++
          }
          // separate common tail
          while (
            commonTail + commonHead < len1 &&
            commonTail + commonHead < len2 &&
            matchItems(
              array1,
              array2,
              len1 - 1 - commonTail,
              len2 - 1 - commonTail,
              matchContext
            )
          ) {
            index1 = len1 - 1 - commonTail
            index2 = len2 - 1 - commonTail
            child = new DiffContext(context.left[index1], context.right[index2])
            context.push(child, index2)
            commonTail++
          }
          var result = void 0
          if (commonHead + commonTail === len1) {
            if (len1 === len2) {
              // arrays are identical
              context.setResult(undefined).exit()
              return
            }
            // trivial case, a block (1 or more consecutive items) was added
            result = result || {
              _t: 'a'
            }
            for (index = commonHead; index < len2 - commonTail; index++) {
              result[index] = [array2[index]]
            }
            context.setResult(result).exit()
            return
          }
          if (commonHead + commonTail === len2) {
            // trivial case, a block (1 or more consecutive items) was removed
            result = result || {
              _t: 'a'
            }
            for (index = commonHead; index < len1 - commonTail; index++) {
              result['_' + index] = [array1[index], 0, 0]
            }
            context.setResult(result).exit()
            return
          }
          // reset hash cache
          delete matchContext.hashCache1
          delete matchContext.hashCache2

          // diff is not trivial, find the LCS (Longest Common Subsequence)
          var trimmed1 = array1.slice(commonHead, len1 - commonTail)
          var trimmed2 = array2.slice(commonHead, len2 - commonTail)
          var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext)
          var removedItems = []
          result = result || {
            _t: 'a'
          }
          for (index = commonHead; index < len1 - commonTail; index++) {
            if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
              // removed
              result['_' + index] = [array1[index], 0, 0]
              removedItems.push(index)
            }
          }

          var detectMove = true
          if (
            context.options &&
            context.options.arrays &&
            context.options.arrays.detectMove === false
          ) {
            detectMove = false
          }
          var includeValueOnMove = false
          if (
            context.options &&
            context.options.arrays &&
            context.options.arrays.includeValueOnMove
          ) {
            includeValueOnMove = true
          }

          var removedItemsLength = removedItems.length
          for (index = commonHead; index < len2 - commonTail; index++) {
            var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead)
            if (indexOnArray2 < 0) {
              // added, try to match with a removed item and register as position move
              var isMove = false
              if (detectMove && removedItemsLength > 0) {
                for (
                  var removeItemIndex1 = 0;
                  removeItemIndex1 < removedItemsLength;
                  removeItemIndex1++
                ) {
                  index1 = removedItems[removeItemIndex1]
                  if (
                    matchItems(
                      trimmed1,
                      trimmed2,
                      index1 - commonHead,
                      index - commonHead,
                      matchContext
                    )
                  ) {
                    // store position move as: [originalValue, newPosition, ARRAY_MOVE]
                    result['_' + index1].splice(1, 2, index, ARRAY_MOVE)
                    if (!includeValueOnMove) {
                      // don't include moved value on diff, to save bytes
                      result['_' + index1][0] = ''
                    }

                    index2 = index
                    child = new DiffContext(
                      context.left[index1],
                      context.right[index2]
                    )
                    context.push(child, index2)
                    removedItems.splice(removeItemIndex1, 1)
                    isMove = true
                    break
                  }
                }
              }
              if (!isMove) {
                // added
                result[index] = [array2[index]]
              }
            } else {
              // match, do inner diff
              index1 = seq.indices1[indexOnArray2] + commonHead
              index2 = seq.indices2[indexOnArray2] + commonHead
              child = new DiffContext(
                context.left[index1],
                context.right[index2]
              )
              context.push(child, index2)
            }
          }

          context.setResult(result).exit()
        }
        diffFilter$1.filterName = 'arrays'

        var compare = {
          numerically: function numerically(a, b) {
            return a - b
          },
          numericallyBy: function numericallyBy(name) {
            return function (a, b) {
              return a[name] - b[name]
            }
          }
        }

        var patchFilter$2 = function nestedPatchFilter(context) {
          if (!context.nested) {
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          var index = void 0
          var index1 = void 0

          var delta = context.delta
          var array = context.left

          // first, separate removals, insertions and modifications
          var toRemove = []
          var toInsert = []
          var toModify = []
          for (index in delta) {
            if (index !== '_t') {
              if (index[0] === '_') {
                // removed item from original array
                if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
                  toRemove.push(parseInt(index.slice(1), 10))
                } else {
                  throw new Error(
                    'only removal or move can be applied at original array indices,' +
                      (' invalid diff type: ' + delta[index][2])
                  )
                }
              } else {
                if (delta[index].length === 1) {
                  // added item at new array
                  toInsert.push({
                    index: parseInt(index, 10),
                    value: delta[index][0]
                  })
                } else {
                  // modified item at new array
                  toModify.push({
                    index: parseInt(index, 10),
                    delta: delta[index]
                  })
                }
              }
            }
          }

          // remove items, in reverse order to avoid sawing our own floor
          toRemove = toRemove.sort(compare.numerically)
          for (index = toRemove.length - 1; index >= 0; index--) {
            index1 = toRemove[index]
            var indexDiff = delta['_' + index1]
            var removedValue = array.splice(index1, 1)[0]
            if (indexDiff[2] === ARRAY_MOVE) {
              // reinsert later
              toInsert.push({
                index: indexDiff[1],
                value: removedValue
              })
            }
          }

          // insert items, in reverse order to avoid moving our own floor
          toInsert = toInsert.sort(compare.numericallyBy('index'))
          var toInsertLength = toInsert.length
          for (index = 0; index < toInsertLength; index++) {
            var insertion = toInsert[index]
            array.splice(insertion.index, 0, insertion.value)
          }

          // apply modifications
          var toModifyLength = toModify.length
          var child = void 0
          if (toModifyLength > 0) {
            for (index = 0; index < toModifyLength; index++) {
              var modification = toModify[index]
              child = new PatchContext(
                context.left[modification.index],
                modification.delta
              )
              context.push(child, modification.index)
            }
          }

          if (!context.children) {
            context.setResult(context.left).exit()
            return
          }
          context.exit()
        }
        patchFilter$2.filterName = 'arrays'

        var collectChildrenPatchFilter$1 = function collectChildrenPatchFilter(
          context
        ) {
          if (!context || !context.children) {
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          var length = context.children.length
          var child = void 0
          for (var index = 0; index < length; index++) {
            child = context.children[index]
            context.left[child.childName] = child.result
          }
          context.setResult(context.left).exit()
        }
        collectChildrenPatchFilter$1.filterName = 'arraysCollectChildren'

        var reverseFilter$2 = function arraysReverseFilter(context) {
          if (!context.nested) {
            if (context.delta[2] === ARRAY_MOVE) {
              context.newName = '_' + context.delta[1]
              context
                .setResult([
                  context.delta[0],
                  parseInt(context.childName.substr(1), 10),
                  ARRAY_MOVE
                ])
                .exit()
            }
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          var name = void 0
          var child = void 0
          for (name in context.delta) {
            if (name === '_t') {
              continue
            }
            child = new ReverseContext(context.delta[name])
            context.push(child, name)
          }
          context.exit()
        }
        reverseFilter$2.filterName = 'arrays'

        var reverseArrayDeltaIndex = function reverseArrayDeltaIndex(
          delta,
          index,
          itemDelta
        ) {
          if (typeof index === 'string' && index[0] === '_') {
            return parseInt(index.substr(1), 10)
          } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {
            return '_' + index
          }

          var reverseIndex = +index
          for (var deltaIndex in delta) {
            var deltaItem = delta[deltaIndex]
            if (isArray$2(deltaItem)) {
              if (deltaItem[2] === ARRAY_MOVE) {
                var moveFromIndex = parseInt(deltaIndex.substr(1), 10)
                var moveToIndex = deltaItem[1]
                if (moveToIndex === +index) {
                  return moveFromIndex
                }
                if (
                  moveFromIndex <= reverseIndex &&
                  moveToIndex > reverseIndex
                ) {
                  reverseIndex++
                } else if (
                  moveFromIndex >= reverseIndex &&
                  moveToIndex < reverseIndex
                ) {
                  reverseIndex--
                }
              } else if (deltaItem[2] === 0) {
                var deleteIndex = parseInt(deltaIndex.substr(1), 10)
                if (deleteIndex <= reverseIndex) {
                  reverseIndex++
                }
              } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
                reverseIndex--
              }
            }
          }

          return reverseIndex
        }

        function collectChildrenReverseFilter$1(context) {
          if (!context || !context.children) {
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          var length = context.children.length
          var child = void 0
          var delta = {
            _t: 'a'
          }

          for (var index = 0; index < length; index++) {
            child = context.children[index]
            var name = child.newName
            if (typeof name === 'undefined') {
              name = reverseArrayDeltaIndex(
                context.delta,
                child.childName,
                child.result
              )
            }
            if (delta[name] !== child.result) {
              delta[name] = child.result
            }
          }
          context.setResult(delta).exit()
        }
        collectChildrenReverseFilter$1.filterName = 'arraysCollectChildren'

        var diffFilter$2 = function datesDiffFilter(context) {
          if (context.left instanceof Date) {
            if (context.right instanceof Date) {
              if (context.left.getTime() !== context.right.getTime()) {
                context.setResult([context.left, context.right])
              } else {
                context.setResult(undefined)
              }
            } else {
              context.setResult([context.left, context.right])
            }
            context.exit()
          } else if (context.right instanceof Date) {
            context.setResult([context.left, context.right]).exit()
          }
        }
        diffFilter$2.filterName = 'dates'

        function createCommonjsModule(fn, module) {
          return (
            (module = { exports: {} }),
            fn(module, module.exports),
            module.exports
          )
        }

        var diffMatchPatch = createCommonjsModule(function (module) {
          /**
           * Diff Match and Patch
           * Copyright 2018 The diff-match-patch Authors.
           * https://github.com/google/diff-match-patch
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *   http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */

          /**
           * @fileoverview Computes the difference between two texts to create a patch.
           * Applies the patch onto another text, allowing for errors.
           * @author fraser@google.com (Neil Fraser)
           */

          /**
           * Class containing the diff, match and patch methods.
           * @constructor
           */
          function diff_match_patch() {
            // Defaults.
            // Redefine these in your program to override the defaults.

            // Number of seconds to map a diff before giving up (0 for infinity).
            this.Diff_Timeout = 1.0
            // Cost of an empty edit operation in terms of edit characters.
            this.Diff_EditCost = 4
            // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
            this.Match_Threshold = 0.5
            // How far to search for a match (0 = exact location, 1000+ = broad match).
            // A match this many characters away from the expected location will add
            // 1.0 to the score (0.0 is a perfect match).
            this.Match_Distance = 1000
            // When deleting a large block of text (over ~64 characters), how close do
            // the contents have to be to match the expected contents. (0.0 = perfection,
            // 1.0 = very loose).  Note that Match_Threshold controls how closely the
            // end points of a delete need to match.
            this.Patch_DeleteThreshold = 0.5
            // Chunk size for context length.
            this.Patch_Margin = 4

            // The number of bits in an int.
            this.Match_MaxBits = 32
          }

          //  DIFF FUNCTIONS

          /**
           * The data structure representing a diff is an array of tuples:
           * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
           * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
           */
          var DIFF_DELETE = -1
          var DIFF_INSERT = 1
          var DIFF_EQUAL = 0

          /** @typedef {{0: number, 1: string}} */
          diff_match_patch.prototype.diff_main = function (
            text1,
            text2,
            opt_checklines,
            opt_deadline
          ) {
            // Set a deadline by which time the diff must be complete.
            if (typeof opt_deadline == 'undefined') {
              if (this.Diff_Timeout <= 0) {
                opt_deadline = Number.MAX_VALUE
              } else {
                opt_deadline = new Date().getTime() + this.Diff_Timeout * 1000
              }
            }
            var deadline = opt_deadline

            // Check for null inputs.
            if (text1 == null || text2 == null) {
              throw new Error('Null input. (diff_main)')
            }

            // Check for equality (speedup).
            if (text1 == text2) {
              if (text1) {
                return [[DIFF_EQUAL, text1]]
              }
              return []
            }

            if (typeof opt_checklines == 'undefined') {
              opt_checklines = true
            }
            var checklines = opt_checklines

            // Trim off common prefix (speedup).
            var commonlength = this.diff_commonPrefix(text1, text2)
            var commonprefix = text1.substring(0, commonlength)
            text1 = text1.substring(commonlength)
            text2 = text2.substring(commonlength)

            // Trim off common suffix (speedup).
            commonlength = this.diff_commonSuffix(text1, text2)
            var commonsuffix = text1.substring(text1.length - commonlength)
            text1 = text1.substring(0, text1.length - commonlength)
            text2 = text2.substring(0, text2.length - commonlength)

            // Compute the diff on the middle block.
            var diffs = this.diff_compute_(text1, text2, checklines, deadline)

            // Restore the prefix and suffix.
            if (commonprefix) {
              diffs.unshift([DIFF_EQUAL, commonprefix])
            }
            if (commonsuffix) {
              diffs.push([DIFF_EQUAL, commonsuffix])
            }
            this.diff_cleanupMerge(diffs)
            return diffs
          }

          /**
           * Find the differences between two texts.  Assumes that the texts do not
           * have any common prefix or suffix.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {boolean} checklines Speedup flag.  If false, then don't run a
           *     line-level diff first to identify the changed areas.
           *     If true, then run a faster, slightly less optimal diff.
           * @param {number} deadline Time when the diff should be complete by.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_compute_ = function (
            text1,
            text2,
            checklines,
            deadline
          ) {
            var diffs

            if (!text1) {
              // Just add some text (speedup).
              return [[DIFF_INSERT, text2]]
            }

            if (!text2) {
              // Just delete some text (speedup).
              return [[DIFF_DELETE, text1]]
            }

            var longtext = text1.length > text2.length ? text1 : text2
            var shorttext = text1.length > text2.length ? text2 : text1
            var i = longtext.indexOf(shorttext)
            if (i != -1) {
              // Shorter text is inside the longer text (speedup).
              diffs = [
                [DIFF_INSERT, longtext.substring(0, i)],
                [DIFF_EQUAL, shorttext],
                [DIFF_INSERT, longtext.substring(i + shorttext.length)]
              ]
              // Swap insertions for deletions if diff is reversed.
              if (text1.length > text2.length) {
                diffs[0][0] = diffs[2][0] = DIFF_DELETE
              }
              return diffs
            }

            if (shorttext.length == 1) {
              // Single character string.
              // After the previous speedup, the character can't be an equality.
              return [
                [DIFF_DELETE, text1],
                [DIFF_INSERT, text2]
              ]
            }

            // Check to see if the problem can be split in two.
            var hm = this.diff_halfMatch_(text1, text2)
            if (hm) {
              // A half-match was found, sort out the return data.
              var text1_a = hm[0]
              var text1_b = hm[1]
              var text2_a = hm[2]
              var text2_b = hm[3]
              var mid_common = hm[4]
              // Send both pairs off for separate processing.
              var diffs_a = this.diff_main(
                text1_a,
                text2_a,
                checklines,
                deadline
              )
              var diffs_b = this.diff_main(
                text1_b,
                text2_b,
                checklines,
                deadline
              )
              // Merge the results.
              return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b)
            }

            if (checklines && text1.length > 100 && text2.length > 100) {
              return this.diff_lineMode_(text1, text2, deadline)
            }

            return this.diff_bisect_(text1, text2, deadline)
          }

          /**
           * Do a quick line-level diff on both strings, then rediff the parts for
           * greater accuracy.
           * This speedup can produce non-minimal diffs.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {number} deadline Time when the diff should be complete by.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_lineMode_ = function (
            text1,
            text2,
            deadline
          ) {
            // Scan the text on a line-by-line basis first.
            var a = this.diff_linesToChars_(text1, text2)
            text1 = a.chars1
            text2 = a.chars2
            var linearray = a.lineArray

            var diffs = this.diff_main(text1, text2, false, deadline)

            // Convert the diff back to original text.
            this.diff_charsToLines_(diffs, linearray)
            // Eliminate freak matches (e.g. blank lines)
            this.diff_cleanupSemantic(diffs)

            // Rediff any replacement blocks, this time character-by-character.
            // Add a dummy entry at the end.
            diffs.push([DIFF_EQUAL, ''])
            var pointer = 0
            var count_delete = 0
            var count_insert = 0
            var text_delete = ''
            var text_insert = ''
            while (pointer < diffs.length) {
              switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                  count_insert++
                  text_insert += diffs[pointer][1]
                  break
                case DIFF_DELETE:
                  count_delete++
                  text_delete += diffs[pointer][1]
                  break
                case DIFF_EQUAL:
                  // Upon reaching an equality, check for prior redundancies.
                  if (count_delete >= 1 && count_insert >= 1) {
                    // Delete the offending records and add the merged ones.
                    diffs.splice(
                      pointer - count_delete - count_insert,
                      count_delete + count_insert
                    )
                    pointer = pointer - count_delete - count_insert
                    var a = this.diff_main(
                      text_delete,
                      text_insert,
                      false,
                      deadline
                    )
                    for (var j = a.length - 1; j >= 0; j--) {
                      diffs.splice(pointer, 0, a[j])
                    }
                    pointer = pointer + a.length
                  }
                  count_insert = 0
                  count_delete = 0
                  text_delete = ''
                  text_insert = ''
                  break
              }
              pointer++
            }
            diffs.pop() // Remove the dummy entry at the end.

            return diffs
          }

          /**
           * Find the 'middle snake' of a diff, split the problem in two
           * and return the recursively constructed diff.
           * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {number} deadline Time at which to bail if not yet complete.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_bisect_ = function (
            text1,
            text2,
            deadline
          ) {
            // Cache the text lengths to prevent multiple calls.
            var text1_length = text1.length
            var text2_length = text2.length
            var max_d = Math.ceil((text1_length + text2_length) / 2)
            var v_offset = max_d
            var v_length = 2 * max_d
            var v1 = new Array(v_length)
            var v2 = new Array(v_length)
            // Setting all elements to -1 is faster in Chrome & Firefox than mixing
            // integers and undefined.
            for (var x = 0; x < v_length; x++) {
              v1[x] = -1
              v2[x] = -1
            }
            v1[v_offset + 1] = 0
            v2[v_offset + 1] = 0
            var delta = text1_length - text2_length
            // If the total number of characters is odd, then the front path will collide
            // with the reverse path.
            var front = delta % 2 != 0
            // Offsets for start and end of k loop.
            // Prevents mapping of space beyond the grid.
            var k1start = 0
            var k1end = 0
            var k2start = 0
            var k2end = 0
            for (var d = 0; d < max_d; d++) {
              // Bail out if deadline is reached.
              if (new Date().getTime() > deadline) {
                break
              }

              // Walk the front path one step.
              for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                var k1_offset = v_offset + k1
                var x1
                if (
                  k1 == -d ||
                  (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])
                ) {
                  x1 = v1[k1_offset + 1]
                } else {
                  x1 = v1[k1_offset - 1] + 1
                }
                var y1 = x1 - k1
                while (
                  x1 < text1_length &&
                  y1 < text2_length &&
                  text1.charAt(x1) == text2.charAt(y1)
                ) {
                  x1++
                  y1++
                }
                v1[k1_offset] = x1
                if (x1 > text1_length) {
                  // Ran off the right of the graph.
                  k1end += 2
                } else if (y1 > text2_length) {
                  // Ran off the bottom of the graph.
                  k1start += 2
                } else if (front) {
                  var k2_offset = v_offset + delta - k1
                  if (
                    k2_offset >= 0 &&
                    k2_offset < v_length &&
                    v2[k2_offset] != -1
                  ) {
                    // Mirror x2 onto top-left coordinate system.
                    var x2 = text1_length - v2[k2_offset]
                    if (x1 >= x2) {
                      // Overlap detected.
                      return this.diff_bisectSplit_(
                        text1,
                        text2,
                        x1,
                        y1,
                        deadline
                      )
                    }
                  }
                }
              }

              // Walk the reverse path one step.
              for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                var k2_offset = v_offset + k2
                var x2
                if (
                  k2 == -d ||
                  (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])
                ) {
                  x2 = v2[k2_offset + 1]
                } else {
                  x2 = v2[k2_offset - 1] + 1
                }
                var y2 = x2 - k2
                while (
                  x2 < text1_length &&
                  y2 < text2_length &&
                  text1.charAt(text1_length - x2 - 1) ==
                    text2.charAt(text2_length - y2 - 1)
                ) {
                  x2++
                  y2++
                }
                v2[k2_offset] = x2
                if (x2 > text1_length) {
                  // Ran off the left of the graph.
                  k2end += 2
                } else if (y2 > text2_length) {
                  // Ran off the top of the graph.
                  k2start += 2
                } else if (!front) {
                  var k1_offset = v_offset + delta - k2
                  if (
                    k1_offset >= 0 &&
                    k1_offset < v_length &&
                    v1[k1_offset] != -1
                  ) {
                    var x1 = v1[k1_offset]
                    var y1 = v_offset + x1 - k1_offset
                    // Mirror x2 onto top-left coordinate system.
                    x2 = text1_length - x2
                    if (x1 >= x2) {
                      // Overlap detected.
                      return this.diff_bisectSplit_(
                        text1,
                        text2,
                        x1,
                        y1,
                        deadline
                      )
                    }
                  }
                }
              }
            }
            // Diff took too long and hit the deadline or
            // number of diffs equals number of characters, no commonality at all.
            return [
              [DIFF_DELETE, text1],
              [DIFF_INSERT, text2]
            ]
          }

          /**
           * Given the location of the 'middle snake', split the diff in two parts
           * and recurse.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {number} x Index of split point in text1.
           * @param {number} y Index of split point in text2.
           * @param {number} deadline Time at which to bail if not yet complete.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_bisectSplit_ = function (
            text1,
            text2,
            x,
            y,
            deadline
          ) {
            var text1a = text1.substring(0, x)
            var text2a = text2.substring(0, y)
            var text1b = text1.substring(x)
            var text2b = text2.substring(y)

            // Compute both diffs serially.
            var diffs = this.diff_main(text1a, text2a, false, deadline)
            var diffsb = this.diff_main(text1b, text2b, false, deadline)

            return diffs.concat(diffsb)
          }

          /**
           * Split two texts into an array of strings.  Reduce the texts to a string of
           * hashes where each Unicode character represents one line.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
           *     An object containing the encoded text1, the encoded text2 and
           *     the array of unique strings.
           *     The zeroth element of the array of unique strings is intentionally blank.
           * @private
           */
          diff_match_patch.prototype.diff_linesToChars_ = function (
            text1,
            text2
          ) {
            var lineArray = [] // e.g. lineArray[4] == 'Hello\n'
            var lineHash = {} // e.g. lineHash['Hello\n'] == 4

            // '\x00' is a valid character, but various debuggers don't like it.
            // So we'll insert a junk entry to avoid generating a null character.
            lineArray[0] = ''

            /**
             * Split a text into an array of strings.  Reduce the texts to a string of
             * hashes where each Unicode character represents one line.
             * Modifies linearray and linehash through being a closure.
             * @param {string} text String to encode.
             * @return {string} Encoded string.
             * @private
             */
            function diff_linesToCharsMunge_(text) {
              var chars = ''
              // Walk the text, pulling out a substring for each line.
              // text.split('\n') would would temporarily double our memory footprint.
              // Modifying text would create many large strings to garbage collect.
              var lineStart = 0
              var lineEnd = -1
              // Keeping our own length variable is faster than looking it up.
              var lineArrayLength = lineArray.length
              while (lineEnd < text.length - 1) {
                lineEnd = text.indexOf('\n', lineStart)
                if (lineEnd == -1) {
                  lineEnd = text.length - 1
                }
                var line = text.substring(lineStart, lineEnd + 1)
                lineStart = lineEnd + 1

                if (
                  lineHash.hasOwnProperty
                    ? lineHash.hasOwnProperty(line)
                    : lineHash[line] !== undefined
                ) {
                  chars += String.fromCharCode(lineHash[line])
                } else {
                  chars += String.fromCharCode(lineArrayLength)
                  lineHash[line] = lineArrayLength
                  lineArray[lineArrayLength++] = line
                }
              }
              return chars
            }

            var chars1 = diff_linesToCharsMunge_(text1)
            var chars2 = diff_linesToCharsMunge_(text2)
            return { chars1: chars1, chars2: chars2, lineArray: lineArray }
          }

          /**
           * Rehydrate the text in a diff from a string of line hashes to real lines of
           * text.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @param {!Array.<string>} lineArray Array of unique strings.
           * @private
           */
          diff_match_patch.prototype.diff_charsToLines_ = function (
            diffs,
            lineArray
          ) {
            for (var x = 0; x < diffs.length; x++) {
              var chars = diffs[x][1]
              var text = []
              for (var y = 0; y < chars.length; y++) {
                text[y] = lineArray[chars.charCodeAt(y)]
              }
              diffs[x][1] = text.join('')
            }
          }

          /**
           * Determine the common prefix of two strings.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {number} The number of characters common to the start of each
           *     string.
           */
          diff_match_patch.prototype.diff_commonPrefix = function (
            text1,
            text2
          ) {
            // Quick check for common null cases.
            if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
              return 0
            }
            // Binary search.
            // Performance analysis: http://neil.fraser.name/news/2007/10/09/
            var pointermin = 0
            var pointermax = Math.min(text1.length, text2.length)
            var pointermid = pointermax
            var pointerstart = 0
            while (pointermin < pointermid) {
              if (
                text1.substring(pointerstart, pointermid) ==
                text2.substring(pointerstart, pointermid)
              ) {
                pointermin = pointermid
                pointerstart = pointermin
              } else {
                pointermax = pointermid
              }
              pointermid = Math.floor(
                (pointermax - pointermin) / 2 + pointermin
              )
            }
            return pointermid
          }

          /**
           * Determine the common suffix of two strings.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {number} The number of characters common to the end of each string.
           */
          diff_match_patch.prototype.diff_commonSuffix = function (
            text1,
            text2
          ) {
            // Quick check for common null cases.
            if (
              !text1 ||
              !text2 ||
              text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)
            ) {
              return 0
            }
            // Binary search.
            // Performance analysis: http://neil.fraser.name/news/2007/10/09/
            var pointermin = 0
            var pointermax = Math.min(text1.length, text2.length)
            var pointermid = pointermax
            var pointerend = 0
            while (pointermin < pointermid) {
              if (
                text1.substring(
                  text1.length - pointermid,
                  text1.length - pointerend
                ) ==
                text2.substring(
                  text2.length - pointermid,
                  text2.length - pointerend
                )
              ) {
                pointermin = pointermid
                pointerend = pointermin
              } else {
                pointermax = pointermid
              }
              pointermid = Math.floor(
                (pointermax - pointermin) / 2 + pointermin
              )
            }
            return pointermid
          }

          /**
           * Determine if the suffix of one string is the prefix of another.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {number} The number of characters common to the end of the first
           *     string and the start of the second string.
           * @private
           */
          diff_match_patch.prototype.diff_commonOverlap_ = function (
            text1,
            text2
          ) {
            // Cache the text lengths to prevent multiple calls.
            var text1_length = text1.length
            var text2_length = text2.length
            // Eliminate the null case.
            if (text1_length == 0 || text2_length == 0) {
              return 0
            }
            // Truncate the longer string.
            if (text1_length > text2_length) {
              text1 = text1.substring(text1_length - text2_length)
            } else if (text1_length < text2_length) {
              text2 = text2.substring(0, text1_length)
            }
            var text_length = Math.min(text1_length, text2_length)
            // Quick check for the worst case.
            if (text1 == text2) {
              return text_length
            }

            // Start by looking for a single character match
            // and increase length until no match is found.
            // Performance analysis: http://neil.fraser.name/news/2010/11/04/
            var best = 0
            var length = 1
            while (true) {
              var pattern = text1.substring(text_length - length)
              var found = text2.indexOf(pattern)
              if (found == -1) {
                return best
              }
              length += found
              if (
                found == 0 ||
                text1.substring(text_length - length) ==
                  text2.substring(0, length)
              ) {
                best = length
                length++
              }
            }
          }

          /**
           * Do the two texts share a substring which is at least half the length of the
           * longer text?
           * This speedup can produce non-minimal diffs.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {Array.<string>} Five element Array, containing the prefix of
           *     text1, the suffix of text1, the prefix of text2, the suffix of
           *     text2 and the common middle.  Or null if there was no match.
           * @private
           */
          diff_match_patch.prototype.diff_halfMatch_ = function (text1, text2) {
            if (this.Diff_Timeout <= 0) {
              // Don't risk returning a non-optimal diff if we have unlimited time.
              return null
            }
            var longtext = text1.length > text2.length ? text1 : text2
            var shorttext = text1.length > text2.length ? text2 : text1
            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
              return null // Pointless.
            }
            var dmp = this // 'this' becomes 'window' in a closure.

            /**
             * Does a substring of shorttext exist within longtext such that the substring
             * is at least half the length of longtext?
             * Closure, but does not reference any external variables.
             * @param {string} longtext Longer string.
             * @param {string} shorttext Shorter string.
             * @param {number} i Start index of quarter length substring within longtext.
             * @return {Array.<string>} Five element Array, containing the prefix of
             *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
             *     of shorttext and the common middle.  Or null if there was no match.
             * @private
             */
            function diff_halfMatchI_(longtext, shorttext, i) {
              // Start with a 1/4 length substring at position i as a seed.
              var seed = longtext.substring(
                i,
                i + Math.floor(longtext.length / 4)
              )
              var j = -1
              var best_common = ''
              var best_longtext_a,
                best_longtext_b,
                best_shorttext_a,
                best_shorttext_b
              while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                var prefixLength = dmp.diff_commonPrefix(
                  longtext.substring(i),
                  shorttext.substring(j)
                )
                var suffixLength = dmp.diff_commonSuffix(
                  longtext.substring(0, i),
                  shorttext.substring(0, j)
                )
                if (best_common.length < suffixLength + prefixLength) {
                  best_common =
                    shorttext.substring(j - suffixLength, j) +
                    shorttext.substring(j, j + prefixLength)
                  best_longtext_a = longtext.substring(0, i - suffixLength)
                  best_longtext_b = longtext.substring(i + prefixLength)
                  best_shorttext_a = shorttext.substring(0, j - suffixLength)
                  best_shorttext_b = shorttext.substring(j + prefixLength)
                }
              }
              if (best_common.length * 2 >= longtext.length) {
                return [
                  best_longtext_a,
                  best_longtext_b,
                  best_shorttext_a,
                  best_shorttext_b,
                  best_common
                ]
              } else {
                return null
              }
            }

            // First check if the second quarter is the seed for a half-match.
            var hm1 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 4)
            )
            // Check again based on the third quarter.
            var hm2 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 2)
            )
            var hm
            if (!hm1 && !hm2) {
              return null
            } else if (!hm2) {
              hm = hm1
            } else if (!hm1) {
              hm = hm2
            } else {
              // Both matched.  Select the longest.
              hm = hm1[4].length > hm2[4].length ? hm1 : hm2
            }

            // A half-match was found, sort out the return data.
            var text1_a, text1_b, text2_a, text2_b
            if (text1.length > text2.length) {
              text1_a = hm[0]
              text1_b = hm[1]
              text2_a = hm[2]
              text2_b = hm[3]
            } else {
              text2_a = hm[0]
              text2_b = hm[1]
              text1_a = hm[2]
              text1_b = hm[3]
            }
            var mid_common = hm[4]
            return [text1_a, text1_b, text2_a, text2_b, mid_common]
          }

          /**
           * Reduce the number of edits by eliminating semantically trivial equalities.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupSemantic = function (diffs) {
            var changes = false
            var equalities = [] // Stack of indices where equalities are found.
            var equalitiesLength = 0 // Keeping our own length var is faster in JS.
            /** @type {?string} */
            var lastequality = null
            // Always equal to diffs[equalities[equalitiesLength - 1]][1]
            var pointer = 0 // Index of current position.
            // Number of characters that changed prior to the equality.
            var length_insertions1 = 0
            var length_deletions1 = 0
            // Number of characters that changed after the equality.
            var length_insertions2 = 0
            var length_deletions2 = 0
            while (pointer < diffs.length) {
              if (diffs[pointer][0] == DIFF_EQUAL) {
                // Equality found.
                equalities[equalitiesLength++] = pointer
                length_insertions1 = length_insertions2
                length_deletions1 = length_deletions2
                length_insertions2 = 0
                length_deletions2 = 0
                lastequality = diffs[pointer][1]
              } else {
                // An insertion or deletion.
                if (diffs[pointer][0] == DIFF_INSERT) {
                  length_insertions2 += diffs[pointer][1].length
                } else {
                  length_deletions2 += diffs[pointer][1].length
                }
                // Eliminate an equality that is smaller or equal to the edits on both
                // sides of it.
                if (
                  lastequality &&
                  lastequality.length <=
                    Math.max(length_insertions1, length_deletions1) &&
                  lastequality.length <=
                    Math.max(length_insertions2, length_deletions2)
                ) {
                  // Duplicate record.
                  diffs.splice(equalities[equalitiesLength - 1], 0, [
                    DIFF_DELETE,
                    lastequality
                  ])
                  // Change second copy to insert.
                  diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT
                  // Throw away the equality we just deleted.
                  equalitiesLength--
                  // Throw away the previous equality (it needs to be reevaluated).
                  equalitiesLength--
                  pointer =
                    equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1
                  length_insertions1 = 0 // Reset the counters.
                  length_deletions1 = 0
                  length_insertions2 = 0
                  length_deletions2 = 0
                  lastequality = null
                  changes = true
                }
              }
              pointer++
            }

            // Normalize the diff.
            if (changes) {
              this.diff_cleanupMerge(diffs)
            }
            this.diff_cleanupSemanticLossless(diffs)

            // Find any overlaps between deletions and insertions.
            // e.g: <del>abcxxx</del><ins>xxxdef</ins>
            //   -> <del>abc</del>xxx<ins>def</ins>
            // e.g: <del>xxxabc</del><ins>defxxx</ins>
            //   -> <ins>def</ins>xxx<del>abc</del>
            // Only extract an overlap if it is as big as the edit ahead or behind it.
            pointer = 1
            while (pointer < diffs.length) {
              if (
                diffs[pointer - 1][0] == DIFF_DELETE &&
                diffs[pointer][0] == DIFF_INSERT
              ) {
                var deletion = diffs[pointer - 1][1]
                var insertion = diffs[pointer][1]
                var overlap_length1 = this.diff_commonOverlap_(
                  deletion,
                  insertion
                )
                var overlap_length2 = this.diff_commonOverlap_(
                  insertion,
                  deletion
                )
                if (overlap_length1 >= overlap_length2) {
                  if (
                    overlap_length1 >= deletion.length / 2 ||
                    overlap_length1 >= insertion.length / 2
                  ) {
                    // Overlap found.  Insert an equality and trim the surrounding edits.
                    diffs.splice(pointer, 0, [
                      DIFF_EQUAL,
                      insertion.substring(0, overlap_length1)
                    ])
                    diffs[pointer - 1][1] = deletion.substring(
                      0,
                      deletion.length - overlap_length1
                    )
                    diffs[pointer + 1][1] = insertion.substring(overlap_length1)
                    pointer++
                  }
                } else {
                  if (
                    overlap_length2 >= deletion.length / 2 ||
                    overlap_length2 >= insertion.length / 2
                  ) {
                    // Reverse overlap found.
                    // Insert an equality and swap and trim the surrounding edits.
                    diffs.splice(pointer, 0, [
                      DIFF_EQUAL,
                      deletion.substring(0, overlap_length2)
                    ])
                    diffs[pointer - 1][0] = DIFF_INSERT
                    diffs[pointer - 1][1] = insertion.substring(
                      0,
                      insertion.length - overlap_length2
                    )
                    diffs[pointer + 1][0] = DIFF_DELETE
                    diffs[pointer + 1][1] = deletion.substring(overlap_length2)
                    pointer++
                  }
                }
                pointer++
              }
              pointer++
            }
          }

          /**
           * Look for single edits surrounded on both sides by equalities
           * which can be shifted sideways to align the edit to a word boundary.
           * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupSemanticLossless = function (
            diffs
          ) {
            /**
             * Given two strings, compute a score representing whether the internal
             * boundary falls on logical boundaries.
             * Scores range from 6 (best) to 0 (worst).
             * Closure, but does not reference any external variables.
             * @param {string} one First string.
             * @param {string} two Second string.
             * @return {number} The score.
             * @private
             */
            function diff_cleanupSemanticScore_(one, two) {
              if (!one || !two) {
                // Edges are the best.
                return 6
              }

              // Each port of this function behaves slightly differently due to
              // subtle differences in each language's definition of things like
              // 'whitespace'.  Since this function's purpose is largely cosmetic,
              // the choice has been made to use each language's native features
              // rather than force total conformity.
              var char1 = one.charAt(one.length - 1)
              var char2 = two.charAt(0)
              var nonAlphaNumeric1 = char1.match(
                diff_match_patch.nonAlphaNumericRegex_
              )
              var nonAlphaNumeric2 = char2.match(
                diff_match_patch.nonAlphaNumericRegex_
              )
              var whitespace1 =
                nonAlphaNumeric1 &&
                char1.match(diff_match_patch.whitespaceRegex_)
              var whitespace2 =
                nonAlphaNumeric2 &&
                char2.match(diff_match_patch.whitespaceRegex_)
              var lineBreak1 =
                whitespace1 && char1.match(diff_match_patch.linebreakRegex_)
              var lineBreak2 =
                whitespace2 && char2.match(diff_match_patch.linebreakRegex_)
              var blankLine1 =
                lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_)
              var blankLine2 =
                lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_)

              if (blankLine1 || blankLine2) {
                // Five points for blank lines.
                return 5
              } else if (lineBreak1 || lineBreak2) {
                // Four points for line breaks.
                return 4
              } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
                // Three points for end of sentences.
                return 3
              } else if (whitespace1 || whitespace2) {
                // Two points for whitespace.
                return 2
              } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
                // One point for non-alphanumeric.
                return 1
              }
              return 0
            }

            var pointer = 1
            // Intentionally ignore the first and last element (don't need checking).
            while (pointer < diffs.length - 1) {
              if (
                diffs[pointer - 1][0] == DIFF_EQUAL &&
                diffs[pointer + 1][0] == DIFF_EQUAL
              ) {
                // This is a single edit surrounded by equalities.
                var equality1 = diffs[pointer - 1][1]
                var edit = diffs[pointer][1]
                var equality2 = diffs[pointer + 1][1]

                // First, shift the edit as far left as possible.
                var commonOffset = this.diff_commonSuffix(equality1, edit)
                if (commonOffset) {
                  var commonString = edit.substring(edit.length - commonOffset)
                  equality1 = equality1.substring(
                    0,
                    equality1.length - commonOffset
                  )
                  edit =
                    commonString + edit.substring(0, edit.length - commonOffset)
                  equality2 = commonString + equality2
                }

                // Second, step character by character right, looking for the best fit.
                var bestEquality1 = equality1
                var bestEdit = edit
                var bestEquality2 = equality2
                var bestScore =
                  diff_cleanupSemanticScore_(equality1, edit) +
                  diff_cleanupSemanticScore_(edit, equality2)
                while (edit.charAt(0) === equality2.charAt(0)) {
                  equality1 += edit.charAt(0)
                  edit = edit.substring(1) + equality2.charAt(0)
                  equality2 = equality2.substring(1)
                  var score =
                    diff_cleanupSemanticScore_(equality1, edit) +
                    diff_cleanupSemanticScore_(edit, equality2)
                  // The >= encourages trailing rather than leading whitespace on edits.
                  if (score >= bestScore) {
                    bestScore = score
                    bestEquality1 = equality1
                    bestEdit = edit
                    bestEquality2 = equality2
                  }
                }

                if (diffs[pointer - 1][1] != bestEquality1) {
                  // We have an improvement, save it back to the diff.
                  if (bestEquality1) {
                    diffs[pointer - 1][1] = bestEquality1
                  } else {
                    diffs.splice(pointer - 1, 1)
                    pointer--
                  }
                  diffs[pointer][1] = bestEdit
                  if (bestEquality2) {
                    diffs[pointer + 1][1] = bestEquality2
                  } else {
                    diffs.splice(pointer + 1, 1)
                    pointer--
                  }
                }
              }
              pointer++
            }
          }

          // Define some regex patterns for matching boundaries.
          diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/
          diff_match_patch.whitespaceRegex_ = /\s/
          diff_match_patch.linebreakRegex_ = /[\r\n]/
          diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/
          diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/

          /**
           * Reduce the number of edits by eliminating operationally trivial equalities.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupEfficiency = function (diffs) {
            var changes = false
            var equalities = [] // Stack of indices where equalities are found.
            var equalitiesLength = 0 // Keeping our own length var is faster in JS.
            /** @type {?string} */
            var lastequality = null
            // Always equal to diffs[equalities[equalitiesLength - 1]][1]
            var pointer = 0 // Index of current position.
            // Is there an insertion operation before the last equality.
            var pre_ins = false
            // Is there a deletion operation before the last equality.
            var pre_del = false
            // Is there an insertion operation after the last equality.
            var post_ins = false
            // Is there a deletion operation after the last equality.
            var post_del = false
            while (pointer < diffs.length) {
              if (diffs[pointer][0] == DIFF_EQUAL) {
                // Equality found.
                if (
                  diffs[pointer][1].length < this.Diff_EditCost &&
                  (post_ins || post_del)
                ) {
                  // Candidate found.
                  equalities[equalitiesLength++] = pointer
                  pre_ins = post_ins
                  pre_del = post_del
                  lastequality = diffs[pointer][1]
                } else {
                  // Not a candidate, and can never become one.
                  equalitiesLength = 0
                  lastequality = null
                }
                post_ins = post_del = false
              } else {
                // An insertion or deletion.
                if (diffs[pointer][0] == DIFF_DELETE) {
                  post_del = true
                } else {
                  post_ins = true
                }
                /*
                 * Five types to be split:
                 * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
                 * <ins>A</ins>X<ins>C</ins><del>D</del>
                 * <ins>A</ins><del>B</del>X<ins>C</ins>
                 * <ins>A</del>X<ins>C</ins><del>D</del>
                 * <ins>A</ins><del>B</del>X<del>C</del>
                 */
                if (
                  lastequality &&
                  ((pre_ins && pre_del && post_ins && post_del) ||
                    (lastequality.length < this.Diff_EditCost / 2 &&
                      pre_ins + pre_del + post_ins + post_del == 3))
                ) {
                  // Duplicate record.
                  diffs.splice(equalities[equalitiesLength - 1], 0, [
                    DIFF_DELETE,
                    lastequality
                  ])
                  // Change second copy to insert.
                  diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT
                  equalitiesLength-- // Throw away the equality we just deleted;
                  lastequality = null
                  if (pre_ins && pre_del) {
                    // No changes made which could affect previous entry, keep going.
                    post_ins = post_del = true
                    equalitiesLength = 0
                  } else {
                    equalitiesLength-- // Throw away the previous equality.
                    pointer =
                      equalitiesLength > 0
                        ? equalities[equalitiesLength - 1]
                        : -1
                    post_ins = post_del = false
                  }
                  changes = true
                }
              }
              pointer++
            }

            if (changes) {
              this.diff_cleanupMerge(diffs)
            }
          }

          /**
           * Reorder and merge like edit sections.  Merge equalities.
           * Any edit section can move as long as it doesn't cross an equality.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupMerge = function (diffs) {
            diffs.push([DIFF_EQUAL, '']) // Add a dummy entry at the end.
            var pointer = 0
            var count_delete = 0
            var count_insert = 0
            var text_delete = ''
            var text_insert = ''
            var commonlength
            while (pointer < diffs.length) {
              switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                  count_insert++
                  text_insert += diffs[pointer][1]
                  pointer++
                  break
                case DIFF_DELETE:
                  count_delete++
                  text_delete += diffs[pointer][1]
                  pointer++
                  break
                case DIFF_EQUAL:
                  // Upon reaching an equality, check for prior redundancies.
                  if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                      // Factor out any common prefixies.
                      commonlength = this.diff_commonPrefix(
                        text_insert,
                        text_delete
                      )
                      if (commonlength !== 0) {
                        if (
                          pointer - count_delete - count_insert > 0 &&
                          diffs[pointer - count_delete - count_insert - 1][0] ==
                            DIFF_EQUAL
                        ) {
                          diffs[pointer - count_delete - count_insert - 1][1] +=
                            text_insert.substring(0, commonlength)
                        } else {
                          diffs.splice(0, 0, [
                            DIFF_EQUAL,
                            text_insert.substring(0, commonlength)
                          ])
                          pointer++
                        }
                        text_insert = text_insert.substring(commonlength)
                        text_delete = text_delete.substring(commonlength)
                      }
                      // Factor out any common suffixies.
                      commonlength = this.diff_commonSuffix(
                        text_insert,
                        text_delete
                      )
                      if (commonlength !== 0) {
                        diffs[pointer][1] =
                          text_insert.substring(
                            text_insert.length - commonlength
                          ) + diffs[pointer][1]
                        text_insert = text_insert.substring(
                          0,
                          text_insert.length - commonlength
                        )
                        text_delete = text_delete.substring(
                          0,
                          text_delete.length - commonlength
                        )
                      }
                    }
                    // Delete the offending records and add the merged ones.
                    if (count_delete === 0) {
                      diffs.splice(
                        pointer - count_insert,
                        count_delete + count_insert,
                        [DIFF_INSERT, text_insert]
                      )
                    } else if (count_insert === 0) {
                      diffs.splice(
                        pointer - count_delete,
                        count_delete + count_insert,
                        [DIFF_DELETE, text_delete]
                      )
                    } else {
                      diffs.splice(
                        pointer - count_delete - count_insert,
                        count_delete + count_insert,
                        [DIFF_DELETE, text_delete],
                        [DIFF_INSERT, text_insert]
                      )
                    }
                    pointer =
                      pointer -
                      count_delete -
                      count_insert +
                      (count_delete ? 1 : 0) +
                      (count_insert ? 1 : 0) +
                      1
                  } else if (
                    pointer !== 0 &&
                    diffs[pointer - 1][0] == DIFF_EQUAL
                  ) {
                    // Merge this equality with the previous one.
                    diffs[pointer - 1][1] += diffs[pointer][1]
                    diffs.splice(pointer, 1)
                  } else {
                    pointer++
                  }
                  count_insert = 0
                  count_delete = 0
                  text_delete = ''
                  text_insert = ''
                  break
              }
            }
            if (diffs[diffs.length - 1][1] === '') {
              diffs.pop() // Remove the dummy entry at the end.
            }

            // Second pass: look for single edits surrounded on both sides by equalities
            // which can be shifted sideways to eliminate an equality.
            // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
            var changes = false
            pointer = 1
            // Intentionally ignore the first and last element (don't need checking).
            while (pointer < diffs.length - 1) {
              if (
                diffs[pointer - 1][0] == DIFF_EQUAL &&
                diffs[pointer + 1][0] == DIFF_EQUAL
              ) {
                // This is a single edit surrounded by equalities.
                if (
                  diffs[pointer][1].substring(
                    diffs[pointer][1].length - diffs[pointer - 1][1].length
                  ) == diffs[pointer - 1][1]
                ) {
                  // Shift the edit over the previous equality.
                  diffs[pointer][1] =
                    diffs[pointer - 1][1] +
                    diffs[pointer][1].substring(
                      0,
                      diffs[pointer][1].length - diffs[pointer - 1][1].length
                    )
                  diffs[pointer + 1][1] =
                    diffs[pointer - 1][1] + diffs[pointer + 1][1]
                  diffs.splice(pointer - 1, 1)
                  changes = true
                } else if (
                  diffs[pointer][1].substring(
                    0,
                    diffs[pointer + 1][1].length
                  ) == diffs[pointer + 1][1]
                ) {
                  // Shift the edit over the next equality.
                  diffs[pointer - 1][1] += diffs[pointer + 1][1]
                  diffs[pointer][1] =
                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
                    diffs[pointer + 1][1]
                  diffs.splice(pointer + 1, 1)
                  changes = true
                }
              }
              pointer++
            }
            // If shifts were made, the diff needs reordering and another shift sweep.
            if (changes) {
              this.diff_cleanupMerge(diffs)
            }
          }

          /**
           * loc is a location in text1, compute and return the equivalent location in
           * text2.
           * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @param {number} loc Location within text1.
           * @return {number} Location within text2.
           */
          diff_match_patch.prototype.diff_xIndex = function (diffs, loc) {
            var chars1 = 0
            var chars2 = 0
            var last_chars1 = 0
            var last_chars2 = 0
            var x
            for (x = 0; x < diffs.length; x++) {
              if (diffs[x][0] !== DIFF_INSERT) {
                // Equality or deletion.
                chars1 += diffs[x][1].length
              }
              if (diffs[x][0] !== DIFF_DELETE) {
                // Equality or insertion.
                chars2 += diffs[x][1].length
              }
              if (chars1 > loc) {
                // Overshot the location.
                break
              }
              last_chars1 = chars1
              last_chars2 = chars2
            }
            // Was the location was deleted?
            if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
              return last_chars2
            }
            // Add the remaining character length.
            return last_chars2 + (loc - last_chars1)
          }

          /**
           * Convert a diff array into a pretty HTML report.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} HTML representation.
           */
          diff_match_patch.prototype.diff_prettyHtml = function (diffs) {
            var html = []
            var pattern_amp = /&/g
            var pattern_lt = /</g
            var pattern_gt = />/g
            var pattern_para = /\n/g
            for (var x = 0; x < diffs.length; x++) {
              var op = diffs[x][0] // Operation (insert, delete, equal)
              var data = diffs[x][1] // Text of change.
              var text = data
                .replace(pattern_amp, '&amp;')
                .replace(pattern_lt, '&lt;')
                .replace(pattern_gt, '&gt;')
                .replace(pattern_para, '&para;<br>')
              switch (op) {
                case DIFF_INSERT:
                  html[x] =
                    '<ins style="background:#e6ffe6;">' + text + '</ins>'
                  break
                case DIFF_DELETE:
                  html[x] =
                    '<del style="background:#ffe6e6;">' + text + '</del>'
                  break
                case DIFF_EQUAL:
                  html[x] = '<span>' + text + '</span>'
                  break
              }
            }
            return html.join('')
          }

          /**
           * Compute and return the source text (all equalities and deletions).
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} Source text.
           */
          diff_match_patch.prototype.diff_text1 = function (diffs) {
            var text = []
            for (var x = 0; x < diffs.length; x++) {
              if (diffs[x][0] !== DIFF_INSERT) {
                text[x] = diffs[x][1]
              }
            }
            return text.join('')
          }

          /**
           * Compute and return the destination text (all equalities and insertions).
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} Destination text.
           */
          diff_match_patch.prototype.diff_text2 = function (diffs) {
            var text = []
            for (var x = 0; x < diffs.length; x++) {
              if (diffs[x][0] !== DIFF_DELETE) {
                text[x] = diffs[x][1]
              }
            }
            return text.join('')
          }

          /**
           * Compute the Levenshtein distance; the number of inserted, deleted or
           * substituted characters.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {number} Number of changes.
           */
          diff_match_patch.prototype.diff_levenshtein = function (diffs) {
            var levenshtein = 0
            var insertions = 0
            var deletions = 0
            for (var x = 0; x < diffs.length; x++) {
              var op = diffs[x][0]
              var data = diffs[x][1]
              switch (op) {
                case DIFF_INSERT:
                  insertions += data.length
                  break
                case DIFF_DELETE:
                  deletions += data.length
                  break
                case DIFF_EQUAL:
                  // A deletion and an insertion is one substitution.
                  levenshtein += Math.max(insertions, deletions)
                  insertions = 0
                  deletions = 0
                  break
              }
            }
            levenshtein += Math.max(insertions, deletions)
            return levenshtein
          }

          /**
           * Crush the diff into an encoded string which describes the operations
           * required to transform text1 into text2.
           * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
           * Operations are tab-separated.  Inserted text is escaped using %xx notation.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} Delta text.
           */
          diff_match_patch.prototype.diff_toDelta = function (diffs) {
            var text = []
            for (var x = 0; x < diffs.length; x++) {
              switch (diffs[x][0]) {
                case DIFF_INSERT:
                  text[x] = '+' + encodeURI(diffs[x][1])
                  break
                case DIFF_DELETE:
                  text[x] = '-' + diffs[x][1].length
                  break
                case DIFF_EQUAL:
                  text[x] = '=' + diffs[x][1].length
                  break
              }
            }
            return text.join('\t').replace(/%20/g, ' ')
          }

          /**
           * Given the original text1, and an encoded string which describes the
           * operations required to transform text1 into text2, compute the full diff.
           * @param {string} text1 Source string for the diff.
           * @param {string} delta Delta text.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @throws {!Error} If invalid input.
           */
          diff_match_patch.prototype.diff_fromDelta = function (text1, delta) {
            var diffs = []
            var diffsLength = 0 // Keeping our own length var is faster in JS.
            var pointer = 0 // Cursor in text1
            var tokens = delta.split(/\t/g)
            for (var x = 0; x < tokens.length; x++) {
              // Each token begins with a one character parameter which specifies the
              // operation of this token (delete, insert, equality).
              var param = tokens[x].substring(1)
              switch (tokens[x].charAt(0)) {
                case '+':
                  try {
                    diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)]
                  } catch (ex) {
                    // Malformed URI sequence.
                    throw new Error(
                      'Illegal escape in diff_fromDelta: ' + param
                    )
                  }
                  break
                case '-':
                // Fall through.
                case '=':
                  var n = parseInt(param, 10)
                  if (isNaN(n) || n < 0) {
                    throw new Error(
                      'Invalid number in diff_fromDelta: ' + param
                    )
                  }
                  var text = text1.substring(pointer, (pointer += n))
                  if (tokens[x].charAt(0) == '=') {
                    diffs[diffsLength++] = [DIFF_EQUAL, text]
                  } else {
                    diffs[diffsLength++] = [DIFF_DELETE, text]
                  }
                  break
                default:
                  // Blank tokens are ok (from a trailing \t).
                  // Anything else is an error.
                  if (tokens[x]) {
                    throw new Error(
                      'Invalid diff operation in diff_fromDelta: ' + tokens[x]
                    )
                  }
              }
            }
            if (pointer != text1.length) {
              throw new Error(
                'Delta length (' +
                  pointer +
                  ') does not equal source text length (' +
                  text1.length +
                  ').'
              )
            }
            return diffs
          }

          //  MATCH FUNCTIONS

          /**
           * Locate the best instance of 'pattern' in 'text' near 'loc'.
           * @param {string} text The text to search.
           * @param {string} pattern The pattern to search for.
           * @param {number} loc The location to search around.
           * @return {number} Best match index or -1.
           */
          diff_match_patch.prototype.match_main = function (
            text,
            pattern,
            loc
          ) {
            // Check for null inputs.
            if (text == null || pattern == null || loc == null) {
              throw new Error('Null input. (match_main)')
            }

            loc = Math.max(0, Math.min(loc, text.length))
            if (text == pattern) {
              // Shortcut (potentially not guaranteed by the algorithm)
              return 0
            } else if (!text.length) {
              // Nothing to match.
              return -1
            } else if (text.substring(loc, loc + pattern.length) == pattern) {
              // Perfect match at the perfect spot!  (Includes case of null pattern)
              return loc
            } else {
              // Do a fuzzy compare.
              return this.match_bitap_(text, pattern, loc)
            }
          }

          /**
           * Locate the best instance of 'pattern' in 'text' near 'loc' using the
           * Bitap algorithm.
           * @param {string} text The text to search.
           * @param {string} pattern The pattern to search for.
           * @param {number} loc The location to search around.
           * @return {number} Best match index or -1.
           * @private
           */
          diff_match_patch.prototype.match_bitap_ = function (
            text,
            pattern,
            loc
          ) {
            if (pattern.length > this.Match_MaxBits) {
              throw new Error('Pattern too long for this browser.')
            }

            // Initialise the alphabet.
            var s = this.match_alphabet_(pattern)

            var dmp = this // 'this' becomes 'window' in a closure.

            /**
             * Compute and return the score for a match with e errors and x location.
             * Accesses loc and pattern through being a closure.
             * @param {number} e Number of errors in match.
             * @param {number} x Location of match.
             * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
             * @private
             */
            function match_bitapScore_(e, x) {
              var accuracy = e / pattern.length
              var proximity = Math.abs(loc - x)
              if (!dmp.Match_Distance) {
                // Dodge divide by zero error.
                return proximity ? 1.0 : accuracy
              }
              return accuracy + proximity / dmp.Match_Distance
            }

            // Highest score beyond which we give up.
            var score_threshold = this.Match_Threshold
            // Is there a nearby exact match? (speedup)
            var best_loc = text.indexOf(pattern, loc)
            if (best_loc != -1) {
              score_threshold = Math.min(
                match_bitapScore_(0, best_loc),
                score_threshold
              )
              // What about in the other direction? (speedup)
              best_loc = text.lastIndexOf(pattern, loc + pattern.length)
              if (best_loc != -1) {
                score_threshold = Math.min(
                  match_bitapScore_(0, best_loc),
                  score_threshold
                )
              }
            }

            // Initialise the bit arrays.
            var matchmask = 1 << (pattern.length - 1)
            best_loc = -1

            var bin_min, bin_mid
            var bin_max = pattern.length + text.length
            var last_rd
            for (var d = 0; d < pattern.length; d++) {
              // Scan for the best match; each iteration allows for one more error.
              // Run a binary search to determine how far from 'loc' we can stray at this
              // error level.
              bin_min = 0
              bin_mid = bin_max
              while (bin_min < bin_mid) {
                if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
                  bin_min = bin_mid
                } else {
                  bin_max = bin_mid
                }
                bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min)
              }
              // Use the result from this iteration as the maximum for the next.
              bin_max = bin_mid
              var start = Math.max(1, loc - bin_mid + 1)
              var finish = Math.min(loc + bin_mid, text.length) + pattern.length

              var rd = Array(finish + 2)
              rd[finish + 1] = (1 << d) - 1
              for (var j = finish; j >= start; j--) {
                // The alphabet (s) is a sparse hash, so the following line generates
                // warnings.
                var charMatch = s[text.charAt(j - 1)]
                if (d === 0) {
                  // First pass: exact match.
                  rd[j] = ((rd[j + 1] << 1) | 1) & charMatch
                } else {
                  // Subsequent passes: fuzzy match.
                  rd[j] =
                    (((rd[j + 1] << 1) | 1) & charMatch) |
                    (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                    last_rd[j + 1]
                }
                if (rd[j] & matchmask) {
                  var score = match_bitapScore_(d, j - 1)
                  // This match will almost certainly be better than any existing match.
                  // But check anyway.
                  if (score <= score_threshold) {
                    // Told you so.
                    score_threshold = score
                    best_loc = j - 1
                    if (best_loc > loc) {
                      // When passing loc, don't exceed our current distance from loc.
                      start = Math.max(1, 2 * loc - best_loc)
                    } else {
                      // Already passed loc, downhill from here on in.
                      break
                    }
                  }
                }
              }
              // No hope for a (better) match at greater error levels.
              if (match_bitapScore_(d + 1, loc) > score_threshold) {
                break
              }
              last_rd = rd
            }
            return best_loc
          }

          /**
           * Initialise the alphabet for the Bitap algorithm.
           * @param {string} pattern The text to encode.
           * @return {!Object} Hash of character locations.
           * @private
           */
          diff_match_patch.prototype.match_alphabet_ = function (pattern) {
            var s = {}
            for (var i = 0; i < pattern.length; i++) {
              s[pattern.charAt(i)] = 0
            }
            for (var i = 0; i < pattern.length; i++) {
              s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1)
            }
            return s
          }

          //  PATCH FUNCTIONS

          /**
           * Increase the context until it is unique,
           * but don't let the pattern expand beyond Match_MaxBits.
           * @param {!diff_match_patch.patch_obj} patch The patch to grow.
           * @param {string} text Source text.
           * @private
           */
          diff_match_patch.prototype.patch_addContext_ = function (
            patch,
            text
          ) {
            if (text.length == 0) {
              return
            }
            var pattern = text.substring(
              patch.start2,
              patch.start2 + patch.length1
            )
            var padding = 0

            // Look for the first and last matches of pattern in text.  If two different
            // matches are found, increase the pattern length.
            while (
              text.indexOf(pattern) != text.lastIndexOf(pattern) &&
              pattern.length <
                this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin
            ) {
              padding += this.Patch_Margin
              pattern = text.substring(
                patch.start2 - padding,
                patch.start2 + patch.length1 + padding
              )
            }
            // Add one chunk for good luck.
            padding += this.Patch_Margin

            // Add the prefix.
            var prefix = text.substring(patch.start2 - padding, patch.start2)
            if (prefix) {
              patch.diffs.unshift([DIFF_EQUAL, prefix])
            }
            // Add the suffix.
            var suffix = text.substring(
              patch.start2 + patch.length1,
              patch.start2 + patch.length1 + padding
            )
            if (suffix) {
              patch.diffs.push([DIFF_EQUAL, suffix])
            }

            // Roll back the start points.
            patch.start1 -= prefix.length
            patch.start2 -= prefix.length
            // Extend the lengths.
            patch.length1 += prefix.length + suffix.length
            patch.length2 += prefix.length + suffix.length
          }

          /**
           * Compute a list of patches to turn text1 into text2.
           * Use diffs if provided, otherwise compute it ourselves.
           * There are four ways to call this function, depending on what data is
           * available to the caller:
           * Method 1:
           * a = text1, b = text2
           * Method 2:
           * a = diffs
           * Method 3 (optimal):
           * a = text1, b = diffs
           * Method 4 (deprecated, use method 3):
           * a = text1, b = text2, c = diffs
           *
           * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
           * Array of diff tuples for text1 to text2 (method 2).
           * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
           * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
           * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
           * for text1 to text2 (method 4) or undefined (methods 1,2,3).
           * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
           */
          diff_match_patch.prototype.patch_make = function (a, opt_b, opt_c) {
            var text1, diffs
            if (
              typeof a == 'string' &&
              typeof opt_b == 'string' &&
              typeof opt_c == 'undefined'
            ) {
              // Method 1: text1, text2
              // Compute diffs from text1 and text2.
              text1 = /** @type {string} */ (a)
              diffs = this.diff_main(text1, /** @type {string} */ (opt_b), true)
              if (diffs.length > 2) {
                this.diff_cleanupSemantic(diffs)
                this.diff_cleanupEfficiency(diffs)
              }
            } else if (
              a &&
              typeof a == 'object' &&
              typeof opt_b == 'undefined' &&
              typeof opt_c == 'undefined'
            ) {
              // Method 2: diffs
              // Compute text1 from diffs.
              diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ (a)
              text1 = this.diff_text1(diffs)
            } else if (
              typeof a == 'string' &&
              opt_b &&
              typeof opt_b == 'object' &&
              typeof opt_c == 'undefined'
            ) {
              // Method 3: text1, diffs
              text1 = /** @type {string} */ (a)
              diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ (opt_b)
            } else if (
              typeof a == 'string' &&
              typeof opt_b == 'string' &&
              opt_c &&
              typeof opt_c == 'object'
            ) {
              // Method 4: text1, text2, diffs
              // text2 is not used.
              text1 = /** @type {string} */ (a)
              diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ (opt_c)
            } else {
              throw new Error('Unknown call format to patch_make.')
            }

            if (diffs.length === 0) {
              return [] // Get rid of the null case.
            }
            var patches = []
            var patch = new diff_match_patch.patch_obj()
            var patchDiffLength = 0 // Keeping our own length var is faster in JS.
            var char_count1 = 0 // Number of characters into the text1 string.
            var char_count2 = 0 // Number of characters into the text2 string.
            // Start with text1 (prepatch_text) and apply the diffs until we arrive at
            // text2 (postpatch_text).  We recreate the patches one by one to determine
            // context info.
            var prepatch_text = text1
            var postpatch_text = text1
            for (var x = 0; x < diffs.length; x++) {
              var diff_type = diffs[x][0]
              var diff_text = diffs[x][1]

              if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
                // A new patch starts here.
                patch.start1 = char_count1
                patch.start2 = char_count2
              }

              switch (diff_type) {
                case DIFF_INSERT:
                  patch.diffs[patchDiffLength++] = diffs[x]
                  patch.length2 += diff_text.length
                  postpatch_text =
                    postpatch_text.substring(0, char_count2) +
                    diff_text +
                    postpatch_text.substring(char_count2)
                  break
                case DIFF_DELETE:
                  patch.length1 += diff_text.length
                  patch.diffs[patchDiffLength++] = diffs[x]
                  postpatch_text =
                    postpatch_text.substring(0, char_count2) +
                    postpatch_text.substring(char_count2 + diff_text.length)
                  break
                case DIFF_EQUAL:
                  if (
                    diff_text.length <= 2 * this.Patch_Margin &&
                    patchDiffLength &&
                    diffs.length != x + 1
                  ) {
                    // Small equality inside a patch.
                    patch.diffs[patchDiffLength++] = diffs[x]
                    patch.length1 += diff_text.length
                    patch.length2 += diff_text.length
                  } else if (diff_text.length >= 2 * this.Patch_Margin) {
                    // Time for a new patch.
                    if (patchDiffLength) {
                      this.patch_addContext_(patch, prepatch_text)
                      patches.push(patch)
                      patch = new diff_match_patch.patch_obj()
                      patchDiffLength = 0
                      // Unlike Unidiff, our patch lists have a rolling context.
                      // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
                      // Update prepatch text & pos to reflect the application of the
                      // just completed patch.
                      prepatch_text = postpatch_text
                      char_count1 = char_count2
                    }
                  }
                  break
              }

              // Update the current character count.
              if (diff_type !== DIFF_INSERT) {
                char_count1 += diff_text.length
              }
              if (diff_type !== DIFF_DELETE) {
                char_count2 += diff_text.length
              }
            }
            // Pick up the leftover patch if not empty.
            if (patchDiffLength) {
              this.patch_addContext_(patch, prepatch_text)
              patches.push(patch)
            }

            return patches
          }

          /**
           * Given an array of patches, return another array that is identical.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
           */
          diff_match_patch.prototype.patch_deepCopy = function (patches) {
            // Making deep copies is hard in JavaScript.
            var patchesCopy = []
            for (var x = 0; x < patches.length; x++) {
              var patch = patches[x]
              var patchCopy = new diff_match_patch.patch_obj()
              patchCopy.diffs = []
              for (var y = 0; y < patch.diffs.length; y++) {
                patchCopy.diffs[y] = patch.diffs[y].slice()
              }
              patchCopy.start1 = patch.start1
              patchCopy.start2 = patch.start2
              patchCopy.length1 = patch.length1
              patchCopy.length2 = patch.length2
              patchesCopy[x] = patchCopy
            }
            return patchesCopy
          }

          /**
           * Merge a set of patches onto the text.  Return a patched text, as well
           * as a list of true/false values indicating which patches were applied.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @param {string} text Old text.
           * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
           *      new text and an array of boolean values.
           */
          diff_match_patch.prototype.patch_apply = function (patches, text) {
            if (patches.length == 0) {
              return [text, []]
            }

            // Deep copy the patches so that no changes are made to originals.
            patches = this.patch_deepCopy(patches)

            var nullPadding = this.patch_addPadding(patches)
            text = nullPadding + text + nullPadding

            this.patch_splitMax(patches)
            // delta keeps track of the offset between the expected and actual location
            // of the previous patch.  If there are patches expected at positions 10 and
            // 20, but the first patch was found at 12, delta is 2 and the second patch
            // has an effective expected position of 22.
            var delta = 0
            var results = []
            for (var x = 0; x < patches.length; x++) {
              var expected_loc = patches[x].start2 + delta
              var text1 = this.diff_text1(patches[x].diffs)
              var start_loc
              var end_loc = -1
              if (text1.length > this.Match_MaxBits) {
                // patch_splitMax will only provide an oversized pattern in the case of
                // a monster delete.
                start_loc = this.match_main(
                  text,
                  text1.substring(0, this.Match_MaxBits),
                  expected_loc
                )
                if (start_loc != -1) {
                  end_loc = this.match_main(
                    text,
                    text1.substring(text1.length - this.Match_MaxBits),
                    expected_loc + text1.length - this.Match_MaxBits
                  )
                  if (end_loc == -1 || start_loc >= end_loc) {
                    // Can't find valid trailing context.  Drop this patch.
                    start_loc = -1
                  }
                }
              } else {
                start_loc = this.match_main(text, text1, expected_loc)
              }
              if (start_loc == -1) {
                // No match found.  :(
                results[x] = false
                // Subtract the delta for this failed patch from subsequent patches.
                delta -= patches[x].length2 - patches[x].length1
              } else {
                // Found a match.  :)
                results[x] = true
                delta = start_loc - expected_loc
                var text2
                if (end_loc == -1) {
                  text2 = text.substring(start_loc, start_loc + text1.length)
                } else {
                  text2 = text.substring(
                    start_loc,
                    end_loc + this.Match_MaxBits
                  )
                }
                if (text1 == text2) {
                  // Perfect match, just shove the replacement text in.
                  text =
                    text.substring(0, start_loc) +
                    this.diff_text2(patches[x].diffs) +
                    text.substring(start_loc + text1.length)
                } else {
                  // Imperfect match.  Run a diff to get a framework of equivalent
                  // indices.
                  var diffs = this.diff_main(text1, text2, false)
                  if (
                    text1.length > this.Match_MaxBits &&
                    this.diff_levenshtein(diffs) / text1.length >
                      this.Patch_DeleteThreshold
                  ) {
                    // The end points match, but the content is unacceptably bad.
                    results[x] = false
                  } else {
                    this.diff_cleanupSemanticLossless(diffs)
                    var index1 = 0
                    var index2
                    for (var y = 0; y < patches[x].diffs.length; y++) {
                      var mod = patches[x].diffs[y]
                      if (mod[0] !== DIFF_EQUAL) {
                        index2 = this.diff_xIndex(diffs, index1)
                      }
                      if (mod[0] === DIFF_INSERT) {
                        // Insertion
                        text =
                          text.substring(0, start_loc + index2) +
                          mod[1] +
                          text.substring(start_loc + index2)
                      } else if (mod[0] === DIFF_DELETE) {
                        // Deletion
                        text =
                          text.substring(0, start_loc + index2) +
                          text.substring(
                            start_loc +
                              this.diff_xIndex(diffs, index1 + mod[1].length)
                          )
                      }
                      if (mod[0] !== DIFF_DELETE) {
                        index1 += mod[1].length
                      }
                    }
                  }
                }
              }
            }
            // Strip the padding off.
            text = text.substring(
              nullPadding.length,
              text.length - nullPadding.length
            )
            return [text, results]
          }

          /**
           * Add some padding on text start and end so that edges can match something.
           * Intended to be called only from within patch_apply.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @return {string} The padding string added to each side.
           */
          diff_match_patch.prototype.patch_addPadding = function (patches) {
            var paddingLength = this.Patch_Margin
            var nullPadding = ''
            for (var x = 1; x <= paddingLength; x++) {
              nullPadding += String.fromCharCode(x)
            }

            // Bump all the patches forward.
            for (var x = 0; x < patches.length; x++) {
              patches[x].start1 += paddingLength
              patches[x].start2 += paddingLength
            }

            // Add some padding on start of first diff.
            var patch = patches[0]
            var diffs = patch.diffs
            if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
              // Add nullPadding equality.
              diffs.unshift([DIFF_EQUAL, nullPadding])
              patch.start1 -= paddingLength // Should be 0.
              patch.start2 -= paddingLength // Should be 0.
              patch.length1 += paddingLength
              patch.length2 += paddingLength
            } else if (paddingLength > diffs[0][1].length) {
              // Grow first equality.
              var extraLength = paddingLength - diffs[0][1].length
              diffs[0][1] =
                nullPadding.substring(diffs[0][1].length) + diffs[0][1]
              patch.start1 -= extraLength
              patch.start2 -= extraLength
              patch.length1 += extraLength
              patch.length2 += extraLength
            }

            // Add some padding on end of last diff.
            patch = patches[patches.length - 1]
            diffs = patch.diffs
            if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
              // Add nullPadding equality.
              diffs.push([DIFF_EQUAL, nullPadding])
              patch.length1 += paddingLength
              patch.length2 += paddingLength
            } else if (paddingLength > diffs[diffs.length - 1][1].length) {
              // Grow last equality.
              var extraLength =
                paddingLength - diffs[diffs.length - 1][1].length
              diffs[diffs.length - 1][1] += nullPadding.substring(
                0,
                extraLength
              )
              patch.length1 += extraLength
              patch.length2 += extraLength
            }

            return nullPadding
          }

          /**
           * Look through the patches and break up any which are longer than the maximum
           * limit of the match algorithm.
           * Intended to be called only from within patch_apply.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           */
          diff_match_patch.prototype.patch_splitMax = function (patches) {
            var patch_size = this.Match_MaxBits
            for (var x = 0; x < patches.length; x++) {
              if (patches[x].length1 <= patch_size) {
                continue
              }
              var bigpatch = patches[x]
              // Remove the big old patch.
              patches.splice(x--, 1)
              var start1 = bigpatch.start1
              var start2 = bigpatch.start2
              var precontext = ''
              while (bigpatch.diffs.length !== 0) {
                // Create one of several smaller patches.
                var patch = new diff_match_patch.patch_obj()
                var empty = true
                patch.start1 = start1 - precontext.length
                patch.start2 = start2 - precontext.length
                if (precontext !== '') {
                  patch.length1 = patch.length2 = precontext.length
                  patch.diffs.push([DIFF_EQUAL, precontext])
                }
                while (
                  bigpatch.diffs.length !== 0 &&
                  patch.length1 < patch_size - this.Patch_Margin
                ) {
                  var diff_type = bigpatch.diffs[0][0]
                  var diff_text = bigpatch.diffs[0][1]
                  if (diff_type === DIFF_INSERT) {
                    // Insertions are harmless.
                    patch.length2 += diff_text.length
                    start2 += diff_text.length
                    patch.diffs.push(bigpatch.diffs.shift())
                    empty = false
                  } else if (
                    diff_type === DIFF_DELETE &&
                    patch.diffs.length == 1 &&
                    patch.diffs[0][0] == DIFF_EQUAL &&
                    diff_text.length > 2 * patch_size
                  ) {
                    // This is a large deletion.  Let it pass in one chunk.
                    patch.length1 += diff_text.length
                    start1 += diff_text.length
                    empty = false
                    patch.diffs.push([diff_type, diff_text])
                    bigpatch.diffs.shift()
                  } else {
                    // Deletion or equality.  Only take as much as we can stomach.
                    diff_text = diff_text.substring(
                      0,
                      patch_size - patch.length1 - this.Patch_Margin
                    )
                    patch.length1 += diff_text.length
                    start1 += diff_text.length
                    if (diff_type === DIFF_EQUAL) {
                      patch.length2 += diff_text.length
                      start2 += diff_text.length
                    } else {
                      empty = false
                    }
                    patch.diffs.push([diff_type, diff_text])
                    if (diff_text == bigpatch.diffs[0][1]) {
                      bigpatch.diffs.shift()
                    } else {
                      bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(
                        diff_text.length
                      )
                    }
                  }
                }
                // Compute the head context for the next patch.
                precontext = this.diff_text2(patch.diffs)
                precontext = precontext.substring(
                  precontext.length - this.Patch_Margin
                )
                // Append the end context for this patch.
                var postcontext = this.diff_text1(bigpatch.diffs).substring(
                  0,
                  this.Patch_Margin
                )
                if (postcontext !== '') {
                  patch.length1 += postcontext.length
                  patch.length2 += postcontext.length
                  if (
                    patch.diffs.length !== 0 &&
                    patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL
                  ) {
                    patch.diffs[patch.diffs.length - 1][1] += postcontext
                  } else {
                    patch.diffs.push([DIFF_EQUAL, postcontext])
                  }
                }
                if (!empty) {
                  patches.splice(++x, 0, patch)
                }
              }
            }
          }

          /**
           * Take a list of patches and return a textual representation.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @return {string} Text representation of patches.
           */
          diff_match_patch.prototype.patch_toText = function (patches) {
            var text = []
            for (var x = 0; x < patches.length; x++) {
              text[x] = patches[x]
            }
            return text.join('')
          }

          /**
           * Parse a textual representation of patches and return a list of Patch objects.
           * @param {string} textline Text representation of patches.
           * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
           * @throws {!Error} If invalid input.
           */
          diff_match_patch.prototype.patch_fromText = function (textline) {
            var patches = []
            if (!textline) {
              return patches
            }
            var text = textline.split('\n')
            var textPointer = 0
            var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/
            while (textPointer < text.length) {
              var m = text[textPointer].match(patchHeader)
              if (!m) {
                throw new Error('Invalid patch string: ' + text[textPointer])
              }
              var patch = new diff_match_patch.patch_obj()
              patches.push(patch)
              patch.start1 = parseInt(m[1], 10)
              if (m[2] === '') {
                patch.start1--
                patch.length1 = 1
              } else if (m[2] == '0') {
                patch.length1 = 0
              } else {
                patch.start1--
                patch.length1 = parseInt(m[2], 10)
              }

              patch.start2 = parseInt(m[3], 10)
              if (m[4] === '') {
                patch.start2--
                patch.length2 = 1
              } else if (m[4] == '0') {
                patch.length2 = 0
              } else {
                patch.start2--
                patch.length2 = parseInt(m[4], 10)
              }
              textPointer++

              while (textPointer < text.length) {
                var sign = text[textPointer].charAt(0)
                try {
                  var line = decodeURI(text[textPointer].substring(1))
                } catch (ex) {
                  // Malformed URI sequence.
                  throw new Error('Illegal escape in patch_fromText: ' + line)
                }
                if (sign == '-') {
                  // Deletion.
                  patch.diffs.push([DIFF_DELETE, line])
                } else if (sign == '+') {
                  // Insertion.
                  patch.diffs.push([DIFF_INSERT, line])
                } else if (sign == ' ') {
                  // Minor equality.
                  patch.diffs.push([DIFF_EQUAL, line])
                } else if (sign == '@') {
                  // Start of next patch.
                  break
                } else if (sign === '') {
                  // Blank line?  Whatever.
                } else {
                  // WTF?
                  throw new Error(
                    'Invalid patch mode "' + sign + '" in: ' + line
                  )
                }
                textPointer++
              }
            }
            return patches
          }

          /**
           * Class representing one patch operation.
           * @constructor
           */
          diff_match_patch.patch_obj = function () {
            /** @type {!Array.<!diff_match_patch.Diff>} */
            this.diffs = []
            /** @type {?number} */
            this.start1 = null
            /** @type {?number} */
            this.start2 = null
            /** @type {number} */
            this.length1 = 0
            /** @type {number} */
            this.length2 = 0
          }

          /**
           * Emmulate GNU diff's format.
           * Header: @@ -382,8 +481,9 @@
           * Indicies are printed as 1-based, not 0-based.
           * @return {string} The GNU diff string.
           */
          diff_match_patch.patch_obj.prototype.toString = function () {
            var coords1, coords2
            if (this.length1 === 0) {
              coords1 = this.start1 + ',0'
            } else if (this.length1 == 1) {
              coords1 = this.start1 + 1
            } else {
              coords1 = this.start1 + 1 + ',' + this.length1
            }
            if (this.length2 === 0) {
              coords2 = this.start2 + ',0'
            } else if (this.length2 == 1) {
              coords2 = this.start2 + 1
            } else {
              coords2 = this.start2 + 1 + ',' + this.length2
            }
            var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n']
            var op
            // Escape the body of the patch with %xx notation.
            for (var x = 0; x < this.diffs.length; x++) {
              switch (this.diffs[x][0]) {
                case DIFF_INSERT:
                  op = '+'
                  break
                case DIFF_DELETE:
                  op = '-'
                  break
                case DIFF_EQUAL:
                  op = ' '
                  break
              }
              text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n'
            }
            return text.join('').replace(/%20/g, ' ')
          }

          // The following export code was added by @ForbesLindesay
          module.exports = diff_match_patch
          module.exports['diff_match_patch'] = diff_match_patch
          module.exports['DIFF_DELETE'] = DIFF_DELETE
          module.exports['DIFF_INSERT'] = DIFF_INSERT
          module.exports['DIFF_EQUAL'] = DIFF_EQUAL
        })

        /* global diff_match_patch */
        var TEXT_DIFF = 2
        var DEFAULT_MIN_LENGTH = 60
        var cachedDiffPatch = null

        var getDiffMatchPatch = function getDiffMatchPatch(required) {
          /* jshint camelcase: false */

          if (!cachedDiffPatch) {
            var instance = void 0
            /* eslint-disable camelcase, new-cap */
            if (typeof diff_match_patch !== 'undefined') {
              // already loaded, probably a browser
              instance =
                typeof diff_match_patch === 'function'
                  ? new diff_match_patch()
                  : new diff_match_patch.diff_match_patch()
            } else if (diffMatchPatch) {
              try {
                instance = diffMatchPatch && new diffMatchPatch()
              } catch (err) {
                instance = null
              }
            }
            /* eslint-enable camelcase, new-cap */
            if (!instance) {
              if (!required) {
                return null
              }
              var error = new Error('text diff_match_patch library not found')
              // eslint-disable-next-line camelcase
              error.diff_match_patch_not_found = true
              throw error
            }
            cachedDiffPatch = {
              diff: function diff(txt1, txt2) {
                return instance.patch_toText(instance.patch_make(txt1, txt2))
              },
              patch: function patch(txt1, _patch) {
                var results = instance.patch_apply(
                  instance.patch_fromText(_patch),
                  txt1
                )
                for (var i = 0; i < results[1].length; i++) {
                  if (!results[1][i]) {
                    var _error = new Error('text patch failed')
                    _error.textPatchFailed = true
                  }
                }
                return results[0]
              }
            }
          }
          return cachedDiffPatch
        }

        var diffFilter$3 = function textsDiffFilter(context) {
          if (context.leftType !== 'string') {
            return
          }
          var minLength =
            (context.options &&
              context.options.textDiff &&
              context.options.textDiff.minLength) ||
            DEFAULT_MIN_LENGTH
          if (
            context.left.length < minLength ||
            context.right.length < minLength
          ) {
            context.setResult([context.left, context.right]).exit()
            return
          }
          // large text, try to use a text-diff algorithm
          var diffMatchPatch$$1 = getDiffMatchPatch()
          if (!diffMatchPatch$$1) {
            // diff-match-patch library not available,
            // fallback to regular string replace
            context.setResult([context.left, context.right]).exit()
            return
          }
          var diff = diffMatchPatch$$1.diff
          context
            .setResult([diff(context.left, context.right), 0, TEXT_DIFF])
            .exit()
        }
        diffFilter$3.filterName = 'texts'

        var patchFilter$3 = function textsPatchFilter(context) {
          if (context.nested) {
            return
          }
          if (context.delta[2] !== TEXT_DIFF) {
            return
          }

          // text-diff, use a text-patch algorithm
          var patch = getDiffMatchPatch(true).patch
          context.setResult(patch(context.left, context.delta[0])).exit()
        }
        patchFilter$3.filterName = 'texts'

        var textDeltaReverse = function textDeltaReverse(delta) {
          var i = void 0
          var l = void 0
          var lines = void 0
          var line = void 0
          var lineTmp = void 0
          var header = null
          var headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/
          var lineHeader = void 0
          lines = delta.split('\n')
          for (i = 0, l = lines.length; i < l; i++) {
            line = lines[i]
            var lineStart = line.slice(0, 1)
            if (lineStart === '@') {
              header = headerRegex.exec(line)
              lineHeader = i

              // fix header
              lines[lineHeader] =
                '@@ -' +
                header[3] +
                ',' +
                header[4] +
                ' +' +
                header[1] +
                ',' +
                header[2] +
                ' @@'
            } else if (lineStart === '+') {
              lines[i] = '-' + lines[i].slice(1)
              if (lines[i - 1].slice(0, 1) === '+') {
                // swap lines to keep default order (-+)
                lineTmp = lines[i]
                lines[i] = lines[i - 1]
                lines[i - 1] = lineTmp
              }
            } else if (lineStart === '-') {
              lines[i] = '+' + lines[i].slice(1)
            }
          }
          return lines.join('\n')
        }

        var reverseFilter$3 = function textsReverseFilter(context) {
          if (context.nested) {
            return
          }
          if (context.delta[2] !== TEXT_DIFF) {
            return
          }

          // text-diff, use a text-diff algorithm
          context
            .setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF])
            .exit()
        }
        reverseFilter$3.filterName = 'texts'

        var DiffPatcher = (function () {
          function DiffPatcher(options) {
            classCallCheck(this, DiffPatcher)

            this.processor = new Processor(options)
            this.processor.pipe(
              new Pipe('diff')
                .append(
                  collectChildrenDiffFilter,
                  diffFilter,
                  diffFilter$2,
                  diffFilter$3,
                  objectsDiffFilter,
                  diffFilter$1
                )
                .shouldHaveResult()
            )
            this.processor.pipe(
              new Pipe('patch')
                .append(
                  collectChildrenPatchFilter,
                  collectChildrenPatchFilter$1,
                  patchFilter,
                  patchFilter$3,
                  patchFilter$1,
                  patchFilter$2
                )
                .shouldHaveResult()
            )
            this.processor.pipe(
              new Pipe('reverse')
                .append(
                  collectChildrenReverseFilter,
                  collectChildrenReverseFilter$1,
                  reverseFilter,
                  reverseFilter$3,
                  reverseFilter$1,
                  reverseFilter$2
                )
                .shouldHaveResult()
            )
          }

          createClass(DiffPatcher, [
            {
              key: 'options',
              value: function options() {
                var _processor

                return (_processor = this.processor).options.apply(
                  _processor,
                  arguments
                )
              }
            },
            {
              key: 'diff',
              value: function diff(left, right) {
                return this.processor.process(new DiffContext(left, right))
              }
            },
            {
              key: 'patch',
              value: function patch(left, delta) {
                return this.processor.process(new PatchContext(left, delta))
              }
            },
            {
              key: 'reverse',
              value: function reverse(delta) {
                return this.processor.process(new ReverseContext(delta))
              }
            },
            {
              key: 'unpatch',
              value: function unpatch(right, delta) {
                return this.patch(right, this.reverse(delta))
              }
            },
            {
              key: 'clone',
              value: function clone$$1(value) {
                return clone(value)
              }
            }
          ])
          return DiffPatcher
        })()

        var isArray$3 =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : function (a) {
                return a instanceof Array
              }

        var getObjectKeys =
          typeof Object.keys === 'function'
            ? function (obj) {
                return Object.keys(obj)
              }
            : function (obj) {
                var names = []
                for (var property in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, property)) {
                    names.push(property)
                  }
                }
                return names
              }

        var trimUnderscore = function trimUnderscore(str) {
          if (str.substr(0, 1) === '_') {
            return str.slice(1)
          }
          return str
        }

        var arrayKeyToSortNumber = function arrayKeyToSortNumber(key) {
          if (key === '_t') {
            return -1
          } else {
            if (key.substr(0, 1) === '_') {
              return parseInt(key.slice(1), 10)
            } else {
              return parseInt(key, 10) + 0.1
            }
          }
        }

        var arrayKeyComparer = function arrayKeyComparer(key1, key2) {
          return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2)
        }

        var BaseFormatter = (function () {
          function BaseFormatter() {
            classCallCheck(this, BaseFormatter)
          }

          createClass(BaseFormatter, [
            {
              key: 'format',
              value: function format(delta, left) {
                var context = {}
                this.prepareContext(context)
                this.recurse(context, delta, left)
                return this.finalize(context)
              }
            },
            {
              key: 'prepareContext',
              value: function prepareContext(context) {
                context.buffer = []
                context.out = function () {
                  var _buffer

                  ;(_buffer = this.buffer).push.apply(_buffer, arguments)
                }
              }
            },
            {
              key: 'typeFormattterNotFound',
              value: function typeFormattterNotFound(context, deltaType) {
                throw new Error('cannot format delta type: ' + deltaType)
              }
            },
            {
              key: 'typeFormattterErrorFormatter',
              value: function typeFormattterErrorFormatter(context, err) {
                return err.toString()
              }
            },
            {
              key: 'finalize',
              value: function finalize(_ref) {
                var buffer = _ref.buffer

                if (isArray$3(buffer)) {
                  return buffer.join('')
                }
              }
            },
            {
              key: 'recurse',
              value: function recurse(
                context,
                delta,
                left,
                key,
                leftKey,
                movedFrom,
                isLast
              ) {
                var useMoveOriginHere = delta && movedFrom
                var leftValue = useMoveOriginHere ? movedFrom.value : left

                if (
                  typeof delta === 'undefined' &&
                  typeof key === 'undefined'
                ) {
                  return undefined
                }

                var type = this.getDeltaType(delta, movedFrom)
                var nodeType =
                  type === 'node' ? (delta._t === 'a' ? 'array' : 'object') : ''

                if (typeof key !== 'undefined') {
                  this.nodeBegin(context, key, leftKey, type, nodeType, isLast)
                } else {
                  this.rootBegin(context, type, nodeType)
                }

                var typeFormattter = void 0
                try {
                  typeFormattter =
                    this['format_' + type] ||
                    this.typeFormattterNotFound(context, type)
                  typeFormattter.call(
                    this,
                    context,
                    delta,
                    leftValue,
                    key,
                    leftKey,
                    movedFrom
                  )
                } catch (err) {
                  this.typeFormattterErrorFormatter(
                    context,
                    err,
                    delta,
                    leftValue,
                    key,
                    leftKey,
                    movedFrom
                  )
                  if (typeof console !== 'undefined' && console.error) {
                    console.error(err.stack)
                  }
                }

                if (typeof key !== 'undefined') {
                  this.nodeEnd(context, key, leftKey, type, nodeType, isLast)
                } else {
                  this.rootEnd(context, type, nodeType)
                }
              }
            },
            {
              key: 'formatDeltaChildren',
              value: function formatDeltaChildren(context, delta, left) {
                var self = this
                this.forEachDeltaKey(
                  delta,
                  left,
                  function (key, leftKey, movedFrom, isLast) {
                    self.recurse(
                      context,
                      delta[key],
                      left ? left[leftKey] : undefined,
                      key,
                      leftKey,
                      movedFrom,
                      isLast
                    )
                  }
                )
              }
            },
            {
              key: 'forEachDeltaKey',
              value: function forEachDeltaKey(delta, left, fn) {
                var keys = getObjectKeys(delta)
                var arrayKeys = delta._t === 'a'
                var moveDestinations = {}
                var name = void 0
                if (typeof left !== 'undefined') {
                  for (name in left) {
                    if (Object.prototype.hasOwnProperty.call(left, name)) {
                      if (
                        typeof delta[name] === 'undefined' &&
                        (!arrayKeys || typeof delta['_' + name] === 'undefined')
                      ) {
                        keys.push(name)
                      }
                    }
                  }
                }
                // look for move destinations
                for (name in delta) {
                  if (Object.prototype.hasOwnProperty.call(delta, name)) {
                    var value = delta[name]
                    if (isArray$3(value) && value[2] === 3) {
                      moveDestinations[value[1].toString()] = {
                        key: name,
                        value: left && left[parseInt(name.substr(1))]
                      }
                      if (this.includeMoveDestinations !== false) {
                        if (
                          typeof left === 'undefined' &&
                          typeof delta[value[1]] === 'undefined'
                        ) {
                          keys.push(value[1].toString())
                        }
                      }
                    }
                  }
                }
                if (arrayKeys) {
                  keys.sort(arrayKeyComparer)
                } else {
                  keys.sort()
                }
                for (
                  var index = 0, length = keys.length;
                  index < length;
                  index++
                ) {
                  var key = keys[index]
                  if (arrayKeys && key === '_t') {
                    continue
                  }
                  var leftKey = arrayKeys
                    ? typeof key === 'number'
                      ? key
                      : parseInt(trimUnderscore(key), 10)
                    : key
                  var isLast = index === length - 1
                  fn(key, leftKey, moveDestinations[leftKey], isLast)
                }
              }
            },
            {
              key: 'getDeltaType',
              value: function getDeltaType(delta, movedFrom) {
                if (typeof delta === 'undefined') {
                  if (typeof movedFrom !== 'undefined') {
                    return 'movedestination'
                  }
                  return 'unchanged'
                }
                if (isArray$3(delta)) {
                  if (delta.length === 1) {
                    return 'added'
                  }
                  if (delta.length === 2) {
                    return 'modified'
                  }
                  if (delta.length === 3 && delta[2] === 0) {
                    return 'deleted'
                  }
                  if (delta.length === 3 && delta[2] === 2) {
                    return 'textdiff'
                  }
                  if (delta.length === 3 && delta[2] === 3) {
                    return 'moved'
                  }
                } else if (
                  (typeof delta === 'undefined'
                    ? 'undefined'
                    : _typeof(delta)) === 'object'
                ) {
                  return 'node'
                }
                return 'unknown'
              }
            },
            {
              key: 'parseTextDiff',
              value: function parseTextDiff(value) {
                var output = []
                var lines = value.split('\n@@ ')
                for (var i = 0, l = lines.length; i < l; i++) {
                  var line = lines[i]
                  var lineOutput = {
                    pieces: []
                  }
                  var location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1)
                  lineOutput.location = {
                    line: location[0],
                    chr: location[1]
                  }
                  var pieces = line.split('\n').slice(1)
                  for (
                    var pieceIndex = 0, piecesLength = pieces.length;
                    pieceIndex < piecesLength;
                    pieceIndex++
                  ) {
                    var piece = pieces[pieceIndex]
                    if (!piece.length) {
                      continue
                    }
                    var pieceOutput = {
                      type: 'context'
                    }
                    if (piece.substr(0, 1) === '+') {
                      pieceOutput.type = 'added'
                    } else if (piece.substr(0, 1) === '-') {
                      pieceOutput.type = 'deleted'
                    }
                    pieceOutput.text = piece.slice(1)
                    lineOutput.pieces.push(pieceOutput)
                  }
                  output.push(lineOutput)
                }
                return output
              }
            }
          ])
          return BaseFormatter
        })()

        var base = Object.freeze({
          default: BaseFormatter
        })

        var HtmlFormatter = (function (_BaseFormatter) {
          inherits(HtmlFormatter, _BaseFormatter)

          function HtmlFormatter() {
            classCallCheck(this, HtmlFormatter)
            return possibleConstructorReturn(
              this,
              (
                HtmlFormatter.__proto__ || Object.getPrototypeOf(HtmlFormatter)
              ).apply(this, arguments)
            )
          }

          createClass(HtmlFormatter, [
            {
              key: 'typeFormattterErrorFormatter',
              value: function typeFormattterErrorFormatter(context, err) {
                context.out(
                  '<pre class="jsondiffpatch-error">' + err + '</pre>'
                )
              }
            },
            {
              key: 'formatValue',
              value: function formatValue(context, value) {
                context.out(
                  '<pre>' +
                    htmlEscape(JSON.stringify(value, null, 2)) +
                    '</pre>'
                )
              }
            },
            {
              key: 'formatTextDiffString',
              value: function formatTextDiffString(context, value) {
                var lines = this.parseTextDiff(value)
                context.out('<ul class="jsondiffpatch-textdiff">')
                for (var i = 0, l = lines.length; i < l; i++) {
                  var line = lines[i]
                  context.out(
                    '<li><div class="jsondiffpatch-textdiff-location">' +
                      ('<span class="jsondiffpatch-textdiff-line-number">' +
                        line.location.line +
                        '</span><span class="jsondiffpatch-textdiff-char">' +
                        line.location.chr +
                        '</span></div><div class="jsondiffpatch-textdiff-line">')
                  )
                  var pieces = line.pieces
                  for (
                    var pieceIndex = 0, piecesLength = pieces.length;
                    pieceIndex < piecesLength;
                    pieceIndex++
                  ) {
                    /* global decodeURI */
                    var piece = pieces[pieceIndex]
                    context.out(
                      '<span class="jsondiffpatch-textdiff-' +
                        piece.type +
                        '">' +
                        htmlEscape(decodeURI(piece.text)) +
                        '</span>'
                    )
                  }
                  context.out('</div></li>')
                }
                context.out('</ul>')
              }
            },
            {
              key: 'rootBegin',
              value: function rootBegin(context, type, nodeType) {
                var nodeClass =
                  'jsondiffpatch-' +
                  type +
                  (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '')
                context.out(
                  '<div class="jsondiffpatch-delta ' + nodeClass + '">'
                )
              }
            },
            {
              key: 'rootEnd',
              value: function rootEnd(context) {
                context.out(
                  '</div>' +
                    (context.hasArrows
                      ? '<script type="text/javascript">setTimeout(' +
                        (adjustArrows.toString() + ',10);</script>')
                      : '')
                )
              }
            },
            {
              key: 'nodeBegin',
              value: function nodeBegin(context, key, leftKey, type, nodeType) {
                var nodeClass =
                  'jsondiffpatch-' +
                  type +
                  (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '')
                context.out(
                  '<li class="' +
                    nodeClass +
                    '" data-key="' +
                    leftKey +
                    '">' +
                    ('<div class="jsondiffpatch-property-name">' +
                      leftKey +
                      '</div>')
                )
              }
            },
            {
              key: 'nodeEnd',
              value: function nodeEnd(context) {
                context.out('</li>')
              }

              /* jshint camelcase: false */
              /* eslint-disable camelcase */
            },
            {
              key: 'format_unchanged',
              value: function format_unchanged(context, delta, left) {
                if (typeof left === 'undefined') {
                  return
                }
                context.out('<div class="jsondiffpatch-value">')
                this.formatValue(context, left)
                context.out('</div>')
              }
            },
            {
              key: 'format_movedestination',
              value: function format_movedestination(context, delta, left) {
                if (typeof left === 'undefined') {
                  return
                }
                context.out('<div class="jsondiffpatch-value">')
                this.formatValue(context, left)
                context.out('</div>')
              }
            },
            {
              key: 'format_node',
              value: function format_node(context, delta, left) {
                // recurse
                var nodeType = delta._t === 'a' ? 'array' : 'object'
                context.out(
                  '<ul class="jsondiffpatch-node jsondiffpatch-node-type-' +
                    nodeType +
                    '">'
                )
                this.formatDeltaChildren(context, delta, left)
                context.out('</ul>')
              }
            },
            {
              key: 'format_added',
              value: function format_added(context, delta) {
                context.out('<div class="jsondiffpatch-value">')
                this.formatValue(context, delta[0])
                context.out('</div>')
              }
            },
            {
              key: 'format_modified',
              value: function format_modified(context, delta) {
                context.out(
                  '<div class="jsondiffpatch-value jsondiffpatch-left-value">'
                )
                this.formatValue(context, delta[0])
                context.out(
                  '</div>' +
                    '<div class="jsondiffpatch-value jsondiffpatch-right-value">'
                )
                this.formatValue(context, delta[1])
                context.out('</div>')
              }
            },
            {
              key: 'format_deleted',
              value: function format_deleted(context, delta) {
                context.out('<div class="jsondiffpatch-value">')
                this.formatValue(context, delta[0])
                context.out('</div>')
              }
            },
            {
              key: 'format_moved',
              value: function format_moved(context, delta) {
                context.out('<div class="jsondiffpatch-value">')
                this.formatValue(context, delta[0])
                context.out(
                  '</div><div class="jsondiffpatch-moved-destination">' +
                    delta[1] +
                    '</div>'
                )

                // draw an SVG arrow from here to move destination
                context.out(
                  /* jshint multistr: true */
                  '<div class="jsondiffpatch-arrow" ' +
                    'style="position: relative; left: -34px;">\n          <svg width="30" height="60" ' +
                    'style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; ' +
                    'stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>'
                )
                context.hasArrows = true
              }
            },
            {
              key: 'format_textdiff',
              value: function format_textdiff(context, delta) {
                context.out('<div class="jsondiffpatch-value">')
                this.formatTextDiffString(context, delta[0])
                context.out('</div>')
              }
            }
          ])
          return HtmlFormatter
        })(BaseFormatter)

        function htmlEscape(text) {
          var html = text
          var replacements = [
            [/&/g, '&amp;'],
            [/</g, '&lt;'],
            [/>/g, '&gt;'],
            [/'/g, '&apos;'],
            [/"/g, '&quot;']
          ]
          for (var i = 0; i < replacements.length; i++) {
            html = html.replace(replacements[i][0], replacements[i][1])
          }
          return html
        }

        var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(
          nodeArg
        ) {
          var node = nodeArg || document
          var getElementText = function getElementText(_ref) {
            var textContent = _ref.textContent,
              innerText = _ref.innerText
            return textContent || innerText
          }
          var eachByQuery = function eachByQuery(el, query, fn) {
            var elems = el.querySelectorAll(query)
            for (var i = 0, l = elems.length; i < l; i++) {
              fn(elems[i])
            }
          }
          var eachChildren = function eachChildren(_ref2, fn) {
            var children = _ref2.children

            for (var i = 0, l = children.length; i < l; i++) {
              fn(children[i], i)
            }
          }
          eachByQuery(node, '.jsondiffpatch-arrow', function (_ref3) {
            var parentNode = _ref3.parentNode,
              children = _ref3.children,
              style = _ref3.style

            var arrowParent = parentNode
            var svg = children[0]
            var path = svg.children[1]
            svg.style.display = 'none'
            var destination = getElementText(
              arrowParent.querySelector('.jsondiffpatch-moved-destination')
            )
            var container = arrowParent.parentNode
            var destinationElem = void 0
            eachChildren(container, function (child) {
              if (child.getAttribute('data-key') === destination) {
                destinationElem = child
              }
            })
            if (!destinationElem) {
              return
            }
            try {
              var distance = destinationElem.offsetTop - arrowParent.offsetTop
              svg.setAttribute('height', Math.abs(distance) + 6)
              style.top = -8 + (distance > 0 ? 0 : distance) + 'px'
              var curve =
                distance > 0
                  ? 'M30,0 Q-10,' +
                    Math.round(distance / 2) +
                    ' 26,' +
                    (distance - 4)
                  : 'M30,' +
                    -distance +
                    ' Q-10,' +
                    Math.round(-distance / 2) +
                    ' 26,4'
              path.setAttribute('d', curve)
              svg.style.display = ''
            } catch (err) {}
          })
        }

        /* jshint camelcase: true */
        /* eslint-enable camelcase */

        var showUnchanged = function showUnchanged(show, node, delay) {
          var el = node || document.body
          var prefix = 'jsondiffpatch-unchanged-'
          var classes = {
            showing: prefix + 'showing',
            hiding: prefix + 'hiding',
            visible: prefix + 'visible',
            hidden: prefix + 'hidden'
          }
          var list = el.classList
          if (!list) {
            return
          }
          if (!delay) {
            list.remove(classes.showing)
            list.remove(classes.hiding)
            list.remove(classes.visible)
            list.remove(classes.hidden)
            if (show === false) {
              list.add(classes.hidden)
            }
            return
          }
          if (show === false) {
            list.remove(classes.showing)
            list.add(classes.visible)
            setTimeout(function () {
              list.add(classes.hiding)
            }, 10)
          } else {
            list.remove(classes.hiding)
            list.add(classes.showing)
            list.remove(classes.hidden)
          }
          var intervalId = setInterval(function () {
            adjustArrows(el)
          }, 100)
          setTimeout(function () {
            list.remove(classes.showing)
            list.remove(classes.hiding)
            if (show === false) {
              list.add(classes.hidden)
              list.remove(classes.visible)
            } else {
              list.add(classes.visible)
              list.remove(classes.hidden)
            }
            setTimeout(function () {
              list.remove(classes.visible)
              clearInterval(intervalId)
            }, delay + 400)
          }, delay)
        }

        var hideUnchanged = function hideUnchanged(node, delay) {
          return showUnchanged(false, node, delay)
        }

        var defaultInstance = void 0

        function format(delta, left) {
          if (!defaultInstance) {
            defaultInstance = new HtmlFormatter()
          }
          return defaultInstance.format(delta, left)
        }

        var html = Object.freeze({
          showUnchanged: showUnchanged,
          hideUnchanged: hideUnchanged,
          default: HtmlFormatter,
          format: format
        })

        var AnnotatedFormatter = (function (_BaseFormatter) {
          inherits(AnnotatedFormatter, _BaseFormatter)

          function AnnotatedFormatter() {
            classCallCheck(this, AnnotatedFormatter)

            var _this = possibleConstructorReturn(
              this,
              (
                AnnotatedFormatter.__proto__ ||
                Object.getPrototypeOf(AnnotatedFormatter)
              ).call(this)
            )

            _this.includeMoveDestinations = false
            return _this
          }

          createClass(AnnotatedFormatter, [
            {
              key: 'prepareContext',
              value: function prepareContext(context) {
                get(
                  AnnotatedFormatter.prototype.__proto__ ||
                    Object.getPrototypeOf(AnnotatedFormatter.prototype),
                  'prepareContext',
                  this
                ).call(this, context)
                context.indent = function (levels) {
                  this.indentLevel =
                    (this.indentLevel || 0) +
                    (typeof levels === 'undefined' ? 1 : levels)
                  this.indentPad = new Array(this.indentLevel + 1).join(
                    '&nbsp;&nbsp;'
                  )
                }
                context.row = function (json, htmlNote) {
                  context.out(
                    '<tr><td style="white-space: nowrap;">' +
                      '<pre class="jsondiffpatch-annotated-indent"' +
                      ' style="display: inline-block">'
                  )
                  context.out(context.indentPad)
                  context.out('</pre><pre style="display: inline-block">')
                  context.out(json)
                  context.out(
                    '</pre></td><td class="jsondiffpatch-delta-note"><div>'
                  )
                  context.out(htmlNote)
                  context.out('</div></td></tr>')
                }
              }
            },
            {
              key: 'typeFormattterErrorFormatter',
              value: function typeFormattterErrorFormatter(context, err) {
                context.row(
                  '',
                  '<pre class="jsondiffpatch-error">' + err + '</pre>'
                )
              }
            },
            {
              key: 'formatTextDiffString',
              value: function formatTextDiffString(context, value) {
                var lines = this.parseTextDiff(value)
                context.out('<ul class="jsondiffpatch-textdiff">')
                for (var i = 0, l = lines.length; i < l; i++) {
                  var line = lines[i]
                  context.out(
                    '<li><div class="jsondiffpatch-textdiff-location">' +
                      ('<span class="jsondiffpatch-textdiff-line-number">' +
                        line.location.line +
                        '</span><span class="jsondiffpatch-textdiff-char">' +
                        line.location.chr +
                        '</span></div><div class="jsondiffpatch-textdiff-line">')
                  )
                  var pieces = line.pieces
                  for (
                    var pieceIndex = 0, piecesLength = pieces.length;
                    pieceIndex < piecesLength;
                    pieceIndex++
                  ) {
                    var piece = pieces[pieceIndex]
                    context.out(
                      '<span class="jsondiffpatch-textdiff-' +
                        piece.type +
                        '">' +
                        piece.text +
                        '</span>'
                    )
                  }
                  context.out('</div></li>')
                }
                context.out('</ul>')
              }
            },
            {
              key: 'rootBegin',
              value: function rootBegin(context, type, nodeType) {
                context.out('<table class="jsondiffpatch-annotated-delta">')
                if (type === 'node') {
                  context.row('{')
                  context.indent()
                }
                if (nodeType === 'array') {
                  context.row(
                    '"_t": "a",',
                    'Array delta (member names indicate array indices)'
                  )
                }
              }
            },
            {
              key: 'rootEnd',
              value: function rootEnd(context, type) {
                if (type === 'node') {
                  context.indent(-1)
                  context.row('}')
                }
                context.out('</table>')
              }
            },
            {
              key: 'nodeBegin',
              value: function nodeBegin(context, key, leftKey, type, nodeType) {
                context.row('&quot;' + key + '&quot;: {')
                if (type === 'node') {
                  context.indent()
                }
                if (nodeType === 'array') {
                  context.row(
                    '"_t": "a",',
                    'Array delta (member names indicate array indices)'
                  )
                }
              }
            },
            {
              key: 'nodeEnd',
              value: function nodeEnd(
                context,
                key,
                leftKey,
                type,
                nodeType,
                isLast
              ) {
                if (type === 'node') {
                  context.indent(-1)
                }
                context.row('}' + (isLast ? '' : ','))
              }

              /* jshint camelcase: false */

              /* eslint-disable camelcase */
            },
            {
              key: 'format_unchanged',
              value: function format_unchanged() {}
            },
            {
              key: 'format_movedestination',
              value: function format_movedestination() {}
            },
            {
              key: 'format_node',
              value: function format_node(context, delta, left) {
                // recurse
                this.formatDeltaChildren(context, delta, left)
              }
            }
          ])
          return AnnotatedFormatter
        })(BaseFormatter)

        /* eslint-enable camelcase */

        var wrapPropertyName = function wrapPropertyName(name) {
          return (
            '<pre style="display:inline-block">&quot;' + name + '&quot;</pre>'
          )
        }

        var deltaAnnotations = {
          added: function added(delta, left, key, leftKey) {
            var formatLegend = ' <pre>([newValue])</pre>'
            if (typeof leftKey === 'undefined') {
              return 'new value' + formatLegend
            }
            if (typeof leftKey === 'number') {
              return 'insert at index ' + leftKey + formatLegend
            }
            return 'add property ' + wrapPropertyName(leftKey) + formatLegend
          },
          modified: function modified(delta, left, key, leftKey) {
            var formatLegend = ' <pre>([previousValue, newValue])</pre>'
            if (typeof leftKey === 'undefined') {
              return 'modify value' + formatLegend
            }
            if (typeof leftKey === 'number') {
              return 'modify at index ' + leftKey + formatLegend
            }
            return 'modify property ' + wrapPropertyName(leftKey) + formatLegend
          },
          deleted: function deleted(delta, left, key, leftKey) {
            var formatLegend = ' <pre>([previousValue, 0, 0])</pre>'
            if (typeof leftKey === 'undefined') {
              return 'delete value' + formatLegend
            }
            if (typeof leftKey === 'number') {
              return 'remove index ' + leftKey + formatLegend
            }
            return 'delete property ' + wrapPropertyName(leftKey) + formatLegend
          },
          moved: function moved(delta, left, key, leftKey) {
            return (
              'move from <span title="(position to remove at original state)">' +
              ('index ' +
                leftKey +
                '</span> to <span title="(position to insert at final') +
              (' state)">index ' + delta[1] + '</span>')
            )
          },
          textdiff: function textdiff(delta, left, key, leftKey) {
            var location =
              typeof leftKey === 'undefined'
                ? ''
                : typeof leftKey === 'number'
                ? ' at index ' + leftKey
                : ' at property ' + wrapPropertyName(leftKey)
            return (
              'text diff' +
              location +
              ', format is <a href="https://code.google.com/' +
              'p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>'
            )
          }
        }

        var formatAnyChange = function formatAnyChange(context, delta) {
          var deltaType = this.getDeltaType(delta)
          var annotator = deltaAnnotations[deltaType]
          var htmlNote =
            annotator &&
            annotator.apply(annotator, Array.prototype.slice.call(arguments, 1))
          var json = JSON.stringify(delta, null, 2)
          if (deltaType === 'textdiff') {
            // split text diffs lines
            json = json.split('\\n').join('\\n"+\n   "')
          }
          context.indent()
          context.row(json, htmlNote)
          context.indent(-1)
        }

        /* eslint-disable camelcase */
        AnnotatedFormatter.prototype.format_added = formatAnyChange
        AnnotatedFormatter.prototype.format_modified = formatAnyChange
        AnnotatedFormatter.prototype.format_deleted = formatAnyChange
        AnnotatedFormatter.prototype.format_moved = formatAnyChange
        AnnotatedFormatter.prototype.format_textdiff = formatAnyChange
        var defaultInstance$1 = void 0

        function format$1(delta, left) {
          if (!defaultInstance$1) {
            defaultInstance$1 = new AnnotatedFormatter()
          }
          return defaultInstance$1.format(delta, left)
        }

        var annotated = Object.freeze({
          default: AnnotatedFormatter,
          format: format$1
        })

        var OPERATIONS = {
          add: 'add',
          remove: 'remove',
          replace: 'replace',
          move: 'move'
        }

        var JSONFormatter = (function (_BaseFormatter) {
          inherits(JSONFormatter, _BaseFormatter)

          function JSONFormatter() {
            classCallCheck(this, JSONFormatter)

            var _this = possibleConstructorReturn(
              this,
              (
                JSONFormatter.__proto__ || Object.getPrototypeOf(JSONFormatter)
              ).call(this)
            )

            _this.includeMoveDestinations = true
            return _this
          }

          createClass(JSONFormatter, [
            {
              key: 'prepareContext',
              value: function prepareContext(context) {
                get(
                  JSONFormatter.prototype.__proto__ ||
                    Object.getPrototypeOf(JSONFormatter.prototype),
                  'prepareContext',
                  this
                ).call(this, context)
                context.result = []
                context.path = []
                context.pushCurrentOp = function (obj) {
                  var op = obj.op,
                    value = obj.value

                  var val = {
                    op: op,
                    path: this.currentPath()
                  }
                  if (typeof value !== 'undefined') {
                    val.value = value
                  }
                  this.result.push(val)
                }

                context.pushMoveOp = function (to) {
                  var from = this.currentPath()
                  this.result.push({
                    op: OPERATIONS.move,
                    from: from,
                    path: this.toPath(to)
                  })
                }

                context.currentPath = function () {
                  return '/' + this.path.join('/')
                }

                context.toPath = function (toPath) {
                  var to = this.path.slice()
                  to[to.length - 1] = toPath
                  return '/' + to.join('/')
                }
              }
            },
            {
              key: 'typeFormattterErrorFormatter',
              value: function typeFormattterErrorFormatter(context, err) {
                context.out('[ERROR] ' + err)
              }
            },
            {
              key: 'rootBegin',
              value: function rootBegin() {}
            },
            {
              key: 'rootEnd',
              value: function rootEnd() {}
            },
            {
              key: 'nodeBegin',
              value: function nodeBegin(_ref, key, leftKey) {
                var path = _ref.path

                path.push(leftKey)
              }
            },
            {
              key: 'nodeEnd',
              value: function nodeEnd(_ref2) {
                var path = _ref2.path

                path.pop()
              }

              /* jshint camelcase: false */
              /* eslint-disable camelcase */
            },
            {
              key: 'format_unchanged',
              value: function format_unchanged() {}
            },
            {
              key: 'format_movedestination',
              value: function format_movedestination() {}
            },
            {
              key: 'format_node',
              value: function format_node(context, delta, left) {
                this.formatDeltaChildren(context, delta, left)
              }
            },
            {
              key: 'format_added',
              value: function format_added(context, delta) {
                context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] })
              }
            },
            {
              key: 'format_modified',
              value: function format_modified(context, delta) {
                context.pushCurrentOp({
                  op: OPERATIONS.replace,
                  value: delta[1]
                })
              }
            },
            {
              key: 'format_deleted',
              value: function format_deleted(context) {
                context.pushCurrentOp({ op: OPERATIONS.remove })
              }
            },
            {
              key: 'format_moved',
              value: function format_moved(context, delta) {
                var to = delta[1]
                context.pushMoveOp(to)
              }
            },
            {
              key: 'format_textdiff',
              value: function format_textdiff() {
                throw new Error('Not implemented')
              }
            },
            {
              key: 'format',
              value: function format(delta, left) {
                var context = {}
                this.prepareContext(context)
                this.recurse(context, delta, left)
                return context.result
              }
            }
          ])
          return JSONFormatter
        })(BaseFormatter)

        var last = function last(arr) {
          return arr[arr.length - 1]
        }

        var sortBy = function sortBy(arr, pred) {
          arr.sort(pred)
          return arr
        }

        var compareByIndexDesc = function compareByIndexDesc(indexA, indexB) {
          var lastA = parseInt(indexA, 10)
          var lastB = parseInt(indexB, 10)
          if (!(isNaN(lastA) || isNaN(lastB))) {
            return lastB - lastA
          } else {
            return 0
          }
        }

        var opsByDescendingOrder = function opsByDescendingOrder(removeOps) {
          return sortBy(removeOps, function (a, b) {
            var splitA = a.path.split('/')
            var splitB = b.path.split('/')
            if (splitA.length !== splitB.length) {
              return splitA.length - splitB.length
            } else {
              return compareByIndexDesc(last(splitA), last(splitB))
            }
          })
        }

        var partitionOps = function partitionOps(arr, fns) {
          var initArr = Array(fns.length + 1)
            .fill()
            .map(function () {
              return []
            })
          return arr
            .map(function (item) {
              var position = fns
                .map(function (fn) {
                  return fn(item)
                })
                .indexOf(true)
              if (position < 0) {
                position = fns.length
              }
              return { item: item, position: position }
            })
            .reduce(function (acc, item) {
              acc[item.position].push(item.item)
              return acc
            }, initArr)
        }
        var isMoveOp = function isMoveOp(_ref3) {
          var op = _ref3.op
          return op === 'move'
        }
        var isRemoveOp = function isRemoveOp(_ref4) {
          var op = _ref4.op
          return op === 'remove'
        }

        var reorderOps = function reorderOps(diff) {
          var _partitionOps = partitionOps(diff, [isMoveOp, isRemoveOp]),
            _partitionOps2 = slicedToArray(_partitionOps, 3),
            moveOps = _partitionOps2[0],
            removedOps = _partitionOps2[1],
            restOps = _partitionOps2[2]

          var removeOpsReverse = opsByDescendingOrder(removedOps)
          return [].concat(
            toConsumableArray(removeOpsReverse),
            toConsumableArray(moveOps),
            toConsumableArray(restOps)
          )
        }

        var defaultInstance$2 = void 0

        var format$2 = function format(delta, left) {
          if (!defaultInstance$2) {
            defaultInstance$2 = new JSONFormatter()
          }
          return reorderOps(defaultInstance$2.format(delta, left))
        }

        var log = function log(delta, left) {
          console.log(format$2(delta, left))
        }

        var jsonpatch = Object.freeze({
          default: JSONFormatter,
          partitionOps: partitionOps,
          format: format$2,
          log: log
        })

        function chalkColor(name) {
          return (
            (chalk && chalk[name]) ||
            function () {
              for (
                var _len = arguments.length, args = Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key]
              }

              return args
            }
          )
        }

        var colors = {
          added: chalkColor('green'),
          deleted: chalkColor('red'),
          movedestination: chalkColor('gray'),
          moved: chalkColor('yellow'),
          unchanged: chalkColor('gray'),
          error: chalkColor('white.bgRed'),
          textDiffLine: chalkColor('gray')
        }

        var ConsoleFormatter = (function (_BaseFormatter) {
          inherits(ConsoleFormatter, _BaseFormatter)

          function ConsoleFormatter() {
            classCallCheck(this, ConsoleFormatter)

            var _this = possibleConstructorReturn(
              this,
              (
                ConsoleFormatter.__proto__ ||
                Object.getPrototypeOf(ConsoleFormatter)
              ).call(this)
            )

            _this.includeMoveDestinations = false
            return _this
          }

          createClass(ConsoleFormatter, [
            {
              key: 'prepareContext',
              value: function prepareContext(context) {
                get(
                  ConsoleFormatter.prototype.__proto__ ||
                    Object.getPrototypeOf(ConsoleFormatter.prototype),
                  'prepareContext',
                  this
                ).call(this, context)
                context.indent = function (levels) {
                  this.indentLevel =
                    (this.indentLevel || 0) +
                    (typeof levels === 'undefined' ? 1 : levels)
                  this.indentPad = new Array(this.indentLevel + 1).join('  ')
                  this.outLine()
                }
                context.outLine = function () {
                  this.buffer.push('\n' + (this.indentPad || ''))
                }
                context.out = function () {
                  for (
                    var _len2 = arguments.length,
                      args = Array(_len2),
                      _key2 = 0;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2] = arguments[_key2]
                  }

                  for (var i = 0, l = args.length; i < l; i++) {
                    var lines = args[i].split('\n')
                    var text = lines.join('\n' + (this.indentPad || ''))
                    if (this.color && this.color[0]) {
                      text = this.color[0](text)
                    }
                    this.buffer.push(text)
                  }
                }
                context.pushColor = function (color) {
                  this.color = this.color || []
                  this.color.unshift(color)
                }
                context.popColor = function () {
                  this.color = this.color || []
                  this.color.shift()
                }
              }
            },
            {
              key: 'typeFormattterErrorFormatter',
              value: function typeFormattterErrorFormatter(context, err) {
                context.pushColor(colors.error)
                context.out('[ERROR]' + err)
                context.popColor()
              }
            },
            {
              key: 'formatValue',
              value: function formatValue(context, value) {
                context.out(JSON.stringify(value, null, 2))
              }
            },
            {
              key: 'formatTextDiffString',
              value: function formatTextDiffString(context, value) {
                var lines = this.parseTextDiff(value)
                context.indent()
                for (var i = 0, l = lines.length; i < l; i++) {
                  var line = lines[i]
                  context.pushColor(colors.textDiffLine)
                  context.out(
                    line.location.line + ',' + line.location.chr + ' '
                  )
                  context.popColor()
                  var pieces = line.pieces
                  for (
                    var pieceIndex = 0, piecesLength = pieces.length;
                    pieceIndex < piecesLength;
                    pieceIndex++
                  ) {
                    var piece = pieces[pieceIndex]
                    context.pushColor(colors[piece.type])
                    context.out(piece.text)
                    context.popColor()
                  }
                  if (i < l - 1) {
                    context.outLine()
                  }
                }
                context.indent(-1)
              }
            },
            {
              key: 'rootBegin',
              value: function rootBegin(context, type, nodeType) {
                context.pushColor(colors[type])
                if (type === 'node') {
                  context.out(nodeType === 'array' ? '[' : '{')
                  context.indent()
                }
              }
            },
            {
              key: 'rootEnd',
              value: function rootEnd(context, type, nodeType) {
                if (type === 'node') {
                  context.indent(-1)
                  context.out(nodeType === 'array' ? ']' : '}')
                }
                context.popColor()
              }
            },
            {
              key: 'nodeBegin',
              value: function nodeBegin(context, key, leftKey, type, nodeType) {
                context.pushColor(colors[type])
                context.out(leftKey + ': ')
                if (type === 'node') {
                  context.out(nodeType === 'array' ? '[' : '{')
                  context.indent()
                }
              }
            },
            {
              key: 'nodeEnd',
              value: function nodeEnd(
                context,
                key,
                leftKey,
                type,
                nodeType,
                isLast
              ) {
                if (type === 'node') {
                  context.indent(-1)
                  context.out(
                    nodeType === 'array' ? ']' : '}' + (isLast ? '' : ',')
                  )
                }
                if (!isLast) {
                  context.outLine()
                }
                context.popColor()
              }

              /* jshint camelcase: false */
              /* eslint-disable camelcase */
            },
            {
              key: 'format_unchanged',
              value: function format_unchanged(context, delta, left) {
                if (typeof left === 'undefined') {
                  return
                }
                this.formatValue(context, left)
              }
            },
            {
              key: 'format_movedestination',
              value: function format_movedestination(context, delta, left) {
                if (typeof left === 'undefined') {
                  return
                }
                this.formatValue(context, left)
              }
            },
            {
              key: 'format_node',
              value: function format_node(context, delta, left) {
                // recurse
                this.formatDeltaChildren(context, delta, left)
              }
            },
            {
              key: 'format_added',
              value: function format_added(context, delta) {
                this.formatValue(context, delta[0])
              }
            },
            {
              key: 'format_modified',
              value: function format_modified(context, delta) {
                context.pushColor(colors.deleted)
                this.formatValue(context, delta[0])
                context.popColor()
                context.out(' => ')
                context.pushColor(colors.added)
                this.formatValue(context, delta[1])
                context.popColor()
              }
            },
            {
              key: 'format_deleted',
              value: function format_deleted(context, delta) {
                this.formatValue(context, delta[0])
              }
            },
            {
              key: 'format_moved',
              value: function format_moved(context, delta) {
                context.out('==> ' + delta[1])
              }
            },
            {
              key: 'format_textdiff',
              value: function format_textdiff(context, delta) {
                this.formatTextDiffString(context, delta[0])
              }
            }
          ])
          return ConsoleFormatter
        })(BaseFormatter)

        var defaultInstance$3 = void 0

        var format$3 = function format(delta, left) {
          if (!defaultInstance$3) {
            defaultInstance$3 = new ConsoleFormatter()
          }
          return defaultInstance$3.format(delta, left)
        }

        function log$1(delta, left) {
          console.log(format$3(delta, left))
        }

        var console$1 = Object.freeze({
          default: ConsoleFormatter,
          format: format$3,
          log: log$1
        })

        var index = Object.freeze({
          base: base,
          html: html,
          annotated: annotated,
          jsonpatch: jsonpatch,
          console: console$1
        })

        // use as 2nd parameter for JSON.parse to revive Date instances
        function dateReviver(key, value) {
          var parts = void 0
          if (typeof value === 'string') {
            // eslint-disable-next-line max-len
            parts =
              /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(
                value
              )
            if (parts) {
              return new Date(
                Date.UTC(
                  +parts[1],
                  +parts[2] - 1,
                  +parts[3],
                  +parts[4],
                  +parts[5],
                  +parts[6],
                  +(parts[7] || 0)
                )
              )
            }
          }
          return value
        }

        function create(options) {
          return new DiffPatcher(options)
        }

        var defaultInstance$4 = void 0

        function diff() {
          if (!defaultInstance$4) {
            defaultInstance$4 = new DiffPatcher()
          }
          return defaultInstance$4.diff.apply(defaultInstance$4, arguments)
        }

        function patch() {
          if (!defaultInstance$4) {
            defaultInstance$4 = new DiffPatcher()
          }
          return defaultInstance$4.patch.apply(defaultInstance$4, arguments)
        }

        function unpatch() {
          if (!defaultInstance$4) {
            defaultInstance$4 = new DiffPatcher()
          }
          return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments)
        }

        function reverse() {
          if (!defaultInstance$4) {
            defaultInstance$4 = new DiffPatcher()
          }
          return defaultInstance$4.reverse.apply(defaultInstance$4, arguments)
        }

        function clone$1() {
          if (!defaultInstance$4) {
            defaultInstance$4 = new DiffPatcher()
          }
          return defaultInstance$4.clone.apply(defaultInstance$4, arguments)
        }

        exports.DiffPatcher = DiffPatcher
        exports.formatters = index
        exports.console = console$1
        exports.create = create
        exports.dateReviver = dateReviver
        exports.diff = diff
        exports.patch = patch
        exports.unpatch = unpatch
        exports.reverse = reverse
        exports.clone = clone$1

        Object.defineProperty(exports, '__esModule', { value: true })
      })

      /***/
    },

    /***/ 8686: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      /**
       * lodash (Custom Build) <https://lodash.com/>
       * Build: `lodash modularize exports="npm" -o ./`
       * Copyright jQuery Foundation and other contributors <https://jquery.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0

      /** `Object#toString` result references. */
      var symbolTag = '[object Symbol]'

      /** Used to match HTML entities and HTML characters. */
      var reUnescapedHtml = /[&<>"'`]/g,
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source)

      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      }

      /** Detect free variable `global` from Node.js. */
      var freeGlobal =
        typeof __webpack_require__.g == 'object' &&
        __webpack_require__.g &&
        __webpack_require__.g.Object === Object &&
        __webpack_require__.g

      /** Detect free variable `self`. */
      var freeSelf =
        typeof self == 'object' && self && self.Object === Object && self

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')()

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined : object[key]
        }
      }

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      var escapeHtmlChar = basePropertyOf(htmlEscapes)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
       * of values.
       */
      var objectToString = objectProto.toString

      /** Built-in value references. */
      var Symbol = root.Symbol

      /** Used to convert symbols to primitives and strings. */
      var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined

      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
          return value
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : ''
        }
        var result = value + ''
        return result == '0' && 1 / value == -INFINITY ? '-0' : result
      }

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return !!value && typeof value == 'object'
      }

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return (
          typeof value == 'symbol' ||
          (isObjectLike(value) && objectToString.call(value) == symbolTag)
        )
      }

      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */
      function toString(value) {
        return value == null ? '' : baseToString(value)
      }

      /**
       * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
       * their corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * Backticks are escaped because in IE < 9, they can break out of
       * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
       * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
       * [#133](https://html5sec.org/#133) of the
       * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */
      function escape(string) {
        string = toString(string)
        return string && reHasUnescapedHtml.test(string)
          ? string.replace(reUnescapedHtml, escapeHtmlChar)
          : string
      }

      module.exports = escape

      /***/
    },

    /***/ 6486: /***/ function (module, exports, __webpack_require__) {
      /* module decorator */ module = __webpack_require__.nmd(module)
      var __WEBPACK_AMD_DEFINE_RESULT__
      /**
       * @license
       * Lodash <https://lodash.com/>
       * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */
      ;(function () {
        /** Used as a safe reference for `undefined` in pre-ES5 environments. */
        var undefined

        /** Used as the semantic version number. */
        var VERSION = '4.17.21'

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200

        /** Error message constants. */
        var CORE_ERROR_TEXT =
            'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
          FUNC_ERROR_TEXT = 'Expected a function',
          INVALID_TEMPL_VAR_ERROR_TEXT =
            'Invalid `variable` option passed into `_.template`'

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED = '__lodash_hash_undefined__'

        /** Used as the maximum memoize cache size. */
        var MAX_MEMOIZE_SIZE = 500

        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__'

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2

        /** Used to compose bitmasks for function metadata. */
        var WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512

        /** Used as default options for `_.truncate`. */
        var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...'

        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT = 800,
          HOT_SPAN = 16

        /** Used to indicate the type of lazy iteratees. */
        var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3

        /** Used as references for various `Number` constants. */
        var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e308,
          NAN = 0 / 0

        /** Used as references for the maximum length and index of an array. */
        var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1

        /** Used to associate wrap methods with their bit flags. */
        var wrapFlags = [
          ['ary', WRAP_ARY_FLAG],
          ['bind', WRAP_BIND_FLAG],
          ['bindKey', WRAP_BIND_KEY_FLAG],
          ['curry', WRAP_CURRY_FLAG],
          ['curryRight', WRAP_CURRY_RIGHT_FLAG],
          ['flip', WRAP_FLIP_FLAG],
          ['partial', WRAP_PARTIAL_FLAG],
          ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
          ['rearg', WRAP_REARG_FLAG]
        ]

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          asyncTag = '[object AsyncFunction]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          domExcTag = '[object DOMException]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          nullTag = '[object Null]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          proxyTag = '[object Proxy]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          undefinedTag = '[object Undefined]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]'

        var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]'

        /** Used to match empty string literals in compiled template source. */
        var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g

        /** Used to match HTML entities and HTML characters. */
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source)

        /** Used to match template delimiters. */
        var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName =
            /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g

        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source)

        /** Used to match leading whitespace. */
        var reTrimStart = /^\s+/

        /** Used to match a single whitespace character. */
        var reWhitespace = /\s/

        /** Used to match wrap detail comments. */
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /

        /** Used to match words composed of alphanumeric characters. */
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g

        /**
         * Used to validate the `validate` option in `_.template` variable.
         *
         * Forbids characters which could potentially change the meaning of the function argument definition:
         * - "()," (modification of function parameters)
         * - "=" (default value)
         * - "[]{}" (destructuring of function parameters)
         * - "/" (beginning of a comment)
         * - whitespace
         */
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g

        /**
         * Used to match
         * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
         */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g

        /** Used to match `RegExp` flags from their coerced string values. */
        var reFlags = /\w*$/

        /** Used to detect bad signed hexadecimal string values. */
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i

        /** Used to detect binary string values. */
        var reIsBinary = /^0b[01]+$/i

        /** Used to detect host constructors (Safari). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/

        /** Used to detect octal string values. */
        var reIsOctal = /^0o[0-7]+$/i

        /** Used to detect unsigned integer values. */
        var reIsUint = /^(?:0|[1-9]\d*)$/

        /** Used to match Latin Unicode letters (excluding mathematical operators). */
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g

        /** Used to ensure capturing order of template delimiters. */
        var reNoMatch = /($^)/

        /** Used to match unescaped characters in compiled string literals. */
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g

        /** Used to compose unicode character classes. */
        var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f',
          reComboHalfMarksRange = '\\ufe20-\\ufe2f',
          rsComboSymbolsRange = '\\u20d0-\\u20ff',
          rsComboRange =
            rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = '\\u2000-\\u206f',
          rsSpaceRange =
            ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange =
            rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange

        /** Used to compose unicode capture groups. */
        var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc =
            '[^' +
            rsAstralRange +
            rsBreakRange +
            rsDigits +
            rsDingbatRange +
            rsLowerRange +
            rsUpperRange +
            ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d'

        /** Used to compose unicode regexes. */
        var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
          rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin =
            '(?:' +
            rsZWJ +
            '(?:' +
            [rsNonAstral, rsRegional, rsSurrPair].join('|') +
            ')' +
            rsOptVar +
            reOptMod +
            ')*',
          rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji =
            '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol =
            '(?:' +
            [
              rsNonAstral + rsCombo + '?',
              rsCombo,
              rsRegional,
              rsSurrPair,
              rsAstral
            ].join('|') +
            ')'

        /** Used to match apostrophes. */
        var reApos = RegExp(rsApos, 'g')

        /**
         * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
         * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
         */
        var reComboMark = RegExp(rsCombo, 'g')

        /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
        var reUnicode = RegExp(
          rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq,
          'g'
        )

        /** Used to match complex or compound words. */
        var reUnicodeWord = RegExp(
          [
            rsUpper +
              '?' +
              rsLower +
              '+' +
              rsOptContrLower +
              '(?=' +
              [rsBreak, rsUpper, '$'].join('|') +
              ')',
            rsMiscUpper +
              '+' +
              rsOptContrUpper +
              '(?=' +
              [rsBreak, rsUpper + rsMiscLower, '$'].join('|') +
              ')',
            rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
            rsUpper + '+' + rsOptContrUpper,
            rsOrdUpper,
            rsOrdLower,
            rsDigits,
            rsEmoji
          ].join('|'),
          'g'
        )

        /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
        var reHasUnicode = RegExp(
          '[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']'
        )

        /** Used to detect strings that need a more robust regexp to match words. */
        var reHasUnicodeWord =
          /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/

        /** Used to assign default `context` object properties. */
        var contextProps = [
          'Array',
          'Buffer',
          'DataView',
          'Date',
          'Error',
          'Float32Array',
          'Float64Array',
          'Function',
          'Int8Array',
          'Int16Array',
          'Int32Array',
          'Map',
          'Math',
          'Object',
          'Promise',
          'RegExp',
          'Set',
          'String',
          'Symbol',
          'TypeError',
          'Uint8Array',
          'Uint8ClampedArray',
          'Uint16Array',
          'Uint32Array',
          'WeakMap',
          '_',
          'clearTimeout',
          'isFinite',
          'parseInt',
          'setTimeout'
        ]

        /** Used to make template sourceURLs easier to identify. */
        var templateCounter = -1

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {}
        typedArrayTags[float32Tag] =
          typedArrayTags[float64Tag] =
          typedArrayTags[int8Tag] =
          typedArrayTags[int16Tag] =
          typedArrayTags[int32Tag] =
          typedArrayTags[uint8Tag] =
          typedArrayTags[uint8ClampedTag] =
          typedArrayTags[uint16Tag] =
          typedArrayTags[uint32Tag] =
            true
        typedArrayTags[argsTag] =
          typedArrayTags[arrayTag] =
          typedArrayTags[arrayBufferTag] =
          typedArrayTags[boolTag] =
          typedArrayTags[dataViewTag] =
          typedArrayTags[dateTag] =
          typedArrayTags[errorTag] =
          typedArrayTags[funcTag] =
          typedArrayTags[mapTag] =
          typedArrayTags[numberTag] =
          typedArrayTags[objectTag] =
          typedArrayTags[regexpTag] =
          typedArrayTags[setTag] =
          typedArrayTags[stringTag] =
          typedArrayTags[weakMapTag] =
            false

        /** Used to identify `toStringTag` values supported by `_.clone`. */
        var cloneableTags = {}
        cloneableTags[argsTag] =
          cloneableTags[arrayTag] =
          cloneableTags[arrayBufferTag] =
          cloneableTags[dataViewTag] =
          cloneableTags[boolTag] =
          cloneableTags[dateTag] =
          cloneableTags[float32Tag] =
          cloneableTags[float64Tag] =
          cloneableTags[int8Tag] =
          cloneableTags[int16Tag] =
          cloneableTags[int32Tag] =
          cloneableTags[mapTag] =
          cloneableTags[numberTag] =
          cloneableTags[objectTag] =
          cloneableTags[regexpTag] =
          cloneableTags[setTag] =
          cloneableTags[stringTag] =
          cloneableTags[symbolTag] =
          cloneableTags[uint8Tag] =
          cloneableTags[uint8ClampedTag] =
          cloneableTags[uint16Tag] =
          cloneableTags[uint32Tag] =
            true
        cloneableTags[errorTag] =
          cloneableTags[funcTag] =
          cloneableTags[weakMapTag] =
            false

        /** Used to map Latin Unicode letters to basic Latin letters. */
        var deburredLetters = {
          // Latin-1 Supplement block.
          '\xc0': 'A',
          '\xc1': 'A',
          '\xc2': 'A',
          '\xc3': 'A',
          '\xc4': 'A',
          '\xc5': 'A',
          '\xe0': 'a',
          '\xe1': 'a',
          '\xe2': 'a',
          '\xe3': 'a',
          '\xe4': 'a',
          '\xe5': 'a',
          '\xc7': 'C',
          '\xe7': 'c',
          '\xd0': 'D',
          '\xf0': 'd',
          '\xc8': 'E',
          '\xc9': 'E',
          '\xca': 'E',
          '\xcb': 'E',
          '\xe8': 'e',
          '\xe9': 'e',
          '\xea': 'e',
          '\xeb': 'e',
          '\xcc': 'I',
          '\xcd': 'I',
          '\xce': 'I',
          '\xcf': 'I',
          '\xec': 'i',
          '\xed': 'i',
          '\xee': 'i',
          '\xef': 'i',
          '\xd1': 'N',
          '\xf1': 'n',
          '\xd2': 'O',
          '\xd3': 'O',
          '\xd4': 'O',
          '\xd5': 'O',
          '\xd6': 'O',
          '\xd8': 'O',
          '\xf2': 'o',
          '\xf3': 'o',
          '\xf4': 'o',
          '\xf5': 'o',
          '\xf6': 'o',
          '\xf8': 'o',
          '\xd9': 'U',
          '\xda': 'U',
          '\xdb': 'U',
          '\xdc': 'U',
          '\xf9': 'u',
          '\xfa': 'u',
          '\xfb': 'u',
          '\xfc': 'u',
          '\xdd': 'Y',
          '\xfd': 'y',
          '\xff': 'y',
          '\xc6': 'Ae',
          '\xe6': 'ae',
          '\xde': 'Th',
          '\xfe': 'th',
          '\xdf': 'ss',
          // Latin Extended-A block.
          '\u0100': 'A',
          '\u0102': 'A',
          '\u0104': 'A',
          '\u0101': 'a',
          '\u0103': 'a',
          '\u0105': 'a',
          '\u0106': 'C',
          '\u0108': 'C',
          '\u010a': 'C',
          '\u010c': 'C',
          '\u0107': 'c',
          '\u0109': 'c',
          '\u010b': 'c',
          '\u010d': 'c',
          '\u010e': 'D',
          '\u0110': 'D',
          '\u010f': 'd',
          '\u0111': 'd',
          '\u0112': 'E',
          '\u0114': 'E',
          '\u0116': 'E',
          '\u0118': 'E',
          '\u011a': 'E',
          '\u0113': 'e',
          '\u0115': 'e',
          '\u0117': 'e',
          '\u0119': 'e',
          '\u011b': 'e',
          '\u011c': 'G',
          '\u011e': 'G',
          '\u0120': 'G',
          '\u0122': 'G',
          '\u011d': 'g',
          '\u011f': 'g',
          '\u0121': 'g',
          '\u0123': 'g',
          '\u0124': 'H',
          '\u0126': 'H',
          '\u0125': 'h',
          '\u0127': 'h',
          '\u0128': 'I',
          '\u012a': 'I',
          '\u012c': 'I',
          '\u012e': 'I',
          '\u0130': 'I',
          '\u0129': 'i',
          '\u012b': 'i',
          '\u012d': 'i',
          '\u012f': 'i',
          '\u0131': 'i',
          '\u0134': 'J',
          '\u0135': 'j',
          '\u0136': 'K',
          '\u0137': 'k',
          '\u0138': 'k',
          '\u0139': 'L',
          '\u013b': 'L',
          '\u013d': 'L',
          '\u013f': 'L',
          '\u0141': 'L',
          '\u013a': 'l',
          '\u013c': 'l',
          '\u013e': 'l',
          '\u0140': 'l',
          '\u0142': 'l',
          '\u0143': 'N',
          '\u0145': 'N',
          '\u0147': 'N',
          '\u014a': 'N',
          '\u0144': 'n',
          '\u0146': 'n',
          '\u0148': 'n',
          '\u014b': 'n',
          '\u014c': 'O',
          '\u014e': 'O',
          '\u0150': 'O',
          '\u014d': 'o',
          '\u014f': 'o',
          '\u0151': 'o',
          '\u0154': 'R',
          '\u0156': 'R',
          '\u0158': 'R',
          '\u0155': 'r',
          '\u0157': 'r',
          '\u0159': 'r',
          '\u015a': 'S',
          '\u015c': 'S',
          '\u015e': 'S',
          '\u0160': 'S',
          '\u015b': 's',
          '\u015d': 's',
          '\u015f': 's',
          '\u0161': 's',
          '\u0162': 'T',
          '\u0164': 'T',
          '\u0166': 'T',
          '\u0163': 't',
          '\u0165': 't',
          '\u0167': 't',
          '\u0168': 'U',
          '\u016a': 'U',
          '\u016c': 'U',
          '\u016e': 'U',
          '\u0170': 'U',
          '\u0172': 'U',
          '\u0169': 'u',
          '\u016b': 'u',
          '\u016d': 'u',
          '\u016f': 'u',
          '\u0171': 'u',
          '\u0173': 'u',
          '\u0174': 'W',
          '\u0175': 'w',
          '\u0176': 'Y',
          '\u0177': 'y',
          '\u0178': 'Y',
          '\u0179': 'Z',
          '\u017b': 'Z',
          '\u017d': 'Z',
          '\u017a': 'z',
          '\u017c': 'z',
          '\u017e': 'z',
          '\u0132': 'IJ',
          '\u0133': 'ij',
          '\u0152': 'Oe',
          '\u0153': 'oe',
          '\u0149': "'n",
          '\u017f': 's'
        }

        /** Used to map characters to HTML entities. */
        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        }

        /** Used to map HTML entities to characters. */
        var htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'"
        }

        /** Used to escape characters for inclusion in compiled string literals. */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        }

        /** Built-in method references without a dependency on `root`. */
        var freeParseFloat = parseFloat,
          freeParseInt = parseInt

        /** Detect free variable `global` from Node.js. */
        var freeGlobal =
          typeof __webpack_require__.g == 'object' &&
          __webpack_require__.g &&
          __webpack_require__.g.Object === Object &&
          __webpack_require__.g

        /** Detect free variable `self`. */
        var freeSelf =
          typeof self == 'object' && self && self.Object === Object && self

        /** Used as a reference to the global object. */
        var root = freeGlobal || freeSelf || Function('return this')()

        /** Detect free variable `exports`. */
        var freeExports = true && exports && !exports.nodeType && exports

        /** Detect free variable `module`. */
        var freeModule =
          freeExports &&
          'object' == 'object' &&
          module &&
          !module.nodeType &&
          module

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports

        /** Detect free variable `process` from Node.js. */
        var freeProcess = moduleExports && freeGlobal.process

        /** Used to access faster Node.js helpers. */
        var nodeUtil = (function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types =
              freeModule &&
              freeModule.require &&
              freeModule.require('util').types

            if (types) {
              return types
            }

            // Legacy `process.binding('util')` for Node.js < 10.
            return (
              freeProcess && freeProcess.binding && freeProcess.binding('util')
            )
          } catch (e) {}
        })()

        /* Node.js helper references. */
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray

        /*--------------------------------------------------------------------------*/

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg)
            case 1:
              return func.call(thisArg, args[0])
            case 2:
              return func.call(thisArg, args[0], args[1])
            case 3:
              return func.call(thisArg, args[0], args[1], args[2])
          }
          return func.apply(thisArg, args)
        }

        /**
         * A specialized version of `baseAggregator` for arrays.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1,
            length = array == null ? 0 : array.length

          while (++index < length) {
            var value = array[index]
            setter(accumulator, value, iteratee(value), array)
          }
          return accumulator
        }

        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length

          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break
            }
          }
          return array
        }

        /**
         * A specialized version of `_.forEachRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length

          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break
            }
          }
          return array
        }

        /**
         * A specialized version of `_.every` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */
        function arrayEvery(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length

          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false
            }
          }
          return true
        }

        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = []

          while (++index < length) {
            var value = array[index]
            if (predicate(value, index, array)) {
              result[resIndex++] = value
            }
          }
          return result
        }

        /**
         * A specialized version of `_.includes` for arrays without support for
         * specifying an index to search from.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length
          return !!length && baseIndexOf(array, value, 0) > -1
        }

        /**
         * This function is like `arrayIncludes` except that it accepts a comparator.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */
        function arrayIncludesWith(array, value, comparator) {
          var index = -1,
            length = array == null ? 0 : array.length

          while (++index < length) {
            if (comparator(value, array[index])) {
              return true
            }
          }
          return false
        }

        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length)

          while (++index < length) {
            result[index] = iteratee(array[index], index, array)
          }
          return result
        }

        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length

          while (++index < length) {
            array[offset + index] = values[index]
          }
          return array
        }

        /**
         * A specialized version of `_.reduce` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the first element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1,
            length = array == null ? 0 : array.length

          if (initAccum && length) {
            accumulator = array[++index]
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array)
          }
          return accumulator
        }

        /**
         * A specialized version of `_.reduceRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the last element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length
          if (initAccum && length) {
            accumulator = array[--length]
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array)
          }
          return accumulator
        }

        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length

          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true
            }
          }
          return false
        }

        /**
         * Gets the size of an ASCII `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */
        var asciiSize = baseProperty('length')

        /**
         * Converts an ASCII `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */
        function asciiToArray(string) {
          return string.split('')
        }

        /**
         * Splits an ASCII `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */
        function asciiWords(string) {
          return string.match(reAsciiWord) || []
        }

        /**
         * The base implementation of methods like `_.findKey` and `_.findLastKey`,
         * without support for iteratee shorthands, which iterates over `collection`
         * using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */
        function baseFindKey(collection, predicate, eachFunc) {
          var result
          eachFunc(collection, function (value, key, collection) {
            if (predicate(value, key, collection)) {
              result = key
              return false
            }
          })
          return result
        }

        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1)

          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index
            }
          }
          return -1
        }

        /**
         * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          return value === value
            ? strictIndexOf(array, value, fromIndex)
            : baseFindIndex(array, baseIsNaN, fromIndex)
        }

        /**
         * This function is like `baseIndexOf` except that it accepts a comparator.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1,
            length = array.length

          while (++index < length) {
            if (comparator(array[index], value)) {
              return index
            }
          }
          return -1
        }

        /**
         * The base implementation of `_.isNaN` without support for number objects.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         */
        function baseIsNaN(value) {
          return value !== value
        }

        /**
         * The base implementation of `_.mean` and `_.meanBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the mean.
         */
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length
          return length ? baseSum(array, iteratee) / length : NAN
        }

        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function baseProperty(key) {
          return function (object) {
            return object == null ? undefined : object[key]
          }
        }

        /**
         * The base implementation of `_.propertyOf` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyOf(object) {
          return function (key) {
            return object == null ? undefined : object[key]
          }
        }

        /**
         * The base implementation of `_.reduce` and `_.reduceRight`, without support
         * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initAccum Specify using the first or last element of
         *  `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */
        function baseReduce(
          collection,
          iteratee,
          accumulator,
          initAccum,
          eachFunc
        ) {
          eachFunc(collection, function (value, index, collection) {
            accumulator = initAccum
              ? ((initAccum = false), value)
              : iteratee(accumulator, value, index, collection)
          })
          return accumulator
        }

        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define the
         * sort order of `array` and replaces criteria objects with their corresponding
         * values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
          var length = array.length

          array.sort(comparer)
          while (length--) {
            array[length] = array[length].value
          }
          return array
        }

        /**
         * The base implementation of `_.sum` and `_.sumBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */
        function baseSum(array, iteratee) {
          var result,
            index = -1,
            length = array.length

          while (++index < length) {
            var current = iteratee(array[index])
            if (current !== undefined) {
              result = result === undefined ? current : result + current
            }
          }
          return result
        }

        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
          var index = -1,
            result = Array(n)

          while (++index < n) {
            result[index] = iteratee(index)
          }
          return result
        }

        /**
         * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
         * of key-value pairs for `object` corresponding to the property names of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the key-value pairs.
         */
        function baseToPairs(object, props) {
          return arrayMap(props, function (key) {
            return [key, object[key]]
          })
        }

        /**
         * The base implementation of `_.trim`.
         *
         * @private
         * @param {string} string The string to trim.
         * @returns {string} Returns the trimmed string.
         */
        function baseTrim(string) {
          return string
            ? string
                .slice(0, trimmedEndIndex(string) + 1)
                .replace(reTrimStart, '')
            : string
        }

        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
          return function (value) {
            return func(value)
          }
        }

        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
          return arrayMap(props, function (key) {
            return object[key]
          })
        }

        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function cacheHas(cache, key) {
          return cache.has(key)
        }

        /**
         * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the first unmatched string symbol.
         */
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1,
            length = strSymbols.length

          while (
            ++index < length &&
            baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
          ) {}
          return index
        }

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the last unmatched string symbol.
         */
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length

          while (
            index-- &&
            baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
          ) {}
          return index
        }

        /**
         * Gets the number of `placeholder` occurrences in `array`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} placeholder The placeholder to search for.
         * @returns {number} Returns the placeholder count.
         */
        function countHolders(array, placeholder) {
          var length = array.length,
            result = 0

          while (length--) {
            if (array[length] === placeholder) {
              ++result
            }
          }
          return result
        }

        /**
         * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
         * letters to basic Latin letters.
         *
         * @private
         * @param {string} letter The matched letter to deburr.
         * @returns {string} Returns the deburred letter.
         */
        var deburrLetter = basePropertyOf(deburredLetters)

        /**
         * Used by `_.escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        var escapeHtmlChar = basePropertyOf(htmlEscapes)

        /**
         * Used by `_.template` to escape characters for inclusion in compiled string literals.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(chr) {
          return '\\' + stringEscapes[chr]
        }

        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
          return object == null ? undefined : object[key]
        }

        /**
         * Checks if `string` contains Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a symbol is found, else `false`.
         */
        function hasUnicode(string) {
          return reHasUnicode.test(string)
        }

        /**
         * Checks if `string` contains a word composed of Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a word is found, else `false`.
         */
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string)
        }

        /**
         * Converts `iterator` to an array.
         *
         * @private
         * @param {Object} iterator The iterator to convert.
         * @returns {Array} Returns the converted array.
         */
        function iteratorToArray(iterator) {
          var data,
            result = []

          while (!(data = iterator.next()).done) {
            result.push(data.value)
          }
          return result
        }

        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */
        function mapToArray(map) {
          var index = -1,
            result = Array(map.size)

          map.forEach(function (value, key) {
            result[++index] = [key, value]
          })
          return result
        }

        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg))
          }
        }

        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */
        function replaceHolders(array, placeholder) {
          var index = -1,
            length = array.length,
            resIndex = 0,
            result = []

          while (++index < length) {
            var value = array[index]
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER
              result[resIndex++] = index
            }
          }
          return result
        }

        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */
        function setToArray(set) {
          var index = -1,
            result = Array(set.size)

          set.forEach(function (value) {
            result[++index] = value
          })
          return result
        }

        /**
         * Converts `set` to its value-value pairs.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the value-value pairs.
         */
        function setToPairs(set) {
          var index = -1,
            result = Array(set.size)

          set.forEach(function (value) {
            result[++index] = [value, value]
          })
          return result
        }

        /**
         * A specialized version of `_.indexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1,
            length = array.length

          while (++index < length) {
            if (array[index] === value) {
              return index
            }
          }
          return -1
        }

        /**
         * A specialized version of `_.lastIndexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1
          while (index--) {
            if (array[index] === value) {
              return index
            }
          }
          return index
        }

        /**
         * Gets the number of symbols in `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the string size.
         */
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string)
        }

        /**
         * Converts `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */
        function stringToArray(string) {
          return hasUnicode(string)
            ? unicodeToArray(string)
            : asciiToArray(string)
        }

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedEndIndex(string) {
          var index = string.length

          while (index-- && reWhitespace.test(string.charAt(index))) {}
          return index
        }

        /**
         * Used by `_.unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} chr The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes)

        /**
         * Gets the size of a Unicode `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */
        function unicodeSize(string) {
          var result = (reUnicode.lastIndex = 0)
          while (reUnicode.test(string)) {
            ++result
          }
          return result
        }

        /**
         * Converts a Unicode `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */
        function unicodeToArray(string) {
          return string.match(reUnicode) || []
        }

        /**
         * Splits a Unicode `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || []
        }

        /*--------------------------------------------------------------------------*/

        /**
         * Create a new pristine `lodash` function using the `context` object.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Util
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns a new `lodash` function.
         * @example
         *
         * _.mixin({ 'foo': _.constant('foo') });
         *
         * var lodash = _.runInContext();
         * lodash.mixin({ 'bar': lodash.constant('bar') });
         *
         * _.isFunction(_.foo);
         * // => true
         * _.isFunction(_.bar);
         * // => false
         *
         * lodash.isFunction(lodash.foo);
         * // => false
         * lodash.isFunction(lodash.bar);
         * // => true
         *
         * // Create a suped-up `defer` in Node.js.
         * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
         */
        var runInContext = function runInContext(context) {
          context =
            context == null
              ? root
              : _.defaults(root.Object(), context, _.pick(root, contextProps))

          /** Built-in constructor references. */
          var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype

          /** Used to detect overreaching core-js shims. */
          var coreJsData = context['__core-js_shared__']

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /** Used to generate unique IDs. */
          var idCounter = 0

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = (function () {
            var uid = /[^.]+$/.exec(
              (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ''
            )
            return uid ? 'Symbol(src)_1.' + uid : ''
          })()

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var nativeObjectToString = objectProto.toString

          /** Used to infer the `Object` constructor. */
          var objectCtorString = funcToString.call(Object)

          /** Used to restore the original `_` reference in `_.noConflict`. */
          var oldDash = root._

          /** Used to detect if a method is native. */
          var reIsNative = RegExp(
            '^' +
              funcToString
                .call(hasOwnProperty)
                .replace(reRegExpChar, '\\$&')
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  '$1.*?'
                ) +
              '$'
          )

          /** Built-in value references. */
          var Buffer = moduleExports ? context.Buffer : undefined,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
            symIterator = Symbol ? Symbol.iterator : undefined,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined

          var defineProperty = (function () {
            try {
              var func = getNative(Object, 'defineProperty')
              func({}, '', {})
              return func
            } catch (e) {}
          })()

          /** Mocked built-ins. */
          var ctxClearTimeout =
              context.clearTimeout !== root.clearTimeout &&
              context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout =
              context.setTimeout !== root.setTimeout && context.setTimeout

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse

          /* Built-in method references that are verified to be native. */
          var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create')

          /** Used to store function metadata. */
          var metaMap = WeakMap && new WeakMap()

          /** Used to lookup unminified function names. */
          var realNames = {}

          /** Used to detect maps, sets, and weakmaps. */
          var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap)

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object which wraps `value` to enable implicit method
           * chain sequences. Methods that operate on and return arrays, collections,
           * and functions can be chained together. Methods that retrieve a single value
           * or may return a primitive value will automatically end the chain sequence
           * and return the unwrapped value. Otherwise, the value must be unwrapped
           * with `_#value`.
           *
           * Explicit chain sequences, which must be unwrapped with `_#value`, may be
           * enabled using `_.chain`.
           *
           * The execution of chained methods is lazy, that is, it's deferred until
           * `_#value` is implicitly or explicitly called.
           *
           * Lazy evaluation allows several methods to support shortcut fusion.
           * Shortcut fusion is an optimization to merge iteratee calls; this avoids
           * the creation of intermediate arrays and can greatly reduce the number of
           * iteratee executions. Sections of a chain sequence qualify for shortcut
           * fusion if the section is applied to an array and iteratees accept only
           * one argument. The heuristic for whether a section qualifies for shortcut
           * fusion is subject to change.
           *
           * Chaining is supported in custom builds as long as the `_#value` method is
           * directly or indirectly included in the build.
           *
           * In addition to lodash methods, wrappers have `Array` and `String` methods.
           *
           * The wrapper `Array` methods are:
           * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
           *
           * The wrapper `String` methods are:
           * `replace` and `split`
           *
           * The wrapper methods that support shortcut fusion are:
           * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
           * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
           * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
           *
           * The chainable wrapper methods are:
           * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
           * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
           * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
           * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
           * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
           * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
           * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
           * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
           * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
           * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
           * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
           * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
           * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
           * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
           * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
           * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
           * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
           * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
           * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
           * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
           * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
           * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
           * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
           * `zipObject`, `zipObjectDeep`, and `zipWith`
           *
           * The wrapper methods that are **not** chainable by default are:
           * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
           * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
           * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
           * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
           * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
           * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
           * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
           * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
           * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
           * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
           * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
           * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
           * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
           * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
           * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
           * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
           * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
           * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
           * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
           * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
           * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
           * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
           * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
           * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
           * `upperFirst`, `value`, and `words`
           *
           * @name _
           * @constructor
           * @category Seq
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // Returns an unwrapped value.
           * wrapped.reduce(_.add);
           * // => 6
           *
           * // Returns a wrapped value.
           * var squares = wrapped.map(square);
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */
          function lodash(value) {
            if (
              isObjectLike(value) &&
              !isArray(value) &&
              !(value instanceof LazyWrapper)
            ) {
              if (value instanceof LodashWrapper) {
                return value
              }
              if (hasOwnProperty.call(value, '__wrapped__')) {
                return wrapperClone(value)
              }
            }
            return new LodashWrapper(value)
          }

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} proto The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          var baseCreate = (function () {
            function object() {}
            return function (proto) {
              if (!isObject(proto)) {
                return {}
              }
              if (objectCreate) {
                return objectCreate(proto)
              }
              object.prototype = proto
              var result = new object()
              object.prototype = undefined
              return result
            }
          })()

          /**
           * The function whose prototype chain sequence wrappers inherit from.
           *
           * @private
           */
          function baseLodash() {
            // No operation performed.
          }

          /**
           * The base constructor for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap.
           * @param {boolean} [chainAll] Enable explicit method chain sequences.
           */
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value
            this.__actions__ = []
            this.__chain__ = !!chainAll
            this.__index__ = 0
            this.__values__ = undefined
          }

          /**
           * By default, the template delimiters used by lodash are like those in
           * embedded Ruby (ERB) as well as ES2015 template strings. Change the
           * following template settings to use alternative delimiters.
           *
           * @static
           * @memberOf _
           * @type {Object}
           */
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            escape: reEscape,

            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            evaluate: reEvaluate,

            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            interpolate: reInterpolate,

            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            variable: '',

            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            imports: {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              _: lodash
            }
          }

          // Ensure wrappers are instances of `baseLodash`.
          lodash.prototype = baseLodash.prototype
          lodash.prototype.constructor = lodash

          LodashWrapper.prototype = baseCreate(baseLodash.prototype)
          LodashWrapper.prototype.constructor = LodashWrapper

          /*------------------------------------------------------------------------*/

          /**
           * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
           *
           * @private
           * @constructor
           * @param {*} value The value to wrap.
           */
          function LazyWrapper(value) {
            this.__wrapped__ = value
            this.__actions__ = []
            this.__dir__ = 1
            this.__filtered__ = false
            this.__iteratees__ = []
            this.__takeCount__ = MAX_ARRAY_LENGTH
            this.__views__ = []
          }

          /**
           * Creates a clone of the lazy wrapper object.
           *
           * @private
           * @name clone
           * @memberOf LazyWrapper
           * @returns {Object} Returns the cloned `LazyWrapper` object.
           */
          function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__)
            result.__actions__ = copyArray(this.__actions__)
            result.__dir__ = this.__dir__
            result.__filtered__ = this.__filtered__
            result.__iteratees__ = copyArray(this.__iteratees__)
            result.__takeCount__ = this.__takeCount__
            result.__views__ = copyArray(this.__views__)
            return result
          }

          /**
           * Reverses the direction of lazy iteration.
           *
           * @private
           * @name reverse
           * @memberOf LazyWrapper
           * @returns {Object} Returns the new reversed `LazyWrapper` object.
           */
          function lazyReverse() {
            if (this.__filtered__) {
              var result = new LazyWrapper(this)
              result.__dir__ = -1
              result.__filtered__ = true
            } else {
              result = this.clone()
              result.__dir__ *= -1
            }
            return result
          }

          /**
           * Extracts the unwrapped value from its lazy wrapper.
           *
           * @private
           * @name value
           * @memberOf LazyWrapper
           * @returns {*} Returns the unwrapped value.
           */
          function lazyValue() {
            var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : start - 1,
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__)

            if (
              !isArr ||
              (!isRight && arrLength == length && takeCount == length)
            ) {
              return baseWrapperValue(array, this.__actions__)
            }
            var result = []

            outer: while (length-- && resIndex < takeCount) {
              index += dir

              var iterIndex = -1,
                value = array[index]

              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value)

                if (type == LAZY_MAP_FLAG) {
                  value = computed
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer
                  } else {
                    break outer
                  }
                }
              }
              result[resIndex++] = value
            }
            return result
          }

          // Ensure `LazyWrapper` is an instance of `baseLodash`.
          LazyWrapper.prototype = baseCreate(baseLodash.prototype)
          LazyWrapper.prototype.constructor = LazyWrapper

          /*------------------------------------------------------------------------*/

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length

            this.clear()
            while (++index < length) {
              var entry = entries[index]
              this.set(entry[0], entry[1])
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {}
            this.size = 0
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key]
            this.size -= result ? 1 : 0
            return result
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__
            if (nativeCreate) {
              var result = data[key]
              return result === HASH_UNDEFINED ? undefined : result
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__
            return nativeCreate
              ? data[key] !== undefined
              : hasOwnProperty.call(data, key)
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__
            this.size += this.has(key) ? 0 : 1
            data[key] =
              nativeCreate && value === undefined ? HASH_UNDEFINED : value
            return this
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear
          Hash.prototype['delete'] = hashDelete
          Hash.prototype.get = hashGet
          Hash.prototype.has = hashHas
          Hash.prototype.set = hashSet

          /*------------------------------------------------------------------------*/

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length

            this.clear()
            while (++index < length) {
              var entry = entries[index]
              this.set(entry[0], entry[1])
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = []
            this.size = 0
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key)

            if (index < 0) {
              return false
            }
            var lastIndex = data.length - 1
            if (index == lastIndex) {
              data.pop()
            } else {
              splice.call(data, index, 1)
            }
            --this.size
            return true
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key)

            return index < 0 ? undefined : data[index][1]
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key)

            if (index < 0) {
              ++this.size
              data.push([key, value])
            } else {
              data[index][1] = value
            }
            return this
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear
          ListCache.prototype['delete'] = listCacheDelete
          ListCache.prototype.get = listCacheGet
          ListCache.prototype.has = listCacheHas
          ListCache.prototype.set = listCacheSet

          /*------------------------------------------------------------------------*/

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length

            this.clear()
            while (++index < length) {
              var entry = entries[index]
              this.set(entry[0], entry[1])
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.size = 0
            this.__data__ = {
              hash: new Hash(),
              map: new (Map || ListCache)(),
              string: new Hash()
            }
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key)
            this.size -= result ? 1 : 0
            return result
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key)
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key)
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
              size = data.size

            data.set(key, value)
            this.size += data.size == size ? 0 : 1
            return this
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear
          MapCache.prototype['delete'] = mapCacheDelete
          MapCache.prototype.get = mapCacheGet
          MapCache.prototype.has = mapCacheHas
          MapCache.prototype.set = mapCacheSet

          /*------------------------------------------------------------------------*/

          /**
           *
           * Creates an array cache object to store unique values.
           *
           * @private
           * @constructor
           * @param {Array} [values] The values to cache.
           */
          function SetCache(values) {
            var index = -1,
              length = values == null ? 0 : values.length

            this.__data__ = new MapCache()
            while (++index < length) {
              this.add(values[index])
            }
          }

          /**
           * Adds `value` to the array cache.
           *
           * @private
           * @name add
           * @memberOf SetCache
           * @alias push
           * @param {*} value The value to cache.
           * @returns {Object} Returns the cache instance.
           */
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED)
            return this
          }

          /**
           * Checks if `value` is in the array cache.
           *
           * @private
           * @name has
           * @memberOf SetCache
           * @param {*} value The value to search for.
           * @returns {number} Returns `true` if `value` is found, else `false`.
           */
          function setCacheHas(value) {
            return this.__data__.has(value)
          }

          // Add methods to `SetCache`.
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
          SetCache.prototype.has = setCacheHas

          /*------------------------------------------------------------------------*/

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Stack(entries) {
            var data = (this.__data__ = new ListCache(entries))
            this.size = data.size
          }

          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */
          function stackClear() {
            this.__data__ = new ListCache()
            this.size = 0
          }

          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function stackDelete(key) {
            var data = this.__data__,
              result = data['delete'](key)

            this.size = data.size
            return result
          }

          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function stackGet(key) {
            return this.__data__.get(key)
          }

          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function stackHas(key) {
            return this.__data__.has(key)
          }

          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */
          function stackSet(key, value) {
            var data = this.__data__
            if (data instanceof ListCache) {
              var pairs = data.__data__
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value])
                this.size = ++data.size
                return this
              }
              data = this.__data__ = new MapCache(pairs)
            }
            data.set(key, value)
            this.size = data.size
            return this
          }

          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear
          Stack.prototype['delete'] = stackDelete
          Stack.prototype.get = stackGet
          Stack.prototype.has = stackHas
          Stack.prototype.set = stackSet

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length

            for (var key in value) {
              if (
                (inherited || hasOwnProperty.call(value, key)) &&
                !(
                  skipIndexes &&
                  // Safari 9 has enumerable `arguments.length` in strict mode.
                  (key == 'length' ||
                    // Node.js 0.10 has enumerable non-index properties on buffers.
                    (isBuff && (key == 'offset' || key == 'parent')) ||
                    // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    (isType &&
                      (key == 'buffer' ||
                        key == 'byteLength' ||
                        key == 'byteOffset')) ||
                    // Skip index properties.
                    isIndex(key, length))
                )
              ) {
                result.push(key)
              }
            }
            return result
          }

          /**
           * A specialized version of `_.sample` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @returns {*} Returns the random element.
           */
          function arraySample(array) {
            var length = array.length
            return length ? array[baseRandom(0, length - 1)] : undefined
          }

          /**
           * A specialized version of `_.sampleSize` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
          }

          /**
           * A specialized version of `_.shuffle` for arrays.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array))
          }

          /**
           * This function is like `assignValue` except that it doesn't assign
           * `undefined` values.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignMergeValue(object, key, value) {
            if (
              (value !== undefined && !eq(object[key], value)) ||
              (value === undefined && !(key in object))
            ) {
              baseAssignValue(object, key, value)
            }
          }

          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignValue(object, key, value) {
            var objValue = object[key]
            if (
              !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))
            ) {
              baseAssignValue(object, key, value)
            }
          }

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length
            while (length--) {
              if (eq(array[length][0], key)) {
                return length
              }
            }
            return -1
          }

          /**
           * Aggregates elements of `collection` on `accumulator` with keys transformed
           * by `iteratee` and values set by `setter`.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform keys.
           * @param {Object} accumulator The initial aggregated object.
           * @returns {Function} Returns `accumulator`.
           */
          function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function (value, key, collection) {
              setter(accumulator, value, iteratee(value), collection)
            })
            return accumulator
          }

          /**
           * The base implementation of `_.assign` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object)
          }

          /**
           * The base implementation of `_.assignIn` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object)
          }

          /**
           * The base implementation of `assignValue` and `assignMergeValue` without
           * value checks.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true
              })
            } else {
              object[key] = value
            }
          }

          /**
           * The base implementation of `_.at` without support for individual paths.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {string[]} paths The property paths to pick.
           * @returns {Array} Returns the picked elements.
           */
          function baseAt(object, paths) {
            var index = -1,
              length = paths.length,
              result = Array(length),
              skip = object == null

            while (++index < length) {
              result[index] = skip ? undefined : get(object, paths[index])
            }
            return result
          }

          /**
           * The base implementation of `_.clamp` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           */
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined) {
                number = number <= upper ? number : upper
              }
              if (lower !== undefined) {
                number = number >= lower ? number : lower
              }
            }
            return number
          }

          /**
           * The base implementation of `_.clone` and `_.cloneDeep` which tracks
           * traversed objects.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Deep clone
           *  2 - Flatten inherited properties
           *  4 - Clone symbols
           * @param {Function} [customizer] The function to customize cloning.
           * @param {string} [key] The key of `value`.
           * @param {Object} [object] The parent object of `value`.
           * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG

            if (customizer) {
              result = object
                ? customizer(value, key, object, stack)
                : customizer(value)
            }
            if (result !== undefined) {
              return result
            }
            if (!isObject(value)) {
              return value
            }
            var isArr = isArray(value)
            if (isArr) {
              result = initCloneArray(value)
              if (!isDeep) {
                return copyArray(value, result)
              }
            } else {
              var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag

              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep)
              }
              if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                result = isFlat || isFunc ? {} : initCloneObject(value)
                if (!isDeep) {
                  return isFlat
                    ? copySymbolsIn(value, baseAssignIn(result, value))
                    : copySymbols(value, baseAssign(result, value))
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {}
                }
                result = initCloneByTag(value, tag, isDeep)
              }
            }
            // Check for circular references and return its corresponding clone.
            stack || (stack = new Stack())
            var stacked = stack.get(value)
            if (stacked) {
              return stacked
            }
            stack.set(value, result)

            if (isSet(value)) {
              value.forEach(function (subValue) {
                result.add(
                  baseClone(
                    subValue,
                    bitmask,
                    customizer,
                    subValue,
                    value,
                    stack
                  )
                )
              })
            } else if (isMap(value)) {
              value.forEach(function (subValue, key) {
                result.set(
                  key,
                  baseClone(subValue, bitmask, customizer, key, value, stack)
                )
              })
            }

            var keysFunc = isFull
              ? isFlat
                ? getAllKeysIn
                : getAllKeys
              : isFlat
              ? keysIn
              : keys

            var props = isArr ? undefined : keysFunc(value)
            arrayEach(props || value, function (subValue, key) {
              if (props) {
                key = subValue
                subValue = value[key]
              }
              // Recursively populate clone (susceptible to call stack limits).
              assignValue(
                result,
                key,
                baseClone(subValue, bitmask, customizer, key, value, stack)
              )
            })
            return result
          }

          /**
           * The base implementation of `_.conforms` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           */
          function baseConforms(source) {
            var props = keys(source)
            return function (object) {
              return baseConformsTo(object, source, props)
            }
          }

          /**
           * The base implementation of `_.conformsTo` which accepts `props` to check.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           */
          function baseConformsTo(object, source, props) {
            var length = props.length
            if (object == null) {
              return !length
            }
            object = Object(object)
            while (length--) {
              var key = props[length],
                predicate = source[key],
                value = object[key]

              if (
                (value === undefined && !(key in object)) ||
                !predicate(value)
              ) {
                return false
              }
            }
            return true
          }

          /**
           * The base implementation of `_.delay` and `_.defer` which accepts `args`
           * to provide to `func`.
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {Array} args The arguments to provide to `func`.
           * @returns {number|Object} Returns the timer id or timeout object.
           */
          function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            return setTimeout(function () {
              func.apply(undefined, args)
            }, wait)
          }

          /**
           * The base implementation of methods like `_.difference` without support
           * for excluding multiple arrays or iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Array} values The values to exclude.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           */
          function baseDifference(array, values, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length

            if (!length) {
              return result
            }
            if (iteratee) {
              values = arrayMap(values, baseUnary(iteratee))
            }
            if (comparator) {
              includes = arrayIncludesWith
              isCommon = false
            } else if (values.length >= LARGE_ARRAY_SIZE) {
              includes = cacheHas
              isCommon = false
              values = new SetCache(values)
            }
            outer: while (++index < length) {
              var value = array[index],
                computed = iteratee == null ? value : iteratee(value)

              value = comparator || value !== 0 ? value : 0
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength
                while (valuesIndex--) {
                  if (values[valuesIndex] === computed) {
                    continue outer
                  }
                }
                result.push(value)
              } else if (!includes(values, computed, comparator)) {
                result.push(value)
              }
            }
            return result
          }

          /**
           * The base implementation of `_.forEach` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */
          var baseEach = createBaseEach(baseForOwn)

          /**
           * The base implementation of `_.forEachRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */
          var baseEachRight = createBaseEach(baseForOwnRight, true)

          /**
           * The base implementation of `_.every` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`
           */
          function baseEvery(collection, predicate) {
            var result = true
            baseEach(collection, function (value, index, collection) {
              result = !!predicate(value, index, collection)
              return result
            })
            return result
          }

          /**
           * The base implementation of methods like `_.max` and `_.min` which accepts a
           * `comparator` to determine the extremum value.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The iteratee invoked per iteration.
           * @param {Function} comparator The comparator used to compare values.
           * @returns {*} Returns the extremum value.
           */
          function baseExtremum(array, iteratee, comparator) {
            var index = -1,
              length = array.length

            while (++index < length) {
              var value = array[index],
                current = iteratee(value)

              if (
                current != null &&
                (computed === undefined
                  ? current === current && !isSymbol(current)
                  : comparator(current, computed))
              ) {
                var computed = current,
                  result = value
              }
            }
            return result
          }

          /**
           * The base implementation of `_.fill` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           */
          function baseFill(array, value, start, end) {
            var length = array.length

            start = toInteger(start)
            if (start < 0) {
              start = -start > length ? 0 : length + start
            }
            end = end === undefined || end > length ? length : toInteger(end)
            if (end < 0) {
              end += length
            }
            end = start > end ? 0 : toLength(end)
            while (start < end) {
              array[start++] = value
            }
            return array
          }

          /**
           * The base implementation of `_.filter` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */
          function baseFilter(collection, predicate) {
            var result = []
            baseEach(collection, function (value, index, collection) {
              if (predicate(value, index, collection)) {
                result.push(value)
              }
            })
            return result
          }

          /**
           * The base implementation of `_.flatten` with support for restricting flattening.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {number} depth The maximum recursion depth.
           * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
           * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
           * @param {Array} [result=[]] The initial result value.
           * @returns {Array} Returns the new flattened array.
           */
          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
              length = array.length

            predicate || (predicate = isFlattenable)
            result || (result = [])

            while (++index < length) {
              var value = array[index]
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  // Recursively flatten arrays (susceptible to call stack limits).
                  baseFlatten(value, depth - 1, predicate, isStrict, result)
                } else {
                  arrayPush(result, value)
                }
              } else if (!isStrict) {
                result[result.length] = value
              }
            }
            return result
          }

          /**
           * The base implementation of `baseForOwn` which iterates over `object`
           * properties returned by `keysFunc` and invokes `iteratee` for each property.
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseFor = createBaseFor()

          /**
           * This function is like `baseFor` except that it iterates over properties
           * in the opposite order.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseForRight = createBaseFor(true)

          /**
           * The base implementation of `_.forOwn` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys)
          }

          /**
           * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys)
          }

          /**
           * The base implementation of `_.functions` which creates an array of
           * `object` function property names filtered from `props`.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} props The property names to filter.
           * @returns {Array} Returns the function names.
           */
          function baseFunctions(object, props) {
            return arrayFilter(props, function (key) {
              return isFunction(object[key])
            })
          }

          /**
           * The base implementation of `_.get` without support for default values.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @returns {*} Returns the resolved value.
           */
          function baseGet(object, path) {
            path = castPath(path, object)

            var index = 0,
              length = path.length

            while (object != null && index < length) {
              object = object[toKey(path[index++])]
            }
            return index && index == length ? object : undefined
          }

          /**
           * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
           * `keysFunc` and `symbolsFunc` to get the enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @param {Function} symbolsFunc The function to get the symbols of `object`.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object)
            return isArray(object)
              ? result
              : arrayPush(result, symbolsFunc(object))
          }

          /**
           * The base implementation of `getTag` without fallbacks for buggy environments.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag
            }
            return symToStringTag && symToStringTag in Object(value)
              ? getRawTag(value)
              : objectToString(value)
          }

          /**
           * The base implementation of `_.gt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           */
          function baseGt(value, other) {
            return value > other
          }

          /**
           * The base implementation of `_.has` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key)
          }

          /**
           * The base implementation of `_.hasIn` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */
          function baseHasIn(object, key) {
            return object != null && key in Object(object)
          }

          /**
           * The base implementation of `_.inRange` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to check.
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           */
          function baseInRange(number, start, end) {
            return (
              number >= nativeMin(start, end) && number < nativeMax(start, end)
            )
          }

          /**
           * The base implementation of methods like `_.intersection`, without support
           * for iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of shared values.
           */
          function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = []

            while (othIndex--) {
              var array = arrays[othIndex]
              if (othIndex && iteratee) {
                array = arrayMap(array, baseUnary(iteratee))
              }
              maxLength = nativeMin(array.length, maxLength)
              caches[othIndex] =
                !comparator &&
                (iteratee || (length >= 120 && array.length >= 120))
                  ? new SetCache(othIndex && array)
                  : undefined
            }
            array = arrays[0]

            var index = -1,
              seen = caches[0]

            outer: while (++index < length && result.length < maxLength) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value

              value = comparator || value !== 0 ? value : 0
              if (
                !(seen
                  ? cacheHas(seen, computed)
                  : includes(result, computed, comparator))
              ) {
                othIndex = othLength
                while (--othIndex) {
                  var cache = caches[othIndex]
                  if (
                    !(cache
                      ? cacheHas(cache, computed)
                      : includes(arrays[othIndex], computed, comparator))
                  ) {
                    continue outer
                  }
                }
                if (seen) {
                  seen.push(computed)
                }
                result.push(value)
              }
            }
            return result
          }

          /**
           * The base implementation of `_.invert` and `_.invertBy` which inverts
           * `object` with values transformed by `iteratee` and set by `setter`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform values.
           * @param {Object} accumulator The initial inverted object.
           * @returns {Function} Returns `accumulator`.
           */
          function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function (value, key, object) {
              setter(accumulator, iteratee(value), key, object)
            })
            return accumulator
          }

          /**
           * The base implementation of `_.invoke` without support for individual
           * method arguments.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {Array} args The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           */
          function baseInvoke(object, path, args) {
            path = castPath(path, object)
            object = parent(object, path)
            var func = object == null ? object : object[toKey(last(path))]
            return func == null ? undefined : apply(func, object, args)
          }

          /**
           * The base implementation of `_.isArguments`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           */
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag
          }

          /**
           * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           */
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
          }

          /**
           * The base implementation of `_.isDate` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           */
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag
          }

          /**
           * The base implementation of `_.isEqual` which supports partial comparisons
           * and tracks traversed objects.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Unordered comparison
           *  2 - Partial comparison
           * @param {Function} [customizer] The function to customize comparisons.
           * @param {Object} [stack] Tracks traversed `value` and `other` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true
            }
            if (
              value == null ||
              other == null ||
              (!isObjectLike(value) && !isObjectLike(other))
            ) {
              return value !== value && other !== other
            }
            return baseIsEqualDeep(
              value,
              other,
              bitmask,
              customizer,
              baseIsEqual,
              stack
            )
          }

          /**
           * A specialized version of `baseIsEqual` for arrays and objects which performs
           * deep comparisons and tracks traversed objects enabling objects with circular
           * references to be compared.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} [stack] Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function baseIsEqualDeep(
            object,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other)

            objTag = objTag == argsTag ? objectTag : objTag
            othTag = othTag == argsTag ? objectTag : othTag

            var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag

            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false
              }
              objIsArr = true
              objIsObj = false
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack())
              return objIsArr || isTypedArray(object)
                ? equalArrays(
                    object,
                    other,
                    bitmask,
                    customizer,
                    equalFunc,
                    stack
                  )
                : equalByTag(
                    object,
                    other,
                    objTag,
                    bitmask,
                    customizer,
                    equalFunc,
                    stack
                  )
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped =
                  objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped =
                  othIsObj && hasOwnProperty.call(other, '__wrapped__')

              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other

                stack || (stack = new Stack())
                return equalFunc(
                  objUnwrapped,
                  othUnwrapped,
                  bitmask,
                  customizer,
                  stack
                )
              }
            }
            if (!isSameTag) {
              return false
            }
            stack || (stack = new Stack())
            return equalObjects(
              object,
              other,
              bitmask,
              customizer,
              equalFunc,
              stack
            )
          }

          /**
           * The base implementation of `_.isMap` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           */
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag
          }

          /**
           * The base implementation of `_.isMatch` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Array} matchData The property names, values, and compare flags to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           */
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
              length = index,
              noCustomizer = !customizer

            if (object == null) {
              return !length
            }
            object = Object(object)
            while (index--) {
              var data = matchData[index]
              if (
                noCustomizer && data[2]
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
              ) {
                return false
              }
            }
            while (++index < length) {
              data = matchData[index]
              var key = data[0],
                objValue = object[key],
                srcValue = data[1]

              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false
                }
              } else {
                var stack = new Stack()
                if (customizer) {
                  var result = customizer(
                    objValue,
                    srcValue,
                    key,
                    object,
                    source,
                    stack
                  )
                }
                if (
                  !(result === undefined
                    ? baseIsEqual(
                        srcValue,
                        objValue,
                        COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                        customizer,
                        stack
                      )
                    : result)
                ) {
                  return false
                }
              }
            }
            return true
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor
            return pattern.test(toSource(value))
          }

          /**
           * The base implementation of `_.isRegExp` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           */
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag
          }

          /**
           * The base implementation of `_.isSet` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           */
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag
          }

          /**
           * The base implementation of `_.isTypedArray` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           */
          function baseIsTypedArray(value) {
            return (
              isObjectLike(value) &&
              isLength(value.length) &&
              !!typedArrayTags[baseGetTag(value)]
            )
          }

          /**
           * The base implementation of `_.iteratee`.
           *
           * @private
           * @param {*} [value=_.identity] The value to convert to an iteratee.
           * @returns {Function} Returns the iteratee.
           */
          function baseIteratee(value) {
            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
            if (typeof value == 'function') {
              return value
            }
            if (value == null) {
              return identity
            }
            if (typeof value == 'object') {
              return isArray(value)
                ? baseMatchesProperty(value[0], value[1])
                : baseMatches(value)
            }
            return property(value)
          }

          /**
           * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object)
            }
            var result = []
            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key)
              }
            }
            return result
          }

          /**
           * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object)
            }
            var isProto = isPrototype(object),
              result = []

            for (var key in object) {
              if (
                !(
                  key == 'constructor' &&
                  (isProto || !hasOwnProperty.call(object, key))
                )
              ) {
                result.push(key)
              }
            }
            return result
          }

          /**
           * The base implementation of `_.lt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           */
          function baseLt(value, other) {
            return value < other
          }

          /**
           * The base implementation of `_.map` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */
          function baseMap(collection, iteratee) {
            var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : []

            baseEach(collection, function (value, key, collection) {
              result[++index] = iteratee(value, key, collection)
            })
            return result
          }

          /**
           * The base implementation of `_.matches` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           */
          function baseMatches(source) {
            var matchData = getMatchData(source)
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1])
            }
            return function (object) {
              return object === source || baseIsMatch(object, source, matchData)
            }
          }

          /**
           * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
           *
           * @private
           * @param {string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue)
            }
            return function (object) {
              var objValue = get(object, path)
              return objValue === undefined && objValue === srcValue
                ? hasIn(object, path)
                : baseIsEqual(
                    srcValue,
                    objValue,
                    COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG
                  )
            }
          }

          /**
           * The base implementation of `_.merge` without support for multiple sources.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return
            }
            baseFor(
              source,
              function (srcValue, key) {
                stack || (stack = new Stack())
                if (isObject(srcValue)) {
                  baseMergeDeep(
                    object,
                    source,
                    key,
                    srcIndex,
                    baseMerge,
                    customizer,
                    stack
                  )
                } else {
                  var newValue = customizer
                    ? customizer(
                        safeGet(object, key),
                        srcValue,
                        key + '',
                        object,
                        source,
                        stack
                      )
                    : undefined

                  if (newValue === undefined) {
                    newValue = srcValue
                  }
                  assignMergeValue(object, key, newValue)
                }
              },
              keysIn
            )
          }

          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMergeDeep(
            object,
            source,
            key,
            srcIndex,
            mergeFunc,
            customizer,
            stack
          ) {
            var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue)

            if (stacked) {
              assignMergeValue(object, key, stacked)
              return
            }
            var newValue = customizer
              ? customizer(objValue, srcValue, key + '', object, source, stack)
              : undefined

            var isCommon = newValue === undefined

            if (isCommon) {
              var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue)

              newValue = srcValue
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue)
                } else if (isBuff) {
                  isCommon = false
                  newValue = cloneBuffer(srcValue, true)
                } else if (isTyped) {
                  isCommon = false
                  newValue = cloneTypedArray(srcValue, true)
                } else {
                  newValue = []
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue)
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue)
                }
              } else {
                isCommon = false
              }
            }
            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue)
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack)
              stack['delete'](srcValue)
            }
            assignMergeValue(object, key, newValue)
          }

          /**
           * The base implementation of `_.nth` which doesn't coerce arguments.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {number} n The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           */
          function baseNth(array, n) {
            var length = array.length
            if (!length) {
              return
            }
            n += n < 0 ? length : 0
            return isIndex(n, length) ? array[n] : undefined
          }

          /**
           * The base implementation of `_.orderBy` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {string[]} orders The sort orders of `iteratees`.
           * @returns {Array} Returns the new sorted array.
           */
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function (iteratee) {
                if (isArray(iteratee)) {
                  return function (value) {
                    return baseGet(
                      value,
                      iteratee.length === 1 ? iteratee[0] : iteratee
                    )
                  }
                }
                return iteratee
              })
            } else {
              iteratees = [identity]
            }

            var index = -1
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()))

            var result = baseMap(collection, function (value, key, collection) {
              var criteria = arrayMap(iteratees, function (iteratee) {
                return iteratee(value)
              })
              return { criteria: criteria, index: ++index, value: value }
            })

            return baseSortBy(result, function (object, other) {
              return compareMultiple(object, other, orders)
            })
          }

          /**
           * The base implementation of `_.pick` without support for individual
           * property identifiers.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @returns {Object} Returns the new object.
           */
          function basePick(object, paths) {
            return basePickBy(object, paths, function (value, path) {
              return hasIn(object, path)
            })
          }

          /**
           * The base implementation of  `_.pickBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @param {Function} predicate The function invoked per property.
           * @returns {Object} Returns the new object.
           */
          function basePickBy(object, paths, predicate) {
            var index = -1,
              length = paths.length,
              result = {}

            while (++index < length) {
              var path = paths[index],
                value = baseGet(object, path)

              if (predicate(value, path)) {
                baseSet(result, castPath(path, object), value)
              }
            }
            return result
          }

          /**
           * A specialized version of `baseProperty` which supports deep paths.
           *
           * @private
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           */
          function basePropertyDeep(path) {
            return function (object) {
              return baseGet(object, path)
            }
          }

          /**
           * The base implementation of `_.pullAllBy` without support for iteratee
           * shorthands.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           */
          function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array

            if (array === values) {
              values = copyArray(values)
            }
            if (iteratee) {
              seen = arrayMap(array, baseUnary(iteratee))
            }
            while (++index < length) {
              var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value

              while (
                (fromIndex = indexOf(seen, computed, fromIndex, comparator)) >
                -1
              ) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1)
                }
                splice.call(array, fromIndex, 1)
              }
            }
            return array
          }

          /**
           * The base implementation of `_.pullAt` without support for individual
           * indexes or capturing the removed elements.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {number[]} indexes The indexes of elements to remove.
           * @returns {Array} Returns `array`.
           */
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0,
              lastIndex = length - 1

            while (length--) {
              var index = indexes[length]
              if (length == lastIndex || index !== previous) {
                var previous = index
                if (isIndex(index)) {
                  splice.call(array, index, 1)
                } else {
                  baseUnset(array, index)
                }
              }
            }
            return array
          }

          /**
           * The base implementation of `_.random` without support for returning
           * floating-point numbers.
           *
           * @private
           * @param {number} lower The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the random number.
           */
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
          }

          /**
           * The base implementation of `_.range` and `_.rangeRight` which doesn't
           * coerce arguments.
           *
           * @private
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @param {number} step The value to increment or decrement by.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the range of numbers.
           */
          function baseRange(start, end, step, fromRight) {
            var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length)

            while (length--) {
              result[fromRight ? length : ++index] = start
              start += step
            }
            return result
          }

          /**
           * The base implementation of `_.repeat` which doesn't coerce arguments.
           *
           * @private
           * @param {string} string The string to repeat.
           * @param {number} n The number of times to repeat the string.
           * @returns {string} Returns the repeated string.
           */
          function baseRepeat(string, n) {
            var result = ''
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result
            }
            // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
            do {
              if (n % 2) {
                result += string
              }
              n = nativeFloor(n / 2)
              if (n) {
                string += string
              }
            } while (n)

            return result
          }

          /**
           * The base implementation of `_.rest` which doesn't validate or coerce arguments.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           */
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '')
          }

          /**
           * The base implementation of `_.sample`.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           */
          function baseSample(collection) {
            return arraySample(values(collection))
          }

          /**
           * The base implementation of `_.sampleSize` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */
          function baseSampleSize(collection, n) {
            var array = values(collection)
            return shuffleSelf(array, baseClamp(n, 0, array.length))
          }

          /**
           * The base implementation of `_.set`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object
            }
            path = castPath(path, object)

            var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object

            while (nested != null && ++index < length) {
              var key = toKey(path[index]),
                newValue = value

              if (
                key === '__proto__' ||
                key === 'constructor' ||
                key === 'prototype'
              ) {
                return object
              }

              if (index != lastIndex) {
                var objValue = nested[key]
                newValue = customizer
                  ? customizer(objValue, key, nested)
                  : undefined
                if (newValue === undefined) {
                  newValue = isObject(objValue)
                    ? objValue
                    : isIndex(path[index + 1])
                    ? []
                    : {}
                }
              }
              assignValue(nested, key, newValue)
              nested = nested[key]
            }
            return object
          }

          /**
           * The base implementation of `setData` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var baseSetData = !metaMap
            ? identity
            : function (func, data) {
                metaMap.set(func, data)
                return func
              }

          /**
           * The base implementation of `setToString` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var baseSetToString = !defineProperty
            ? identity
            : function (func, string) {
                return defineProperty(func, 'toString', {
                  configurable: true,
                  enumerable: false,
                  value: constant(string),
                  writable: true
                })
              }

          /**
           * The base implementation of `_.shuffle`.
           *
           * @private
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */
          function baseShuffle(collection) {
            return shuffleSelf(values(collection))
          }

          /**
           * The base implementation of `_.slice` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseSlice(array, start, end) {
            var index = -1,
              length = array.length

            if (start < 0) {
              start = -start > length ? 0 : length + start
            }
            end = end > length ? length : end
            if (end < 0) {
              end += length
            }
            length = start > end ? 0 : (end - start) >>> 0
            start >>>= 0

            var result = Array(length)
            while (++index < length) {
              result[index] = array[index + start]
            }
            return result
          }

          /**
           * The base implementation of `_.some` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */
          function baseSome(collection, predicate) {
            var result

            baseEach(collection, function (value, index, collection) {
              result = predicate(value, index, collection)
              return !result
            })
            return !!result
          }

          /**
           * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
           * performs a binary search of `array` to determine the index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function baseSortedIndex(array, value, retHighest) {
            var low = 0,
              high = array == null ? low : array.length

            if (
              typeof value == 'number' &&
              value === value &&
              high <= HALF_MAX_ARRAY_LENGTH
            ) {
              while (low < high) {
                var mid = (low + high) >>> 1,
                  computed = array[mid]

                if (
                  computed !== null &&
                  !isSymbol(computed) &&
                  (retHighest ? computed <= value : computed < value)
                ) {
                  low = mid + 1
                } else {
                  high = mid
                }
              }
              return high
            }
            return baseSortedIndexBy(array, value, identity, retHighest)
          }

          /**
           * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
           * which invokes `iteratee` for `value` and each element of `array` to compute
           * their sort ranking. The iteratee is invoked with one argument; (value).
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} iteratee The iteratee invoked per element.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function baseSortedIndexBy(array, value, iteratee, retHighest) {
            var low = 0,
              high = array == null ? 0 : array.length
            if (high === 0) {
              return 0
            }

            value = iteratee(value)
            var valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined

            while (low < high) {
              var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed)

              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined)
              } else if (valIsNull) {
                setLow =
                  othIsReflexive && othIsDefined && (retHighest || !othIsNull)
              } else if (valIsSymbol) {
                setLow =
                  othIsReflexive &&
                  othIsDefined &&
                  !othIsNull &&
                  (retHighest || !othIsSymbol)
              } else if (othIsNull || othIsSymbol) {
                setLow = false
              } else {
                setLow = retHighest ? computed <= value : computed < value
              }
              if (setLow) {
                low = mid + 1
              } else {
                high = mid
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX)
          }

          /**
           * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
           * support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */
          function baseSortedUniq(array, iteratee) {
            var index = -1,
              length = array.length,
              resIndex = 0,
              result = []

            while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value

              if (!index || !eq(computed, seen)) {
                var seen = computed
                result[resIndex++] = value === 0 ? 0 : value
              }
            }
            return result
          }

          /**
           * The base implementation of `_.toNumber` which doesn't ensure correct
           * conversions of binary, hexadecimal, or octal string values.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           */
          function baseToNumber(value) {
            if (typeof value == 'number') {
              return value
            }
            if (isSymbol(value)) {
              return NAN
            }
            return +value
          }

          /**
           * The base implementation of `_.toString` which doesn't convert nullish
           * values to empty strings.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           */
          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
              return value
            }
            if (isArray(value)) {
              // Recursively convert values (susceptible to call stack limits).
              return arrayMap(value, baseToString) + ''
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : ''
            }
            var result = value + ''
            return result == '0' && 1 / value == -INFINITY ? '-0' : result
          }

          /**
           * The base implementation of `_.uniqBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */
          function baseUniq(array, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result

            if (comparator) {
              isCommon = false
              includes = arrayIncludesWith
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array)
              if (set) {
                return setToArray(set)
              }
              isCommon = false
              includes = cacheHas
              seen = new SetCache()
            } else {
              seen = iteratee ? [] : result
            }
            outer: while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value

              value = comparator || value !== 0 ? value : 0
              if (isCommon && computed === computed) {
                var seenIndex = seen.length
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer
                  }
                }
                if (iteratee) {
                  seen.push(computed)
                }
                result.push(value)
              } else if (!includes(seen, computed, comparator)) {
                if (seen !== result) {
                  seen.push(computed)
                }
                result.push(value)
              }
            }
            return result
          }

          /**
           * The base implementation of `_.unset`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The property path to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           */
          function baseUnset(object, path) {
            path = castPath(path, object)
            object = parent(object, path)
            return object == null || delete object[toKey(last(path))]
          }

          /**
           * The base implementation of `_.update`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to update.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(
              object,
              path,
              updater(baseGet(object, path)),
              customizer
            )
          }

          /**
           * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
           * without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {Function} predicate The function invoked per iteration.
           * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length,
              index = fromRight ? length : -1

            while (
              (fromRight ? index-- : ++index < length) &&
              predicate(array[index], index, array)
            ) {}

            return isDrop
              ? baseSlice(
                  array,
                  fromRight ? 0 : index,
                  fromRight ? index + 1 : length
                )
              : baseSlice(
                  array,
                  fromRight ? index + 1 : 0,
                  fromRight ? length : index
                )
          }

          /**
           * The base implementation of `wrapperValue` which returns the result of
           * performing a sequence of actions on the unwrapped `value`, where each
           * successive action is supplied the return value of the previous.
           *
           * @private
           * @param {*} value The unwrapped value.
           * @param {Array} actions Actions to perform to resolve the unwrapped value.
           * @returns {*} Returns the resolved value.
           */
          function baseWrapperValue(value, actions) {
            var result = value
            if (result instanceof LazyWrapper) {
              result = result.value()
            }
            return arrayReduce(
              actions,
              function (result, action) {
                return action.func.apply(
                  action.thisArg,
                  arrayPush([result], action.args)
                )
              },
              result
            )
          }

          /**
           * The base implementation of methods like `_.xor`, without support for
           * iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of values.
           */
          function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : []
            }
            var index = -1,
              result = Array(length)

            while (++index < length) {
              var array = arrays[index],
                othIndex = -1

              while (++othIndex < length) {
                if (othIndex != index) {
                  result[index] = baseDifference(
                    result[index] || array,
                    arrays[othIndex],
                    iteratee,
                    comparator
                  )
                }
              }
            }
            return baseUniq(baseFlatten(result, 1), iteratee, comparator)
          }

          /**
           * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
           *
           * @private
           * @param {Array} props The property identifiers.
           * @param {Array} values The property values.
           * @param {Function} assignFunc The function to assign values.
           * @returns {Object} Returns the new object.
           */
          function baseZipObject(props, values, assignFunc) {
            var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {}

            while (++index < length) {
              var value = index < valsLength ? values[index] : undefined
              assignFunc(result, props[index], value)
            }
            return result
          }

          /**
           * Casts `value` to an empty array if it's not an array like object.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Array|Object} Returns the cast array-like object.
           */
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : []
          }

          /**
           * Casts `value` to `identity` if it's not a function.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Function} Returns cast function.
           */
          function castFunction(value) {
            return typeof value == 'function' ? value : identity
          }

          /**
           * Casts `value` to a path array if it's not one.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {Object} [object] The object to query keys on.
           * @returns {Array} Returns the cast property path array.
           */
          function castPath(value, object) {
            if (isArray(value)) {
              return value
            }
            return isKey(value, object)
              ? [value]
              : stringToPath(toString(value))
          }

          /**
           * A `baseRest` alias which can be replaced with `identity` by module
           * replacement plugins.
           *
           * @private
           * @type {Function}
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */
          var castRest = baseRest

          /**
           * Casts `array` to a slice if it's needed.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {number} start The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the cast slice.
           */
          function castSlice(array, start, end) {
            var length = array.length
            end = end === undefined ? length : end
            return !start && end >= length
              ? array
              : baseSlice(array, start, end)
          }

          /**
           * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
           *
           * @private
           * @param {number|Object} id The timer id or timeout object of the timer to clear.
           */
          var clearTimeout =
            ctxClearTimeout ||
            function (id) {
              return root.clearTimeout(id)
            }

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice()
            }
            var length = buffer.length,
              result = allocUnsafe
                ? allocUnsafe(length)
                : new buffer.constructor(length)

            buffer.copy(result)
            return result
          }

          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength)
            new Uint8Array(result).set(new Uint8Array(arrayBuffer))
            return result
          }

          /**
           * Creates a clone of `dataView`.
           *
           * @private
           * @param {Object} dataView The data view to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned data view.
           */
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep
              ? cloneArrayBuffer(dataView.buffer)
              : dataView.buffer
            return new dataView.constructor(
              buffer,
              dataView.byteOffset,
              dataView.byteLength
            )
          }

          /**
           * Creates a clone of `regexp`.
           *
           * @private
           * @param {Object} regexp The regexp to clone.
           * @returns {Object} Returns the cloned regexp.
           */
          function cloneRegExp(regexp) {
            var result = new regexp.constructor(
              regexp.source,
              reFlags.exec(regexp)
            )
            result.lastIndex = regexp.lastIndex
            return result
          }

          /**
           * Creates a clone of the `symbol` object.
           *
           * @private
           * @param {Object} symbol The symbol object to clone.
           * @returns {Object} Returns the cloned symbol object.
           */
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
          }

          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep
              ? cloneArrayBuffer(typedArray.buffer)
              : typedArray.buffer
            return new typedArray.constructor(
              buffer,
              typedArray.byteOffset,
              typedArray.length
            )
          }

          /**
           * Compares values to sort them in ascending order.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {number} Returns the sort order indicator for `value`.
           */
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value)

              var othIsDefined = other !== undefined,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other)

              if (
                (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol &&
                  othIsDefined &&
                  othIsReflexive &&
                  !othIsNull &&
                  !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive
              ) {
                return 1
              }
              if (
                (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol &&
                  valIsDefined &&
                  valIsReflexive &&
                  !valIsNull &&
                  !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive
              ) {
                return -1
              }
            }
            return 0
          }

          /**
           * Used by `_.orderBy` to compare multiple properties of a value to another
           * and stable sort them.
           *
           * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
           * specify an order of "desc" for descending or "asc" for ascending sort order
           * of corresponding values.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {boolean[]|string[]} orders The order to sort by for each property.
           * @returns {number} Returns the sort order indicator for `object`.
           */
          function compareMultiple(object, other, orders) {
            var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length

            while (++index < length) {
              var result = compareAscending(
                objCriteria[index],
                othCriteria[index]
              )
              if (result) {
                if (index >= ordersLength) {
                  return result
                }
                var order = orders[index]
                return result * (order == 'desc' ? -1 : 1)
              }
            }
            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
            // that causes it, under certain circumstances, to provide the same value for
            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
            // for more details.
            //
            // This also ensures a stable sort in V8 and other engines.
            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
            return object.index - other.index
          }

          /**
           * Creates an array that is the composition of partially applied arguments,
           * placeholders, and provided arguments into a single array of arguments.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to prepend to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried

            while (++leftIndex < leftLength) {
              result[leftIndex] = partials[leftIndex]
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[holders[argsIndex]] = args[argsIndex]
              }
            }
            while (rangeLength--) {
              result[leftIndex++] = args[argsIndex++]
            }
            return result
          }

          /**
           * This function is like `composeArgs` except that the arguments composition
           * is tailored for `_.partialRight`.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to append to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried

            while (++argsIndex < rangeLength) {
              result[argsIndex] = args[argsIndex]
            }
            var offset = argsIndex
            while (++rightIndex < rightLength) {
              result[offset + rightIndex] = partials[rightIndex]
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++]
              }
            }
            return result
          }

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function copyArray(source, array) {
            var index = -1,
              length = source.length

            array || (array = Array(length))
            while (++index < length) {
              array[index] = source[index]
            }
            return array
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */
          function copyObject(source, props, object, customizer) {
            var isNew = !object
            object || (object = {})

            var index = -1,
              length = props.length

            while (++index < length) {
              var key = props[index]

              var newValue = customizer
                ? customizer(object[key], source[key], key, object, source)
                : undefined

              if (newValue === undefined) {
                newValue = source[key]
              }
              if (isNew) {
                baseAssignValue(object, key, newValue)
              } else {
                assignValue(object, key, newValue)
              }
            }
            return object
          }

          /**
           * Copies own symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object)
          }

          /**
           * Copies own and inherited symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object)
          }

          /**
           * Creates a function like `_.groupBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} [initializer] The accumulator object initializer.
           * @returns {Function} Returns the new aggregator function.
           */
          function createAggregator(setter, initializer) {
            return function (collection, iteratee) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {}

              return func(
                collection,
                setter,
                getIteratee(iteratee, 2),
                accumulator
              )
            }
          }

          /**
           * Creates a function like `_.assign`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */
          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined

              customizer =
                assigner.length > 3 && typeof customizer == 'function'
                  ? (length--, customizer)
                  : undefined

              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer
                length = 1
              }
              object = Object(object)
              while (++index < length) {
                var source = sources[index]
                if (source) {
                  assigner(object, source, index, customizer)
                }
              }
              return object
            })
          }

          /**
           * Creates a `baseEach` or `baseEachRight` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
              if (collection == null) {
                return collection
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee)
              }
              var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection)

              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break
                }
              }
              return collection
            }
          }

          /**
           * Creates a base function for methods like `_.forIn` and `_.forOwn`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length

              while (length--) {
                var key = props[fromRight ? length : ++index]
                if (iteratee(iterable[key], key, iterable) === false) {
                  break
                }
              }
              return object
            }
          }

          /**
           * Creates a function that wraps `func` to invoke it with the optional `this`
           * binding of `thisArg`.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func)

            function wrapper() {
              var fn =
                this && this !== root && this instanceof wrapper ? Ctor : func
              return fn.apply(isBind ? thisArg : this, arguments)
            }
            return wrapper
          }

          /**
           * Creates a function like `_.lowerFirst`.
           *
           * @private
           * @param {string} methodName The name of the `String` case method to use.
           * @returns {Function} Returns the new case function.
           */
          function createCaseFirst(methodName) {
            return function (string) {
              string = toString(string)

              var strSymbols = hasUnicode(string)
                ? stringToArray(string)
                : undefined

              var chr = strSymbols ? strSymbols[0] : string.charAt(0)

              var trailing = strSymbols
                ? castSlice(strSymbols, 1).join('')
                : string.slice(1)

              return chr[methodName]() + trailing
            }
          }

          /**
           * Creates a function like `_.camelCase`.
           *
           * @private
           * @param {Function} callback The function to combine each word.
           * @returns {Function} Returns the new compounder function.
           */
          function createCompounder(callback) {
            return function (string) {
              return arrayReduce(
                words(deburr(string).replace(reApos, '')),
                callback,
                ''
              )
            }
          }

          /**
           * Creates a function that produces an instance of `Ctor` regardless of
           * whether it was invoked as part of a `new` expression or by `call` or `apply`.
           *
           * @private
           * @param {Function} Ctor The constructor to wrap.
           * @returns {Function} Returns the new wrapped function.
           */
          function createCtor(Ctor) {
            return function () {
              // Use a `switch` statement to work with class constructors. See
              // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
              // for more details.
              var args = arguments
              switch (args.length) {
                case 0:
                  return new Ctor()
                case 1:
                  return new Ctor(args[0])
                case 2:
                  return new Ctor(args[0], args[1])
                case 3:
                  return new Ctor(args[0], args[1], args[2])
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3])
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4])
                case 6:
                  return new Ctor(
                    args[0],
                    args[1],
                    args[2],
                    args[3],
                    args[4],
                    args[5]
                  )
                case 7:
                  return new Ctor(
                    args[0],
                    args[1],
                    args[2],
                    args[3],
                    args[4],
                    args[5],
                    args[6]
                  )
              }
              var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args)

              // Mimic the constructor's `return` behavior.
              // See https://es5.github.io/#x13.2.2 for more details.
              return isObject(result) ? result : thisBinding
            }
          }

          /**
           * Creates a function that wraps `func` to enable currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {number} arity The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func)

            function wrapper() {
              var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper)

              while (index--) {
                args[index] = arguments[index]
              }
              var holders =
                length < 3 &&
                args[0] !== placeholder &&
                args[length - 1] !== placeholder
                  ? []
                  : replaceHolders(args, placeholder)

              length -= holders.length
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined,
                  args,
                  holders,
                  undefined,
                  undefined,
                  arity - length
                )
              }
              var fn =
                this && this !== root && this instanceof wrapper ? Ctor : func
              return apply(fn, this, args)
            }
            return wrapper
          }

          /**
           * Creates a `_.find` or `_.findLast` function.
           *
           * @private
           * @param {Function} findIndexFunc The function to find the collection index.
           * @returns {Function} Returns the new find function.
           */
          function createFind(findIndexFunc) {
            return function (collection, predicate, fromIndex) {
              var iterable = Object(collection)
              if (!isArrayLike(collection)) {
                var iteratee = getIteratee(predicate, 3)
                collection = keys(collection)
                predicate = function (key) {
                  return iteratee(iterable[key], key, iterable)
                }
              }
              var index = findIndexFunc(collection, predicate, fromIndex)
              return index > -1
                ? iterable[iteratee ? collection[index] : index]
                : undefined
            }
          }

          /**
           * Creates a `_.flow` or `_.flowRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new flow function.
           */
          function createFlow(fromRight) {
            return flatRest(function (funcs) {
              var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru

              if (fromRight) {
                funcs.reverse()
              }
              while (index--) {
                var func = funcs[index]
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT)
                }
                if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                  var wrapper = new LodashWrapper([], true)
                }
              }
              index = wrapper ? index : length
              while (++index < length) {
                func = funcs[index]

                var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined

                if (
                  data &&
                  isLaziable(data[0]) &&
                  data[1] ==
                    (WRAP_ARY_FLAG |
                      WRAP_CURRY_FLAG |
                      WRAP_PARTIAL_FLAG |
                      WRAP_REARG_FLAG) &&
                  !data[4].length &&
                  data[9] == 1
                ) {
                  wrapper = wrapper[getFuncName(data[0])].apply(
                    wrapper,
                    data[3]
                  )
                } else {
                  wrapper =
                    func.length == 1 && isLaziable(func)
                      ? wrapper[funcName]()
                      : wrapper.thru(func)
                }
              }
              return function () {
                var args = arguments,
                  value = args[0]

                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value()
                }
                var index = 0,
                  result = length ? funcs[index].apply(this, args) : value

                while (++index < length) {
                  result = funcs[index].call(this, result)
                }
                return result
              }
            })
          }

          /**
           * Creates a function that wraps `func` to invoke it with optional `this`
           * binding of `thisArg`, partial application, and currying.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [partialsRight] The arguments to append to those provided
           *  to the new function.
           * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createHybrid(
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary,
            arity
          ) {
            var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined : createCtor(func)

            function wrapper() {
              var length = arguments.length,
                args = Array(length),
                index = length

              while (index--) {
                args[index] = arguments[index]
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder)
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried)
              }
              if (partialsRight) {
                args = composeArgsRight(
                  args,
                  partialsRight,
                  holdersRight,
                  isCurried
                )
              }
              length -= holdersCount
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder)
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary,
                  arity - length
                )
              }
              var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func

              length = args.length
              if (argPos) {
                args = reorder(args, argPos)
              } else if (isFlip && length > 1) {
                args.reverse()
              }
              if (isAry && ary < length) {
                args.length = ary
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn)
              }
              return fn.apply(thisBinding, args)
            }
            return wrapper
          }

          /**
           * Creates a function like `_.invertBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} toIteratee The function to resolve iteratees.
           * @returns {Function} Returns the new inverter function.
           */
          function createInverter(setter, toIteratee) {
            return function (object, iteratee) {
              return baseInverter(object, setter, toIteratee(iteratee), {})
            }
          }

          /**
           * Creates a function that performs a mathematical operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @param {number} [defaultValue] The value used for `undefined` arguments.
           * @returns {Function} Returns the new mathematical operation function.
           */
          function createMathOperation(operator, defaultValue) {
            return function (value, other) {
              var result
              if (value === undefined && other === undefined) {
                return defaultValue
              }
              if (value !== undefined) {
                result = value
              }
              if (other !== undefined) {
                if (result === undefined) {
                  return other
                }
                if (typeof value == 'string' || typeof other == 'string') {
                  value = baseToString(value)
                  other = baseToString(other)
                } else {
                  value = baseToNumber(value)
                  other = baseToNumber(other)
                }
                result = operator(value, other)
              }
              return result
            }
          }

          /**
           * Creates a function like `_.over`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over iteratees.
           * @returns {Function} Returns the new over function.
           */
          function createOver(arrayFunc) {
            return flatRest(function (iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()))
              return baseRest(function (args) {
                var thisArg = this
                return arrayFunc(iteratees, function (iteratee) {
                  return apply(iteratee, thisArg, args)
                })
              })
            })
          }

          /**
           * Creates the padding for `string` based on `length`. The `chars` string
           * is truncated if the number of characters exceeds `length`.
           *
           * @private
           * @param {number} length The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padding for `string`.
           */
          function createPadding(length, chars) {
            chars = chars === undefined ? ' ' : baseToString(chars)

            var charsLength = chars.length
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars
            }
            var result = baseRepeat(
              chars,
              nativeCeil(length / stringSize(chars))
            )
            return hasUnicode(chars)
              ? castSlice(stringToArray(result), 0, length).join('')
              : result.slice(0, length)
          }

          /**
           * Creates a function that wraps `func` to invoke it with the `this` binding
           * of `thisArg` and `partials` prepended to the arguments it receives.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} partials The arguments to prepend to those provided to
           *  the new function.
           * @returns {Function} Returns the new wrapped function.
           */
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func)

            function wrapper() {
              var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn =
                  this && this !== root && this instanceof wrapper ? Ctor : func

              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex]
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex]
              }
              return apply(fn, isBind ? thisArg : this, args)
            }
            return wrapper
          }

          /**
           * Creates a `_.range` or `_.rangeRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new range function.
           */
          function createRange(fromRight) {
            return function (start, end, step) {
              if (
                step &&
                typeof step != 'number' &&
                isIterateeCall(start, end, step)
              ) {
                end = step = undefined
              }
              // Ensure the sign of `-0` is preserved.
              start = toFinite(start)
              if (end === undefined) {
                end = start
                start = 0
              } else {
                end = toFinite(end)
              }
              step =
                step === undefined ? (start < end ? 1 : -1) : toFinite(step)
              return baseRange(start, end, step, fromRight)
            }
          }

          /**
           * Creates a function that performs a relational operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @returns {Function} Returns the new relational operation function.
           */
          function createRelationalOperation(operator) {
            return function (value, other) {
              if (!(typeof value == 'string' && typeof other == 'string')) {
                value = toNumber(value)
                other = toNumber(other)
              }
              return operator(value, other)
            }
          }

          /**
           * Creates a function that wraps `func` to continue currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {Function} wrapFunc The function to create the `func` wrapper.
           * @param {*} placeholder The placeholder value.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createRecurry(
            func,
            bitmask,
            wrapFunc,
            placeholder,
            thisArg,
            partials,
            holders,
            argPos,
            ary,
            arity
          ) {
            var isCurry = bitmask & WRAP_CURRY_FLAG,
              newHolders = isCurry ? holders : undefined,
              newHoldersRight = isCurry ? undefined : holders,
              newPartials = isCurry ? partials : undefined,
              newPartialsRight = isCurry ? undefined : partials

            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG)

            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG)
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary,
              arity
            ]

            var result = wrapFunc.apply(undefined, newData)
            if (isLaziable(func)) {
              setData(result, newData)
            }
            result.placeholder = placeholder
            return setWrapToString(result, func, bitmask)
          }

          /**
           * Creates a function like `_.round`.
           *
           * @private
           * @param {string} methodName The name of the `Math` method to use when rounding.
           * @returns {Function} Returns the new round function.
           */
          function createRound(methodName) {
            var func = Math[methodName]
            return function (number, precision) {
              number = toNumber(number)
              precision =
                precision == null ? 0 : nativeMin(toInteger(precision), 292)
              if (precision && nativeIsFinite(number)) {
                // Shift with exponential notation to avoid floating-point issues.
                // See [MDN](https://mdn.io/round#Examples) for more details.
                var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision))

                pair = (toString(value) + 'e').split('e')
                return +(pair[0] + 'e' + (+pair[1] - precision))
              }
              return func(number)
            }
          }

          /**
           * Creates a set object of `values`.
           *
           * @private
           * @param {Array} values The values to add to the set.
           * @returns {Object} Returns the new set.
           */
          var createSet = !(
            Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY
          )
            ? noop
            : function (values) {
                return new Set(values)
              }

          /**
           * Creates a `_.toPairs` or `_.toPairsIn` function.
           *
           * @private
           * @param {Function} keysFunc The function to get the keys of a given object.
           * @returns {Function} Returns the new pairs function.
           */
          function createToPairs(keysFunc) {
            return function (object) {
              var tag = getTag(object)
              if (tag == mapTag) {
                return mapToArray(object)
              }
              if (tag == setTag) {
                return setToPairs(object)
              }
              return baseToPairs(object, keysFunc(object))
            }
          }

          /**
           * Creates a function that either curries or invokes `func` with optional
           * `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags.
           *    1 - `_.bind`
           *    2 - `_.bindKey`
           *    4 - `_.curry` or `_.curryRight` of a bound function
           *    8 - `_.curry`
           *   16 - `_.curryRight`
           *   32 - `_.partial`
           *   64 - `_.partialRight`
           *  128 - `_.rearg`
           *  256 - `_.ary`
           *  512 - `_.flip`
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to be partially applied.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createWrap(
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            argPos,
            ary,
            arity
          ) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG
            if (!isBindKey && typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            var length = partials ? partials.length : 0
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG)
              partials = holders = undefined
            }
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0)
            arity = arity === undefined ? arity : toInteger(arity)
            length -= holders ? holders.length : 0

            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials,
                holdersRight = holders

              partials = holders = undefined
            }
            var data = isBindKey ? undefined : getData(func)

            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary,
              arity
            ]

            if (data) {
              mergeData(newData, data)
            }
            func = newData[0]
            bitmask = newData[1]
            thisArg = newData[2]
            partials = newData[3]
            holders = newData[4]
            arity = newData[9] =
              newData[9] === undefined
                ? isBindKey
                  ? 0
                  : func.length
                : nativeMax(newData[9] - length, 0)

            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result = createBind(func, bitmask, thisArg)
            } else if (
              bitmask == WRAP_CURRY_FLAG ||
              bitmask == WRAP_CURRY_RIGHT_FLAG
            ) {
              result = createCurry(func, bitmask, arity)
            } else if (
              (bitmask == WRAP_PARTIAL_FLAG ||
                bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &&
              !holders.length
            ) {
              result = createPartial(func, bitmask, thisArg, partials)
            } else {
              result = createHybrid.apply(undefined, newData)
            }
            var setter = data ? baseSetData : setData
            return setWrapToString(setter(result, newData), func, bitmask)
          }

          /**
           * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
           * of source objects to the destination object for all destination properties
           * that resolve to `undefined`.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to assign.
           * @param {Object} object The parent object of `objValue`.
           * @returns {*} Returns the value to assign.
           */
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (
              objValue === undefined ||
              (eq(objValue, objectProto[key]) &&
                !hasOwnProperty.call(object, key))
            ) {
              return srcValue
            }
            return objValue
          }

          /**
           * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
           * objects into destination objects that are passed thru.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to merge.
           * @param {Object} object The parent object of `objValue`.
           * @param {Object} source The parent object of `srcValue`.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           * @returns {*} Returns the value to assign.
           */
          function customDefaultsMerge(
            objValue,
            srcValue,
            key,
            object,
            source,
            stack
          ) {
            if (isObject(objValue) && isObject(srcValue)) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, objValue)
              baseMerge(
                objValue,
                srcValue,
                undefined,
                customDefaultsMerge,
                stack
              )
              stack['delete'](srcValue)
            }
            return objValue
          }

          /**
           * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
           * objects.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {string} key The key of the property to inspect.
           * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
           */
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value
          }

          /**
           * A specialized version of `baseIsEqualDeep` for arrays with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Array} array The array to compare.
           * @param {Array} other The other array to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `array` and `other` objects.
           * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
           */
          function equalArrays(
            array,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length

            if (
              arrLength != othLength &&
              !(isPartial && othLength > arrLength)
            ) {
              return false
            }
            // Check that cyclic values are equal.
            var arrStacked = stack.get(array)
            var othStacked = stack.get(other)
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array
            }
            var index = -1,
              result = true,
              seen =
                bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined

            stack.set(array, other)
            stack.set(other, array)

            // Ignore non-index properties.
            while (++index < arrLength) {
              var arrValue = array[index],
                othValue = other[index]

              if (customizer) {
                var compared = isPartial
                  ? customizer(othValue, arrValue, index, other, array, stack)
                  : customizer(arrValue, othValue, index, array, other, stack)
              }
              if (compared !== undefined) {
                if (compared) {
                  continue
                }
                result = false
                break
              }
              // Recursively compare arrays (susceptible to call stack limits).
              if (seen) {
                if (
                  !arraySome(other, function (othValue, othIndex) {
                    if (
                      !cacheHas(seen, othIndex) &&
                      (arrValue === othValue ||
                        equalFunc(
                          arrValue,
                          othValue,
                          bitmask,
                          customizer,
                          stack
                        ))
                    ) {
                      return seen.push(othIndex)
                    }
                  })
                ) {
                  result = false
                  break
                }
              } else if (
                !(
                  arrValue === othValue ||
                  equalFunc(arrValue, othValue, bitmask, customizer, stack)
                )
              ) {
                result = false
                break
              }
            }
            stack['delete'](array)
            stack['delete'](other)
            return result
          }

          /**
           * A specialized version of `baseIsEqualDeep` for comparing objects of
           * the same `toStringTag`.
           *
           * **Note:** This function only supports comparing values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {string} tag The `toStringTag` of the objects to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalByTag(
            object,
            other,
            tag,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            switch (tag) {
              case dataViewTag:
                if (
                  object.byteLength != other.byteLength ||
                  object.byteOffset != other.byteOffset
                ) {
                  return false
                }
                object = object.buffer
                other = other.buffer

              case arrayBufferTag:
                if (
                  object.byteLength != other.byteLength ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))
                ) {
                  return false
                }
                return true

              case boolTag:
              case dateTag:
              case numberTag:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other)

              case errorTag:
                return (
                  object.name == other.name && object.message == other.message
                )

              case regexpTag:
              case stringTag:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == other + ''

              case mapTag:
                var convert = mapToArray

              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG
                convert || (convert = setToArray)

                if (object.size != other.size && !isPartial) {
                  return false
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object)
                if (stacked) {
                  return stacked == other
                }
                bitmask |= COMPARE_UNORDERED_FLAG

                // Recursively compare objects (susceptible to call stack limits).
                stack.set(object, other)
                var result = equalArrays(
                  convert(object),
                  convert(other),
                  bitmask,
                  customizer,
                  equalFunc,
                  stack
                )
                stack['delete'](object)
                return result

              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other)
                }
            }
            return false
          }

          /**
           * A specialized version of `baseIsEqualDeep` for objects with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalObjects(
            object,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack
          ) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length

            if (objLength != othLength && !isPartial) {
              return false
            }
            var index = objLength
            while (index--) {
              var key = objProps[index]
              if (
                !(isPartial ? key in other : hasOwnProperty.call(other, key))
              ) {
                return false
              }
            }
            // Check that cyclic values are equal.
            var objStacked = stack.get(object)
            var othStacked = stack.get(other)
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object
            }
            var result = true
            stack.set(object, other)
            stack.set(other, object)

            var skipCtor = isPartial
            while (++index < objLength) {
              key = objProps[index]
              var objValue = object[key],
                othValue = other[key]

              if (customizer) {
                var compared = isPartial
                  ? customizer(othValue, objValue, key, other, object, stack)
                  : customizer(objValue, othValue, key, object, other, stack)
              }
              // Recursively compare objects (susceptible to call stack limits).
              if (
                !(compared === undefined
                  ? objValue === othValue ||
                    equalFunc(objValue, othValue, bitmask, customizer, stack)
                  : compared)
              ) {
                result = false
                break
              }
              skipCtor || (skipCtor = key == 'constructor')
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor,
                othCtor = other.constructor

              // Non `Object` object instances with different constructors are not equal.
              if (
                objCtor != othCtor &&
                'constructor' in object &&
                'constructor' in other &&
                !(
                  typeof objCtor == 'function' &&
                  objCtor instanceof objCtor &&
                  typeof othCtor == 'function' &&
                  othCtor instanceof othCtor
                )
              ) {
                result = false
              }
            }
            stack['delete'](object)
            stack['delete'](other)
            return result
          }

          /**
           * A specialized version of `baseRest` which flattens the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */
          function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + '')
          }

          /**
           * Creates an array of own enumerable property names and symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols)
          }

          /**
           * Creates an array of own and inherited enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn)
          }

          /**
           * Gets metadata for `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {*} Returns the metadata for `func`.
           */
          var getData = !metaMap
            ? noop
            : function (func) {
                return metaMap.get(func)
              }

          /**
           * Gets the name of `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {string} Returns the function name.
           */
          function getFuncName(func) {
            var result = func.name + '',
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0

            while (length--) {
              var data = array[length],
                otherFunc = data.func
              if (otherFunc == null || otherFunc == func) {
                return data.name
              }
            }
            return result
          }

          /**
           * Gets the argument placeholder value for `func`.
           *
           * @private
           * @param {Function} func The function to inspect.
           * @returns {*} Returns the placeholder value.
           */
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, 'placeholder')
              ? lodash
              : func
            return object.placeholder
          }

          /**
           * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
           * this function returns the custom method, otherwise it returns `baseIteratee`.
           * If arguments are provided, the chosen function is invoked with them and
           * its result is returned.
           *
           * @private
           * @param {*} [value] The value to convert to an iteratee.
           * @param {number} [arity] The arity of the created iteratee.
           * @returns {Function} Returns the chosen function or its result.
           */
          function getIteratee() {
            var result = lodash.iteratee || iteratee
            result = result === iteratee ? baseIteratee : result
            return arguments.length
              ? result(arguments[0], arguments[1])
              : result
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__
            return isKeyable(key)
              ? data[typeof key == 'string' ? 'string' : 'hash']
              : data.map
          }

          /**
           * Gets the property names, values, and compare flags of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the match data of `object`.
           */
          function getMatchData(object) {
            var result = keys(object),
              length = result.length

            while (length--) {
              var key = result[length],
                value = object[key]

              result[length] = [key, value, isStrictComparable(value)]
            }
            return result
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key)
            return baseIsNative(value) ? value : undefined
          }

          /**
           * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the raw `toStringTag`.
           */
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag]

            try {
              value[symToStringTag] = undefined
              var unmasked = true
            } catch (e) {}

            var result = nativeObjectToString.call(value)
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag
              } else {
                delete value[symToStringTag]
              }
            }
            return result
          }

          /**
           * Creates an array of the own enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */
          var getSymbols = !nativeGetSymbols
            ? stubArray
            : function (object) {
                if (object == null) {
                  return []
                }
                object = Object(object)
                return arrayFilter(nativeGetSymbols(object), function (symbol) {
                  return propertyIsEnumerable.call(object, symbol)
                })
              }

          /**
           * Creates an array of the own and inherited enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */
          var getSymbolsIn = !nativeGetSymbols
            ? stubArray
            : function (object) {
                var result = []
                while (object) {
                  arrayPush(result, getSymbols(object))
                  object = getPrototype(object)
                }
                return result
              }

          /**
           * Gets the `toStringTag` of `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          var getTag = baseGetTag

          // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
          if (
            (DataView &&
              getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map()) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set()) != setTag) ||
            (WeakMap && getTag(new WeakMap()) != weakMapTag)
          ) {
            getTag = function (value) {
              var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : ''

              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag
                  case mapCtorString:
                    return mapTag
                  case promiseCtorString:
                    return promiseTag
                  case setCtorString:
                    return setTag
                  case weakMapCtorString:
                    return weakMapTag
                }
              }
              return result
            }
          }

          /**
           * Gets the view, applying any `transforms` to the `start` and `end` positions.
           *
           * @private
           * @param {number} start The start of the view.
           * @param {number} end The end of the view.
           * @param {Array} transforms The transformations to apply to the view.
           * @returns {Object} Returns an object containing the `start` and `end`
           *  positions of the view.
           */
          function getView(start, end, transforms) {
            var index = -1,
              length = transforms.length

            while (++index < length) {
              var data = transforms[index],
                size = data.size

              switch (data.type) {
                case 'drop':
                  start += size
                  break
                case 'dropRight':
                  end -= size
                  break
                case 'take':
                  end = nativeMin(end, start + size)
                  break
                case 'takeRight':
                  start = nativeMax(start, end - size)
                  break
              }
            }
            return { start: start, end: end }
          }

          /**
           * Extracts wrapper details from the `source` body comment.
           *
           * @private
           * @param {string} source The source to inspect.
           * @returns {Array} Returns the wrapper details.
           */
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails)
            return match ? match[1].split(reSplitDetails) : []
          }

          /**
           * Checks if `path` exists on `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @param {Function} hasFunc The function to check properties.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           */
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object)

            var index = -1,
              length = path.length,
              result = false

            while (++index < length) {
              var key = toKey(path[index])
              if (!(result = object != null && hasFunc(object, key))) {
                break
              }
              object = object[key]
            }
            if (result || ++index != length) {
              return result
            }
            length = object == null ? 0 : object.length
            return (
              !!length &&
              isLength(length) &&
              isIndex(key, length) &&
              (isArray(object) || isArguments(object))
            )
          }

          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */
          function initCloneArray(array) {
            var length = array.length,
              result = new array.constructor(length)

            // Add properties assigned by `RegExp#exec`.
            if (
              length &&
              typeof array[0] == 'string' &&
              hasOwnProperty.call(array, 'index')
            ) {
              result.index = array.index
              result.input = array.input
            }
            return result
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            return typeof object.constructor == 'function' &&
              !isPrototype(object)
              ? baseCreate(getPrototype(object))
              : {}
          }

          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object)

              case boolTag:
              case dateTag:
                return new Ctor(+object)

              case dataViewTag:
                return cloneDataView(object, isDeep)

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep)

              case mapTag:
                return new Ctor()

              case numberTag:
              case stringTag:
                return new Ctor(object)

              case regexpTag:
                return cloneRegExp(object)

              case setTag:
                return new Ctor()

              case symbolTag:
                return cloneSymbol(object)
            }
          }

          /**
           * Inserts wrapper `details` in a comment at the top of the `source` body.
           *
           * @private
           * @param {string} source The source to modify.
           * @returns {Array} details The details to insert.
           * @returns {string} Returns the modified source.
           */
          function insertWrapDetails(source, details) {
            var length = details.length
            if (!length) {
              return source
            }
            var lastIndex = length - 1
            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex]
            details = details.join(length > 2 ? ', ' : ' ')
            return source.replace(
              reWrapComment,
              '{\n/* [wrapped with ' + details + '] */\n'
            )
          }

          /**
           * Checks if `value` is a flattenable `arguments` object or array.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
           */
          function isFlattenable(value) {
            return (
              isArray(value) ||
              isArguments(value) ||
              !!(spreadableSymbol && value && value[spreadableSymbol])
            )
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            var type = typeof value
            length = length == null ? MAX_SAFE_INTEGER : length

            return (
              !!length &&
              (type == 'number' ||
                (type != 'symbol' && reIsUint.test(value))) &&
              value > -1 &&
              value % 1 == 0 &&
              value < length
            )
          }

          /**
           * Checks if the given arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
           *  else `false`.
           */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false
            }
            var type = typeof index
            if (
              type == 'number'
                ? isArrayLike(object) && isIndex(index, object.length)
                : type == 'string' && index in object
            ) {
              return eq(object[index], value)
            }
            return false
          }

          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */
          function isKey(value, object) {
            if (isArray(value)) {
              return false
            }
            var type = typeof value
            if (
              type == 'number' ||
              type == 'symbol' ||
              type == 'boolean' ||
              value == null ||
              isSymbol(value)
            ) {
              return true
            }
            return (
              reIsPlainProp.test(value) ||
              !reIsDeepProp.test(value) ||
              (object != null && value in Object(object))
            )
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = typeof value
            return type == 'string' ||
              type == 'number' ||
              type == 'symbol' ||
              type == 'boolean'
              ? value !== '__proto__'
              : value === null
          }

          /**
           * Checks if `func` has a lazy counterpart.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
           *  else `false`.
           */
          function isLaziable(func) {
            var funcName = getFuncName(func),
              other = lodash[funcName]

            if (
              typeof other != 'function' ||
              !(funcName in LazyWrapper.prototype)
            ) {
              return false
            }
            if (func === other) {
              return true
            }
            var data = getData(other)
            return !!data && func === data[0]
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func
          }

          /**
           * Checks if `func` is capable of being masked.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
           */
          var isMaskable = coreJsData ? isFunction : stubFalse

          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto =
                (typeof Ctor == 'function' && Ctor.prototype) || objectProto

            return value === proto
          }

          /**
           * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` if suitable for strict
           *  equality comparisons, else `false`.
           */
          function isStrictComparable(value) {
            return value === value && !isObject(value)
          }

          /**
           * A specialized version of `matchesProperty` for source values suitable
           * for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {string} key The key of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */
          function matchesStrictComparable(key, srcValue) {
            return function (object) {
              if (object == null) {
                return false
              }
              return (
                object[key] === srcValue &&
                (srcValue !== undefined || key in Object(object))
              )
            }
          }

          /**
           * A specialized version of `_.memoize` which clears the memoized function's
           * cache when it exceeds `MAX_MEMOIZE_SIZE`.
           *
           * @private
           * @param {Function} func The function to have its output memoized.
           * @returns {Function} Returns the new memoized function.
           */
          function memoizeCapped(func) {
            var result = memoize(func, function (key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear()
              }
              return key
            })

            var cache = result.cache
            return result
          }

          /**
           * Merges the function metadata of `source` into `data`.
           *
           * Merging metadata reduces the number of wrappers used to invoke a function.
           * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
           * may be applied regardless of execution order. Methods like `_.ary` and
           * `_.rearg` modify function arguments, making the order in which they are
           * executed important, preventing the merging of metadata. However, we make
           * an exception for a safe combined case where curried functions have `_.ary`
           * and or `_.rearg` applied.
           *
           * @private
           * @param {Array} data The destination metadata.
           * @param {Array} source The source metadata.
           * @returns {Array} Returns `data`.
           */
          function mergeData(data, source) {
            var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon =
                newBitmask <
                (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG)

            var isCombo =
              (srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG) ||
              (srcBitmask == WRAP_ARY_FLAG &&
                bitmask == WRAP_REARG_FLAG &&
                data[7].length <= source[8]) ||
              (srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) &&
                source[7].length <= source[8] &&
                bitmask == WRAP_CURRY_FLAG)

            // Exit early if metadata can't be merged.
            if (!(isCommon || isCombo)) {
              return data
            }
            // Use source `thisArg` if available.
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2]
              // Set when currying a bound function.
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG
            }
            // Compose partial arguments.
            var value = source[3]
            if (value) {
              var partials = data[3]
              data[3] = partials
                ? composeArgs(partials, value, source[4])
                : value
              data[4] = partials
                ? replaceHolders(data[3], PLACEHOLDER)
                : source[4]
            }
            // Compose partial right arguments.
            value = source[5]
            if (value) {
              partials = data[5]
              data[5] = partials
                ? composeArgsRight(partials, value, source[6])
                : value
              data[6] = partials
                ? replaceHolders(data[5], PLACEHOLDER)
                : source[6]
            }
            // Use source `argPos` if available.
            value = source[7]
            if (value) {
              data[7] = value
            }
            // Use source `ary` if it's smaller.
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] =
                data[8] == null ? source[8] : nativeMin(data[8], source[8])
            }
            // Use source `arity` if one is not provided.
            if (data[9] == null) {
              data[9] = source[9]
            }
            // Use source `func` and merge bitmasks.
            data[0] = source[0]
            data[1] = newBitmask

            return data
          }

          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function nativeKeysIn(object) {
            var result = []
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key)
              }
            }
            return result
          }

          /**
           * Converts `value` to a string using `Object.prototype.toString`.
           *
           * @private
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           */
          function objectToString(value) {
            return nativeObjectToString.call(value)
          }

          /**
           * A specialized version of `baseRest` which transforms the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @param {Function} transform The rest array transform.
           * @returns {Function} Returns the new function.
           */
          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0)
            return function () {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length)

              while (++index < length) {
                array[index] = args[start + index]
              }
              index = -1
              var otherArgs = Array(start + 1)
              while (++index < start) {
                otherArgs[index] = args[index]
              }
              otherArgs[start] = transform(array)
              return apply(func, this, otherArgs)
            }
          }

          /**
           * Gets the parent value at `path` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} path The path to get the parent value of.
           * @returns {*} Returns the parent value.
           */
          function parent(object, path) {
            return path.length < 2
              ? object
              : baseGet(object, baseSlice(path, 0, -1))
          }

          /**
           * Reorder `array` according to the specified indexes where the element at
           * the first index is assigned as the first element, the element at
           * the second index is assigned as the second element, and so on.
           *
           * @private
           * @param {Array} array The array to reorder.
           * @param {Array} indexes The arranged array indexes.
           * @returns {Array} Returns `array`.
           */
          function reorder(array, indexes) {
            var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array)

            while (length--) {
              var index = indexes[length]
              array[length] = isIndex(index, arrLength)
                ? oldArray[index]
                : undefined
            }
            return array
          }

          /**
           * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') {
              return
            }

            if (key == '__proto__') {
              return
            }

            return object[key]
          }

          /**
           * Sets metadata for `func`.
           *
           * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
           * period of time, it will trip its breaker and transition to an identity
           * function to avoid garbage collection pauses in V8. See
           * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
           * for more details.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var setData = shortOut(baseSetData)

          /**
           * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @returns {number|Object} Returns the timer id or timeout object.
           */
          var setTimeout =
            ctxSetTimeout ||
            function (func, wait) {
              return root.setTimeout(func, wait)
            }

          /**
           * Sets the `toString` method of `func` to return `string`.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var setToString = shortOut(baseSetToString)

          /**
           * Sets the `toString` method of `wrapper` to mimic the source of `reference`
           * with wrapper details in a comment at the top of the source body.
           *
           * @private
           * @param {Function} wrapper The function to modify.
           * @param {Function} reference The reference function.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Function} Returns `wrapper`.
           */
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + ''
            return setToString(
              wrapper,
              insertWrapDetails(
                source,
                updateWrapDetails(getWrapDetails(source), bitmask)
              )
            )
          }

          /**
           * Creates a function that'll short out and invoke `identity` instead
           * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
           * milliseconds.
           *
           * @private
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new shortable function.
           */
          function shortOut(func) {
            var count = 0,
              lastCalled = 0

            return function () {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled)

              lastCalled = stamp
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0]
                }
              } else {
                count = 0
              }
              return func.apply(undefined, arguments)
            }
          }

          /**
           * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @param {number} [size=array.length] The size of `array`.
           * @returns {Array} Returns `array`.
           */
          function shuffleSelf(array, size) {
            var index = -1,
              length = array.length,
              lastIndex = length - 1

            size = size === undefined ? length : size
            while (++index < size) {
              var rand = baseRandom(index, lastIndex),
                value = array[rand]

              array[rand] = array[index]
              array[index] = value
            }
            array.length = size
            return array
          }

          /**
           * Converts `string` to a property path array.
           *
           * @private
           * @param {string} string The string to convert.
           * @returns {Array} Returns the property path array.
           */
          var stringToPath = memoizeCapped(function (string) {
            var result = []
            if (string.charCodeAt(0) === 46 /* . */) {
              result.push('')
            }
            string.replace(
              rePropName,
              function (match, number, quote, subString) {
                result.push(
                  quote
                    ? subString.replace(reEscapeChar, '$1')
                    : number || match
                )
              }
            )
            return result
          })

          /**
           * Converts `value` to a string key if it's not a string or symbol.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {string|symbol} Returns the key.
           */
          function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) {
              return value
            }
            var result = value + ''
            return result == '0' && 1 / value == -INFINITY ? '-0' : result
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to convert.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func)
              } catch (e) {}
              try {
                return func + ''
              } catch (e) {}
            }
            return ''
          }

          /**
           * Updates wrapper `details` based on `bitmask` flags.
           *
           * @private
           * @returns {Array} details The details to modify.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Array} Returns `details`.
           */
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function (pair) {
              var value = '_.' + pair[0]
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value)
              }
            })
            return details.sort()
          }

          /**
           * Creates a clone of `wrapper`.
           *
           * @private
           * @param {Object} wrapper The wrapper to clone.
           * @returns {Object} Returns the cloned wrapper.
           */
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone()
            }
            var result = new LodashWrapper(
              wrapper.__wrapped__,
              wrapper.__chain__
            )
            result.__actions__ = copyArray(wrapper.__actions__)
            result.__index__ = wrapper.__index__
            result.__values__ = wrapper.__values__
            return result
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements split into groups the length of `size`.
           * If `array` can't be split evenly, the final chunk will be the remaining
           * elements.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to process.
           * @param {number} [size=1] The length of each chunk
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the new array of chunks.
           * @example
           *
           * _.chunk(['a', 'b', 'c', 'd'], 2);
           * // => [['a', 'b'], ['c', 'd']]
           *
           * _.chunk(['a', 'b', 'c', 'd'], 3);
           * // => [['a', 'b', 'c'], ['d']]
           */
          function chunk(array, size, guard) {
            if (
              guard ? isIterateeCall(array, size, guard) : size === undefined
            ) {
              size = 1
            } else {
              size = nativeMax(toInteger(size), 0)
            }
            var length = array == null ? 0 : array.length
            if (!length || size < 1) {
              return []
            }
            var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size))

            while (index < length) {
              result[resIndex++] = baseSlice(array, index, (index += size))
            }
            return result
          }

          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are falsey.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to compact.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */
          function compact(array) {
            var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = []

            while (++index < length) {
              var value = array[index]
              if (value) {
                result[resIndex++] = value
              }
            }
            return result
          }

          /**
           * Creates a new array concatenating `array` with any additional arrays
           * and/or values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to concatenate.
           * @param {...*} [values] The values to concatenate.
           * @returns {Array} Returns the new concatenated array.
           * @example
           *
           * var array = [1];
           * var other = _.concat(array, 2, [3], [[4]]);
           *
           * console.log(other);
           * // => [1, 2, 3, [4]]
           *
           * console.log(array);
           * // => [1]
           */
          function concat() {
            var length = arguments.length
            if (!length) {
              return []
            }
            var args = Array(length - 1),
              array = arguments[0],
              index = length

            while (index--) {
              args[index - 1] = arguments[index]
            }
            return arrayPush(
              isArray(array) ? copyArray(array) : [array],
              baseFlatten(args, 1)
            )
          }

          /**
           * Creates an array of `array` values not included in the other given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * **Note:** Unlike `_.pullAll`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.without, _.xor
           * @example
           *
           * _.difference([2, 1], [2, 3]);
           * // => [1]
           */
          var difference = baseRest(function (array, values) {
            return isArrayLikeObject(array)
              ? baseDifference(
                  array,
                  baseFlatten(values, 1, isArrayLikeObject, true)
                )
              : []
          })

          /**
           * This method is like `_.difference` except that it accepts `iteratee` which
           * is invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */
          var differenceBy = baseRest(function (array, values) {
            var iteratee = last(values)
            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined
            }
            return isArrayLikeObject(array)
              ? baseDifference(
                  array,
                  baseFlatten(values, 1, isArrayLikeObject, true),
                  getIteratee(iteratee, 2)
                )
              : []
          })

          /**
           * This method is like `_.difference` except that it accepts `comparator`
           * which is invoked to compare elements of `array` to `values`. The order and
           * references of result values are determined by the first array. The comparator
           * is invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           *
           * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }]
           */
          var differenceWith = baseRest(function (array, values) {
            var comparator = last(values)
            if (isArrayLikeObject(comparator)) {
              comparator = undefined
            }
            return isArrayLikeObject(array)
              ? baseDifference(
                  array,
                  baseFlatten(values, 1, isArrayLikeObject, true),
                  undefined,
                  comparator
                )
              : []
          })

          /**
           * Creates a slice of `array` with `n` elements dropped from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.drop([1, 2, 3]);
           * // => [2, 3]
           *
           * _.drop([1, 2, 3], 2);
           * // => [3]
           *
           * _.drop([1, 2, 3], 5);
           * // => []
           *
           * _.drop([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return []
            }
            n = guard || n === undefined ? 1 : toInteger(n)
            return baseSlice(array, n < 0 ? 0 : n, length)
          }

          /**
           * Creates a slice of `array` with `n` elements dropped from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRight([1, 2, 3]);
           * // => [1, 2]
           *
           * _.dropRight([1, 2, 3], 2);
           * // => [1]
           *
           * _.dropRight([1, 2, 3], 5);
           * // => []
           *
           * _.dropRight([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return []
            }
            n = guard || n === undefined ? 1 : toInteger(n)
            n = length - n
            return baseSlice(array, 0, n < 0 ? 0 : n)
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the end.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.dropRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropRightWhile(users, ['active', false]);
           * // => objects for ['barney']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropRightWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */
          function dropRightWhile(array, predicate) {
            return array && array.length
              ? baseWhile(array, getIteratee(predicate, 3), true, true)
              : []
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the beginning.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.dropWhile(users, function(o) { return !o.active; });
           * // => objects for ['pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropWhile(users, ['active', false]);
           * // => objects for ['pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */
          function dropWhile(array, predicate) {
            return array && array.length
              ? baseWhile(array, getIteratee(predicate, 3), true)
              : []
          }

          /**
           * Fills elements of `array` with `value` from `start` up to, but not
           * including, `end`.
           *
           * **Note:** This method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Array
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.fill(array, 'a');
           * console.log(array);
           * // => ['a', 'a', 'a']
           *
           * _.fill(Array(3), 2);
           * // => [2, 2, 2]
           *
           * _.fill([4, 6, 8, 10], '*', 1, 3);
           * // => [4, '*', '*', 10]
           */
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return []
            }
            if (
              start &&
              typeof start != 'number' &&
              isIterateeCall(array, value, start)
            ) {
              start = 0
              end = length
            }
            return baseFill(array, value, start, end)
          }

          /**
           * This method is like `_.find` except that it returns the index of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.findIndex(users, function(o) { return o.user == 'barney'; });
           * // => 0
           *
           * // The `_.matches` iteratee shorthand.
           * _.findIndex(users, { 'user': 'fred', 'active': false });
           * // => 1
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findIndex(users, ['active', false]);
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.findIndex(users, 'active');
           * // => 2
           */
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return -1
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex)
            if (index < 0) {
              index = nativeMax(length + index, 0)
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index)
          }

          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
           * // => 2
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastIndex(users, { 'user': 'barney', 'active': true });
           * // => 0
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastIndex(users, ['active', false]);
           * // => 2
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastIndex(users, 'active');
           * // => 0
           */
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return -1
            }
            var index = length - 1
            if (fromIndex !== undefined) {
              index = toInteger(fromIndex)
              index =
                fromIndex < 0
                  ? nativeMax(length + index, 0)
                  : nativeMin(index, length - 1)
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true)
          }

          /**
           * Flattens `array` a single level deep.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flatten([1, [2, [3, [4]], 5]]);
           * // => [1, 2, [3, [4]], 5]
           */
          function flatten(array) {
            var length = array == null ? 0 : array.length
            return length ? baseFlatten(array, 1) : []
          }

          /**
           * Recursively flattens `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flattenDeep([1, [2, [3, [4]], 5]]);
           * // => [1, 2, 3, 4, 5]
           */
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length
            return length ? baseFlatten(array, INFINITY) : []
          }

          /**
           * Recursively flatten `array` up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * var array = [1, [2, [3, [4]], 5]];
           *
           * _.flattenDepth(array, 1);
           * // => [1, 2, [3, [4]], 5]
           *
           * _.flattenDepth(array, 2);
           * // => [1, 2, 3, [4], 5]
           */
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return []
            }
            depth = depth === undefined ? 1 : toInteger(depth)
            return baseFlatten(array, depth)
          }

          /**
           * The inverse of `_.toPairs`; this method returns an object composed
           * from key-value `pairs`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} pairs The key-value pairs.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.fromPairs([['a', 1], ['b', 2]]);
           * // => { 'a': 1, 'b': 2 }
           */
          function fromPairs(pairs) {
            var index = -1,
              length = pairs == null ? 0 : pairs.length,
              result = {}

            while (++index < length) {
              var pair = pairs[index]
              result[pair[0]] = pair[1]
            }
            return result
          }

          /**
           * Gets the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias first
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the first element of `array`.
           * @example
           *
           * _.head([1, 2, 3]);
           * // => 1
           *
           * _.head([]);
           * // => undefined
           */
          function head(array) {
            return array && array.length ? array[0] : undefined
          }

          /**
           * Gets the index at which the first occurrence of `value` is found in `array`
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it's used as the
           * offset from the end of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.indexOf([1, 2, 1, 2], 2);
           * // => 1
           *
           * // Search from the `fromIndex`.
           * _.indexOf([1, 2, 1, 2], 2, 2);
           * // => 3
           */
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return -1
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex)
            if (index < 0) {
              index = nativeMax(length + index, 0)
            }
            return baseIndexOf(array, value, index)
          }

          /**
           * Gets all but the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           */
          function initial(array) {
            var length = array == null ? 0 : array.length
            return length ? baseSlice(array, 0, -1) : []
          }

          /**
           * Creates an array of unique values that are included in all given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersection([2, 1], [2, 3]);
           * // => [2]
           */
          var intersection = baseRest(function (arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject)
            return mapped.length && mapped[0] === arrays[0]
              ? baseIntersection(mapped)
              : []
          })

          /**
           * This method is like `_.intersection` except that it accepts `iteratee`
           * which is invoked for each element of each `arrays` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [2.1]
           *
           * // The `_.property` iteratee shorthand.
           * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }]
           */
          var intersectionBy = baseRest(function (arrays) {
            var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject)

            if (iteratee === last(mapped)) {
              iteratee = undefined
            } else {
              mapped.pop()
            }
            return mapped.length && mapped[0] === arrays[0]
              ? baseIntersection(mapped, getIteratee(iteratee, 2))
              : []
          })

          /**
           * This method is like `_.intersection` except that it accepts `comparator`
           * which is invoked to compare elements of `arrays`. The order and references
           * of result values are determined by the first array. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.intersectionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }]
           */
          var intersectionWith = baseRest(function (arrays) {
            var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject)

            comparator =
              typeof comparator == 'function' ? comparator : undefined
            if (comparator) {
              mapped.pop()
            }
            return mapped.length && mapped[0] === arrays[0]
              ? baseIntersection(mapped, undefined, comparator)
              : []
          })

          /**
           * Converts all elements in `array` into a string separated by `separator`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to convert.
           * @param {string} [separator=','] The element separator.
           * @returns {string} Returns the joined string.
           * @example
           *
           * _.join(['a', 'b', 'c'], '~');
           * // => 'a~b~c'
           */
          function join(array, separator) {
            return array == null ? '' : nativeJoin.call(array, separator)
          }

          /**
           * Gets the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the last element of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           */
          function last(array) {
            var length = array == null ? 0 : array.length
            return length ? array[length - 1] : undefined
          }

          /**
           * This method is like `_.indexOf` except that it iterates over elements of
           * `array` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 1, 2], 2);
           * // => 3
           *
           * // Search from the `fromIndex`.
           * _.lastIndexOf([1, 2, 1, 2], 2, 2);
           * // => 1
           */
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return -1
            }
            var index = length
            if (fromIndex !== undefined) {
              index = toInteger(fromIndex)
              index =
                index < 0
                  ? nativeMax(length + index, 0)
                  : nativeMin(index, length - 1)
            }
            return value === value
              ? strictLastIndexOf(array, value, index)
              : baseFindIndex(array, baseIsNaN, index, true)
          }

          /**
           * Gets the element at index `n` of `array`. If `n` is negative, the nth
           * element from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.11.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=0] The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           *
           * _.nth(array, 1);
           * // => 'b'
           *
           * _.nth(array, -2);
           * // => 'c';
           */
          function nth(array, n) {
            return array && array.length
              ? baseNth(array, toInteger(n))
              : undefined
          }

          /**
           * Removes all given values from `array` using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
           * to remove elements from an array by predicate.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...*} [values] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pull(array, 'a', 'c');
           * console.log(array);
           * // => ['b', 'b']
           */
          var pull = baseRest(pullAll)

          /**
           * This method is like `_.pull` except that it accepts an array of values to remove.
           *
           * **Note:** Unlike `_.difference`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pullAll(array, ['a', 'c']);
           * console.log(array);
           * // => ['b', 'b']
           */
          function pullAll(array, values) {
            return array && array.length && values && values.length
              ? basePullAll(array, values)
              : array
          }

          /**
           * This method is like `_.pullAll` except that it accepts `iteratee` which is
           * invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The iteratee is invoked with one argument: (value).
           *
           * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
           *
           * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
           * console.log(array);
           * // => [{ 'x': 2 }]
           */
          function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length
              ? basePullAll(array, values, getIteratee(iteratee, 2))
              : array
          }

          /**
           * This method is like `_.pullAll` except that it accepts `comparator` which
           * is invoked to compare elements of `array` to `values`. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
           *
           * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
           * console.log(array);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
           */
          function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length
              ? basePullAll(array, values, undefined, comparator)
              : array
          }

          /**
           * Removes elements from `array` corresponding to `indexes` and returns an
           * array of removed elements.
           *
           * **Note:** Unlike `_.at`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...(number|number[])} [indexes] The indexes of elements to remove.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           * var pulled = _.pullAt(array, [1, 3]);
           *
           * console.log(array);
           * // => ['a', 'c']
           *
           * console.log(pulled);
           * // => ['b', 'd']
           */
          var pullAt = flatRest(function (array, indexes) {
            var length = array == null ? 0 : array.length,
              result = baseAt(array, indexes)

            basePullAt(
              array,
              arrayMap(indexes, function (index) {
                return isIndex(index, length) ? +index : index
              }).sort(compareAscending)
            )

            return result
          })

          /**
           * Removes all elements from `array` that `predicate` returns truthy for
           * and returns an array of the removed elements. The predicate is invoked
           * with three arguments: (value, index, array).
           *
           * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
           * to pull elements from an array by value.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4];
           * var evens = _.remove(array, function(n) {
           *   return n % 2 == 0;
           * });
           *
           * console.log(array);
           * // => [1, 3]
           *
           * console.log(evens);
           * // => [2, 4]
           */
          function remove(array, predicate) {
            var result = []
            if (!(array && array.length)) {
              return result
            }
            var index = -1,
              indexes = [],
              length = array.length

            predicate = getIteratee(predicate, 3)
            while (++index < length) {
              var value = array[index]
              if (predicate(value, index, array)) {
                result.push(value)
                indexes.push(index)
              }
            }
            basePullAt(array, indexes)
            return result
          }

          /**
           * Reverses `array` so that the first element becomes the last, the second
           * element becomes the second to last, and so on.
           *
           * **Note:** This method mutates `array` and is based on
           * [`Array#reverse`](https://mdn.io/Array/reverse).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.reverse(array);
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array)
          }

          /**
           * Creates a slice of `array` from `start` up to, but not including, `end`.
           *
           * **Note:** This method is used instead of
           * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
           * returned.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return []
            }
            if (
              end &&
              typeof end != 'number' &&
              isIterateeCall(array, start, end)
            ) {
              start = 0
              end = length
            } else {
              start = start == null ? 0 : toInteger(start)
              end = end === undefined ? length : toInteger(end)
            }
            return baseSlice(array, start, end)
          }

          /**
           * Uses a binary search to determine the lowest index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([30, 50], 40);
           * // => 1
           */
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value)
          }

          /**
           * This method is like `_.sortedIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
           * // => 0
           */
          function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2))
          }

          /**
           * This method is like `_.indexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
           * // => 1
           */
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length
            if (length) {
              var index = baseSortedIndex(array, value)
              if (index < length && eq(array[index], value)) {
                return index
              }
            }
            return -1
          }

          /**
           * This method is like `_.sortedIndex` except that it returns the highest
           * index at which `value` should be inserted into `array` in order to
           * maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
           * // => 4
           */
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true)
          }

          /**
           * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 1
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
           * // => 1
           */
          function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(
              array,
              value,
              getIteratee(iteratee, 2),
              true
            )
          }

          /**
           * This method is like `_.lastIndexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
           * // => 3
           */
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1
              if (eq(array[index], value)) {
                return index
              }
            }
            return -1
          }

          /**
           * This method is like `_.uniq` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniq([1, 1, 2]);
           * // => [1, 2]
           */
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : []
          }

          /**
           * This method is like `_.uniqBy` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
           * // => [1.1, 2.3]
           */
          function sortedUniqBy(array, iteratee) {
            return array && array.length
              ? baseSortedUniq(array, getIteratee(iteratee, 2))
              : []
          }

          /**
           * Gets all but the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.tail([1, 2, 3]);
           * // => [2, 3]
           */
          function tail(array) {
            var length = array == null ? 0 : array.length
            return length ? baseSlice(array, 1, length) : []
          }

          /**
           * Creates a slice of `array` with `n` elements taken from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.take([1, 2, 3]);
           * // => [1]
           *
           * _.take([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.take([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.take([1, 2, 3], 0);
           * // => []
           */
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return []
            }
            n = guard || n === undefined ? 1 : toInteger(n)
            return baseSlice(array, 0, n < 0 ? 0 : n)
          }

          /**
           * Creates a slice of `array` with `n` elements taken from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRight([1, 2, 3]);
           * // => [3]
           *
           * _.takeRight([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.takeRight([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.takeRight([1, 2, 3], 0);
           * // => []
           */
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return []
            }
            n = guard || n === undefined ? 1 : toInteger(n)
            n = length - n
            return baseSlice(array, n < 0 ? 0 : n, length)
          }

          /**
           * Creates a slice of `array` with elements taken from the end. Elements are
           * taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.takeRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeRightWhile(users, ['active', false]);
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeRightWhile(users, 'active');
           * // => []
           */
          function takeRightWhile(array, predicate) {
            return array && array.length
              ? baseWhile(array, getIteratee(predicate, 3), false, true)
              : []
          }

          /**
           * Creates a slice of `array` with elements taken from the beginning. Elements
           * are taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.takeWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeWhile(users, ['active', false]);
           * // => objects for ['barney', 'fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeWhile(users, 'active');
           * // => []
           */
          function takeWhile(array, predicate) {
            return array && array.length
              ? baseWhile(array, getIteratee(predicate, 3))
              : []
          }

          /**
           * Creates an array of unique values, in order, from all given arrays using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.union([2], [1, 2]);
           * // => [2, 1]
           */
          var union = baseRest(function (arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true))
          })

          /**
           * This method is like `_.union` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which uniqueness is computed. Result values are chosen from the first
           * array in which the value occurs. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.unionBy([2.1], [1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          var unionBy = baseRest(function (arrays) {
            var iteratee = last(arrays)
            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined
            }
            return baseUniq(
              baseFlatten(arrays, 1, isArrayLikeObject, true),
              getIteratee(iteratee, 2)
            )
          })

          /**
           * This method is like `_.union` except that it accepts `comparator` which
           * is invoked to compare elements of `arrays`. Result values are chosen from
           * the first array in which the value occurs. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.unionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */
          var unionWith = baseRest(function (arrays) {
            var comparator = last(arrays)
            comparator =
              typeof comparator == 'function' ? comparator : undefined
            return baseUniq(
              baseFlatten(arrays, 1, isArrayLikeObject, true),
              undefined,
              comparator
            )
          })

          /**
           * Creates a duplicate-free version of an array, using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons, in which only the first occurrence of each element
           * is kept. The order of result values is determined by the order they occur
           * in the array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniq([2, 1, 2]);
           * // => [2, 1]
           */
          function uniq(array) {
            return array && array.length ? baseUniq(array) : []
          }

          /**
           * This method is like `_.uniq` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * uniqueness is computed. The order of result values is determined by the
           * order they occur in the array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          function uniqBy(array, iteratee) {
            return array && array.length
              ? baseUniq(array, getIteratee(iteratee, 2))
              : []
          }

          /**
           * This method is like `_.uniq` except that it accepts `comparator` which
           * is invoked to compare elements of `array`. The order of result values is
           * determined by the order they occur in the array.The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.uniqWith(objects, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
           */
          function uniqWith(array, comparator) {
            comparator =
              typeof comparator == 'function' ? comparator : undefined
            return array && array.length
              ? baseUniq(array, undefined, comparator)
              : []
          }

          /**
           * This method is like `_.zip` except that it accepts an array of grouped
           * elements and creates an array regrouping the elements to their pre-zip
           * configuration.
           *
           * @static
           * @memberOf _
           * @since 1.2.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           *
           * _.unzip(zipped);
           * // => [['a', 'b'], [1, 2], [true, false]]
           */
          function unzip(array) {
            if (!(array && array.length)) {
              return []
            }
            var length = 0
            array = arrayFilter(array, function (group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length)
                return true
              }
            })
            return baseTimes(length, function (index) {
              return arrayMap(array, baseProperty(index))
            })
          }

          /**
           * This method is like `_.unzip` except that it accepts `iteratee` to specify
           * how regrouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  regrouped values.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
           * // => [[1, 10, 100], [2, 20, 200]]
           *
           * _.unzipWith(zipped, _.add);
           * // => [3, 30, 300]
           */
          function unzipWith(array, iteratee) {
            if (!(array && array.length)) {
              return []
            }
            var result = unzip(array)
            if (iteratee == null) {
              return result
            }
            return arrayMap(result, function (group) {
              return apply(iteratee, undefined, group)
            })
          }

          /**
           * Creates an array excluding all given values using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.pull`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...*} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.xor
           * @example
           *
           * _.without([2, 1, 2, 3], 1, 2);
           * // => [3]
           */
          var without = baseRest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : []
          })

          /**
           * Creates an array of unique values that is the
           * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
           * of the given arrays. The order of result values is determined by the order
           * they occur in the arrays.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.without
           * @example
           *
           * _.xor([2, 1], [2, 3]);
           * // => [1, 3]
           */
          var xor = baseRest(function (arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject))
          })

          /**
           * This method is like `_.xor` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which by which they're compared. The order of result values is determined
           * by the order they occur in the arrays. The iteratee is invoked with one
           * argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2, 3.4]
           *
           * // The `_.property` iteratee shorthand.
           * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */
          var xorBy = baseRest(function (arrays) {
            var iteratee = last(arrays)
            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined
            }
            return baseXor(
              arrayFilter(arrays, isArrayLikeObject),
              getIteratee(iteratee, 2)
            )
          })

          /**
           * This method is like `_.xor` except that it accepts `comparator` which is
           * invoked to compare elements of `arrays`. The order of result values is
           * determined by the order they occur in the arrays. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.xorWith(objects, others, _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */
          var xorWith = baseRest(function (arrays) {
            var comparator = last(arrays)
            comparator =
              typeof comparator == 'function' ? comparator : undefined
            return baseXor(
              arrayFilter(arrays, isArrayLikeObject),
              undefined,
              comparator
            )
          })

          /**
           * Creates an array of grouped elements, the first of which contains the
           * first elements of the given arrays, the second of which contains the
           * second elements of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           */
          var zip = baseRest(unzip)

          /**
           * This method is like `_.fromPairs` except that it accepts two arrays,
           * one of property identifiers and one of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 0.4.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObject(['a', 'b'], [1, 2]);
           * // => { 'a': 1, 'b': 2 }
           */
          function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue)
          }

          /**
           * This method is like `_.zipObject` except that it supports property paths.
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
           * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
           */
          function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet)
          }

          /**
           * This method is like `_.zip` except that it accepts `iteratee` to specify
           * how grouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  grouped values.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
           *   return a + b + c;
           * });
           * // => [111, 222]
           */
          var zipWith = baseRest(function (arrays) {
            var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined

            iteratee =
              typeof iteratee == 'function'
                ? (arrays.pop(), iteratee)
                : undefined
            return unzipWith(arrays, iteratee)
          })

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` wrapper instance that wraps `value` with explicit method
           * chain sequences enabled. The result of such sequences must be unwrapped
           * with `_#value`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Seq
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36 },
           *   { 'user': 'fred',    'age': 40 },
           *   { 'user': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _
           *   .chain(users)
           *   .sortBy('age')
           *   .map(function(o) {
           *     return o.user + ' is ' + o.age;
           *   })
           *   .head()
           *   .value();
           * // => 'pebbles is 1'
           */
          function chain(value) {
            var result = lodash(value)
            result.__chain__ = true
            return result
          }

          /**
           * This method invokes `interceptor` and returns `value`. The interceptor
           * is invoked with one argument; (value). The purpose of this method is to
           * "tap into" a method chain sequence in order to modify intermediate results.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3])
           *  .tap(function(array) {
           *    // Mutate input array.
           *    array.pop();
           *  })
           *  .reverse()
           *  .value();
           * // => [2, 1]
           */
          function tap(value, interceptor) {
            interceptor(value)
            return value
          }

          /**
           * This method is like `_.tap` except that it returns the result of `interceptor`.
           * The purpose of this method is to "pass thru" values replacing intermediate
           * results in a method chain sequence.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns the result of `interceptor`.
           * @example
           *
           * _('  abc  ')
           *  .chain()
           *  .trim()
           *  .thru(function(value) {
           *    return [value];
           *  })
           *  .value();
           * // => ['abc']
           */
          function thru(value, interceptor) {
            return interceptor(value)
          }

          /**
           * This method is the wrapper version of `_.at`.
           *
           * @name at
           * @memberOf _
           * @since 1.0.0
           * @category Seq
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _(object).at(['a[0].b.c', 'a[1]']).value();
           * // => [3, 4]
           */
          var wrapperAt = flatRest(function (paths) {
            var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function (object) {
                return baseAt(object, paths)
              }

            if (
              length > 1 ||
              this.__actions__.length ||
              !(value instanceof LazyWrapper) ||
              !isIndex(start)
            ) {
              return this.thru(interceptor)
            }
            value = value.slice(start, +start + (length ? 1 : 0))
            value.__actions__.push({
              func: thru,
              args: [interceptor],
              thisArg: undefined
            })
            return new LodashWrapper(value, this.__chain__).thru(function (
              array
            ) {
              if (length && !array.length) {
                array.push(undefined)
              }
              return array
            })
          })

          /**
           * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
           *
           * @name chain
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // A sequence without explicit chaining.
           * _(users).head();
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // A sequence with explicit chaining.
           * _(users)
           *   .chain()
           *   .head()
           *   .pick('user')
           *   .value();
           * // => { 'user': 'barney' }
           */
          function wrapperChain() {
            return chain(this)
          }

          /**
           * Executes the chain sequence and returns the wrapped result.
           *
           * @name commit
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapped = _(array).push(3);
           *
           * console.log(array);
           * // => [1, 2]
           *
           * wrapped = wrapped.commit();
           * console.log(array);
           * // => [1, 2, 3]
           *
           * wrapped.last();
           * // => 3
           *
           * console.log(array);
           * // => [1, 2, 3]
           */
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__)
          }

          /**
           * Gets the next value on a wrapped object following the
           * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
           *
           * @name next
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the next iterator value.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 1 }
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 2 }
           *
           * wrapped.next();
           * // => { 'done': true, 'value': undefined }
           */
          function wrapperNext() {
            if (this.__values__ === undefined) {
              this.__values__ = toArray(this.value())
            }
            var done = this.__index__ >= this.__values__.length,
              value = done ? undefined : this.__values__[this.__index__++]

            return { done: done, value: value }
          }

          /**
           * Enables the wrapper to be iterable.
           *
           * @name Symbol.iterator
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the wrapper object.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped[Symbol.iterator]() === wrapped;
           * // => true
           *
           * Array.from(wrapped);
           * // => [1, 2]
           */
          function wrapperToIterator() {
            return this
          }

          /**
           * Creates a clone of the chain sequence planting `value` as the wrapped value.
           *
           * @name plant
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @param {*} value The value to plant.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2]).map(square);
           * var other = wrapped.plant([3, 4]);
           *
           * other.value();
           * // => [9, 16]
           *
           * wrapped.value();
           * // => [1, 4]
           */
          function wrapperPlant(value) {
            var result,
              parent = this

            while (parent instanceof baseLodash) {
              var clone = wrapperClone(parent)
              clone.__index__ = 0
              clone.__values__ = undefined
              if (result) {
                previous.__wrapped__ = clone
              } else {
                result = clone
              }
              var previous = clone
              parent = parent.__wrapped__
            }
            previous.__wrapped__ = value
            return result
          }

          /**
           * This method is the wrapper version of `_.reverse`.
           *
           * **Note:** This method mutates the wrapped array.
           *
           * @name reverse
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _(array).reverse().value()
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */
          function wrapperReverse() {
            var value = this.__wrapped__
            if (value instanceof LazyWrapper) {
              var wrapped = value
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this)
              }
              wrapped = wrapped.reverse()
              wrapped.__actions__.push({
                func: thru,
                args: [reverse],
                thisArg: undefined
              })
              return new LodashWrapper(wrapped, this.__chain__)
            }
            return this.thru(reverse)
          }

          /**
           * Executes the chain sequence to resolve the unwrapped value.
           *
           * @name value
           * @memberOf _
           * @since 0.1.0
           * @alias toJSON, valueOf
           * @category Seq
           * @returns {*} Returns the resolved unwrapped value.
           * @example
           *
           * _([1, 2, 3]).value();
           * // => [1, 2, 3]
           */
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__)
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the number of times the key was returned by `iteratee`. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': 1, '6': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */
          var countBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              ++result[key]
            } else {
              baseAssignValue(result, key, 1)
            }
          })

          /**
           * Checks if `predicate` returns truthy for **all** elements of `collection`.
           * Iteration is stopped once `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * **Note:** This method returns `true` for
           * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
           * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
           * elements of empty collections.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes'], Boolean);
           * // => false
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.every(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.every(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.every(users, 'active');
           * // => false
           */
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined
            }
            return func(collection, getIteratee(predicate, 3))
          }

          /**
           * Iterates over elements of `collection`, returning an array of all elements
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * **Note:** Unlike `_.remove`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.reject
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.filter(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, { 'age': 36, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.filter(users, 'active');
           * // => objects for ['barney']
           *
           * // Combining several predicates using `_.overEvery` or `_.overSome`.
           * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
           * // => objects for ['fred', 'barney']
           */
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter
            return func(collection, getIteratee(predicate, 3))
          }

          /**
           * Iterates over elements of `collection`, returning the first element
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': true },
           *   { 'user': 'fred',    'age': 40, 'active': false },
           *   { 'user': 'pebbles', 'age': 1,  'active': true }
           * ];
           *
           * _.find(users, function(o) { return o.age < 40; });
           * // => object for 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.find(users, { 'age': 1, 'active': true });
           * // => object for 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.find(users, ['active', false]);
           * // => object for 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.find(users, 'active');
           * // => object for 'barney'
           */
          var find = createFind(findIndex)

          /**
           * This method is like `_.find` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=collection.length-1] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(n) {
           *   return n % 2 == 1;
           * });
           * // => 3
           */
          var findLast = createFind(findLastIndex)

          /**
           * Creates a flattened array of values by running each element in `collection`
           * thru `iteratee` and flattening the mapped results. The iteratee is invoked
           * with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [n, n];
           * }
           *
           * _.flatMap([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */
          function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1)
          }

          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDeep([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */
          function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY)
          }

          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDepth([1, 2], duplicate, 2);
           * // => [[1, 1], [2, 2]]
           */
          function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth)
            return baseFlatten(map(collection, iteratee), depth)
          }

          /**
           * Iterates over elements of `collection` and invokes `iteratee` for each element.
           * The iteratee is invoked with three arguments: (value, index|key, collection).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * **Note:** As with other "Collections" methods, objects with a "length"
           * property are iterated like arrays. To avoid this behavior use `_.forIn`
           * or `_.forOwn` for object iteration.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias each
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEachRight
           * @example
           *
           * _.forEach([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `1` then `2`.
           *
           * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */
          function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach
            return func(collection, getIteratee(iteratee, 3))
          }

          /**
           * This method is like `_.forEach` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @alias eachRight
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEach
           * @example
           *
           * _.forEachRight([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `2` then `1`.
           */
          function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight
            return func(collection, getIteratee(iteratee, 3))
          }

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The order of grouped values
           * is determined by the order they occur in `collection`. The corresponding
           * value of each key is an array of elements responsible for generating the
           * key. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': [4.2], '6': [6.1, 6.3] }
           *
           * // The `_.property` iteratee shorthand.
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */
          var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              result[key].push(value)
            } else {
              baseAssignValue(result, key, [value])
            }
          })

          /**
           * Checks if `value` is in `collection`. If `collection` is a string, it's
           * checked for a substring of `value`, otherwise
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * is used for equality comparisons. If `fromIndex` is negative, it's used as
           * the offset from the end of `collection`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {boolean} Returns `true` if `value` is found, else `false`.
           * @example
           *
           * _.includes([1, 2, 3], 1);
           * // => true
           *
           * _.includes([1, 2, 3], 1, 2);
           * // => false
           *
           * _.includes({ 'a': 1, 'b': 2 }, 1);
           * // => true
           *
           * _.includes('abcd', 'bc');
           * // => true
           */
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection)
              ? collection
              : values(collection)
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0

            var length = collection.length
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0)
            }
            return isString(collection)
              ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
              : !!length && baseIndexOf(collection, value, fromIndex) > -1
          }

          /**
           * Invokes the method at `path` of each element in `collection`, returning
           * an array of the results of each invoked method. Any additional arguments
           * are provided to each invoked method. If `path` is a function, it's invoked
           * for, and `this` bound to, each element in `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array|Function|string} path The path of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [args] The arguments to invoke each method with.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invokeMap([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */
          var invokeMap = baseRest(function (collection, path, args) {
            var index = -1,
              isFunc = typeof path == 'function',
              result = isArrayLike(collection) ? Array(collection.length) : []

            baseEach(collection, function (value) {
              result[++index] = isFunc
                ? apply(path, value, args)
                : baseInvoke(value, path, args)
            })
            return result
          })

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the last element responsible for generating the key. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var array = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.keyBy(array, function(o) {
           *   return String.fromCharCode(o.code);
           * });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.keyBy(array, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           */
          var keyBy = createAggregator(function (result, value, key) {
            baseAssignValue(result, key, value)
          })

          /**
           * Creates an array of values by running each element in `collection` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
           *
           * The guarded methods are:
           * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
           * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
           * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
           * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * _.map([4, 8], square);
           * // => [16, 64]
           *
           * _.map({ 'a': 4, 'b': 8 }, square);
           * // => [16, 64] (iteration order is not guaranteed)
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, 'user');
           * // => ['barney', 'fred']
           */
          function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap
            return func(collection, getIteratee(iteratee, 3))
          }

          /**
           * This method is like `_.sortBy` except that it allows specifying the sort
           * orders of the iteratees to sort by. If `orders` is unspecified, all values
           * are sorted in ascending order. Otherwise, specify an order of "desc" for
           * descending or "asc" for ascending sort order of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @param {string[]} [orders] The sort orders of `iteratees`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 34 },
           *   { 'user': 'fred',   'age': 40 },
           *   { 'user': 'barney', 'age': 36 }
           * ];
           *
           * // Sort by `user` in ascending order and by `age` in descending order.
           * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
           */
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return []
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees]
            }
            orders = guard ? undefined : orders
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders]
            }
            return baseOrderBy(collection, iteratees, orders)
          }

          /**
           * Creates an array of elements split into two groups, the first of which
           * contains elements `predicate` returns truthy for, the second of which
           * contains elements `predicate` returns falsey for. The predicate is
           * invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of grouped elements.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': false },
           *   { 'user': 'fred',    'age': 40, 'active': true },
           *   { 'user': 'pebbles', 'age': 1,  'active': false }
           * ];
           *
           * _.partition(users, function(o) { return o.active; });
           * // => objects for [['fred'], ['barney', 'pebbles']]
           *
           * // The `_.matches` iteratee shorthand.
           * _.partition(users, { 'age': 1, 'active': false });
           * // => objects for [['pebbles'], ['barney', 'fred']]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.partition(users, ['active', false]);
           * // => objects for [['barney', 'pebbles'], ['fred']]
           *
           * // The `_.property` iteratee shorthand.
           * _.partition(users, 'active');
           * // => objects for [['fred'], ['barney', 'pebbles']]
           */
          var partition = createAggregator(
            function (result, value, key) {
              result[key ? 0 : 1].push(value)
            },
            function () {
              return [[], []]
            }
          )

          /**
           * Reduces `collection` to a value which is the accumulated result of running
           * each element in `collection` thru `iteratee`, where each successive
           * invocation is supplied the return value of the previous. If `accumulator`
           * is not given, the first element of `collection` is used as the initial
           * value. The iteratee is invoked with four arguments:
           * (accumulator, value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.reduce`, `_.reduceRight`, and `_.transform`.
           *
           * The guarded methods are:
           * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
           * and `sortBy`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduceRight
           * @example
           *
           * _.reduce([1, 2], function(sum, n) {
           *   return sum + n;
           * }, 0);
           * // => 3
           *
           * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           *   return result;
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
           */
          function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3

            return func(
              collection,
              getIteratee(iteratee, 4),
              accumulator,
              initAccum,
              baseEach
            )
          }

          /**
           * This method is like `_.reduce` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduce
           * @example
           *
           * var array = [[0, 1], [2, 3], [4, 5]];
           *
           * _.reduceRight(array, function(flattened, other) {
           *   return flattened.concat(other);
           * }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */
          function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3

            return func(
              collection,
              getIteratee(iteratee, 4),
              accumulator,
              initAccum,
              baseEachRight
            )
          }

          /**
           * The opposite of `_.filter`; this method returns the elements of `collection`
           * that `predicate` does **not** return truthy for.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.filter
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': true }
           * ];
           *
           * _.reject(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.reject(users, { 'age': 40, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.reject(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.reject(users, 'active');
           * // => objects for ['barney']
           */
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter
            return func(collection, negate(getIteratee(predicate, 3)))
          }

          /**
           * Gets a random element from `collection`.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           */
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample
            return func(collection)
          }

          /**
           * Gets `n` random elements at unique keys from `collection` up to the
           * size of `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @param {number} [n=1] The number of elements to sample.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the random elements.
           * @example
           *
           * _.sampleSize([1, 2, 3], 2);
           * // => [3, 1]
           *
           * _.sampleSize([1, 2, 3], 4);
           * // => [2, 3, 1]
           */
          function sampleSize(collection, n, guard) {
            if (
              guard ? isIterateeCall(collection, n, guard) : n === undefined
            ) {
              n = 1
            } else {
              n = toInteger(n)
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize
            return func(collection, n)
          }

          /**
           * Creates an array of shuffled values, using a version of the
           * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           * @example
           *
           * _.shuffle([1, 2, 3, 4]);
           * // => [4, 1, 3, 2]
           */
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle
            return func(collection)
          }

          /**
           * Gets the size of `collection` by returning its length for array-like
           * values or the number of own enumerable string keyed properties for objects.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns the collection size.
           * @example
           *
           * _.size([1, 2, 3]);
           * // => 3
           *
           * _.size({ 'a': 1, 'b': 2 });
           * // => 2
           *
           * _.size('pebbles');
           * // => 7
           */
          function size(collection) {
            if (collection == null) {
              return 0
            }
            if (isArrayLike(collection)) {
              return isString(collection)
                ? stringSize(collection)
                : collection.length
            }
            var tag = getTag(collection)
            if (tag == mapTag || tag == setTag) {
              return collection.size
            }
            return baseKeys(collection).length
          }

          /**
           * Checks if `predicate` returns truthy for **any** element of `collection`.
           * Iteration is stopped once `predicate` returns truthy. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var users = [
           *   { 'user': 'barney', 'active': true },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.some(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.some(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.some(users, 'active');
           * // => true
           */
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined
            }
            return func(collection, getIteratee(predicate, 3))
          }

          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection thru each iteratee. This method
           * performs a stable sort, that is, it preserves the original sort order of
           * equal elements. The iteratees are invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 30 },
           *   { 'user': 'barney', 'age': 34 }
           * ];
           *
           * _.sortBy(users, [function(o) { return o.user; }]);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
           *
           * _.sortBy(users, ['user', 'age']);
           * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
           */
          var sortBy = baseRest(function (collection, iteratees) {
            if (collection == null) {
              return []
            }
            var length = iteratees.length
            if (
              length > 1 &&
              isIterateeCall(collection, iteratees[0], iteratees[1])
            ) {
              iteratees = []
            } else if (
              length > 2 &&
              isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
            ) {
              iteratees = [iteratees[0]]
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), [])
          })

          /*------------------------------------------------------------------------*/

          /**
           * Gets the timestamp of the number of milliseconds that have elapsed since
           * the Unix epoch (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Date
           * @returns {number} Returns the timestamp.
           * @example
           *
           * _.defer(function(stamp) {
           *   console.log(_.now() - stamp);
           * }, _.now());
           * // => Logs the number of milliseconds it took for the deferred invocation.
           */
          var now =
            ctxNow ||
            function () {
              return root.Date.now()
            }

          /*------------------------------------------------------------------------*/

          /**
           * The opposite of `_.before`; this method creates a function that invokes
           * `func` once it's called `n` or more times.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {number} n The number of calls before `func` is invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => Logs 'done saving!' after the two async saves have completed.
           */
          function after(n, func) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            n = toInteger(n)
            return function () {
              if (--n < 1) {
                return func.apply(this, arguments)
              }
            }
          }

          /**
           * Creates a function that invokes `func`, with up to `n` arguments,
           * ignoring any additional arguments.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @param {number} [n=func.length] The arity cap.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.ary(parseInt, 1));
           * // => [6, 8, 10]
           */
          function ary(func, n, guard) {
            n = guard ? undefined : n
            n = func && n == null ? func.length : n
            return createWrap(
              func,
              WRAP_ARY_FLAG,
              undefined,
              undefined,
              undefined,
              undefined,
              n
            )
          }

          /**
           * Creates a function that invokes `func`, with the `this` binding and arguments
           * of the created function, while it's called less than `n` times. Subsequent
           * calls to the created function return the result of the last `func` invocation.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {number} n The number of calls at which `func` is no longer invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * jQuery(element).on('click', _.before(5, addContactToList));
           * // => Allows adding up to 4 contacts to the list.
           */
          function before(n, func) {
            var result
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            n = toInteger(n)
            return function () {
              if (--n > 0) {
                result = func.apply(this, arguments)
              }
              if (n <= 1) {
                func = undefined
              }
              return result
            }
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and `partials` prepended to the arguments it receives.
           *
           * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for partially applied arguments.
           *
           * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
           * property of bound functions.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * function greet(greeting, punctuation) {
           *   return greeting + ' ' + this.user + punctuation;
           * }
           *
           * var object = { 'user': 'fred' };
           *
           * var bound = _.bind(greet, object, 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bind(greet, object, _, '!');
           * bound('hi');
           * // => 'hi fred!'
           */
          var bind = baseRest(function (func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind))
              bitmask |= WRAP_PARTIAL_FLAG
            }
            return createWrap(func, bitmask, thisArg, partials, holders)
          })

          /**
           * Creates a function that invokes the method at `object[key]` with `partials`
           * prepended to the arguments it receives.
           *
           * This method differs from `_.bind` by allowing bound functions to reference
           * methods that may be redefined or don't yet exist. See
           * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
           * for more details.
           *
           * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Function
           * @param {Object} object The object to invoke the method on.
           * @param {string} key The key of the method.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'user': 'fred',
           *   'greet': function(greeting, punctuation) {
           *     return greeting + ' ' + this.user + punctuation;
           *   }
           * };
           *
           * var bound = _.bindKey(object, 'greet', 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * object.greet = function(greeting, punctuation) {
           *   return greeting + 'ya ' + this.user + punctuation;
           * };
           *
           * bound('!');
           * // => 'hiya fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bindKey(object, 'greet', _, '!');
           * bound('hi');
           * // => 'hiya fred!'
           */
          var bindKey = baseRest(function (object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey))
              bitmask |= WRAP_PARTIAL_FLAG
            }
            return createWrap(key, bitmask, object, partials, holders)
          })

          /**
           * Creates a function that accepts arguments of `func` and either invokes
           * `func` returning its result, if at least `arity` number of arguments have
           * been provided, or returns a function that accepts the remaining `func`
           * arguments, and so on. The arity of `func` may be specified if `func.length`
           * is not sufficient.
           *
           * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curry(abc);
           *
           * curried(1)(2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(1)(_, 3)(2);
           * // => [1, 2, 3]
           */
          function curry(func, arity, guard) {
            arity = guard ? undefined : arity
            var result = createWrap(
              func,
              WRAP_CURRY_FLAG,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              arity
            )
            result.placeholder = curry.placeholder
            return result
          }

          /**
           * This method is like `_.curry` except that arguments are applied to `func`
           * in the manner of `_.partialRight` instead of `_.partial`.
           *
           * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curryRight(abc);
           *
           * curried(3)(2)(1);
           * // => [1, 2, 3]
           *
           * curried(2, 3)(1);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(3)(1, _)(2);
           * // => [1, 2, 3]
           */
          function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity
            var result = createWrap(
              func,
              WRAP_CURRY_RIGHT_FLAG,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              arity
            )
            result.placeholder = curryRight.placeholder
            return result
          }

          /**
           * Creates a debounced function that delays invoking `func` until after `wait`
           * milliseconds have elapsed since the last time the debounced function was
           * invoked. The debounced function comes with a `cancel` method to cancel
           * delayed `func` invocations and a `flush` method to immediately invoke them.
           * Provide `options` to indicate whether `func` should be invoked on the
           * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
           * with the last arguments provided to the debounced function. Subsequent
           * calls to the debounced function return the result of the last `func`
           * invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the debounced function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.debounce` and `_.throttle`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to debounce.
           * @param {number} [wait=0] The number of milliseconds to delay.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=false]
           *  Specify invoking on the leading edge of the timeout.
           * @param {number} [options.maxWait]
           *  The maximum time `func` is allowed to be delayed before it's invoked.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // Avoid costly calculations while the window size is in flux.
           * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
           *
           * // Invoke `sendMail` when clicked, debouncing subsequent calls.
           * jQuery(element).on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * }));
           *
           * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
           * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
           * var source = new EventSource('/stream');
           * jQuery(source).on('message', debounced);
           *
           * // Cancel the trailing debounced invocation.
           * jQuery(window).on('popstate', debounced.cancel);
           */
          function debounce(func, wait, options) {
            var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            wait = toNumber(wait) || 0
            if (isObject(options)) {
              leading = !!options.leading
              maxing = 'maxWait' in options
              maxWait = maxing
                ? nativeMax(toNumber(options.maxWait) || 0, wait)
                : maxWait
              trailing = 'trailing' in options ? !!options.trailing : trailing
            }

            function invokeFunc(time) {
              var args = lastArgs,
                thisArg = lastThis

              lastArgs = lastThis = undefined
              lastInvokeTime = time
              result = func.apply(thisArg, args)
              return result
            }

            function leadingEdge(time) {
              // Reset any `maxWait` timer.
              lastInvokeTime = time
              // Start the timer for the trailing edge.
              timerId = setTimeout(timerExpired, wait)
              // Invoke the leading edge.
              return leading ? invokeFunc(time) : result
            }

            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall

              return maxing
                ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
                : timeWaiting
            }

            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime

              // Either this is the first call, activity has stopped and we're at the
              // trailing edge, the system time has gone backwards and we're treating
              // it as the trailing edge, or we've hit the `maxWait` limit.
              return (
                lastCallTime === undefined ||
                timeSinceLastCall >= wait ||
                timeSinceLastCall < 0 ||
                (maxing && timeSinceLastInvoke >= maxWait)
              )
            }

            function timerExpired() {
              var time = now()
              if (shouldInvoke(time)) {
                return trailingEdge(time)
              }
              // Restart the timer.
              timerId = setTimeout(timerExpired, remainingWait(time))
            }

            function trailingEdge(time) {
              timerId = undefined

              // Only invoke if we have `lastArgs` which means `func` has been
              // debounced at least once.
              if (trailing && lastArgs) {
                return invokeFunc(time)
              }
              lastArgs = lastThis = undefined
              return result
            }

            function cancel() {
              if (timerId !== undefined) {
                clearTimeout(timerId)
              }
              lastInvokeTime = 0
              lastArgs = lastCallTime = lastThis = timerId = undefined
            }

            function flush() {
              return timerId === undefined ? result : trailingEdge(now())
            }

            function debounced() {
              var time = now(),
                isInvoking = shouldInvoke(time)

              lastArgs = arguments
              lastThis = this
              lastCallTime = time

              if (isInvoking) {
                if (timerId === undefined) {
                  return leadingEdge(lastCallTime)
                }
                if (maxing) {
                  // Handle invocations in a tight loop.
                  clearTimeout(timerId)
                  timerId = setTimeout(timerExpired, wait)
                  return invokeFunc(lastCallTime)
                }
              }
              if (timerId === undefined) {
                timerId = setTimeout(timerExpired, wait)
              }
              return result
            }
            debounced.cancel = cancel
            debounced.flush = flush
            return debounced
          }

          /**
           * Defers invoking the `func` until the current call stack has cleared. Any
           * additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to defer.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) {
           *   console.log(text);
           * }, 'deferred');
           * // => Logs 'deferred' after one millisecond.
           */
          var defer = baseRest(function (func, args) {
            return baseDelay(func, 1, args)
          })

          /**
           * Invokes `func` after `wait` milliseconds. Any additional arguments are
           * provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) {
           *   console.log(text);
           * }, 1000, 'later');
           * // => Logs 'later' after one second.
           */
          var delay = baseRest(function (func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args)
          })

          /**
           * Creates a function that invokes `func` with arguments reversed.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to flip arguments for.
           * @returns {Function} Returns the new flipped function.
           * @example
           *
           * var flipped = _.flip(function() {
           *   return _.toArray(arguments);
           * });
           *
           * flipped('a', 'b', 'c', 'd');
           * // => ['d', 'c', 'b', 'a']
           */
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG)
          }

          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided, it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is used as the map cache key. The `func`
           * is invoked with the `this` binding of the memoized function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the
           * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
           * method interface of `clear`, `delete`, `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoized function.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           * var other = { 'c': 3, 'd': 4 };
           *
           * var values = _.memoize(_.values);
           * values(object);
           * // => [1, 2]
           *
           * values(other);
           * // => [3, 4]
           *
           * object.a = 2;
           * values(object);
           * // => [1, 2]
           *
           * // Modify the result cache.
           * values.cache.set(object, ['a', 'b']);
           * values(object);
           * // => ['a', 'b']
           *
           * // Replace `_.memoize.Cache`.
           * _.memoize.Cache = WeakMap;
           */
          function memoize(func, resolver) {
            if (
              typeof func != 'function' ||
              (resolver != null && typeof resolver != 'function')
            ) {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            var memoized = function () {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache

              if (cache.has(key)) {
                return cache.get(key)
              }
              var result = func.apply(this, args)
              memoized.cache = cache.set(key, result) || cache
              return result
            }
            memoized.cache = new (memoize.Cache || MapCache)()
            return memoized
          }

          // Expose `MapCache`.
          memoize.Cache = MapCache

          /**
           * Creates a function that negates the result of the predicate `func`. The
           * `func` predicate is invoked with the `this` binding and arguments of the
           * created function.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} predicate The predicate to negate.
           * @returns {Function} Returns the new negated function.
           * @example
           *
           * function isEven(n) {
           *   return n % 2 == 0;
           * }
           *
           * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
           * // => [1, 3, 5]
           */
          function negate(predicate) {
            if (typeof predicate != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            return function () {
              var args = arguments
              switch (args.length) {
                case 0:
                  return !predicate.call(this)
                case 1:
                  return !predicate.call(this, args[0])
                case 2:
                  return !predicate.call(this, args[0], args[1])
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2])
              }
              return !predicate.apply(this, args)
            }
          }

          /**
           * Creates a function that is restricted to invoking `func` once. Repeat calls
           * to the function return the value of the first invocation. The `func` is
           * invoked with the `this` binding and arguments of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // => `createApplication` is invoked once
           */
          function once(func) {
            return before(2, func)
          }

          /**
           * Creates a function that invokes `func` with its arguments transformed.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Function
           * @param {Function} func The function to wrap.
           * @param {...(Function|Function[])} [transforms=[_.identity]]
           *  The argument transforms.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function doubled(n) {
           *   return n * 2;
           * }
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var func = _.overArgs(function(x, y) {
           *   return [x, y];
           * }, [square, doubled]);
           *
           * func(9, 3);
           * // => [81, 6]
           *
           * func(10, 5);
           * // => [100, 10]
           */
          var overArgs = castRest(function (func, transforms) {
            transforms =
              transforms.length == 1 && isArray(transforms[0])
                ? arrayMap(transforms[0], baseUnary(getIteratee()))
                : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()))

            var funcsLength = transforms.length
            return baseRest(function (args) {
              var index = -1,
                length = nativeMin(args.length, funcsLength)

              while (++index < length) {
                args[index] = transforms[index].call(this, args[index])
              }
              return apply(func, this, args)
            })
          })

          /**
           * Creates a function that invokes `func` with `partials` prepended to the
           * arguments it receives. This method is like `_.bind` except it does **not**
           * alter the `this` binding.
           *
           * The `_.partial.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 0.2.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var sayHelloTo = _.partial(greet, 'hello');
           * sayHelloTo('fred');
           * // => 'hello fred'
           *
           * // Partially applied with placeholders.
           * var greetFred = _.partial(greet, _, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           */
          var partial = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partial))
            return createWrap(
              func,
              WRAP_PARTIAL_FLAG,
              undefined,
              partials,
              holders
            )
          })

          /**
           * This method is like `_.partial` except that partially applied arguments
           * are appended to the arguments it receives.
           *
           * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var greetFred = _.partialRight(greet, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           *
           * // Partially applied with placeholders.
           * var sayHelloTo = _.partialRight(greet, 'hello', _);
           * sayHelloTo('fred');
           * // => 'hello fred'
           */
          var partialRight = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight))
            return createWrap(
              func,
              WRAP_PARTIAL_RIGHT_FLAG,
              undefined,
              partials,
              holders
            )
          })

          /**
           * Creates a function that invokes `func` with arguments arranged according
           * to the specified `indexes` where the argument value at the first index is
           * provided as the first argument, the argument value at the second index is
           * provided as the second argument, and so on.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to rearrange arguments for.
           * @param {...(number|number[])} indexes The arranged argument indexes.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var rearged = _.rearg(function(a, b, c) {
           *   return [a, b, c];
           * }, [2, 0, 1]);
           *
           * rearged('b', 'c', 'a')
           * // => ['a', 'b', 'c']
           */
          var rearg = flatRest(function (func, indexes) {
            return createWrap(
              func,
              WRAP_REARG_FLAG,
              undefined,
              undefined,
              undefined,
              indexes
            )
          })

          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * created function and arguments from `start` and beyond provided as
           * an array.
           *
           * **Note:** This method is based on the
           * [rest parameter](https://mdn.io/rest_parameters).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.rest(function(what, names) {
           *   return what + ' ' + _.initial(names).join(', ') +
           *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
           * });
           *
           * say('hello', 'fred', 'barney', 'pebbles');
           * // => 'hello fred, barney, & pebbles'
           */
          function rest(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            start = start === undefined ? start : toInteger(start)
            return baseRest(func, start)
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * create function and an array of arguments much like
           * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
           *
           * **Note:** This method is based on the
           * [spread operator](https://mdn.io/spread_operator).
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Function
           * @param {Function} func The function to spread arguments over.
           * @param {number} [start=0] The start position of the spread.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.spread(function(who, what) {
           *   return who + ' says ' + what;
           * });
           *
           * say(['fred', 'hello']);
           * // => 'fred says hello'
           *
           * var numbers = Promise.all([
           *   Promise.resolve(40),
           *   Promise.resolve(36)
           * ]);
           *
           * numbers.then(_.spread(function(x, y) {
           *   return x + y;
           * }));
           * // => a Promise of 76
           */
          function spread(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0)
            return baseRest(function (args) {
              var array = args[start],
                otherArgs = castSlice(args, 0, start)

              if (array) {
                arrayPush(otherArgs, array)
              }
              return apply(func, this, otherArgs)
            })
          }

          /**
           * Creates a throttled function that only invokes `func` at most once per
           * every `wait` milliseconds. The throttled function comes with a `cancel`
           * method to cancel delayed `func` invocations and a `flush` method to
           * immediately invoke them. Provide `options` to indicate whether `func`
           * should be invoked on the leading and/or trailing edge of the `wait`
           * timeout. The `func` is invoked with the last arguments provided to the
           * throttled function. Subsequent calls to the throttled function return the
           * result of the last `func` invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the throttled function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.throttle` and `_.debounce`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to throttle.
           * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=true]
           *  Specify invoking on the leading edge of the timeout.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // Avoid excessively updating the position while scrolling.
           * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
           *
           * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
           * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
           * jQuery(element).on('click', throttled);
           *
           * // Cancel the trailing throttled invocation.
           * jQuery(window).on('popstate', throttled.cancel);
           */
          function throttle(func, wait, options) {
            var leading = true,
              trailing = true

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            if (isObject(options)) {
              leading = 'leading' in options ? !!options.leading : leading
              trailing = 'trailing' in options ? !!options.trailing : trailing
            }
            return debounce(func, wait, {
              leading: leading,
              maxWait: wait,
              trailing: trailing
            })
          }

          /**
           * Creates a function that accepts up to one argument, ignoring any
           * additional arguments.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.unary(parseInt));
           * // => [6, 8, 10]
           */
          function unary(func) {
            return ary(func, 1)
          }

          /**
           * Creates a function that provides `value` to `wrapper` as its first
           * argument. Any additional arguments provided to the function are appended
           * to those provided to the `wrapper`. The wrapper is invoked with the `this`
           * binding of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {*} value The value to wrap.
           * @param {Function} [wrapper=identity] The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('fred, barney, & pebbles');
           * // => '<p>fred, barney, &amp; pebbles</p>'
           */
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value)
          }

          /*------------------------------------------------------------------------*/

          /**
           * Casts `value` as an array if it's not one.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Lang
           * @param {*} value The value to inspect.
           * @returns {Array} Returns the cast array.
           * @example
           *
           * _.castArray(1);
           * // => [1]
           *
           * _.castArray({ 'a': 1 });
           * // => [{ 'a': 1 }]
           *
           * _.castArray('abc');
           * // => ['abc']
           *
           * _.castArray(null);
           * // => [null]
           *
           * _.castArray(undefined);
           * // => [undefined]
           *
           * _.castArray();
           * // => []
           *
           * var array = [1, 2, 3];
           * console.log(_.castArray(array) === array);
           * // => true
           */
          function castArray() {
            if (!arguments.length) {
              return []
            }
            var value = arguments[0]
            return isArray(value) ? value : [value]
          }

          /**
           * Creates a shallow clone of `value`.
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
           * and supports cloning arrays, array buffers, booleans, date objects, maps,
           * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
           * arrays. The own enumerable properties of `arguments` objects are cloned
           * as plain objects. An empty object is returned for uncloneable values such
           * as error objects, functions, DOM nodes, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to clone.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeep
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var shallow = _.clone(objects);
           * console.log(shallow[0] === objects[0]);
           * // => true
           */
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG)
          }

          /**
           * This method is like `_.clone` except that it accepts `customizer` which
           * is invoked to produce the cloned value. If `customizer` returns `undefined`,
           * cloning is handled by the method instead. The `customizer` is invoked with
           * up to four arguments; (value [, index|key, object, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeepWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(false);
           *   }
           * }
           *
           * var el = _.cloneWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 0
           */
          function cloneWith(value, customizer) {
            customizer =
              typeof customizer == 'function' ? customizer : undefined
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer)
          }

          /**
           * This method is like `_.clone` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @returns {*} Returns the deep cloned value.
           * @see _.clone
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var deep = _.cloneDeep(objects);
           * console.log(deep[0] === objects[0]);
           * // => false
           */
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
          }

          /**
           * This method is like `_.cloneWith` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the deep cloned value.
           * @see _.cloneWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(true);
           *   }
           * }
           *
           * var el = _.cloneDeepWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 20
           */
          function cloneDeepWith(value, customizer) {
            customizer =
              typeof customizer == 'function' ? customizer : undefined
            return baseClone(
              value,
              CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG,
              customizer
            )
          }

          /**
           * Checks if `object` conforms to `source` by invoking the predicate
           * properties of `source` with the corresponding property values of `object`.
           *
           * **Note:** This method is equivalent to `_.conforms` when `source` is
           * partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
           * // => true
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
           * // => false
           */
          function conformsTo(object, source) {
            return (
              source == null || baseConformsTo(object, source, keys(source))
            )
          }

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || (value !== value && other !== other)
          }

          /**
           * Checks if `value` is greater than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           * @see _.lt
           * @example
           *
           * _.gt(3, 1);
           * // => true
           *
           * _.gt(3, 3);
           * // => false
           *
           * _.gt(1, 3);
           * // => false
           */
          var gt = createRelationalOperation(baseGt)

          /**
           * Checks if `value` is greater than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than or equal to
           *  `other`, else `false`.
           * @see _.lte
           * @example
           *
           * _.gte(3, 1);
           * // => true
           *
           * _.gte(3, 3);
           * // => true
           *
           * _.gte(1, 3);
           * // => false
           */
          var gte = createRelationalOperation(function (value, other) {
            return value >= other
          })

          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          var isArguments = baseIsArguments(
            (function () {
              return arguments
            })()
          )
            ? baseIsArguments
            : function (value) {
                return (
                  isObjectLike(value) &&
                  hasOwnProperty.call(value, 'callee') &&
                  !propertyIsEnumerable.call(value, 'callee')
                )
              }

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray

          /**
           * Checks if `value` is classified as an `ArrayBuffer` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           * @example
           *
           * _.isArrayBuffer(new ArrayBuffer(2));
           * // => true
           *
           * _.isArrayBuffer(new Array(2));
           * // => false
           */
          var isArrayBuffer = nodeIsArrayBuffer
            ? baseUnary(nodeIsArrayBuffer)
            : baseIsArrayBuffer

          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value)
          }

          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value)
          }

          /**
           * Checks if `value` is classified as a boolean primitive or object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
           * @example
           *
           * _.isBoolean(false);
           * // => true
           *
           * _.isBoolean(null);
           * // => false
           */
          function isBoolean(value) {
            return (
              value === true ||
              value === false ||
              (isObjectLike(value) && baseGetTag(value) == boolTag)
            )
          }

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse

          /**
           * Checks if `value` is classified as a `Date` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           *
           * _.isDate('Mon April 23 2012');
           * // => false
           */
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate

          /**
           * Checks if `value` is likely a DOM element.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           *
           * _.isElement('<body>');
           * // => false
           */
          function isElement(value) {
            return (
              isObjectLike(value) &&
              value.nodeType === 1 &&
              !isPlainObject(value)
            )
          }

          /**
           * Checks if `value` is an empty object, collection, map, or set.
           *
           * Objects are considered empty if they have no own enumerable string keyed
           * properties.
           *
           * Array-like values such as `arguments` objects, arrays, buffers, strings, or
           * jQuery-like collections are considered empty if they have a `length` of `0`.
           * Similarly, maps and sets are considered empty if they have a `size` of `0`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty(null);
           * // => true
           *
           * _.isEmpty(true);
           * // => true
           *
           * _.isEmpty(1);
           * // => true
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({ 'a': 1 });
           * // => false
           */
          function isEmpty(value) {
            if (value == null) {
              return true
            }
            if (
              isArrayLike(value) &&
              (isArray(value) ||
                typeof value == 'string' ||
                typeof value.splice == 'function' ||
                isBuffer(value) ||
                isTypedArray(value) ||
                isArguments(value))
            ) {
              return !value.length
            }
            var tag = getTag(value)
            if (tag == mapTag || tag == setTag) {
              return !value.size
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false
              }
            }
            return true
          }

          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent.
           *
           * **Note:** This method supports comparing arrays, array buffers, booleans,
           * date objects, error objects, maps, numbers, `Object` objects, regexes,
           * sets, strings, symbols, and typed arrays. `Object` objects are compared
           * by their own, not inherited, enumerable properties. Functions and DOM
           * nodes are compared by strict equality, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.isEqual(object, other);
           * // => true
           *
           * object === other;
           * // => false
           */
          function isEqual(value, other) {
            return baseIsEqual(value, other)
          }

          /**
           * This method is like `_.isEqual` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with up to
           * six arguments: (objValue, othValue [, index|key, object, other, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, othValue) {
           *   if (isGreeting(objValue) && isGreeting(othValue)) {
           *     return true;
           *   }
           * }
           *
           * var array = ['hello', 'goodbye'];
           * var other = ['hi', 'goodbye'];
           *
           * _.isEqualWith(array, other, customizer);
           * // => true
           */
          function isEqualWith(value, other, customizer) {
            customizer =
              typeof customizer == 'function' ? customizer : undefined
            var result = customizer ? customizer(value, other) : undefined
            return result === undefined
              ? baseIsEqual(value, other, undefined, customizer)
              : !!result
          }

          /**
           * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
           * `SyntaxError`, `TypeError`, or `URIError` object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
           * @example
           *
           * _.isError(new Error);
           * // => true
           *
           * _.isError(Error);
           * // => false
           */
          function isError(value) {
            if (!isObjectLike(value)) {
              return false
            }
            var tag = baseGetTag(value)
            return (
              tag == errorTag ||
              tag == domExcTag ||
              (typeof value.message == 'string' &&
                typeof value.name == 'string' &&
                !isPlainObject(value))
            )
          }

          /**
           * Checks if `value` is a finite primitive number.
           *
           * **Note:** This method is based on
           * [`Number.isFinite`](https://mdn.io/Number/isFinite).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
           * @example
           *
           * _.isFinite(3);
           * // => true
           *
           * _.isFinite(Number.MIN_VALUE);
           * // => true
           *
           * _.isFinite(Infinity);
           * // => false
           *
           * _.isFinite('3');
           * // => false
           */
          function isFinite(value) {
            return typeof value == 'number' && nativeIsFinite(value)
          }

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            if (!isObject(value)) {
              return false
            }
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value)
            return (
              tag == funcTag ||
              tag == genTag ||
              tag == asyncTag ||
              tag == proxyTag
            )
          }

          /**
           * Checks if `value` is an integer.
           *
           * **Note:** This method is based on
           * [`Number.isInteger`](https://mdn.io/Number/isInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
           * @example
           *
           * _.isInteger(3);
           * // => true
           *
           * _.isInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isInteger(Infinity);
           * // => false
           *
           * _.isInteger('3');
           * // => false
           */
          function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value)
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */
          function isLength(value) {
            return (
              typeof value == 'number' &&
              value > -1 &&
              value % 1 == 0 &&
              value <= MAX_SAFE_INTEGER
            )
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = typeof value
            return value != null && (type == 'object' || type == 'function')
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return value != null && typeof value == 'object'
          }

          /**
           * Checks if `value` is classified as a `Map` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           * @example
           *
           * _.isMap(new Map);
           * // => true
           *
           * _.isMap(new WeakMap);
           * // => false
           */
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap

          /**
           * Performs a partial deep comparison between `object` and `source` to
           * determine if `object` contains equivalent property values.
           *
           * **Note:** This method is equivalent to `_.matches` when `source` is
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.isMatch(object, { 'b': 2 });
           * // => true
           *
           * _.isMatch(object, { 'b': 1 });
           * // => false
           */
          function isMatch(object, source) {
            return (
              object === source ||
              baseIsMatch(object, source, getMatchData(source))
            )
          }

          /**
           * This method is like `_.isMatch` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with five
           * arguments: (objValue, srcValue, index|key, object, source).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, srcValue) {
           *   if (isGreeting(objValue) && isGreeting(srcValue)) {
           *     return true;
           *   }
           * }
           *
           * var object = { 'greeting': 'hello' };
           * var source = { 'greeting': 'hi' };
           *
           * _.isMatchWith(object, source, customizer);
           * // => true
           */
          function isMatchWith(object, source, customizer) {
            customizer =
              typeof customizer == 'function' ? customizer : undefined
            return baseIsMatch(object, source, getMatchData(source), customizer)
          }

          /**
           * Checks if `value` is `NaN`.
           *
           * **Note:** This method is based on
           * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
           * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
           * `undefined` and other non-number values.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */
          function isNaN(value) {
            // An `NaN` primitive is the only value that is not equal to itself.
            // Perform the `toStringTag` check first to avoid errors with some
            // ActiveX objects in IE.
            return isNumber(value) && value != +value
          }

          /**
           * Checks if `value` is a pristine native function.
           *
           * **Note:** This method can't reliably detect native functions in the presence
           * of the core-js package because core-js circumvents this kind of detection.
           * Despite multiple requests, the core-js maintainer has made it clear: any
           * attempt to fix the detection will be obstructed. As a result, we're left
           * with little choice but to throw an error. Unfortunately, this also affects
           * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
           * which rely on core-js.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           * @example
           *
           * _.isNative(Array.prototype.push);
           * // => true
           *
           * _.isNative(_);
           * // => false
           */
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error(CORE_ERROR_TEXT)
            }
            return baseIsNative(value)
          }

          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(void 0);
           * // => false
           */
          function isNull(value) {
            return value === null
          }

          /**
           * Checks if `value` is `null` or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
           * @example
           *
           * _.isNil(null);
           * // => true
           *
           * _.isNil(void 0);
           * // => true
           *
           * _.isNil(NaN);
           * // => false
           */
          function isNil(value) {
            return value == null
          }

          /**
           * Checks if `value` is classified as a `Number` primitive or object.
           *
           * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
           * classified as numbers, use the `_.isFinite` method.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a number, else `false`.
           * @example
           *
           * _.isNumber(3);
           * // => true
           *
           * _.isNumber(Number.MIN_VALUE);
           * // => true
           *
           * _.isNumber(Infinity);
           * // => true
           *
           * _.isNumber('3');
           * // => false
           */
          function isNumber(value) {
            return (
              typeof value == 'number' ||
              (isObjectLike(value) && baseGetTag(value) == numberTag)
            )
          }

          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * @static
           * @memberOf _
           * @since 0.8.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false
            }
            var proto = getPrototype(value)
            if (proto === null) {
              return true
            }
            var Ctor =
              hasOwnProperty.call(proto, 'constructor') && proto.constructor
            return (
              typeof Ctor == 'function' &&
              Ctor instanceof Ctor &&
              funcToString.call(Ctor) == objectCtorString
            )
          }

          /**
           * Checks if `value` is classified as a `RegExp` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           * @example
           *
           * _.isRegExp(/abc/);
           * // => true
           *
           * _.isRegExp('/abc/');
           * // => false
           */
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp

          /**
           * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
           * double precision number which isn't the result of a rounded unsafe integer.
           *
           * **Note:** This method is based on
           * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
           * @example
           *
           * _.isSafeInteger(3);
           * // => true
           *
           * _.isSafeInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isSafeInteger(Infinity);
           * // => false
           *
           * _.isSafeInteger('3');
           * // => false
           */
          function isSafeInteger(value) {
            return (
              isInteger(value) &&
              value >= -MAX_SAFE_INTEGER &&
              value <= MAX_SAFE_INTEGER
            )
          }

          /**
           * Checks if `value` is classified as a `Set` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           * @example
           *
           * _.isSet(new Set);
           * // => true
           *
           * _.isSet(new WeakSet);
           * // => false
           */
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet

          /**
           * Checks if `value` is classified as a `String` primitive or object.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a string, else `false`.
           * @example
           *
           * _.isString('abc');
           * // => true
           *
           * _.isString(1);
           * // => false
           */
          function isString(value) {
            return (
              typeof value == 'string' ||
              (!isArray(value) &&
                isObjectLike(value) &&
                baseGetTag(value) == stringTag)
            )
          }

          /**
           * Checks if `value` is classified as a `Symbol` primitive or object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
           * @example
           *
           * _.isSymbol(Symbol.iterator);
           * // => true
           *
           * _.isSymbol('abc');
           * // => false
           */
          function isSymbol(value) {
            return (
              typeof value == 'symbol' ||
              (isObjectLike(value) && baseGetTag(value) == symbolTag)
            )
          }

          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */
          var isTypedArray = nodeIsTypedArray
            ? baseUnary(nodeIsTypedArray)
            : baseIsTypedArray

          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           *
           * _.isUndefined(null);
           * // => false
           */
          function isUndefined(value) {
            return value === undefined
          }

          /**
           * Checks if `value` is classified as a `WeakMap` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
           * @example
           *
           * _.isWeakMap(new WeakMap);
           * // => true
           *
           * _.isWeakMap(new Map);
           * // => false
           */
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag
          }

          /**
           * Checks if `value` is classified as a `WeakSet` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
           * @example
           *
           * _.isWeakSet(new WeakSet);
           * // => true
           *
           * _.isWeakSet(new Set);
           * // => false
           */
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag
          }

          /**
           * Checks if `value` is less than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           * @see _.gt
           * @example
           *
           * _.lt(1, 3);
           * // => true
           *
           * _.lt(3, 3);
           * // => false
           *
           * _.lt(3, 1);
           * // => false
           */
          var lt = createRelationalOperation(baseLt)

          /**
           * Checks if `value` is less than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than or equal to
           *  `other`, else `false`.
           * @see _.gte
           * @example
           *
           * _.lte(1, 3);
           * // => true
           *
           * _.lte(3, 3);
           * // => true
           *
           * _.lte(3, 1);
           * // => false
           */
          var lte = createRelationalOperation(function (value, other) {
            return value <= other
          })

          /**
           * Converts `value` to an array.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Array} Returns the converted array.
           * @example
           *
           * _.toArray({ 'a': 1, 'b': 2 });
           * // => [1, 2]
           *
           * _.toArray('abc');
           * // => ['a', 'b', 'c']
           *
           * _.toArray(1);
           * // => []
           *
           * _.toArray(null);
           * // => []
           */
          function toArray(value) {
            if (!value) {
              return []
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value)
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]())
            }
            var tag = getTag(value),
              func =
                tag == mapTag ? mapToArray : tag == setTag ? setToArray : values

            return func(value)
          }

          /**
           * Converts `value` to a finite number.
           *
           * @static
           * @memberOf _
           * @since 4.12.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted number.
           * @example
           *
           * _.toFinite(3.2);
           * // => 3.2
           *
           * _.toFinite(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toFinite(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toFinite('3.2');
           * // => 3.2
           */
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0
            }
            value = toNumber(value)
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1
              return sign * MAX_INTEGER
            }
            return value === value ? value : 0
          }

          /**
           * Converts `value` to an integer.
           *
           * **Note:** This method is loosely based on
           * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toInteger(3.2);
           * // => 3
           *
           * _.toInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toInteger(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toInteger('3.2');
           * // => 3
           */
          function toInteger(value) {
            var result = toFinite(value),
              remainder = result % 1

            return result === result
              ? remainder
                ? result - remainder
                : result
              : 0
          }

          /**
           * Converts `value` to an integer suitable for use as the length of an
           * array-like object.
           *
           * **Note:** This method is based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toLength(3.2);
           * // => 3
           *
           * _.toLength(Number.MIN_VALUE);
           * // => 0
           *
           * _.toLength(Infinity);
           * // => 4294967295
           *
           * _.toLength('3.2');
           * // => 3
           */
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
          }

          /**
           * Converts `value` to a number.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           * @example
           *
           * _.toNumber(3.2);
           * // => 3.2
           *
           * _.toNumber(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toNumber(Infinity);
           * // => Infinity
           *
           * _.toNumber('3.2');
           * // => 3.2
           */
          function toNumber(value) {
            if (typeof value == 'number') {
              return value
            }
            if (isSymbol(value)) {
              return NAN
            }
            if (isObject(value)) {
              var other =
                typeof value.valueOf == 'function' ? value.valueOf() : value
              value = isObject(other) ? other + '' : other
            }
            if (typeof value != 'string') {
              return value === 0 ? value : +value
            }
            value = baseTrim(value)
            var isBinary = reIsBinary.test(value)
            return isBinary || reIsOctal.test(value)
              ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
              : reIsBadHex.test(value)
              ? NAN
              : +value
          }

          /**
           * Converts `value` to a plain object flattening inherited enumerable string
           * keyed properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */
          function toPlainObject(value) {
            return copyObject(value, keysIn(value))
          }

          /**
           * Converts `value` to a safe integer. A safe integer can be compared and
           * represented correctly.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toSafeInteger(3.2);
           * // => 3
           *
           * _.toSafeInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toSafeInteger(Infinity);
           * // => 9007199254740991
           *
           * _.toSafeInteger('3.2');
           * // => 3
           */
          function toSafeInteger(value) {
            return value
              ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
              : value === 0
              ? value
              : 0
          }

          /**
           * Converts `value` to a string. An empty string is returned for `null`
           * and `undefined` values. The sign of `-0` is preserved.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.toString(null);
           * // => ''
           *
           * _.toString(-0);
           * // => '-0'
           *
           * _.toString([1, 2, 3]);
           * // => '1,2,3'
           */
          function toString(value) {
            return value == null ? '' : baseToString(value)
          }

          /*------------------------------------------------------------------------*/

          /**
           * Assigns own enumerable string keyed properties of source objects to the
           * destination object. Source objects are applied from left to right.
           * Subsequent sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object` and is loosely based on
           * [`Object.assign`](https://mdn.io/Object/assign).
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assignIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assign({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'c': 3 }
           */
          var assign = createAssigner(function (object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object)
              return
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key])
              }
            }
          })

          /**
           * This method is like `_.assign` except that it iterates over own and
           * inherited source properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extend
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assign
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assignIn({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
           */
          var assignIn = createAssigner(function (object, source) {
            copyObject(source, keysIn(source), object)
          })

          /**
           * This method is like `_.assignIn` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extendWith
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignInWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */
          var assignInWith = createAssigner(function (
            object,
            source,
            srcIndex,
            customizer
          ) {
            copyObject(source, keysIn(source), object, customizer)
          })

          /**
           * This method is like `_.assign` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignInWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */
          var assignWith = createAssigner(function (
            object,
            source,
            srcIndex,
            customizer
          ) {
            copyObject(source, keys(source), object, customizer)
          })

          /**
           * Creates an array of values corresponding to `paths` of `object`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Array} Returns the picked values.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _.at(object, ['a[0].b.c', 'a[1]']);
           * // => [3, 4]
           */
          var at = flatRest(baseAt)

          /**
           * Creates an object that inherits from the `prototype` object. If a
           * `properties` object is given, its own enumerable string keyed properties
           * are assigned to the created object.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Object
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, {
           *   'constructor': Circle
           * });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */
          function create(prototype, properties) {
            var result = baseCreate(prototype)
            return properties == null ? result : baseAssign(result, properties)
          }

          /**
           * Assigns own and inherited enumerable string keyed properties of source
           * objects to the destination object for all destination properties that
           * resolve to `undefined`. Source objects are applied from left to right.
           * Once a property is set, additional values of the same property are ignored.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaultsDeep
           * @example
           *
           * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */
          var defaults = baseRest(function (object, sources) {
            object = Object(object)

            var index = -1
            var length = sources.length
            var guard = length > 2 ? sources[2] : undefined

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1
            }

            while (++index < length) {
              var source = sources[index]
              var props = keysIn(source)
              var propsIndex = -1
              var propsLength = props.length

              while (++propsIndex < propsLength) {
                var key = props[propsIndex]
                var value = object[key]

                if (
                  value === undefined ||
                  (eq(value, objectProto[key]) &&
                    !hasOwnProperty.call(object, key))
                ) {
                  object[key] = source[key]
                }
              }
            }

            return object
          })

          /**
           * This method is like `_.defaults` except that it recursively assigns
           * default properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaults
           * @example
           *
           * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
           * // => { 'a': { 'b': 2, 'c': 3 } }
           */
          var defaultsDeep = baseRest(function (args) {
            args.push(undefined, customDefaultsMerge)
            return apply(mergeWith, undefined, args)
          })

          /**
           * This method is like `_.find` except that it returns the key of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findKey(users, function(o) { return o.age < 40; });
           * // => 'barney' (iteration order is not guaranteed)
           *
           * // The `_.matches` iteratee shorthand.
           * _.findKey(users, { 'age': 1, 'active': true });
           * // => 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findKey(users, 'active');
           * // => 'barney'
           */
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
          }

          /**
           * This method is like `_.findKey` except that it iterates over elements of
           * a collection in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findLastKey(users, function(o) { return o.age < 40; });
           * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastKey(users, { 'age': 36, 'active': true });
           * // => 'barney'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastKey(users, 'active');
           * // => 'pebbles'
           */
          function findLastKey(object, predicate) {
            return baseFindKey(
              object,
              getIteratee(predicate, 3),
              baseForOwnRight
            )
          }

          /**
           * Iterates over own and inherited enumerable string keyed properties of an
           * object and invokes `iteratee` for each property. The iteratee is invoked
           * with three arguments: (value, key, object). Iteratee functions may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forInRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forIn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
           */
          function forIn(object, iteratee) {
            return object == null
              ? object
              : baseFor(object, getIteratee(iteratee, 3), keysIn)
          }

          /**
           * This method is like `_.forIn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forInRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
           */
          function forInRight(object, iteratee) {
            return object == null
              ? object
              : baseForRight(object, getIteratee(iteratee, 3), keysIn)
          }

          /**
           * Iterates over own enumerable string keyed properties of an object and
           * invokes `iteratee` for each property. The iteratee is invoked with three
           * arguments: (value, key, object). Iteratee functions may exit iteration
           * early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwnRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */
          function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3))
          }

          /**
           * This method is like `_.forOwn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwnRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
           */
          function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3))
          }

          /**
           * Creates an array of function property names from own enumerable properties
           * of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functionsIn
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functions(new Foo);
           * // => ['a', 'b']
           */
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object))
          }

          /**
           * Creates an array of function property names from own and inherited
           * enumerable properties of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functions
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functionsIn(new Foo);
           * // => ['a', 'b', 'c']
           */
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object))
          }

          /**
           * Gets the value at `path` of `object`. If the resolved value is
           * `undefined`, the `defaultValue` is returned in its place.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.get(object, 'a[0].b.c');
           * // => 3
           *
           * _.get(object, ['a', '0', 'b', 'c']);
           * // => 3
           *
           * _.get(object, 'a.b.c', 'default');
           * // => 'default'
           */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path)
            return result === undefined ? defaultValue : result
          }

          /**
           * Checks if `path` is a direct property of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = { 'a': { 'b': 2 } };
           * var other = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.has(object, 'a');
           * // => true
           *
           * _.has(object, 'a.b');
           * // => true
           *
           * _.has(object, ['a', 'b']);
           * // => true
           *
           * _.has(other, 'a');
           * // => false
           */
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas)
          }

          /**
           * Checks if `path` is a direct or inherited property of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.hasIn(object, 'a');
           * // => true
           *
           * _.hasIn(object, 'a.b');
           * // => true
           *
           * _.hasIn(object, ['a', 'b']);
           * // => true
           *
           * _.hasIn(object, 'b');
           * // => false
           */
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn)
          }

          /**
           * Creates an object composed of the inverted keys and values of `object`.
           * If `object` contains duplicate values, subsequent values overwrite
           * property assignments of previous values.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Object
           * @param {Object} object The object to invert.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invert(object);
           * // => { '1': 'c', '2': 'b' }
           */
          var invert = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value)
            }

            result[value] = key
          }, constant(identity))

          /**
           * This method is like `_.invert` except that the inverted object is generated
           * from the results of running each element of `object` thru `iteratee`. The
           * corresponding inverted value of each inverted key is an array of keys
           * responsible for generating the inverted value. The iteratee is invoked
           * with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Object
           * @param {Object} object The object to invert.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invertBy(object);
           * // => { '1': ['a', 'c'], '2': ['b'] }
           *
           * _.invertBy(object, function(value) {
           *   return 'group' + value;
           * });
           * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
           */
          var invertBy = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value)
            }

            if (hasOwnProperty.call(result, value)) {
              result[value].push(key)
            } else {
              result[value] = [key]
            }
          }, getIteratee)

          /**
           * Invokes the method at `path` of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
           *
           * _.invoke(object, 'a[0].b.c.slice', 1, 3);
           * // => [2, 3]
           */
          var invoke = baseRest(baseInvoke)

          /**
           * Creates an array of the own enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects. See the
           * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * for more details.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keys(new Foo);
           * // => ['a', 'b'] (iteration order is not guaranteed)
           *
           * _.keys('hi');
           * // => ['0', '1']
           */
          function keys(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object)
              : baseKeys(object)
          }

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object, true)
              : baseKeysIn(object)
          }

          /**
           * The opposite of `_.mapValues`; this method creates an object with the
           * same values as `object` and keys generated by running each own enumerable
           * string keyed property of `object` thru `iteratee`. The iteratee is invoked
           * with three arguments: (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapValues
           * @example
           *
           * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
           *   return key + value;
           * });
           * // => { 'a1': 1, 'b2': 2 }
           */
          function mapKeys(object, iteratee) {
            var result = {}
            iteratee = getIteratee(iteratee, 3)

            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, iteratee(value, key, object), value)
            })
            return result
          }

          /**
           * Creates an object with the same keys as `object` and values generated
           * by running each own enumerable string keyed property of `object` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapKeys
           * @example
           *
           * var users = {
           *   'fred':    { 'user': 'fred',    'age': 40 },
           *   'pebbles': { 'user': 'pebbles', 'age': 1 }
           * };
           *
           * _.mapValues(users, function(o) { return o.age; });
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           *
           * // The `_.property` iteratee shorthand.
           * _.mapValues(users, 'age');
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           */
          function mapValues(object, iteratee) {
            var result = {}
            iteratee = getIteratee(iteratee, 3)

            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, key, iteratee(value, key, object))
            })
            return result
          }

          /**
           * This method is like `_.assign` except that it recursively merges own and
           * inherited enumerable string keyed properties of source objects into the
           * destination object. Source properties that resolve to `undefined` are
           * skipped if a destination value exists. Array and plain object properties
           * are merged recursively. Other objects and value types are overridden by
           * assignment. Source objects are applied from left to right. Subsequent
           * sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {
           *   'a': [{ 'b': 2 }, { 'd': 4 }]
           * };
           *
           * var other = {
           *   'a': [{ 'c': 3 }, { 'e': 5 }]
           * };
           *
           * _.merge(object, other);
           * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
           */
          var merge = createAssigner(function (object, source, srcIndex) {
            baseMerge(object, source, srcIndex)
          })

          /**
           * This method is like `_.merge` except that it accepts `customizer` which
           * is invoked to produce the merged values of the destination and source
           * properties. If `customizer` returns `undefined`, merging is handled by the
           * method instead. The `customizer` is invoked with six arguments:
           * (objValue, srcValue, key, object, source, stack).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   if (_.isArray(objValue)) {
           *     return objValue.concat(srcValue);
           *   }
           * }
           *
           * var object = { 'a': [1], 'b': [2] };
           * var other = { 'a': [3], 'b': [4] };
           *
           * _.mergeWith(object, other, customizer);
           * // => { 'a': [1, 3], 'b': [2, 4] }
           */
          var mergeWith = createAssigner(function (
            object,
            source,
            srcIndex,
            customizer
          ) {
            baseMerge(object, source, srcIndex, customizer)
          })

          /**
           * The opposite of `_.pick`; this method creates an object composed of the
           * own and inherited enumerable property paths of `object` that are not omitted.
           *
           * **Note:** This method is considerably slower than `_.pick`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to omit.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omit(object, ['a', 'c']);
           * // => { 'b': '2' }
           */
          var omit = flatRest(function (object, paths) {
            var result = {}
            if (object == null) {
              return result
            }
            var isDeep = false
            paths = arrayMap(paths, function (path) {
              path = castPath(path, object)
              isDeep || (isDeep = path.length > 1)
              return path
            })
            copyObject(object, getAllKeysIn(object), result)
            if (isDeep) {
              result = baseClone(
                result,
                CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG,
                customOmitClone
              )
            }
            var length = paths.length
            while (length--) {
              baseUnset(result, paths[length])
            }
            return result
          })

          /**
           * The opposite of `_.pickBy`; this method creates an object composed of
           * the own and inherited enumerable string keyed properties of `object` that
           * `predicate` doesn't return truthy for. The predicate is invoked with two
           * arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omitBy(object, _.isNumber);
           * // => { 'b': '2' }
           */
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)))
          }

          /**
           * Creates an object composed of the picked `object` properties.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pick(object, ['a', 'c']);
           * // => { 'a': 1, 'c': 3 }
           */
          var pick = flatRest(function (object, paths) {
            return object == null ? {} : basePick(object, paths)
          })

          /**
           * Creates an object composed of the `object` properties `predicate` returns
           * truthy for. The predicate is invoked with two arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pickBy(object, _.isNumber);
           * // => { 'a': 1, 'c': 3 }
           */
          function pickBy(object, predicate) {
            if (object == null) {
              return {}
            }
            var props = arrayMap(getAllKeysIn(object), function (prop) {
              return [prop]
            })
            predicate = getIteratee(predicate)
            return basePickBy(object, props, function (value, path) {
              return predicate(value, path[0])
            })
          }

          /**
           * This method is like `_.get` except that if the resolved value is a
           * function it's invoked with the `this` binding of its parent object and
           * its result is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to resolve.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
           *
           * _.result(object, 'a[0].b.c1');
           * // => 3
           *
           * _.result(object, 'a[0].b.c2');
           * // => 4
           *
           * _.result(object, 'a[0].b.c3', 'default');
           * // => 'default'
           *
           * _.result(object, 'a[0].b.c3', _.constant('default'));
           * // => 'default'
           */
          function result(object, path, defaultValue) {
            path = castPath(path, object)

            var index = -1,
              length = path.length

            // Ensure the loop is entered when path is empty.
            if (!length) {
              length = 1
              object = undefined
            }
            while (++index < length) {
              var value =
                object == null ? undefined : object[toKey(path[index])]
              if (value === undefined) {
                index = length
                value = defaultValue
              }
              object = isFunction(value) ? value.call(object) : value
            }
            return object
          }

          /**
           * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
           * it's created. Arrays are created for missing index properties while objects
           * are created for all other missing properties. Use `_.setWith` to customize
           * `path` creation.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.set(object, 'a[0].b.c', 4);
           * console.log(object.a[0].b.c);
           * // => 4
           *
           * _.set(object, ['x', '0', 'y', 'z'], 5);
           * console.log(object.x[0].y.z);
           * // => 5
           */
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value)
          }

          /**
           * This method is like `_.set` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.setWith(object, '[0][1]', 'a', Object);
           * // => { '0': { '1': 'a' } }
           */
          function setWith(object, path, value, customizer) {
            customizer =
              typeof customizer == 'function' ? customizer : undefined
            return object == null
              ? object
              : baseSet(object, path, value, customizer)
          }

          /**
           * Creates an array of own enumerable string keyed-value pairs for `object`
           * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
           * entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entries
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairs(new Foo);
           * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
           */
          var toPairs = createToPairs(keys)

          /**
           * Creates an array of own and inherited enumerable string keyed-value pairs
           * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
           * or set, its entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entriesIn
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairsIn(new Foo);
           * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
           */
          var toPairsIn = createToPairs(keysIn)

          /**
           * An alternative to `_.reduce`; this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own
           * enumerable string keyed properties thru `iteratee`, with each invocation
           * potentially mutating the `accumulator` object. If `accumulator` is not
           * provided, a new object with the same `[[Prototype]]` will be used. The
           * iteratee is invoked with four arguments: (accumulator, value, key, object).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.transform([2, 3, 4], function(result, n) {
           *   result.push(n *= n);
           *   return n % 2 == 0;
           * }, []);
           * // => [4, 9]
           *
           * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] }
           */
          function transform(object, iteratee, accumulator) {
            var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object)

            iteratee = getIteratee(iteratee, 4)
            if (accumulator == null) {
              var Ctor = object && object.constructor
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : []
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor)
                  ? baseCreate(getPrototype(object))
                  : {}
              } else {
                accumulator = {}
              }
            }
            ;(isArrLike ? arrayEach : baseForOwn)(
              object,
              function (value, index, object) {
                return iteratee(accumulator, value, index, object)
              }
            )
            return accumulator
          }

          /**
           * Removes the property at `path` of `object`.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 7 } }] };
           * _.unset(object, 'a[0].b.c');
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           *
           * _.unset(object, ['a', '0', 'b', 'c']);
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           */
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path)
          }

          /**
           * This method is like `_.set` except that accepts `updater` to produce the
           * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
           * is invoked with one argument: (value).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.update(object, 'a[0].b.c', function(n) { return n * n; });
           * console.log(object.a[0].b.c);
           * // => 9
           *
           * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
           * console.log(object.x[0].y.z);
           * // => 0
           */
          function update(object, path, updater) {
            return object == null
              ? object
              : baseUpdate(object, path, castFunction(updater))
          }

          /**
           * This method is like `_.update` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.updateWith(object, '[0][1]', _.constant('a'), Object);
           * // => { '0': { '1': 'a' } }
           */
          function updateWith(object, path, updater, customizer) {
            customizer =
              typeof customizer == 'function' ? customizer : undefined
            return object == null
              ? object
              : baseUpdate(object, path, castFunction(updater), customizer)
          }

          /**
           * Creates an array of the own enumerable string keyed property values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.values(new Foo);
           * // => [1, 2] (iteration order is not guaranteed)
           *
           * _.values('hi');
           * // => ['h', 'i']
           */
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object))
          }

          /**
           * Creates an array of the own and inherited enumerable string keyed property
           * values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.valuesIn(new Foo);
           * // => [1, 2, 3] (iteration order is not guaranteed)
           */
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object))
          }

          /*------------------------------------------------------------------------*/

          /**
           * Clamps `number` within the inclusive `lower` and `upper` bounds.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Number
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           * @example
           *
           * _.clamp(-10, -5, 5);
           * // => -5
           *
           * _.clamp(10, -5, 5);
           * // => 5
           */
          function clamp(number, lower, upper) {
            if (upper === undefined) {
              upper = lower
              lower = undefined
            }
            if (upper !== undefined) {
              upper = toNumber(upper)
              upper = upper === upper ? upper : 0
            }
            if (lower !== undefined) {
              lower = toNumber(lower)
              lower = lower === lower ? lower : 0
            }
            return baseClamp(toNumber(number), lower, upper)
          }

          /**
           * Checks if `n` is between `start` and up to, but not including, `end`. If
           * `end` is not specified, it's set to `start` with `start` then set to `0`.
           * If `start` is greater than `end` the params are swapped to support
           * negative ranges.
           *
           * @static
           * @memberOf _
           * @since 3.3.0
           * @category Number
           * @param {number} number The number to check.
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           * @see _.range, _.rangeRight
           * @example
           *
           * _.inRange(3, 2, 4);
           * // => true
           *
           * _.inRange(4, 8);
           * // => true
           *
           * _.inRange(4, 2);
           * // => false
           *
           * _.inRange(2, 2);
           * // => false
           *
           * _.inRange(1.2, 2);
           * // => true
           *
           * _.inRange(5.2, 4);
           * // => false
           *
           * _.inRange(-3, -2, -6);
           * // => true
           */
          function inRange(number, start, end) {
            start = toFinite(start)
            if (end === undefined) {
              end = start
              start = 0
            } else {
              end = toFinite(end)
            }
            number = toNumber(number)
            return baseInRange(number, start, end)
          }

          /**
           * Produces a random number between the inclusive `lower` and `upper` bounds.
           * If only one argument is provided a number between `0` and the given number
           * is returned. If `floating` is `true`, or either `lower` or `upper` are
           * floats, a floating-point number is returned instead of an integer.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Number
           * @param {number} [lower=0] The lower bound.
           * @param {number} [upper=1] The upper bound.
           * @param {boolean} [floating] Specify returning a floating-point number.
           * @returns {number} Returns the random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */
          function random(lower, upper, floating) {
            if (
              floating &&
              typeof floating != 'boolean' &&
              isIterateeCall(lower, upper, floating)
            ) {
              upper = floating = undefined
            }
            if (floating === undefined) {
              if (typeof upper == 'boolean') {
                floating = upper
                upper = undefined
              } else if (typeof lower == 'boolean') {
                floating = lower
                lower = undefined
              }
            }
            if (lower === undefined && upper === undefined) {
              lower = 0
              upper = 1
            } else {
              lower = toFinite(lower)
              if (upper === undefined) {
                upper = lower
                lower = 0
              } else {
                upper = toFinite(upper)
              }
            }
            if (lower > upper) {
              var temp = lower
              lower = upper
              upper = temp
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom()
              return nativeMin(
                lower +
                  rand *
                    (upper -
                      lower +
                      freeParseFloat('1e-' + ((rand + '').length - 1))),
                upper
              )
            }
            return baseRandom(lower, upper)
          }

          /*------------------------------------------------------------------------*/

          /**
           * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the camel cased string.
           * @example
           *
           * _.camelCase('Foo Bar');
           * // => 'fooBar'
           *
           * _.camelCase('--foo-bar--');
           * // => 'fooBar'
           *
           * _.camelCase('__FOO_BAR__');
           * // => 'fooBar'
           */
          var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase()
            return result + (index ? capitalize(word) : word)
          })

          /**
           * Converts the first character of `string` to upper case and the remaining
           * to lower case.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to capitalize.
           * @returns {string} Returns the capitalized string.
           * @example
           *
           * _.capitalize('FRED');
           * // => 'Fred'
           */
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase())
          }

          /**
           * Deburrs `string` by converting
           * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
           * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
           * letters to basic Latin letters and removing
           * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to deburr.
           * @returns {string} Returns the deburred string.
           * @example
           *
           * _.deburr('dj vu');
           * // => 'deja vu'
           */
          function deburr(string) {
            string = toString(string)
            return (
              string &&
              string.replace(reLatin, deburrLetter).replace(reComboMark, '')
            )
          }

          /**
           * Checks if `string` ends with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=string.length] The position to search up to.
           * @returns {boolean} Returns `true` if `string` ends with `target`,
           *  else `false`.
           * @example
           *
           * _.endsWith('abc', 'c');
           * // => true
           *
           * _.endsWith('abc', 'b');
           * // => false
           *
           * _.endsWith('abc', 'b', 2);
           * // => true
           */
          function endsWith(string, target, position) {
            string = toString(string)
            target = baseToString(target)

            var length = string.length
            position =
              position === undefined
                ? length
                : baseClamp(toInteger(position), 0, length)

            var end = position
            position -= target.length
            return position >= 0 && string.slice(position, end) == target
          }

          /**
           * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
           * corresponding HTML entities.
           *
           * **Note:** No other characters are escaped. To escape additional
           * characters use a third-party library like [_he_](https://mths.be/he).
           *
           * Though the ">" character is escaped for symmetry, characters like
           * ">" and "/" don't need escaping in HTML and have no special meaning
           * unless they're part of a tag or unquoted attribute value. See
           * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
           * (under "semi-related fun fact") for more details.
           *
           * When working with HTML you should always
           * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
           * XSS vectors.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('fred, barney, & pebbles');
           * // => 'fred, barney, &amp; pebbles'
           */
          function escape(string) {
            string = toString(string)
            return string && reHasUnescapedHtml.test(string)
              ? string.replace(reUnescapedHtml, escapeHtmlChar)
              : string
          }

          /**
           * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
           * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escapeRegExp('[lodash](https://lodash.com/)');
           * // => '\[lodash\]\(https://lodash\.com/\)'
           */
          function escapeRegExp(string) {
            string = toString(string)
            return string && reHasRegExpChar.test(string)
              ? string.replace(reRegExpChar, '\\$&')
              : string
          }

          /**
           * Converts `string` to
           * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the kebab cased string.
           * @example
           *
           * _.kebabCase('Foo Bar');
           * // => 'foo-bar'
           *
           * _.kebabCase('fooBar');
           * // => 'foo-bar'
           *
           * _.kebabCase('__FOO_BAR__');
           * // => 'foo-bar'
           */
          var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase()
          })

          /**
           * Converts `string`, as space separated words, to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.lowerCase('--Foo-Bar--');
           * // => 'foo bar'
           *
           * _.lowerCase('fooBar');
           * // => 'foo bar'
           *
           * _.lowerCase('__FOO_BAR__');
           * // => 'foo bar'
           */
          var lowerCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toLowerCase()
          })

          /**
           * Converts the first character of `string` to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.lowerFirst('Fred');
           * // => 'fred'
           *
           * _.lowerFirst('FRED');
           * // => 'fRED'
           */
          var lowerFirst = createCaseFirst('toLowerCase')

          /**
           * Pads `string` on the left and right sides if it's shorter than `length`.
           * Padding characters are truncated if they can't be evenly divided by `length`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.pad('abc', 8);
           * // => '  abc   '
           *
           * _.pad('abc', 8, '_-');
           * // => '_-abc_-_'
           *
           * _.pad('abc', 3);
           * // => 'abc'
           */
          function pad(string, length, chars) {
            string = toString(string)
            length = toInteger(length)

            var strLength = length ? stringSize(string) : 0
            if (!length || strLength >= length) {
              return string
            }
            var mid = (length - strLength) / 2
            return (
              createPadding(nativeFloor(mid), chars) +
              string +
              createPadding(nativeCeil(mid), chars)
            )
          }

          /**
           * Pads `string` on the right side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padEnd('abc', 6);
           * // => 'abc   '
           *
           * _.padEnd('abc', 6, '_-');
           * // => 'abc_-_'
           *
           * _.padEnd('abc', 3);
           * // => 'abc'
           */
          function padEnd(string, length, chars) {
            string = toString(string)
            length = toInteger(length)

            var strLength = length ? stringSize(string) : 0
            return length && strLength < length
              ? string + createPadding(length - strLength, chars)
              : string
          }

          /**
           * Pads `string` on the left side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padStart('abc', 6);
           * // => '   abc'
           *
           * _.padStart('abc', 6, '_-');
           * // => '_-_abc'
           *
           * _.padStart('abc', 3);
           * // => 'abc'
           */
          function padStart(string, length, chars) {
            string = toString(string)
            length = toInteger(length)

            var strLength = length ? stringSize(string) : 0
            return length && strLength < length
              ? createPadding(length - strLength, chars) + string
              : string
          }

          /**
           * Converts `string` to an integer of the specified radix. If `radix` is
           * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
           * hexadecimal, in which case a `radix` of `16` is used.
           *
           * **Note:** This method aligns with the
           * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category String
           * @param {string} string The string to convert.
           * @param {number} [radix=10] The radix to interpret `value` by.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           *
           * _.map(['6', '08', '10'], _.parseInt);
           * // => [6, 8, 10]
           */
          function parseInt(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0
            } else if (radix) {
              radix = +radix
            }
            return nativeParseInt(
              toString(string).replace(reTrimStart, ''),
              radix || 0
            )
          }

          /**
           * Repeats the given string `n` times.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to repeat.
           * @param {number} [n=1] The number of times to repeat the string.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the repeated string.
           * @example
           *
           * _.repeat('*', 3);
           * // => '***'
           *
           * _.repeat('abc', 2);
           * // => 'abcabc'
           *
           * _.repeat('abc', 0);
           * // => ''
           */
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
              n = 1
            } else {
              n = toInteger(n)
            }
            return baseRepeat(toString(string), n)
          }

          /**
           * Replaces matches for `pattern` in `string` with `replacement`.
           *
           * **Note:** This method is based on
           * [`String#replace`](https://mdn.io/String/replace).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to modify.
           * @param {RegExp|string} pattern The pattern to replace.
           * @param {Function|string} replacement The match replacement.
           * @returns {string} Returns the modified string.
           * @example
           *
           * _.replace('Hi Fred', 'Fred', 'Barney');
           * // => 'Hi Barney'
           */
          function replace() {
            var args = arguments,
              string = toString(args[0])

            return args.length < 3 ? string : string.replace(args[1], args[2])
          }

          /**
           * Converts `string` to
           * [snake case](https://en.wikipedia.org/wiki/Snake_case).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the snake cased string.
           * @example
           *
           * _.snakeCase('Foo Bar');
           * // => 'foo_bar'
           *
           * _.snakeCase('fooBar');
           * // => 'foo_bar'
           *
           * _.snakeCase('--FOO-BAR--');
           * // => 'foo_bar'
           */
          var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase()
          })

          /**
           * Splits `string` by `separator`.
           *
           * **Note:** This method is based on
           * [`String#split`](https://mdn.io/String/split).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to split.
           * @param {RegExp|string} separator The separator pattern to split by.
           * @param {number} [limit] The length to truncate results to.
           * @returns {Array} Returns the string segments.
           * @example
           *
           * _.split('a-b-c', '-', 2);
           * // => ['a', 'b']
           */
          function split(string, separator, limit) {
            if (
              limit &&
              typeof limit != 'number' &&
              isIterateeCall(string, separator, limit)
            ) {
              separator = limit = undefined
            }
            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0
            if (!limit) {
              return []
            }
            string = toString(string)
            if (
              string &&
              (typeof separator == 'string' ||
                (separator != null && !isRegExp(separator)))
            ) {
              separator = baseToString(separator)
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit)
              }
            }
            return string.split(separator, limit)
          }

          /**
           * Converts `string` to
           * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
           *
           * @static
           * @memberOf _
           * @since 3.1.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the start cased string.
           * @example
           *
           * _.startCase('--foo-bar--');
           * // => 'Foo Bar'
           *
           * _.startCase('fooBar');
           * // => 'Foo Bar'
           *
           * _.startCase('__FOO_BAR__');
           * // => 'FOO BAR'
           */
          var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + upperFirst(word)
          })

          /**
           * Checks if `string` starts with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=0] The position to search from.
           * @returns {boolean} Returns `true` if `string` starts with `target`,
           *  else `false`.
           * @example
           *
           * _.startsWith('abc', 'a');
           * // => true
           *
           * _.startsWith('abc', 'b');
           * // => false
           *
           * _.startsWith('abc', 'b', 1);
           * // => true
           */
          function startsWith(string, target, position) {
            string = toString(string)
            position =
              position == null
                ? 0
                : baseClamp(toInteger(position), 0, string.length)

            target = baseToString(target)
            return string.slice(position, position + target.length) == target
          }

          /**
           * Creates a compiled template function that can interpolate data properties
           * in "interpolate" delimiters, HTML-escape interpolated data properties in
           * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
           * properties may be accessed as free variables in the template. If a setting
           * object is given, it takes precedence over `_.templateSettings` values.
           *
           * **Note:** In the development build `_.template` utilizes
           * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
           * for easier debugging.
           *
           * For more information on precompiling templates see
           * [lodash's custom builds documentation](https://lodash.com/custom-builds).
           *
           * For more information on Chrome extension sandboxes see
           * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The template string.
           * @param {Object} [options={}] The options object.
           * @param {RegExp} [options.escape=_.templateSettings.escape]
           *  The HTML "escape" delimiter.
           * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
           *  The "evaluate" delimiter.
           * @param {Object} [options.imports=_.templateSettings.imports]
           *  An object to import into the template as free variables.
           * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
           *  The "interpolate" delimiter.
           * @param {string} [options.sourceURL='lodash.templateSources[n]']
           *  The sourceURL of the compiled template.
           * @param {string} [options.variable='obj']
           *  The data object variable name.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the compiled template function.
           * @example
           *
           * // Use the "interpolate" delimiter to create a compiled template.
           * var compiled = _.template('hello <%= user %>!');
           * compiled({ 'user': 'fred' });
           * // => 'hello fred!'
           *
           * // Use the HTML "escape" delimiter to escape data property values.
           * var compiled = _.template('<b><%- value %></b>');
           * compiled({ 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
           * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the internal `print` function in "evaluate" delimiters.
           * var compiled = _.template('<% print("hello " + user); %>!');
           * compiled({ 'user': 'barney' });
           * // => 'hello barney!'
           *
           * // Use the ES template literal delimiter as an "interpolate" delimiter.
           * // Disable support by replacing the "interpolate" delimiter.
           * var compiled = _.template('hello ${ user }!');
           * compiled({ 'user': 'pebbles' });
           * // => 'hello pebbles!'
           *
           * // Use backslashes to treat delimiters as plain text.
           * var compiled = _.template('<%= "\\<%- value %\\>" %>');
           * compiled({ 'value': 'ignored' });
           * // => '<%- value %>'
           *
           * // Use the `imports` option to import `jQuery` as `jq`.
           * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
           * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the `sourceURL` option to specify a custom sourceURL for the template.
           * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
           *
           * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
           * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           * //   var __t, __p = '';
           * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
           * //   return __p;
           * // }
           *
           * // Use custom template delimiters.
           * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
           * var compiled = _.template('hello {{ user }}!');
           * compiled({ 'user': 'mustache' });
           * // => 'hello mustache!'
           *
           * // Use the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and stack traces.
           * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */
          function template(string, options, guard) {
            // Based on John Resig's `tmpl` implementation
            // (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = lodash.templateSettings

            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined
            }
            string = toString(string)
            options = assignInWith(
              {},
              options,
              settings,
              customDefaultsAssignIn
            )

            var imports = assignInWith(
                {},
                options.imports,
                settings.imports,
                customDefaultsAssignIn
              ),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys)

            var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '"

            // Compile the regexp to match each delimiter.
            var reDelimiters = RegExp(
              (options.escape || reNoMatch).source +
                '|' +
                interpolate.source +
                '|' +
                (interpolate === reInterpolate ? reEsTemplate : reNoMatch)
                  .source +
                '|' +
                (options.evaluate || reNoMatch).source +
                '|$',
              'g'
            )

            // Use a sourceURL for easier debugging.
            // The sourceURL gets injected into the source that's eval-ed, so be careful
            // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
            // and escape the comment, thus injecting code that gets evaled.
            var sourceURL =
              '//# sourceURL=' +
              (hasOwnProperty.call(options, 'sourceURL')
                ? (options.sourceURL + '').replace(/\s/g, ' ')
                : 'lodash.templateSources[' + ++templateCounter + ']') +
              '\n'

            string.replace(
              reDelimiters,
              function (
                match,
                escapeValue,
                interpolateValue,
                esTemplateValue,
                evaluateValue,
                offset
              ) {
                interpolateValue || (interpolateValue = esTemplateValue)

                // Escape characters that can't be included in string literals.
                source += string
                  .slice(index, offset)
                  .replace(reUnescapedString, escapeStringChar)

                // Replace delimiters with snippets.
                if (escapeValue) {
                  isEscaping = true
                  source += "' +\n__e(" + escapeValue + ") +\n'"
                }
                if (evaluateValue) {
                  isEvaluating = true
                  source += "';\n" + evaluateValue + ";\n__p += '"
                }
                if (interpolateValue) {
                  source +=
                    "' +\n((__t = (" +
                    interpolateValue +
                    ")) == null ? '' : __t) +\n'"
                }
                index = offset + match.length

                // The JS engine embedded in Adobe products needs `match` returned in
                // order to produce the correct `offset` value.
                return match
              }
            )

            source += "';\n"

            // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.
            var variable =
              hasOwnProperty.call(options, 'variable') && options.variable
            if (!variable) {
              source = 'with (obj) {\n' + source + '\n}\n'
            }
            // Throw an error if a forbidden character was found in `variable`, to prevent
            // potential command injection attacks.
            else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT)
            }

            // Cleanup code by stripping empty strings.
            source = (
              isEvaluating ? source.replace(reEmptyStringLeading, '') : source
            )
              .replace(reEmptyStringMiddle, '$1')
              .replace(reEmptyStringTrailing, '$1;')

            // Frame code as the function body.
            source =
              'function(' +
              (variable || 'obj') +
              ') {\n' +
              (variable ? '' : 'obj || (obj = {});\n') +
              "var __t, __p = ''" +
              (isEscaping ? ', __e = _.escape' : '') +
              (isEvaluating
                ? ', __j = Array.prototype.join;\n' +
                  "function print() { __p += __j.call(arguments, '') }\n"
                : ';\n') +
              source +
              'return __p\n}'

            var result = attempt(function () {
              return Function(
                importsKeys,
                sourceURL + 'return ' + source
              ).apply(undefined, importsValues)
            })

            // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.
            result.source = source
            if (isError(result)) {
              throw result
            }
            return result
          }

          /**
           * Converts `string`, as a whole, to lower case just like
           * [String#toLowerCase](https://mdn.io/toLowerCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.toLower('--Foo-Bar--');
           * // => '--foo-bar--'
           *
           * _.toLower('fooBar');
           * // => 'foobar'
           *
           * _.toLower('__FOO_BAR__');
           * // => '__foo_bar__'
           */
          function toLower(value) {
            return toString(value).toLowerCase()
          }

          /**
           * Converts `string`, as a whole, to upper case just like
           * [String#toUpperCase](https://mdn.io/toUpperCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.toUpper('--foo-bar--');
           * // => '--FOO-BAR--'
           *
           * _.toUpper('fooBar');
           * // => 'FOOBAR'
           *
           * _.toUpper('__foo_bar__');
           * // => '__FOO_BAR__'
           */
          function toUpper(value) {
            return toString(value).toUpperCase()
          }

          /**
           * Removes leading and trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trim('  abc  ');
           * // => 'abc'
           *
           * _.trim('-_-abc-_-', '_-');
           * // => 'abc'
           *
           * _.map(['  foo  ', '  bar  '], _.trim);
           * // => ['foo', 'bar']
           */
          function trim(string, chars, guard) {
            string = toString(string)
            if (string && (guard || chars === undefined)) {
              return baseTrim(string)
            }
            if (!string || !(chars = baseToString(chars))) {
              return string
            }
            var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1

            return castSlice(strSymbols, start, end).join('')
          }

          /**
           * Removes trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimEnd('  abc  ');
           * // => '  abc'
           *
           * _.trimEnd('-_-abc-_-', '_-');
           * // => '-_-abc'
           */
          function trimEnd(string, chars, guard) {
            string = toString(string)
            if (string && (guard || chars === undefined)) {
              return string.slice(0, trimmedEndIndex(string) + 1)
            }
            if (!string || !(chars = baseToString(chars))) {
              return string
            }
            var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1

            return castSlice(strSymbols, 0, end).join('')
          }

          /**
           * Removes leading whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimStart('  abc  ');
           * // => 'abc  '
           *
           * _.trimStart('-_-abc-_-', '_-');
           * // => 'abc-_-'
           */
          function trimStart(string, chars, guard) {
            string = toString(string)
            if (string && (guard || chars === undefined)) {
              return string.replace(reTrimStart, '')
            }
            if (!string || !(chars = baseToString(chars))) {
              return string
            }
            var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars))

            return castSlice(strSymbols, start).join('')
          }

          /**
           * Truncates `string` if it's longer than the given maximum string length.
           * The last characters of the truncated string are replaced with the omission
           * string which defaults to "...".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to truncate.
           * @param {Object} [options={}] The options object.
           * @param {number} [options.length=30] The maximum string length.
           * @param {string} [options.omission='...'] The string to indicate text is omitted.
           * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
           * @returns {string} Returns the truncated string.
           * @example
           *
           * _.truncate('hi-diddly-ho there, neighborino');
           * // => 'hi-diddly-ho there, neighbo...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': ' '
           * });
           * // => 'hi-diddly-ho there,...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': /,? +/
           * });
           * // => 'hi-diddly-ho there...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'omission': ' [...]'
           * });
           * // => 'hi-diddly-ho there, neig [...]'
           */
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION

            if (isObject(options)) {
              var separator =
                'separator' in options ? options.separator : separator
              length = 'length' in options ? toInteger(options.length) : length
              omission =
                'omission' in options
                  ? baseToString(options.omission)
                  : omission
            }
            string = toString(string)

            var strLength = string.length
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string)
              strLength = strSymbols.length
            }
            if (length >= strLength) {
              return string
            }
            var end = length - stringSize(omission)
            if (end < 1) {
              return omission
            }
            var result = strSymbols
              ? castSlice(strSymbols, 0, end).join('')
              : string.slice(0, end)

            if (separator === undefined) {
              return result + omission
            }
            if (strSymbols) {
              end += result.length - end
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match,
                  substring = result

                if (!separator.global) {
                  separator = RegExp(
                    separator.source,
                    toString(reFlags.exec(separator)) + 'g'
                  )
                }
                separator.lastIndex = 0
                while ((match = separator.exec(substring))) {
                  var newEnd = match.index
                }
                result = result.slice(0, newEnd === undefined ? end : newEnd)
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result.lastIndexOf(separator)
              if (index > -1) {
                result = result.slice(0, index)
              }
            }
            return result + omission
          }

          /**
           * The inverse of `_.escape`; this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
           * their corresponding characters.
           *
           * **Note:** No other HTML entities are unescaped. To unescape additional
           * HTML entities use a third-party library like [_he_](https://mths.be/he).
           *
           * @static
           * @memberOf _
           * @since 0.6.0
           * @category String
           * @param {string} [string=''] The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('fred, barney, &amp; pebbles');
           * // => 'fred, barney, & pebbles'
           */
          function unescape(string) {
            string = toString(string)
            return string && reHasEscapedHtml.test(string)
              ? string.replace(reEscapedHtml, unescapeHtmlChar)
              : string
          }

          /**
           * Converts `string`, as space separated words, to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.upperCase('--foo-bar');
           * // => 'FOO BAR'
           *
           * _.upperCase('fooBar');
           * // => 'FOO BAR'
           *
           * _.upperCase('__foo_bar__');
           * // => 'FOO BAR'
           */
          var upperCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toUpperCase()
          })

          /**
           * Converts the first character of `string` to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.upperFirst('fred');
           * // => 'Fred'
           *
           * _.upperFirst('FRED');
           * // => 'FRED'
           */
          var upperFirst = createCaseFirst('toUpperCase')

          /**
           * Splits `string` into an array of its words.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {RegExp|string} [pattern] The pattern to match words.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the words of `string`.
           * @example
           *
           * _.words('fred, barney, & pebbles');
           * // => ['fred', 'barney', 'pebbles']
           *
           * _.words('fred, barney, & pebbles', /[^, ]+/g);
           * // => ['fred', 'barney', '&', 'pebbles']
           */
          function words(string, pattern, guard) {
            string = toString(string)
            pattern = guard ? undefined : pattern

            if (pattern === undefined) {
              return hasUnicodeWord(string)
                ? unicodeWords(string)
                : asciiWords(string)
            }
            return string.match(pattern) || []
          }

          /*------------------------------------------------------------------------*/

          /**
           * Attempts to invoke `func`, returning either the result or the caught error
           * object. Any additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Function} func The function to attempt.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {*} Returns the `func` result or error object.
           * @example
           *
           * // Avoid throwing errors for invalid selectors.
           * var elements = _.attempt(function(selector) {
           *   return document.querySelectorAll(selector);
           * }, '>_>');
           *
           * if (_.isError(elements)) {
           *   elements = [];
           * }
           */
          var attempt = baseRest(function (func, args) {
            try {
              return apply(func, undefined, args)
            } catch (e) {
              return isError(e) ? e : new Error(e)
            }
          })

          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method.
           *
           * **Note:** This method doesn't set the "length" property of bound functions.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...(string|string[])} methodNames The object method names to bind.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'click': function() {
           *     console.log('clicked ' + this.label);
           *   }
           * };
           *
           * _.bindAll(view, ['click']);
           * jQuery(element).on('click', view.click);
           * // => Logs 'clicked docs' when clicked.
           */
          var bindAll = flatRest(function (object, methodNames) {
            arrayEach(methodNames, function (key) {
              key = toKey(key)
              baseAssignValue(object, key, bind(object[key], object))
            })
            return object
          })

          /**
           * Creates a function that iterates over `pairs` and invokes the corresponding
           * function of the first predicate to return truthy. The predicate-function
           * pairs are invoked with the `this` binding and arguments of the created
           * function.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Array} pairs The predicate-function pairs.
           * @returns {Function} Returns the new composite function.
           * @example
           *
           * var func = _.cond([
           *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
           *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
           *   [_.stubTrue,                      _.constant('no match')]
           * ]);
           *
           * func({ 'a': 1, 'b': 2 });
           * // => 'matches A'
           *
           * func({ 'a': 0, 'b': 1 });
           * // => 'matches B'
           *
           * func({ 'a': '1', 'b': '2' });
           * // => 'no match'
           */
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length,
              toIteratee = getIteratee()

            pairs = !length
              ? []
              : arrayMap(pairs, function (pair) {
                  if (typeof pair[1] != 'function') {
                    throw new TypeError(FUNC_ERROR_TEXT)
                  }
                  return [toIteratee(pair[0]), pair[1]]
                })

            return baseRest(function (args) {
              var index = -1
              while (++index < length) {
                var pair = pairs[index]
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args)
                }
              }
            })
          }

          /**
           * Creates a function that invokes the predicate properties of `source` with
           * the corresponding property values of a given object, returning `true` if
           * all predicates return truthy, else `false`.
           *
           * **Note:** The created function is equivalent to `_.conformsTo` with
           * `source` partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 2, 'b': 1 },
           *   { 'a': 1, 'b': 2 }
           * ];
           *
           * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
           * // => [{ 'a': 1, 'b': 2 }]
           */
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG))
          }

          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new constant function.
           * @example
           *
           * var objects = _.times(2, _.constant({ 'a': 1 }));
           *
           * console.log(objects);
           * // => [{ 'a': 1 }, { 'a': 1 }]
           *
           * console.log(objects[0] === objects[1]);
           * // => true
           */
          function constant(value) {
            return function () {
              return value
            }
          }

          /**
           * Checks `value` to determine whether a default value should be returned in
           * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
           * or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Util
           * @param {*} value The value to check.
           * @param {*} defaultValue The default value.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * _.defaultTo(1, 10);
           * // => 1
           *
           * _.defaultTo(undefined, 10);
           * // => 10
           */
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value
          }

          /**
           * Creates a function that returns the result of invoking the given functions
           * with the `this` binding of the created function, where each successive
           * invocation is supplied the return value of the previous.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flowRight
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flow([_.add, square]);
           * addSquare(1, 2);
           * // => 9
           */
          var flow = createFlow()

          /**
           * This method is like `_.flow` except that it creates a function that
           * invokes the given functions from right to left.
           *
           * @static
           * @since 3.0.0
           * @memberOf _
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flow
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flowRight([square, _.add]);
           * addSquare(1, 2);
           * // => 9
           */
          var flowRight = createFlow(true)

          /**
           * This method returns the first argument it receives.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'a': 1 };
           *
           * console.log(_.identity(object) === object);
           * // => true
           */
          function identity(value) {
            return value
          }

          /**
           * Creates a function that invokes `func` with the arguments of the created
           * function. If `func` is a property name, the created function returns the
           * property value for a given element. If `func` is an array or object, the
           * created function returns `true` for elements that contain the equivalent
           * source properties, otherwise it returns `false`.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Util
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @returns {Function} Returns the callback.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
           * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, _.iteratee(['user', 'fred']));
           * // => [{ 'user': 'fred', 'age': 40 }]
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, _.iteratee('user'));
           * // => ['barney', 'fred']
           *
           * // Create custom iteratee shorthands.
           * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
           *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
           *     return func.test(string);
           *   };
           * });
           *
           * _.filter(['abc', 'def'], /ef/);
           * // => ['def']
           */
          function iteratee(func) {
            return baseIteratee(
              typeof func == 'function'
                ? func
                : baseClone(func, CLONE_DEEP_FLAG)
            )
          }

          /**
           * Creates a function that performs a partial deep comparison between a given
           * object and `source`, returning `true` if the given object has equivalent
           * property values, else `false`.
           *
           * **Note:** The created function is equivalent to `_.isMatch` with `source`
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * **Note:** Multiple values can be checked by combining several matchers
           * using `_.overSome`
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
           * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
           *
           * // Checking for several possible values
           * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
           * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
           */
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
          }

          /**
           * Creates a function that performs a partial deep comparison between the
           * value at `path` of a given object to `srcValue`, returning `true` if the
           * object value is equivalent, else `false`.
           *
           * **Note:** Partial comparisons will match empty array and empty object
           * `srcValue` values against any array or object value, respectively. See
           * `_.isEqual` for a list of supported value comparisons.
           *
           * **Note:** Multiple values can be checked by combining several matchers
           * using `_.overSome`
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.find(objects, _.matchesProperty('a', 4));
           * // => { 'a': 4, 'b': 5, 'c': 6 }
           *
           * // Checking for several possible values
           * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
           * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
           */
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(
              path,
              baseClone(srcValue, CLONE_DEEP_FLAG)
            )
          }

          /**
           * Creates a function that invokes the method at `path` of a given object.
           * Any additional arguments are provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': _.constant(2) } },
           *   { 'a': { 'b': _.constant(1) } }
           * ];
           *
           * _.map(objects, _.method('a.b'));
           * // => [2, 1]
           *
           * _.map(objects, _.method(['a', 'b']));
           * // => [2, 1]
           */
          var method = baseRest(function (path, args) {
            return function (object) {
              return baseInvoke(object, path, args)
            }
          })

          /**
           * The opposite of `_.method`; this method creates a function that invokes
           * the method at a given path of `object`. Any additional arguments are
           * provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Object} object The object to query.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var array = _.times(3, _.constant),
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.methodOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
           * // => [2, 0]
           */
          var methodOf = baseRest(function (object, args) {
            return function (path) {
              return baseInvoke(object, path, args)
            }
          })

          /**
           * Adds all own enumerable string keyed function properties of a source
           * object to the destination object. If `object` is a function, then methods
           * are added to its prototype as well.
           *
           * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
           * avoid conflicts caused by modifying the original.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Function|Object} [object=lodash] The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
           * @returns {Function|Object} Returns `object`.
           * @example
           *
           * function vowels(string) {
           *   return _.filter(string, function(v) {
           *     return /[aeiou]/i.test(v);
           *   });
           * }
           *
           * _.mixin({ 'vowels': vowels });
           * _.vowels('fred');
           * // => ['e']
           *
           * _('fred').vowels().value();
           * // => ['e']
           *
           * _.mixin({ 'vowels': vowels }, { 'chain': false });
           * _('fred').vowels();
           * // => ['e']
           */
          function mixin(object, source, options) {
            var props = keys(source),
              methodNames = baseFunctions(source, props)

            if (
              options == null &&
              !(isObject(source) && (methodNames.length || !props.length))
            ) {
              options = source
              source = object
              object = this
              methodNames = baseFunctions(source, keys(source))
            }
            var chain =
                !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object)

            arrayEach(methodNames, function (methodName) {
              var func = source[methodName]
              object[methodName] = func
              if (isFunc) {
                object.prototype[methodName] = function () {
                  var chainAll = this.__chain__
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                      actions = (result.__actions__ = copyArray(
                        this.__actions__
                      ))

                    actions.push({
                      func: func,
                      args: arguments,
                      thisArg: object
                    })
                    result.__chain__ = chainAll
                    return result
                  }
                  return func.apply(
                    object,
                    arrayPush([this.value()], arguments)
                  )
                }
              }
            })

            return object
          }

          /**
           * Reverts the `_` variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash
            }
            return this
          }

          /**
           * This method returns `undefined`.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Util
           * @example
           *
           * _.times(2, _.noop);
           * // => [undefined, undefined]
           */
          function noop() {
            // No operation performed.
          }

          /**
           * Creates a function that gets the argument at index `n`. If `n` is negative,
           * the nth argument from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [n=0] The index of the argument to return.
           * @returns {Function} Returns the new pass-thru function.
           * @example
           *
           * var func = _.nthArg(1);
           * func('a', 'b', 'c', 'd');
           * // => 'b'
           *
           * var func = _.nthArg(-2);
           * func('a', 'b', 'c', 'd');
           * // => 'c'
           */
          function nthArg(n) {
            n = toInteger(n)
            return baseRest(function (args) {
              return baseNth(args, n)
            })
          }

          /**
           * Creates a function that invokes `iteratees` with the arguments it receives
           * and returns their results.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.over([Math.max, Math.min]);
           *
           * func(1, 2, 3, 4);
           * // => [4, 1]
           */
          var over = createOver(arrayMap)

          /**
           * Creates a function that checks if **all** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * Following shorthands are possible for providing predicates.
           * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
           * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overEvery([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => false
           *
           * func(NaN);
           * // => false
           */
          var overEvery = createOver(arrayEvery)

          /**
           * Creates a function that checks if **any** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * Following shorthands are possible for providing predicates.
           * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
           * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overSome([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => true
           *
           * func(NaN);
           * // => false
           *
           * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
           * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
           */
          var overSome = createOver(arraySome)

          /**
           * Creates a function that returns the value at `path` of a given object.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': 2 } },
           *   { 'a': { 'b': 1 } }
           * ];
           *
           * _.map(objects, _.property('a.b'));
           * // => [2, 1]
           *
           * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
           * // => [1, 2]
           */
          function property(path) {
            return isKey(path)
              ? baseProperty(toKey(path))
              : basePropertyDeep(path)
          }

          /**
           * The opposite of `_.property`; this method creates a function that returns
           * the value at a given path of `object`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} object The object to query.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var array = [0, 1, 2],
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
           * // => [2, 0]
           */
          function propertyOf(object) {
            return function (path) {
              return object == null ? undefined : baseGet(object, path)
            }
          }

          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to, but not including, `end`. A step of `-1` is used if a negative
           * `start` is specified without an `end` or `step`. If `end` is not specified,
           * it's set to `start` with `start` then set to `0`.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.rangeRight
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(-4);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */
          var range = createRange()

          /**
           * This method is like `_.range` except that it populates values in
           * descending order.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.range
           * @example
           *
           * _.rangeRight(4);
           * // => [3, 2, 1, 0]
           *
           * _.rangeRight(-4);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 5);
           * // => [4, 3, 2, 1]
           *
           * _.rangeRight(0, 20, 5);
           * // => [15, 10, 5, 0]
           *
           * _.rangeRight(0, -4, -1);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.rangeRight(0);
           * // => []
           */
          var rangeRight = createRange(true)

          /**
           * This method returns a new empty array.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Array} Returns the new empty array.
           * @example
           *
           * var arrays = _.times(2, _.stubArray);
           *
           * console.log(arrays);
           * // => [[], []]
           *
           * console.log(arrays[0] === arrays[1]);
           * // => false
           */
          function stubArray() {
            return []
          }

          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */
          function stubFalse() {
            return false
          }

          /**
           * This method returns a new empty object.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Object} Returns the new empty object.
           * @example
           *
           * var objects = _.times(2, _.stubObject);
           *
           * console.log(objects);
           * // => [{}, {}]
           *
           * console.log(objects[0] === objects[1]);
           * // => false
           */
          function stubObject() {
            return {}
          }

          /**
           * This method returns an empty string.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {string} Returns the empty string.
           * @example
           *
           * _.times(2, _.stubString);
           * // => ['', '']
           */
          function stubString() {
            return ''
          }

          /**
           * This method returns `true`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `true`.
           * @example
           *
           * _.times(2, _.stubTrue);
           * // => [true, true]
           */
          function stubTrue() {
            return true
          }

          /**
           * Invokes the iteratee `n` times, returning an array of the results of
           * each invocation. The iteratee is invoked with one argument; (index).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.times(3, String);
           * // => ['0', '1', '2']
           *
           *  _.times(4, _.constant(0));
           * // => [0, 0, 0, 0]
           */
          function times(n, iteratee) {
            n = toInteger(n)
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return []
            }
            var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH)

            iteratee = getIteratee(iteratee)
            n -= MAX_ARRAY_LENGTH

            var result = baseTimes(length, iteratee)
            while (++index < n) {
              iteratee(index)
            }
            return result
          }

          /**
           * Converts `value` to a property path array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {*} value The value to convert.
           * @returns {Array} Returns the new property path array.
           * @example
           *
           * _.toPath('a.b.c');
           * // => ['a', 'b', 'c']
           *
           * _.toPath('a[0].b.c');
           * // => ['a', '0', 'b', 'c']
           */
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey)
            }
            return isSymbol(value)
              ? [value]
              : copyArray(stringToPath(toString(value)))
          }

          /**
           * Generates a unique ID. If `prefix` is given, the ID is appended to it.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {string} [prefix=''] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */
          function uniqueId(prefix) {
            var id = ++idCounter
            return toString(prefix) + id
          }

          /*------------------------------------------------------------------------*/

          /**
           * Adds two numbers.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {number} augend The first number in an addition.
           * @param {number} addend The second number in an addition.
           * @returns {number} Returns the total.
           * @example
           *
           * _.add(6, 4);
           * // => 10
           */
          var add = createMathOperation(function (augend, addend) {
            return augend + addend
          }, 0)

          /**
           * Computes `number` rounded up to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round up.
           * @param {number} [precision=0] The precision to round up to.
           * @returns {number} Returns the rounded up number.
           * @example
           *
           * _.ceil(4.006);
           * // => 5
           *
           * _.ceil(6.004, 2);
           * // => 6.01
           *
           * _.ceil(6040, -2);
           * // => 6100
           */
          var ceil = createRound('ceil')

          /**
           * Divide two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} dividend The first number in a division.
           * @param {number} divisor The second number in a division.
           * @returns {number} Returns the quotient.
           * @example
           *
           * _.divide(6, 4);
           * // => 1.5
           */
          var divide = createMathOperation(function (dividend, divisor) {
            return dividend / divisor
          }, 1)

          /**
           * Computes `number` rounded down to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round down.
           * @param {number} [precision=0] The precision to round down to.
           * @returns {number} Returns the rounded down number.
           * @example
           *
           * _.floor(4.006);
           * // => 4
           *
           * _.floor(0.046, 2);
           * // => 0.04
           *
           * _.floor(4060, -2);
           * // => 4000
           */
          var floor = createRound('floor')

          /**
           * Computes the maximum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * _.max([]);
           * // => undefined
           */
          function max(array) {
            return array && array.length
              ? baseExtremum(array, identity, baseGt)
              : undefined
          }

          /**
           * This method is like `_.max` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.maxBy(objects, function(o) { return o.n; });
           * // => { 'n': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.maxBy(objects, 'n');
           * // => { 'n': 2 }
           */
          function maxBy(array, iteratee) {
            return array && array.length
              ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
              : undefined
          }

          /**
           * Computes the mean of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the mean.
           * @example
           *
           * _.mean([4, 2, 8, 6]);
           * // => 5
           */
          function mean(array) {
            return baseMean(array, identity)
          }

          /**
           * This method is like `_.mean` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be averaged.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the mean.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.meanBy(objects, function(o) { return o.n; });
           * // => 5
           *
           * // The `_.property` iteratee shorthand.
           * _.meanBy(objects, 'n');
           * // => 5
           */
          function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2))
          }

          /**
           * Computes the minimum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * _.min([]);
           * // => undefined
           */
          function min(array) {
            return array && array.length
              ? baseExtremum(array, identity, baseLt)
              : undefined
          }

          /**
           * This method is like `_.min` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.minBy(objects, function(o) { return o.n; });
           * // => { 'n': 1 }
           *
           * // The `_.property` iteratee shorthand.
           * _.minBy(objects, 'n');
           * // => { 'n': 1 }
           */
          function minBy(array, iteratee) {
            return array && array.length
              ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
              : undefined
          }

          /**
           * Multiply two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} multiplier The first number in a multiplication.
           * @param {number} multiplicand The second number in a multiplication.
           * @returns {number} Returns the product.
           * @example
           *
           * _.multiply(6, 4);
           * // => 24
           */
          var multiply = createMathOperation(function (
            multiplier,
            multiplicand
          ) {
            return multiplier * multiplicand
          },
          1)

          /**
           * Computes `number` rounded to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round.
           * @param {number} [precision=0] The precision to round to.
           * @returns {number} Returns the rounded number.
           * @example
           *
           * _.round(4.006);
           * // => 4
           *
           * _.round(4.006, 2);
           * // => 4.01
           *
           * _.round(4060, -2);
           * // => 4100
           */
          var round = createRound('round')

          /**
           * Subtract two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {number} minuend The first number in a subtraction.
           * @param {number} subtrahend The second number in a subtraction.
           * @returns {number} Returns the difference.
           * @example
           *
           * _.subtract(6, 4);
           * // => 2
           */
          var subtract = createMathOperation(function (minuend, subtrahend) {
            return minuend - subtrahend
          }, 0)

          /**
           * Computes the sum of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.sum([4, 2, 8, 6]);
           * // => 20
           */
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0
          }

          /**
           * This method is like `_.sum` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be summed.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the sum.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.sumBy(objects, function(o) { return o.n; });
           * // => 20
           *
           * // The `_.property` iteratee shorthand.
           * _.sumBy(objects, 'n');
           * // => 20
           */
          function sumBy(array, iteratee) {
            return array && array.length
              ? baseSum(array, getIteratee(iteratee, 2))
              : 0
          }

          /*------------------------------------------------------------------------*/

          // Add methods that return wrapped values in chain sequences.
          lodash.after = after
          lodash.ary = ary
          lodash.assign = assign
          lodash.assignIn = assignIn
          lodash.assignInWith = assignInWith
          lodash.assignWith = assignWith
          lodash.at = at
          lodash.before = before
          lodash.bind = bind
          lodash.bindAll = bindAll
          lodash.bindKey = bindKey
          lodash.castArray = castArray
          lodash.chain = chain
          lodash.chunk = chunk
          lodash.compact = compact
          lodash.concat = concat
          lodash.cond = cond
          lodash.conforms = conforms
          lodash.constant = constant
          lodash.countBy = countBy
          lodash.create = create
          lodash.curry = curry
          lodash.curryRight = curryRight
          lodash.debounce = debounce
          lodash.defaults = defaults
          lodash.defaultsDeep = defaultsDeep
          lodash.defer = defer
          lodash.delay = delay
          lodash.difference = difference
          lodash.differenceBy = differenceBy
          lodash.differenceWith = differenceWith
          lodash.drop = drop
          lodash.dropRight = dropRight
          lodash.dropRightWhile = dropRightWhile
          lodash.dropWhile = dropWhile
          lodash.fill = fill
          lodash.filter = filter
          lodash.flatMap = flatMap
          lodash.flatMapDeep = flatMapDeep
          lodash.flatMapDepth = flatMapDepth
          lodash.flatten = flatten
          lodash.flattenDeep = flattenDeep
          lodash.flattenDepth = flattenDepth
          lodash.flip = flip
          lodash.flow = flow
          lodash.flowRight = flowRight
          lodash.fromPairs = fromPairs
          lodash.functions = functions
          lodash.functionsIn = functionsIn
          lodash.groupBy = groupBy
          lodash.initial = initial
          lodash.intersection = intersection
          lodash.intersectionBy = intersectionBy
          lodash.intersectionWith = intersectionWith
          lodash.invert = invert
          lodash.invertBy = invertBy
          lodash.invokeMap = invokeMap
          lodash.iteratee = iteratee
          lodash.keyBy = keyBy
          lodash.keys = keys
          lodash.keysIn = keysIn
          lodash.map = map
          lodash.mapKeys = mapKeys
          lodash.mapValues = mapValues
          lodash.matches = matches
          lodash.matchesProperty = matchesProperty
          lodash.memoize = memoize
          lodash.merge = merge
          lodash.mergeWith = mergeWith
          lodash.method = method
          lodash.methodOf = methodOf
          lodash.mixin = mixin
          lodash.negate = negate
          lodash.nthArg = nthArg
          lodash.omit = omit
          lodash.omitBy = omitBy
          lodash.once = once
          lodash.orderBy = orderBy
          lodash.over = over
          lodash.overArgs = overArgs
          lodash.overEvery = overEvery
          lodash.overSome = overSome
          lodash.partial = partial
          lodash.partialRight = partialRight
          lodash.partition = partition
          lodash.pick = pick
          lodash.pickBy = pickBy
          lodash.property = property
          lodash.propertyOf = propertyOf
          lodash.pull = pull
          lodash.pullAll = pullAll
          lodash.pullAllBy = pullAllBy
          lodash.pullAllWith = pullAllWith
          lodash.pullAt = pullAt
          lodash.range = range
          lodash.rangeRight = rangeRight
          lodash.rearg = rearg
          lodash.reject = reject
          lodash.remove = remove
          lodash.rest = rest
          lodash.reverse = reverse
          lodash.sampleSize = sampleSize
          lodash.set = set
          lodash.setWith = setWith
          lodash.shuffle = shuffle
          lodash.slice = slice
          lodash.sortBy = sortBy
          lodash.sortedUniq = sortedUniq
          lodash.sortedUniqBy = sortedUniqBy
          lodash.split = split
          lodash.spread = spread
          lodash.tail = tail
          lodash.take = take
          lodash.takeRight = takeRight
          lodash.takeRightWhile = takeRightWhile
          lodash.takeWhile = takeWhile
          lodash.tap = tap
          lodash.throttle = throttle
          lodash.thru = thru
          lodash.toArray = toArray
          lodash.toPairs = toPairs
          lodash.toPairsIn = toPairsIn
          lodash.toPath = toPath
          lodash.toPlainObject = toPlainObject
          lodash.transform = transform
          lodash.unary = unary
          lodash.union = union
          lodash.unionBy = unionBy
          lodash.unionWith = unionWith
          lodash.uniq = uniq
          lodash.uniqBy = uniqBy
          lodash.uniqWith = uniqWith
          lodash.unset = unset
          lodash.unzip = unzip
          lodash.unzipWith = unzipWith
          lodash.update = update
          lodash.updateWith = updateWith
          lodash.values = values
          lodash.valuesIn = valuesIn
          lodash.without = without
          lodash.words = words
          lodash.wrap = wrap
          lodash.xor = xor
          lodash.xorBy = xorBy
          lodash.xorWith = xorWith
          lodash.zip = zip
          lodash.zipObject = zipObject
          lodash.zipObjectDeep = zipObjectDeep
          lodash.zipWith = zipWith

          // Add aliases.
          lodash.entries = toPairs
          lodash.entriesIn = toPairsIn
          lodash.extend = assignIn
          lodash.extendWith = assignInWith

          // Add methods to `lodash.prototype`.
          mixin(lodash, lodash)

          /*------------------------------------------------------------------------*/

          // Add methods that return unwrapped values in chain sequences.
          lodash.add = add
          lodash.attempt = attempt
          lodash.camelCase = camelCase
          lodash.capitalize = capitalize
          lodash.ceil = ceil
          lodash.clamp = clamp
          lodash.clone = clone
          lodash.cloneDeep = cloneDeep
          lodash.cloneDeepWith = cloneDeepWith
          lodash.cloneWith = cloneWith
          lodash.conformsTo = conformsTo
          lodash.deburr = deburr
          lodash.defaultTo = defaultTo
          lodash.divide = divide
          lodash.endsWith = endsWith
          lodash.eq = eq
          lodash.escape = escape
          lodash.escapeRegExp = escapeRegExp
          lodash.every = every
          lodash.find = find
          lodash.findIndex = findIndex
          lodash.findKey = findKey
          lodash.findLast = findLast
          lodash.findLastIndex = findLastIndex
          lodash.findLastKey = findLastKey
          lodash.floor = floor
          lodash.forEach = forEach
          lodash.forEachRight = forEachRight
          lodash.forIn = forIn
          lodash.forInRight = forInRight
          lodash.forOwn = forOwn
          lodash.forOwnRight = forOwnRight
          lodash.get = get
          lodash.gt = gt
          lodash.gte = gte
          lodash.has = has
          lodash.hasIn = hasIn
          lodash.head = head
          lodash.identity = identity
          lodash.includes = includes
          lodash.indexOf = indexOf
          lodash.inRange = inRange
          lodash.invoke = invoke
          lodash.isArguments = isArguments
          lodash.isArray = isArray
          lodash.isArrayBuffer = isArrayBuffer
          lodash.isArrayLike = isArrayLike
          lodash.isArrayLikeObject = isArrayLikeObject
          lodash.isBoolean = isBoolean
          lodash.isBuffer = isBuffer
          lodash.isDate = isDate
          lodash.isElement = isElement
          lodash.isEmpty = isEmpty
          lodash.isEqual = isEqual
          lodash.isEqualWith = isEqualWith
          lodash.isError = isError
          lodash.isFinite = isFinite
          lodash.isFunction = isFunction
          lodash.isInteger = isInteger
          lodash.isLength = isLength
          lodash.isMap = isMap
          lodash.isMatch = isMatch
          lodash.isMatchWith = isMatchWith
          lodash.isNaN = isNaN
          lodash.isNative = isNative
          lodash.isNil = isNil
          lodash.isNull = isNull
          lodash.isNumber = isNumber
          lodash.isObject = isObject
          lodash.isObjectLike = isObjectLike
          lodash.isPlainObject = isPlainObject
          lodash.isRegExp = isRegExp
          lodash.isSafeInteger = isSafeInteger
          lodash.isSet = isSet
          lodash.isString = isString
          lodash.isSymbol = isSymbol
          lodash.isTypedArray = isTypedArray
          lodash.isUndefined = isUndefined
          lodash.isWeakMap = isWeakMap
          lodash.isWeakSet = isWeakSet
          lodash.join = join
          lodash.kebabCase = kebabCase
          lodash.last = last
          lodash.lastIndexOf = lastIndexOf
          lodash.lowerCase = lowerCase
          lodash.lowerFirst = lowerFirst
          lodash.lt = lt
          lodash.lte = lte
          lodash.max = max
          lodash.maxBy = maxBy
          lodash.mean = mean
          lodash.meanBy = meanBy
          lodash.min = min
          lodash.minBy = minBy
          lodash.stubArray = stubArray
          lodash.stubFalse = stubFalse
          lodash.stubObject = stubObject
          lodash.stubString = stubString
          lodash.stubTrue = stubTrue
          lodash.multiply = multiply
          lodash.nth = nth
          lodash.noConflict = noConflict
          lodash.noop = noop
          lodash.now = now
          lodash.pad = pad
          lodash.padEnd = padEnd
          lodash.padStart = padStart
          lodash.parseInt = parseInt
          lodash.random = random
          lodash.reduce = reduce
          lodash.reduceRight = reduceRight
          lodash.repeat = repeat
          lodash.replace = replace
          lodash.result = result
          lodash.round = round
          lodash.runInContext = runInContext
          lodash.sample = sample
          lodash.size = size
          lodash.snakeCase = snakeCase
          lodash.some = some
          lodash.sortedIndex = sortedIndex
          lodash.sortedIndexBy = sortedIndexBy
          lodash.sortedIndexOf = sortedIndexOf
          lodash.sortedLastIndex = sortedLastIndex
          lodash.sortedLastIndexBy = sortedLastIndexBy
          lodash.sortedLastIndexOf = sortedLastIndexOf
          lodash.startCase = startCase
          lodash.startsWith = startsWith
          lodash.subtract = subtract
          lodash.sum = sum
          lodash.sumBy = sumBy
          lodash.template = template
          lodash.times = times
          lodash.toFinite = toFinite
          lodash.toInteger = toInteger
          lodash.toLength = toLength
          lodash.toLower = toLower
          lodash.toNumber = toNumber
          lodash.toSafeInteger = toSafeInteger
          lodash.toString = toString
          lodash.toUpper = toUpper
          lodash.trim = trim
          lodash.trimEnd = trimEnd
          lodash.trimStart = trimStart
          lodash.truncate = truncate
          lodash.unescape = unescape
          lodash.uniqueId = uniqueId
          lodash.upperCase = upperCase
          lodash.upperFirst = upperFirst

          // Add aliases.
          lodash.each = forEach
          lodash.eachRight = forEachRight
          lodash.first = head

          mixin(
            lodash,
            (function () {
              var source = {}
              baseForOwn(lodash, function (func, methodName) {
                if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                  source[methodName] = func
                }
              })
              return source
            })(),
            { chain: false }
          )

          /*------------------------------------------------------------------------*/

          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type {string}
           */
          lodash.VERSION = VERSION

          // Assign default placeholders.
          arrayEach(
            [
              'bind',
              'bindKey',
              'curry',
              'curryRight',
              'partial',
              'partialRight'
            ],
            function (methodName) {
              lodash[methodName].placeholder = lodash
            }
          )

          // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
          arrayEach(['drop', 'take'], function (methodName, index) {
            LazyWrapper.prototype[methodName] = function (n) {
              n = n === undefined ? 1 : nativeMax(toInteger(n), 0)

              var result =
                this.__filtered__ && !index
                  ? new LazyWrapper(this)
                  : this.clone()

              if (result.__filtered__) {
                result.__takeCount__ = nativeMin(n, result.__takeCount__)
              } else {
                result.__views__.push({
                  size: nativeMin(n, MAX_ARRAY_LENGTH),
                  type: methodName + (result.__dir__ < 0 ? 'Right' : '')
                })
              }
              return result
            }

            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
              return this.reverse()[methodName](n).reverse()
            }
          })

          // Add `LazyWrapper` methods that accept an `iteratee` value.
          arrayEach(
            ['filter', 'map', 'takeWhile'],
            function (methodName, index) {
              var type = index + 1,
                isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG

              LazyWrapper.prototype[methodName] = function (iteratee) {
                var result = this.clone()
                result.__iteratees__.push({
                  iteratee: getIteratee(iteratee, 3),
                  type: type
                })
                result.__filtered__ = result.__filtered__ || isFilter
                return result
              }
            }
          )

          // Add `LazyWrapper` methods for `_.head` and `_.last`.
          arrayEach(['head', 'last'], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '')

            LazyWrapper.prototype[methodName] = function () {
              return this[takeName](1).value()[0]
            }
          })

          // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
          arrayEach(['initial', 'tail'], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right')

            LazyWrapper.prototype[methodName] = function () {
              return this.__filtered__
                ? new LazyWrapper(this)
                : this[dropName](1)
            }
          })

          LazyWrapper.prototype.compact = function () {
            return this.filter(identity)
          }

          LazyWrapper.prototype.find = function (predicate) {
            return this.filter(predicate).head()
          }

          LazyWrapper.prototype.findLast = function (predicate) {
            return this.reverse().find(predicate)
          }

          LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
            if (typeof path == 'function') {
              return new LazyWrapper(this)
            }
            return this.map(function (value) {
              return baseInvoke(value, path, args)
            })
          })

          LazyWrapper.prototype.reject = function (predicate) {
            return this.filter(negate(getIteratee(predicate)))
          }

          LazyWrapper.prototype.slice = function (start, end) {
            start = toInteger(start)

            var result = this
            if (result.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result)
            }
            if (start < 0) {
              result = result.takeRight(-start)
            } else if (start) {
              result = result.drop(start)
            }
            if (end !== undefined) {
              end = toInteger(end)
              result =
                end < 0 ? result.dropRight(-end) : result.take(end - start)
            }
            return result
          }

          LazyWrapper.prototype.takeRightWhile = function (predicate) {
            return this.reverse().takeWhile(predicate).reverse()
          }

          LazyWrapper.prototype.toArray = function () {
            return this.take(MAX_ARRAY_LENGTH)
          }

          // Add `LazyWrapper` methods to `lodash.prototype`.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(
                methodName
              ),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc =
                lodash[
                  isTaker
                    ? 'take' + (methodName == 'last' ? 'Right' : '')
                    : methodName
                ],
              retUnwrapped = isTaker || /^find/.test(methodName)

            if (!lodashFunc) {
              return
            }
            lodash.prototype[methodName] = function () {
              var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value)

              var interceptor = function (value) {
                var result = lodashFunc.apply(lodash, arrayPush([value], args))
                return isTaker && chainAll ? result[0] : result
              }

              if (
                useLazy &&
                checkIteratee &&
                typeof iteratee == 'function' &&
                iteratee.length != 1
              ) {
                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                isLazy = useLazy = false
              }
              var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid

              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this)
                var result = func.apply(value, args)
                result.__actions__.push({
                  func: thru,
                  args: [interceptor],
                  thisArg: undefined
                })
                return new LodashWrapper(result, chainAll)
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args)
              }
              result = this.thru(interceptor)
              return isUnwrapped
                ? isTaker
                  ? result.value()[0]
                  : result.value()
                : result
            }
          })

          // Add `Array` methods to `lodash.prototype`.
          arrayEach(
            ['pop', 'push', 'shift', 'sort', 'splice', 'unshift'],
            function (methodName) {
              var func = arrayProto[methodName],
                chainName = /^(?:push|sort|unshift)$/.test(methodName)
                  ? 'tap'
                  : 'thru',
                retUnwrapped = /^(?:pop|shift)$/.test(methodName)

              lodash.prototype[methodName] = function () {
                var args = arguments
                if (retUnwrapped && !this.__chain__) {
                  var value = this.value()
                  return func.apply(isArray(value) ? value : [], args)
                }
                return this[chainName](function (value) {
                  return func.apply(isArray(value) ? value : [], args)
                })
              }
            }
          )

          // Map minified method names to their real names.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName]
            if (lodashFunc) {
              var key = lodashFunc.name + ''
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = []
              }
              realNames[key].push({ name: methodName, func: lodashFunc })
            }
          })

          realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [
            {
              name: 'wrapper',
              func: undefined
            }
          ]

          // Add methods to `LazyWrapper`.
          LazyWrapper.prototype.clone = lazyClone
          LazyWrapper.prototype.reverse = lazyReverse
          LazyWrapper.prototype.value = lazyValue

          // Add chain sequence methods to the `lodash` wrapper.
          lodash.prototype.at = wrapperAt
          lodash.prototype.chain = wrapperChain
          lodash.prototype.commit = wrapperCommit
          lodash.prototype.next = wrapperNext
          lodash.prototype.plant = wrapperPlant
          lodash.prototype.reverse = wrapperReverse
          lodash.prototype.toJSON =
            lodash.prototype.valueOf =
            lodash.prototype.value =
              wrapperValue

          // Add lazy aliases.
          lodash.prototype.first = lodash.prototype.head

          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator
          }
          return lodash
        }

        /*--------------------------------------------------------------------------*/

        // Export lodash.
        var _ = runInContext()

        // Some AMD build optimizers, like r.js, check for condition patterns like:
        if (true) {
          // Expose Lodash on the global object to prevent errors when Lodash is
          // loaded by a script tag in the presence of an AMD loader.
          // See http://requirejs.org/docs/errors.html#mismatch for more details.
          // Use `_.noConflict` to remove Lodash from the global object.
          root._ = _

          // Define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module.
          !((__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return _
          }.call(exports, __webpack_require__, exports, module)),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        }
        // Check for `exports` after `define` in case a build optimizer adds it.
        else {
        }
      }.call(this))

      /***/
    },

    /***/ 9462: /***/ (module) => {
      module.exports = Observable

      function Observable(value) {
        var listeners = []
        value = value === undefined ? null : value

        observable.set = function (v) {
          value = v
          listeners.forEach(function (f) {
            f(v)
          })
        }

        return observable

        function observable(listener) {
          if (!listener) {
            return value
          }

          listeners.push(listener)

          return function remove() {
            listeners.splice(listeners.indexOf(listener), 1)
          }
        }
      }

      /***/
    },

    /***/ 6470: /***/ (module) => {
      'use strict'
      // 'path' module extracted from Node.js v8.11.1 (only the posix part)
      // transplited with Babel

      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      function assertPath(path) {
        if (typeof path !== 'string') {
          throw new TypeError(
            'Path must be a string. Received ' + JSON.stringify(path)
          )
        }
      }

      // Resolves . and .. elements in a path with directory names
      function normalizeStringPosix(path, allowAboveRoot) {
        var res = ''
        var lastSegmentLength = 0
        var lastSlash = -1
        var dots = 0
        var code
        for (var i = 0; i <= path.length; ++i) {
          if (i < path.length) code = path.charCodeAt(i)
          else if (code === 47 /*/*/) break
          else code = 47 /*/*/
          if (code === 47 /*/*/) {
            if (lastSlash === i - 1 || dots === 1) {
              // NOOP
            } else if (lastSlash !== i - 1 && dots === 2) {
              if (
                res.length < 2 ||
                lastSegmentLength !== 2 ||
                res.charCodeAt(res.length - 1) !== 46 /*.*/ ||
                res.charCodeAt(res.length - 2) !== 46 /*.*/
              ) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf('/')
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = ''
                      lastSegmentLength = 0
                    } else {
                      res = res.slice(0, lastSlashIndex)
                      lastSegmentLength = res.length - 1 - res.lastIndexOf('/')
                    }
                    lastSlash = i
                    dots = 0
                    continue
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = ''
                  lastSegmentLength = 0
                  lastSlash = i
                  dots = 0
                  continue
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0) res += '/..'
                else res = '..'
                lastSegmentLength = 2
              }
            } else {
              if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i)
              else res = path.slice(lastSlash + 1, i)
              lastSegmentLength = i - lastSlash - 1
            }
            lastSlash = i
            dots = 0
          } else if (code === 46 /*.*/ && dots !== -1) {
            ++dots
          } else {
            dots = -1
          }
        }
        return res
      }

      function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root
        var base =
          pathObject.base || (pathObject.name || '') + (pathObject.ext || '')
        if (!dir) {
          return base
        }
        if (dir === pathObject.root) {
          return dir + base
        }
        return dir + sep + base
      }

      var posix = {
        // path.resolve([from ...], to)
        resolve: function resolve() {
          var resolvedPath = ''
          var resolvedAbsolute = false
          var cwd

          for (
            var i = arguments.length - 1;
            i >= -1 && !resolvedAbsolute;
            i--
          ) {
            var path
            if (i >= 0) path = arguments[i]
            else {
              if (cwd === undefined) cwd = process.cwd()
              path = cwd
            }

            assertPath(path)

            // Skip empty entries
            if (path.length === 0) {
              continue
            }

            resolvedPath = path + '/' + resolvedPath
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/
          }

          // At this point the path should be resolved to a full absolute path, but
          // handle relative paths to be safe (might happen when process.cwd() fails)

          // Normalize the path
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute)

          if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return '/' + resolvedPath
            else return '/'
          } else if (resolvedPath.length > 0) {
            return resolvedPath
          } else {
            return '.'
          }
        },

        normalize: function normalize(path) {
          assertPath(path)

          if (path.length === 0) return '.'

          var isAbsolute = path.charCodeAt(0) === 47 /*/*/
          var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/

          // Normalize the path
          path = normalizeStringPosix(path, !isAbsolute)

          if (path.length === 0 && !isAbsolute) path = '.'
          if (path.length > 0 && trailingSeparator) path += '/'

          if (isAbsolute) return '/' + path
          return path
        },

        isAbsolute: function isAbsolute(path) {
          assertPath(path)
          return path.length > 0 && path.charCodeAt(0) === 47 /*/*/
        },

        join: function join() {
          if (arguments.length === 0) return '.'
          var joined
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i]
            assertPath(arg)
            if (arg.length > 0) {
              if (joined === undefined) joined = arg
              else joined += '/' + arg
            }
          }
          if (joined === undefined) return '.'
          return posix.normalize(joined)
        },

        relative: function relative(from, to) {
          assertPath(from)
          assertPath(to)

          if (from === to) return ''

          from = posix.resolve(from)
          to = posix.resolve(to)

          if (from === to) return ''

          // Trim any leading backslashes
          var fromStart = 1
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47 /*/*/) break
          }
          var fromEnd = from.length
          var fromLen = fromEnd - fromStart

          // Trim any leading backslashes
          var toStart = 1
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47 /*/*/) break
          }
          var toEnd = to.length
          var toLen = toEnd - toStart

          // Compare paths to find the longest common path from root
          var length = fromLen < toLen ? fromLen : toLen
          var lastCommonSep = -1
          var i = 0
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                  // We get here if `from` is the exact base path for `to`.
                  // For example: from='/foo/bar'; to='/foo/bar/baz'
                  return to.slice(toStart + i + 1)
                } else if (i === 0) {
                  // We get here if `from` is the root
                  // For example: from='/'; to='/foo'
                  return to.slice(toStart + i)
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                  // We get here if `to` is the exact base path for `from`.
                  // For example: from='/foo/bar/baz'; to='/foo/bar'
                  lastCommonSep = i
                } else if (i === 0) {
                  // We get here if `to` is the root.
                  // For example: from='/foo'; to='/'
                  lastCommonSep = 0
                }
              }
              break
            }
            var fromCode = from.charCodeAt(fromStart + i)
            var toCode = to.charCodeAt(toStart + i)
            if (fromCode !== toCode) break
            else if (fromCode === 47 /*/*/) lastCommonSep = i
          }

          var out = ''
          // Generate the relative path based on the path difference between `to`
          // and `from`
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
              if (out.length === 0) out += '..'
              else out += '/..'
            }
          }

          // Lastly, append the rest of the destination (`to`) path that comes after
          // the common path parts
          if (out.length > 0) return out + to.slice(toStart + lastCommonSep)
          else {
            toStart += lastCommonSep
            if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart
            return to.slice(toStart)
          }
        },

        _makeLong: function _makeLong(path) {
          return path
        },

        dirname: function dirname(path) {
          assertPath(path)
          if (path.length === 0) return '.'
          var code = path.charCodeAt(0)
          var hasRoot = code === 47 /*/*/
          var end = -1
          var matchedSlash = true
          for (var i = path.length - 1; i >= 1; --i) {
            code = path.charCodeAt(i)
            if (code === 47 /*/*/) {
              if (!matchedSlash) {
                end = i
                break
              }
            } else {
              // We saw the first non-path separator
              matchedSlash = false
            }
          }

          if (end === -1) return hasRoot ? '/' : '.'
          if (hasRoot && end === 1) return '//'
          return path.slice(0, end)
        },

        basename: function basename(path, ext) {
          if (ext !== undefined && typeof ext !== 'string')
            throw new TypeError('"ext" argument must be a string')
          assertPath(path)

          var start = 0
          var end = -1
          var matchedSlash = true
          var i

          if (
            ext !== undefined &&
            ext.length > 0 &&
            ext.length <= path.length
          ) {
            if (ext.length === path.length && ext === path) return ''
            var extIdx = ext.length - 1
            var firstNonSlashEnd = -1
            for (i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i)
              if (code === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  start = i + 1
                  break
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  // We saw the first non-path separator, remember this index in case
                  // we need it if the extension ends up not matching
                  matchedSlash = false
                  firstNonSlashEnd = i + 1
                }
                if (extIdx >= 0) {
                  // Try to match the explicit extension
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      // We matched the extension, so mark this as the end of our path
                      // component
                      end = i
                    }
                  } else {
                    // Extension does not match, so our result is the entire path
                    // component
                    extIdx = -1
                    end = firstNonSlashEnd
                  }
                }
              }
            }

            if (start === end) end = firstNonSlashEnd
            else if (end === -1) end = path.length
            return path.slice(start, end)
          } else {
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  start = i + 1
                  break
                }
              } else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false
                end = i + 1
              }
            }

            if (end === -1) return ''
            return path.slice(start, end)
          }
        },

        extname: function extname(path) {
          assertPath(path)
          var startDot = -1
          var startPart = 0
          var end = -1
          var matchedSlash = true
          // Track the state of characters (if any) we see before our first dot and
          // after any path separator we find
          var preDotState = 0
          for (var i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i)
            if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1
                break
              }
              continue
            }
            if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // extension
              matchedSlash = false
              end = i + 1
            }
            if (code === 46 /*.*/) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1) startDot = i
              else if (preDotState !== 1) preDotState = 1
            } else if (startDot !== -1) {
              // We saw a non-dot and non-path separator before our dot, so we should
              // have a good chance at having a non-empty extension
              preDotState = -1
            }
          }

          if (
            startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
              startDot === end - 1 &&
              startDot === startPart + 1)
          ) {
            return ''
          }
          return path.slice(startDot, end)
        },

        format: function format(pathObject) {
          if (pathObject === null || typeof pathObject !== 'object') {
            throw new TypeError(
              'The "pathObject" argument must be of type Object. Received type ' +
                typeof pathObject
            )
          }
          return _format('/', pathObject)
        },

        parse: function parse(path) {
          assertPath(path)

          var ret = { root: '', dir: '', base: '', ext: '', name: '' }
          if (path.length === 0) return ret
          var code = path.charCodeAt(0)
          var isAbsolute = code === 47 /*/*/
          var start
          if (isAbsolute) {
            ret.root = '/'
            start = 1
          } else {
            start = 0
          }
          var startDot = -1
          var startPart = 0
          var end = -1
          var matchedSlash = true
          var i = path.length - 1

          // Track the state of characters (if any) we see before our first dot and
          // after any path separator we find
          var preDotState = 0

          // Get non-dir info
          for (; i >= start; --i) {
            code = path.charCodeAt(i)
            if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1
                break
              }
              continue
            }
            if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // extension
              matchedSlash = false
              end = i + 1
            }
            if (code === 46 /*.*/) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1) startDot = i
              else if (preDotState !== 1) preDotState = 1
            } else if (startDot !== -1) {
              // We saw a non-dot and non-path separator before our dot, so we should
              // have a good chance at having a non-empty extension
              preDotState = -1
            }
          }

          if (
            startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
              startDot === end - 1 &&
              startDot === startPart + 1)
          ) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path.slice(1, end)
              else ret.base = ret.name = path.slice(startPart, end)
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path.slice(1, startDot)
              ret.base = path.slice(1, end)
            } else {
              ret.name = path.slice(startPart, startDot)
              ret.base = path.slice(startPart, end)
            }
            ret.ext = path.slice(startDot, end)
          }

          if (startPart > 0) ret.dir = path.slice(0, startPart - 1)
          else if (isAbsolute) ret.dir = '/'

          return ret
        },

        sep: '/',
        delimiter: ':',
        win32: null,
        posix: null
      }

      posix.posix = posix

      module.exports = posix

      /***/
    },

    /***/ 5346: /***/ function (module) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i]
          descriptor.enumerable = descriptor.enumerable || false
          descriptor.configurable = true
          if ('value' in descriptor) descriptor.writable = true
          Object.defineProperty(target, descriptor.key, descriptor)
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps)
        if (staticProps) _defineProperties(Constructor, staticProps)
        return Constructor
      }

      /**
       * Sticky.js
       * Library for sticky elements written in vanilla javascript. With this library you can easily set sticky elements on your website. It's also responsive.
       *
       * @version 1.3.0
       * @author Rafal Galus <biuro@rafalgalus.pl>
       * @website https://rgalus.github.io/sticky-js/
       * @repo https://github.com/rgalus/sticky-js
       * @license https://github.com/rgalus/sticky-js/blob/master/LICENSE
       */
      var Sticky = /*#__PURE__*/ (function () {
        /**
         * Sticky instance constructor
         * @constructor
         * @param {string} selector - Selector which we can find elements
         * @param {string} options - Global options for sticky elements (could be overwritten by data-{option}="" attributes)
         */
        function Sticky() {
          var selector =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : ''
          var options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          _classCallCheck(this, Sticky)

          this.selector = selector
          this.elements = []
          this.version = '1.3.0'
          this.vp = this.getViewportSize()
          this.body = document.querySelector('body')
          this.options = {
            wrap: options.wrap || false,
            wrapWith: options.wrapWith || '<span></span>',
            marginTop: options.marginTop || 0,
            marginBottom: options.marginBottom || 0,
            stickyFor: options.stickyFor || 0,
            stickyClass: options.stickyClass || null,
            stickyContainer: options.stickyContainer || 'body'
          }
          this.updateScrollTopPosition = this.updateScrollTopPosition.bind(this)
          this.updateScrollTopPosition()
          window.addEventListener('load', this.updateScrollTopPosition)
          window.addEventListener('scroll', this.updateScrollTopPosition)
          this.run()
        }
        /**
         * Function that waits for page to be fully loaded and then renders & activates every sticky element found with specified selector
         * @function
         */

        _createClass(Sticky, [
          {
            key: 'run',
            value: function run() {
              var _this = this

              // wait for page to be fully loaded
              var pageLoaded = setInterval(function () {
                if (document.readyState === 'complete') {
                  clearInterval(pageLoaded)
                  var elements = document.querySelectorAll(_this.selector)

                  _this.forEach(elements, function (element) {
                    return _this.renderElement(element)
                  })
                }
              }, 10)
            }
            /**
             * Function that assign needed variables for sticky element, that are used in future for calculations and other
             * @function
             * @param {node} element - Element to be rendered
             */
          },
          {
            key: 'renderElement',
            value: function renderElement(element) {
              var _this2 = this

              // create container for variables needed in future
              element.sticky = {} // set default variables

              element.sticky.active = false
              element.sticky.marginTop =
                parseInt(element.getAttribute('data-margin-top')) ||
                this.options.marginTop
              element.sticky.marginBottom =
                parseInt(element.getAttribute('data-margin-bottom')) ||
                this.options.marginBottom
              element.sticky.stickyFor =
                parseInt(element.getAttribute('data-sticky-for')) ||
                this.options.stickyFor
              element.sticky.stickyClass =
                element.getAttribute('data-sticky-class') ||
                this.options.stickyClass
              element.sticky.wrap = element.hasAttribute('data-sticky-wrap')
                ? true
                : this.options.wrap // @todo attribute for stickyContainer
              // element.sticky.stickyContainer = element.getAttribute('data-sticky-container') || this.options.stickyContainer;

              element.sticky.stickyContainer = this.options.stickyContainer
              element.sticky.container = this.getStickyContainer(element)
              element.sticky.container.rect = this.getRectangle(
                element.sticky.container
              )
              element.sticky.rect = this.getRectangle(element) // fix when element is image that has not yet loaded and width, height = 0

              if (element.tagName.toLowerCase() === 'img') {
                element.onload = function () {
                  return (element.sticky.rect = _this2.getRectangle(element))
                }
              }

              if (element.sticky.wrap) {
                this.wrapElement(element)
              } // activate rendered element

              this.activate(element)
            }
            /**
             * Wraps element into placeholder element
             * @function
             * @param {node} element - Element to be wrapped
             */
          },
          {
            key: 'wrapElement',
            value: function wrapElement(element) {
              element.insertAdjacentHTML(
                'beforebegin',
                element.getAttribute('data-sticky-wrapWith') ||
                  this.options.wrapWith
              )
              element.previousSibling.appendChild(element)
            }
            /**
             * Function that activates element when specified conditions are met and then initalise events
             * @function
             * @param {node} element - Element to be activated
             */
          },
          {
            key: 'activate',
            value: function activate(element) {
              if (
                element.sticky.rect.top + element.sticky.rect.height <
                  element.sticky.container.rect.top +
                    element.sticky.container.rect.height &&
                element.sticky.stickyFor < this.vp.width &&
                !element.sticky.active
              ) {
                element.sticky.active = true
              }

              if (this.elements.indexOf(element) < 0) {
                this.elements.push(element)
              }

              if (!element.sticky.resizeEvent) {
                this.initResizeEvents(element)
                element.sticky.resizeEvent = true
              }

              if (!element.sticky.scrollEvent) {
                this.initScrollEvents(element)
                element.sticky.scrollEvent = true
              }

              this.setPosition(element)
            }
            /**
             * Function which is adding onResizeEvents to window listener and assigns function to element as resizeListener
             * @function
             * @param {node} element - Element for which resize events are initialised
             */
          },
          {
            key: 'initResizeEvents',
            value: function initResizeEvents(element) {
              var _this3 = this

              element.sticky.resizeListener = function () {
                return _this3.onResizeEvents(element)
              }

              window.addEventListener('resize', element.sticky.resizeListener)
            }
            /**
             * Removes element listener from resize event
             * @function
             * @param {node} element - Element from which listener is deleted
             */
          },
          {
            key: 'destroyResizeEvents',
            value: function destroyResizeEvents(element) {
              window.removeEventListener(
                'resize',
                element.sticky.resizeListener
              )
            }
            /**
             * Function which is fired when user resize window. It checks if element should be activated or deactivated and then run setPosition function
             * @function
             * @param {node} element - Element for which event function is fired
             */
          },
          {
            key: 'onResizeEvents',
            value: function onResizeEvents(element) {
              this.vp = this.getViewportSize()
              element.sticky.rect = this.getRectangle(element)
              element.sticky.container.rect = this.getRectangle(
                element.sticky.container
              )

              if (
                element.sticky.rect.top + element.sticky.rect.height <
                  element.sticky.container.rect.top +
                    element.sticky.container.rect.height &&
                element.sticky.stickyFor < this.vp.width &&
                !element.sticky.active
              ) {
                element.sticky.active = true
              } else if (
                element.sticky.rect.top + element.sticky.rect.height >=
                  element.sticky.container.rect.top +
                    element.sticky.container.rect.height ||
                (element.sticky.stickyFor >= this.vp.width &&
                  element.sticky.active)
              ) {
                element.sticky.active = false
              }

              this.setPosition(element)
            }
            /**
             * Function which is adding onScrollEvents to window listener and assigns function to element as scrollListener
             * @function
             * @param {node} element - Element for which scroll events are initialised
             */
          },
          {
            key: 'initScrollEvents',
            value: function initScrollEvents(element) {
              var _this4 = this

              element.sticky.scrollListener = function () {
                return _this4.onScrollEvents(element)
              }

              window.addEventListener('scroll', element.sticky.scrollListener)
            }
            /**
             * Removes element listener from scroll event
             * @function
             * @param {node} element - Element from which listener is deleted
             */
          },
          {
            key: 'destroyScrollEvents',
            value: function destroyScrollEvents(element) {
              window.removeEventListener(
                'scroll',
                element.sticky.scrollListener
              )
            }
            /**
             * Function which is fired when user scroll window. If element is active, function is invoking setPosition function
             * @function
             * @param {node} element - Element for which event function is fired
             */
          },
          {
            key: 'onScrollEvents',
            value: function onScrollEvents(element) {
              if (element.sticky && element.sticky.active) {
                this.setPosition(element)
              }
            }
            /**
             * Main function for the library. Here are some condition calculations and css appending for sticky element when user scroll window
             * @function
             * @param {node} element - Element that will be positioned if it's active
             */
          },
          {
            key: 'setPosition',
            value: function setPosition(element) {
              this.css(element, {
                position: '',
                width: '',
                top: '',
                left: ''
              })

              if (
                this.vp.height < element.sticky.rect.height ||
                !element.sticky.active
              ) {
                return
              }

              if (!element.sticky.rect.width) {
                element.sticky.rect = this.getRectangle(element)
              }

              if (element.sticky.wrap) {
                this.css(element.parentNode, {
                  display: 'block',
                  width: element.sticky.rect.width + 'px',
                  height: element.sticky.rect.height + 'px'
                })
              }

              if (
                element.sticky.rect.top === 0 &&
                element.sticky.container === this.body
              ) {
                this.css(element, {
                  position: 'fixed',
                  top: element.sticky.rect.top + 'px',
                  left: element.sticky.rect.left + 'px',
                  width: element.sticky.rect.width + 'px'
                })

                if (element.sticky.stickyClass) {
                  element.classList.add(element.sticky.stickyClass)
                }
              } else if (
                this.scrollTop >
                element.sticky.rect.top - element.sticky.marginTop
              ) {
                this.css(element, {
                  position: 'fixed',
                  width: element.sticky.rect.width + 'px',
                  left: element.sticky.rect.left + 'px'
                })

                if (
                  this.scrollTop +
                    element.sticky.rect.height +
                    element.sticky.marginTop >
                  element.sticky.container.rect.top +
                    element.sticky.container.offsetHeight -
                    element.sticky.marginBottom
                ) {
                  if (element.sticky.stickyClass) {
                    element.classList.remove(element.sticky.stickyClass)
                  }

                  this.css(element, {
                    top:
                      element.sticky.container.rect.top +
                      element.sticky.container.offsetHeight -
                      (this.scrollTop +
                        element.sticky.rect.height +
                        element.sticky.marginBottom) +
                      'px'
                  })
                } else {
                  if (element.sticky.stickyClass) {
                    element.classList.add(element.sticky.stickyClass)
                  }

                  this.css(element, {
                    top: element.sticky.marginTop + 'px'
                  })
                }
              } else {
                if (element.sticky.stickyClass) {
                  element.classList.remove(element.sticky.stickyClass)
                }

                this.css(element, {
                  position: '',
                  width: '',
                  top: '',
                  left: ''
                })

                if (element.sticky.wrap) {
                  this.css(element.parentNode, {
                    display: '',
                    width: '',
                    height: ''
                  })
                }
              }
            }
            /**
             * Function that updates element sticky rectangle (with sticky container), then activate or deactivate element, then update position if it's active
             * @function
             */
          },
          {
            key: 'update',
            value: function update() {
              var _this5 = this

              this.forEach(this.elements, function (element) {
                element.sticky.rect = _this5.getRectangle(element)
                element.sticky.container.rect = _this5.getRectangle(
                  element.sticky.container
                )

                _this5.activate(element)

                _this5.setPosition(element)
              })
            }
            /**
             * Destroys sticky element, remove listeners
             * @function
             */
          },
          {
            key: 'destroy',
            value: function destroy() {
              var _this6 = this

              window.removeEventListener('load', this.updateScrollTopPosition)
              window.removeEventListener('scroll', this.updateScrollTopPosition)
              this.forEach(this.elements, function (element) {
                _this6.destroyResizeEvents(element)

                _this6.destroyScrollEvents(element)

                delete element.sticky
              })
            }
            /**
             * Function that returns container element in which sticky element is stuck (if is not specified, then it's stuck to body)
             * @function
             * @param {node} element - Element which sticky container are looked for
             * @return {node} element - Sticky container
             */
          },
          {
            key: 'getStickyContainer',
            value: function getStickyContainer(element) {
              var container = element.parentNode

              while (
                !container.hasAttribute('data-sticky-container') &&
                !container.parentNode.querySelector(
                  element.sticky.stickyContainer
                ) &&
                container !== this.body
              ) {
                container = container.parentNode
              }

              return container
            }
            /**
             * Function that returns element rectangle & position (width, height, top, left)
             * @function
             * @param {node} element - Element which position & rectangle are returned
             * @return {object}
             */
          },
          {
            key: 'getRectangle',
            value: function getRectangle(element) {
              this.css(element, {
                position: '',
                width: '',
                top: '',
                left: ''
              })
              var width = Math.max(
                element.offsetWidth,
                element.clientWidth,
                element.scrollWidth
              )
              var height = Math.max(
                element.offsetHeight,
                element.clientHeight,
                element.scrollHeight
              )
              var top = 0
              var left = 0

              do {
                top += element.offsetTop || 0
                left += element.offsetLeft || 0
                element = element.offsetParent
              } while (element)

              return {
                top: top,
                left: left,
                width: width,
                height: height
              }
            }
            /**
             * Function that returns viewport dimensions
             * @function
             * @return {object}
             */
          },
          {
            key: 'getViewportSize',
            value: function getViewportSize() {
              return {
                width: Math.max(
                  document.documentElement.clientWidth,
                  window.innerWidth || 0
                ),
                height: Math.max(
                  document.documentElement.clientHeight,
                  window.innerHeight || 0
                )
              }
            }
            /**
             * Function that updates window scroll position
             * @function
             * @return {number}
             */
          },
          {
            key: 'updateScrollTopPosition',
            value: function updateScrollTopPosition() {
              this.scrollTop =
                (window.pageYOffset || document.scrollTop) -
                  (document.clientTop || 0) || 0
            }
            /**
             * Helper function for loops
             * @helper
             * @param {array}
             * @param {function} callback - Callback function (no need for explanation)
             */
          },
          {
            key: 'forEach',
            value: function forEach(array, callback) {
              for (var i = 0, len = array.length; i < len; i++) {
                callback(array[i])
              }
            }
            /**
             * Helper function to add/remove css properties for specified element.
             * @helper
             * @param {node} element - DOM element
             * @param {object} properties - CSS properties that will be added/removed from specified element
             */
          },
          {
            key: 'css',
            value: function css(element, properties) {
              for (var property in properties) {
                if (properties.hasOwnProperty(property)) {
                  element.style[property] = properties[property]
                }
              }
            }
          }
        ])

        return Sticky
      })()
      /**
       * Export function that supports AMD, CommonJS and Plain Browser.
       */

      ;(function (root, factory) {
        if (true) {
          module.exports = factory
        } else {
        }
      })(this, Sticky)

      /***/
    },

    /***/ 5820: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      var Sticky = __webpack_require__(5346)

      module.exports = Sticky

      /***/
    },

    /***/ 9623: /***/ (module) => {
      module.exports = throttle

      /**
       * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.
       *
       * @param {Function} func Function to wrap.
       * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.
       * @return {Function} A new function that wraps the `func` function passed in.
       */

      function throttle(func, wait) {
        var ctx, args, rtn, timeoutID // caching
        var last = 0

        return function throttled() {
          ctx = this
          args = arguments
          var delta = new Date() - last
          if (!timeoutID)
            if (delta >= wait) call()
            else timeoutID = setTimeout(call, wait - delta)
          return rtn
        }

        function call() {
          timeoutID = 0
          last = +new Date()
          rtn = func.apply(ctx, args)
          ctx = null
          args = null
        }
      }

      /***/
    },

    /***/ 540: /***/ function (__unused_webpack_module, exports) {
      /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
      ;(function (global, factory) {
        true ? factory(exports) : 0
      })(this, function (exports) {
        'use strict'

        function merge() {
          for (
            var _len = arguments.length, sets = Array(_len), _key = 0;
            _key < _len;
            _key++
          ) {
            sets[_key] = arguments[_key]
          }

          if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1)
            var xl = sets.length - 1
            for (var x = 1; x < xl; ++x) {
              sets[x] = sets[x].slice(1, -1)
            }
            sets[xl] = sets[xl].slice(1)
            return sets.join('')
          } else {
            return sets[0]
          }
        }
        function subexp(str) {
          return '(?:' + str + ')'
        }
        function typeOf(o) {
          return o === undefined
            ? 'undefined'
            : o === null
            ? 'null'
            : Object.prototype.toString
                .call(o)
                .split(' ')
                .pop()
                .split(']')
                .shift()
                .toLowerCase()
        }
        function toUpperCase(str) {
          return str.toUpperCase()
        }
        function toArray(obj) {
          return obj !== undefined && obj !== null
            ? obj instanceof Array
              ? obj
              : typeof obj.length !== 'number' ||
                obj.split ||
                obj.setInterval ||
                obj.call
              ? [obj]
              : Array.prototype.slice.call(obj)
            : []
        }
        function assign(target, source) {
          var obj = target
          if (source) {
            for (var key in source) {
              obj[key] = source[key]
            }
          }
          return obj
        }

        function buildExps(isIRI) {
          var ALPHA$$ = '[A-Za-z]',
            CR$ = '[\\x0D]',
            DIGIT$$ = '[0-9]',
            DQUOTE$$ = '[\\x22]',
            HEXDIG$$ = merge(DIGIT$$, '[A-Fa-f]'),
            //case-insensitive
            LF$$ = '[\\x0A]',
            SP$$ = '[\\x20]',
            PCT_ENCODED$ = subexp(
              subexp(
                '%[EFef]' +
                  HEXDIG$$ +
                  '%' +
                  HEXDIG$$ +
                  HEXDIG$$ +
                  '%' +
                  HEXDIG$$ +
                  HEXDIG$$
              ) +
                '|' +
                subexp('%[89A-Fa-f]' + HEXDIG$$ + '%' + HEXDIG$$ + HEXDIG$$) +
                '|' +
                subexp('%' + HEXDIG$$ + HEXDIG$$)
            ),
            //expanded
            GEN_DELIMS$$ = '[\\:\\/\\?\\#\\[\\]\\@]',
            SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
            RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
            UCSCHAR$$ = isIRI
              ? '[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]'
              : '[]',
            //subset, excludes bidi control characters
            IPRIVATE$$ = isIRI ? '[\\uE000-\\uF8FF]' : '[]',
            //subset
            UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, '[\\-\\.\\_\\~]', UCSCHAR$$),
            SCHEME$ = subexp(
              ALPHA$$ + merge(ALPHA$$, DIGIT$$, '[\\+\\-\\.]') + '*'
            ),
            USERINFO$ = subexp(
              subexp(
                PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$, '[\\:]')
              ) + '*'
            ),
            DEC_OCTET$ = subexp(
              subexp('25[0-5]') +
                '|' +
                subexp('2[0-4]' + DIGIT$$) +
                '|' +
                subexp('1' + DIGIT$$ + DIGIT$$) +
                '|' +
                subexp('[1-9]' + DIGIT$$) +
                '|' +
                DIGIT$$
            ),
            DEC_OCTET_RELAXED$ = subexp(
              subexp('25[0-5]') +
                '|' +
                subexp('2[0-4]' + DIGIT$$) +
                '|' +
                subexp('1' + DIGIT$$ + DIGIT$$) +
                '|' +
                subexp('0?[1-9]' + DIGIT$$) +
                '|0?0?' +
                DIGIT$$
            ),
            //relaxed parsing rules
            IPV4ADDRESS$ = subexp(
              DEC_OCTET_RELAXED$ +
                '\\.' +
                DEC_OCTET_RELAXED$ +
                '\\.' +
                DEC_OCTET_RELAXED$ +
                '\\.' +
                DEC_OCTET_RELAXED$
            ),
            H16$ = subexp(HEXDIG$$ + '{1,4}'),
            LS32$ = subexp(subexp(H16$ + '\\:' + H16$) + '|' + IPV4ADDRESS$),
            IPV6ADDRESS1$ = subexp(subexp(H16$ + '\\:') + '{6}' + LS32$),
            //                           6( h16 ":" ) ls32
            IPV6ADDRESS2$ = subexp(
              '\\:\\:' + subexp(H16$ + '\\:') + '{5}' + LS32$
            ),
            //                      "::" 5( h16 ":" ) ls32
            IPV6ADDRESS3$ = subexp(
              subexp(H16$) + '?\\:\\:' + subexp(H16$ + '\\:') + '{4}' + LS32$
            ),
            //[               h16 ] "::" 4( h16 ":" ) ls32
            IPV6ADDRESS4$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,1}' + H16$) +
                '?\\:\\:' +
                subexp(H16$ + '\\:') +
                '{3}' +
                LS32$
            ),
            //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
            IPV6ADDRESS5$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,2}' + H16$) +
                '?\\:\\:' +
                subexp(H16$ + '\\:') +
                '{2}' +
                LS32$
            ),
            //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
            IPV6ADDRESS6$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,3}' + H16$) +
                '?\\:\\:' +
                H16$ +
                '\\:' +
                LS32$
            ),
            //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
            IPV6ADDRESS7$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,4}' + H16$) + '?\\:\\:' + LS32$
            ),
            //[ *4( h16 ":" ) h16 ] "::"              ls32
            IPV6ADDRESS8$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,5}' + H16$) + '?\\:\\:' + H16$
            ),
            //[ *5( h16 ":" ) h16 ] "::"              h16
            IPV6ADDRESS9$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,6}' + H16$) + '?\\:\\:'
            ),
            //[ *6( h16 ":" ) h16 ] "::"
            IPV6ADDRESS$ = subexp(
              [
                IPV6ADDRESS1$,
                IPV6ADDRESS2$,
                IPV6ADDRESS3$,
                IPV6ADDRESS4$,
                IPV6ADDRESS5$,
                IPV6ADDRESS6$,
                IPV6ADDRESS7$,
                IPV6ADDRESS8$,
                IPV6ADDRESS9$
              ].join('|')
            ),
            ZONEID$ = subexp(subexp(UNRESERVED$$ + '|' + PCT_ENCODED$) + '+'),
            //RFC 6874
            IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + '\\%25' + ZONEID$),
            //RFC 6874
            IPV6ADDRZ_RELAXED$ = subexp(
              IPV6ADDRESS$ +
                subexp('\\%25|\\%(?!' + HEXDIG$$ + '{2})') +
                ZONEID$
            ),
            //RFC 6874, with relaxed parsing rules
            IPVFUTURE$ = subexp(
              '[vV]' +
                HEXDIG$$ +
                '+\\.' +
                merge(UNRESERVED$$, SUB_DELIMS$$, '[\\:]') +
                '+'
            ),
            IP_LITERAL$ = subexp(
              '\\[' +
                subexp(
                  IPV6ADDRZ_RELAXED$ + '|' + IPV6ADDRESS$ + '|' + IPVFUTURE$
                ) +
                '\\]'
            ),
            //RFC 6874
            REG_NAME$ = subexp(
              subexp(PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$)) +
                '*'
            ),
            HOST$ = subexp(
              IP_LITERAL$ +
                '|' +
                IPV4ADDRESS$ +
                '(?!' +
                REG_NAME$ +
                ')' +
                '|' +
                REG_NAME$
            ),
            PORT$ = subexp(DIGIT$$ + '*'),
            AUTHORITY$ = subexp(
              subexp(USERINFO$ + '@') +
                '?' +
                HOST$ +
                subexp('\\:' + PORT$) +
                '?'
            ),
            PCHAR$ = subexp(
              PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$, '[\\:\\@]')
            ),
            SEGMENT$ = subexp(PCHAR$ + '*'),
            SEGMENT_NZ$ = subexp(PCHAR$ + '+'),
            SEGMENT_NZ_NC$ = subexp(
              subexp(
                PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$, '[\\@]')
              ) + '+'
            ),
            PATH_ABEMPTY$ = subexp(subexp('\\/' + SEGMENT$) + '*'),
            PATH_ABSOLUTE$ = subexp(
              '\\/' + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + '?'
            ),
            //simplified
            PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
            //simplified
            PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
            //simplified
            PATH_EMPTY$ = '(?!' + PCHAR$ + ')',
            PATH$ = subexp(
              PATH_ABEMPTY$ +
                '|' +
                PATH_ABSOLUTE$ +
                '|' +
                PATH_NOSCHEME$ +
                '|' +
                PATH_ROOTLESS$ +
                '|' +
                PATH_EMPTY$
            ),
            QUERY$ = subexp(
              subexp(PCHAR$ + '|' + merge('[\\/\\?]', IPRIVATE$$)) + '*'
            ),
            FRAGMENT$ = subexp(subexp(PCHAR$ + '|[\\/\\?]') + '*'),
            HIER_PART$ = subexp(
              subexp('\\/\\/' + AUTHORITY$ + PATH_ABEMPTY$) +
                '|' +
                PATH_ABSOLUTE$ +
                '|' +
                PATH_ROOTLESS$ +
                '|' +
                PATH_EMPTY$
            ),
            URI$ = subexp(
              SCHEME$ +
                '\\:' +
                HIER_PART$ +
                subexp('\\?' + QUERY$) +
                '?' +
                subexp('\\#' + FRAGMENT$) +
                '?'
            ),
            RELATIVE_PART$ = subexp(
              subexp('\\/\\/' + AUTHORITY$ + PATH_ABEMPTY$) +
                '|' +
                PATH_ABSOLUTE$ +
                '|' +
                PATH_NOSCHEME$ +
                '|' +
                PATH_EMPTY$
            ),
            RELATIVE$ = subexp(
              RELATIVE_PART$ +
                subexp('\\?' + QUERY$) +
                '?' +
                subexp('\\#' + FRAGMENT$) +
                '?'
            ),
            URI_REFERENCE$ = subexp(URI$ + '|' + RELATIVE$),
            ABSOLUTE_URI$ = subexp(
              SCHEME$ + '\\:' + HIER_PART$ + subexp('\\?' + QUERY$) + '?'
            ),
            GENERIC_REF$ =
              '^(' +
              SCHEME$ +
              ')\\:' +
              subexp(
                subexp(
                  '\\/\\/(' +
                    subexp('(' + USERINFO$ + ')@') +
                    '?(' +
                    HOST$ +
                    ')' +
                    subexp('\\:(' + PORT$ + ')') +
                    '?)'
                ) +
                  '?(' +
                  PATH_ABEMPTY$ +
                  '|' +
                  PATH_ABSOLUTE$ +
                  '|' +
                  PATH_ROOTLESS$ +
                  '|' +
                  PATH_EMPTY$ +
                  ')'
              ) +
              subexp('\\?(' + QUERY$ + ')') +
              '?' +
              subexp('\\#(' + FRAGMENT$ + ')') +
              '?$',
            RELATIVE_REF$ =
              '^(){0}' +
              subexp(
                subexp(
                  '\\/\\/(' +
                    subexp('(' + USERINFO$ + ')@') +
                    '?(' +
                    HOST$ +
                    ')' +
                    subexp('\\:(' + PORT$ + ')') +
                    '?)'
                ) +
                  '?(' +
                  PATH_ABEMPTY$ +
                  '|' +
                  PATH_ABSOLUTE$ +
                  '|' +
                  PATH_NOSCHEME$ +
                  '|' +
                  PATH_EMPTY$ +
                  ')'
              ) +
              subexp('\\?(' + QUERY$ + ')') +
              '?' +
              subexp('\\#(' + FRAGMENT$ + ')') +
              '?$',
            ABSOLUTE_REF$ =
              '^(' +
              SCHEME$ +
              ')\\:' +
              subexp(
                subexp(
                  '\\/\\/(' +
                    subexp('(' + USERINFO$ + ')@') +
                    '?(' +
                    HOST$ +
                    ')' +
                    subexp('\\:(' + PORT$ + ')') +
                    '?)'
                ) +
                  '?(' +
                  PATH_ABEMPTY$ +
                  '|' +
                  PATH_ABSOLUTE$ +
                  '|' +
                  PATH_ROOTLESS$ +
                  '|' +
                  PATH_EMPTY$ +
                  ')'
              ) +
              subexp('\\?(' + QUERY$ + ')') +
              '?$',
            SAMEDOC_REF$ = '^' + subexp('\\#(' + FRAGMENT$ + ')') + '?$',
            AUTHORITY_REF$ =
              '^' +
              subexp('(' + USERINFO$ + ')@') +
              '?(' +
              HOST$ +
              ')' +
              subexp('\\:(' + PORT$ + ')') +
              '?$'
          return {
            NOT_SCHEME: new RegExp(
              merge('[^]', ALPHA$$, DIGIT$$, '[\\+\\-\\.]'),
              'g'
            ),
            NOT_USERINFO: new RegExp(
              merge('[^\\%\\:]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_HOST: new RegExp(
              merge('[^\\%\\[\\]\\:]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_PATH: new RegExp(
              merge('[^\\%\\/\\:\\@]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_PATH_NOSCHEME: new RegExp(
              merge('[^\\%\\/\\@]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_QUERY: new RegExp(
              merge(
                '[^\\%]',
                UNRESERVED$$,
                SUB_DELIMS$$,
                '[\\:\\@\\/\\?]',
                IPRIVATE$$
              ),
              'g'
            ),
            NOT_FRAGMENT: new RegExp(
              merge('[^\\%]', UNRESERVED$$, SUB_DELIMS$$, '[\\:\\@\\/\\?]'),
              'g'
            ),
            ESCAPE: new RegExp(merge('[^]', UNRESERVED$$, SUB_DELIMS$$), 'g'),
            UNRESERVED: new RegExp(UNRESERVED$$, 'g'),
            OTHER_CHARS: new RegExp(
              merge('[^\\%]', UNRESERVED$$, RESERVED$$),
              'g'
            ),
            PCT_ENCODED: new RegExp(PCT_ENCODED$, 'g'),
            IPV4ADDRESS: new RegExp('^(' + IPV4ADDRESS$ + ')$'),
            IPV6ADDRESS: new RegExp(
              '^\\[?(' +
                IPV6ADDRESS$ +
                ')' +
                subexp(
                  subexp('\\%25|\\%(?!' + HEXDIG$$ + '{2})') +
                    '(' +
                    ZONEID$ +
                    ')'
                ) +
                '?\\]?$'
            ) //RFC 6874, with relaxed parsing rules
          }
        }
        var URI_PROTOCOL = buildExps(false)

        var IRI_PROTOCOL = buildExps(true)

        var slicedToArray = (function () {
          function sliceIterator(arr, i) {
            var _arr = []
            var _n = true
            var _d = false
            var _e = undefined

            try {
              for (
                var _i = arr[Symbol.iterator](), _s;
                !(_n = (_s = _i.next()).done);
                _n = true
              ) {
                _arr.push(_s.value)

                if (i && _arr.length === i) break
              }
            } catch (err) {
              _d = true
              _e = err
            } finally {
              try {
                if (!_n && _i['return']) _i['return']()
              } finally {
                if (_d) throw _e
              }
            }

            return _arr
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i)
            } else {
              throw new TypeError(
                'Invalid attempt to destructure non-iterable instance'
              )
            }
          }
        })()

        var toConsumableArray = function (arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
              arr2[i] = arr[i]

            return arr2
          } else {
            return Array.from(arr)
          }
        }

        /** Highest positive signed 32-bit float value */

        var maxInt = 2147483647 // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        var base = 36
        var tMin = 1
        var tMax = 26
        var skew = 38
        var damp = 700
        var initialBias = 72
        var initialN = 128 // 0x80
        var delimiter = '-' // '\x2D'

        /** Regular expressions */
        var regexPunycode = /^xn--/
        var regexNonASCII = /[^\0-\x7E]/ // non-ASCII chars
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g // RFC 3490 separators

        /** Error messages */
        var errors = {
          overflow: 'Overflow: input needs wider integers to process',
          'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
          'invalid-input': 'Invalid input'
        }

        /** Convenience shortcuts */
        var baseMinusTMin = base - tMin
        var floor = Math.floor
        var stringFromCharCode = String.fromCharCode

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error$1(type) {
          throw new RangeError(errors[type])
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
          var result = []
          var length = array.length
          while (length--) {
            result[length] = fn(array[length])
          }
          return result
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
          var parts = string.split('@')
          var result = ''
          if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@'
            string = parts[1]
          }
          // Avoid `split(regex)` for IE8 compatibility. See #17.
          string = string.replace(regexSeparators, '\x2E')
          var labels = string.split('.')
          var encoded = map(labels, fn).join('.')
          return result + encoded
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
          var output = []
          var counter = 0
          var length = string.length
          while (counter < length) {
            var value = string.charCodeAt(counter++)
            if (value >= 0xd800 && value <= 0xdbff && counter < length) {
              // It's a high surrogate, and there is a next character.
              var extra = string.charCodeAt(counter++)
              if ((extra & 0xfc00) == 0xdc00) {
                // Low surrogate.
                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000)
              } else {
                // It's an unmatched surrogate; only append this code unit, in case the
                // next code unit is the high surrogate of a surrogate pair.
                output.push(value)
                counter--
              }
            } else {
              output.push(value)
            }
          }
          return output
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        var ucs2encode = function ucs2encode(array) {
          return String.fromCodePoint.apply(String, toConsumableArray(array))
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        var basicToDigit = function basicToDigit(codePoint) {
          if (codePoint - 0x30 < 0x0a) {
            return codePoint - 0x16
          }
          if (codePoint - 0x41 < 0x1a) {
            return codePoint - 0x41
          }
          if (codePoint - 0x61 < 0x1a) {
            return codePoint - 0x61
          }
          return base
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        var digitToBasic = function digitToBasic(digit, flag) {
          //  0..25 map to ASCII a..z or A..Z
          // 26..35 map to ASCII 0..9
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * https://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        var adapt = function adapt(delta, numPoints, firstTime) {
          var k = 0
          delta = firstTime ? floor(delta / damp) : delta >> 1
          delta += floor(delta / numPoints)
          for (
            ;
            /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
            k += base
          ) {
            delta = floor(delta / baseMinusTMin)
          }
          return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew))
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        var decode = function decode(input) {
          // Don't use UCS-2.
          var output = []
          var inputLength = input.length
          var i = 0
          var n = initialN
          var bias = initialBias

          // Handle the basic code points: let `basic` be the number of input code
          // points before the last delimiter, or `0` if there is none, then copy
          // the first basic code points to the output.

          var basic = input.lastIndexOf(delimiter)
          if (basic < 0) {
            basic = 0
          }

          for (var j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
              error$1('not-basic')
            }
            output.push(input.charCodeAt(j))
          }

          // Main decoding loop: start just after the last delimiter if any basic code
          // points were copied; start at the beginning otherwise.

          for (
            var index = basic > 0 ? basic + 1 : 0;
            index < inputLength;

          ) /* no final expression */ {
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            var oldi = i
            for (var w = 1, k = base; ; /* no condition */ k += base) {
              if (index >= inputLength) {
                error$1('invalid-input')
              }

              var digit = basicToDigit(input.charCodeAt(index++))

              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error$1('overflow')
              }

              i += digit * w
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias

              if (digit < t) {
                break
              }

              var baseMinusT = base - t
              if (w > floor(maxInt / baseMinusT)) {
                error$1('overflow')
              }

              w *= baseMinusT
            }

            var out = output.length + 1
            bias = adapt(i - oldi, out, oldi == 0)

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
              error$1('overflow')
            }

            n += floor(i / out)
            i %= out

            // Insert `n` at position `i` of the output.
            output.splice(i++, 0, n)
          }

          return String.fromCodePoint.apply(String, output)
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        var encode = function encode(input) {
          var output = []

          // Convert the input in UCS-2 to an array of Unicode code points.
          input = ucs2decode(input)

          // Cache the length.
          var inputLength = input.length

          // Initialize the state.
          var n = initialN
          var delta = 0
          var bias = initialBias

          // Handle the basic code points.
          var _iteratorNormalCompletion = true
          var _didIteratorError = false
          var _iteratorError = undefined

          try {
            for (
              var _iterator = input[Symbol.iterator](), _step;
              !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
              _iteratorNormalCompletion = true
            ) {
              var _currentValue2 = _step.value

              if (_currentValue2 < 0x80) {
                output.push(stringFromCharCode(_currentValue2))
              }
            }
          } catch (err) {
            _didIteratorError = true
            _iteratorError = err
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return()
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError
              }
            }
          }

          var basicLength = output.length
          var handledCPCount = basicLength

          // `handledCPCount` is the number of code points that have been handled;
          // `basicLength` is the number of basic code points.

          // Finish the basic string with a delimiter unless it's empty.
          if (basicLength) {
            output.push(delimiter)
          }

          // Main encoding loop:
          while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            var m = maxInt
            var _iteratorNormalCompletion2 = true
            var _didIteratorError2 = false
            var _iteratorError2 = undefined

            try {
              for (
                var _iterator2 = input[Symbol.iterator](), _step2;
                !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next())
                  .done);
                _iteratorNormalCompletion2 = true
              ) {
                var currentValue = _step2.value

                if (currentValue >= n && currentValue < m) {
                  m = currentValue
                }
              }

              // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
              // but guard against overflow.
            } catch (err) {
              _didIteratorError2 = true
              _iteratorError2 = err
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return()
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2
                }
              }
            }

            var handledCPCountPlusOne = handledCPCount + 1
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error$1('overflow')
            }

            delta += (m - n) * handledCPCountPlusOne
            n = m

            var _iteratorNormalCompletion3 = true
            var _didIteratorError3 = false
            var _iteratorError3 = undefined

            try {
              for (
                var _iterator3 = input[Symbol.iterator](), _step3;
                !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next())
                  .done);
                _iteratorNormalCompletion3 = true
              ) {
                var _currentValue = _step3.value

                if (_currentValue < n && ++delta > maxInt) {
                  error$1('overflow')
                }
                if (_currentValue == n) {
                  // Represent delta as a generalized variable-length integer.
                  var q = delta
                  for (var k = base; ; /* no condition */ k += base) {
                    var t =
                      k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
                    if (q < t) {
                      break
                    }
                    var qMinusT = q - t
                    var baseMinusT = base - t
                    output.push(
                      stringFromCharCode(
                        digitToBasic(t + (qMinusT % baseMinusT), 0)
                      )
                    )
                    q = floor(qMinusT / baseMinusT)
                  }

                  output.push(stringFromCharCode(digitToBasic(q, 0)))
                  bias = adapt(
                    delta,
                    handledCPCountPlusOne,
                    handledCPCount == basicLength
                  )
                  delta = 0
                  ++handledCPCount
                }
              }
            } catch (err) {
              _didIteratorError3 = true
              _iteratorError3 = err
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return()
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3
                }
              }
            }

            ++delta
            ++n
          }
          return output.join('')
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        var toUnicode = function toUnicode(input) {
          return mapDomain(input, function (string) {
            return regexPunycode.test(string)
              ? decode(string.slice(4).toLowerCase())
              : string
          })
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        var toASCII = function toASCII(input) {
          return mapDomain(input, function (string) {
            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string
          })
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        var punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          version: '2.1.0',
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          ucs2: {
            decode: ucs2decode,
            encode: ucs2encode
          },
          decode: decode,
          encode: encode,
          toASCII: toASCII,
          toUnicode: toUnicode
        }

        /**
         * URI.js
         *
         * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
         * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
         * @see http://github.com/garycourt/uri-js
         */
        /**
         * Copyright 2011 Gary Court. All rights reserved.
         *
         * Redistribution and use in source and binary forms, with or without modification, are
         * permitted provided that the following conditions are met:
         *
         *    1. Redistributions of source code must retain the above copyright notice, this list of
         *       conditions and the following disclaimer.
         *
         *    2. Redistributions in binary form must reproduce the above copyright notice, this list
         *       of conditions and the following disclaimer in the documentation and/or other materials
         *       provided with the distribution.
         *
         * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
         * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
         * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
         * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
         * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
         * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
         * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
         * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
         * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         *
         * The views and conclusions contained in the software and documentation are those of the
         * authors and should not be interpreted as representing official policies, either expressed
         * or implied, of Gary Court.
         */
        var SCHEMES = {}
        function pctEncChar(chr) {
          var c = chr.charCodeAt(0)
          var e = void 0
          if (c < 16) e = '%0' + c.toString(16).toUpperCase()
          else if (c < 128) e = '%' + c.toString(16).toUpperCase()
          else if (c < 2048)
            e =
              '%' +
              ((c >> 6) | 192).toString(16).toUpperCase() +
              '%' +
              ((c & 63) | 128).toString(16).toUpperCase()
          else
            e =
              '%' +
              ((c >> 12) | 224).toString(16).toUpperCase() +
              '%' +
              (((c >> 6) & 63) | 128).toString(16).toUpperCase() +
              '%' +
              ((c & 63) | 128).toString(16).toUpperCase()
          return e
        }
        function pctDecChars(str) {
          var newStr = ''
          var i = 0
          var il = str.length
          while (i < il) {
            var c = parseInt(str.substr(i + 1, 2), 16)
            if (c < 128) {
              newStr += String.fromCharCode(c)
              i += 3
            } else if (c >= 194 && c < 224) {
              if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16)
                newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63))
              } else {
                newStr += str.substr(i, 6)
              }
              i += 6
            } else if (c >= 224) {
              if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16)
                var c3 = parseInt(str.substr(i + 7, 2), 16)
                newStr += String.fromCharCode(
                  ((c & 15) << 12) | ((_c & 63) << 6) | (c3 & 63)
                )
              } else {
                newStr += str.substr(i, 9)
              }
              i += 9
            } else {
              newStr += str.substr(i, 3)
              i += 3
            }
          }
          return newStr
        }
        function _normalizeComponentEncoding(components, protocol) {
          function decodeUnreserved(str) {
            var decStr = pctDecChars(str)
            return !decStr.match(protocol.UNRESERVED) ? str : decStr
          }
          if (components.scheme)
            components.scheme = String(components.scheme)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .toLowerCase()
              .replace(protocol.NOT_SCHEME, '')
          if (components.userinfo !== undefined)
            components.userinfo = String(components.userinfo)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(protocol.NOT_USERINFO, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.host !== undefined)
            components.host = String(components.host)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .toLowerCase()
              .replace(protocol.NOT_HOST, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.path !== undefined)
            components.path = String(components.path)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(
                components.scheme
                  ? protocol.NOT_PATH
                  : protocol.NOT_PATH_NOSCHEME,
                pctEncChar
              )
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.query !== undefined)
            components.query = String(components.query)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(protocol.NOT_QUERY, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.fragment !== undefined)
            components.fragment = String(components.fragment)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(protocol.NOT_FRAGMENT, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          return components
        }

        function _stripLeadingZeros(str) {
          return str.replace(/^0*(.*)/, '$1') || '0'
        }
        function _normalizeIPv4(host, protocol) {
          var matches = host.match(protocol.IPV4ADDRESS) || []

          var _matches = slicedToArray(matches, 2),
            address = _matches[1]

          if (address) {
            return address.split('.').map(_stripLeadingZeros).join('.')
          } else {
            return host
          }
        }
        function _normalizeIPv6(host, protocol) {
          var matches = host.match(protocol.IPV6ADDRESS) || []

          var _matches2 = slicedToArray(matches, 3),
            address = _matches2[1],
            zone = _matches2[2]

          if (address) {
            var _address$toLowerCase$ = address
                .toLowerCase()
                .split('::')
                .reverse(),
              _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
              last = _address$toLowerCase$2[0],
              first = _address$toLowerCase$2[1]

            var firstFields = first
              ? first.split(':').map(_stripLeadingZeros)
              : []
            var lastFields = last.split(':').map(_stripLeadingZeros)
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(
              lastFields[lastFields.length - 1]
            )
            var fieldCount = isLastFieldIPv4Address ? 7 : 8
            var lastFieldsStart = lastFields.length - fieldCount
            var fields = Array(fieldCount)
            for (var x = 0; x < fieldCount; ++x) {
              fields[x] =
                firstFields[x] || lastFields[lastFieldsStart + x] || ''
            }
            if (isLastFieldIPv4Address) {
              fields[fieldCount - 1] = _normalizeIPv4(
                fields[fieldCount - 1],
                protocol
              )
            }
            var allZeroFields = fields.reduce(function (acc, field, index) {
              if (!field || field === '0') {
                var lastLongest = acc[acc.length - 1]
                if (
                  lastLongest &&
                  lastLongest.index + lastLongest.length === index
                ) {
                  lastLongest.length++
                } else {
                  acc.push({ index: index, length: 1 })
                }
              }
              return acc
            }, [])
            var longestZeroFields = allZeroFields.sort(function (a, b) {
              return b.length - a.length
            })[0]
            var newHost = void 0
            if (longestZeroFields && longestZeroFields.length > 1) {
              var newFirst = fields.slice(0, longestZeroFields.index)
              var newLast = fields.slice(
                longestZeroFields.index + longestZeroFields.length
              )
              newHost = newFirst.join(':') + '::' + newLast.join(':')
            } else {
              newHost = fields.join(':')
            }
            if (zone) {
              newHost += '%' + zone
            }
            return newHost
          } else {
            return host
          }
        }
        var URI_PARSE =
          /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i
        var NO_MATCH_IS_UNDEFINED = ''.match(/(){0}/)[1] === undefined
        function parse(uriString) {
          var options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          var components = {}
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL
          if (options.reference === 'suffix')
            uriString =
              (options.scheme ? options.scheme + ':' : '') + '//' + uriString
          var matches = uriString.match(URI_PARSE)
          if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
              //store each component
              components.scheme = matches[1]
              components.userinfo = matches[3]
              components.host = matches[4]
              components.port = parseInt(matches[5], 10)
              components.path = matches[6] || ''
              components.query = matches[7]
              components.fragment = matches[8]
              //fix port number
              if (isNaN(components.port)) {
                components.port = matches[5]
              }
            } else {
              //IE FIX for improper RegExp matching
              //store each component
              components.scheme = matches[1] || undefined
              components.userinfo =
                uriString.indexOf('@') !== -1 ? matches[3] : undefined
              components.host =
                uriString.indexOf('//') !== -1 ? matches[4] : undefined
              components.port = parseInt(matches[5], 10)
              components.path = matches[6] || ''
              components.query =
                uriString.indexOf('?') !== -1 ? matches[7] : undefined
              components.fragment =
                uriString.indexOf('#') !== -1 ? matches[8] : undefined
              //fix port number
              if (isNaN(components.port)) {
                components.port = uriString.match(
                  /\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/
                )
                  ? matches[4]
                  : undefined
              }
            }
            if (components.host) {
              //normalize IP hosts
              components.host = _normalizeIPv6(
                _normalizeIPv4(components.host, protocol),
                protocol
              )
            }
            //determine reference type
            if (
              components.scheme === undefined &&
              components.userinfo === undefined &&
              components.host === undefined &&
              components.port === undefined &&
              !components.path &&
              components.query === undefined
            ) {
              components.reference = 'same-document'
            } else if (components.scheme === undefined) {
              components.reference = 'relative'
            } else if (components.fragment === undefined) {
              components.reference = 'absolute'
            } else {
              components.reference = 'uri'
            }
            //check for reference errors
            if (
              options.reference &&
              options.reference !== 'suffix' &&
              options.reference !== components.reference
            ) {
              components.error =
                components.error ||
                'URI is not a ' + options.reference + ' reference.'
            }
            //find scheme handler
            var schemeHandler =
              SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]
            //check if scheme can't handle IRIs
            if (
              !options.unicodeSupport &&
              (!schemeHandler || !schemeHandler.unicodeSupport)
            ) {
              //if host component is a domain name
              if (
                components.host &&
                (options.domainHost ||
                  (schemeHandler && schemeHandler.domainHost))
              ) {
                //convert Unicode IDN -> ASCII IDN
                try {
                  components.host = punycode.toASCII(
                    components.host
                      .replace(protocol.PCT_ENCODED, pctDecChars)
                      .toLowerCase()
                  )
                } catch (e) {
                  components.error =
                    components.error ||
                    "Host's domain name can not be converted to ASCII via punycode: " +
                      e
                }
              }
              //convert IRI -> URI
              _normalizeComponentEncoding(components, URI_PROTOCOL)
            } else {
              //normalize encodings
              _normalizeComponentEncoding(components, protocol)
            }
            //perform scheme specific parsing
            if (schemeHandler && schemeHandler.parse) {
              schemeHandler.parse(components, options)
            }
          } else {
            components.error = components.error || 'URI can not be parsed.'
          }
          return components
        }

        function _recomposeAuthority(components, options) {
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL
          var uriTokens = []
          if (components.userinfo !== undefined) {
            uriTokens.push(components.userinfo)
            uriTokens.push('@')
          }
          if (components.host !== undefined) {
            //normalize IP hosts, add brackets and escape zone separator for IPv6
            uriTokens.push(
              _normalizeIPv6(
                _normalizeIPv4(String(components.host), protocol),
                protocol
              ).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
                return '[' + $1 + ($2 ? '%25' + $2 : '') + ']'
              })
            )
          }
          if (
            typeof components.port === 'number' ||
            typeof components.port === 'string'
          ) {
            uriTokens.push(':')
            uriTokens.push(String(components.port))
          }
          return uriTokens.length ? uriTokens.join('') : undefined
        }

        var RDS1 = /^\.\.?\//
        var RDS2 = /^\/\.(\/|$)/
        var RDS3 = /^\/\.\.(\/|$)/
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/
        function removeDotSegments(input) {
          var output = []
          while (input.length) {
            if (input.match(RDS1)) {
              input = input.replace(RDS1, '')
            } else if (input.match(RDS2)) {
              input = input.replace(RDS2, '/')
            } else if (input.match(RDS3)) {
              input = input.replace(RDS3, '/')
              output.pop()
            } else if (input === '.' || input === '..') {
              input = ''
            } else {
              var im = input.match(RDS5)
              if (im) {
                var s = im[0]
                input = input.slice(s.length)
                output.push(s)
              } else {
                throw new Error('Unexpected dot segment condition')
              }
            }
          }
          return output.join('')
        }

        function serialize(components) {
          var options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL
          var uriTokens = []
          //find scheme handler
          var schemeHandler =
            SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]
          //perform scheme specific serialization
          if (schemeHandler && schemeHandler.serialize)
            schemeHandler.serialize(components, options)
          if (components.host) {
            //if host component is an IPv6 address
            if (protocol.IPV6ADDRESS.test(components.host)) {
            }
            //TODO: normalize IPv6 address as per RFC 5952

            //if host component is a domain name
            else if (
              options.domainHost ||
              (schemeHandler && schemeHandler.domainHost)
            ) {
              //convert IDN via punycode
              try {
                components.host = !options.iri
                  ? punycode.toASCII(
                      components.host
                        .replace(protocol.PCT_ENCODED, pctDecChars)
                        .toLowerCase()
                    )
                  : punycode.toUnicode(components.host)
              } catch (e) {
                components.error =
                  components.error ||
                  "Host's domain name can not be converted to " +
                    (!options.iri ? 'ASCII' : 'Unicode') +
                    ' via punycode: ' +
                    e
              }
            }
          }
          //normalize encoding
          _normalizeComponentEncoding(components, protocol)
          if (options.reference !== 'suffix' && components.scheme) {
            uriTokens.push(components.scheme)
            uriTokens.push(':')
          }
          var authority = _recomposeAuthority(components, options)
          if (authority !== undefined) {
            if (options.reference !== 'suffix') {
              uriTokens.push('//')
            }
            uriTokens.push(authority)
            if (components.path && components.path.charAt(0) !== '/') {
              uriTokens.push('/')
            }
          }
          if (components.path !== undefined) {
            var s = components.path
            if (
              !options.absolutePath &&
              (!schemeHandler || !schemeHandler.absolutePath)
            ) {
              s = removeDotSegments(s)
            }
            if (authority === undefined) {
              s = s.replace(/^\/\//, '/%2F') //don't allow the path to start with "//"
            }
            uriTokens.push(s)
          }
          if (components.query !== undefined) {
            uriTokens.push('?')
            uriTokens.push(components.query)
          }
          if (components.fragment !== undefined) {
            uriTokens.push('#')
            uriTokens.push(components.fragment)
          }
          return uriTokens.join('') //merge tokens into a string
        }

        function resolveComponents(base, relative) {
          var options =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : {}
          var skipNormalization = arguments[3]

          var target = {}
          if (!skipNormalization) {
            base = parse(serialize(base, options), options) //normalize base components
            relative = parse(serialize(relative, options), options) //normalize relative components
          }
          options = options || {}
          if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo
            target.host = relative.host
            target.port = relative.port
            target.path = removeDotSegments(relative.path || '')
            target.query = relative.query
          } else {
            if (
              relative.userinfo !== undefined ||
              relative.host !== undefined ||
              relative.port !== undefined
            ) {
              //target.authority = relative.authority;
              target.userinfo = relative.userinfo
              target.host = relative.host
              target.port = relative.port
              target.path = removeDotSegments(relative.path || '')
              target.query = relative.query
            } else {
              if (!relative.path) {
                target.path = base.path
                if (relative.query !== undefined) {
                  target.query = relative.query
                } else {
                  target.query = base.query
                }
              } else {
                if (relative.path.charAt(0) === '/') {
                  target.path = removeDotSegments(relative.path)
                } else {
                  if (
                    (base.userinfo !== undefined ||
                      base.host !== undefined ||
                      base.port !== undefined) &&
                    !base.path
                  ) {
                    target.path = '/' + relative.path
                  } else if (!base.path) {
                    target.path = relative.path
                  } else {
                    target.path =
                      base.path.slice(0, base.path.lastIndexOf('/') + 1) +
                      relative.path
                  }
                  target.path = removeDotSegments(target.path)
                }
                target.query = relative.query
              }
              //target.authority = base.authority;
              target.userinfo = base.userinfo
              target.host = base.host
              target.port = base.port
            }
            target.scheme = base.scheme
          }
          target.fragment = relative.fragment
          return target
        }

        function resolve(baseURI, relativeURI, options) {
          var schemelessOptions = assign({ scheme: 'null' }, options)
          return serialize(
            resolveComponents(
              parse(baseURI, schemelessOptions),
              parse(relativeURI, schemelessOptions),
              schemelessOptions,
              true
            ),
            schemelessOptions
          )
        }

        function normalize(uri, options) {
          if (typeof uri === 'string') {
            uri = serialize(parse(uri, options), options)
          } else if (typeOf(uri) === 'object') {
            uri = parse(serialize(uri, options), options)
          }
          return uri
        }

        function equal(uriA, uriB, options) {
          if (typeof uriA === 'string') {
            uriA = serialize(parse(uriA, options), options)
          } else if (typeOf(uriA) === 'object') {
            uriA = serialize(uriA, options)
          }
          if (typeof uriB === 'string') {
            uriB = serialize(parse(uriB, options), options)
          } else if (typeOf(uriB) === 'object') {
            uriB = serialize(uriB, options)
          }
          return uriA === uriB
        }

        function escapeComponent(str, options) {
          return (
            str &&
            str
              .toString()
              .replace(
                !options || !options.iri
                  ? URI_PROTOCOL.ESCAPE
                  : IRI_PROTOCOL.ESCAPE,
                pctEncChar
              )
          )
        }

        function unescapeComponent(str, options) {
          return (
            str &&
            str
              .toString()
              .replace(
                !options || !options.iri
                  ? URI_PROTOCOL.PCT_ENCODED
                  : IRI_PROTOCOL.PCT_ENCODED,
                pctDecChars
              )
          )
        }

        var handler = {
          scheme: 'http',
          domainHost: true,
          parse: function parse(components, options) {
            //report missing host
            if (!components.host) {
              components.error =
                components.error || 'HTTP URIs must have a host.'
            }
            return components
          },
          serialize: function serialize(components, options) {
            var secure = String(components.scheme).toLowerCase() === 'https'
            //normalize the default port
            if (
              components.port === (secure ? 443 : 80) ||
              components.port === ''
            ) {
              components.port = undefined
            }
            //normalize the empty path
            if (!components.path) {
              components.path = '/'
            }
            //NOTE: We do not parse query strings for HTTP URIs
            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
            //and not the HTTP spec.
            return components
          }
        }

        var handler$1 = {
          scheme: 'https',
          domainHost: handler.domainHost,
          parse: handler.parse,
          serialize: handler.serialize
        }

        function isSecure(wsComponents) {
          return typeof wsComponents.secure === 'boolean'
            ? wsComponents.secure
            : String(wsComponents.scheme).toLowerCase() === 'wss'
        }
        //RFC 6455
        var handler$2 = {
          scheme: 'ws',
          domainHost: true,
          parse: function parse(components, options) {
            var wsComponents = components
            //indicate if the secure flag is set
            wsComponents.secure = isSecure(wsComponents)
            //construct resouce name
            wsComponents.resourceName =
              (wsComponents.path || '/') +
              (wsComponents.query ? '?' + wsComponents.query : '')
            wsComponents.path = undefined
            wsComponents.query = undefined
            return wsComponents
          },
          serialize: function serialize(wsComponents, options) {
            //normalize the default port
            if (
              wsComponents.port === (isSecure(wsComponents) ? 443 : 80) ||
              wsComponents.port === ''
            ) {
              wsComponents.port = undefined
            }
            //ensure scheme matches secure flag
            if (typeof wsComponents.secure === 'boolean') {
              wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws'
              wsComponents.secure = undefined
            }
            //reconstruct path from resource name
            if (wsComponents.resourceName) {
              var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                _wsComponents$resourc2 = slicedToArray(
                  _wsComponents$resourc,
                  2
                ),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1]

              wsComponents.path = path && path !== '/' ? path : undefined
              wsComponents.query = query
              wsComponents.resourceName = undefined
            }
            //forbid fragment component
            wsComponents.fragment = undefined
            return wsComponents
          }
        }

        var handler$3 = {
          scheme: 'wss',
          domainHost: handler$2.domainHost,
          parse: handler$2.parse,
          serialize: handler$2.serialize
        }

        var O = {}
        var isIRI = true
        //RFC 3986
        var UNRESERVED$$ =
          '[A-Za-z0-9\\-\\.\\_\\~' +
          (isIRI
            ? '\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF'
            : '') +
          ']'
        var HEXDIG$$ = '[0-9A-Fa-f]' //case-insensitive
        var PCT_ENCODED$ = subexp(
          subexp(
            '%[EFef]' +
              HEXDIG$$ +
              '%' +
              HEXDIG$$ +
              HEXDIG$$ +
              '%' +
              HEXDIG$$ +
              HEXDIG$$
          ) +
            '|' +
            subexp('%[89A-Fa-f]' + HEXDIG$$ + '%' + HEXDIG$$ + HEXDIG$$) +
            '|' +
            subexp('%' + HEXDIG$$ + HEXDIG$$)
        ) //expanded
        //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
        //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
        //const WSP$$ = "[\\x20\\x09]";
        //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
        //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
        //const VCHAR$$ = "[\\x21-\\x7E]";
        //const WSP$$ = "[\\x20\\x09]";
        //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
        //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
        //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
        //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]"
        var QTEXT$$ =
          "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]"
        var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]')
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"
        var UNRESERVED = new RegExp(UNRESERVED$$, 'g')
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, 'g')
        var NOT_LOCAL_PART = new RegExp(
          merge('[^]', ATEXT$$, '[\\.]', '[\\"]', VCHAR$$),
          'g'
        )
        var NOT_HFNAME = new RegExp(
          merge('[^]', UNRESERVED$$, SOME_DELIMS$$),
          'g'
        )
        var NOT_HFVALUE = NOT_HFNAME
        function decodeUnreserved(str) {
          var decStr = pctDecChars(str)
          return !decStr.match(UNRESERVED) ? str : decStr
        }
        var handler$4 = {
          scheme: 'mailto',
          parse: function parse$$1(components, options) {
            var mailtoComponents = components
            var to = (mailtoComponents.to = mailtoComponents.path
              ? mailtoComponents.path.split(',')
              : [])
            mailtoComponents.path = undefined
            if (mailtoComponents.query) {
              var unknownHeaders = false
              var headers = {}
              var hfields = mailtoComponents.query.split('&')
              for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split('=')
                switch (hfield[0]) {
                  case 'to':
                    var toAddrs = hfield[1].split(',')
                    for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                      to.push(toAddrs[_x])
                    }
                    break
                  case 'subject':
                    mailtoComponents.subject = unescapeComponent(
                      hfield[1],
                      options
                    )
                    break
                  case 'body':
                    mailtoComponents.body = unescapeComponent(
                      hfield[1],
                      options
                    )
                    break
                  default:
                    unknownHeaders = true
                    headers[unescapeComponent(hfield[0], options)] =
                      unescapeComponent(hfield[1], options)
                    break
                }
              }
              if (unknownHeaders) mailtoComponents.headers = headers
            }
            mailtoComponents.query = undefined
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
              var addr = to[_x2].split('@')
              addr[0] = unescapeComponent(addr[0])
              if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                  addr[1] = punycode.toASCII(
                    unescapeComponent(addr[1], options).toLowerCase()
                  )
                } catch (e) {
                  mailtoComponents.error =
                    mailtoComponents.error ||
                    "Email address's domain name can not be converted to ASCII via punycode: " +
                      e
                }
              } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase()
              }
              to[_x2] = addr.join('@')
            }
            return mailtoComponents
          },
          serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents
            var to = toArray(mailtoComponents.to)
            if (to) {
              for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x])
                var atIdx = toAddr.lastIndexOf('@')
                var localPart = toAddr
                  .slice(0, atIdx)
                  .replace(PCT_ENCODED, decodeUnreserved)
                  .replace(PCT_ENCODED, toUpperCase)
                  .replace(NOT_LOCAL_PART, pctEncChar)
                var domain = toAddr.slice(atIdx + 1)
                //convert IDN via punycode
                try {
                  domain = !options.iri
                    ? punycode.toASCII(
                        unescapeComponent(domain, options).toLowerCase()
                      )
                    : punycode.toUnicode(domain)
                } catch (e) {
                  components.error =
                    components.error ||
                    "Email address's domain name can not be converted to " +
                      (!options.iri ? 'ASCII' : 'Unicode') +
                      ' via punycode: ' +
                      e
                }
                to[x] = localPart + '@' + domain
              }
              components.path = to.join(',')
            }
            var headers = (mailtoComponents.headers =
              mailtoComponents.headers || {})
            if (mailtoComponents.subject)
              headers['subject'] = mailtoComponents.subject
            if (mailtoComponents.body) headers['body'] = mailtoComponents.body
            var fields = []
            for (var name in headers) {
              if (headers[name] !== O[name]) {
                fields.push(
                  name
                    .replace(PCT_ENCODED, decodeUnreserved)
                    .replace(PCT_ENCODED, toUpperCase)
                    .replace(NOT_HFNAME, pctEncChar) +
                    '=' +
                    headers[name]
                      .replace(PCT_ENCODED, decodeUnreserved)
                      .replace(PCT_ENCODED, toUpperCase)
                      .replace(NOT_HFVALUE, pctEncChar)
                )
              }
            }
            if (fields.length) {
              components.query = fields.join('&')
            }
            return components
          }
        }

        var URN_PARSE = /^([^\:]+)\:(.*)/
        //RFC 2141
        var handler$5 = {
          scheme: 'urn',
          parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE)
            var urnComponents = components
            if (matches) {
              var scheme = options.scheme || urnComponents.scheme || 'urn'
              var nid = matches[1].toLowerCase()
              var nss = matches[2]
              var urnScheme = scheme + ':' + (options.nid || nid)
              var schemeHandler = SCHEMES[urnScheme]
              urnComponents.nid = nid
              urnComponents.nss = nss
              urnComponents.path = undefined
              if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options)
              }
            } else {
              urnComponents.error =
                urnComponents.error || 'URN can not be parsed.'
            }
            return urnComponents
          },
          serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || 'urn'
            var nid = urnComponents.nid
            var urnScheme = scheme + ':' + (options.nid || nid)
            var schemeHandler = SCHEMES[urnScheme]
            if (schemeHandler) {
              urnComponents = schemeHandler.serialize(urnComponents, options)
            }
            var uriComponents = urnComponents
            var nss = urnComponents.nss
            uriComponents.path = (nid || options.nid) + ':' + nss
            return uriComponents
          }
        }

        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/
        //RFC 4122
        var handler$6 = {
          scheme: 'urn:uuid',
          parse: function parse(urnComponents, options) {
            var uuidComponents = urnComponents
            uuidComponents.uuid = uuidComponents.nss
            uuidComponents.nss = undefined
            if (
              !options.tolerant &&
              (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))
            ) {
              uuidComponents.error =
                uuidComponents.error || 'UUID is not valid.'
            }
            return uuidComponents
          },
          serialize: function serialize(uuidComponents, options) {
            var urnComponents = uuidComponents
            //normalize UUID
            urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()
            return urnComponents
          }
        }

        SCHEMES[handler.scheme] = handler
        SCHEMES[handler$1.scheme] = handler$1
        SCHEMES[handler$2.scheme] = handler$2
        SCHEMES[handler$3.scheme] = handler$3
        SCHEMES[handler$4.scheme] = handler$4
        SCHEMES[handler$5.scheme] = handler$5
        SCHEMES[handler$6.scheme] = handler$6

        exports.SCHEMES = SCHEMES
        exports.pctEncChar = pctEncChar
        exports.pctDecChars = pctDecChars
        exports.parse = parse
        exports.removeDotSegments = removeDotSegments
        exports.serialize = serialize
        exports.resolveComponents = resolveComponents
        exports.resolve = resolve
        exports.normalize = normalize
        exports.equal = equal
        exports.escapeComponent = escapeComponent
        exports.unescapeComponent = unescapeComponent

        Object.defineProperty(exports, '__esModule', { value: true })
      })
      //# sourceMappingURL=uri.all.js.map

      /***/
    },

    /***/ 4775: /***/ (module) => {
      'use strict'
      module.exports = JSON.parse(
        '{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}'
      )

      /***/
    },

    /***/ 98: /***/ (module) => {
      'use strict'
      module.exports = JSON.parse(
        '{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}'
      )

      /***/
    }

    /******/
  }
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {}
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId]
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ id: moduleId,
      /******/ loaded: false,
      /******/ exports: {}
      /******/
    })
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    )
    /******/
    /******/ // Flag the module as loaded
    /******/ module.loaded = true
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ ;(() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module['default']
          : /******/ () => module
      /******/ __webpack_require__.d(getter, { a: getter })
      /******/ return getter
      /******/
    }
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ ;(() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          })
          /******/
        }
        /******/
      }
      /******/
    }
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/global */
  /******/ ;(() => {
    /******/ __webpack_require__.g = (function () {
      /******/ if (typeof globalThis === 'object') return globalThis
      /******/ try {
        /******/ return this || new Function('return this')()
        /******/
      } catch (e) {
        /******/ if (typeof window === 'object') return window
        /******/
      }
      /******/
    })()
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ ;(() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop)
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/node module decorator */
  /******/ ;(() => {
    /******/ __webpack_require__.nmd = (module) => {
      /******/ module.paths = []
      /******/ if (!module.children) module.children = []
      /******/ return module
      /******/
    }
    /******/
  })()
  /******/
  /************************************************************************/
  var __webpack_exports__ = {}
  // This entry need to be wrapped in an IIFE because it need to be in strict mode.
  ;(() => {
    'use strict'

    // EXTERNAL MODULE: ./node_modules/alertifyjs/build/alertify.js
    var alertify = __webpack_require__(8307)
    var alertify_default = /*#__PURE__*/ __webpack_require__.n(alertify)
    // EXTERNAL MODULE: ./node_modules/debounce/index.js
    var debounce = __webpack_require__(296)
    var debounce_default = /*#__PURE__*/ __webpack_require__.n(debounce)
    // EXTERNAL MODULE: ./node_modules/delegate/src/delegate.js
    var delegate = __webpack_require__(9438)
    var delegate_default = /*#__PURE__*/ __webpack_require__.n(delegate)
    // EXTERNAL MODULE: ./node_modules/dohtml/index.js
    var dohtml = __webpack_require__(1182)
    var dohtml_default = /*#__PURE__*/ __webpack_require__.n(dohtml)
    // EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
    var jquery = __webpack_require__(9755)
    var jquery_default = /*#__PURE__*/ __webpack_require__.n(jquery)
    // EXTERNAL MODULE: ./node_modules/jquery-ui/ui/widgets/dialog.js
    var dialog = __webpack_require__(2466) // CONCATENATED MODULE: ./src/lib/component/Dialog.js
    class Dialog {
      constructor(title, contentHtml, option = {}) {
        this._el = dohtml_default().create(`
    <div title="${title}">
      ${contentHtml}
    </div>
    `)
        this._$dialog = jquery_default()(this._el)
        this._$dialog.on('dialogclose', () => {
          // Delay destroy to check a click target is child of the dialog.
          requestAnimationFrame(() => this._$dialog.dialog('destroy'))
        })

        this._option = option
      }

      get el() {
        return this._el
      }

      get button() {
        return this._$dialog
          .dialog('widget')[0]
          .querySelector('.ui-dialog-buttonpane button')
      }

      open() {
        this._$dialog.dialog({
          ...{
            dialogClass: 'textae-editor__dialog',
            height: 'auto',
            modal: true,
            resizable: false,
            width: 'calc(100% - 10px)',
            create: (event) => {
              // The maxWidth option of the jQuery UI dialog is not working.
              // See: https://stackoverflow.com/a/20218692/1276969
              jquery_default()(event.target.parentElement).css(
                'maxWidth',
                `${this._option.maxWidth || 550}px`
              )
            }
          },
          ...this._option
        })
      }

      close() {
        this._$dialog.dialog('close')
      }
    } // CONCATENATED MODULE: ./src/lib/component/HelpDialog.js

    class HelpDialog extends Dialog {
      constructor() {
        super(
          'Help (Keyboard short-cuts)',
          `<div class="textae-tool__key-help"></div>
       <ul>
         <li>
          cut
          : Ctrl+x
        </li>
         <li>
          copy
          : Ctrl+c
        </li>
         <li>
          paste
          : Ctrl+v
        </li>
       </ul>
      `,

          {
            maxWidth: 523
          }
        )
      }
    } // CONCATENATED MODULE: ./src/lib/component/TipsDialog.js

    class TipsDialog extends Dialog {
      constructor() {
        super(
          'For security reason, the shortcut keys for cut/copy/paste are changed as follows:',
          `<table class="textae-editor__tips-dialog__table">
        <thead>
          <tr><th></th><th>before</th><th>after</th></tr>
        </thead>
        <tbody>
          <tr><td>cut</td><td>x</td><td>Ctrl-x</td></tr>
          <tr><td>copy</td><td>c</td><td>Ctrl-c</td></tr>
          <tr><td>paste</td><td>v</td><td>Ctrl-v</td></tr>
        </tbody>
      </table>
      `,

          {
            maxWidth: 785
          }
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Tool/EditorContainer/isTextFields.js

    /* harmony default export */ function isTextFields(htmlElement) {
      return (
        htmlElement instanceof HTMLInputElement ||
        htmlElement instanceof HTMLTextAreaElement
      )
    } // CONCATENATED MODULE: ./src/lib/Tool/EditorContainer/observeBodyEvents.js

    /**
     *
     * @param {import('.').default} editorContainer
     */
    /* harmony default export */ function observeBodyEvents(editorContainer) {
      // The blur events always occurs each focus changing.
      // For example, blur events always occurs when the labels in the pallet is clicked.
      // If other editors are selected, the pallet should be closed.
      // But the blur events is not distinguished from clicking on the pallet and selection other editors.

      // Select the editor when the editor, a span or an entity-type is focused in.
      // Unselect the editor when a child element of other than the editor is focused in.
      // The click events are not fired on changing the selection by the tab key.
      document.body.addEventListener(
        'focus',
        (e) => {
          const element = e.target.closest('.textae-editor')

          if (element) {
            if (
              editorContainer.selected &&
              editorContainer.selected !== element
            ) {
              editorContainer.unselect(editorContainer.selected)
            }
            editorContainer.selected = element
          }
        },
        true
      )

      // Unselect the editor when a child element of other than the editor is clicked.
      // The focus events are not fired on the un-focusable elements like div.
      document.body.addEventListener('click', (e) => {
        // Ignore clicks on the jQuery UI dialogs.
        if (e.target.closest('.textae-editor__dialog') !== null) {
          return
        }

        // Ignore clicks on the auto-completion items.
        if (e.target.closest('.ui-autocomplete') !== null) {
          return
        }

        // Ignore clicks on the overlay of the jQuery UI.
        if (e.target.closest('.ui-widget-overlay') !== null) {
          return
        }

        // Ignore clicks on the pallet.
        if (e.target.closest('.textae-editor__pallet__content') !== null) {
          return
        }

        // Ignore clicks on children of the this Editor
        if (editorContainer.has(e.target.closest('.textae-editor'))) {
          return
        }

        if (editorContainer.selected) {
          editorContainer.unselect(editorContainer.selected)
        }
      })
    } // CONCATENATED MODULE: ./src/lib/Tool/EditorContainer/index.js

    const helpDialog = new HelpDialog()
    const tipsDialog = new TipsDialog()

    class EditorContainer {
      constructor() {
        this._editors = new Map()
        this._selected = null

        delegate_default()(window, '.textae-editor', 'keyup', (event) => {
          // Keyup events occurs without selected editor, When editor is focused before initializing.
          if (this.selected) {
            switch (event.key) {
              case 'h':
                helpDialog.open()
                break
              case 'c':
              case 'x':
              case 'v':
                if (!event.ctrlKey && !event.metaKey) {
                  tipsDialog.open()
                }
            }
          }
        })

        this._observeDocumentEvents()
      }

      observeBodyEvents() {
        observeBodyEvents(this)
      }

      set(element, editor) {
        this._editors.set(element, editor)
      }

      get selected() {
        return this._selected
      }

      set selected(element) {
        this._editors.get(element).active()

        this._selected = element
      }

      unselect(element) {
        if (this._selected === element) {
          this._editors.get(element).deactive()
          this._selected = null
        }
      }

      drawGridsInSight() {
        for (const editor of this._editors.values()) {
          editor.drawGridsInSight()
        }
      }

      updateDenotationEntitiesWidth() {
        for (const editor of this._editors.values()) {
          editor.updateDenotationEntitiesWidth()
        }
      }

      relayout() {
        for (const editor of this._editors.values()) {
          editor.relayout()
        }
      }

      has(element) {
        return this._editors.has(element)
      }

      get nextID() {
        return `editor${this._editors.size}`
      }

      _observeDocumentEvents() {
        // Since the Body element does not yet exist at the time of initializing the EditorContainer,
        // we will set up an event handler in the document.
        document.addEventListener('copy', (e) => {
          if (isTextFields(e.target)) {
            return
          }

          if (this.selected) {
            this._editors.get(this.selected).copyEntitiesToSystemClipboard(e)
          }
        })
        document.addEventListener('cut', (e) => {
          if (isTextFields(e.target)) {
            return
          }

          if (this.selected) {
            this._editors.get(this.selected).cutEntitiesToSystemClipboard(e)
          }
        })
        document.addEventListener('paste', (e) => {
          if (isTextFields(e.target)) {
            return
          }

          if (this.selected) {
            this._editors.get(this.selected).pasteEntitiesFromSystemClipboard(e)
          }
        })

        // Enable/disable the context menu icon by looking at the text selection.
        document.addEventListener(
          'selectionchange',
          debounce_default()(() => {
            if (this.selected) {
              this._editors.get(this.selected).applyTextSelection()
            }
          }, 100)
        )
        document.addEventListener('contextmenu', () => {
          if (this.selected) {
            this._editors.get(this.selected).applyTextSelection()
          }
        })

        // Close ContextMenu when another editor is clicked
        document.addEventListener('click', (e) => {
          // In Firefox, the right button of mouse fires a 'click' event.
          // https://stackoverflow.com/questions/43144995/mouse-right-click-on-firefox-triggers-click-event
          // In Fireforx, MoesueEvent has a 'which' property, which is 3 when the right button is clicked.
          // https://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
          if (e.which === 3) {
            return
          }

          for (const api of this._editors.values()) {
            api.hideContextMenu()
          }
        })

        document.addEventListener('contextmenu', (contextmenuEvent) => {
          // Close ContextMenu when another editor is clicked.
          for (const api of this._editors.values()) {
            api.hideContextMenu()
          }

          // If the editor you click on is selected and editable,
          // it will display its own context menu, rather than the browser's context menu.
          const clickedEditor =
            contextmenuEvent.target.closest('.textae-editor')
          if (clickedEditor === this._selected) {
            if (
              clickedEditor.classList.contains(
                'textae-editor__mode--view-with-relation'
              ) ||
              clickedEditor.classList.contains(
                'textae-editor__mode--view-without-relation'
              )
            ) {
              return
            }

            // Prevent show browser default context menu
            contextmenuEvent.preventDefault()
            this._editors.get(this._selected).showContextMenu(contextmenuEvent)
          }
        })
      }
    } // CONCATENATED MODULE: ./src/lib/Tool/Veil.js

    const config = {
      attributes: true,
      attributeFilter: ['class']
    }

    class Veil {
      constructor() {
        // Since not all editors will be notified at once, keep the state in a instance variable.
        this._waitingEditors = new Set()
      }

      setObserver(editorHTMLElement) {
        // Do not create HTML elements in the constructor
        // so that this class can be initialized before document.body is created.
        // Instead, we create it here.
        if (!this._el) {
          this._el = dohtml_default().create(
            `<div class="textae-editor-veil" style="display: none;"></div>`
          )
          document.body.appendChild(this._el)
        }

        new MutationObserver((mutationRecords) =>
          this._mutationCallback(mutationRecords)
        ).observe(editorHTMLElement, config)
      }

      _mutationCallback(mutationRecords) {
        this._collectWaitingEditors(mutationRecords)

        if (this._waitingEditors.size > 0) {
          this._show()
        } else {
          this._hide()
        }
      }

      _collectWaitingEditors(mutationRecords) {
        mutationRecords.forEach(({ target }) => {
          if (target.classList.contains('textae-editor--wait')) {
            this._waitingEditors.add(target)
          } else {
            this._waitingEditors.delete(target)
          }
        })
      }

      _show() {
        this._el.style.display = 'block'
      }

      _hide() {
        this._el.style.display = 'none'
      }
    }

    // EXTERNAL MODULE: ./node_modules/throttleit/index.js
    var throttleit = __webpack_require__(9623)
    var throttleit_default = /*#__PURE__*/ __webpack_require__.n(throttleit) // CONCATENATED MODULE: ./src/lib/Tool/index.js
    // The tool manages interactions between components.
    class Tool {
      constructor() {
        this._editorContainer = new EditorContainer()
        this._veil = new Veil()

        // When the DOMContentLoaded event occurs, document.body may not have been initialized yet.
        // When the load event occurs, bind the event handler of document.body.
        window.addEventListener('load', () =>
          this._editorContainer.observeBodyEvents()
        )

        // Observe window-resize event and redraw all editors.
        window.addEventListener(
          'resize',
          throttleit_default()(() => {
            this._editorContainer.relayout()
            this._editorContainer.drawGridsInSight()
            this._editorContainer.updateDenotationEntitiesWidth()
          }, 500)
        )

        window.addEventListener(
          'scroll',
          throttleit_default()(() => {
            this._editorContainer.drawGridsInSight()
          }, 300)
        )
      }

      get nextID() {
        return this._editorContainer.nextID
      }

      registerEditor(element, editor) {
        this._veil.setObserver(element)
        this._editorContainer.set(element, editor)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/ModelContainer/index.js

    class ModelContainer {
      constructor(emitter, name) {
        this._emitter = emitter
        this._name = name
        this._container = new Map()
      }

      _toModel(rowDatum) {
        return rowDatum
      }

      _toModels(rowData, type) {
        return rowData.map((r) => this._toModel(r, type))
      }

      addSource(source, type) {
        for (const instance of this._toModels(source, type)) {
          this._addToContainer(instance)
        }
      }

      add(instance) {
        const newInstance = this._addToContainer(instance)
        this._emit(
          `textae-event.annotation-data.${this._name}.add`,
          newInstance
        )
        return newInstance
      }

      get(id) {
        return this._container.get(id)
      }

      get all() {
        return Array.from(this._container.values())
      }

      get selectedItems() {
        return this.all.filter(({ isSelected }) => isSelected)
      }

      findByType(typeName) {
        return this.all.filter((model) => model.typeName === typeName)
      }

      get some() {
        return this._container.size
      }

      changeType(id, newType) {
        const instance = this._container.get(id)
        instance.typeName = newType
        this._emit(
          `textae-event.annotation-data.${this._name}.change`,
          instance
        )
        return instance
      }

      remove(id) {
        const instance = this._container.get(id)
        if (instance) {
          this._container.delete(id)
          this._emit(
            `textae-event.annotation-data.${this._name}.remove`,
            instance
          )
        }
        return instance
      }

      clear() {
        this._container.clear()
      }

      _addToContainer(instance) {
        this._container.set(instance.id, instance)
        return instance
      }

      _emit(event, data) {
        this._emitter.emit(event, data)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/updateSpanTree/getParent/isChildOf.js

    /* harmony default export */ function isChildOf(span, maybeParent) {
      if (!maybeParent) {
        return false
      }

      return maybeParent.begin <= span.begin && span.end <= maybeParent.end
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/updateSpanTree/getParent/index.js

    function getParet(span, parent) {
      if (isChildOf(span, parent)) {
        return parent
      } else if (parent.parent) {
        return getParet(span, parent.parent)
      } else {
        return null
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/spanComparator.js

    /* harmony default export */ function spanComparator(a, b) {
      return a.begin - b.begin || b.end - a.end
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/updateSpanTree/index.js

    // the spanTree has parent-child structure.
    /* harmony default export */ function updateSpanTree(root, spans) {
      // Sort spans by the position.
      const sortedSpans = spans.sort(spanComparator)

      sortedSpans.forEach((span, index, array) => {
        span.severTies()

        const left = index !== 0 ? array[index - 1] : null
        if (left) {
          const parent = getParet(span, left)
          if (parent) {
            span.beChildOf(parent)
          } else {
            span.beChildOf(root)
          }
        } else {
          span.beChildOf(root)
        }
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/idFactory.js

    // The ID of spans has editorID and begin and end, like 'editor1__S0_15'.
    function makeDenotationSpanHTMLElementID(editorID, begin, end) {
      return `${editorID}__D${begin}_${end}`
    }

    function makeStyleSpanHTMLElementID(editorID, begin, end) {
      return `${editorID}__S${begin}_${end}`
    }

    function makeBlockSpanHTMLElementID(editorID, begin, end) {
      return `${editorID}__B${begin}_${end}`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/SELECTED.js

    const SELECTED = 'ui-selected'
    /* harmony default export */ const SpanModelContainer_SELECTED = SELECTED // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/getGridHeightIncludeDescendantGrids/index.js

    /**
     *
     * @param {import('../SpanModel').default} span
     * @param {number} typeGap
     * @returns {number}
     */
    function getGridHeightIncludeDescendantGrids(span) {
      const descendantsMaxHeight =
        span.children.length === 0 ? 0 : getMaxHeight(span)
      const height = span.gridHeight

      return height + descendantsMaxHeight
    }

    function getMaxHeight(span) {
      return Math.max.apply(
        null,
        span.children.map((childSpan) =>
          getGridHeightIncludeDescendantGrids(childSpan)
        )
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/round.js

    // The value of getBoundingClientRect may contain 13 decimal places.
    // It's too fine to use as a style attribute,
    // so I'll round it to 2 decimal places,
    // which is below the rounding accuracy of Google Chrome and Firefox.
    /* harmony default export */ function round(val) {
      return Math.round(val * 100) / 100
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/SpanModel/createGridHtml.js

    /* harmony default export */ function createGridHtml(
      spanId,
      top,
      left,
      width
    ) {
      return `
<div 
  id=G${spanId} 
  class="textae-editor__grid" 
  style="top: ${top}px; left: ${left}px; width: ${width}px;">
</div>
`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/SpanModel/getBigBrotherSpan.js

    // Big Brother is the Span before the span
    /* harmony default export */ function getBigBrotherSpan(span) {
      // The parent of a big Brother and the span is the same.
      const bros = span.parent.children
      const index = bros.indexOf(span)
      return index === 0 ? null : bros[index - 1]
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/SpanModel/updateGridPosition/isStaying.js

    /* harmony default export */ function isStaying(gridElement, top, left) {
      if (
        gridElement.style &&
        parseFloat(gridElement.style.top) === top &&
        parseFloat(gridElement.style.left) === left
      ) {
        return true
      }
      return false
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/SpanModel/updateGridPosition/index.js

    /* harmony default export */ function updateGridPosition(
      gridElement,
      top,
      left
    ) {
      if (!isStaying(gridElement, top, left)) {
        gridElement.style.top = `${top}px`
        gridElement.style.left = `${left}px`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/getAnnotationBox.js

    // Get the display area for denotations and relations.
    /* harmony default export */ function getAnnotationBox(editorHTMLElement) {
      return editorHTMLElement.querySelector('.textae-editor__annotation-box')
    } // CONCATENATED MODULE: ./src/lib/Editor/getRightElement.js

    /* harmony default export */ function getRightElement(
      editorHTMLElement,
      element,
      className
    ) {
      console.assert(element, 'element MUST exists.')

      const all = editorHTMLElement.querySelectorAll(`.${className}`)
      const index = Array.from(all).indexOf(element)

      if (all.length - index > 1) {
        return all[index + 1]
      }

      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/getRightSpanElement.js

    /* harmony default export */ function getRightSpanElement(
      editorHTMLElement,
      spanId
    ) {
      return getRightElement(
        editorHTMLElement,
        document.querySelector(`#${spanId}`),
        'textae-editor__span'
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/SpanModel/getRightGrid.js

    /* harmony default export */ function getRightGrid(
      editorHTMLElement,
      spanId
    ) {
      const rightSpan = getRightSpanElement(editorHTMLElement, spanId)

      if (rightSpan) {
        return document.querySelector(`#G${rightSpan.id}`)
      }

      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/createRangeToSpan/getRenderingPosition/getOffset.js

    /* harmony default export */ function getOffset(span, startOfTextNode) {
      const start = span.begin - startOfTextNode
      const end = span.end - startOfTextNode

      return {
        start,
        end
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/createRangeToSpan/getRenderingPosition/getRenderingPositionFromParent.js

    /* harmony default export */ function getRenderingPositionFromParent(span) {
      const { start, end } = getOffset(span, span.parent.begin)

      return {
        textNode: span.parent.element.firstChild,
        start,
        end
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/isBoundaryCrossing.js

    /* harmony default export */ function isBoundaryCrossing(
      begin,
      end,
      existSpan
    ) {
      const isStartOfCandidateSpanBetweenExistsSpan =
        existSpan.begin < begin && begin < existSpan.end && existSpan.end < end

      const isEndOfCandidateSpanBetweenExistSpan =
        begin < existSpan.begin && existSpan.begin < end && end < existSpan.end

      return (
        isStartOfCandidateSpanBetweenExistsSpan ||
        isEndOfCandidateSpanBetweenExistSpan
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/createRangeToSpan/getRenderingPosition/getRenderingPositionFromBigBrother.js

    /* harmony default export */ function getRenderingPositionFromBigBrother(
      span,
      bigBrotherSpan
    ) {
      if (isBoundaryCrossing(span.begin, span.end, bigBrotherSpan)) {
        throw new Error(`span ${span.id} is corrisng with ${bigBrotherSpan.id}`)
      }

      let { start, end } = getOffset(span, bigBrotherSpan.end)
      let textNode = bigBrotherSpan.element.nextSibling

      // Google chrome and Safari have a 65536 character limit on the text node.
      //  A string may consist of two or more text nodes.
      // If the start position is larger than the length of the text node,
      //  the next text node is used as the range for creating a span.
      if (textNode.length < start) {
        start = start - textNode.length
        end = end - textNode.length
        textNode = textNode.nextSibling
      }

      return {
        textNode,
        start,
        end
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/createRangeToSpan/getRenderingPosition/index.js

    /* harmony default export */ function getRenderingPosition(span) {
      const bigBrotherSpan = span.bigBrother

      if (bigBrotherSpan) {
        // The target text arrounded by span is in a textNode after the bigBrotherSpan
        // if bigBrotherSpan exists.
        return getRenderingPositionFromBigBrother(span, bigBrotherSpan)
      } else {
        // There is no big brother if the span is first in the text.
        // The target text arrounded by span is the first child of parent
        // unless bigBrotherSpan exists.
        return getRenderingPositionFromParent(span)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/createRangeToSpan/createRange.js

    /* harmony default export */ function createRange(textNode, start, end) {
      const range = document.createRange()

      range.setStart(textNode, start)
      range.setEnd(textNode, end)

      return range
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/createRangeToSpan/index.js

    // Get the Range to that new span tag insert.
    // This function works well when no child span is rendered.
    /* harmony default export */ function createRangeToSpan(span) {
      const { textNode, start, end } = getRenderingPosition(span)

      if (!textNode) {
        throw new Error(
          `The textNode on to create a span is not found. ${span.id}`
        )
      }

      if (start < 0) {
        throw new Error(`start must be positive, but ${start} for ${span.id}.`)
      }

      if (textNode.length < end) {
        throw new Error(
          `oh my god! I cannot render ${span.id}. "${textNode.textContent.slice(
            start,
            end
          )}" at ${start}~${end} of text(${textNode.textContent.length}) as "${
            textNode.textContent
          }".`
        )
      }

      return createRange(textNode, start, end)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/SpanModel/index.js

    class SpanModel {
      constructor(editorID, editorHTMLElement, begin, end, spanModelContainer) {
        this._editorID = editorID
        this._editorHTMLElement = editorHTMLElement
        this._begin = begin
        this._end = end
        this._spanModelContainer = spanModelContainer
        this._isGridRendered = false
        this._isSelected = false

        this.severTies()
      }

      get begin() {
        return this._begin
      }

      get end() {
        return this._end
      }

      get title() {
        return `${this._begin}-${this._end}`
      }

      get types() {
        return []
      }

      /**
       * @return {[import('../../../EntityModel').default]}
       */
      get entities() {
        if (this._entityModelContainer) {
          return this._entityModelContainer.getAllOfSpan(this)
        }

        return []
      }

      get relations() {
        return this.entities.map(({ relations }) => relations).flat()
      }

      get bigBrother() {
        return getBigBrotherSpan(this, this._spanModelContainer.topLevel)
      }

      get root() {
        return this._spanModelContainer
      }

      get parent() {
        return this._parent
      }

      get children() {
        return this._children
      }

      severTies() {
        // Reset parent
        this._parent = null
        // Reset children
        this._children = []
      }

      beChildOf(parent) {
        parent.children.push(this)
        this._parent = parent
      }

      traverse(preOrderFunction) {
        preOrderFunction(this)

        for (const child of this._children) {
          child.traverse(preOrderFunction)
        }
      }

      get element() {
        return document.querySelector(`#${this.id}`)
      }

      render() {
        // Destroy children spans to wrap a TextNode with <span> tag when new span over exists spans.
        this.traverse((span) => {
          if (span.element !== null) {
            span.destroyElement()
          }
        })

        // Reflow occurs when acquiring the position information of the span to draw the grid.
        // If the span drawing and grid drawing are repeated at the first display,
        // the reflow effect will slow down the process.
        // Here, only the span will be drawn,
        // and the grid drawing will be done at another time.
        this.traverse((span) => span.renderElement())
      }

      erase() {
        if (this.hasStyle) {
          const spanElement = this.element
          spanElement.removeAttribute('tabindex')
          spanElement.classList.remove('textae-editor__span')
        } else {
          this.destroyElement()
        }
        this._destroyGridElement()
      }

      renderElement() {
        const element = dohtml_default().create(this._contentHTML)
        const targetRange = createRangeToSpan(this)
        targetRange.surroundContents(element)
      }

      destroyElement() {
        const spanElement = this.element
        const parent = spanElement.parentNode

        // Move the textNode wrapped this span in front of this span.
        while (spanElement.firstChild) {
          parent.insertBefore(spanElement.firstChild, spanElement)
        }

        parent.removeChild(spanElement)
        parent.normalize()
      }

      get gridElement() {
        return document.querySelector(`#G${this.id}`)
      }

      get gridHeight() {
        const typeGapHeight = this._spanModelContainer.typeGap.height
        const { entities } = this
        return entities
          .map(({ height }) => height)
          .reduce((sum, entityHeight) => sum + typeGapHeight + entityHeight, 0)
      }

      get isGridRendered() {
        return this._isGridRendered
      }

      get isSelected() {
        return this._selected
      }

      select() {
        this._selected = true
      }

      deselect() {
        this._selected = false
      }

      addEntityElementToGridElement(entityElement) {
        this.gridElement.insertAdjacentElement('beforeend', entityElement)
      }

      updateSelfAndAncestorsGridPosition() {
        // Do nothing.
        // This method overrided in the DenotationSpanModel.
      }

      drawGrid(clientHeight, clientWidth) {
        if (this.isGridInDrawArea(clientHeight, clientWidth)) {
          this._renderGridElement()
          for (const entity of this.entities) {
            entity.render()
          }
        } else {
          this._destroyGridElement()
        }
      }

      isGridInDrawArea() {
        throw new Error(
          'SpanModel.isGridInDrawArea should be implemented in a subclass.'
        )
      }

      _renderGridElement() {
        if (this.isGridRendered) {
          return this.gridElement
        }

        const rightGrid = getRightGrid(this._editorHTMLElement, this.id)
        if (rightGrid) {
          // insert before the right grid.
          rightGrid.insertAdjacentElement(
            'beforebegin',
            this._createGridElement()
          )
          this._isGridRendered = true

          return rightGrid.previousElementSibling
        } else {
          // append to the annotation area.
          const container = getAnnotationBox(this._editorHTMLElement)
          container.insertAdjacentElement(
            'beforeend',
            this._createGridElement()
          )
          this._isGridRendered = true

          return container.lastElementChild
        }
      }

      _createGridElement() {
        const { offsetTopOfGrid, offsetLeftOfGrid, widthOfGrid } = this
        const html = createGridHtml(
          this.id,
          round(offsetTopOfGrid),
          round(offsetLeftOfGrid),
          widthOfGrid
        )
        return dohtml_default().create(html)
      }

      updateGridPosition() {
        if (this.isGridRendered) {
          const { offsetTopOfGrid, offsetLeftOfGrid } = this
          updateGridPosition(
            this.gridElement,
            round(offsetTopOfGrid),
            round(offsetLeftOfGrid)
          )
        }
      }

      _destroyGridElement() {
        if (this.isGridRendered) {
          this._isGridRendered = false

          for (const entity of this.entities) {
            entity.erase()
          }

          this.gridElement.remove()
        }
      }

      get _styleClasses() {
        return [...this.styles.values()].map(
          (style) => `textae-editor__style textae-editor__style--${style}`
        )
      }

      /**
       *
       * @param {import('../../../API/Presenter/EditMode/SelectionWrapper').default} selectionWrapper
       */
      getShotrenInAnchorNodeToFocusNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (anchor < focus) {
          // shorten the left boundary
          return {
            begin: spanAdjuster.forwardFromBegin(sourceDoc, focus, spanConfig),
            end: this.end
          }
        } else {
          // shorten the right boundary
          return {
            begin: this.begin,
            end: spanAdjuster.backFromEnd(sourceDoc, focus - 1, spanConfig) + 1
          }
        }
      }

      getShortenInFocusNodeToAnchorNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (focus < anchor) {
          // shorten the left boundary
          return {
            begin: spanAdjuster.forwardFromBegin(sourceDoc, anchor, spanConfig),
            end: this.end
          }
        } else {
          // shorten the right boundary
          return {
            begin: this.begin,
            end: spanAdjuster.backFromEnd(sourceDoc, anchor - 1, spanConfig) + 1
          }
        }
      }

      getExpandedInAnchorNodeToFocusNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (anchor < focus) {
          // expand to the right
          return {
            begin: this.begin,
            end:
              spanAdjuster.forwardFromEnd(sourceDoc, focus - 1, spanConfig) + 1
          }
        } else {
          // expand to the left
          return {
            begin: spanAdjuster.backFromBegin(sourceDoc, focus, spanConfig),
            end: this.end
          }
        }
      }

      getExpandedInFocusNodeToAnchorNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (focus < anchor) {
          // expand to the right
          return {
            begin: this.begin,
            end:
              spanAdjuster.forwardFromEnd(sourceDoc, anchor - 1, spanConfig) + 1
          }
        } else {
          // expand to the left
          return {
            begin: spanAdjuster.backFromBegin(sourceDoc, anchor, spanConfig),
            end: this.end
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/isTouchable.js

    // https://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript/4819886#4819886
    /* harmony default export */ function isTouchable() {
      return (
        'ontouchstart' in window ||
        navigator.maxTouchPoints > 0 ||
        navigator.msMaxTouchPoints > 0
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/DenotationSpanModel.js

    const TEXT_HEIGHT = 23
    const MARGIN_TOP = 30
    class DenotationSpanModel extends SpanModel {
      constructor(
        editorID,
        editorHTMLElement,
        begin,
        end,
        entityModelContainer,
        spanModelContainer
      ) {
        super(editorID, editorHTMLElement, begin, end, spanModelContainer)
        this._entityModelContainer = entityModelContainer
      }

      get id() {
        return makeDenotationSpanHTMLElementID(
          this._editorID,
          this._begin,
          this._end
        )
      }

      passesAllEntitiesTo(newSpan) {
        for (const entity of this.entities) {
          entity.span = newSpan
        }
      }

      get hasStyle() {
        return this.styles.size > 0
      }

      // Merges a span and a typesetting so that it can be rendered as a single DOM element.
      get styles() {
        return this._spanModelContainer.getStyle(this.id)
      }

      get _offsetLeft() {
        const spanElement = this.element

        // An element.offsetTop and element.offsetLeft does not work in the Firefox,
        // when much spans are loaded like http://pubannotation.org/docs/sourcedb/PMC/sourceid/1315279/divs/10/annotations.json.
        const rectOfSpan = spanElement.getBoundingClientRect()
        const rectOfTextBox =
          spanElement.offsetParent.offsetParent.getBoundingClientRect()

        const left = rectOfSpan.left - rectOfTextBox.left

        return left
      }

      get isDenotation() {
        return true
      }

      addEntityElementToGridElement(entityElement) {
        super.addEntityElementToGridElement(entityElement)
        this.updateSelfAndAncestorsGridPosition()
      }

      updateSelfAndAncestorsGridPosition() {
        this.updateGridPosition()
        let parentSpan = this.parent
        while (parentSpan instanceof DenotationSpanModel) {
          parentSpan.updateGridPosition()
          parentSpan = parentSpan.parent
        }
      }

      updateDenotationEntitiesWidth() {
        if (this.isGridRendered) {
          const { widthOfGrid } = this
          this.gridElement.style.width = `${widthOfGrid}px`
        }
      }

      select() {
        super.select()

        const el = super.element
        el.classList.add(SpanModelContainer_SELECTED)

        // Set focus to the span element in order to scroll the browser to the position of the element.
        // Focusing the span with the mouseup event on the context menu
        // will trigger the textae-editor click event in the Chrome browser on Android.
        // This will trigger the body click event, which will deselect the span.
        // To prevent this, we will focus the span in the next event loop cycle.
        setTimeout(() => el.focus(), 0)
      }

      deselect() {
        super.deselect()

        const el = super.element

        // A dom does not exist when it is deleted.
        if (el) {
          el.classList.remove(SpanModelContainer_SELECTED)
        }
      }

      get heightIncludeDescendantGrids() {
        return (
          getGridHeightIncludeDescendantGrids(this) + TEXT_HEIGHT + MARGIN_TOP
        )
      }

      get widthOfGrid() {
        if (isTouchable) {
          const rectOfSpan = this.element.getBoundingClientRect()
          const rectOfTextBox =
            this.element.offsetParent.offsetParent.getBoundingClientRect()
          const left = rectOfSpan.left - rectOfTextBox.left

          // To fix the position of the toolbar, we use position: sticky.
          // On Android chrome, if an element is drawn at a position that is out of the device width,
          // the sticky position will be shifted upward by the width of the overhang.
          // To prevent this, the grid is not drawn outside the text box.
          const width = Math.min(rectOfSpan.width, rectOfTextBox.width - left)

          return round(width)
        } else {
          return round(this.element.getBoundingClientRect().width)
        }
      }

      get offsetCenterOfGrid() {
        return this._offsetLeft + this.widthOfGrid / 2
      }

      get clientTopOfGrid() {
        return (
          this.element.getBoundingClientRect().top -
          getGridHeightIncludeDescendantGrids(this)
        )
      }

      get offsetTopOfGrid() {
        // An element.offsetTop and element.offsetLeft does not work in the Firefox,
        // when much spans are loaded like http://pubannotation.org/docs/sourcedb/PMC/sourceid/1315279/divs/10/annotations.json.
        const offsetTop =
          this.element.getBoundingClientRect().top -
          this.element.offsetParent.offsetParent.getBoundingClientRect().top
        return offsetTop - getGridHeightIncludeDescendantGrids(this)
      }

      get offsetLeftOfGrid() {
        return this._offsetLeft
      }

      isGridInViewport(clientHeight, clientWidth) {
        return this._isGridInViewPort(clientHeight, clientWidth, 0)
      }

      isGridInDrawArea(clientHeight, clientWidth) {
        return this._isGridInViewPort(clientHeight, clientWidth, clientHeight)
      }

      _isGridInViewPort(clientHeight, clientWidth, margin) {
        const { top, left } = this.element.getBoundingClientRect()
        const gridHeightIncludeDescendantGrids =
          getGridHeightIncludeDescendantGrids(this)
        const gridBottom =
          top - gridHeightIncludeDescendantGrids + this.gridHeight
        const gridTop = top - gridHeightIncludeDescendantGrids

        return (
          0 - margin <= gridBottom &&
          gridTop <= clientHeight + margin &&
          left <= clientWidth
        )
      }

      get _contentHTML() {
        return `
      <span
        id="${this.id}"
        title="${this.title}"
        tabindex="0"
        class="${['textae-editor__span'].concat(this._styleClasses).join(' ')}"
        >
      </span>
    `
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/StyleSpanModel.js

    class StyleSpanModel extends SpanModel {
      constructor(
        editorID,
        editorHTMLElement,
        begin,
        end,
        spanModelContainer,
        style
      ) {
        super(
          editorID,
          editorHTMLElement,
          begin,
          end,
          spanModelContainer,
          style
        )
        this.styles = new Set([style])
      }

      get id() {
        return makeStyleSpanHTMLElementID(
          this._editorID,
          this._begin,
          this._end
        )
      }

      // Mark it not to be rendered as a span.
      get styleOnly() {
        return true
      }

      appendStyles(styles) {
        this.styles = new Set([...this.styles, ...styles])
      }

      get _contentHTML() {
        return `
      <span
        id="${this.id}"
        title="${this.title}"
        class="${this._styleClasses.join(' ')}"
        >
      </span>
    `
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/BlockSpanModel/renderBackground.js

    /* harmony default export */ function renderBackground(parentElement, id) {
      const div = dohtml_default().create(`
    <div id="${id}" class="textae-editor__block-bg"></div>
  `)

      // Always add to the top of the annotation box to place it behind the grid.
      parentElement.insertAdjacentElement('afterbegin', div)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/BlockSpanModel/setPosition.js

    /* harmony default export */ function setPosition(
      element,
      top,
      left,
      width,
      height
    ) {
      element.style.top = `${top}px`
      element.style.left = `${left}px`
      element.style.width = `${width}px`
      element.style.height = `${height}px`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/BlockSpanModel/index.js

    // Leave a gap between the text and the block border.
    const gapBetweenText = 8
    class BlockSpanModel extends SpanModel {
      /**
       *
       * @param {import('../../createTextBox/TextBox').default} textBox
       */
      constructor(
        editorID,
        editorHTMLElement,
        begin,
        end,
        entityModelContainer,
        spanModelContainer,
        textBox
      ) {
        super(editorID, editorHTMLElement, begin, end, spanModelContainer)
        this._entityModelContainer = entityModelContainer
        this._textBox = textBox
      }

      // Utility to distinguish with otehr type spans.
      get isBlock() {
        return true
      }

      passesAllEntitiesTo(newSpan) {
        for (const entity of this.entities) {
          entity.span = newSpan
        }
      }

      get id() {
        return makeBlockSpanHTMLElementID(
          this._editorID,
          this._begin,
          this._end
        )
      }

      select() {
        super.select()

        const el = super.element
        el.classList.add(SpanModelContainer_SELECTED)

        this._backgroundElement.classList.add(SpanModelContainer_SELECTED)

        // Set focus to the span element in order to scroll the browser to the position of the element.
        el.focus()
      }

      deselect() {
        super.deselect()

        const el = super.element

        // A dom does not exist when it is deleted.
        if (el) {
          el.classList.remove(SpanModelContainer_SELECTED)
        }

        if (this._backgroundElement) {
          this._backgroundElement.classList.remove(SpanModelContainer_SELECTED)
        }
      }

      updateBackgroundPosition() {
        if (this.isGridRendered) {
          const height = this._height

          const clientRect = this.element.getBoundingClientRect()
          const offsetLeft =
            clientRect.left -
            this._textBox.boundingClientRect.left -
            gapBetweenText
          const width = clientRect.width + gapBetweenText

          setPosition(
            this._backgroundElement,
            this._offsetTop,
            offsetLeft,
            width,
            height
          )

          // The div height cannot be obtained at grid rendering time,
          // so set it at move.
          this.gridElement.style.height = `${height}px`
        }
      }

      renderElement() {
        super.renderElement()

        // Place the background in the annotation box
        // to shift the background up by half a line from the block span area.
        const annotationBox = getAnnotationBox(this._editorHTMLElement)
        renderBackground(annotationBox, this._backgroundId)
      }

      destroyElement() {
        super.destroyElement()
        this._backgroundElement.remove()
      }

      get heightIncludeDescendantGrids() {
        return super.gridHeight + 35
      }

      get widthOfGrid() {
        return 100
      }

      get offsetCenterOfGrid() {
        return this._textBox.boundingClientRect.width - 58
      }

      get offsetTopOfGrid() {
        return this._offsetTop
      }

      get clientBottomOfGrid() {
        return this._clientTop + this._height
      }

      get offsetBottomOfGrid() {
        return this._offsetTop + this._height
      }

      get offsetLeftOfGrid() {
        return this._textBox.boundingClientRect.width - 108
      }

      updateGridPosition() {
        super.updateGridPosition()

        if (this._entityToFocusOn) {
          // A block span has only one entity.
          this._entityToFocusOn.select()
          this._entityToFocusOn = null
        }
      }

      get isGridBeforePositioned() {
        return !this.gridElement.style.top
      }

      set entityToFocusOn(val) {
        this._entityToFocusOn = val
      }

      isGridInViewport(clientHeight) {
        return this._isGridInViewPort(clientHeight, 0)
      }

      isGridInDrawArea(clientHeight) {
        return this._isGridInViewPort(clientHeight, clientHeight)
      }

      get _height() {
        return this.element.getBoundingClientRect().height
      }

      get _offsetTop() {
        return this._clientTop - this._textBox.boundingClientRect.top
      }

      get _backgroundId() {
        return `bg_of_${this.id}`
      }

      get _backgroundElement() {
        return document.querySelector(`#${this._backgroundId}`)
      }

      _isGridInViewPort(clientHeight, margin) {
        return (
          0 - margin <= this._clientBottom &&
          this._clientTop <= clientHeight + margin
        )
      }

      // Shifting up half a line from the original block position.
      get _clientTop() {
        return this._shiftUpGrid(this.element.getBoundingClientRect().top)
      }

      get _clientBottom() {
        return this._shiftUpGrid(this.element.getBoundingClientRect().bottom)
      }

      _shiftUpGrid(y) {
        return y - this._textBox.lineHeight / 2 + 20
      }

      get _contentHTML() {
        return `<div id="${this.id}" class="textae-editor__block"></div>`
      }

      _createGridElement() {
        const el = super._createGridElement()
        el.classList.add('textae-editor__block-hit-area')
        el.dataset.id = this.id
        el.title = this.title
        return el
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/getBoundaryCrossingSpans.js

    /* harmony default export */ function getBoundaryCrossingSpans(
      spans,
      begin,
      end
    ) {
      return spans.filter(({ span }) => isBoundaryCrossing(begin, end, span))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/isBoundaryCrossingWithOtherSpans.js

    // A span its range is coross over with other spans are not able to rendered.
    // Because spans are renderd with span tag. Html tags can not be cross over.
    /* harmony default export */ function isBoundaryCrossingWithOtherSpans(
      spans,
      begin,
      end
    ) {
      console.assert(end !== undefined, 'end is necessary.')

      return (
        getBoundaryCrossingSpans(
          spans.map((span) => ({ span })),
          begin,
          end
        ).length > 0
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/rangeFrom.js

    /* harmony default export */ function rangeFrom(
      spanModelContainer,
      firstId,
      secondId
    ) {
      const first = spanModelContainer.get(firstId)
      const second = spanModelContainer.get(secondId)
      let left = first
      let right = second

      // switch if seconfId before firstId
      if (spanComparator(first, second) > 0) {
        left = second
        right = first
      }

      // When the parent-child span is selected, the child span will be on the right.
      // In this case, the end of the child span is to the left of the end of the parent span.
      return [...spanModelContainer.values()]
        .filter(
          (span) =>
            left.begin <= span.begin &&
            (span.end <= left.end || span.end <= right.end)
        )
        .map((span) => span.id)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/getCurrentMaxHeight.js

    /* harmony default export */ function getCurrentMaxHeight(spans) {
      const maxHeight = Math.max(
        ...spans.map((span) => span.heightIncludeDescendantGrids)
      )
      return maxHeight
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/SpanModelContainer/index.js

    class SpanModelContainer {
      /**
       *
       * @param {import('../createTextBox/TextBox').default} textBox
       */
      constructor(
        editorID,
        editorHTMLElement,
        emitter,
        entityContainer,
        textBox,
        typeGap
      ) {
        this._editorID = editorID
        this._editorHTMLElement = editorHTMLElement
        this._emitter = emitter
        this._entityContainer = entityContainer
        this._textBox = textBox
        this.typeGap = typeGap

        this._denotations = new Map()
        this._blocks = new Map()
        this._styles = new Map()
      }

      // expected span is like { "begin": 19, "end": 49 }
      add(newValue) {
        console.assert(newValue, 'span is necessary.')

        // When redoing, the newValue is instance of the BlockSpanModel
        // or the DeontationSpan already.
        if (newValue instanceof BlockSpanModel) {
          return this._addBlock(newValue)
        } else if (newValue instanceof DenotationSpanModel) {
          return this._addDenotation(newValue)
        } else if (newValue.isBlock) {
          console.assert(
            !this.doesParentOrSameSpanExist(newValue.begin, newValue.end),
            `There are some parent spans of {begin: ${newValue.begin}, end: ${newValue.end}}.`
          )

          const blockSpan = new BlockSpanModel(
            this._editorID,
            this._editorHTMLElement,
            newValue.begin,
            newValue.end,
            this._entityContainer,
            this,
            this._textBox
          )
          return this._addBlock(blockSpan)
        } else {
          console.assert(
            !this.hasDenotationSpan(newValue.begin, newValue.end),
            'There is already a span.'
          )
          const denotationSpan = new DenotationSpanModel(
            this._editorID,
            this._editorHTMLElement,
            newValue.begin,
            newValue.end,
            this._entityContainer,
            this
          )
          return this._addDenotation(denotationSpan)
        }
      }

      // Does not draw the instance.
      // When loading for the first time, all instances will be loaded at once.
      // The drawing of the instance is performed at a different time.
      addSource(source, type) {
        for (const element of source) {
          this._addInstanceFromElement(type, element)
        }

        this._updateSpanTree()
      }

      hasDenotationSpan(begin, end) {
        const spanID = makeDenotationSpanHTMLElementID(
          this._editorID,
          begin,
          end
        )
        return this._denotations.has(spanID)
      }

      hasBlockSpan(begin, end) {
        const spanID = makeBlockSpanHTMLElementID(this._editorID, begin, end)
        return this._blocks.has(spanID)
      }

      hasBlockSpanBetween(begin, end, option = {}) {
        for (const blockSpan of this._blocks.values()) {
          if (
            begin <= blockSpan.begin &&
            blockSpan.end <= end &&
            option &&
            blockSpan.id !== option.excluded
          ) {
            return true
          }
        }

        return false
      }

      hasParentOf(begin, end, spanID) {
        for (const parent of this.all) {
          if (parent.id === spanID) {
            continue
          }

          if (parent.begin <= begin && end <= parent.end) {
            return true
          }
        }

        return false
      }

      /**
       *
       * @returns {import('./SpanModel').default}
       */
      get(spanID) {
        if (this._denotations.has(spanID)) {
          return this._denotations.get(spanID)
        } else if (this._blocks.has(spanID)) {
          return this._blocks.get(spanID)
        } else {
          // Returns a typesetting only.
          return this._styles.get(spanID)
        }
      }

      getStyle(spanID) {
        if (this._styles.has(spanID)) {
          return this._styles.get(spanID).styles
        } else {
          return new Set()
        }
      }

      getDenotationSpan(spanID) {
        if (this._denotations.has(spanID)) {
          return this._denotations.get(spanID)
        }
      }

      rangeDenotationSpan(firstID, secondID) {
        return rangeFrom(this._denotations, firstID, secondID)
      }

      rangeBlockSpan(firstID, secondID) {
        return rangeFrom(this._blocks, firstID, secondID)
      }

      get topLevel() {
        return this.all
          .filter((span) => span.parent === this)
          .sort(spanComparator)
      }

      get children() {
        return this.topLevel
      }

      clear() {
        this._denotations.clear()
        this._blocks.clear()
        this._styles.clear()
      }

      remove(id) {
        const blockSpan = this._blocks.get(id)
        if (blockSpan) {
          this._removeBlock(blockSpan)
          return
        }

        const denotationSpan = this._denotations.get(id)
        if (denotationSpan) {
          this._removeDenotation(denotationSpan)
          return
        }

        console.assert(false, `There is no target for remove for ${id}!`)
      }

      // Since moving a span is deleting and adding span tags,
      // we will delete and add the model as well.
      moveDenotationSpan(id, begin, end) {
        console.assert(
          id !== makeDenotationSpanHTMLElementID(this._editorID, begin, end),
          `Do not need move span:  ${id} ${begin} ${end}`
        )

        const oldSpan = this._denotations.get(id)
        console.assert(oldSpan, `There is no target for move for ${id}!`)

        this._removeDenotation(oldSpan)

        const newOne = new DenotationSpanModel(
          this._editorID,
          this._editorHTMLElement,
          begin,
          end,
          this._entityContainer,
          this
        )
        this._addDenotation(newOne, oldSpan)
        this._emitter.emit('textae-event.annotation-data.span.move')

        return {
          begin: oldSpan.begin,
          end: oldSpan.end,
          id: newOne.id
        }
      }

      moveBlockSpan(id, begin, end) {
        console.assert(
          id !== makeBlockSpanHTMLElementID(this._editorID, begin, end),
          `Do not need move span:  ${id} ${begin} ${end}`
        )

        const oldSpan = this._blocks.get(id)
        this._removeBlock(oldSpan)

        const newOne = new BlockSpanModel(
          this._editorID,
          this._editorHTMLElement,
          begin,
          end,
          this._entityContainer,
          this,
          this._textBox
        )
        this._addBlock(newOne, oldSpan)
        this._emitter.emit('textae-event.annotation-data.span.move')

        return {
          begin: oldSpan.begin,
          end: oldSpan.end,
          id: newOne.id
        }
      }

      _addDenotation(denotationSpan, oldSpan = null) {
        this._addSpan(this._denotations, denotationSpan, oldSpan)
        this._emitter.emit(
          `textae-event.annotation-data.span.add`,
          denotationSpan
        )

        return denotationSpan
      }

      _addBlock(blockSpan, oldSpan = null) {
        this._addSpan(this._blocks, blockSpan, oldSpan)
        this._emitter.emit(`textae-event.annotation-data.span.add`, blockSpan)

        return blockSpan
      }

      _addSpan(container, span, oldSpan = null) {
        container.set(span.id, span)
        this._updateSpanTree()

        if (oldSpan) {
          // Span.entities depends on the property of the entity.
          // Span DOM element is rendered by 'span.add' event.
          // We need to update the span ID of the entity before 'span.add' event.
          oldSpan.passesAllEntitiesTo(span)
        }

        span.render()

        const { clientHeight, clientWidth } = document.documentElement
        span.drawGrid(clientHeight, clientWidth)
      }

      _removeDenotation(span) {
        this._denotations.delete(span.id)
        span.erase()
        this._emitter.emit(`textae-event.annotation-data.span.remove`, span)
      }

      _removeBlock(span) {
        this._blocks.delete(span.id)
        span.erase()
        this._emitter.emit(`textae-event.annotation-data.span.remove`, span)
      }

      isBoundaryCrossingWithOtherSpans(begin, end) {
        return isBoundaryCrossingWithOtherSpans(this.all, begin, end)
      }

      doesParentOrSameSpanExist(begin, end) {
        const isParent = (span) => span.begin <= begin && end <= span.end

        return (
          [...this._denotations.values()].some(isParent) ||
          [...this._blocks.values()].some(isParent) ||
          [...this._styles.values()].some(isParent)
        )
      }

      get all() {
        const styleOnlySpans = [...this._styles.values()].filter(
          (s) => !this._denotations.has(s.id)
        )
        return [...this._blocks.values()]
          .concat([...this._denotations.values()])
          .concat(styleOnlySpans)
      }

      get selectedItems() {
        return [...this._blocks.values()]
          .concat([...this._denotations.values()])
          .filter(({ isSelected }) => isSelected)
      }

      get allDenotationSpans() {
        return [...this._denotations.values()]
      }

      get allBlockSpans() {
        return [...this._blocks.values()]
      }

      // It has a common interface with the span model so that it can be the parent of the span model.
      get begin() {
        return 0
      }

      // It has a common interface with the span model so that it can be the parent of the span model
      get element() {
        return this._editorHTMLElement.querySelector(`.textae-editor__text-box`)
      }

      _updateSpanTree() {
        // Register a typesetting in the span tree to put it in the span rendering flow.
        updateSpanTree(this, this.all)
      }

      _addInstanceFromElement(type, denotation) {
        switch (type) {
          case 'denotation': {
            const objectSpan = new DenotationSpanModel(
              this._editorID,
              this._editorHTMLElement,
              denotation.span.begin,
              denotation.span.end,
              this._entityContainer,
              this
            )

            if (!this._denotations.has(objectSpan.id)) {
              this._denotations.set(objectSpan.id, objectSpan)
            }
            break
          }
          case 'block': {
            const blockSpan = new BlockSpanModel(
              this._editorID,
              this._editorHTMLElement,
              denotation.span.begin,
              denotation.span.end,
              this._entityContainer,
              this,
              this._textBox
            )

            if (!this._blocks.has(blockSpan.id)) {
              this._blocks.set(blockSpan.id, blockSpan)
            }
            break
          }
          case 'typesetting': {
            const styleSpan = new StyleSpanModel(
              this._editorID,
              this._editorHTMLElement,
              denotation.span.begin,
              denotation.span.end,
              this,
              denotation.style
            )

            // Merge multiple styles for the same range.
            if (this._styles.has(styleSpan.id)) {
              this._styles.get(styleSpan.id).appendStyles(styleSpan.styles)
            } else {
              this._styles.set(styleSpan.id, styleSpan)
            }

            break
          }
          default:
            throw `${type} is unknown type span!`
        }
      }

      arrangeDenotationEntityPosition() {
        for (const span of this.allDenotationSpans) {
          span.updateGridPosition()
        }
      }

      arrangeBlockEntityPosition() {
        for (const span of this.allBlockSpans) {
          span.updateGridPosition()
        }
      }

      arrangeBackgroundOfBlockSpanPosition() {
        for (const span of this.allBlockSpans) {
          span.updateBackgroundPosition()
        }
      }

      get maxHeight() {
        const spans = [...this._blocks.values()].concat([
          ...this._denotations.values()
        ])

        if (spans.length) {
          return getCurrentMaxHeight(spans)
        } else {
          return null
        }
      }
    } // CONCATENATED MODULE: ./src/lib/isUri.js

    /* harmony default export */ function isUri(type) {
      return type.trim().startsWith('http')
    } // CONCATENATED MODULE: ./src/lib/Editor/getMatchPrefix.js

    /* harmony default export */ function getMatchPrefix(namespace, type) {
      const namespaces = namespace.all
      const matchs = namespaces
        .filter((namespace) => namespace.prefix !== '_base')
        .filter((namespace) => {
          return type.indexOf(`${namespace.prefix}:`) === 0
        })
      if (matchs.length === 1) return matchs[0]
      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/getUrlMatches.js

    /* harmony default export */ function getUrlMatches(type) {
      // The regular-expression to parse URL.
      // See detail:
      // http://someweblog.com/url-regular-expression-javascript-link-shortener/
      const urlRegex =
        /\(?(?:(http|https|ftp):\/\/)?(?:((?:[^\W\s]|\.|-|[:]{1})+)@{1})?((?:www.)?(?:[^\W\s]|\.|-)+[.][^\W\s]{2,4}|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?::(\d*))?([/]?[^\s?]*[/]{1})*(?:\/?([^\s\n?[\]{}#]*(?:(?=\.)){1}|[^\s\n?[\]{}.#]*)?([.]{1}[^\s?#]*)?)?(?:\?{1}([^\s\n#[\]]*))?([#][^\s\n]*)?\)?/gi
      return urlRegex.exec(type)
    } // CONCATENATED MODULE: ./src/lib/Editor/getDisplayName/getDisplayNameFromUri.js

    // Display short name for URL(http or https);
    /* harmony default export */ function getDisplayNameFromUri(type) {
      // For tunning, search the scheme before execute a regular-expression.
      if (isUri(type)) {
        const matches = getUrlMatches(type)

        if (matches) {
          // Order to dispaly.
          // 1. The anchor without #.
          if (matches[9]) return matches[9].slice(1)

          // 2. The file name with the extention.
          if (matches[6]) return matches[6] + (matches[7] || '')

          // 3. The last directory name.
          // Exclude slash only. cf. http://hoge.com/
          if (matches[5] && matches[5].length > 1)
            return matches[5]
              .split('/')
              .filter((s) => {
                return s !== ''
              })
              .pop()

          // 4. The domain name.
          return matches[3]
        }
      }
      return type
    } // CONCATENATED MODULE: ./src/lib/Editor/getDisplayName/index.js

    /* harmony default export */ function getDisplayName(
      namespace,
      value,
      displayName
    ) {
      // When a type id has label attrdute.
      if (displayName) {
        return displayName
      }

      // When a type id is uri
      if (isUri(value)) {
        return getDisplayNameFromUri(value)
      }

      const match = getMatchPrefix(namespace, value)
      if (match) {
        return value.replace(`${match.prefix}:`, '')
      }

      return value
    } // CONCATENATED MODULE: ./src/lib/Editor/hexToRGBA.js

    /* harmony default export */ function hexToRGBA(hex, alpha) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
      console.assert(result, `${hex} is not a hexadecimal color values!`)

      return `rgba(${parseInt(result[1], 16)}, ${parseInt(
        result[2],
        16
      )}, ${parseInt(result[3], 16)}, ${alpha})`
    } // CONCATENATED MODULE: ./src/lib/Editor/getLabelBackgroundColor.js

    /* harmony default export */ function getLabelBackgroundColor() {
      return hexToRGBA('#FFFFFF', 0.6)
    } // CONCATENATED MODULE: ./src/lib/Editor/getUri.js

    /* harmony default export */ function getUri(namespace, value, uri) {
      if (isUri(value)) {
        return value
      }

      if (uri) {
        return uri
      }

      if (namespace.some) {
        const match = getMatchPrefix(namespace, value)

        if (match) {
          return `${match.uri}${value.replace(`${match.prefix}:`, '')}`
        }

        const base = namespace.all.find(
          (namespace) => namespace.prefix === '_base'
        )
        if (base) {
          return `${base.uri}${value}`
        }
      }

      return null
    }

    // EXTERNAL MODULE: ./node_modules/eskape/index.js
    var eskape = __webpack_require__(4576)
    var eskape_default = /*#__PURE__*/ __webpack_require__.n(eskape) // CONCATENATED MODULE: ./src/lib/Editor/toAnchorElement.js
    /* harmony default export */ function toAnchorElement(displayName, href) {
      return href
        ? eskape_default()`<a target="_blank" href="${href}">${displayName}</a>`
        : eskape_default()`${displayName}`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/AttributeModelContainer/AttributeModel.js

    class AttributeModel {
      // Expected an attribute like {id: "A1", subj: "T1", pred: "example_predicate_1", obj: "attr1"}.
      constructor(
        { id, subj, pred, obj },
        entityContainer,
        relationContaier,
        namespace,
        definitionContainer
      ) {
        this.id = id
        this.subj = subj
        this.pred = pred
        this._obj = obj
        this._entityContainer = entityContainer
        this._relationContaier = relationContaier
        this._namespace = namespace
        this._definitionContainer = definitionContainer
      }

      get obj() {
        return this._obj
      }

      set obj(value) {
        if (this._valueType === 'numeric') {
          this._obj = parseFloat(value)
        } else {
          this._obj = value
        }
      }

      get subjectModel() {
        return (
          this._entityContainer.get(this.subj) ||
          this._relationContaier.get(this.subj)
        )
      }

      get JSON() {
        return {
          id: this.id,
          subj: this.subj,
          pred: this.pred,
          obj: this._obj
        }
      }

      equalsTo(pred, obj) {
        // If the attribute is a numeric type,
        // then the type of obj is numeric.
        // Cast obj to a string to compare.
        return this.pred === pred && String(this._obj) === obj
      }

      render() {
        this.subjectModel.updateElement()
      }

      erase() {
        this.subjectModel.updateElement()
      }

      clarifyLabelIn(parentElement) {
        parentElement.querySelector(
          `[data-pred="${this.pred}"][data-obj="${this.obj}"] .textae-editor__signboard__attribute-label`
        ).style.backgroundColor = hexToRGBA(this._color, 1)
      }

      declarifyLabelIn(parentElement) {
        parentElement.querySelector(
          `[data-pred="${this.pred}"][data-obj="${this.obj}"] .textae-editor__signboard__attribute-label`
        ).style.backgroundColor = getLabelBackgroundColor()
      }

      get contentHTML() {
        return `
      <div
        class="textae-editor__signboard__attribute"
        title="${this._title}"
        data-pred="${this.pred}"
        data-obj="${this.obj}"
        ${`style="background-color: ${hexToRGBA(this._color, 0.4)}; height: ${
          this.height
        }px;"`}
        >
        <span
          class="textae-editor__signboard__attribute-label"
          ${`style="background-color: ${getLabelBackgroundColor()};"`}
          >
          ${this._labelOrMedia}
        </span>
      </div>
      `
      }

      get height() {
        if (
          this._isMedia &&
          this._definitionContainer.get(this.pred).mediaHeight
        ) {
          return this._definitionContainer.get(this.pred).mediaHeight
        } else {
          return 18
        }
      }

      get _title() {
        return `[${this.id}] pred: ${this.pred}, value: ${this._obj}`
      }

      get _labelOrMedia() {
        if (this._isMedia) {
          return `<img src="${this.obj}" height="${this.height}" >`
        } else {
          return toAnchorElement(this._displayName, this._href)
        }
      }

      get _isMedia() {
        return (
          this._valueType === 'string' && /\.(jpg|png|gif)$/.test(this._href)
        )
      }

      get _displayName() {
        return getDisplayName(
          this._namespace,
          typeof this._obj === 'string' ? this._obj : '',
          this._definitionContainer.getDisplayName(this.pred, this._obj)
        )
      }

      get _href() {
        return getUri(
          this._namespace,
          typeof this._obj === 'string' ? this._obj : ''
        )
      }

      get _color() {
        return (
          this._definitionContainer.getColor(this.pred, this._obj) ||
          this.subjectModel.color
        )
      }

      get _valueType() {
        return this._definitionContainer.get(this.pred).valueType
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/IdIssueContainer/issueId/getNextId/getIssuedNumbers/onlyNumber.js

    /* harmony default export */ function onlyNumber(id) {
      return id.slice(1)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/IdIssueContainer/issueId/getNextId/getIssuedNumbers/isWellFormed.js

    /* harmony default export */ function isWellFormed(prefix, id) {
      // The format of id is a prefix and a number, for exapmle 'T1'.
      return new RegExp(`^${prefix}\\d+$`).test(id)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/IdIssueContainer/issueId/getNextId/getIssuedNumbers/inedx.js

    /* harmony default export */ function inedx(ids, prefix) {
      return ids.filter((id) => isWellFormed(prefix, id)).map(onlyNumber)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/IdIssueContainer/issueId/getNextId/getNextNumber.js

    /* harmony default export */ function getNextNumber(numbers) {
      // The Math.max retrun -Infinity when the second argument array is empty.
      const max = numbers.length === 0 ? 0 : Math.max(...numbers)
      return max + 1
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/IdIssueContainer/issueId/getNextId/index.js

    /* harmony default export */ function getNextId(prefix, existsIds) {
      const numbers = inedx(existsIds, prefix)
      const nextNumber = getNextNumber(numbers)

      return prefix + nextNumber
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/IdIssueContainer/issueId/index.js

    /* harmony default export */ function issueId(instance, container, prefix) {
      if (!instance.id) {
        // Overwrite to revert
        const ids = Array.from(container.keys())
        const newId = getNextId(prefix, ids)
        instance.id = newId
      }
      return instance
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/IdIssueContainer/index.js

    class IdIssueContainer extends ModelContainer {
      constructor(emitter, name, prefix) {
        super(emitter, name)

        this._prefix = prefix
      }

      _toModels(rowDatum, type) {
        const collection = super._toModels(rowDatum, type)

        // Move medols without id behind others, to prevet id duplication generated and exists.
        collection.sort((a, b) => {
          if (!a.id) return 1
          if (!b.id) return -1
          if (a.id < b.id) return -1
          if (a.id > b.id) return 1

          return 0
        })

        return collection
      }

      _addToContainer(instance) {
        return super._addToContainer(
          issueId(instance, this._container, this._prefix)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/AttributeModelContainer/index.js

    class AttributeModelContainer extends IdIssueContainer {
      constructor(
        emitter,
        entityContainer,
        relationContaier,
        namespace,
        definitionContainer
      ) {
        super(emitter, 'attribute', 'A')

        this._entityContainer = entityContainer
        this._relationContaier = relationContaier
        this._namespace = namespace
        this._definitionContainer = definitionContainer
      }

      _toModel(attribute) {
        return new AttributeModel(
          attribute,
          this._entityContainer,
          this._relationContaier,
          this._namespace,
          this._definitionContainer
        )
      }

      add(newValue) {
        // When redoing, the newValue is instance of the AttributeModel already.
        newValue =
          newValue instanceof AttributeModel
            ? newValue
            : this._toModel(newValue)

        super.add(newValue)

        newValue.render()

        return newValue
      }

      change(id, newPred, newObj) {
        const model = this.get(id)

        if (newPred) {
          model.pred = newPred
        }

        if (newObj) {
          model.obj = newObj
        }

        return model
      }

      remove(id) {
        const instance = super.remove(id)

        console.assert(instance, `There are no attribute ${id} to delete!`)

        instance.erase()
      }

      getSameDefinitionsAttributes(pred) {
        return this.all.filter((attr) => attr.pred === pred)
      }

      getSameAttributes(pred, obj) {
        return this.all.filter((a) => a.equalsTo(pred, obj))
      }

      /**
       *
       * @param {string} subj
       * @returns {AttributeModel[]}
       */
      getAttributesFor(subj) {
        return this.all
          .filter((a) => a.subj === subj)
          .sort((a, b) =>
            this._definitionContainer.attributeCompareFunction(a, b)
          )
      }
    } // CONCATENATED MODULE: ./src/lib/TypeValues.js

    class TypeValues {
      constructor(typeName, attributes = []) {
        this._typeName = typeName
        this._attributes = attributes
      }

      get typeName() {
        return this._typeName
      }

      get attributes() {
        return this._attributes
      }

      get JSON() {
        return {
          obj: this._typeName,
          attributes: this._attributes.map(({ JSON }) => JSON)
        }
      }

      isSameType(typeName, attributes = null) {
        if (attributes) {
          return (
            this.typeName === typeName && this._hasSameAttributes(attributes)
          )
        }

        return this.typeName === typeName
      }

      hasSpecificPredicateAttribute(pred) {
        return this.attributes.some((a) => a.pred === pred)
      }

      _hasSameAttributes(newAttributes) {
        if (newAttributes.length != this.attributes.length) {
          return false
        }

        const clone = [...newAttributes]
        for (const attribute of this.attributes) {
          const index = clone.findIndex(
            (a) => a.pred === attribute.pred && a.obj === String(attribute.obj)
          )
          if (index === -1) {
            return false
          }
          clone.splice(index, 1)
        }

        if (clone.length === 0) {
          return true
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/updatePath.js

    /* harmony default export */ function updatePath(
      path,
      curveAlgorithm,
      color,
      isBold
    ) {
      path.setAttribute('d', curveAlgorithm.pathCommands)

      path.setAttribute('style', `stroke: ${color};`)

      if (isBold) {
        path.classList.add('textae-editor__relation--isBold')
      } else {
        path.classList.remove('textae-editor__relation--isBold')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/NS.js

    const NS = {
      SVG: 'http://www.w3.org/2000/svg'
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/MarkerHeight.js

    const MarkerHeight = 6 // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/createSourceBollard.js

    /* harmony default export */ function createSourceBollard() {
      const bollard = document.createElementNS(NS.SVG, 'polygon')
      bollard.setAttribute(
        'points',
        `-4 ${MarkerHeight}, 4 ${MarkerHeight}, 0 0`
      )

      return bollard
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/createTargetBollard.js

    /* harmony default export */ function createTargetBollard() {
      const bollard = document.createElementNS(NS.SVG, 'polygon')
      bollard.setAttribute('points', `-4 0, 4 0, 0 ${MarkerHeight}`)

      return bollard
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/createPath.js

    /**
     *
     * @returns {SVGGraphicsElement} path
     */
    /* harmony default export */ function createPath() {
      const path = document.createElementNS(NS.SVG, 'path')
      path.classList.add('textae-editor__relation')
      return path
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/moveJetty.js

    /**
     *
     * @param {Element} jetty
     * @param {number} x
     * @param {number} y
     * @param {import('../../../../../EntityModel').default} entity
     */
    /* harmony default export */ function moveJetty(jetty, x, y, entity) {
      jetty.setAttribute(
        'points',
        `${x} ${y + MarkerHeight}, ${entity.offsetCenter} ${
          y + MarkerHeight
        }, ${entity.offsetCenter} ${entity.offsetTop}`
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/createJetty.js

    /* harmony default export */ function createJetty(x, y, entity) {
      const jetty = document.createElementNS(NS.SVG, 'polyline')

      moveJetty(jetty, x, y, entity)

      return jetty
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/CurveAlgorithm.js

    class CurveAlgorithm {
      /**
       * @param {import('./StartAndEnd').startAndEnd} startAndEnd
       * @param {boolean} alignSourceBollards
       * @param {boolean} alignTargetBollards
       * @param {number} clientTopOfContainer
       * @param {number} column
       */
      constructor(
        startAndEnd,
        alignSourceBollards,
        alignTargetBollards,
        controlBarHeight,
        clientTopOfContainer
      ) {
        this._controlY =
          startAndEnd.offsetTop -
          startAndEnd.horizontalDistance / 4 -
          20 +
          (alignSourceBollards && alignTargetBollards ? 3 : 0)
        this._startAndEnd = startAndEnd
        this._controlBarHeight = controlBarHeight
        this._clientTopOfContainer = clientTopOfContainer

        this._virtualEntityWidth = 100
      }

      get sourceX() {
        return this._startAndEnd.start.x
      }
      get targetX() {
        return this._startAndEnd.end.x
      }

      get sourceY() {
        return this._startAndEnd.start.y - MarkerHeight
      }
      get targetY() {
        return this._startAndEnd.end.y - MarkerHeight
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
            C ${this._sourceControlX} ${this._controlY}, ${this._targetControlX} ${this._controlY}, ${this.targetX} ${this.targetY}`
      }

      get transformDefinitionsForSourceTriangle() {
        return `translate(${this.sourceX}, ${this.sourceY})`
      }

      get transformDefinitionsForTargetTriangle() {
        return `translate(${this.targetX}, ${this.targetY})`
      }

      getTForY(y) {
        const sample = 20

        // https://ja.javascript.info/bezier-curve
        // (1t)3P1 + 3(1t)2tP2 +3(1t)t2P3 + t3P4
        return [...Array(sample).keys()]
          .map((i) => (i * 1) / sample)
          .find((t) => {
            const labelY =
              Math.pow(1 - t, 3) * this.sourceY +
              3 * Math.pow(1 - t, 2) * t * this._controlY +
              3 * (1 - t) * Math.pow(t, 2) * this._controlY +
              Math.pow(t, 3) * this.targetY
            return Math.abs(labelY - y) < 1
          })
      }

      getXOnT(_t) {
        const {
          sourceX,
          targetX,
          _sourceControlX: sourceControlX,
          _targetControlX: targetControlX
        } = this

        return (
          Math.pow(1 - _t, 3) * sourceX +
          3 * Math.pow(1 - _t, 2) * _t * sourceControlX +
          3 * (1 - _t) * Math.pow(_t, 2) * targetControlX +
          Math.pow(_t, 3) * targetX
        )
      }

      get _sourceControlX() {
        return this._startAndEnd.start.x
      }

      get _targetControlX() {
        return this._startAndEnd.end.x
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/BentOnTargetCurveAlgorithm.js

    class BentOnTargetCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return true
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
              C ${this._sourceControlX} ${this._controlY}, ${this._targetControlX} ${this._controlY}, ${this._junctionPointX} ${this._junctionPointY}
              Q ${this.targetX} ${this._additionalControlY}, ${this.targetX} ${this.targetY}`
      }

      getTForY(y) {
        const sample = 20

        // https://ja.javascript.info/bezier-curve
        // (1t)3P1 + 3(1t)2tP2 +3(1t)t2P3 + t3P4
        return [...Array(sample).keys()]
          .map((i) => (i * 1) / sample)
          .find((t) => {
            const labelY =
              Math.pow(1 - t, 3) * this.sourceY +
              3 * Math.pow(1 - t, 2) * t * this._controlY +
              3 * (1 - t) * Math.pow(t, 2) * this._controlY +
              Math.pow(t, 3) * this._junctionPointY
            return Math.abs(labelY - y) < 1
          })
      }

      get _additionalControlY() {
        return this.sourceY * 0.3 + this.targetY * 0.7
      }

      get _junctionPointX() {
        return this._targetControlX * 0.25 + this.targetX * 0.75
      }

      get _junctionPointY() {
        return this._controlY * 0.25 + this._additionalControlY * 0.75
      }

      get _targetControlX() {
        return (
          this._startAndEnd.end.x +
          (this._startAndEnd.isPointingToRight ? 150 : -150)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/BentOnSourceCurveAlgorithm.js

    class BentOnSourceCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return true
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
              Q ${this.sourceX} ${this._additionalControlY}, ${this._junctionPointX} ${this._junctionPointY}
              C ${this._sourceControlX} ${this._controlY}, ${this._targetControlX} ${this._controlY}, ${this.targetX} ${this.targetY}`
      }

      getTForY(y) {
        const sample = 20

        // https://ja.javascript.info/bezier-curve
        // (1t)3P1 + 3(1t)2tP2 +3(1t)t2P3 + t3P4
        return [...Array(sample).keys()]
          .map((i) => (i * 1) / sample)
          .find((t) => {
            const labelY =
              Math.pow(1 - t, 3) * this._junctionPointY +
              3 * Math.pow(1 - t, 2) * t * this._controlY +
              3 * (1 - t) * Math.pow(t, 2) * this._controlY +
              Math.pow(t, 3) * this.targetY

            return Math.abs(labelY - y) < 1
          })
      }

      get _additionalControlY() {
        return this.sourceY * 0.7 + this.targetY * 0.3
      }

      get _junctionPointX() {
        return this._sourceControlX * 0.25 + this.sourceX * 0.75
      }

      get _junctionPointY() {
        return this._controlY * 0.25 + this._additionalControlY * 0.75
      }

      get _sourceControlX() {
        return (
          this._startAndEnd.start.x +
          (this._startAndEnd.isPointingToRight ? 150 : -150)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/PointingDownCurveAlgorithm.js

    class PointingDownCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }
      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY + MarkerHeight}
      C ${this._sourceControlX} ${
          this.sourceY + Math.abs(this.targetY - this.sourceY) / 3
        }, ${this._targetControlX} ${
          this.targetY - Math.abs(this.targetY - this.sourceY) / 3
        }, ${this.targetX} ${this.targetY}`
      }

      get transformDefinitionsForSourceTriangle() {
        return `rotate(180, ${this.sourceX}, ${this.sourceY + 3}) translate(${
          this.sourceX
        }, ${this.sourceY})`
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        return this._controlBarHeight - this._clientTopOfContainer
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/PointingUpCurveAlgorithm.js

    class PointingUpCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
      C ${this._sourceControlX} ${
          this.sourceY - Math.abs(this.targetY - this.sourceY) / 3
        }, ${this._targetControlX} ${
          this.targetY + Math.abs(this.targetY - this.sourceY) / 3
        }, ${this.targetX} ${this.targetY + MarkerHeight}`
      }

      get transformDefinitionsForTargetTriangle() {
        return ` rotate(180, ${this.targetX}, ${this.targetY + 3}) translate(${
          this.targetX
        }, ${this.targetY})`
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        return this._controlBarHeight - this._clientTopOfContainer
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/ArchedCurveAlgorithm.js

    class ArchedCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return true
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/StartAndEnd.js

    class StartAndEnd_startAndEnd {
      /**
       *
       * @param {import('../../../../../../../EntityModel').default} sourceEntity
       * @param {import('../../../../../../../EntityModel').default} targetEntity
       * @returns
       */
      constructor(relation, alignSourceBollards, alignTargetBollards) {
        this._relation = relation
        this._sourceEntity = relation.sourceEntity
        this._targetEntity = relation.targetEntity

        const sourceY =
          this._sourceEntity.offsetTop - (alignSourceBollards ? 3 : 0)
        const targetY =
          this._targetEntity.offsetTop - (alignTargetBollards ? 3 : 0)

        const sourceAnchorPosition =
          this._sourceEntity.getSourceAnchorPosition(alignSourceBollards)
        const targetAnchorPosition =
          this._targetEntity.getTargetAnchorPosition(alignTargetBollards)

        if (
          this._sourceEntity.offsetCenter === this._targetEntity.offsetCenter
        ) {
          this._start = {
            y: sourceY,
            x: this._sourceEntity.offsetCenter
          }
          this._end = {
            y: targetY,
            x: this._targetEntity.offsetCenter
          }
          return
        }

        if (sourceY < targetY) {
          const sourceAnchor = this.isPointingToRight ? 'right' : 'left'
          const targetAnchor =
            sourceAnchorPosition[sourceAnchor] < this._targetEntity.offsetCenter
              ? 'left'
              : 'right'

          this._start = {
            y: sourceY,
            x: sourceAnchorPosition[sourceAnchor]
          }
          this._end = {
            y: targetY,
            x: targetAnchorPosition[targetAnchor]
          }
          return
        } else if (sourceY > targetY) {
          const targetAnchor = this.isPointingToRight ? 'left' : 'right'
          const sourceAnchor =
            targetAnchorPosition[targetAnchor] < this._sourceEntity.offsetCenter
              ? 'left'
              : 'right'

          this._start = {
            y: sourceY,
            x: sourceAnchorPosition[sourceAnchor]
          }
          this._end = {
            y: targetY,
            x: targetAnchorPosition[targetAnchor]
          }
          return
        } else {
          // When the source and target entities have the same height
          // Prevent source and target X coordinates from being swapped.
          if (this.isPointingToRight) {
            const targetAnchor =
              sourceAnchorPosition.right < targetAnchorPosition.left
                ? 'left'
                : 'right'

            this._start = {
              y: sourceY,
              x: sourceAnchorPosition.right
            }
            this._end = {
              y: targetY,
              x: targetAnchorPosition[targetAnchor]
            }
            return
          } else {
            const targetAnchor =
              sourceAnchorPosition.left < targetAnchorPosition.right
                ? 'left'
                : 'right'

            this._start = {
              y: sourceY,
              x: sourceAnchorPosition.left
            }
            this._end = {
              y: targetY,
              x: targetAnchorPosition[targetAnchor]
            }
            return
          }
        }
      }

      get start() {
        return this._start
      }

      get end() {
        return this._end
      }

      get isPointingToRight() {
        return this._sourceEntity.offsetCenter < this._targetEntity.offsetCenter
      }

      get isDownward() {
        return this._start.y < this._end.y
      }

      get offsetTop() {
        return Math.min(this._start.y, this._end.y)
      }

      get horizontalDistance() {
        return Math.abs(this._end.x - this._start.x)
      }

      get sourceXShiftRate() {
        const { relations } = this._sourceEntity.span
        const index = relations.indexOf(this._relation)
        return relations.length === 1 ? 0.5 : index / (relations.length - 1)
      }

      get targetXShiftRate() {
        const { relations } = this._targetEntity.span
        const index = relations.indexOf(this._relation)
        return relations.length === 1 ? 0.5 : index / (relations.length - 1)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/CutOffOnSourceBentOnSourceCurveAlgorithm.js

    class CutOffOnSourceBentOnSourceCurveAlgorithm extends BentOnSourceCurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/CutOffOnTargetBentOnTargetCurveAlgorithm.js

    class CutOffOnTargetBentOnTargetCurveAlgorithm extends BentOnTargetCurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/CutOffOnSourceBentOnTargetCurveAlgorithm.js

    class CutOffOnSourceBentOnTargetCurveAlgorithm extends BentOnTargetCurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/CutOffOnTargetBentOnSourceCurveAlgorithm.js

    class CutOffOnTargetBentOnSourceCurveAlgorithm extends BentOnSourceCurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/CutOffOnSourceArchedCurveAlgorithm.js

    class CutOffOnSourceArchedCurveAlgorithm extends ArchedCurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/CutOffOnTargetArchedCurveAlgorithm.js

    class CutOffOnTargetArchedCurveAlgorithm extends ArchedCurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/CurveAlgorithmFactory/index.js

    class CurveAlgorithmFactory {
      static create(
        relation,
        alignSourceBollards,
        alignTargetBollards,
        clientTopOfContainer,
        controlBarHeight
      ) {
        const startAndEnd = new StartAndEnd_startAndEnd(
          relation,
          alignSourceBollards,
          alignTargetBollards
        )

        const { sourceEntity, targetEntity } = relation

        if (
          targetEntity.clientBottom < controlBarHeight &&
          targetEntity.clientTop < sourceEntity.clientTop
        ) {
          return new PointingUpCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }

        if (
          sourceEntity.clientBottom < controlBarHeight &&
          sourceEntity.clientTop < targetEntity.clientTop
        ) {
          return new PointingDownCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }

        const { clientHeight } = document.documentElement
        if (
          Math.abs(sourceEntity.clientBottom - targetEntity.clientBottom) <
            12 ||
          42 < startAndEnd.horizontalDistance
        ) {
          if (clientHeight < sourceEntity.clientTop) {
            return new CutOffOnSourceArchedCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          if (clientHeight < targetEntity.clientTop) {
            return new CutOffOnTargetArchedCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          return new ArchedCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }

        if (startAndEnd.isDownward) {
          if (clientHeight < sourceEntity.clientTop) {
            return new CutOffOnSourceBentOnTargetCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          if (clientHeight < targetEntity.clientTop) {
            return new CutOffOnTargetBentOnTargetCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          return new BentOnTargetCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        } else {
          if (clientHeight < sourceEntity.clientTop) {
            return new CutOffOnSourceBentOnSourceCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          if (clientHeight < targetEntity.clientTop) {
            return new CutOffOnTargetBentOnSourceCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          return new BentOnSourceCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Arrow/index.js

    class Arrow {
      constructor(
        editorHTMLElement,
        relation,
        controlBarHeight,
        onAuraClick,
        onBollardClick,
        onMouseEnter,
        onMouseLeave
      ) {
        this._container = editorHTMLElement.querySelector(
          '.textae-editor__relation-box'
        )
        this._relation = relation
        this._controlBarHeight = controlBarHeight

        const sourceBollard = createSourceBollard()
        this._container.appendChild(sourceBollard)
        this._sourceBollard = sourceBollard

        const targetBollard = createTargetBollard()
        this._container.appendChild(targetBollard)
        this._targetBollard = targetBollard

        const path = createPath()
        this._container.appendChild(path)
        this._path = path

        const pathAura = document.createElementNS(NS.SVG, 'path')
        pathAura.classList.add('textae-editor__relation-aura')
        pathAura.addEventListener('click', onAuraClick)
        pathAura.addEventListener('mouseenter', onMouseEnter)
        pathAura.addEventListener('mouseleave', onMouseLeave)
        const title = document.createElementNS(NS.SVG, 'title')
        pathAura.appendChild(title)
        this._container.appendChild(pathAura)
        this._pathAura = pathAura

        const sourceBollardAura = createSourceBollard()
        sourceBollardAura.classList.add('textae-editor__relation-bollard-aura')
        sourceBollardAura.addEventListener('click', (e) =>
          onBollardClick(e, relation.sourceEntity)
        )
        sourceBollardAura.appendChild(document.createElementNS(NS.SVG, 'title'))
        this._container.appendChild(sourceBollardAura)
        this._sourceBollardAura = sourceBollardAura

        const targetBollardAura = createTargetBollard()
        targetBollardAura.classList.add('textae-editor__relation-bollard-aura')
        targetBollardAura.addEventListener('click', (e) =>
          onBollardClick(e, relation.targetEntity)
        )
        targetBollardAura.appendChild(document.createElementNS(NS.SVG, 'title'))
        this._container.appendChild(targetBollardAura)
        this._targetBollardAura = targetBollardAura

        this._sourceJetty = null
        this._targetJetty = null

        this.update(false, false, false)
      }

      update(pointUpPath, pointUpSourceBollards, pointUpTargetBollards) {
        const curveAlgorithm = CurveAlgorithmFactory.create(
          this._relation,
          pointUpSourceBollards,
          pointUpTargetBollards,
          this._container.getBoundingClientRect().top,
          this._controlBarHeight
        )
        updatePath(
          this._path,
          curveAlgorithm,
          this._relation.color,
          pointUpPath
        )
        updatePath(this._pathAura, curveAlgorithm, this._relation.color, false)
        this._pathAura.children[0].textContent = this._relation.title

        this._sourceBollard.setAttribute(
          'style',
          `fill:${this._relation.sourceColor}`
        )
        this._sourceBollard.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForSourceTriangle
        )

        this._targetBollard.setAttribute(
          'style',
          `fill:${this._relation.targetColor}`
        )
        this._targetBollard.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForTargetTriangle
        )

        this._sourceBollardAura.children[0].textContent =
          this._relation.sourceEntity.title
        this._sourceBollardAura.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForSourceTriangle
        )

        this._targetBollardAura.children[0].textContent =
          this._relation.targetEntity.title
        this._targetBollardAura.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForTargetTriangle
        )

        if (pointUpSourceBollards && curveAlgorithm.isSourceJettyVisible) {
          this._drawSourceJetty(curveAlgorithm)
        } else {
          this._destroySourceJetty()
        }

        if (pointUpTargetBollards && curveAlgorithm.isTargetJettyVisible) {
          this._drawTargetJetty(curveAlgorithm)
        } else {
          this._destroyTargetJetty()
        }

        this._curveAlgorithm = curveAlgorithm
      }

      destructor() {
        this._container.removeChild(this._path)
        this._container.removeChild(this._sourceBollardAura)
        this._container.removeChild(this._targetBollardAura)
        this._container.removeChild(this._pathAura)
        this._container.removeChild(this._sourceBollard)
        this._container.removeChild(this._targetBollard)

        this._destroySourceJetty()
        this._destroyTargetJetty()
      }

      get top() {
        return this._path.getBBox().y
      }

      get left() {
        return this._path.getBBox().x
      }

      get highestX() {
        const _t = this._curveAlgorithm.getTForY(this.top)

        return this._curveAlgorithm.getXOnT(_t)
      }

      get width() {
        return this._path.getBBox().width
      }

      _drawSourceJetty(curveAlgorithm) {
        const { sourceEntity } = this._relation

        if (this._sourceJetty) {
          moveJetty(
            this._sourceJetty,
            curveAlgorithm.sourceX,
            curveAlgorithm.sourceY,
            sourceEntity
          )
        } else {
          const sourceJetty = createJetty(
            curveAlgorithm.sourceX,
            curveAlgorithm.sourceY,
            sourceEntity
          )
          this._container.appendChild(sourceJetty)
          this._sourceJetty = sourceJetty
        }
      }

      _drawTargetJetty(curveAlgorithm) {
        const { targetEntity } = this._relation

        if (this._targetJetty) {
          moveJetty(
            this._targetJetty,
            curveAlgorithm.targetX,
            curveAlgorithm.targetY,
            targetEntity
          )
        } else {
          const targetJetty = createJetty(
            curveAlgorithm.targetX,
            curveAlgorithm.targetY,
            targetEntity
          )
          this._container.appendChild(targetJetty)
          this._targetJetty = targetJetty
        }
      }

      _destroySourceJetty() {
        if (this._sourceJetty) {
          this._container.removeChild(this._sourceJetty)
          this._sourceJetty = null
        }
      }

      _destroyTargetJetty() {
        if (this._targetJetty) {
          this._container.removeChild(this._targetJetty)
          this._targetJetty = null
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/SignboardHTMLElement.js

    const CSS_CLASS_SELECTED = 'textae-editor__signboard--selected'
    const CSS_CLASS_HOVERED = 'textae-editor__signboard--hovered'
    const CSS_CLASS_CUTTING = 'textae-editor__signboard--cutting'

    class SignboardHTMLElement {
      constructor(model, entityType, HTMLId) {
        this._model = model
        this._element = dohtml_default().create(
          this._getHtml(HTMLId, entityType)
        )
      }

      get element() {
        return this._element
      }

      addEventListener(event, listener) {
        this._element.addEventListener(event, listener)
      }

      hover() {
        this._element.classList.add(CSS_CLASS_HOVERED)
      }

      select() {
        this._element.classList.add(CSS_CLASS_SELECTED)
      }

      deselect() {
        this._element.classList.remove(CSS_CLASS_SELECTED)
      }

      startCut() {
        this._element.classList.add(CSS_CLASS_CUTTING)
      }

      cancelCut() {
        this._element.classList.remove(CSS_CLASS_CUTTING)
      }

      clearCSSClass() {
        this.element.className = ''
        this.element.classList.add('textae-editor__signboard')
      }

      updateLabel() {
        const typeValues = this.element.querySelector(
          '.textae-editor__signboard__type-values'
        )
        typeValues.style.backgroundColor = hexToRGBA(this._model.color, 0.4)
        typeValues.querySelector(
          '.textae-editor__signboard__type-label'
        ).innerHTML = this._model.anchorHTML

        // Re-create all attributes.
        for (const attributeElement of typeValues.querySelectorAll(
          '.textae-editor__signboard__attribute'
        )) {
          attributeElement.remove()
        }
        for (const a of this._model.attributes) {
          typeValues.insertAdjacentHTML('beforeend', a.contentHTML)
        }
      }

      clarifyLabel() {
        this.element.querySelector(
          '.textae-editor__signboard__type-label'
        ).style.backgroundColor = hexToRGBA(this._model.color, 1)

        for (const a of this._model.attributes) {
          a.clarifyLabelIn(this.element)
        }
      }

      declarifyLabel() {
        this.element.querySelector(
          '.textae-editor__signboard__type-label'
        ).style.backgroundColor = getLabelBackgroundColor()

        for (const a of this._model.attributes) {
          a.declarifyLabelIn(this.element)
        }
      }

      focus() {
        this._element
          .querySelector('.textae-editor__signboard__type-label')
          .focus()
      }

      replaceWith(signboardHTMLElement) {
        this._element.replaceWith(signboardHTMLElement.element)
        return signboardHTMLElement
      }

      reflectTypeGapInTheHeight(height) {
        this._element.setAttribute('style', `padding-top: ${height}px;`)
      }

      remove() {
        this._element.remove()
      }

      // A Type element has an entity_pane elment that has a label and will have entities.
      _getHtml(HTMLId, entityType) {
        return `
  <div
    class="textae-editor__signboard"
    ${HTMLId ? `id="${HTMLId}"` : ''}
    title="${this._model.title}"
    data-entity-type="${entityType}"
    data-id="${this._model.id}"
    >
    <div
      class="textae-editor__signboard__type-values"
      style="background-color: ${hexToRGBA(this._model.color, 0.4)};"
      >
      <div
        class="textae-editor__signboard__type-label"
        tabindex="0"
        style="background-color: ${getLabelBackgroundColor()};"
        >
        ${this._model.anchorHTML}
      </div>
      ${this._model.attributes.map((a) => a.contentHTML).join('')}
    </div>
  </div>
  `
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/Label.js

    class Label {
      /**
       *
       * @param {HTMLElement} editorHTMLElement
       * @param {import('.').default} relation
       * @param {import('./Arrow').default} arrow
       */
      constructor(
        editorHTMLElement,
        relation,
        arrow,
        onClick,
        onMouseEnter,
        onMouseLeave
      ) {
        this._container = getAnnotationBox(editorHTMLElement)
        this._relation = relation
        this._arrow = arrow

        this._location = dohtml_default().create(
          `<div class="textae-editor__relation__signboard-location"></div>`
        )
        this._updatePosition()

        this._signboard = new SignboardHTMLElement(relation, 'relation', null)
        this._location.appendChild(this._signboard.element)
        this._container.appendChild(this._location)

        this._location.addEventListener('click', onClick)
        this._location.addEventListener('mouseenter', onMouseEnter)
        this._location.addEventListener('mouseleave', onMouseLeave)
      }

      updateValue() {
        this._updatePosition()
        this._signboard.updateLabel()
      }

      updateHighlighting() {
        this._updatePosition()

        this._signboard.clearCSSClass()

        if (this._relation.isSelected) {
          this._signboard.select()
        } else if (this._relation.isHovered) {
          this._signboard.hover()
        }
      }

      destructor() {
        this._container.removeChild(this._location)
      }

      get y() {
        return this._background.getBBox().y
      }

      get width() {
        return this._location.getBBox().width
      }

      get height() {
        return this._location.getBBox().height
      }

      _updatePosition() {
        // Set the center of the label to the X coordinate of the highest point of the curve.
        this._location.style.width = '0px'
        this._location.style.left = `${this._arrow.highestX}px`

        this._location.style.top = `${
          this._arrow.top - 18 - this._relation.attributes.length * 18
        }px`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/RelationModel/index.js

    class RelationModel {
      constructor(
        editorHTMLElement,
        eventEmitter,
        entityContainer,
        attributeContainer,
        { id, pred, subj, obj },
        namespace,
        definitionContainer,
        controlBarHeight
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._eventEmitter = eventEmitter
        this._entityContainer = entityContainer
        this._attributeContainer = attributeContainer
        this._id = id
        this.typeName = pred
        this._subj = subj
        this._obj = obj
        this._namespace = namespace
        this._definitionContainer = definitionContainer
        this._controlBarHeight = controlBarHeight
        this._isSelected = false

        // When you click on a relation to deselect it, the display of the relation will be in hover.
        // When you click on the body and deselect the relation, the display of the relation becomes non-hover.
        // To make this distinction, the hover state is retained.
        this._isHovered = false
      }

      get id() {
        return this._id
      }

      set id(val) {
        this._id = val
      }

      get typeName() {
        return this._typeName
      }

      set typeName(val) {
        // Replace null to 'null' if type is null and undefined too.
        this._typeName = String(val)
      }

      get typeValues() {
        return new TypeValues(
          this._typeName,
          this._attributeContainer.getAttributesFor(this._id)
        )
      }

      get subj() {
        return this._subj
      }

      get obj() {
        return this._obj
      }

      get attributes() {
        return this._attributeContainer.getAttributesFor(this._id)
      }

      /** @returns {import('../../../EntityModel').default} */
      get sourceEntity() {
        return this._entityContainer.get(this.subj)
      }

      /** @returns {import('../../../EntityModel').default} */
      get targetEntity() {
        return this._entityContainer.get(this.obj)
      }

      get sourceColor() {
        return this.sourceEntity.color
      }

      get targetColor() {
        return this.targetEntity.color
      }

      get isSelected() {
        return this._isSelected
      }

      get isHovered() {
        return this._isHovered
      }

      select() {
        if (!this._isSelected) {
          this._isSelected = true
          // When we select a relation,
          // it is hovering and we have already highlighted the line,
          // so we only need to update the label.
          if (this._label) {
            this._label.updateHighlighting()
          }
        }
      }

      deselect() {
        if (this._isSelected) {
          this._isSelected = false
          if (this._arrow || this._label) {
            this.redrawLineConsideringSelection()
          }
        }
      }

      render(clientHeight, clientWidth) {
        if (
          this.sourceEntity.isInViewport(clientHeight, clientWidth) ||
          this.targetEntity.isInViewport(clientHeight, clientWidth)
        ) {
          if (!this._arrow) {
            this._arrow = new Arrow(
              this._editorHTMLElement,
              this,
              this._controlBarHeight,
              (event) => {
                this._eventEmitter.emit(
                  'textae-event.editor.relation.click',
                  event,
                  this
                )
                event.stopPropagation()
              },
              (event, entity) => {
                this._eventEmitter.emit(
                  'textae-event.editor.relation-bollard.click',
                  event,
                  entity
                )
                event.stopPropagation()
              },
              () => this._pointUpSelfAndEntities(),
              () => this._pointDownSelfAndEntities()
            )

            this._label = new Label(
              this._editorHTMLElement,
              this,
              this._arrow,
              (event, attribute) => {
                this._eventEmitter.emit(
                  'textae-event.editor.relation.click',
                  event,
                  this,
                  attribute
                )
                event.stopPropagation()
              },
              () => this._pointUpSelfAndEntities(),
              () => this._pointDownSelfAndEntities()
            )
          } else {
            this._redrawArrowConsideringSelection()
          }

          if (
            (this.sourceEntity.clientTop > this.targetEntity.clientTop &&
              this.targetEntity.isInViewport(clientHeight, clientWidth)) ||
            (this.sourceEntity.clientTop < this.targetEntity.clientTop &&
              this.sourceEntity.isInViewport(clientHeight, clientWidth)) ||
            this.sourceEntity.clientTop === this.targetEntity.clientTop
          ) {
            if (!this._label) {
              this._label = new Label(
                this._editorHTMLElement,
                this,
                this._arrow,
                (event, attribute) => {
                  this._eventEmitter.emit(
                    'textae-event.editor.relation.click',
                    event,
                    this,
                    attribute
                  )
                  event.stopPropagation()
                },
                () => this._pointUpSelfAndEntities(),
                () => this._pointDownSelfAndEntities()
              )

              // When scrolling out of a selected relation and then scrolling in again,
              // the selected state will be highlighted.
              this._label.updateHighlighting()
            } else {
              this._redrawLabelConsideringSelection()
            }
          } else {
            if (this._label) {
              this._label.destructor()
              this._label = undefined
            }
          }
        } else {
          if (this._arrow || this._label) {
            this.erase()
          }
        }
      }

      updateElement() {
        if (this._arrow) {
          this._arrow.update(
            this.isSelected || this._relation.isHovered,
            this.isSelected || this._relation.isHovered,
            this.isSelected || this._relation.isHovered
          )
        }

        if (this._label) {
          this._label.updateValue()
        }
      }

      redrawLineConsideringSelection() {
        this._redrawArrowConsideringSelection()
        this._redrawLabelConsideringSelection()
      }

      pointUpPathAndSourceBollards() {
        if (this._arrow) {
          if (this.targetEntity.isSelected) {
            this._arrow.update(true, true, true)
          } else {
            this._arrow.update(true, true, this.isSelected)
          }
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpPathAndTargetBollards() {
        if (this._arrow) {
          if (this.sourceEntity.isSelected) {
            this._arrow.update(true, true, true)
          } else {
            this._arrow.update(true, this.isSelected, true)
          }
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpSourceBollardsAndTargetBollards() {
        if (this._arrow) {
          this._arrow.update(this.isSelected, true, true)
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpSourceBollards() {
        if (this._arrow) {
          this._arrow.update(this.isSelected, true, this.isSelected)
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpTargetBollards() {
        if (this._arrow) {
          this._arrow.update(this.isSelected, this.isSelected, true)
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      erase() {
        if (this._arrow) {
          this._arrow.destructor()
          this._arrow = undefined
        }

        if (this._label) {
          this._label.destructor()
          this._label = undefined
        }
      }

      get title() {
        return `[${this.id}] pred: type, value: ${this.typeName}`
      }

      get color() {
        return this._definitionContainer.getColor(this.typeName)
      }

      get anchorHTML() {
        return toAnchorElement(this._displayName, this._href)
      }

      get _displayName() {
        return getDisplayName(
          this._namespace,
          this.typeName,
          this._definitionContainer.getLabel(this.typeName)
        )
      }

      get _href() {
        return getUri(
          this._namespace,
          this.typeName,
          this._definitionContainer.getUri(this.typeName)
        )
      }

      _pointUpSelfAndEntities() {
        this._isHovered = true
        this._arrow.update(true, true, true)
        if (this._label) {
          this._label.updateHighlighting()
        }

        const bothRelations = new Set()
        const sourceRelations = new Set()
        const targetRelations = new Set()

        for (const r of this.sourceEntity.relationsWhereThisIsSource) {
          if (r === this) {
            continue
          }

          if (r.targetEntity == this.targetEntity) {
            bothRelations.add(r)
          } else {
            sourceRelations.add(r)
          }
        }

        for (const r of this.sourceEntity.relationsWhereThisIsTarget) {
          if (r === this) {
            continue
          }

          if (r.sourceEntity == this.targetEntity) {
            bothRelations.add(r)
          } else {
            targetRelations.add(r)
          }
        }

        for (const r of this.targetEntity.relationsWhereThisIsSource) {
          if (r === this) {
            continue
          }

          if (r.targetEntity == this.sourceEntity) {
            bothRelations.add(r)
          } else {
            sourceRelations.add(r)
          }
        }

        for (const r of this.targetEntity.relationsWhereThisIsTarget) {
          if (r === this) {
            continue
          }

          if (r.sourceEntity == this.sourceEntity) {
            bothRelations.add(r)
          } else {
            targetRelations.add(r)
          }
        }

        for (const r of bothRelations) {
          r.pointUpSourceBollardsAndTargetBollards()
        }

        for (const r of sourceRelations) {
          r.pointUpSourceBollards()
        }

        for (const r of targetRelations) {
          r.pointUpTargetBollards()
        }
      }

      _pointDownSelfAndEntities() {
        this._isHovered = false

        const relations = new Set()

        for (const r of this.sourceEntity.relations) {
          relations.add(r)
        }

        for (const r of this.targetEntity.relations) {
          relations.add(r)
        }

        for (const r of relations) {
          r.redrawLineConsideringSelection()
        }
      }

      _redrawArrowConsideringSelection() {
        if (this._arrow) {
          if (this.sourceEntity.isSelected && this.targetEntity.isSelected) {
            this._arrow.update(true, true, true)
          } else if (this.sourceEntity.isSelected) {
            this._arrow.update(true, true, this.isSelected)
          } else if (this.targetEntity.isSelected) {
            this._arrow.update(true, this.isSelected, true)
          } else {
            this._arrow.update(
              this.isSelected,
              this.isSelected,
              this.isSelected
            )
          }
        }
      }

      _redrawLabelConsideringSelection() {
        if (this._label) {
          this._label.updateHighlighting()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/RelationModelContainer/index.js

    class RelationModelContainer extends IdIssueContainer {
      constructor(
        editorHTMLElement,
        eventEmitter,
        parentContainer,
        namespace,
        definitionContainer
      ) {
        super(eventEmitter, 'relation', 'R')
        this._editorHTMLElement = editorHTMLElement
        this._eventEmitter = eventEmitter
        this._parentContainer = parentContainer
        this._namespace = namespace
        this._definitionContainer = definitionContainer
      }

      /** @param {number} value */
      set controlBarHeight(value) {
        this._controlBarHeight = value
      }

      _toModel(relation) {
        return new RelationModel(
          this._editorHTMLElement,
          this._eventEmitter,
          this._parentContainer.entity,
          this._parentContainer.attribute,
          relation,
          this._namespace,
          this._definitionContainer,
          this._controlBarHeight
        )
      }

      add(newValue) {
        // When redoing, the newValue is instance of the RelationModel already.
        newValue =
          newValue instanceof RelationModel
            ? newValue
            : new RelationModel(
                this._editorHTMLElement,
                this._eventEmitter,
                this._parentContainer.entity,
                this._parentContainer.attribute,
                newValue,
                this._namespace,
                this._definitionContainer,
                this._controlBarHeight
              )
        const { clientHeight, clientWidth } = document.documentElement
        newValue.render(clientHeight, clientWidth)
        return super.add(newValue)
      }

      changeType(id, newType) {
        const relation = super.changeType(id, newType)
        relation.updateElement()
        return relation
      }

      remove(id) {
        console.assert(id, 'id is necessary!')
        const relation = super.remove(id)
        relation.erase()
      }

      clear() {
        for (const relation of this.all) {
          relation.erase()
        }
        super.clear()
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/EntityModel.js

    const DistanceToShift = 8
    // Leave a gap half the width of the triangle so that the triangle does not intersect the vertical line.
    const MinimumDistance = DistanceToShift * 3 + 4

    class EntityModel {
      /**
       *
       * @param {import('./AnnotationData/SpanModelContainer/SpanModel').default} span
       */
      constructor(
        editorID,
        attributeContainer,
        relationContaier,
        typeGap,
        typeDefinition,
        span,
        typeName,
        namespace,
        controlBarHeight,
        id = null
      ) {
        this._editorID = editorID
        this._span = span
        this.typeName = typeName
        this._id = id
        this._attributeContainer = attributeContainer
        this._relationContaier = relationContaier
        this._typeGap = typeGap
        this._typeDefinition = typeDefinition
        this._namespace = namespace
        this._controlBarHeight = controlBarHeight

        this._isSelected = false
        this._isHovered = false
        // When in view mode, the mousleave event will not declarify labels.
        this._isLabelClarified = false

        /** @type {SignboardHTMLElement} */
        this._signboard = null
      }

      get id() {
        return this._id
      }

      set id(val) {
        this._id = val
      }

      get title() {
        return `[${this.id}] pred: type, value: ${this._typeName}`
      }

      get color() {
        return this._definitionContainerFor.getColor(this.typeName)
      }

      get anchorHTML() {
        return toAnchorElement(this._displayName, this._href)
      }

      get span() {
        return this._span
      }

      set span(val) {
        this._span = val
      }

      get typeName() {
        return this._typeName
      }

      set typeName(val) {
        // Replace null to 'null' if type is null and undefined too.
        this._typeName = String(val)
      }

      get typeValues() {
        return new TypeValues(
          this._typeName,
          this._attributeContainer.getAttributesFor(this._id)
        )
      }

      get relations() {
        return this.relationsWhereThisIsSource.concat(
          this.relationsWhereThisIsTarget
        )
      }

      /**
       * @returns {AttributeModel[]}
       */
      get attributes() {
        return this._attributeContainer.getAttributesFor(this._id)
      }

      get relationsWhereThisIsSource() {
        return this._relationContaier.all.filter((r) => r.subj === this.id)
      }

      get relationsWhereThisIsTarget() {
        return this._relationContaier.all.filter((r) => r.obj === this.id)
      }

      get hasMultipleEndpoints() {
        const relations = new Map()
        relations.set('whereThisIsSourceAndTargetIsOnTheLeft', new Set())
        relations.set('whereThisIsSourceAndTargetIsOnTheRight', new Set())
        relations.set('whereThisIsSourceAndTargetIsUpOrDown', new Set())

        for (const r of this.relationsWhereThisIsSource) {
          if (r.targetEntity.offsetCenter < this.offsetCenter) {
            relations.get('whereThisIsSourceAndTargetIsOnTheLeft').add(r)
          } else if (this.offsetCenter < r.targetEntity.offsetCenter) {
            relations.get('whereThisIsSourceAndTargetIsOnTheRight').add(r)
          } else {
            relations.get('whereThisIsSourceAndTargetIsUpOrDown').add(r)
          }
        }

        relations.set('whereThisIsTargetAndSourceIsOnTheLeft', new Set())
        relations.set('whereThisIsTargetAndSourceIsOnTheRight', new Set())
        relations.set('whereThisIsTargetAndSourceIsUpOrDown', new Set())

        for (const r of this.relationsWhereThisIsTarget) {
          if (r.sourceEntity.offsetCenter < this.offsetCenter) {
            relations.get('whereThisIsTargetAndSourceIsOnTheLeft').add(r)
          } else if (this.offsetCenter < r.targetEntity.offsetCenter) {
            relations.get('whereThisIsTargetAndSourceIsOnTheRight').add(r)
          } else {
            relations.get('whereThisIsTargetAndSourceIsUpOrDown').add(r)
          }
        }

        return [...relations.values()].filter((s) => s.size).length > 1
      }

      get clientTop() {
        const { span } = this

        // Calculates the top without referencing the HTML element of entities.
        if (span.isDenotation) {
          let top = span.clientTopOfGrid + this._typeGap.height

          for (const entity of span.entities) {
            if (entity === this) {
              break
            }

            top += this._typeGap.height + entity.height
          }

          return round(top)
        }

        if (span.isBlock) {
          const paddingBottomOfGridOfBlockSpan = 15
          return round(
            span.clientBottomOfGrid -
              this.height -
              paddingBottomOfGridOfBlockSpan
          )
        }

        throw new Error('Unexpect type of span')
      }

      get offsetTop() {
        return (
          this.clientTop -
          this.span.element.offsetParent.offsetParent.getBoundingClientRect()
            .top
        )
      }

      get clientBottom() {
        return this.clientTop + this.height
      }

      isInViewport(clientHeight) {
        return (
          this._controlBarHeight <= this.clientBottom &&
          this.clientTop <= clientHeight
        )
      }

      get width() {
        return this.span.widthOfGrid
      }

      get height() {
        const labelUnitHegiht = 18

        return labelUnitHegiht + this._attributesHeight
      }

      get offsetCenter() {
        return round(this.span.offsetCenterOfGrid)
      }

      get isDenotation() {
        return this._span.isDenotation
      }

      get isBlock() {
        return this._span.isBlock
      }

      get isSelected() {
        return this._isSelected
      }

      getSourceAnchorPosition(alignBollards) {
        // When the entity width is small and the endpoint is displayed in the center of the entity and the entity has only one endpoint,
        // hovering will not move the entity left or right.
        const isJettyDeployed =
          this.width / 2 >= MinimumDistance ||
          (this.hasMultipleEndpoints && alignBollards)

        return {
          left: isJettyDeployed
            ? this.offsetCenter - DistanceToShift * 3
            : this.offsetCenter,
          right: isJettyDeployed
            ? this.offsetCenter + DistanceToShift * 3
            : this.offsetCenter
        }
      }

      getTargetAnchorPosition(alignBollards) {
        // When the entity width is small and the endpoint is displayed in the center of the entity and the entity has only one endpoint,
        // hovering will not move the entity left or right.
        const isJettyDeployed =
          this.width / 2 >= MinimumDistance ||
          (this.hasMultipleEndpoints && alignBollards)

        return {
          left: isJettyDeployed
            ? this.offsetCenter - DistanceToShift
            : this.offsetCenter,
          right: isJettyDeployed
            ? this.offsetCenter + DistanceToShift
            : this.offsetCenter
        }
      }

      focus() {
        this._signboard.focus()
      }

      select() {
        if (!this._isSelected) {
          this._isSelected = true
          this._selectElement()
          this._updateRelationHighlighting()
        }
      }

      deselect() {
        if (this._isSelected) {
          this._isSelected = false
          if (this._signboard) {
            this._signboard.deselect()
          }
          this._updateRelationHighlighting()
        }
      }

      startCut() {
        if (this._signboard) {
          this._signboard.startCut()
        }
      }

      cancelCut() {
        if (this._signboard) {
          this._signboard.cancelCut()
        }
      }

      render() {
        if (this._signboard) {
          return
        }

        if (this.span.isGridRendered) {
          // Append a new entity to the type
          this._signboard = this._createSignboardElement()
          this.span.addEntityElementToGridElement(this._signboard.element)

          this.reflectTypeGapInTheHeight()

          for (const entity of this.span.entities.filter((e) => e !== this)) {
            for (const relation of entity.relations) {
              relation.redrawLineConsideringSelection()
            }
          }

          // When scrolling out of a selected entity and then scrolling in again,
          // the selected state will be highlighted.
          if (this._isSelected) {
            this._signboard.select()
          }
        }
      }

      updateElement() {
        if (this._signboard) {
          this._signboard = this._signboard.replaceWith(
            this._createSignboardElement()
          )

          // Re-select a new entity element.
          if (this._isSelected) {
            this._selectElement()
          }

          this.reflectTypeGapInTheHeight()

          this.span.updateSelfAndAncestorsGridPosition()
          for (const entity of this.span.entities) {
            for (const relation of entity.relations) {
              relation.redrawLineConsideringSelection()
            }
          }
        }
      }

      reflectTypeGapInTheHeight() {
        if (this.isDenotation && this._signboard) {
          this._signboard.reflectTypeGapInTheHeight(this._typeGap.height)
        }
      }

      clarifyLabel() {
        if (this._signboard) {
          this._signboard.clarifyLabel()
        }
        this._isLabelClarified = true
      }

      declarifyLabel() {
        if (!this._isHovered && this._signboard) {
          this._signboard.declarifyLabel()
        }
        this._isLabelClarified = false
      }

      erase() {
        if (this._signboard) {
          this._signboard.remove()
          this._signboard = null
          this.span.updateSelfAndAncestorsGridPosition()
        }
      }

      _createSignboardElement() {
        const signboard = new SignboardHTMLElement(
          this,
          this.isDenotation ? 'denotation' : 'block',
          `${this._editorID}__E${this.id.replace(/[:.]/g, '')}`
        )

        // Highlight retaitons when related entity is hoverd.
        signboard.addEventListener('mouseenter', () => {
          signboard.clarifyLabel()
          this._pointUpRelations()
          this._isHovered = true
        })
        signboard.addEventListener('mouseleave', () => {
          if (!this._isLabelClarified) {
            signboard.declarifyLabel()
          }
          this._updateRelationHighlighting()
          this._isHovered = false
        })

        return signboard
      }

      _selectElement() {
        if (this._signboard) {
          this._signboard.select()

          // The block span renders as a div HTML element.
          // Because the positioning of div HTML elements is slower than that of span HTML elements,
          // block span grids do not move at render time.
          // Focusing before moving causes the browser to scroll to the top of the document.
          // So focus after the move, not at render time.
          if (this.span.isGridBeforePositioned) {
            this.span.entityToFocusOn = this
          } else {
            // Set focus to the label element in order to scroll the browser to the position of the element.
            this._signboard.focus()
          }
        }
      }

      get _definitionContainerFor() {
        if (this.isDenotation) {
          return this._typeDefinition.denotation
        } else if (this.isBlock) {
          return this._typeDefinition.block
        } else {
          throw 'unknown entity type'
        }
      }

      get _displayName() {
        return getDisplayName(
          this._namespace,
          this.typeName,
          this._definitionContainerFor.getLabel(this.typeName)
        )
      }

      get _href() {
        return getUri(
          this._namespace,
          this.typeName,
          this._definitionContainerFor.getUri(this.typeName)
        )
      }

      get _attributesHeight() {
        return this.attributes
          .map(({ height }) => height)
          .reduce((sum, height) => sum + height, 0)
      }

      _pointUpRelations() {
        for (const relation of this.relationsWhereThisIsSource) {
          relation.pointUpPathAndSourceBollards()
        }
        for (const relation of this.relationsWhereThisIsTarget) {
          relation.pointUpPathAndTargetBollards()
        }
      }

      _updateRelationHighlighting() {
        for (const relation of this.relations) {
          relation.redrawLineConsideringSelection()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/EntityModelContainer.js

    class EntityModelContainer extends IdIssueContainer {
      constructor(editorID, eventEmitter, parent, typeGap, namespace) {
        super(eventEmitter, 'entity', 'T')

        this._editorID = editorID

        // Since the attribute model container and the entity model container are cross-referenced,
        // the entity model retrieves other containers dynamically.
        this._parent = parent

        this._typeGap = typeGap
        this._namespace = namespace
      }

      get _spanModelContainer() {
        return this._parent.span
      }

      get _attributeModelContainer() {
        return this._parent.attribute
      }

      get _relationModelContainer() {
        return this._parent.relation
      }

      /** @param {number} value */
      set controlBarHeight(value) {
        this._controlBarHeight = value
      }

      _toModel(denotation, type) {
        // Expected an entity like {id: "E21", span: "editor2__S50_54", obj: "Protein"}.
        return new EntityModel(
          this._editorID,
          this._attributeModelContainer,
          this._relationModelContainer,
          this._typeGap,
          this._parent.typeDefinition,
          this._getSpan(type, denotation),
          denotation.obj,
          this._namespace,
          this._controlBarHeight,
          denotation.id
        )
      }

      add(newValue) {
        if (!newValue.span)
          throw new Error(`entity has no span! ${JSON.stringify(newValue)}`)

        // When redoing, the newValue is instance of the EntityModel already.
        if (newValue instanceof EntityModel) {
          super.add(newValue)
          newValue.render()
          return newValue
        }

        const newEntity = new EntityModel(
          this._editorID,
          this._attributeModelContainer,
          this._relationModelContainer,
          this._typeGap,
          this._parent.typeDefinition,
          this._spanModelContainer.get(newValue.span),
          newValue.typeName,
          this._namespace,
          this._controlBarHeight
        )

        console.assert(
          newEntity.span.isDenotation || newEntity.span.entities.length === 0,
          'A blockspan cannot have more than one entity.'
        )

        super.add(newEntity)
        newEntity.render()
        return newEntity
      }

      remove(id) {
        const instance = super.remove(id)
        instance.erase()
      }

      changeType(id, newType) {
        const entity = super.changeType(id, newType)
        entity.updateElement()
        return entity
      }

      moveEntities(span, entities) {
        for (const entity of entities) {
          const spanBeforeMove = entity.span
          entity.span = span
          entity.erase()
          spanBeforeMove.updateSelfAndAncestorsGridPosition()

          entity.render()

          for (const relation of entity.relations) {
            relation.redrawLineConsideringSelection()
          }
        }

        this._emit(`textae-event.annotation-data.entity.move`)
      }

      getAllOfSpan(span) {
        return this.all.filter((entity) => span.id === entity.span.id)
      }

      get denotations() {
        return this.all.filter((entity) => entity.isDenotation)
      }

      get blocks() {
        return this.all.filter((entity) => entity.isBlock)
      }

      redrawEntitiesWithSpecifiedAttribute(pred) {
        const entities = this.all.filter((e) =>
          e.typeValues.hasSpecificPredicateAttribute(pred)
        )
        for (const entity of entities) {
          entity.updateElement()
        }

        // If you change the media height attribute of the string attribute definition,
        // you may need to change the position of the Grid.
        for (const span of new Set([...entities.map(({ span }) => span)])) {
          span.updateGridPosition()
        }
      }

      clarifyLabelOfAll() {
        for (const entity of this.all) {
          entity.clarifyLabel()
        }
      }

      declarifyLabelOfAll() {
        for (const entity of this.all) {
          entity.declarifyLabel()
        }
      }

      _getSpan(type, denotation) {
        return this._spanModelContainer.get(this._getSpanId(type, denotation))
      }

      _getSpanId(type, denotation) {
        switch (type) {
          case 'denotation':
            return makeDenotationSpanHTMLElementID(
              this._editorID,
              denotation.span.begin,
              denotation.span.end
            )
          case 'block':
            return makeBlockSpanHTMLElementID(
              this._editorID,
              denotation.span.begin,
              denotation.span.end
            )
          default:
            throw `${type} is unknown type span!`
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/getSpanValidation/isBeginAndEndIn/isInText.js

    /* harmony default export */ function isInText(boundary, text) {
      return 0 <= boundary && boundary <= text.length
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/getSpanValidation/isBeginAndEndIn/index.js

    /* harmony default export */ function isBeginAndEndIn(text, span) {
      return isInText(span.begin, text) && isInText(span.end, text)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/ChainValidation/setSourceProperty.js

    /* harmony default export */ function setSourceProperty(n, name) {
      n.sourceProperty = name
      return n
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/ErrorMap.js

    class ErrorMap {
      constructor() {
        this._map = new Map()
      }

      set(key, errors, inhibitors) {
        this._map.set(key, [errors, inhibitors])
      }

      getErrors(key) {
        return this._map.has(key) ? this._map.get(key)[0] : []
      }

      getInhibitors(key) {
        return this._map.has(key) ? this._map.get(key)[1] : []
      }

      get size() {
        return this._map.size
      }
    }

    function collectErrors(name, errorMaps) {
      return errorMaps.reduce(
        (acc, errorMap) => acc.concat(errorMap.getErrors(name)),
        []
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/ChainValidation/index.js

    class ChainValidation {
      constructor(
        candidates,
        sourcePropertyName,
        name = '',
        predicate = () => true,
        prevValidation
      ) {
        this._candidates = candidates || []
        this._name = name
        this._predicate = predicate
        this._prevValidation = prevValidation
        this._sourcePropertyName = sourcePropertyName
      }

      and(name, predicate) {
        return new ChainValidation(
          this._candidates,
          this._sourcePropertyName,
          name,
          predicate,
          this
        )
      }

      validateAll() {
        const errorMap = new ErrorMap()

        let validation
        let qualifieds
        for (
          validation = this, qualifieds = this._candidates;
          validation;
          validation = validation._prevValidation
        ) {
          qualifieds = validation._validate(
            qualifieds,
            this._candidates,
            errorMap
          )
        }

        return [qualifieds, errorMap]
      }

      _validate(qualifieds, candidates, errorMap) {
        if (this._getRejects(candidates).length > 0) {
          errorMap.set(
            this._name,
            this._getRejects(candidates),
            this._getInhibitors(candidates)
          )
        }

        return this._getAccepts(qualifieds)
      }

      _getAccepts(candidates) {
        return candidates.filter((c) => this._test(c))
      }

      _getRejects(candidates) {
        return candidates
          .filter((c) => !this._test(c))
          .map((n) => setSourceProperty(n, this._sourcePropertyName))
      }

      // Returns the elements affectting to the validation to debug.
      // For example, the Span of the cross-boundary partner.
      _getInhibitors(candidates) {
        const inhibitors = new Map()

        for (const c of candidates) {
          const result = this._predicate(c)

          if (Array.isArray(result) && !result[0]) {
            inhibitors.set(c, result[1])
          }
        }

        return inhibitors
      }

      // A predicate function can return both consequences and inhibitors.
      // This function returns consequences only.
      _test(c) {
        const result = this._predicate(c)

        if (Array.isArray(result)) {
          return result[0]
        }

        return result
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/getSpanValidation/index.js

    /* harmony default export */ function getSpanValidation(
      targetSpans,
      text,
      allSpans,
      sourcePropertyName
    ) {
      return new ChainValidation(targetSpans, sourcePropertyName)
        .and('hasLength', (n) => n.span.end - n.span.begin > 0)
        .and('inText', (n) => isBeginAndEndIn(text, n.span))
        .and('isNotCrossing', (n) => {
          const bondaryCrossingSpans = getBoundaryCrossingSpans(
            allSpans,
            n.span.begin,
            n.span.end
          )
          return [bondaryCrossingSpans.length === 0, bondaryCrossingSpans]
        })
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/validateTypeSettings.js

    /* harmony default export */ function validateTypeSettings(
      text,
      targetSpans,
      allSpans
    ) {
      return getSpanValidation(
        targetSpans,
        text,
        allSpans,
        'typesettings'
      ).validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/isContains.js

    /* harmony default export */ function isContains(
      dictionary,
      referedEntityId
    ) {
      return dictionary.some((entry) => entry.id === referedEntityId)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/validateAttribute/isUniqueIn.js

    /* harmony default export */ function isUniqueIn(attributes, node) {
      return (
        attributes.filter(
          (a) =>
            a.subj === node.subj && a.pred === node.pred && a.obj === node.obj
        ).length === 1
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/validateAttribute/index.js

    /* harmony default export */ function validateAttribute(
      subjects,
      attributes
    ) {
      return new ChainValidation(attributes)
        .and('subject', (a) => isContains(subjects, a.subj))
        .and('unique', (node) => isUniqueIn(attributes, node))
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/validateRelation.js

    /* harmony default export */ function validateRelation(
      denotations,
      relations
    ) {
      return new ChainValidation(relations)
        .and('object', (r) => isContains(denotations, r.obj))
        .and('subject', (r) => isContains(denotations, r.subj))
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/transformToReferencedEntitiesError.js

    /* harmony default export */ function transformToReferencedEntitiesError(
      attributeSubj,
      relationObj,
      relationSubj
    ) {
      // Combine rejects for referenced object errer.
      // Mark the column you want to highlight.
      return attributeSubj
        .map((attribute) => {
          attribute.sourceProperty = 'attributes'
          attribute.alertSubj = true
          return attribute
        })
        .concat(
          relationObj.map((relation) => {
            relation.sourceProperty = 'relations'
            relation.alertObj = true
            return relation
          })
        )
        .concat(
          relationSubj.map((relation) => {
            relation.sourceProperty = 'relations'
            relation.alertSubj = true
            return relation
          })
        )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/isIDUnique.js

    /* harmony default export */ function isIDUnique(spans, node) {
      // Span without ID is acceptable.
      return (
        node.id === undefined ||
        spans.filter((d) => node.id && node.id === d.id).length === 1
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/validateDenotation.js

    /* harmony default export */ function validateDenotation(
      text,
      denotations,
      spanOfAllTracks,
      spansInTrack
    ) {
      return getSpanValidation(
        denotations,
        text,
        spanOfAllTracks,
        'denotations'
      )
        .and('uniqueID', (n) => isIDUnique(spansInTrack, n))
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/validateBlock.js

    /* harmony default export */ function validateBlock(
      text,
      blocks,
      spanOfAllTracks,
      spansInTrack
    ) {
      return getSpanValidation(blocks, text, spanOfAllTracks, 'blocks')
        .and('uniqueID', (n) => isIDUnique(spansInTrack, n))
        .and(
          'uniqueRange',
          ({ span }) =>
            blocks.filter(
              ({ span: otherSpan }) =>
                (span.begin === otherSpan.begin) & (span.end === otherSpan.end)
            ).length === 1
        )
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/debugLogCrossing.js

    /* harmony default export */ function debugLogCrossing(name, errors) {
      for (const [key, values] of errors.getInhibitors('isNotCrossing')) {
        console.warn(
          `Crossing ${name}: [${key.span.begin}:${key.span.end}](${
            key.id
          }) crosses with ${values
            .map(({ id, span }) => `[${span.begin}:${span.end}](${id})`)
            .join(', ')}`
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/getAllSpansIn.js

    /* harmony default export */ function getAllSpansIn(track) {
      const { typesettings, denotations, blocks } = track
      return (typesettings || []).concat(denotations || []).concat(blocks || [])
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/validateAnnotation/index.js

    /* harmony default export */ function validateAnnotation(
      text,
      spanOfAllTracks,
      track
    ) {
      const [typeSetting, errorTypeSettings] = validateTypeSettings(
        text,
        track.typesettings,
        spanOfAllTracks
      )

      const spansInTrack = getAllSpansIn(track)

      const [denotation, errorDenotations] = validateDenotation(
        text,
        track.denotations,
        spanOfAllTracks,
        spansInTrack
      )

      const [block, errorBlocks] = validateBlock(
        text,
        track.blocks,
        spanOfAllTracks,
        spansInTrack
      )

      const [relation, errorRelations] = validateRelation(
        denotation.concat(block),
        track.relations
      )

      const [attribute, errorAttributes] = validateAttribute(
        denotation.concat(block).concat(relation),
        track.attributes
      )

      debugLogCrossing('TypeSettings', errorTypeSettings)
      debugLogCrossing('Denotations', errorDenotations)
      debugLogCrossing('Blocks', errorBlocks)

      return {
        accept: {
          denotation,
          attribute,
          relation,
          typeSetting,
          block
        },
        reject: {
          wrongRangeDenotations: errorDenotations.getErrors('hasLength'),
          outOfTextDenotations: errorDenotations.getErrors('inText'),
          wrongRangeBlocks: errorBlocks.getErrors('hasLength'),
          outOfTextBlocks: errorBlocks.getErrors('inText'),
          duplicatedRangeBlocks: errorBlocks.getErrors('uniqueRange'),
          wrongRangeTypesettings: errorTypeSettings.getErrors('hasLength'),
          outOfTextTypesettings: errorTypeSettings.getErrors('inText'),
          duplicatedIDs: collectErrors('uniqueID', [
            errorDenotations,
            errorBlocks
          ]),
          boundaryCrossingSpans: collectErrors('isNotCrossing', [
            errorTypeSettings,
            errorDenotations,
            errorBlocks
          ]),
          referencedEntitiesDoNotExist: transformToReferencedEntitiesError(
            errorAttributes.getErrors('subject'),
            errorRelations.getErrors('object'),
            errorRelations.getErrors('subject')
          ),
          duplicatedAttributes: errorAttributes.getErrors('unique'),
          hasError:
            errorDenotations.size ||
            errorBlocks.size ||
            errorAttributes.size ||
            errorRelations.size ||
            errorTypeSettings.size
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/importSource.js

    /* harmony default export */ function importSource(
      targets,
      translater,
      source,
      type
    ) {
      if (source) {
        source = source.map(translater)
      }

      for (const target of targets) {
        target.addSource(source, type)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/setIdPrefixIfExist.js

    /* harmony default export */ function setIdPrefixIfExist(src, prefix) {
      // An id will be generated if id is null.
      // But an undefined is convert to string as 'undefined' when it add to any string.
      return src.id ? prefix + src.id : null
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/convertBeginAndEndToInteger.js

    // If the begin or end value is a string,
    // the comparison with other numbers cannot be done correctly.
    // You cannot generate a valid value for the ID of HTML element of span
    // from a begin or end that contains a decimal point.
    /* harmony default export */ function convertBeginAndEndToInteger(span) {
      return { ...span, begin: parseInt(span.begin), end: parseInt(span.end) }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/translateSpan.js

    // Expected denotations is an Array of object like { "id": "T1", "span": { "begin": 19, "end": 49 }, "obj": "Cell" }.
    /* harmony default export */ function translateSpan(src, prefix) {
      return {
        ...src,
        id: setIdPrefixIfExist(src, prefix),
        span: convertBeginAndEndToInteger(src.span)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/translateAttribute.js

    // Expected denotations is an Array of object like { "id": "A1", "subj": "T1", "pred": "example_predicate_1", "obj": "attr1" }.
    /* harmony default export */ function translateAttribute(src, prefix) {
      return {
        ...src,
        id: setIdPrefixIfExist(src, prefix),
        subj: prefix + src.subj,
        obj: src.obj
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/translateRelation.js

    // Expected relations is an Array of object like { "id": "R1", "pred": "locatedAt", "subj": "E1", "obj": "T1" }.
    /* harmony default export */ function translateRelation(src, prefix) {
      return {
        ...src,
        id: setIdPrefixIfExist(src, prefix),
        subj: prefix + src.subj,
        obj: prefix + src.obj
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTrack/index.js

    /* harmony default export */ function parseTrack(
      spanContainer,
      entityContainer,
      attributeContainer,
      relationContainer,
      text,
      spans,
      rowData,
      trackNumber = ''
    ) {
      const result = validateAnnotation(text, spans, rowData)

      importSource(
        [spanContainer, entityContainer],
        (src) => translateSpan(src, trackNumber),
        result.accept.denotation,
        'denotation'
      )

      importSource(
        [attributeContainer],
        (src) => translateAttribute(src, trackNumber),
        result.accept.attribute
      )

      importSource(
        [relationContainer],
        (src) => translateRelation(src, trackNumber),
        result.accept.relation
      )

      importSource(
        [spanContainer],
        (src) => {
          return { ...src, span: convertBeginAndEndToInteger(src.span) }
        },
        result.accept.typeSetting,
        'typesetting'
      )

      importSource(
        [spanContainer, entityContainer],
        (src) => translateSpan(src, trackNumber),
        result.accept.block,
        'block'
      )

      return result.reject
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/importNamespace.js

    /* harmony default export */ function importNamespace(destination, source) {
      // Clone source to prevet changing orignal data.
      importSource(
        [destination],
        (namespace) => ({ id: namespace.prefix, ...namespace }),
        source
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/parseTracks.js

    /* harmony default export */ function parseTracks(
      spanContainer,
      entityContainer,
      attributeContainer,
      relationContainer,
      text,
      spans,
      rowData
    ) {
      if (!rowData.tracks) return [false, []]
      const { tracks } = rowData
      delete rowData.tracks
      const rejects = tracks.map((track, i) => {
        const number = i + 1
        const trackNumber = `track${number}_`
        const reject = parseTrack(
          spanContainer,
          entityContainer,
          attributeContainer,
          relationContainer,
          text,
          spans,
          track,
          trackNumber
        )
        reject.name = `Track ${number} annotations.`
        return reject
      })
      return [true, rejects]
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/getAllSpansOf.js

    // The boundraries of elements in the typesetings and
    // the denotations and blocks cannot cross each other.

    // The same is true when across the tracks.
    /* harmony default export */ function getAllSpansOf(rowData) {
      let spans = getAllSpansIn(rowData)

      if (rowData.tracks) {
        for (const track of rowData.tracks) {
          spans = spans.concat(getAllSpansIn(track))
        }
      }

      return spans
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/parseAnnotation/index.js

    /* harmony default export */ function parseAnnotation(
      annotationData,
      rowData
    ) {
      const { span, entity, attribute, relation } = annotationData
      const { text } = rowData
      const spans = getAllSpansOf(rowData)

      const [multitrack, multitrackRejects] = parseTracks(
        span,
        entity,
        attribute,
        relation,
        text,
        spans,
        rowData
      )
      const annotationReject = parseTrack(
        span,
        entity,
        attribute,
        relation,
        text,
        spans,
        rowData
      )
      annotationReject.name = 'Root annotations.'
      importNamespace(annotationData.namespace, rowData.namespaces || [])

      const rejects = [annotationReject].concat(multitrackRejects)

      return {
        multitrack,
        rejects
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/clearAnnotationData.js

    /* harmony default export */ function clearAnnotationData(annotationData) {
      annotationData.span.clear()
      annotationData.entity.clear()
      annotationData.attribute.clear()
      annotationData.relation.clear()
      annotationData.namespace.clear()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/toDenotations.js

    /* harmony default export */ function toDenotations(annotationData) {
      return annotationData.entity.denotations.map((entity) => ({
        id: entity.id,
        span: {
          begin: entity.span.begin,
          end: entity.span.end
        },
        obj: entity.typeName
      }))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/toRelations.js

    /* harmony default export */ function toRelations(annotationData) {
      return annotationData.relation.all.map((r) => {
        return {
          id: r.id,
          pred: r.typeName,
          subj: r.subj,
          obj: r.obj
        }
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/toBlocks.js

    /* harmony default export */ function toBlocks(annotationData) {
      return annotationData.entity.blocks.map((entity) => ({
        id: entity.id,
        span: {
          begin: entity.span.begin,
          end: entity.span.end
        },
        obj: entity.typeName
      }))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/getReplicationRanges/getDuplicateSentenceFromText.js

    /* harmony default export */ function getDuplicateSentenceFromText(
      text,
      beginOfSentence,
      endOfSentence
    ) {
      const searchSentence = text.substring(beginOfSentence, endOfSentence)
      const sentenceLength = endOfSentence - beginOfSentence
      const findRanges = []

      let end = 0

      for (
        let begin = text.indexOf(searchSentence);
        begin !== -1;
        begin = text.indexOf(searchSentence, end)
      ) {
        end = begin + sentenceLength

        findRanges.push({
          begin,
          end
        })
      }

      return findRanges
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/getReplicationRanges/isWord.js

    // The preceding charactor and the following of a word charactor are delimiter.
    // For example, 't' ,a part of 'that', is not same with an origin span when it is 't'.
    /* harmony default export */ function isWord(
      sourceDoc,
      begin,
      end,
      isDelimiterFunc
    ) {
      const precedingChar = sourceDoc.charAt(begin - 1)
      const followingChar = sourceDoc.charAt(end)

      return isDelimiterFunc(precedingChar) && isDelimiterFunc(followingChar)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/getReplicationRanges/index.js

    // Check replications are word or not if spanConfig is set.
    /* harmony default export */ function getReplicationRanges(
      sourceDoc,
      beginOfSample,
      endOfSample,
      span,
      isDelimiterFunc
    ) {
      return getDuplicateSentenceFromText(sourceDoc, beginOfSample, endOfSample)
        .filter(
          ({ begin }) =>
            // The candidateSpan is a same span when begin is same.
            // Because string of each others are same. End of them are same too.
            begin !== beginOfSample
        )
        .filter(({ begin, end }) =>
          isWord(sourceDoc, begin, end, isDelimiterFunc)
        )
        .filter(({ begin, end }) => !span.hasDenotationSpan(begin, end))
        .filter(
          ({ begin, end }) => !span.isBoundaryCrossingWithOtherSpans(begin, end)
        )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/TypeGap.js

    class TypeGap {
      constructor(callback) {
        // The typeGap is changed from the Setting dialog or
        // by changing mode showing or not showing instances.
        this._isGapShown = true
        this._numberOfGap = 1
        this._callback = callback
      }

      set show(val) {
        if (this._isGapShown !== val) {
          this._isGapShown = val
          this._callback(this.value)
        }
      }

      get show() {
        return this._isGapShown
      }

      get value() {
        return this._isGapShown ? this._numberOfGap : 0
      }

      get height() {
        const typeGapUnitHeight = 24

        return this.value * typeGapUnitHeight
      }

      // The typeGap be able to be changed when mode showing instances.
      set value(val) {
        if (this._numberOfGap !== val) {
          this._numberOfGap = val
          this._callback(val)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/createTextBox/focusEditorWhenFocusedChildRemoved.js

    // Focus of the editor or children element is necessary to listen to keyboard events.
    // Elements be able to focused are the editor, spans and entity types.
    // The focus is lost when spans or entity types are remove.
    // Next elements are seleced autmatically by user deleting.
    // Next elements are not seleced autmatically by undo creation.
    // So, focus the editer when spans or entity types are removed and lost focus.
    /* harmony default export */ function focusEditorWhenFocusedChildRemoved(
      editorHTMLElement
    ) {
      // Observe a removing the focused document object.
      new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (
            mutation.removedNodes.length &&
            mutation.removedNodes[0].nodeType === 1
          ) {
            if (
              mutation.removedNodes[0].classList.contains(
                'textae-editor__span'
              ) ||
              mutation.removedNodes[0].classList.contains('textae-editor__type')
            ) {
              if (document.activeElement.tagName === 'BODY') {
                editorHTMLElement.focus()
              }
            }
          }
        })
      }).observe(editorHTMLElement.querySelector('.textae-editor__body'), {
        childList: true,
        subtree: true
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/createTextBox/TextBox/pixelToInt.js

    /* harmony default export */ function pixelToInt(str) {
      // The default value of google chrome line-height is "normal".
      // "normal" cannot be converted to an integer.
      const i = parseInt(str, 10)
      return isNaN(i) ? 0 : i
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/createTextBox/TextBox/getLineHeight.js

    /* harmony default export */ function getLineHeight(textBox) {
      const style = window.getComputedStyle(textBox)
      return pixelToInt(style.lineHeight)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/createTextBox/TextBox/setLineHeight.js

    /* harmony default export */ function setLineHeight(textBox, heightValue) {
      textBox.style.lineHeight = `${heightValue}px`
      textBox.style.paddingTop = `${heightValue / 2}px`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/createTextBox/TextBox/updateTextBoxHeight.js

    // Reduce the space under the .textae-editor__text-box same as padding-top.
    /* harmony default export */ function updateTextBoxHeight(textBox) {
      const style = window.getComputedStyle(textBox)

      // The height calculated by auto is exclude the value of the padding top.
      // Rest small space.
      textBox.style.height = 'auto'
      textBox.style.height = `${
        textBox.offsetHeight - pixelToInt(style.paddingTop) + 20
      }px`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/createTextBox/TextBox/index.js

    class TextBox {
      constructor(editorHTMLElement, annotationData) {
        this._editorHTMLElement = editorHTMLElement
        this._el = editorHTMLElement.querySelector('.textae-editor__text-box')
        this._annotationData = annotationData
      }

      get boundingClientRect() {
        return this._el.getBoundingClientRect()
      }

      get lineHeight() {
        return getLineHeight(this._el)
      }

      set lineHeight(val) {
        setLineHeight(this._el, val)
        this.forceUpdate()
        this._annotationData.updatePosition()
      }

      render(text) {
        // https://stackoverflow.com/questions/6234773/can-i-escape-html-special-chars-in-javascript
        this._el.innerHTML = text
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;')
      }

      updateLineHeight() {
        const lineHeight = this._annotationData.span.maxHeight

        if (lineHeight) {
          this.lineHeight = lineHeight
        } else {
          this._resetLineHeight()
        }
      }

      forceUpdate() {
        updateTextBoxHeight(this._el)
        this._updateSizeOfRelationBox()
      }

      _resetLineHeight() {
        // The default line height follows the editor's line height.
        const { lineHeight } = window.getComputedStyle(this._editorHTMLElement)
        this.lineHeight = pixelToInt(lineHeight)
      }

      _updateSizeOfRelationBox() {
        const relationBox = this._editorHTMLElement.querySelector(
          '.textae-editor__relation-box'
        )
        relationBox.style.height = this._el.style.height

        // When determining the width of one editor, vertical scroll bars are not needed,
        // and when annotations are loaded in another editor and vertical scroll bars appear,
        // the original editor is not wide enough and horizontal scroll bars appear.
        // Reduce the size of the relational display area to prevent horizontal scroll bars from appearing.
        // Why not resize the editor?
        // It is not possible to detect that a scroll bar has been displayed, so a notification is needed to change the height of the editor.
        // The editor does not have a notification mechanism.
        // It would be a big step to add a notification mechanism for this purpose.
        const width = parseFloat(window.getComputedStyle(this._el).width)
        relationBox.style.width = `${width - 10}px`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/createTextBox/index.js

    /* harmony default export */ function createTextBox(
      editorHTMLElement,
      annotationData
    ) {
      // Place the text box behind the annotation box to allow you
      // to select the text behind the relationship label in entity editing mode.
      const html = `
    <div class="textae-editor__body">
      <div class="textae-editor__annotation-box"></div>
      <svg
        namespace="http://www.w3.org/2000/svg"
        class="textae-editor__relation-box">
      </svg>
      <div class="textae-editor__text-box"></div>
    </div>
    `
      // The editor itself has a "white-space: pre" style for processing text that contains a series of whitespace.
      // In this case, HTML line breaks are included in the editor's height calculation.
      // Remove CRLF so that it is not included in the height calculation.
      editorHTMLElement.innerHTML = html.replace(/[\n\r]+/g, '')
      focusEditorWhenFocusedChildRemoved(editorHTMLElement)

      return new TextBox(editorHTMLElement, annotationData)
    }

    // EXTERNAL MODULE: ./node_modules/observ/index.js
    var observ = __webpack_require__(9462)
    var observ_default = /*#__PURE__*/ __webpack_require__.n(observ) // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/TypeDefinition.js
    class TypeDefinition {
      /**
       *
       * @param {import('../AttributeDefinitionContainer').default} attribute
       */
      constructor(eventEmitter, denotation, block, relation, attribute) {
        this._eventEmitter = eventEmitter
        this._denotationContainer = denotation
        this._blockContainer = block
        this._relationContainer = relation
        this._attributeContainer = attribute

        this._lockStateObservable = new (observ_default())(false)
        this._lockStateObservable(() =>
          this._eventEmitter.emit(`textae-event.type-definition.lock`)
        )
      }

      get denotation() {
        return this._denotationContainer
      }

      get block() {
        return this._blockContainer
      }

      get relation() {
        return this._relationContainer
      }

      get attribute() {
        return this._attributeContainer
      }

      get config() {
        const ret = {}

        if (this._denotationContainer.config.length) {
          ret['entity types'] = this._denotationContainer.config
        }

        if (this._relationContainer.config.length) {
          ret['relation types'] = this._relationContainer.config
        }

        if (this._attributeContainer.config.length) {
          ret['attribute types'] = this._attributeContainer.config
        }

        if (this._blockContainer.config.length) {
          ret['block types'] = this._blockContainer.config
        }

        return ret
      }

      get isLock() {
        return this._lockStateObservable()
      }

      lockEdit() {
        this._lockStateObservable.set(true)
      }
      unlockEdit() {
        this._lockStateObservable.set(false)
      }

      setTypeConfig(config) {
        if (config) {
          this._denotationContainer.definedTypes = config['entity types'] || []
          this._relationContainer.definedTypes = config['relation types'] || []
          this._attributeContainer.definedTypes =
            config['attribute types'] || []
          this._blockContainer.definedTypes = config['block types'] || []
          this.autocompletionWs = config['autocompletion_ws']
        } else {
          this._denotationContainer.definedTypes = []
          this._relationContainer.definedTypes = []
          this._attributeContainer.definedTypes = []
          this._blockContainer.definedTypes = []
          this.autocompletionWs = ''
        }

        this._eventEmitter.emit(`textae-event.type-definition.reset`)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/formatForPallet/index.js

    /* harmony default export */ function formatForPallet(
      types,
      countMap,
      definedTypes,
      defaultType,
      defaultColor
    ) {
      return types.map((id) => ({
        id,
        label:
          (definedTypes.has(id) && definedTypes.get(id).label) || undefined,
        defaultType: id === defaultType,
        uri: getUrlMatches(id) ? id : undefined,
        color:
          (definedTypes.has(id) && definedTypes.get(id).color) || defaultColor,
        useNumber: countMap.get(id).usage
      }))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/DefinedTypeContainer/getConfig/getForwardMatchTypes.js

    /* harmony default export */ function getForwardMatchTypes(typeIds, id) {
      const forwardMatchTypes = []

      for (const definedType of typeIds) {
        if (
          definedType.indexOf('*') !== -1 &&
          id.indexOf(definedType.slice(0, -1)) === 0
        ) {
          forwardMatchTypes.push(definedType)
        }
      }

      return forwardMatchTypes
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/DefinedTypeContainer/getConfig/getLongestIdMatchType.js

    /* harmony default export */ function getLongestIdMatchType(typeIds) {
      let longestMatchId = ''

      for (const id of typeIds) {
        if (id.length > longestMatchId.length) {
          longestMatchId = id
        }
      }

      return longestMatchId
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/DefinedTypeContainer/getConfig/getForwardMatchType.js

    /* harmony default export */ function getForwardMatchType(
      definedTypes,
      id
    ) {
      // '*' at the last char of id means wildcard.
      const forwardMatchTypes = getForwardMatchTypes(definedTypes.ids(), id)

      if (forwardMatchTypes.length === 0) {
        return null
      }

      // If some wildcard-id are matched, return the type of the most longest matched.
      return definedTypes.get(getLongestIdMatchType(forwardMatchTypes))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/DefinedTypeContainer/getConfig/index.js

    /* harmony default export */ function getConfig(definedTypes, id) {
      // Return value if perfectly matched
      if (definedTypes.has(id)) {
        return definedTypes.get(id)
      }

      // Return value if forward matched
      return getForwardMatchType(definedTypes, id)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/DefinedTypeContainer/index.js

    class DefinedTypeContainer {
      // Expected values is an array of object.
      // An example of object is {"id": "Regulation","color": "#FFFF66","default": true}.
      constructor(values) {
        // If the order of the type definitions changes,
        // it will be treated as a change, so preserve the order.
        this._list = values
      }

      has(id) {
        return this.map.has(id)
      }

      get(id) {
        return { ...this.map.get(id) }
      }

      replace(id, newType) {
        const index = this._list.findIndex((elem) => elem.id === id)

        if (index !== -1) {
          this._list.splice(index, 1, newType)
        } else {
          this._list.push(newType)
        }
      }

      delete(id) {
        this._list = this._list.filter((elem) => elem.id !== id)
      }

      ids() {
        return this.map.keys()
      }

      getConfig(id) {
        return getConfig(this, id)
      }

      labelIncludes(term) {
        return this._list
          .filter((t) => t.label)
          .filter((t) => t.label.includes(term))
      }

      get map() {
        return this._list.reduce((acc, cur) => acc.set(cur.id, cur), new Map())
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/sortByCountAndName.js

    /* harmony default export */ function sortByCountAndName(countTypeUse) {
      // Sort by number of types, and by name if numbers are same.
      const typeNames = Array.from(countTypeUse.keys())

      typeNames.sort((a, b) => {
        const diff = countTypeUse.get(b).usage - countTypeUse.get(a).usage
        return diff !== 0 ? diff : a > b ? 1 : a < b ? -1 : 0
      })

      return typeNames
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/countUsage.js

    /* harmony default export */ function countUsage(map, instances) {
      for (const [key, value] of map.entries()) {
        map.set(key, { ...value, usage: 0 })
      }

      return instances.reduce((countMap, { typeName }) => {
        countMap.get(typeName).usage += 1

        return countMap
      }, map)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/DefinitionContainer/index.js

    class DefinitionContainer {
      constructor(
        eventEmitter,
        annotationType,
        getAllInstanceFunc,
        defaultColor
      ) {
        this._eventEmitter = eventEmitter
        this._annotationType = annotationType
        /** @type {DefinedTypeContainer} **/
        this._definedTypes = null
        this._getAllInstanceFunc = getAllInstanceFunc
        this._defaultColor = defaultColor
      }

      get annotationType() {
        return this._annotationType
      }

      set definedTypes(value) {
        this._definedTypes = new DefinedTypeContainer(value)

        // Set default type
        const defaultType = value.find((type) => type.default === true)
        if (defaultType) {
          delete defaultType.default
          this._defaultType = defaultType.id
        } else {
          this._defaultType = null
        }
      }

      has(id) {
        return this._definedTypes.has(id)
      }

      get(id) {
        const type = { ...this._definedTypes.get(id) }

        if (this._defaultType === id) {
          type.default = true
          return type
        } else {
          delete type.default
          return type
        }
      }

      replace(id, newType) {
        this._definedTypes.replace(id, newType)
        this._eventEmitter.emit(
          `textae-event.type-definition.${this._annotationType}.change`,
          newType.id
        )
      }

      addDefinedType(newType) {
        if (typeof newType.color === 'undefined') {
          const forwardMatchColor = this.getColor(newType.id)
          if (forwardMatchColor !== this._defaultColor) {
            newType.color = forwardMatchColor
          }
        }

        if (typeof newType.label === 'undefined') {
          const forwardMatchLabel = this.getLabel(newType.id)
          if (forwardMatchLabel) {
            newType.label = forwardMatchLabel
          }
        }

        if (newType.default) {
          this._defaultType = newType.id
        }

        this.replace(newType.id, newType)
      }

      get definedTypes() {
        return this._definedTypes
      }

      // Return the type that has the default property or the most used type.
      get defaultType() {
        if (this._defaultType) {
          return this._defaultType
        }

        if (this._getAllInstanceFunc().length > 0) {
          return sortByCountAndName(
            countUsage(this._typeMap, this._getAllInstanceFunc())
          )[0]
        }

        return 'something'
      }

      // The default value can be removed.
      set defaultType(id) {
        this._defaultType = id
        this._eventEmitter.emit(
          `textae-event.type-definition.${this._annotationType}.change-default`,
          id
        )
      }

      get defaultColor() {
        return this._defaultColor
      }

      getColor(id) {
        const config = this._definedTypes.getConfig(id)
        return (config && config.color) || this._defaultColor
      }

      getLabel(id) {
        const config = this._definedTypes.getConfig(id)
        return config && config.label
      }

      getUri(id) {
        return getUrlMatches(id) ? id : undefined
      }

      findByLabel(term) {
        return this.definedTypes.labelIncludes(term)
      }

      get pallet() {
        const countMap = countUsage(this._typeMap, this._getAllInstanceFunc())
        const types = sortByCountAndName(countMap)

        return formatForPallet(
          types,
          countMap,
          this._definedTypes,
          this.defaultType,
          this._defaultColor
        )
      }

      get config() {
        const types = this._typeMap

        // Make default type and delete defalut type from original configuratian.
        for (const [key, type] of types.entries()) {
          // Make a copy so as not to destroy the original object.
          const copy = { ...type }
          if (type.id === this.defaultType) {
            copy.default = true
          } else {
            delete copy.default
          }
          types.set(key, copy)
        }

        return [...types.values()]
      }

      get _typeMap() {
        // Get type definitions.
        // Copy map to add definitions from instance.
        const types = this._definedTypes.map

        // Get types from instances.
        for (const { typeName } of this._getAllInstanceFunc()) {
          if (!types.has(typeName)) {
            types.set(typeName, { id: typeName })
          }
        }

        return types
      }

      delete(id, defaultType) {
        this._definedTypes.delete(id)
        this._defaultType = defaultType
        this._eventEmitter.emit(
          `textae-event.type-definition.${this._annotationType}.delete`,
          id
        )
      }
    } // CONCATENATED MODULE: ./node_modules/array-move/index.js

    function arrayMoveMutable(array, fromIndex, toIndex) {
      const startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex

      if (startIndex >= 0 && startIndex < array.length) {
        const endIndex = toIndex < 0 ? array.length + toIndex : toIndex

        const [item] = array.splice(fromIndex, 1)
        array.splice(endIndex, 0, item)
      }
    }

    function arrayMoveImmutable(array, fromIndex, toIndex) {
      array = [...array]
      arrayMoveMutable(array, fromIndex, toIndex)
      return array
    } // CONCATENATED MODULE: ./src/lib/AttributeDefinition.js

    class AttributeDefinition {
      constructor(valueType, pred) {
        this.valueType = valueType
        this.pred = pred
      }

      get values() {
        console.assert(this._values, 'this._values to return!')

        return this._values
      }

      get JSON() {
        return {
          pred: this.pred
        }
      }

      get _valuesClone() {
        console.assert(this._values, 'this._values is necessary to clone!')

        const values = []
        for (const value of this._values) {
          values.push({ ...value })
        }
        return values
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/FlagAttributeDefinition.js

    class FlagAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this.default = true
        this.label = hash.label
        this.color = hash.color
      }

      getLabel() {
        return this.label
      }

      getDisplayName() {
        if (this.label) {
          return this.label
        }

        return this.pred
      }

      getColor() {
        return this.color
      }

      get JSON() {
        return {
          ...super.JSON,
          ...{
            'value type': 'flag',
            default: this.default,
            label: this.label,
            color: this.color
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/gte.js

    /* harmony default export */ function gte(left, right) {
      return left <= right
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/gt.js

    /* harmony default export */ function gt(left, right) {
      return left < right
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/getLowwerCond.js

    /* harmony default export */ function getLowwerCond(str) {
      if (str.startsWith('[')) {
        return (right) => gte(new Number(str.replace('[', '')), right)
      }
      if (str.startsWith('(')) {
        return (right) => gt(new Number(str.replace('(', '')), right)
      }
      throw `${str} is not valid interval notation`
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/getUpperCond.js

    /* harmony default export */ function getUpperCond(str) {
      if (str.endsWith(']')) {
        return (left) => gte(left, new Number(str.replace(']', '')))
      }
      if (str.endsWith(')')) {
        return (left) => gt(left, new Number(str.replace(')', '')))
      }
      throw `${str} is not valid interval notation`
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/index.js

    // https://www.varsitytutors.com/hotmath/hotmath_help/topics/interval-notation
    class IntervalNotation {
      constructor(str) {
        const [left, right] = str.split(',')

        if (!right) {
          if (left.startsWith('[') || left.startsWith('(')) {
            // Upper limit is omitted
            this._lowwerCond = getLowwerCond(left)
            this._upperCond = (_) => true
          }

          if (left.endsWith(']') || left.endsWith(')')) {
            // Lowwer limit is omitted
            this._lowwerCond = (_) => true
            this._upperCond = getUpperCond(left)
          }
        } else {
          this._lowwerCond = getLowwerCond(left)
          this._upperCond = getUpperCond(right)
        }

        if (!this._lowwerCond || !this._upperCond) {
          throw `${str} is not valid interval notation`
        }
      }

      test(value) {
        return this._lowwerCond(value) && this._upperCond(value)
      }
    } // CONCATENATED MODULE: ./src/lib/isAbleToParseFloat.js

    /* harmony default export */ function isAbleToParseFloat(str) {
      return !Number.isNaN(parseFloat(str))
    } // CONCATENATED MODULE: ./src/lib/NumericAttributeDefinition.js

    const DEFAULT = 0
    const STEP = 2

    class NumericAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this.default = isAbleToParseFloat(hash.default)
          ? parseFloat(hash.default)
          : DEFAULT
        if (isAbleToParseFloat(hash.min)) {
          this.min = parseFloat(hash.min)
        }
        if (isAbleToParseFloat(hash.max)) {
          this.max = parseFloat(hash.max)
        }
        this.step = isAbleToParseFloat(hash.step) ? parseFloat(hash.step) : STEP
        this._values = hash.values || []
      }

      getLabel(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.label) {
          return def.label
        }
      }

      getDisplayName(obj) {
        return this.getLabel(obj) || String(obj)
      }

      getColor(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.color) {
          return def.color
        }

        return null
      }

      _getMatchedValue(obj) {
        const match = this._values
          .filter((a) => a.range !== 'default')
          .find((a) => new IntervalNotation(a.range).test(obj))

        if (match) {
          return match
        }

        const defaultValue = this._values.find((a) => a.range === 'default')
        if (defaultValue) {
          return defaultValue
        }

        return null
      }

      get JSON() {
        return {
          ...super.JSON,
          ...{
            'value type': 'numeric',
            default: this.default,
            min: this.min,
            max: this.max,
            step: this.step,
            values: super._valuesClone
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/SelectionAttributeDefinition.js

    class SelectionAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this._values = hash.values || []
      }

      get default() {
        return this.values.find((a) => a.default).id
      }

      getLabel(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.label) {
          return def.label
        }
      }

      getDisplayName(obj) {
        return this.getLabel(obj)
      }

      getColor(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.color) {
          return def.color
        }

        return null
      }

      get values() {
        return this._values
      }

      get hasOnlyOneValue() {
        return this._values.length === 1
      }

      _getMatchedValue(obj) {
        return this.values.find((a) => a.id == obj)
      }

      get JSON() {
        return {
          ...super.JSON,
          ...{
            'value type': 'selection',
            values: super._valuesClone
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/StringAttributeDefinition.js

    class StringAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this.autocompletionWs = hash.autocompletion_ws
        this.default = hash.default
        if (isAbleToParseFloat(hash.mediaHeight)) {
          this.mediaHeight = parseFloat(hash.mediaHeight)
        }
        this._values = hash.values || []
      }

      getLabel(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.label) {
          return def.label
        }
      }

      getDisplayName(obj) {
        return this.getLabel(obj)
      }

      getColor(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.color) {
          return def.color
        }

        return null
      }

      _getMatchedValue(obj) {
        const match = this._values
          .filter((a) => a.pattern !== 'default')
          .find((a) => new RegExp(a.pattern).test(obj))

        if (match) {
          return match
        }

        const defaultValue = this._values.find((a) => a.pattern === 'default')
        if (defaultValue) {
          return defaultValue
        }

        return null
      }

      get JSON() {
        return {
          ...super.JSON,
          ...{
            'value type': 'string',
            autocompletion_ws: this.autocompletionWs,
            default: this.default,
            values: super._valuesClone
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/index.js

    /* harmony default export */ function createAttributeDefinition(
      valueType,
      hash
    ) {
      switch (valueType) {
        case 'flag':
          return new FlagAttributeDefinition(valueType, hash)
        case 'numeric':
          return new NumericAttributeDefinition(valueType, hash)
        case 'selection':
          return new SelectionAttributeDefinition(valueType, hash)
        case 'string':
          return new StringAttributeDefinition(valueType, hash)
        default:
          throw new Error(
            `${valueType} of ${JSON.stringify(hash)} is Uknown Attribute`
          )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/index.js

    class AttributeDefinitionContainer {
      constructor(eventEmitter, getAllInstanceFunc) {
        this._eventEmitter = eventEmitter
        this._getAllInstanceFunc = getAllInstanceFunc
      }

      set definedTypes(attributes) {
        this._definedTypes = new Map(
          (attributes || []).map((a) => [
            a.pred,
            createAttributeDefinition(a['value type'], a)
          ])
        )
      }

      create(valueType, attrDef, index = null) {
        // To restore the position of a deleted attribute,
        // insert the new attribute at the specified index, if specified.
        // Note: 0 is false in JavaScript
        // When index and the number of attribute definitions are the same,
        // the position of the deleted definition is the last. Add to the end of the attribute definition.
        if (index !== null && this._definedTypes.size !== index) {
          this._definedTypes = new Map(
            Array.from(this._definedTypes.entries()).reduce(
              (acc, [key, val], i) => {
                if (i === index) {
                  acc.push([
                    attrDef.pred,
                    createAttributeDefinition(valueType, attrDef)
                  ])
                }
                acc.push([key, val])

                return acc
              },
              []
            )
          )
        } else {
          this._definedTypes.set(
            attrDef.pred,
            createAttributeDefinition(valueType, attrDef)
          )
        }

        this._eventEmitter.emit(
          `textae-event.type-definition.attribute.create`,
          attrDef.pred
        )
      }

      get(pred) {
        return this._definedTypes.get(pred)
      }

      update(oldPred, attrDef) {
        // Predicate as key of map may be changed.
        // Keep oreder of attributes.
        // So that re-create an map instance.
        this._definedTypes = new Map(
          Array.from(this._definedTypes.entries()).map(([key, val]) => {
            if (key === oldPred) {
              return [
                attrDef.pred,
                createAttributeDefinition(val.valueType, attrDef)
              ]
            } else {
              return [key, val]
            }
          })
        )

        this._eventEmitter.emit(
          `textae-event.type-definition.attribute.change`,
          attrDef.pred
        )

        return this.get(attrDef.pred)
      }

      updateValues(pred, values) {
        const hash = this.get(pred).JSON
        return this.update(pred, { ...hash, ...{ values } })
      }

      move(oldIndex, newIndex) {
        this._definedTypes = new Map(
          arrayMoveImmutable(this.attributes, oldIndex, newIndex).map((a) => [
            a.pred,
            a
          ])
        )

        // -1 points to the end of the array.
        const { pred } =
          this.attributes[
            newIndex === -1 ? this.attributes.length - 1 : newIndex
          ]

        // When an attribute definition move is undoed,
        // it fires an event to notify the palette to immediately reflect the display content.
        this._eventEmitter.emit(
          `textae-event.type-definition.attribute.move`,
          pred
        )
      }

      delete(pred) {
        this._definedTypes.delete(pred)
        this._eventEmitter.emit(`textae-event.type-definition.attribute.delete`)
      }

      get attributes() {
        return Array.from(this._definedTypes.values()) || []
      }

      get config() {
        return this.attributes.map((a) => a.JSON)
      }

      isSelectionAttributeValueIndelible(pred, id) {
        if (this.get(pred).hasOnlyOneValue) {
          return true
        }

        // If there is an instance that uses a selection attribute, do not delete it.
        if (this._getAllInstanceFunc().some((a) => a.equalsTo(pred, id))) {
          return true
        }

        return false
      }

      getLabel(pred, obj) {
        console.assert(
          this._definedTypes.has(pred),
          `There is no attribute definition for ${pred}.`
        )

        return this.get(pred).getLabel(obj)
      }

      getDisplayName(pred, obj) {
        console.assert(
          this._definedTypes.has(pred),
          `There is no attribute definition for ${pred}.`
        )

        return this.get(pred).getDisplayName(obj)
      }

      getColor(pred, obj) {
        if (this._definedTypes.has(pred)) {
          return this.get(pred).getColor(obj)
        }
      }

      getIndexOf(pred) {
        return Array.from(this._definedTypes.values()).findIndex(
          (a) => a.pred === pred
        )
      }

      getAttributeAt(number) {
        return Array.from(this._definedTypes.values())[number - 1]
      }

      attributeCompareFunction(a, b) {
        // Order by attribute definition order.
        const indexOfA = this.getIndexOf(a.pred)
        const indexOfB = this.getIndexOf(b.pred)
        if (indexOfA !== indexOfB) {
          return indexOfA - indexOfB
        }

        if (a.id && b.id) {
          return a.id.localeCompare(b.id)
        }

        return 0
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/LineHeightAuto.js

    class LineHeightAuto {
      /**
       *
       * @param {import('./createTextBox/TextBox').default} textBox
       */
      constructor(eventEmitter, textBox) {
        this._textBox = textBox
        this._enable = false

        eventEmitter.on(
          'textae-event.control.button.push',
          ({ name, isPushed }) => {
            if (name === 'line-height-auto') {
              this._enable = isPushed
            }
          }
        )
      }

      updateLineHeight() {
        if (this._enable) {
          this._textBox.updateLineHeight()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationData/index.js

    class AnnotationData {
      constructor(
        editorID,
        editorHTMLElement,
        eventEmitter,
        editorCSSClass,
        startJQueryUIDialogWait,
        endJQueryUIDialogWait
      ) {
        this._sourceDoc = ''
        this.namespace = new ModelContainer(eventEmitter, 'namespace')
        const relationDefinitionContainer = new DefinitionContainer(
          eventEmitter,
          'relation',
          () => this.relation.all,
          '#00CC66'
        )

        this.relation = new RelationModelContainer(
          editorHTMLElement,
          eventEmitter,
          this,
          this.namespace,
          relationDefinitionContainer
        )
        this._typeGap = new TypeGap(() => {
          for (const entity of this.entity.denotations) {
            entity.reflectTypeGapInTheHeight()
          }
          this._textBox.updateLineHeight()
          eventEmitter.emit('textae-event.annotation-data.entity-gap.change')
        })

        this.entity = new EntityModelContainer(
          editorID,
          eventEmitter,
          this,
          this._typeGap,
          this.namespace
        )

        this.attributeDefinitionContainer = new AttributeDefinitionContainer(
          eventEmitter,
          () => this.attribute.all
        )
        this.attribute = new AttributeModelContainer(
          eventEmitter,
          this.entity,
          this.relation,
          this.namespace,
          this.attributeDefinitionContainer
        )

        this.updatePosition = () => {
          try {
            editorCSSClass.startWait()
            startJQueryUIDialogWait()

            this._rearrangeAllAnnotations()
          } catch (e) {
            console.error(e)
          } finally {
            editorCSSClass.endWait()
            endJQueryUIDialogWait()
          }
        }
        this._textBox = createTextBox(editorHTMLElement, this)
        this._lineHeightAuto = new LineHeightAuto(eventEmitter, this._textBox)
        this.span = new SpanModelContainer(
          editorID,
          editorHTMLElement,
          eventEmitter,
          this.entity,
          this._textBox,
          this._typeGap
        )

        this.denotationDefinitionContainer = new DefinitionContainer(
          eventEmitter,
          'entity',
          () => this.entity.denotations,
          '#77DDDD'
        )
        const blockDefinitionContainer = new DefinitionContainer(
          eventEmitter,
          'entity',
          () => this.entity.blocks,
          '#77DDDD'
        )
        this._typeDefinition = new TypeDefinition(
          eventEmitter,
          this.denotationDefinitionContainer,
          blockDefinitionContainer,
          relationDefinitionContainer,
          this.attributeDefinitionContainer
        )

        eventEmitter
          .on('textae-event.annotation-data.span.add', (span) => {
            if (span.isDenotation || span.isBlock) {
              this._textBox.forceUpdate()
              this._rearrangeAllAnnotations()
            }
          })
          .on('textae-event.annotation-data.span.remove', (span) => {
            if (span.isDenotation || span.isBlock) {
              this._textBox.forceUpdate()
              this._rearrangeAllAnnotations()
            }
          })
          .on('textae-event.annotation-data.entity.add', (entity) => {
            if (entity.span.isDenotation) {
              this._lineHeightAuto.updateLineHeight()
            }
          })
          .on('textae-event.annotation-data.entity.remove', (entity) => {
            if (entity.span.isDenotation) {
              this._lineHeightAuto.updateLineHeight()
            }
          })

        // Bind type-definition events.
        eventEmitter
          .on('textae-event.type-definition.entity.change', (typeName) => {
            for (const entity of this.entity.all) {
              // If the type name ends in a wildcard, look for the DOMs to update with a forward match.
              if (
                entity.typeName === typeName ||
                (typeName.lastIndexOf('*') === typeName.length - 1 &&
                  entity.typeName.indexOf(typeName.slice(0, -1) === 0))
              ) {
                entity.updateElement()
              }
            }
          })
          .on('textae-event.type-definition.attribute.change', (pred) =>
            this.entity.redrawEntitiesWithSpecifiedAttribute(pred)
          )
          .on('textae-event.type-definition.attribute.move', (pred) =>
            this.entity.redrawEntitiesWithSpecifiedAttribute(pred)
          )
          .on('textae-event.type-definition.relation.change', (typeName) => {
            for (const relation of this.relation.all) {
              // If the type name ends in a wildcard, look for the DOMs to update with a forward match.
              if (
                relation.typeName === typeName ||
                (typeName.lastIndexOf('*') === typeName.length - 1 &&
                  relation.typeName.indexOf(typeName.slice(0, -1) === 0))
              ) {
                relation.updateElement()
              }
            }
          })

        this._editorHTMLElement = editorHTMLElement
        this._eventEmitter = eventEmitter
      }

      reset(rawData, config) {
        console.assert(rawData.text, 'This is not a json file of anntations.')

        this._typeDefinition.setTypeConfig(config)
        this._sourceDoc = rawData.text
        this._textBox.render(this.sourceDoc)

        clearAnnotationData(this)
        const { multitrack, rejects } = parseAnnotation(this, rawData)

        this._clearAndDrawAllAnnotations()

        this._eventEmitter.emit(
          'textae-event.annotation-data.all.change',
          this,
          multitrack,
          rejects
        )
      }

      get JSON() {
        return {
          denotations: toDenotations(this),
          attributes: this.attribute.all.map(({ JSON }) => JSON),
          relations: toRelations(this),
          blocks: toBlocks(this)
        }
      }

      getReplicationRanges(span, isDelimiterFunc) {
        return getReplicationRanges(
          this.sourceDoc,
          span.begin,
          span.end,
          this.span,
          isDelimiterFunc
        )
      }

      get typeGap() {
        return this._typeGap
      }

      get textBox() {
        return this._textBox
      }

      get sourceDoc() {
        // Since 6.0.0, the text-box is set to "white-space: pre-wrap;"
        // in order to render line breaks contained in text as they are in the browser.
        // "\r\n" is rendered as a single character.
        // Replace "\r\n" with "\n" so that the browser can render "\r\n" as two characters.
        return this._sourceDoc.replaceAll(/\r\n/g, ' \n')
      }

      get typeDefinition() {
        return this._typeDefinition
      }

      drawGridsInSight() {
        if (this._isEditorInSight) {
          const { clientHeight, clientWidth } = document.documentElement

          for (const span of this.span.allDenotationSpans) {
            span.drawGrid(clientHeight, clientWidth)
          }

          for (const span of this.span.allBlockSpans) {
            span.drawGrid(clientHeight, clientWidth)
            span.updateBackgroundPosition()
          }

          for (const relation of this.relation.all) {
            relation.render(clientHeight, clientWidth)
          }
        }
      }

      relayout() {
        this._textBox.forceUpdate()

        if (this._isEditorInSight) {
          this.updatePosition()
        }
      }

      /** @param {number} value */
      set controlBarHeight(value) {
        this.entity.controlBarHeight = value
        this.relation.controlBarHeight = value
      }

      get _isEditorInSight() {
        const { clientHeight } = document.documentElement
        const { top, bottom } = this._editorHTMLElement.getBoundingClientRect()

        return 0 <= bottom && top <= clientHeight
      }

      _clearAndDrawAllAnnotations() {
        getAnnotationBox(this._editorHTMLElement).innerHTML = ''

        this._textBox.updateLineHeight()

        for (const span of this.span.topLevel) {
          span.render()
        }

        // Reflects the addition and deletion of line breaks by span.
        this._textBox.forceUpdate()

        const { clientHeight, clientWidth } = document.documentElement

        for (const span of this.span.allDenotationSpans) {
          span.drawGrid(clientHeight, clientWidth)
        }

        for (const span of this.span.allBlockSpans) {
          span.drawGrid(clientHeight, clientWidth)
        }

        for (const relation of this.relation.all) {
          relation.render(clientHeight, clientWidth)
        }
      }

      _rearrangeAllAnnotations() {
        this.span.arrangeDenotationEntityPosition()

        // When you undo the deletion of a block span,
        // if you move the background first, the grid will move to a better position.
        this.span.arrangeBackgroundOfBlockSpanPosition()
        this.span.arrangeBlockEntityPosition()

        for (const relation of this.relation.all) {
          // The Grid disappears while the span is moving.
          if (
            relation.sourceEntity.span.isGridRendered &&
            relation.targetEntity.span.isGridRendered
          ) {
            relation.redrawLineConsideringSelection()
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/SpanConfig.js

    const defaults = {
      'delimiter characters': [
        ' ',
        '.',
        '!',
        '?',
        ',',
        ':',
        ';',
        '-',
        '/',
        '&',
        '(',
        ')',
        '{',
        '}',
        '[',
        ']',
        '+',
        '*',
        '\\',
        '"',
        "'",
        '\n',
        ''
      ],
      'non-edge characters': [' ', '\n']
    }

    class SpanConfig {
      constructor() {
        this._delimiterCharacters = []
        this._blankCharacters = []
      }

      set(config) {
        const settings = { ...defaults, ...config }

        this._delimiterCharacters = settings['delimiter characters']
        this._blankCharacters = settings['non-edge characters']
        return config
      }

      isDelimiter(char) {
        if (this._delimiterCharacters.indexOf('ANY') >= 0) {
          return 1
        }

        return this._delimiterCharacters.indexOf(char) >= 0
      }

      isBlankCharacter(char) {
        return this._blankCharacters.indexOf(char) >= 0
      }

      removeBlankChractors(str) {
        for (const char of this._blankCharacters) {
          str = str.replaceAll(char, '')
        }

        return str
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/History.js

    // histories of edit to undo and redo.
    class History {
      constructor(eventEmitter) {
        this._resetHistory()
        this._eventEmitter = eventEmitter

        eventEmitter
          .on('textae-event.type-definition.reset', () => {
            this._removeConfigurationOperationsFromHistory()
            this._trigger()
          })
          .on('textae-event.annotation-data.all.change', () => {
            this._resetHistory()
            this._trigger()
          })
          .on('textae-event.resource.annotation.save', () => {
            this._trigger()
          })
          .on('textae-event.resource.configuration.save', () => {
            this._trigger()
          })
      }

      push(command) {
        // Delete the following history.
        this._histories.splice(
          this._pointer + 1,
          this._histories.length - this._pointer,
          command
        )
        this._pointer++
        this._trigger()
      }

      next() {
        this._pointer++
        const next = this._histories[this._pointer]
        this._trigger()
        return next
      }

      prev() {
        const prev = this._histories[this._pointer]
        this._pointer--
        this._trigger()
        return prev
      }

      get hasAnythingToUndo() {
        return this._pointer > -1
      }

      get hasAnythingToRedo() {
        return this._pointer < this._histories.length - 1
      }

      _trigger() {
        this._eventEmitter.emit('textae-event.history.change', this)
      }

      _removeConfigurationOperationsFromHistory() {
        for (let i = 0; i < this._histories.length; i++) {
          if (this._histories[i].isExactly('configuration_command')) {
            this._pointer--
            this._histories.splice(i, 1)
          }
        }
      }

      _resetHistory() {
        this._pointer = -1
        this._histories = []
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/commandLog.js

    /* harmony default export */ function commandLog(self, message, object) {
      // For debug
      if (object) {
        console.log(`[${self.constructor.name}]`, message, object)
      } else {
        console.log(`[${self.constructor.name}]`, message)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/BaseCommand.js

    class BaseCommand {
      get isEmpty() {
        return false
      }

      isExactly(kind) {
        return this.kind.has(kind) && this.kind.size === 1
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/AnnotationCommand.js

    class AnnotationCommand extends BaseCommand {
      get kind() {
        return new Set(['annotation_command'])
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/commandTemplate.js

    class CreateCommand extends AnnotationCommand {
      constructor(annotationData, modelType, model, selectionModel = null) {
        super()
        this._annotationData = annotationData
        this._modelType = modelType
        this._model = model
        this._selectionModel = selectionModel
      }

      execute() {
        this._model = this._annotationData[this._modelType].add(this._model)

        if (this._selectionModel) {
          this._selectionModel.add(this._modelType, this._model.id)
        }

        commandLog(this, `${this._modelType}: ${this._model.id}`)
      }

      revert() {
        return new RemoveCommand(
          this._annotationData,
          this._modelType,
          this._model
        )
      }
    }

    class RemoveCommand extends AnnotationCommand {
      constructor(annotationData, modelType, model) {
        super()
        this._annotationData = annotationData
        this._modelType = modelType
        this._model = model
      }

      execute() {
        this._annotationData[this._modelType].remove(this._model.id)

        commandLog(this, `${this._modelType}: ${this._model.id}`)
      }

      revert() {
        return new CreateCommand(
          this._annotationData,
          this._modelType,
          this._model
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ConfigurationCommand.js

    class ConfigurationCommand extends BaseCommand {
      get kind() {
        return new Set(['configuration_command'])
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/RemoveValueFromAttributeDefinitionCommand.js

    class RemoveValueFromAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(
        definitionContainer,
        attrDef,
        index,
        indexThatAddDefaultTo = null
      ) {
        super()
        this._definitionContainer = definitionContainer
        this._attrDef = attrDef
        this._index = index
        this._indexThatAddDefaultTo = indexThatAddDefaultTo
      }

      execute() {
        const values = [...this._attrDef.values]
        // When removing value with default property.
        if (
          this._attrDef.valueType === 'selection' &&
          values[this._index].default &&
          this._indexThatAddDefaultTo === null
        ) {
          let indexThatAddDefaultTo = null

          values.forEach((_, index) => {
            if (indexThatAddDefaultTo === null && index != this._index) {
              indexThatAddDefaultTo = index
            }
          })

          values[indexThatAddDefaultTo] = {
            ...values[indexThatAddDefaultTo],
            ...{ default: true }
          }
        }

        this._deletedValue = values.splice(this._index, 1)[0]

        // When undoing to add new value with default property.
        if (
          this._attrDef.valueType === 'selection' &&
          this._indexThatAddDefaultTo !== null
        ) {
          values[this._indexThatAddDefaultTo] = {
            ...values[this._indexThatAddDefaultTo],
            ...{ default: true }
          }
        }

        this._updatedAttrDef = this._definitionContainer.updateValues(
          this._attrDef.pred,
          values
        )

        commandLog(
          this,
          `remove a value from an attrribute:${this._attrDef.pred}, index:${
            this._index
          }, updated values: \n ${values
            .map((v) => JSON.stringify(v))
            .join('\n ')}`
        )
      }

      revert() {
        return new AddValueToAttributeDefinitionCommand(
          this._definitionContainer,
          this._updatedAttrDef,
          this._deletedValue,
          this._index
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/AddValueToAttributeDefinitionCommand.js

    class AddValueToAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, attrDef, value, index = null) {
        super()
        this._definitionContainer = definitionContainer
        this._pred = attrDef.pred
        this._index = index
        this._value = value

        const values = [...attrDef.values]
        if (attrDef.valueType === 'selection') {
          // When adding default, remove default property from existing default value.
          if (value.default) {
            if (!this._indexThatRemoveDefaultFrom) {
              this._indexThatRemoveDefaultFrom = values.findIndex(
                (v) => v.default
              )
            }

            const newValue = { ...values[this._indexThatRemoveDefaultFrom] }
            delete newValue.default
            values[this._indexThatRemoveDefaultFrom] = newValue
          }
        }

        // When undoing, insert to the position before remove.
        // The array of values is a copy. If you add values to the array of values when the command executes,
        // the value object will increase each time the command is executed.
        values.splice(index || values.length, 0, value)

        this._modifiedValues = values
      }

      execute() {
        this._updatedAttrDef = this._definitionContainer.updateValues(
          this._pred,
          this._modifiedValues
        )

        commandLog(
          this,
          `add a new value to attrribute:${this._pred}, value: ${JSON.stringify(
            this._value
          )}, index: ${this._index}, updated values: \n ${this._modifiedValues
            .map((v) => JSON.stringify(v))
            .join('\n ')}`
        )
      }

      revert() {
        return new RemoveValueFromAttributeDefinitionCommand(
          this._definitionContainer,
          this._updatedAttrDef,
          this._updatedAttrDef.values.length - 1,
          this._indexThatRemoveDefaultFrom
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CompositeCommand.js

    class CompositeCommand extends BaseCommand {
      execute() {
        console.assert(this._subCommands, '_subCommands is necessary!')

        // If subCommands is empty, pretend to be executed and don't log.
        if (this.isEmpty) {
          this.revert = () => ({
            execute() {}
          })
          return
        }

        for (const c of this._subCommands) {
          c.execute()
        }

        if (this._afterInvoke) {
          this._afterInvoke()
        }

        const self = this
        this.revert = () => ({
          _subCommands: this._subCommands,
          _logMessage: this._logMessage,
          _afterInvoke: this._afterInvoke,
          execute() {
            for (const c of this._subCommands
              .map((c) => c.revert())
              .reverse()) {
              c.execute()
            }

            if (this._afterInvoke) {
              this._afterInvoke()
            }

            commandLog(self, `revert: ${this._logMessage}`)
          }
        })
        commandLog(this, this._logMessage)
      }

      get kind() {
        return this._subCommands.reduce(
          (acc, curr) => new Set([...acc, ...curr.kind]),
          new Set()
        )
      }

      get isEmpty() {
        return !this._subCommands || this._subCommands.length === 0
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeAttributeDefinitionAndRefectInstancesCommand/ChangeAttributeDefinitionCommand/applyChangedProperties.js

    /* harmony default export */ function applyChangedProperties(
      oldAttrDef,
      changedProperties
    ) {
      const newAttrDef = oldAttrDef.JSON
      const revertChangedProperties = new Map()
      // change config
      for (const [key, property] of changedProperties.entries()) {
        if (property === null && typeof oldAttrDef[key] !== 'undefined') {
          delete newAttrDef[key]
          revertChangedProperties.set(key, oldAttrDef[key])
        } else if (property !== null) {
          newAttrDef[key] = property
          revertChangedProperties.set(
            key,
            typeof oldAttrDef[key] === 'undefined' ? null : oldAttrDef[key]
          )
        }
      }
      return [newAttrDef, revertChangedProperties]
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeAttributeDefinitionAndRefectInstancesCommand/ChangeAttributeDefinitionCommand/index.js

    class ChangeAttributeDefinitionCommand extends ConfigurationCommand {
      /**
       *
       * @param {import('../../../../../AttributeDefinitionContainer').default} definitionContainer
       */
      constructor(definitionContainer, attrDef, changedProperties) {
        super()
        this._definitionContainer = definitionContainer
        this._attrDef = attrDef
        this._changedProperties = changedProperties
      }

      execute() {
        const oldPred = this._attrDef.pred
        const [newAttrDef, revertChangedProperties] = applyChangedProperties(
          this._attrDef,
          this._changedProperties
        )

        this._revertAttrDef = this._definitionContainer.update(
          oldPred,
          newAttrDef
        )
        this._revertChangedProperties = revertChangedProperties

        commandLog(
          this,
          `change old pred:${oldPred} to new attridute definition:${JSON.stringify(
            newAttrDef
          )}`
        )
      }

      revert() {
        return new ChangeAttributeDefinitionCommand(
          this._definitionContainer,
          this._revertAttrDef,
          this._revertChangedProperties
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeAttributeCommand.js

    class ChangeAttributeCommand extends AnnotationCommand {
      constructor(annotationData, attribute, newPred, newObj) {
        super()
        this._annotationData = annotationData
        this._attribute = attribute
        this._oldPred = attribute.pred
        this._oldObj = attribute.obj
        this._newPred = newPred
        this._newObj = newObj
      }

      execute() {
        this.newModel = this._annotationData.attribute.change(
          this._attribute.id,
          this._newPred,
          this._newObj
        )

        commandLog(
          this,
          `atttribute: ${this._attribute.id} changed from ${this._oldPred}:${this._oldObj} to ${this.newModel.pred}:${this.newModel.obj}.`
        )
      }

      revert() {
        return new ChangeAttributeCommand(
          this._annotationData,
          this.newModel,
          this._oldPred,
          this._oldObj
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeAttributeDefinitionAndRefectInstancesCommand/index.js

    class ChangeAttributeDefinitionAndRefectInstancesCommand extends CompositeCommand {
      constructor(
        eventEmitter,
        annotationData,
        definitionContainer,
        attrDef,
        changedProperties
      ) {
        super()

        // change config
        const changeConfigcommands = [
          new ChangeAttributeDefinitionCommand(
            definitionContainer,
            attrDef,
            changedProperties
          )
        ]

        let changAnnotationCommands = []
        // change annotation
        if (changedProperties.has('pred')) {
          const sameDefinitionAttributes =
            annotationData.attribute.getSameDefinitionsAttributes(attrDef.pred)

          changAnnotationCommands = sameDefinitionAttributes.map(
            (attribute) => {
              return new ChangeAttributeCommand(
                annotationData,
                attribute,
                changedProperties.get('pred'),
                attribute.obj
              )
            }
          )

          this._afterInvoke = () => {
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              sameDefinitionAttributes
            )
          }
        }

        this._subCommands = changeConfigcommands.concat(changAnnotationCommands)
        this._logMessage = `set ${[...changedProperties.entries()].map(
          ([id, val]) => `${id}:${val}`
        )} to attribute definition ${attrDef.pred}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeAttributeObjOfItemsCommand.js

    class ChangeAttributeObjOfItemsCommand extends CompositeCommand {
      constructor(eventEmitter, annotationData, items, attrDef, newObj) {
        super()

        const effectedAttributes = []
        for (const item of items) {
          const attribute = item.attributes.find(
            (a) => a.pred == attrDef.pred && a.obj !== newObj
          )

          if (attribute) {
            effectedAttributes.push(attribute)
          }
        }

        this._subCommands = effectedAttributes.map(
          (attribute) =>
            new ChangeAttributeCommand(annotationData, attribute, null, newObj)
        )

        if (effectedAttributes.length) {
          this._afterInvoke = () =>
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              effectedAttributes
            )
        }

        this._logMessage = `update obj ${newObj} to attributes: ${effectedAttributes
          .map((attribute) => attribute.id)
          .join(',')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/getAddPatternToStringAttributeDefinitionCommand.js

    /* harmony default export */ function getAddPatternToStringAttributeDefinitionCommand(
      definitionContainer,
      attrDef,
      obj,
      label
    ) {
      // When the value of the string attribute is acquired by auto-complete,
      // if the label of the acquired value is not registered in the attribute definition pattern,
      // it will be additionally registered.
      if (
        attrDef.valueType === 'string' &&
        label &&
        !attrDef.values.some((v) => v.pattern === obj) &&
        label !== attrDef.getLabel(obj)
      ) {
        return new AddValueToAttributeDefinitionCommand(
          definitionContainer,
          attrDef,
          {
            pattern: obj,
            label
          }
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeStringAttributeObjOfItemsCommand.js

    class ChangeStringAttributeObjOfItemsCommand extends CompositeCommand {
      constructor(
        eventEmitter,
        annotationData,
        definitionContainer,
        items,
        attrDef,
        newObj,
        newLabel = null
      ) {
        super()

        const effectedAttributes = []
        for (const item of items) {
          const attribute = item.attributes.find(
            (a) => a.pred == attrDef.pred && a.obj !== newObj
          )

          if (attribute) {
            effectedAttributes.push(attribute)
          }
        }

        this._subCommands = effectedAttributes.map(
          (attribute) =>
            new ChangeAttributeCommand(annotationData, attribute, null, newObj)
        )

        if (effectedAttributes.length) {
          this._afterInvoke = () =>
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              effectedAttributes
            )
        }

        const commnad = getAddPatternToStringAttributeDefinitionCommand(
          definitionContainer,
          attrDef,
          newObj,
          newLabel
        )
        if (commnad) {
          this._subCommands.push(commnad)
        }

        this._logMessage = `update obj ${newObj} to attributes: ${effectedAttributes
          .map((attribute) => attribute.id)
          .join(',')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeAnnotationCommand.js

    class ChangeAnnotationCommand extends AnnotationCommand {
      constructor(annotationData, annotationType, id, newType) {
        super()
        this._annotationData = annotationData
        this._annotationType = annotationType
        this._id = id
        this._newType = newType
      }

      execute() {
        this.oldType = this._annotationData[this._annotationType].get(
          this._id
        ).typeName

        // Update model
        const targetModel = this._annotationData[
          this._annotationType
        ].changeType(this._id, this._newType)
        commandLog(
          this,
          `change type of a ${this._annotationType}. oldtype:${this.oldType} ${this._annotationType}:`,
          targetModel
        )
      }

      revert() {
        return new ChangeAnnotationCommand(
          this._annotationData,
          this._annotationType,
          this._id,
          this.oldType
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeNameAndAttributeOfSelectedItemsCommand/getChangeAttributeCommands.js

    /* harmony default export */ function getChangeAttributeCommands(
      items,
      attributes,
      annotationData
    ) {
      const changeAttributeCommnads = []

      for (const item of items) {
        if (item.typeValues) {
          for (const oldAttribute of item.attributes) {
            const newAttribute = attributes.find((a) =>
              oldAttribute.equalsTo(a.pred, a.obj)
            )
            if (newAttribute) {
              if (String(oldAttribute.obj) !== newAttribute.obj) {
                changeAttributeCommnads.push(
                  new ChangeAttributeCommand(
                    annotationData,
                    oldAttribute,
                    newAttribute.pred,
                    newAttribute.obj
                  )
                )
              }
            } else {
              changeAttributeCommnads.push(
                new RemoveCommand(annotationData, 'attribute', oldAttribute)
              )
            }
          }
        }

        for (const newAttribute of attributes) {
          if (
            !item.attributes.some((a) =>
              a.equalsTo(newAttribute.pred, newAttribute.obj)
            )
          ) {
            changeAttributeCommnads.push(
              new CreateCommand(annotationData, 'attribute', {
                subj: item.id,
                pred: newAttribute.pred,
                obj: newAttribute.obj
              })
            )
          }
        }
      }

      return changeAttributeCommnads
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeNameAndAttributeOfSelectedItemsCommand/index.js

    class ChangeTypeNameAndAttributeOfSelectedItemsCommand extends CompositeCommand {
      constructor(
        annotationData,
        selectionModel,
        annotationType,
        typeName,
        attributes
      ) {
        super()

        // Get only items with changes.
        const itemsWithChange = selectionModel[annotationType].all.filter(
          (item) => !item.typeValues.isSameType(typeName, attributes)
        )

        // Change type of items.
        this._subCommands = itemsWithChange.map(
          (item) =>
            new ChangeAnnotationCommand(
              annotationData,
              annotationType,
              item.id,
              typeName
            )
        )

        // Change attributes
        this._subCommands = this._subCommands.concat(
          getChangeAttributeCommands(
            itemsWithChange,
            attributes,
            annotationData
          )
        )

        for (const { pred, obj, label } of attributes) {
          const definitionContainer = annotationData.typeDefinition.attribute
          const attrDef = definitionContainer.get(pred)
          const commnad = getAddPatternToStringAttributeDefinitionCommand(
            definitionContainer,
            attrDef,
            obj,
            label
          )
          if (commnad) {
            this._subCommands.push(commnad)
          }
        }

        this._logMessage = `set type ${typeName}${
          attributes.length > 0
            ? ` and attributes ${JSON.stringify(attributes)}`
            : ``
        } to ${annotationType} items ${itemsWithChange.map((i) => i.id)}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeDefinitionCommand/applyChangedProperties.js

    /* harmony default export */ function ChangeTypeDefinitionCommand_applyChangedProperties(
      changedProperties,
      oldType
    ) {
      const newType = { ...oldType }
      const revertChangedProperties = new Map()

      // change config
      for (const [key, property] of changedProperties.entries()) {
        if (property === null && typeof oldType[key] !== 'undefined') {
          delete newType[key]
          revertChangedProperties.set(key, oldType[key])
        } else if (property !== null) {
          newType[key] = property
          revertChangedProperties.set(
            key,
            typeof oldType[key] === 'undefined' ? null : oldType[key]
          )
        }
      }

      return [newType, revertChangedProperties]
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeDefinitionCommand/index.js

    class ChangeTypeDefinitionCommand extends ConfigurationCommand {
      constructor(
        annotationData,
        definitionContainer,
        id,
        changedProperties,
        newDefaultTypeId
      ) {
        super()
        this._annotationData = annotationData
        this._definitionContainer = definitionContainer
        this._id = id
        this._changedProperties = changedProperties
        this._newDefaultTypeId = newDefaultTypeId
      }

      execute() {
        const oldType = this._definitionContainer.get(this._id)
        const [newType, revertChangedProperties] =
          ChangeTypeDefinitionCommand_applyChangedProperties(
            this._changedProperties,
            oldType
          )
        this._definitionContainer.replace(this._id, newType)

        if (newType.default) {
          // remember the current default, because revert command will not understand what type was it.
          this.revertDefaultTypeId = this._definitionContainer.defaultType
          this._definitionContainer.defaultType = newType.id
        } else if (this._newDefaultTypeId) {
          this._definitionContainer.defaultType = this._newDefaultTypeId
        }

        this.revertId = newType.id
        this.revertChangedProperties = revertChangedProperties

        commandLog(
          this,
          `change old type:${JSON.stringify(
            oldType
          )} to new type:${JSON.stringify(newType)}, default is ${
            this._definitionContainer.defaultType
          }`
        )
      }

      revert() {
        return new ChangeTypeDefinitionCommand(
          this._annotationData,
          this._definitionContainer,
          this.revertId,
          this.revertChangedProperties,
          this.revertDefaultTypeId
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/RemoveTypeDefinitionCommand.js

    class RemoveTypeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, removeType, revertDefaultTypeId) {
        super()
        this._definitionContainer = definitionContainer
        this._removeType = removeType
        this._revertDefaultTypeId = revertDefaultTypeId
      }

      execute() {
        const { id } = this._removeType
        const oldType = this._definitionContainer.get(id)

        this._definitionContainer.delete(id, this._revertDefaultTypeId)

        if (oldType) {
          this._removeType = oldType
        }

        commandLog(
          this,
          `remove a type:${JSON.stringify(this._removeType)}, default is ${
            this._definitionContainer.defaultType
          }`
        )
      }

      revert() {
        return new CreateTypeDefinitionCommand(
          this._definitionContainer,
          this._removeType
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateTypeDefinitionCommand.js

    class CreateTypeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, newType) {
        super()
        this._definitionContainer = definitionContainer
        this._newType = newType
      }

      execute() {
        // For UNDO, remember the default value before running this command.
        this._revertDefaultTypeId = this._definitionContainer._defaultType

        this._definitionContainer.addDefinedType(this._newType)

        commandLog(
          this,
          `create a new type:${JSON.stringify(this._newType)}, default is ${
            this._definitionContainer.defaultType
          }`
        )
      }

      revert() {
        return new RemoveTypeDefinitionCommand(
          this._definitionContainer,
          this._newType,
          this._revertDefaultTypeId
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/createChangeConfigCommand.js

    /* harmony default export */ function createChangeConfigCommand(
      definitionContainer,
      id,
      annotationData,
      changedProperties
    ) {
      // The palette also displays instance types other than type in the typeDefinition,
      // so modified type may not be in the typeDefinition.
      if (definitionContainer.has(id)) {
        return new ChangeTypeDefinitionCommand(
          annotationData,
          definitionContainer,
          id,
          changedProperties,
          null
        )
      } else {
        // The change properties contain only the changed attributes.
        // When the ID is changed, it does not overwrite the ID with the old ID.
        // When you add a label, the old ID is used to add the type definition.
        return new CreateTypeDefinitionCommand(definitionContainer, {
          id,
          ...Object.fromEntries(changedProperties)
        })
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeValuesCommand.js

    class ChangeTypeValuesCommand extends CompositeCommand {
      constructor(
        annotationData,
        selectionModel,
        label,
        value,
        definitionContainer,
        attributes
      ) {
        super()

        const commands = []
        if (label) {
          commands.push(
            createChangeConfigCommand(
              definitionContainer,
              value,
              annotationData,
              new Map([['label', label]])
            )
          )
        }

        const changeItemsCommand =
          new ChangeTypeNameAndAttributeOfSelectedItemsCommand(
            annotationData,
            selectionModel,
            definitionContainer.annotationType,
            value,
            attributes
          )
        if (!changeItemsCommand.isEmpty) {
          commands.push(changeItemsCommand)
        }

        this._subCommands = commands
        this._logMessage = `change ${
          definitionContainer.annotationType
        } value:"${value}"${label ? `, label:"${label}"` : ``}${
          attributes.length > 0
            ? `, attributes:${JSON.stringify(attributes)}`
            : ``
        }`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeDefinitionAndRefectInstancesCommand/createChangeAnnotationCommands.js

    /* harmony default export */ function createChangeAnnotationCommands(
      annotationData,
      annotationType,
      oldTypeName,
      newTypeName
    ) {
      return annotationData[annotationType].all
        .filter((model) => model.typeName === oldTypeName)
        .map((model) => {
          return new ChangeAnnotationCommand(
            annotationData,
            annotationType,
            model.id,
            newTypeName
          )
        })
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeDefinitionAndRefectInstancesCommand/index.js

    class ChangeTypeDefinitionAndRefectInstancesCommand extends CompositeCommand {
      constructor(
        annotationData,
        definitionContainer,
        annotationType,
        id,
        changedProperties
      ) {
        super()

        // change config
        const changeConfigcommands = [
          createChangeConfigCommand(
            definitionContainer,
            id,
            annotationData,
            changedProperties
          )
        ]

        let changAnnotationCommands = []
        // change annotation
        if (changedProperties.has('id')) {
          changAnnotationCommands = createChangeAnnotationCommands(
            annotationData,
            annotationType,
            id,
            changedProperties.get('id')
          )
        }

        this._subCommands = changeConfigcommands.concat(changAnnotationCommands)
        this._logMessage = `set ${[...changedProperties.entries()].map(
          ([id, val]) => `${id}:${val}`
        )} to type definition ${id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeTypeOfSelectedItemsCommand.js

    class ChangeTypeOfSelectedItemsCommand extends CompositeCommand {
      constructor(annotationData, selectionModel, annotationType, typeName) {
        super()

        const itemsWithChange = selectionModel[annotationType].all.filter(
          (item) => !item.typeValues.isSameType(typeName)
        )

        this._subCommands = itemsWithChange.map(
          (item) =>
            new ChangeAnnotationCommand(
              annotationData,
              annotationType,
              item.id,
              typeName
            )
        )
        this._logMessage = `set type ${typeName} to ${annotationType} items ${itemsWithChange}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand/ChangeValueOfAttributeDefinitionCommand.js

    class ChangeValueOfAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(
        definitionContainer,
        attrDef,
        targetIndex,
        newValue,
        indexThatRemoveDefaultFrom
      ) {
        super()
        this._definitionContainer = definitionContainer
        this._attrDef = attrDef
        this._targetIndex = targetIndex
        this._newValue = newValue
        this._indexThatRemoveDefaultFrom = indexThatRemoveDefaultFrom
      }

      execute() {
        // Change default value of selection attribute.
        if (this._attrDef['value type'] === 'selection') {
          // When adding default
          if (
            !this._attrDef.values[this._targetIndex].default &&
            this._newValue.default
          ) {
            if (!this._indexThatRemoveDefaultFrom) {
              this._indexThatRemoveDefaultFrom = this._attrDef.values.findIndex(
                (v) => v.default
              )
            }

            delete this._attrDef.values[this._indexThatRemoveDefaultFrom]
              .default
          }

          // When removeing default.
          if (
            this._attrDef.values[this._targetIndex].default &&
            !this._newValue.default
          ) {
            if (this._attrDef.values.length === 1) {
              this._newValue.default = true
            } else if (this._indexThatRemoveDefaultFrom) {
              this._attrDef.values[
                this._indexThatRemoveDefaultFrom
              ].default = true
            } else {
              let indexThatAddDefaultTo = null

              this._attrDef.values.forEach((v, index) => {
                if (
                  indexThatAddDefaultTo === null &&
                  index != this._targetIndex
                ) {
                  indexThatAddDefaultTo = index
                }
              })

              this._attrDef.values[indexThatAddDefaultTo].default = true
              this._indexThatRemoveDefaultFrom = indexThatAddDefaultTo
            }
          }
        }

        this._valueBeforeChange = this._attrDef.values.splice(
          this._targetIndex,
          1,
          this._newValue
        )[0]

        this._definitionContainer.update(this._attrDef.pred, this._attrDef)

        commandLog(
          this,
          `change value of attrribute:${
            this._attrDef.pred
          }, oldValue: ${JSON.stringify(
            this._valueBeforeChange
          )}, newValue: ${JSON.stringify(this._newValue)}`
        )
      }

      revert() {
        return new ChangeValueOfAttributeDefinitionCommand(
          this._definitionContainer,
          this._attrDef,
          this._targetIndex,
          this._valueBeforeChange,
          this._indexThatRemoveDefaultFrom
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand/index.js

    class ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand extends CompositeCommand {
      constructor(
        eventEmitter,
        annotationData,
        definitionContainer,
        attrDef,
        index,
        value,
        indexThatRemoveDefaultFrom
      ) {
        super()

        this._subCommands = [
          new ChangeValueOfAttributeDefinitionCommand(
            definitionContainer,
            attrDef,
            index,
            value,
            indexThatRemoveDefaultFrom
          )
        ]

        if (
          attrDef['value type'] === 'selection' &&
          attrDef.values[index].id !== value.id
        ) {
          const sameAttributes = annotationData.attribute.getSameAttributes(
            attrDef.pred,
            attrDef.values[index].id
          )
          const changeAnnotationCommands = sameAttributes.map(
            (a) => new ChangeAttributeCommand(annotationData, a, null, value.id)
          )

          this._subCommands = this._subCommands.concat(changeAnnotationCommands)
          this._afterInvoke = () =>
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              sameAttributes
            )
        }

        this._logMessage = `attribute: ${attrDef.pred}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/DeleteAttributeDefinitionCommand.js

    class DeleteAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, attrDef) {
        super()
        this._definitionContainer = definitionContainer
        this._removeAttrdef = attrDef
        this._index = definitionContainer.getIndexOf(attrDef.pred)
      }

      execute() {
        this._definitionContainer.delete(this._removeAttrdef.pred)

        commandLog(
          this,
          `remove an attrribute definition:${JSON.stringify(
            this._removeAttrdef
          )}, index:${this._index}`
        )
      }

      revert() {
        return new CreateAttributeDefinitionCommand(
          this._definitionContainer,
          this._removeAttrdef,
          this._index
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateAttributeDefinitionCommand.js

    class CreateAttributeDefinitionCommand extends ConfigurationCommand {
      /** @param {import("../../../AttributeDefinitionContainer").default} definitionContainer */
      constructor(definitionContainer, attrDef, index) {
        super()
        this._definitionContainer = definitionContainer
        this._newAttrDef = attrDef
        this._index = index
      }

      execute() {
        // Added default value to newly created selection attribute definition.
        // Except when undoing the deletion of selection attribute definition.
        if (
          this._newAttrDef.valueType === 'selection' &&
          !this._newAttrDef.values
        ) {
          this._newAttrDef.values = [
            {
              id: 'default',
              default: true
            }
          ]
        }

        this._definitionContainer.create(
          this._newAttrDef.valueType,
          this._newAttrDef,
          this._index
        )

        commandLog(
          this,
          `create a new attrribute definition:${JSON.stringify(
            this._newAttrDef
          )}, index: ${this._index}`
        )
      }

      revert() {
        return new DeleteAttributeDefinitionCommand(
          this._definitionContainer,
          this._newAttrDef
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/getCreateAttributeToItemsCommands.js

    /* harmony default export */ function getCreateAttributeToItemsCommands(
      annotationData,
      items,
      pred,
      obj
    ) {
      return items
        .filter((i) => !i.typeValues.hasSpecificPredicateAttribute(pred))
        .map(({ id }) => {
          return new CreateCommand(annotationData, 'attribute', {
            id: null,
            subj: id,
            pred,
            obj
          })
        })
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateAttributeToItemsCommand.js

    class CreateAttributeToItemsCommand extends CompositeCommand {
      constructor(annotationData, items, attributeDefinition, obj) {
        super()

        this._subCommands = getCreateAttributeToItemsCommands(
          annotationData,
          items,
          attributeDefinition.pred,
          obj || attributeDefinition.default
        )

        this._logMessage = `create attirbute ${attributeDefinition.pred}:${
          attributeDefinition.default
        } to item ${items.map(({ id }) => id).join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateEntityAndAttributesCommand/CreateAttributeToTheLatestEntityCommand.js

    class CreateAttributeToTheLatestEntityCommand extends CreateCommand {
      constructor(annotationData, obj, pred) {
        super(annotationData, 'attribute', {
          obj,
          pred
        })
      }

      execute() {
        const subj = this._annotationData.entity.all.pop().id
        this._model.subj = subj
        return super.execute()
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateEntityAndAttributesCommand/index.js

    class CreateEntityAndAttributesCommand extends CompositeCommand {
      constructor(annotationData, selectionModel, span, typeName, attributes) {
        super()

        this._subCommands = [
          new CreateCommand(
            annotationData,
            'entity',
            {
              span,
              typeName
            },
            selectionModel
          )
        ].concat(
          attributes.map(
            ({ obj, pred }) =>
              // Only one entity was created.
              new CreateAttributeToTheLatestEntityCommand(
                annotationData,
                obj,
                pred
              )
          )
        )

        this._logMessage = `span: ${span}, type: ${typeName}${
          attributes.length
            ? `, attributes: ${attributes.map(({ pred }) => pred).join(', ')}`
            : ''
        }`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateBlockSpanCommand.js

    class CreateBlockCommand extends CompositeCommand {
      constructor(
        editorID,
        annotationData,
        selectionModel,
        begin,
        end,
        defaultType
      ) {
        super()

        const spanId = makeBlockSpanHTMLElementID(editorID, begin, end)
        const createSpanCommand = new CreateCommand(
          annotationData,
          'span',
          {
            begin,
            end,
            isBlock: true
          },
          selectionModel
        )
        const createEntityCommand = new CreateEntityAndAttributesCommand(
          annotationData,
          selectionModel,
          spanId,
          defaultType,
          []
        )

        this._subCommands = [createSpanCommand, createEntityCommand]
        this._logMessage = `create a span ${spanId}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateDefaultTypeEntityToSelectedSpansCommand.js

    class CreateDefaultTypeEntityToSelectedSpansCommand extends CompositeCommand {
      constructor(annotationData, selectionModel, typeName) {
        super()

        const selectedSpans = selectionModel.span.all
          .filter((span) => span.isDenotation)
          .map((span) => span.id)
        this._subCommands = selectedSpans.map(
          (span) =>
            new CreateCommand(
              annotationData,
              'entity',
              {
                span,
                typeName
              },
              selectionModel
            )
        )

        this._logMessage = `create a ${typeName} type entity to ${selectedSpans}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateSpanAndTypesCommand.js

    class CreateSpanAndTypesCommand extends CompositeCommand {
      constructor(
        annotationData,
        selectionModel,
        spanId,
        begin,
        end,
        typeValuesList
      ) {
        super()

        this._subCommands = [
          new CreateCommand(
            annotationData,
            'span',
            {
              begin,
              end
            },
            selectionModel
          )
        ].concat(
          typeValuesList.map(
            (typeValues) =>
              new CreateEntityAndAttributesCommand(
                annotationData,
                selectionModel,
                spanId,
                typeValues.typeName,
                typeValues.attributes
              )
          )
        )
        this._logMessage = `span: ${spanId}, types: ${typeValuesList
          .map(({ typeName }) => typeName)
          .join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ReplicateSpanCommand.js

    class ReplicateSpanCommand extends CompositeCommand {
      constructor(
        editorID,
        annotationData,
        selectionModel,
        span,
        typeValeusList,
        isDelimiterFunc
      ) {
        super()

        this._subCommands = annotationData
          .getReplicationRanges(span, isDelimiterFunc)
          .map(({ begin, end }) => {
            const spanId = makeDenotationSpanHTMLElementID(editorID, begin, end)

            return new CreateSpanAndTypesCommand(
              annotationData,
              selectionModel,
              spanId,
              begin,
              end,
              typeValeusList
            )
          })
        this._logMessage = `from span: ${makeDenotationSpanHTMLElementID(
          editorID,
          span.begin,
          span.end
        )}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/CreateSpanAndAutoReplicateCommand.js

    const BLOCK_THRESHOLD = 100

    class CreateSpanAndAutoReplicateCommand extends CompositeCommand {
      constructor(
        editorID,
        annotationData,
        selectionModel,
        newSpan,
        defaultType,
        isReplicateAuto,
        isDelimiterFunc
      ) {
        super()

        const typeValuesList = [new TypeValues(defaultType)]

        const spanID = makeDenotationSpanHTMLElementID(
          editorID,
          newSpan.begin,
          newSpan.end
        )

        this._subCommands = [
          new CreateSpanAndTypesCommand(
            annotationData,
            selectionModel,
            spanID,
            newSpan.begin,
            newSpan.end,
            typeValuesList
          )
        ]
        this._logMessage = `create a span ${newSpan.begin}:${newSpan.end} with type ${typeValuesList[0].typeName}`

        if (isReplicateAuto && newSpan.end - newSpan.begin <= BLOCK_THRESHOLD) {
          this._subCommands.push(
            new ReplicateSpanCommand(
              editorID,
              annotationData,
              selectionModel,
              {
                begin: newSpan.begin,
                end: newSpan.end
              },
              typeValuesList,
              isDelimiterFunc
            )
          )
          this._logMessage = `${this._logMessage} and replicate auto`
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/MoveAttributeDefinitionCommand.js

    class MoveAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, oldIndex, newIndex) {
        super()
        this._definitionContainer = definitionContainer
        this._oldIndex = oldIndex
        this._newIndex = newIndex
      }

      execute() {
        this._definitionContainer.move(this._oldIndex, this._newIndex)

        commandLog(
          this,
          `move the attrribute definition: from ${this._oldIndex} to ${this._newIndex}`
        )
      }

      revert() {
        return new MoveAttributeDefinitionCommand(
          this._definitionContainer,
          this._newIndex,
          this._oldIndex
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/MoveBlockSpanCommand.js

    class MoveBlockSpanCommand extends AnnotationCommand {
      constructor(annotationData, spanId, begin, end) {
        super()
        this._annotationData = annotationData
        this._spanId = spanId
        this._begin = begin
        this._end = end
      }

      execute() {
        // Update model
        const { id, begin, end } = this._annotationData.span.moveBlockSpan(
          this._spanId,
          this._begin,
          this._end
        )

        this._newId = id
        this._oldBegin = begin
        this._oldEnd = end

        commandLog(
          this,
          `move span: ${this._spanId} to {begin: ${this._begin}, end: ${this._end}}`
        )
      }

      revert() {
        return new MoveBlockSpanCommand(
          this._annotationData,
          this._newId,
          this._oldBegin,
          this._oldEnd
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/MoveDenotationSpanCommand.js

    class MoveDenotationSpanCommand extends AnnotationCommand {
      constructor(annotationData, spanId, begin, end) {
        super()
        this._annotationData = annotationData
        this._spanId = spanId
        this._begin = begin
        this._end = end
      }

      execute() {
        // Update model
        const { id, begin, end } = this._annotationData.span.moveDenotationSpan(
          this._spanId,
          this._begin,
          this._end
        )

        this._newId = id
        this._oldBegin = begin
        this._oldEnd = end

        commandLog(
          this,
          `move span: ${this._spanId} to {begin: ${this._begin}, end: ${this._end}}`
        )
      }

      revert() {
        return new MoveDenotationSpanCommand(
          this._annotationData,
          this._newId,
          this._oldBegin,
          this._oldEnd
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/areAllEntiesOfSpan.js

    /* harmony default export */ function areAllEntiesOfSpan(span, entities) {
      return span.entities.every((entity) => entities.includes(entity))
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/MoveEntitiesToSelectedSpanCommand/MoveEntitiesToSpanCommand/RevertMoveEntitiesCommand.js

    class RevertMoveEntitiesCommand extends CompositeCommand {
      constructor(annotationData, moveMap) {
        super()

        this._subCommands = []
        for (const [span, entities] of moveMap.entries()) {
          this._subCommands.push(
            new MoveEntitiesToSpanCommand(annotationData, span, entities)
          )
        }

        this._logMessage = `revert: move entities ${Array.from(moveMap.values())
          .flat()
          .map((e) => e.id)
          .join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/MoveEntitiesToSelectedSpanCommand/MoveEntitiesToSpanCommand/index.js

    class MoveEntitiesToSpanCommand extends AnnotationCommand {
      constructor(annotationData, span, entities) {
        super()

        this._annotationData = annotationData
        this._span = span
        this._entities = entities
      }

      execute() {
        // Save move map to revert this command.
        this._moveMap = this._entities.reduce((map, entity) => {
          if (map.has(entity.span)) {
            map.get(entity.span).push(entity)
          } else {
            map.set(entity.span, [entity])
          }
          return map
        }, new Map())

        const message = `${Array.from(this._moveMap.entries())
          .map(([_, entities]) => {
            return `${entities.map((e) => e.id).join(', ')} from ${
              entities[0].span.id
            } to ${this._span.id}`
          })
          .join(', ')}`

        this._annotationData.entity.moveEntities(this._span, this._entities)

        commandLog(this, message)
      }

      revert() {
        return new RevertMoveEntitiesCommand(
          this._annotationData,
          this._moveMap
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/MoveEntitiesToSelectedSpanCommand/index.js

    class MoveEntitiesToSelectedSpanCommand extends CompositeCommand {
      constructor(annotationData, selectionModel, entities) {
        console.assert(
          selectionModel.span.single,
          'There must be one span to be pasted.'
        )

        super()

        // Move cut entities to the selected span.
        const commands = [
          new MoveEntitiesToSpanCommand(
            annotationData,
            selectionModel.span.single,
            entities
          )
        ]

        // Remove spans losing all entities.
        for (const span of entities
          .map((entity) => entity.span)
          .reduce((acc, span) => {
            acc.add(span)
            return acc
          }, new Set())
          .values()) {
          if (areAllEntiesOfSpan(span, entities)) {
            commands.push(new RemoveCommand(annotationData, 'span', span))
          }
        }

        this._subCommands = commands

        this._logMessage = `paste cut entities`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/PasteTypesToSelectedSpansCommand.js

    class PasteTypesToSelectedSpansCommand extends CompositeCommand {
      constructor(
        annotationData,
        selectionModel,
        typeValuesList,
        newTypes,
        attrDefs,
        newSelectionAttributeObjects
      ) {
        super()

        const selecteedSpans = selectionModel.span.all.map((span) => span.id)
        this._subCommands = []

        for (const newType of newTypes) {
          this._subCommands.push(
            new CreateTypeDefinitionCommand(
              annotationData.denotationDefinitionContainer,
              newType
            )
          )
        }

        for (const attrDef of attrDefs) {
          this._subCommands.push(
            new CreateAttributeDefinitionCommand(
              annotationData.attributeDefinitionContainer,
              { valueType: attrDef['value type'], ...attrDef }
            )
          )
        }

        for (const { pred, value } of newSelectionAttributeObjects) {
          this._subCommands.push(
            new AddValueToAttributeDefinitionCommand(
              annotationData.attributeDefinitionContainer,
              annotationData.attributeDefinitionContainer.get(pred),
              value
            )
          )
        }

        this._subCommands = this._subCommands.concat(
          selecteedSpans
            .map((span) =>
              typeValuesList.map(
                (typeValues) =>
                  new CreateEntityAndAttributesCommand(
                    annotationData,
                    selectionModel,
                    span,
                    typeValues.typeName,
                    typeValues.attributes
                  )
              )
            )
            .flat()
        )

        this._logMessage = `paste types [${typeValuesList.map(
          ({ typeName, attributes }) =>
            [`{type:${typeName}}`].concat(
              attributes.map(({ pred, obj }) => `{${pred}:${obj}}`)
            )
        )}] to ${selecteedSpans}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/getRemoveAttributesByPredCommands.js

    /* harmony default export */ function getRemoveAttributesByPredCommands(
      annotationData,
      items,
      pred
    ) {
      return items
        .reduce((attrs, { attributes }) => attrs.concat(attributes), [])
        .filter((a) => a.pred === pred)
        .map((a) => new RemoveCommand(annotationData, 'attribute', a))
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/RemoveAttributesFromItemsByPredCommand.js

    class RemoveAttributesFromItemsByPredCommand extends CompositeCommand {
      constructor(annotationData, items, attributeDefinition) {
        super()

        const removeAttributeCommands = getRemoveAttributesByPredCommands(
          annotationData,
          items,
          attributeDefinition.pred
        )

        this._subCommands = removeAttributeCommands
        this._logMessage = `remove ${
          attributeDefinition.pred
        } attribute from items ${items.map((i) => i.id).join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/aggregateTargetRelations.js

    /* harmony default export */ function aggregateTargetRelations(
      targetRelations,
      targetAttributes,
      relation
    ) {
      targetRelations.add(relation)
      for (const attribute of relation.attributes) {
        targetAttributes.add(attribute)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/aggregateTargetEntities.js

    /* harmony default export */ function aggregateTargetEntities(
      targetEntities,
      targetRelations,
      targetAttributes,
      entity
    ) {
      targetEntities.add(entity)
      for (const attribute of entity.attributes) {
        targetAttributes.add(attribute)
      }
      for (const relation of entity.relations) {
        aggregateTargetRelations(targetRelations, targetAttributes, relation)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/RemoveSelectedCommand.js

    class RemoveSelectedCommand extends CompositeCommand {
      constructor(annotationData, selectionModel) {
        super()

        // Aggregate seleceted targets
        const targetSpans = new Set()
        const targetEntities = new Set()
        const targetRelations = new Set()
        const targetAttributes = new Set()
        for (const span of selectionModel.span.all) {
          targetSpans.add(span)
          for (const entity of span.entities) {
            aggregateTargetEntities(
              targetEntities,
              targetRelations,
              targetAttributes,
              entity
            )
          }
        }
        for (const entity of selectionModel.entity.all) {
          aggregateTargetEntities(
            targetEntities,
            targetRelations,
            targetAttributes,
            entity
          )
        }
        for (const relation of selectionModel.relation.all) {
          aggregateTargetRelations(targetRelations, targetAttributes, relation)
        }

        // Aggregate spans to lose all entities.
        for (const span of annotationData.span.all) {
          if (
            span.entities.every((e) => selectionModel.entity.all.includes(e))
          ) {
            if (!span.styleOnly) {
              targetSpans.add(span)
            }
          }
        }

        this._subCommands = []
        for (const attribute of targetAttributes) {
          this._subCommands.push(
            new RemoveCommand(annotationData, 'attribute', attribute)
          )
        }
        for (const relation of targetRelations) {
          this._subCommands.push(
            new RemoveCommand(annotationData, 'relation', relation)
          )
        }
        for (const entity of targetEntities) {
          this._subCommands.push(
            new RemoveCommand(annotationData, 'entity', entity)
          )
        }
        for (const span of targetSpans) {
          this._subCommands.push(
            new RemoveCommand(annotationData, 'span', span)
          )
        }

        this._logMessage = `remove selected ${[
          ...targetSpans,
          ...targetEntities,
          ...targetRelations,
          ...targetAttributes
        ]
          .map(({ id }) => id)
          .join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/RemoveRelationAndAssociatesCommand.js

    class RemoveRelationAndAssociatesCommand extends CompositeCommand {
      constructor(annotationData, relation) {
        super()
        const removeRelation = new RemoveCommand(
          annotationData,
          'relation',
          relation
        )
        const removeAttribute = relation.attributes.map(
          (attribute) =>
            new RemoveCommand(annotationData, 'attribute', attribute)
        )

        this._subCommands = removeAttribute.concat(removeRelation)
        this._logMessage = `remove a relation ${relation.id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/RemoveEntityAndAssociatesCommand.js

    class RemoveEntityAndAssociatesCommand extends CompositeCommand {
      constructor(annotationData, entity) {
        super()
        const removeEntity = new RemoveCommand(annotationData, 'entity', entity)
        const removeRelation = entity.relations.map(
          (relation) =>
            new RemoveRelationAndAssociatesCommand(annotationData, relation)
        )
        const removeAttribute = entity.attributes.map(
          (attribute) =>
            new RemoveCommand(annotationData, 'attribute', attribute)
        )

        this._subCommands = removeRelation
          .concat(removeAttribute)
          .concat(removeEntity)
        this._logMessage = `remove an entity ${entity.id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/RemoveSpanCommand.js

    class RemoveSpanCommand extends CompositeCommand {
      constructor(annotationData, id) {
        super()

        const span = annotationData.span.get(id)
        const removeEntities = span.entities.map(
          (entity) =>
            new RemoveEntityAndAssociatesCommand(annotationData, entity)
        )

        const removeSpan = new RemoveCommand(annotationData, 'span', span)

        this._subCommands = removeEntities.concat(removeSpan)
        this._logMessage = `remove a span ${id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/ToggleFlagAttributeToItemsCommand.js

    class ToggleFlagAttributeToItemsCommand extends CompositeCommand {
      constructor(annotationData, items, attributeDefinition) {
        super()

        this._subCommands = getCreateAttributeToItemsCommands(
          annotationData,
          items,
          attributeDefinition.pred,
          attributeDefinition.default
        )

        // Toggle exisitng flag type attributes
        const removeAttributeCommands = getRemoveAttributesByPredCommands(
          annotationData,
          items,
          attributeDefinition.pred
        )

        this._subCommands = this._subCommands.concat(removeAttributeCommands)

        this._logMessage = `toggle flag attirbute ${
          attributeDefinition.pred
        } to item ${items.map(({ id }) => id).join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/Factory/index.js

    class Factory {
      constructor(editorID, eventEmitter, annotationData, selectionModel) {
        this._editorID = editorID
        this._eventEmitter = eventEmitter
        this._annotationData = annotationData
        this._selectionModel = selectionModel
      }

      addValueToAttributeDefinitionCommand(attributeDefinition, value) {
        return new AddValueToAttributeDefinitionCommand(
          this._annotationData.typeDefinition.attribute,
          attributeDefinition,
          value
        )
      }

      changeAttributeDefinitionCommand(attributeDefinition, changedProperties) {
        return new ChangeAttributeDefinitionAndRefectInstancesCommand(
          this._eventEmitter,
          this._annotationData,
          this._annotationData.typeDefinition.attribute,
          attributeDefinition,
          changedProperties
        )
      }

      changeAttributeObjOfItemsCommand(items, attributeDefinition, newObj) {
        return new ChangeAttributeObjOfItemsCommand(
          this._eventEmitter,
          this._annotationData,
          items,
          attributeDefinition,
          newObj
        )
      }

      changeStringAttributeObjOfItemsCommand(
        items,
        attributeDefinition,
        newObj,
        newLabel
      ) {
        return new ChangeStringAttributeObjOfItemsCommand(
          this._eventEmitter,
          this._annotationData,
          this._annotationData.typeDefinition.attribute,
          items,
          attributeDefinition,
          newObj,
          newLabel
        )
      }

      changeTypeValuesCommand(label, value, definitionContainer, attributes) {
        return new ChangeTypeValuesCommand(
          this._annotationData,
          this._selectionModel,
          label,
          value,
          definitionContainer,
          attributes
        )
      }

      changeTypeDefinitionCommand(
        definitionContainer,
        annotationType,
        id,
        changedProperties
      ) {
        return new ChangeTypeDefinitionAndRefectInstancesCommand(
          this._annotationData,
          definitionContainer,
          annotationType,
          id,
          changedProperties
        )
      }

      changeTypeOfSelectedItemsCommand(annotationType, newType) {
        return new ChangeTypeOfSelectedItemsCommand(
          this._annotationData,
          this._selectionModel,
          annotationType,
          newType
        )
      }

      changeValueOfAttributeDefinitionAndObjectOfSelectionAttributeCommand(
        attributeDefinition,
        index,
        value
      ) {
        return new ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand(
          this._eventEmitter,
          this._annotationData,
          this._annotationData.typeDefinition.attribute,
          attributeDefinition,
          index,
          value
        )
      }

      createAttributeDefinitionCommand(attributeDefinition) {
        return new CreateAttributeDefinitionCommand(
          this._annotationData.typeDefinition.attribute,
          attributeDefinition
        )
      }

      createAttributeToItemsCommand(items, attributeDefinition, obj = null) {
        return new CreateAttributeToItemsCommand(
          this._annotationData,
          items,
          attributeDefinition,
          obj
        )
      }

      createBlockSpanCommand(newSpan) {
        return new CreateBlockCommand(
          this._editorID,
          this._annotationData,
          this._selectionModel,
          newSpan.begin,
          newSpan.end,
          this._annotationData.typeDefinition.block.defaultType
        )
      }

      createDefaultTypeEntityToSelectedSpansCommand(typeName) {
        return new CreateDefaultTypeEntityToSelectedSpansCommand(
          this._annotationData,
          this._selectionModel,
          typeName
        )
      }

      createRelationCommand(relation) {
        return new CreateCommand(
          this._annotationData,
          'relation',
          relation,
          this._selectionModel
        )
      }

      createSpanAndAutoReplicateCommand(
        newSpan,
        isReplicateAuto,
        isDelimiterFunc
      ) {
        return new CreateSpanAndAutoReplicateCommand(
          this._editorID,
          this._annotationData,
          this._selectionModel,
          newSpan,
          this._annotationData.typeDefinition.denotation.defaultType,
          isReplicateAuto,
          isDelimiterFunc
        )
      }

      createTypeDefinitionCommand(definitionContainer, newType) {
        return new CreateTypeDefinitionCommand(definitionContainer, newType)
      }

      deleteAttributeDefinitionCommand(attributeDefinition) {
        return new DeleteAttributeDefinitionCommand(
          this._annotationData.typeDefinition.attribute,
          attributeDefinition
        )
      }

      moveAttributeDefintionComannd(oldIndex, newIndex) {
        return new MoveAttributeDefinitionCommand(
          this._annotationData.typeDefinition.attribute,
          oldIndex,
          newIndex
        )
      }

      moveBlockSpanCommand(spanId, begin, end) {
        return new MoveBlockSpanCommand(
          this._annotationData,
          spanId,
          begin,
          end
        )
      }

      moveDenotationSpanCommand(spanId, begin, end) {
        return new MoveDenotationSpanCommand(
          this._annotationData,
          spanId,
          begin,
          end
        )
      }

      moveEntitiesToSelectedSpanCommand(entities) {
        return new MoveEntitiesToSelectedSpanCommand(
          this._annotationData,
          this._selectionModel,
          entities
        )
      }

      pasteTypesToSelectedSpansCommand(
        typeValuesList,
        newTypes = [],
        attrDefs = [],
        newSelectionAttributeObjects = []
      ) {
        return new PasteTypesToSelectedSpansCommand(
          this._annotationData,
          this._selectionModel,
          typeValuesList,
          newTypes,
          attrDefs,
          newSelectionAttributeObjects
        )
      }

      replicateSpanCommand(span, typeValuesList, isDelimiterFunc) {
        return new ReplicateSpanCommand(
          this._editorID,
          this._annotationData,
          this._selectionModel,
          span,
          typeValuesList,
          isDelimiterFunc
        )
      }

      removeAttributesFromItemsByPredCommand(items, attributeDefinition) {
        return new RemoveAttributesFromItemsByPredCommand(
          this._annotationData,
          items,
          attributeDefinition
        )
      }

      removeSpanCommand(id) {
        return new RemoveSpanCommand(this._annotationData, id)
      }

      removeSelectedComand() {
        return new RemoveSelectedCommand(
          this._annotationData,
          this._selectionModel
        )
      }

      removeTypeDefinitionCommand(definitionContainer, removeType) {
        return new RemoveTypeDefinitionCommand(definitionContainer, removeType)
      }

      removeValueFromAttributeDefinitionCommand(attributeDefinition, index) {
        return new RemoveValueFromAttributeDefinitionCommand(
          this._annotationData.typeDefinition.attribute,
          attributeDefinition,
          index
        )
      }

      toggleFlagAttributeToItemsCommand(items, attributeDefinition) {
        return new ToggleFlagAttributeToItemsCommand(
          this._annotationData,
          items,
          attributeDefinition
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Commander/index.js

    // A command is an operation by user that is saved as history, and can undo and redo.
    // Users can edit model only via commands.
    class Commander {
      constructor(
        editorHTMLElement,
        editorID,
        eventEmitter,
        annotationData,
        selectionModel
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._editorID = editorID
        this._eventEmitter = eventEmitter
        this._annotationData = annotationData
        this._selectionModel = selectionModel
        this._history = new History(eventEmitter)
      }

      invoke(command) {
        if (command.isEmpty) {
          return
        }

        command.execute()
        this._history.push(command)
      }

      undo() {
        if (this._history.hasAnythingToUndo) {
          // Focus the editor.
          // Focus is lost when undo a creation.
          this._selectionModel.removeAll()
          this._editorHTMLElement.focus()

          const command = this._history.prev()
          if (command.kind.has('configuration_command')) {
            alertify_default().success('configuration has been undone')
          }

          command.revert().execute()
        }
      }

      redo() {
        if (this._history.hasAnythingToRedo) {
          // Select only new element when redo a creation.
          this._selectionModel.removeAll()

          const command = this._history.next()
          if (command.kind.has('configuration_command')) {
            alertify_default().success('configuration has been redo')
          }

          command.execute()
        }
      }

      get factory() {
        return new Factory(
          this._editorID,
          this._eventEmitter,
          this._annotationData,
          this._selectionModel,
          this._annotationData.typeDefinition
        )
      }
    } // CONCATENATED MODULE: ./src/lib/MODE.js

    const MODE = {
      INIT: 'Init',
      VIEW_WITHOUT_RELATION: 'View Term',
      VIEW_WITH_RELATION: 'View Instance',
      EDIT_DENOTATION_WITHOUT_RELATION: 'Term Centric',
      EDIT_DENOTATION_WITH_RELATION: 'Instance / Relation',
      EDIT_BLOCK_WITHOUT_RELATION: 'Block Centric',
      EDIT_BLOCK_WITH_RELATION: 'Block / Relation',
      EDIT_RELATION: 'Relation Edit'
    }

    // EXTERNAL MODULE: ./node_modules/emitter-fsm/index.js
    var emitter_fsm = __webpack_require__(4676)
    var emitter_fsm_default = /*#__PURE__*/ __webpack_require__.n(emitter_fsm) // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/StateMachine/toEnterEvent.js
    /* harmony default export */ function toEnterEvent(state) {
      return `enter:${state}`
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/StateMachine/bindTransition.js

    /* harmony default export */ function bindTransition(
      stateMachine,
      transition
    ) {
      stateMachine
        .on(toEnterEvent(MODE.EDIT_DENOTATION_WITHOUT_RELATION), () =>
          transition.toEditDenotationWithoutRelation()
        )
        .on(toEnterEvent(MODE.EDIT_DENOTATION_WITH_RELATION), () =>
          transition.toEditDenotationWithRelation()
        )
        .on(toEnterEvent(MODE.EDIT_BLOCK_WITHOUT_RELATION), () =>
          transition.toEditBlockWithoutRelation()
        )
        .on(toEnterEvent(MODE.EDIT_BLOCK_WITH_RELATION), () =>
          transition.toEditBlockWithRelation()
        )
        .on(toEnterEvent(MODE.EDIT_RELATION), () => transition.toEditRelation())
        .on(toEnterEvent(MODE.VIEW_WITHOUT_RELATION), () =>
          transition.toViewWithoutRelation()
        )
        .on(toEnterEvent(MODE.VIEW_WITH_RELATION), () =>
          transition.toViewWithRelation()
        )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/StateMachine/index.js

    class StateMachine {
      /**
       *
       * @param {import('../../../../AnnotationData/RelationModelContainer').default} relationContainer
       * @param {import('../Transition').default} transition
       */
      constructor(relationContainer, transition) {
        const m = new (emitter_fsm_default())({
          states: [
            MODE.INIT,
            MODE.EDIT_DENOTATION_WITHOUT_RELATION,
            MODE.EDIT_DENOTATION_WITH_RELATION,
            MODE.EDIT_BLOCK_WITHOUT_RELATION,
            MODE.EDIT_BLOCK_WITH_RELATION,
            MODE.EDIT_RELATION,
            MODE.VIEW_WITHOUT_RELATION,
            MODE.VIEW_WITH_RELATION
          ]
        })

        m.config(MODE.INIT, {
          to: {
            exclude: [MODE.EDIT_RELATION]
          }
        })

        m.config(MODE.EDIT_DENOTATION_WITHOUT_RELATION, {
          from: {
            exclude: [MODE.VIEW_WITH_RELATION]
          },
          to: {
            exclude: [MODE.INIT, MODE.VIEW_WITH_RELATION]
          }
        })

        m.config(MODE.EDIT_DENOTATION_WITH_RELATION, {
          from: {
            exclude: [MODE.VIEW_WITHOUT_RELATION]
          },
          to: {
            exclude: [MODE.INIT, MODE.VIEW_WITHOUT_RELATION]
          }
        })

        m.config(MODE.EDIT_BLOCK_WITHOUT_RELATION, {
          from: {
            exclude: [MODE.VIEW_WITH_RELATION]
          },
          to: {
            exclude: [MODE.INIT, MODE.VIEW_WITH_RELATION]
          }
        })

        m.config(MODE.EDIT_BLOCK_WITH_RELATION, {
          from: {
            exclude: [MODE.VIEW_WITHOUT_RELATION]
          },
          to: {
            exclude: [MODE.INIT, MODE.VIEW_WITHOUT_RELATION]
          }
        })

        m.config(MODE.EDIT_RELATION, {
          from: {
            exclude: [MODE.INIT]
          },
          to: {
            exclude: [MODE.INIT]
          }
        })

        m.config(MODE.VIEW_WITHOUT_RELATION, {
          from: {
            exclude: [MODE.EDIT_DENOTATION_WITH_RELATION]
          },
          to: {
            exclude: [MODE.INIT, MODE.EDIT_DENOTATION_WITH_RELATION]
          }
        })

        m.config(MODE.VIEW_WITH_RELATION, {
          from: {
            exclude: [MODE.EDIT_DENOTATION_WITHOUT_RELATION]
          },
          to: {
            exclude: [MODE.INIT, MODE.EDIT_DENOTATION_WITHOUT_RELATION]
          }
        })

        bindTransition(m, transition)

        this._m = m
        this._relationContainer = relationContainer
      }

      get currentState() {
        return this._m.currentState
      }

      setState(state) {
        this._m.setState(state)
      }

      toViewMode() {
        switch (this.currentState) {
          case MODE.EDIT_RELATION:
            if (this._relationContainer.some) {
              this.setState(MODE.VIEW_WITH_RELATION)
            } else {
              this.setState(MODE.VIEW_WITHOUT_RELATION)
            }
            break
          case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
          case MODE.EDIT_BLOCK_WITHOUT_RELATION:
            this.setState(MODE.VIEW_WITHOUT_RELATION)
            break
          case MODE.EDIT_DENOTATION_WITH_RELATION:
          case MODE.EDIT_BLOCK_WITH_RELATION:
            this.setState(MODE.VIEW_WITH_RELATION)
            break
          default:
          // Do nothig.
        }
      }

      toTermMode() {
        switch (this.currentState) {
          case MODE.EDIT_RELATION:
            if (this._relationContainer.some) {
              this.setState(MODE.EDIT_DENOTATION_WITH_RELATION)
            } else {
              this.setState(MODE.EDIT_DENOTATION_WITHOUT_RELATION)
            }
            break
          case MODE.VIEW_WITH_RELATION:
          case MODE.EDIT_BLOCK_WITH_RELATION:
            this.setState(MODE.EDIT_DENOTATION_WITH_RELATION)
            break
          case MODE.VIEW_WITHOUT_RELATION:
          case MODE.EDIT_BLOCK_WITHOUT_RELATION:
            this.setState(MODE.EDIT_DENOTATION_WITHOUT_RELATION)
            break
          default:
          // Do nothig.
        }
      }

      toBlockMode() {
        switch (this.currentState) {
          case MODE.EDIT_RELATION:
            if (this._relationContainer.some) {
              this.setState(MODE.EDIT_BLOCK_WITH_RELATION)
            } else {
              this.setState(MODE.EDIT_BLOCK_WITHOUT_RELATION)
            }
            break
          case MODE.VIEW_WITH_RELATION:
          case MODE.EDIT_DENOTATION_WITH_RELATION:
            this.setState(MODE.EDIT_BLOCK_WITH_RELATION)
            break
          case MODE.VIEW_WITHOUT_RELATION:
          case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
            this.setState(MODE.EDIT_BLOCK_WITHOUT_RELATION)
            break
          default:
          // Do nothig.
        }
      }

      toRelationMode() {
        this.setState(MODE.EDIT_RELATION)
      }

      toggleSimpleMode() {
        switch (this.currentState) {
          case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
            this.setState(MODE.EDIT_DENOTATION_WITH_RELATION)
            break
          case MODE.EDIT_BLOCK_WITHOUT_RELATION:
            this.setState(MODE.EDIT_BLOCK_WITH_RELATION)
            break
          case MODE.VIEW_WITHOUT_RELATION:
            this.setState(MODE.VIEW_WITH_RELATION)
            break
          case MODE.EDIT_DENOTATION_WITH_RELATION:
            this.setState(MODE.EDIT_DENOTATION_WITHOUT_RELATION)
            break
          case MODE.EDIT_BLOCK_WITH_RELATION:
            this.setState(MODE.EDIT_BLOCK_WITHOUT_RELATION)
            break
          case MODE.VIEW_WITH_RELATION:
            this.setState(MODE.VIEW_WITHOUT_RELATION)
            break
          default:
            throw new Error(`Invalid state: ${this.currentState}`)
        }
      }

      changeModeByShortcut() {
        switch (this.currentState) {
          case MODE.VIEW_WITH_RELATION:
            this.setState(MODE.EDIT_DENOTATION_WITH_RELATION)
            break
          case MODE.VIEW_WITHOUT_RELATION:
            this.setState(MODE.EDIT_DENOTATION_WITHOUT_RELATION)
            break
          case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
            this.setState(MODE.EDIT_BLOCK_WITHOUT_RELATION)
            break
          case MODE.EDIT_DENOTATION_WITH_RELATION:
            this.setState(MODE.EDIT_BLOCK_WITH_RELATION)
            break
          case MODE.EDIT_BLOCK_WITHOUT_RELATION:
          case MODE.EDIT_BLOCK_WITH_RELATION:
            this.setState(MODE.EDIT_RELATION)
            break
          case MODE.EDIT_RELATION:
            if (this._relationContainer.some) {
              this.setState(MODE.VIEW_WITH_RELATION)
            } else {
              this.setState(MODE.VIEW_WITHOUT_RELATION)
            }
            break
          default:
          // Do nothig.
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/clearTextSelection.js

    /* harmony default export */ function clearTextSelection() {
      window.getSelection().removeAllRanges()
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/isNodeDenotationSpan.js

    /* harmony default export */ function isNodeDenotationSpan(node) {
      return node.classList.contains('textae-editor__span')
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/isNodeTextBox.js

    /* harmony default export */ function isNodeTextBox(node) {
      return node.classList.contains('textae-editor__text-box')
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/isNodeStyleSpan.js

    /* harmony default export */ function isNodeStyleSpan(node) {
      return node.classList.contains('textae-editor__style')
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/isNodeBlockSpan.js

    /* harmony default export */ function isNodeBlockSpan(node) {
      return node.classList.contains('textae-editor__block')
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/PositionsOnAnnotation/getOffsetFromParent.js

    /* harmony default export */ function getOffsetFromParent(node) {
      let offset = 0

      for (const prevNode of node.parentElement.childNodes) {
        // until the focus node
        if (prevNode == node) {
          break
        }

        if (prevNode.nodeName === '#text') {
          offset += prevNode.nodeValue.length
        } else {
          offset += prevNode.textContent.length
        }
      }

      return offset
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/PositionsOnAnnotation/getParentOffset.js

    /* harmony default export */ function getParentOffset(span, node) {
      const parent = node.parentElement
      if (isNodeTextBox(parent)) {
        return 0
      }
      if (
        isNodeDenotationSpan(parent) ||
        isNodeBlockSpan(parent) ||
        isNodeStyleSpan(parent)
      ) {
        return span.get(parent.id).begin
      }
      throw new Error(`Can not get position of a node : ${node} ${node.data}`)
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/PositionsOnAnnotation/index.js

    class PositionsOnAnnotation {
      constructor(spanModelContainer, selectionWrapper) {
        this._spanModelContainer = spanModelContainer
        this._selection = selectionWrapper.selection
      }

      get anchor() {
        const position =
          getParentOffset(
            this._spanModelContainer,
            this._selection.anchorNode
          ) + getOffsetFromParent(this._selection.anchorNode)

        return position + this._selection.anchorOffset
      }

      get focus() {
        const position =
          getParentOffset(this._spanModelContainer, this._selection.focusNode) +
          getOffsetFromParent(this._selection.focusNode)

        return position + this._selection.focusOffset
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/SelectionWrapper/index.js

    class SelectionWrapper {
      constructor(spanModelContainer) {
        this.selection = window.getSelection()

        console.assert(
          this.parentOfAnchorNode.closest('.textae-editor__text-box') ===
            this.parentOfFocusNode.closest('.textae-editor__text-box'),
          'Text selection across editors is disabled'
        )

        this._spanModelContainer = spanModelContainer
      }

      get isParentOfAnchorNodeTextBox() {
        return isNodeTextBox(this.parentOfAnchorNode)
      }

      get isParentOfAnchorNodeDenotationSpan() {
        return isNodeDenotationSpan(this.parentOfAnchorNode)
      }

      get isParentOfAnchorNodeBlockSpan() {
        return isNodeBlockSpan(this.parentOfAnchorNode)
      }

      get isParentOfAnchorNodeStyleSpan() {
        return isNodeStyleSpan(this.parentOfAnchorNode)
      }

      get isParentOfFocusNodeTextBox() {
        return isNodeTextBox(this.parentOfFocusNode)
      }

      get isParentOfFocusNodeDenotationSpan() {
        return isNodeDenotationSpan(this.parentOfFocusNode)
      }

      get isParentOfFocusNodeBlockSpan() {
        return isNodeBlockSpan(this.parentOfFocusNode)
      }

      get isParentOfFocusNodeStyleSpan() {
        return isNodeStyleSpan(this.parentOfFocusNode)
      }

      get isParentOfBothNodesSame() {
        return this.parentOfAnchorNode === this.parentOfFocusNode
      }

      get isParentOfBothNodesTextBox() {
        return (
          this.isParentOfAnchorNodeTextBox && this.isParentOfFocusNodeTextBox
        )
      }

      get isParentsParentOfAnchorNodeAndFocusedNodeSame() {
        return (
          this.parentOfAnchorNode.parentElement ===
          this.parentOfFocusNode.parentElement
        )
      }

      get isAnchorNodeParentIsDescendantOfFocusNodeParent() {
        return this.parentOfAnchorNode.closest(`#${this.parentOfFocusNode.id}`)
      }

      get ancestorDenotationSpanOfAnchorNode() {
        return this.parentOfAnchorNode.closest('.textae-editor__span')
      }

      get ancestorDenotationSpanOfFocusNode() {
        return this.parentOfFocusNode.closest('.textae-editor__span')
      }

      get ancestorBlockSpanOfAnchorNode() {
        return this.parentOfAnchorNode.closest('.textae-editor__block')
      }

      get ancestorBlockSpanOfFocusNode() {
        return this.parentOfFocusNode.closest('.textae-editor__block')
      }

      get doesFitInOneBlockSpan() {
        return (
          this.ancestorBlockSpanOfAnchorNode ===
          this.ancestorBlockSpanOfFocusNode
        )
      }

      get parentOfAnchorNode() {
        return this.selection.anchorNode.parentElement
      }

      get parentOfFocusNode() {
        return this.selection.focusNode.parentElement
      }

      get positionsOnAnnotation() {
        return new PositionsOnAnnotation(this._spanModelContainer, this)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/selectSpan.js

    /* harmony default export */ function selectSpan(
      selectionModel,
      rangeOfSpans,
      event,
      spanID
    ) {
      if (rangeOfSpans.length) {
        selectionModel.selectSpanRange(rangeOfSpans)
        return
      }

      if (event.ctrlKey || event.metaKey) {
        selectionModel.span.toggle(spanID)
        return
      }

      selectionModel.selectSpan(spanID)
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/isRangeInTextBox.js

    /* harmony default export */ function isRangeInTextBox(
      selection,
      textBoxHTMLElement
    ) {
      return (
        selection.type === 'Range' &&
        textBoxHTMLElement.contains(selection.anchorNode) &&
        textBoxHTMLElement.contains(selection.focusNode)
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/MouseEventHandler.js

    class MouseEventHandler {
      constructor(
        editorHTMLElement,
        annotationData,
        selectionModel,
        pallet,
        spanEditor
      ) {
        this._annotationData = annotationData
        this._selectionModel = selectionModel
        this._spanEditor = spanEditor
        this._editorHTMLElement = editorHTMLElement
        this._pallet = pallet
      }

      bodyClicked() {
        this._pallet.hide()
        this._selectionModel.removeAll()
      }

      textBoxClicked() {
        this._pallet.hide()

        const selection = window.getSelection()

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
        } else {
          this._selectionModel.removeAll()
        }
      }

      denotationSpanClicked(event) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (event.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        // When you create a denotation span and
        // click on another denotation span while holding down the Shift key,
        // the Selection type will be 'None'.
        if (selection.type === 'Caret' || selection.type === 'None') {
          this._selectSpan(event, event.target.id)
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
        }
      }

      blockSpanClicked(e) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (e.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
        }
      }

      styleSpanClicked(e) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (e.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          const span = e.target.closest('.textae-editor__span')
          if (span) {
            this._selectSpan(e, span.id)
          } else {
            this._selectionModel.removeAll()
          }
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
        }
      }

      signboardClicked() {
        this._editorHTMLElement.focus()
      }

      typeValuesClicked(event, entityID) {
        if (this._annotationData.entity.get(entityID).isDenotation) {
          if (event.ctrlKey || event.metaKey) {
            this._selectionModel.entity.toggle(entityID)
          } else {
            this._selectionModel.selectEntity(entityID)
          }
        }
      }

      _selectSpan(event, spanID) {
        const selectedSpanID = this._selectionModel.span.singleId
        const rangeOfSpans =
          event.shiftKey && selectedSpanID
            ? this._annotationData.span.rangeDenotationSpan(
                selectedSpanID,
                spanID
              )
            : []

        selectSpan(this._selectionModel, rangeOfSpans, event, spanID)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/SpanEditor/create/createCommand.js

    /* harmony default export */ function createCommand(
      commander,
      newSpan,
      isReplicateAuto,
      isDelimiterFunc
    ) {
      return commander.factory.createSpanAndAutoReplicateCommand(
        {
          begin: newSpan.begin,
          end: newSpan.end
        },
        isReplicateAuto,
        isDelimiterFunc
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/OrderedPositions.js

    class OrderedPositions {
      constructor(positions) {
        this._positions = positions
      }

      // switch the position when the selection is made from right to left
      get begin() {
        if (this._positions.anchor < this._positions.focus) {
          return this._positions.anchor
        }

        return this._positions.focus
      }

      // switch the position when the selection is made from right to left
      get end() {
        if (this._positions.anchor < this._positions.focus) {
          return this._positions.focus
        }

        return this._positions.anchor
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/getNewSpan.js

    /* harmony default export */ function getNewSpan(
      sourceDoc,
      spanAdjuster,
      selectionWrapper,
      spanConfig
    ) {
      const { positionsOnAnnotation } = selectionWrapper
      const orderedPositions = new OrderedPositions(positionsOnAnnotation)

      return {
        begin: spanAdjuster.backFromBegin(
          sourceDoc,
          orderedPositions.begin,
          spanConfig
        ),
        end:
          spanAdjuster.forwardFromEnd(
            sourceDoc,
            orderedPositions.end - 1,
            spanConfig
          ) + 1
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/SpanEditor/validateNewDennotationSpan.js

    /**
     *
     * @param {import('../../../../../AnnotationData/SpanModelContainer').default} spanModelContainer
     * @returns
     */
    /* harmony default export */ function validateNewDennotationSpan(
      spanModelContainer,
      begin,
      end
    ) {
      // The span cross exists spans.
      if (spanModelContainer.isBoundaryCrossingWithOtherSpans(begin, end)) {
        alertify_default().warning(
          'A span cannot be modifyed to make a boundary crossing.'
        )
        return false
      }

      // The span exists already.
      if (spanModelContainer.hasDenotationSpan(begin, end)) {
        return false
      }

      // There is a BlockSpan that is a child.
      if (spanModelContainer.hasBlockSpanBetween(begin, end)) {
        return false
      }

      return true
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/SpanEditor/create/index.js

    /* harmony default export */ function create(
      sourceDoc,
      spanModelContainer,
      commander,
      spanAdjuster,
      isReplicateAuto,
      selectionWrapper,
      spanConfig,
      isDelimiterFunc
    ) {
      const { begin, end } = getNewSpan(
        sourceDoc,
        spanAdjuster,
        selectionWrapper,
        spanConfig
      )

      if (validateNewDennotationSpan(spanModelContainer, begin, end)) {
        const command = createCommand(
          commander,
          { begin, end },
          isReplicateAuto,
          isDelimiterFunc
        )

        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/shrinkSpan/shrinkSpanToSelection.js

    /**
     *
     * @param {import('../../../../AnnotationData/SpanModelContainer').default} spanModelContainer
     */
    /* harmony default export */ function shrinkSpanToSelection(
      spanModelContainer,
      sourceDoc,
      commander,
      spanAdjuster,
      spanId,
      selectionWrapper,
      spanConfig,
      moveHandler
    ) {
      const { begin, end } = spanModelContainer
        .get(spanId)
        .getShotrenInAnchorNodeToFocusNodeDirection(
          spanAdjuster,
          selectionWrapper,
          sourceDoc,
          spanConfig
        )

      // The span cross exists spans.
      if (spanModelContainer.isBoundaryCrossingWithOtherSpans(begin, end)) {
        alertify_default().warning(
          'A span cannot be shrinked to make a boundary crossing.'
        )
        return false
      }

      const doesExists = spanModelContainer.hasDenotationSpan(begin, end)

      if (begin < end && !doesExists) {
        moveHandler(begin, end)
      } else {
        commander.invoke(commander.factory.removeSpanCommand(spanId))
        return true
      }

      return false
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/shrinkSpan/index.js

    /* harmony default export */ function shrinkSpan(
      editorHTMLElement,
      spanModelContainer,
      sourceDoc,
      selectionModel,
      commander,
      spanAdjuster,
      spanId,
      selectionWrapper,
      spanConfig,
      moveHandler
    ) {
      if (spanId) {
        selectionModel.removeAll()

        // Get the next span before removing the old span.
        const nextSpan = getRightSpanElement(editorHTMLElement, spanId)
        const removed = shrinkSpanToSelection(
          spanModelContainer,
          sourceDoc,
          commander,
          spanAdjuster,
          spanId,
          selectionWrapper,
          spanConfig,
          moveHandler
        )

        if (removed && nextSpan) {
          selectionModel.selectSpan(nextSpan.id)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/hasCharacters.js

    // A span cannot be created include nonEdgeCharacters only.
    /* harmony default export */ function hasCharacters(
      sourceDoc,
      spanConfig,
      selectionWrapper
    ) {
      const { positionsOnAnnotation } = selectionWrapper
      const orderedPositions = new OrderedPositions(positionsOnAnnotation)
      const selectedString = sourceDoc.substring(
        orderedPositions.begin,
        orderedPositions.end
      )

      return spanConfig.removeBlankChractors(selectedString).length > 0
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/getIsDelimiterFunc.js

    /* harmony default export */ function getIsDelimiterFunc(
      buttonController,
      spanConfig
    ) {
      if (buttonController.isPushed('boundary-detection')) {
        return (char) => spanConfig.isDelimiter(char)
      } else {
        return () => true
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/SpanEditor/isPositionBetweenSpan.js

    /* harmony default export */ function isPositionBetweenSpan(
      span,
      position
    ) {
      if (!span) {
        return false
      }

      return span.begin < position && position < span.end
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/SpanEditor/index.js

    class SpanEditor {
      constructor(
        editorHTMLElemnt,
        annotationData,
        selectionModel,
        commander,
        buttonController,
        spanConfig
      ) {
        this._editorHTMLElement = editorHTMLElemnt
        this._annotationData = annotationData
        this._spanModelContainer = annotationData.span
        this._selectionModel = selectionModel
        this._commander = commander
        this._buttonController = buttonController
        this._spanConfig = spanConfig
      }

      editFor(selectionWrapper) {
        if (selectionWrapper.isParentOfAnchorNodeTextBox) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInTextBoxFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInTextBoxFocusNodeInDenotationSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInTextBoxFocusNodeInBlockSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInTextBoxFocusNodeInStyleSpan(selectionWrapper)
            return
          }
        }
        if (selectionWrapper.isParentOfAnchorNodeDenotationSpan) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInDenotationSpanFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInDenotationSpanFocusNodeInDenotationSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInDenotationSpanFocusNodeInBlockSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInDenotationSpanFocusNodeInStyleSpan(
              selectionWrapper
            )
            return
          }
        }
        if (selectionWrapper.isParentOfAnchorNodeBlockSpan) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInBlockSpanFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInBlockSpanFocusNodeInDenotationSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInBlockSpanFocusNodeInBlockSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInBlockSpanFocusNodeInStyleSpan(selectionWrapper)
            return
          }
        }
        if (selectionWrapper.isParentOfAnchorNodeStyleSpan) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInStyleSpanFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInStyleSpanFocusNodeInDenotationSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInStyleSpanFocusNodeInBlockSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInStyleSpanFocusNodeInStyleSpan(selectionWrapper)
            return
          }
        }
      }

      cerateSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._spanModelContainer)

        if (selectionWrapper.isParentOfBothNodesSame) {
          this._create(selectionWrapper)
        }
      }

      expandForTouchDevice() {
        const expandedSpan = this._getExpandedSpanForTouchDevice()
        if (expandedSpan) {
          const { spanID, begin, end } = expandedSpan

          // The span cross exists spans.
          if (
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )
          ) {
            return
          }

          // A span cannot be expanded a span to the same as an existing span.
          if (this._spanModelContainer.hasDenotationSpan(begin, end)) {
            return
          }

          this._commander.invoke(
            this._commander.factory.moveDenotationSpanCommand(
              spanID,
              begin,
              end
            )
          )
        }
      }

      shrinkForTouchDevice() {
        const shrinkedSpan = this._getShrinkedSpanForTouchDevice()
        if (shrinkedSpan) {
          const { spanID, begin, end } = shrinkedSpan
          const nextSpan = getRightSpanElement(this._editorHTMLElement, spanID)

          // The span cross exists spans.
          if (
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )
          ) {
            alertify_default().warning(
              'A span cannot be shrinked to make a boundary crossing.'
            )
            return
          }

          const doesExists = this._spanModelContainer.hasDenotationSpan(
            begin,
            end
          )
          if (begin < end && !doesExists) {
            this._commander.invoke(
              this._commander.factory.moveDenotationSpanCommand(
                spanID,
                begin,
                end
              )
            )
          } else {
            this._commander.invoke(
              this._commander.factory.removeSpanCommand(spanID)
            )
            if (nextSpan) {
              this._selectionModel.selectSpan(nextSpan.id)
            }
          }
        }
      }

      _getExpandedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._spanModelContainer)

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to expand does not exist.
        if (
          selectionWrapper.ancestorDenotationSpanOfAnchorNode == null &&
          selectionWrapper.ancestorDenotationSpanOfFocusNode == null
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfAnchorNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getExpandedInAnchorNodeToFocusNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfFocusNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getExpandedInFocusNodeToAnchorNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }
      }

      _getShrinkedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._spanModelContainer)

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to shrink does not exist.
        if (
          selectionWrapper.ancestorDenotationSpanOfAnchorNode == null &&
          selectionWrapper.ancestorDenotationSpanOfFocusNode == null
        ) {
          return null
        }

        // On mobile devices,
        // do not shrink the denotation span when the selected text fits into one denotation span.
        if (
          selectionWrapper.parentOfAnchorNode ===
          selectionWrapper.parentOfFocusNode
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfAnchorNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getShortenInFocusNodeToAnchorNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfFocusNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getShotrenInAnchorNodeToFocusNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }
      }

      _anchorNodeInTextBoxFocusNodeInTextBox(selectionWrapper) {
        // The parent of the focusNode is the text.
        this._create(selectionWrapper)
      }

      _anchorNodeInTextBoxFocusNodeInDenotationSpan(selectionWrapper) {
        const targetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (targetSpanID) {
          this._shrink(selectionWrapper, targetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInTextBoxFocusNodeInBlockSpan() {
        clearTextSelection()
      }

      _anchorNodeInTextBoxFocusNodeInStyleSpan(selectionWrapper) {
        // There is a Span between the StyleSpan and the text.
        // Shrink Span when mousedown on the text or a span and mouseup on the styleSpan.
        const targetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (targetSpanID) {
          this._shrink(selectionWrapper, targetSpanID)
          return
        }

        this._create(selectionWrapper)
      }

      _anchorNodeInDenotationSpanFocusNodeInTextBox(selectionWrapper) {
        this._expand(selectionWrapper, selectionWrapper.parentOfAnchorNode.id)
      }

      _anchorNodeInDenotationSpanFocusNodeInDenotationSpan(selectionWrapper) {
        const shrinkableEndSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkableEndSpanID) {
          this._shrink(selectionWrapper, shrinkableEndSpanID)
          return
        }

        // The anchor node and the focus node are in the same span.
        if (selectionWrapper.isParentOfBothNodesSame) {
          this._create(selectionWrapper)
          return
        }

        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        // Mouse down on the child DenotationSpan
        // and mouse up on the sibling DenotationSpan of the parent DenotationSpan
        // to expand the the child DenotationSpan.
        // The condition for this is that the ancestor of the anchor node
        // and the ancestor of the focus node are the same.
        // Since this is always true, it will always expand when it is neither create nor shrink.
        this._expand(selectionWrapper, selectionWrapper.parentOfAnchorNode.id)
      }

      _anchorNodeInDenotationSpanFocusNodeInBlockSpan(selectionWrapper) {
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          this._expand(selectionWrapper, selectionWrapper.parentOfAnchorNode.id)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInDenotationSpanFocusNodeInStyleSpan(selectionWrapper) {
        const shrinkTargetEndSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkTargetEndSpanID) {
          this._shrink(selectionWrapper, shrinkTargetEndSpanID)
          return
        }

        if (
          selectionWrapper.parentOfAnchorNode ===
          selectionWrapper.ancestorDenotationSpanOfFocusNode
        ) {
          this._create(selectionWrapper)
          return
        }

        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }
      }

      _anchorNodeInBlockSpanFocusNodeInTextBox() {
        clearTextSelection()
      }

      _anchorNodeInBlockSpanFocusNodeInDenotationSpan(selectionWrapper) {
        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInBlockSpanFocusNodeInBlockSpan(selectionWrapper) {
        this._create(selectionWrapper)
      }

      _anchorNodeInBlockSpanFocusNodeInStyleSpan(selectionWrapper) {
        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInStyleSpanFocusNodeInTextBox(selectionWrapper) {
        // If the anchor node is a style span but has a parent span, extend the parent span.
        if (selectionWrapper.ancestorDenotationSpanOfAnchorNode) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfAnchorNode.id

          if (spanID) {
            this._expand(selectionWrapper, spanID)
          }
          return
        }

        this._create(selectionWrapper)
      }

      _anchorNodeInStyleSpanFocusNodeInDenotationSpan(selectionWrapper) {
        const shrinkTargetEndSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkTargetEndSpanID) {
          this._shrink(selectionWrapper, shrinkTargetEndSpanID)
          return
        }

        if (
          selectionWrapper.ancestorDenotationSpanOfAnchorNode ===
          selectionWrapper.parentOfFocusNode
        ) {
          this._create(selectionWrapper)
          return
        }

        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInStyleSpanFocusNodeInBlockSpan(selectionWrapper) {
        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        this._create(selectionWrapper)
      }

      _anchorNodeInStyleSpanFocusNodeInStyleSpan(selectionWrapper) {
        const shrinkTargetSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        if (
          selectionWrapper.isParentOfBothNodesSame ||
          selectionWrapper.isParentsParentOfAnchorNodeAndFocusedNodeSame
        ) {
          this._create(selectionWrapper)
          return
        }

        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _getShrinkableEndSpanID(selectionWrapper) {
        if (selectionWrapper.ancestorDenotationSpanOfAnchorNode) {
          const { anchor } = selectionWrapper.positionsOnAnnotation

          const { begin, end } = this._spanModelContainer.getDenotationSpan(
            selectionWrapper.ancestorDenotationSpanOfAnchorNode.id
          )
          if (anchor === begin || anchor === end) {
            // Shrink the span of the ends.
            if (
              selectionWrapper.ancestorDenotationSpanOfAnchorNode ===
              selectionWrapper.ancestorDenotationSpanOfFocusNode
            ) {
              return selectionWrapper.ancestorDenotationSpanOfAnchorNode.id
            }

            // Shrink the parent of the parent-child span at the end.
            if (
              selectionWrapper.ancestorDenotationSpanOfAnchorNode !==
                selectionWrapper.ancestorDenotationSpanOfFocusNode &&
              selectionWrapper.ancestorDenotationSpanOfFocusNode.contains(
                selectionWrapper.ancestorDenotationSpanOfAnchorNode
              )
            ) {
              return selectionWrapper.ancestorDenotationSpanOfFocusNode.id
            }
          }
        }
      }

      _getShrinkableSpanID(selectionWrapper) {
        const targetSpanElement =
          selectionWrapper.ancestorDenotationSpanOfFocusNode

        if (targetSpanElement) {
          if (
            selectionWrapper.ancestorDenotationSpanOfAnchorNode !==
              targetSpanElement &&
            (!selectionWrapper.ancestorDenotationSpanOfAnchorNode ||
              selectionWrapper.ancestorDenotationSpanOfAnchorNode.contains(
                targetSpanElement
              ))
          ) {
            return targetSpanElement.id
          }
        }

        // If the parent of the anchor node is a descendant of the focus node,
        // and the focus node is selected, shrink the focus node.
        if (selectionWrapper.isAnchorNodeParentIsDescendantOfFocusNodeParent) {
          if (
            isPositionBetweenSpan(
              this._selectionModel.span.single,
              selectionWrapper.positionsOnAnnotation.focus
            )
          ) {
            return this._selectionModel.span.single.element.id
          }
        }
      }

      _getExpandableSpanID(selectionWrapper) {
        const targetSpanElement =
          selectionWrapper.ancestorDenotationSpanOfAnchorNode

        if (targetSpanElement) {
          const { ancestorDenotationSpanOfFocusNode } = selectionWrapper

          if (ancestorDenotationSpanOfFocusNode) {
            if (
              targetSpanElement !== ancestorDenotationSpanOfFocusNode &&
              (targetSpanElement.parentElement ===
                ancestorDenotationSpanOfFocusNode.parentElement ||
                ancestorDenotationSpanOfFocusNode.contains(targetSpanElement))
            ) {
              return targetSpanElement.id
            }
          } else {
            return targetSpanElement.id
          }
        }
      }

      _create(selectionWrapper) {
        if (
          hasCharacters(
            this._annotationData.sourceDoc,
            this._spanConfig,
            selectionWrapper
          )
        ) {
          this._selectionModel.removeAll()
          create(
            this._annotationData.sourceDoc,
            this._spanModelContainer,
            this._commander,
            this._buttonController.spanAdjuster,
            this._isReplicateAuto,
            selectionWrapper,
            this._spanConfig,
            getIsDelimiterFunc(this._buttonController, this._spanConfig)
          )
        }
        clearTextSelection()
      }

      _expand(selectionWrapper, spanID) {
        this._selectionModel.removeAll()

        const { begin, end } = this._spanModelContainer
          .get(spanID)
          .getExpandedInAnchorNodeToFocusNodeDirection(
            this._buttonController.spanAdjuster,
            selectionWrapper,
            this._annotationData.sourceDoc,
            this._spanConfig
          )

        if (validateNewDennotationSpan(this._spanModelContainer, begin, end)) {
          this._commander.invoke(
            this._commander.factory.moveDenotationSpanCommand(
              spanID,
              begin,
              end
            )
          )
        }

        clearTextSelection()
      }

      _shrink(selectionWrapper, spanID) {
        shrinkSpan(
          this._editorHTMLElement,
          this._spanModelContainer,
          this._annotationData.sourceDoc,
          this._selectionModel,
          this._commander,
          this._buttonController.spanAdjuster,
          spanID,
          selectionWrapper,
          this._spanConfig,
          (begin, end) => {
            this._commander.invoke(
              this._commander.factory.moveDenotationSpanCommand(
                spanID,
                begin,
                end
              )
            )
          }
        )

        clearTextSelection()
      }

      get _isReplicateAuto() {
        return this._buttonController.isPushed('replicate-auto')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/forwardMethods.js

    /* harmony default export */ function forwardMethods(
      delegator,
      getTargetFunction,
      methods
    ) {
      for (const method of methods) {
        delegator[method] = (...args) => {
          const target = getTargetFunction()
          console.assert(
            target[method],
            `No ${method} method to forward`,
            target
          )

          return target[method].apply(target, args)
        }
      }

      return delegator
    } // CONCATENATED MODULE: ./src/lib/component/PromiseDialog.js

    class PromiseDialog extends Dialog {
      constructor(title, contentHtml, option, getResultsFunc) {
        const onOKButtonClick = () => {
          const results = getResultsFunc()
          if (results) {
            this.resolveFunc(results)
          }
          super.close()
        }
        const okButton = {
          text: 'OK',
          click: onOKButtonClick
        }
        option.buttons = option.buttons
          ? option.buttons.concat([okButton])
          : [okButton]

        super(title, contentHtml, option)

        delegate_default()(
          super.el,
          '.textae-editor__promise-daialog__observable-element',
          'keyup',
          (e) => {
            if (e.keyCode === 13) {
              onOKButtonClick()
            }
          }
        )
      }

      open() {
        super.open()
        return new Promise((resolveFunc) => (this.resolveFunc = resolveFunc))
      }
    }

    // EXTERNAL MODULE: ./node_modules/jquery-ui/ui/widgets/autocomplete.js
    var autocomplete = __webpack_require__(2993) // CONCATENATED MODULE: ./src/lib/component/customize-jquery-ui-autocomplete.js
    /* eslint no-underscore-dangle: 0 */
    // Custumize jQuery-ui autocomplete
    /* harmony default export */ function customize_jquery_ui_autocomplete() {
      // Repalce @ to font awesome icon
      jquery_default().ui.autocomplete.prototype._renderItem = (
        $ul,
        { id, label }
      ) => {
        const $li = jquery_default()(eskape_default()`
      <li>
        <div>
          ${label} 
          <i class="fa fa-globe"></i>
          ${id}
        </div>
      </li>`)

        $ul.append($li)

        return $li
      }
      jquery_default().ui.autocomplete.prototype._resizeMenu = () => {
        // Prepend resize menu
      }
    } // CONCATENATED MODULE: ./src/lib/component/searchTerm.js

    /* harmony default export */ function searchTerm(
      autocompletionWs,
      localData,
      term,
      done
    ) {
      if (!autocompletionWs) {
        done(localData)
        return
      }

      const request = new XMLHttpRequest()

      // Append a term parameter.
      const url = new URL(autocompletionWs, location)
      url.searchParams.append('term', term)

      request.open('GET', url.href, true)
      request.onload = () => {
        if (request.status >= 200 && request.status < 400) {
          // Success!
          const data = JSON.parse(request.response)

          // Prior lacal data if duplicated
          const filtteredData = data.filter(
            (t) => !localData.some((l) => t.id === l.id)
          )

          done(localData.concat(filtteredData))
        }
      }

      request.send()
    } // CONCATENATED MODULE: ./src/lib/component/TypeDefinitionDialog/select.js

    /* harmony default export */ function TypeDefinitionDialog_select(
      inputId,
      inputLabel,
      { item }
    ) {
      inputId.value = item.id
      inputLabel.value = item.label
      return false
    } // CONCATENATED MODULE: ./src/lib/component/TypeDefinitionDialog/setSourceOfAutoComplete.js

    customize_jquery_ui_autocomplete()

    /* harmony default export */ function setSourceOfAutoComplete(
      el,
      autocompletionWs,
      getLocalData
    ) {
      const inputs = el.querySelectorAll('input')

      // Update the source
      jquery_default()(inputs[0]).autocomplete({
        source: (request, response) =>
          searchTerm(
            autocompletionWs,
            getLocalData(request.term),
            request.term,
            response
          ),
        minLength: 3,
        select: (_, ui) => TypeDefinitionDialog_select(inputs[0], inputs[1], ui)
      })

      jquery_default()(inputs[1]).autocomplete({
        source: (request, response) =>
          searchTerm(
            autocompletionWs,
            getLocalData(request.term),
            request.term,
            response
          ),
        minLength: 3,
        select: (_, ui) => TypeDefinitionDialog_select(inputs[0], inputs[1], ui)
      })
    } // CONCATENATED MODULE: ./src/lib/component/TypeDefinitionDialog/index.js

    function template(context) {
      const { id, label, color, isDefault } = context
      return eskape_default()`
<div class="textae-editor__type-definition-dialog__container">
  <div class="textae-editor__type-definition-dialog__row ui-front">
    <label>Id</label>
    <input
      class="textae-editor__type-definition-dialog--id textae-editor__promise-daialog__observable-element" 
      value="${id || ''}">
  </div>
  <div class="textae-editor__type-definition-dialog__row ui-front">
    <label>Label<span></span></label>
    <input value="${label}">
  </div>
  <div class="textae-editor__type-definition-dialog__color-picker">
    <label><input 
      class="textae-editor__type-definition-dialog__color-picker__input" 
      type="color" 
      value="${color}">
    Color</label>
  </div>
  <div class="textae-editor__type-definition-dialog__set-default">
    <label><input 
      class="textae-editor__type-definition-dialog__set-default__input" 
      type="checkbox" ${
        isDefault ? 'checked="checked" disabled="disabled"' : ''
      }>
    Default type</label>
  </div>
</div>`
    }

    class TypeDefinitionDialog extends PromiseDialog {
      constructor(
        title,
        content,
        definitionContainer,
        autocompletionWs,
        convertToReseltsFunc
      ) {
        super(title, template(content), {}, () => {
          const inputs = super.el.querySelectorAll('input')
          return convertToReseltsFunc(
            inputs[0].value,
            inputs[1].value,
            inputs[2].value,
            inputs[3].checked
          )
        })

        setSourceOfAutoComplete(super.el, autocompletionWs, (term) =>
          definitionContainer.findByLabel(term)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/component/CreateTypeDefinitionDialog.js

    class CreateTypeDefinitionDialog extends TypeDefinitionDialog {
      constructor(definitionContainer, autocompletionWs) {
        const convertToReseltsFunc = (
          newId,
          newLabel,
          newColor,
          newDefault
        ) => {
          if (newId === '') {
            return
          }

          const newType = {
            id: newId,
            color: newColor
          }

          if (newLabel !== '') {
            newType.label = newLabel
          }

          if (newDefault) {
            newType.default = newDefault
          }

          return { newType }
        }

        super(
          'New type',
          {
            id: null,
            label: '',
            color: definitionContainer.defaultColor,
            isDefault: false
          },
          definitionContainer,
          autocompletionWs,
          convertToReseltsFunc
        )
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeDefinitionDialog/getDifference.js

    /* harmony default export */ function getDifference(before, after) {
      const changedProperties = new Map()

      if (before.id !== after.id) {
        changedProperties.set('id', after.id)
      }

      if (before.label !== after.label) {
        changedProperties.set('label', after.label === '' ? null : after.label)
      }

      if (before.color !== after.color) {
        changedProperties.set('color', after.color === '' ? null : after.color)
      }

      if (before.isDefault !== after.isDefault) {
        changedProperties.set('default', after.isDefault ? true : null)
      }

      return changedProperties
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeDefinitionDialog/index.js

    class EditTypeDefinitionDialog extends TypeDefinitionDialog {
      constructor(definitionContainer, id, color, isDefault, autocompletionWs) {
        const label = definitionContainer.getLabel(id) || ''

        const beforeChange = {
          id,
          label,
          color,
          isDefault
        }

        const convertToReseltsFunc = (
          newId,
          newLabel,
          newColor,
          newDefault
        ) => {
          const afterChange = {
            id: newId,
            label: newLabel,
            color: newColor,
            isDefault: newDefault
          }

          const changedProperties = getDifference(beforeChange, afterChange)

          return {
            id,
            changedProperties
          }
        }

        super(
          'Edit type',
          beforeChange,
          definitionContainer,
          autocompletionWs,
          convertToReseltsFunc
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/Edit/bindPalletEvents/checkButtonEnable.js

    /* harmony default export */ function checkButtonEnable(targetNode) {
      return !targetNode.classList.contains(
        'textae-editor__pallet__table-button--disabled'
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/Edit/bindPalletEvents/index.js

    /* harmony default export */ function bindPalletEvents(
      pallet,
      commander,
      getAutocompletionWs,
      definitionContainer,
      annotationType,
      selectionModel,
      annotationData
    ) {
      delegate_default()(
        pallet.el,
        `.textae-editor__pallet__add-button`,
        'click',
        () => {
          new CreateTypeDefinitionDialog(
            definitionContainer,
            getAutocompletionWs()
          )
            .open()
            .then(({ newType }) =>
              commander.invoke(
                commander.factory.createTypeDefinitionCommand(
                  definitionContainer,
                  newType
                )
              )
            )
        }
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__label',
        'click',
        (e) =>
          commander.invoke(
            commander.factory.changeTypeOfSelectedItemsCommand(
              annotationType,
              e.delegateTarget.dataset.id
            )
          )
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__select-all',
        'click',
        (e) => {
          if (!checkButtonEnable(e.target)) {
            return
          }

          selectionModel.removeAll()
          for (const { id } of annotationData[annotationType].findByType(
            e.delegateTarget.dataset.id
          )) {
            selectionModel[annotationType].add(id)
          }
        }
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__edit-type',
        'click',
        (e) => {
          new EditTypeDefinitionDialog(
            definitionContainer,
            e.target.dataset.id,
            e.target.dataset.color.toLowerCase(),
            e.target.dataset.isDefault === 'true',
            getAutocompletionWs()
          )
            .open()
            .then(({ id, changedProperties }) => {
              if (changedProperties.size) {
                commander.invoke(
                  commander.factory.changeTypeDefinitionCommand(
                    definitionContainer,
                    annotationType,
                    id,
                    changedProperties
                  )
                )
              }
            })
        }
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__remove',
        'click',
        (e) => {
          if (!checkButtonEnable(e.target)) {
            return
          }
          const { id } = e.delegateTarget.dataset
          const { label } = e.delegateTarget.dataset

          const removeType = {
            id,
            label: label || ''
          }

          if (typeof id === 'undefined') {
            throw new Error('You must set the type id to remove.')
          }

          commander.invoke(
            commander.factory.removeTypeDefinitionCommand(
              definitionContainer,
              removeType
            )
          )
        }
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/Edit/index.js

    class Edit {
      constructor(
        editorHTMLElement,
        selectionModel,
        annotationData,
        pallet,
        commander,
        getAutocompletionWs,
        definitionContainer,
        annotationType
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
        this._annotationData = annotationData
        this._getAutocompletionWs = getAutocompletionWs
        this._definitionContainer = definitionContainer
        this._commander = commander

        this._pallet = pallet

        bindPalletEvents(
          pallet,
          commander,
          getAutocompletionWs,
          definitionContainer,
          annotationType,
          selectionModel,
          annotationData
        )

        editorHTMLElement.appendChild(pallet.el)

        forwardMethods(this, () => pallet, [
          'showPallet',
          'selectLeftAttributeTab',
          'selectRightAttributeTab'
        ])
      }

      get pallet() {
        return this._pallet
      }

      // Dummy funcitions
      createSpan() {}
      expandSpan() {}
      shrinkSpan() {}
      relationClicked() {}
      typeValuesClicked() {}

      manipulateAttribute(number, shiftKey) {
        if (shiftKey) {
          this._attributeEditor.deleteAt(number)
        } else {
          this._attributeEditor.addOrEditAt(number)
        }
      }

      _typeValuesChanged({ typeName, label, attributes = [] }) {
        const commands = this._commander.factory.changeTypeValuesCommand(
          label,
          typeName,
          this._definitionContainer,
          attributes
        )

        if (typeName) {
          this._commander.invoke(commands)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/getEntityHTMLelementFromChild.js

    /* harmony default export */ function getEntityHTMLelementFromChild(
      elementInEntityHtmlelement
    ) {
      return elementInEntityHtmlelement.closest('.textae-editor__signboard')
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/bindMouseEvents.js

    // For support context menu.
    // Mouse up event occurs when either left or right button is clicked.
    // Change mouse events to monitor from mouseup to click since v5.0.0.
    /* harmony default export */ function bindMouseEvents(
      editorHTMLElement,
      mouseEventHandler
    ) {
      const listeners = []

      // In Friefox, the text box click event fires when you shrink and erase a span.
      // To do this, the span mouse-up event selects the span to the right of the erased span,
      // and then the text box click event deselects it.
      // To prevent this, we set a flag to indicate that it is immediately after the span's mouse-up event.
      let afterSpanMouseUpEventFlag = false

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__text-box',
          'click',
          (e) => {
            if (
              e.target.classList.contains('textae-editor__text-box') &&
              !afterSpanMouseUpEventFlag
            ) {
              mouseEventHandler.textBoxClicked()
            }
          }
        )
      )

      // When extending span, the behavior depends on whether span is selected or not;
      // you must not deselect span before editing it.
      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor',
          'click',
          (e) => {
            // The delegate also fires events for child elements of the selector.
            // Ignores events that occur in child elements.
            // Otherwise, you cannot select child elements.
            if (e.target.classList.contains('textae-editor')) {
              mouseEventHandler.bodyClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard',
          'mousedown',
          () => mouseEventHandler.signboardClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard__type-values',
          'click',
          (event) => {
            const entityID = getEntityHTMLelementFromChild(event.target).dataset
              .id
            mouseEventHandler.typeValuesClicked(event, entityID)
          }
        )
      )

      // To shrink a span listen the mouseup event.
      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__span',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__span')) {
              mouseEventHandler.denotationSpanClicked(e)
              afterSpanMouseUpEventFlag = true

              // In Chrome, the text box click event does not fire when you shrink the span and erase it.
              // Instead of beating the flag on the text box click event,
              // it uses a timer to beat the flag instantly, faster than any user action.
              setTimeout(() => (afterSpanMouseUpEventFlag = false), 0)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__block',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__block')) {
              mouseEventHandler.blockSpanClicked(e)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__style',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__style')) {
              mouseEventHandler.styleSpanClicked(e)
            }
          }
        )
      )

      return listeners
    }

    // EXTERNAL MODULE: ./node_modules/jquery-ui/ui/widgets/draggable.js
    var draggable = __webpack_require__(7285) // CONCATENATED MODULE: ./src/lib/component/Pallet/enableJqueryDraggable.js
    /* harmony default export */ function enableJqueryDraggable(
      element,
      editorHTMLElement
    ) {
      jquery_default()(element).draggable({
        containment: editorHTMLElement,
        distance: 10
      })
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/getMousePoint.js

    // Ovserve and record mouse position to return it.
    const lastMousePoint = {}

    document.querySelector('html').addEventListener('mousemove', (e) => {
      lastMousePoint.clientY = e.clientY
      lastMousePoint.pageY = e.pageY
      lastMousePoint.left = e.clientX
    })

    /* harmony default export */ function getMousePoint() {
      return lastMousePoint
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/createPalletElement.js

    /* harmony default export */ function createPalletElement() {
      // Add ui-dialog class to prohibit the entity edit dialog from taking the focus.
      const html = `
    <div 
      class="textae-editor__pallet ui-dialog"
      style="display: none;"
      >
    </div>`
      return dohtml_default().create(html)
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/setWidthWithin.js

    /* harmony default export */ function setWidthWithin(pallet, width) {
      pallet.style.width = 'auto'

      if (width - 2 <= pallet.offsetWidth) {
        pallet.style.width = `${width - 4}px`
      }
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/setHeightWithin.js

    const BORDER_HEIGHT = 7 * 2

    /* harmony default export */ function setHeightWithin(pallet, height) {
      if (height - BORDER_HEIGHT <= pallet.offsetHeight) {
        pallet.style.height = `${height - BORDER_HEIGHT}px`
      } else {
        pallet.style.height = null
      }
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/index.js

    class Pallet {
      constructor(editorHTMLElement, title) {
        this._editorHTMLElement = editorHTMLElement
        this._title = title
        this._el = createPalletElement()

        // let the pallet draggable.
        enableJqueryDraggable(this._el, editorHTMLElement)

        // bugfix: Shortcut keys do not work after operating palette buttons.
        //
        // Some browsers focus button at clicking it.
        // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        // There are hacks that can override this behavior.
        // See: https://stackoverflow.com/questions/8735764/prevent-firing-focus-event-when-clicking-on-div
        // Simply refocus the editor for the following reasons:
        // 1. It's hard to see which browsers are hack-enabled using mousedown + preventDefault
        // 2. preventDefault changes default operations other than focus. Difficult to investigate impact range
        // 3. Operations that focus on a specific DOM element will work in any browser
        // 4. Refocusing on a focused DOM element has no side effects
        delegate_default()(this._el, '[type="button"]', 'click', () =>
          editorHTMLElement.focus()
        )

        delegate_default()(
          this._el,
          '.textae-editor__pallet__close-button',
          'click',
          () => this.hide()
        )
      }

      updateDisplay() {
        if (this.visibly) {
          this._updateDisplay()
        }
      }

      get el() {
        return this._el
      }

      show() {
        this._el.style.display = 'block'
        this._updateDisplay()

        this._moveInto()
      }

      _updateDisplay() {
        // Wrap the content in a special class so that you can determine if the target of the event is an element of the palette
        // even after the content has been removed from the DOM tree.
        // The taxtae-editor deselects itself when a click event to something other than taxtae-editor occurs.
        // After updating the palette, the click event reaches the body.
        // At that time, if the target of the event is the palette, you can see that it is an event for textae-editor.
        this._el.innerHTML = `
      <div class="textae-editor__pallet__container">
        <div class="textae-editor__pallet__title-bar ui-widget-header ui-corner-all">
          <span class="textae-editor__pallet__title-string">${this._title}</span>
          <button 
            type="button"
            class="textae-editor__pallet__close-button ui-button ui-corner-all ui-widget ui-button-icon-only ui-dialog-titlebar-close"
            title="Close">
            <span class="ui-button-icon ui-icon ui-icon-closethick"></span>
            <span class="ui-button-icon-space"> </span>Close
          </button>
        </div>
        <div class="textae-editor__pallet__content">${this._content}</div>
      </div>
    `

        setWidthWithin(this._el, this._maxWidth)
        setHeightWithin(
          this._el.querySelector('.textae-editor__pallet__container'),
          this._maxHeight
        )
      }

      _moveInto() {
        const { left, clientY, pageY } = getMousePoint()

        if (this._el.offsetWidth + left <= this._maxWidth) {
          this._el.style.left = `${left}px`
        } else {
          // Pull left the pallet when the pallet protrudes from right of the editor.
          this._el.style.left = `${
            this._editorHTMLElement.offsetLeft +
            this._maxWidth -
            this._el.offsetWidth -
            2
          }px`
        }

        if (this._el.offsetHeight + clientY <= this._maxHeight) {
          const top = pageY - this._editorHTMLElement.offsetTop
          this._el.style.top = `${top}px`
        } else {
          // Pull up the pallet when the pallet protrudes from bottom of the window.
          const top =
            pageY -
            this._editorHTMLElement.offsetTop -
            (this._el.offsetHeight + clientY - this._maxHeight)
          this._el.style.top = `${top}px`
        }
      }

      get _maxWidth() {
        return this._editorHTMLElement.offsetWidth
      }

      get _maxHeight() {
        return document.documentElement.clientHeight
      }

      hide() {
        this._el.style.display = 'none'
      }

      get visibly() {
        return this._el.style.display !== 'none'
      }
    } // CONCATENATED MODULE: ./src/lib/component/getInputElementValue.js

    /* harmony default export */ function getInputElementValue(el, selector) {
      return (
        el.querySelector(`input${selector}`) &&
        el.querySelector(`input${selector}`).value
      )
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputDefault.js

    /* harmony default export */ function inputDefault(
      componentClassName,
      defaultValue
    ) {
      return eskape_default()`
  <div class="${componentClassName}__row">
    <label>Default</label>
    <input
      value="${defaultValue || ''}"
      class="${componentClassName}__default-value"
    >
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputMediaHeight.js

    /* harmony default export */ function inputMediaHeight(
      componentClassName,
      mediaHeight
    ) {
      return `
    <div class="${componentClassName}__row">
      <label>Media Height</label>
      <input
        type="text"
        value="${mediaHeight || ''}"
        class="${componentClassName}__media-height"
      >
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/getRandomColorString.js

    /* harmony default export */ function getRandomColorString() {
      return `#${getRandomHEXFrom64ToFF()}${getRandomHEXFrom64ToFF()}${getRandomHEXFrom64ToFF()}`
    }

    function getRandomHEXFrom64ToFF() {
      return Math.floor(Math.random() * 155 + 100).toString(16)
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputLabelAndColor.js

    /* harmony default export */ function inputLabelAndColor(
      componentClassName,
      label,
      color
    ) {
      return eskape_default()`
    <div class="${componentClassName}__row">
      <label>Label</label>
      <input
        type="text"
        value="${label || ''}"
        class="${componentClassName}__label"
      >
    </div>
    <div class="${componentClassName}__row">
      <label>Color</label>
      <input
        type="color"
        value="${color || getRandomColorString()}"
        class="${componentClassName}__color"
      >
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputNumeric.js

    /* harmony default export */ function inputNumeric(
      componentClassName,
      min,
      max,
      step
    ) {
      return `
    <div class="${componentClassName}__row">
      <label>Min</label>
      <input
        type="text"
        value="${min || ''}"
        class="${componentClassName}__min"
      >
    </div>
    <div class="${componentClassName}__row">
      <label>Max</label>
      <input
        type="text"
        value="${max || ''}"
        class="${componentClassName}__max"
      >
    </div>
    <div class="${componentClassName}__row">
      <label>Step</label>
      <input
        type="text"
        value="${step || STEP}"
        class="${componentClassName}__step"
      >
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/index.js

    /* harmony default export */ function inputAttributeDefinition(
      componentClassName,
      context
    ) {
      const {
        pred,
        default: defaultValue,
        mediaHeight,
        label,
        color,
        min,
        max,
        step,
        valueType
      } = context

      const showDefault = valueType === 'numeric' || valueType === 'string'
      const showMediaHeight = valueType === 'string'
      const showLabelAndColor = valueType === 'flag'
      const showNumeric = valueType === 'numeric'

      return `
    <div class="${componentClassName}__row">
      <label>Predicate</label>
      <input
        value="${pred || ''}"
        class="${componentClassName}__pred textae-editor__promise-daialog__observable-element"
      >
    </div>
    ${showDefault ? `${inputDefault(componentClassName, defaultValue)}` : ''}
    ${
      showMediaHeight
        ? `${inputMediaHeight(componentClassName, mediaHeight)}`
        : ''
    }
    ${
      showLabelAndColor
        ? `${inputLabelAndColor(componentClassName, label, color)}`
        : ''
    }
    ${showNumeric ? `${inputNumeric(componentClassName, min, max, step)}` : ''}
  `
    } // CONCATENATED MODULE: ./src/lib/component/CreateAttributeDefinitionDialog/template.js

    /* harmony default export */ function CreateAttributeDefinitionDialog_template(
      componentClassName,
      context
    ) {
      const { valueType } = context

      return `
<div class="${componentClassName}__container">
  <div class="${componentClassName}__row">
    <label>Attribute type</label>
    <div class="${componentClassName}__value-type-row">
      <label>
        <input
          type="radio" 
          name="${componentClassName}__value-type"
          value="flag"
          ${valueType === 'flag' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--flag">
        flag
      </label>
      <label>
        <input
          type="radio"
          name="${componentClassName}__value-type"
          value="selection"
          ${valueType === 'selection' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--selection">
        selection
      </label>
      <label>
        <input
          type="radio"
          name="${componentClassName}__value-type"
          value="string"
          ${valueType === 'string' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--string">
        string
      </label>
      <label>
        <input
          type="radio"
          name="${componentClassName}__value-type"
          value="numeric"
          ${valueType === 'numeric' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--numeric">
        numeric
      </label>
    </div>
  </div>
  ${inputAttributeDefinition(componentClassName, context)}
</div>`
    } // CONCATENATED MODULE: ./src/lib/component/CreateAttributeDefinitionDialog/index.js

    const componentClassName = `textae-editor__create-attribute-definition-dialog`

    class CreateAttributeDefinitionDialog extends PromiseDialog {
      constructor() {
        super(
          'New attribute',
          CreateAttributeDefinitionDialog_template(componentClassName, {
            valueType: 'flag'
          }),
          {},
          () => this._state
        )

        delegate_default()(
          super.el,
          `[name="${componentClassName}__value-type"]`,
          'change',
          () => {
            const html = CreateAttributeDefinitionDialog_template(
              componentClassName,
              this._state
            )
            super.el.closest('.ui-dialog-content').innerHTML = html
          }
        )
      }

      get _state() {
        const valueType = super.el.querySelector(
          `[name="${componentClassName}__value-type"]:checked`
        ).value
        const pred = getInputElementValue(
          super.el,
          `.${componentClassName}__pred`
        )
        const label = getInputElementValue(
          super.el,
          `.${componentClassName}__label`
        )
        const color = getInputElementValue(
          super.el,
          `.${componentClassName}__color`
        )
        const defaultValue = getInputElementValue(
          super.el,
          `.${componentClassName}__default-value`
        )
        const mediaHeight = getInputElementValue(
          super.el,
          `.${componentClassName}__media-height`
        )
        const min = getInputElementValue(
          super.el,
          `.${componentClassName}__min`
        )
        const max = getInputElementValue(
          super.el,
          `.${componentClassName}__max`
        )
        const step = getInputElementValue(
          super.el,
          `.${componentClassName}__step`
        )

        return {
          pred,
          label,
          color,
          default: defaultValue,
          mediaHeight,
          min,
          max,
          step,
          valueType
        }
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditAttributeDefinitionDialog/isChanged.js

    /* harmony default export */ function isChanged(orig, changed) {
      // Ignore non number value.
      return !Number.isNaN(parseFloat(changed)) && orig !== parseFloat(changed)
    } // CONCATENATED MODULE: ./src/lib/component/EditAttributeDefinitionDialog/template.js

    /* harmony default export */ function EditAttributeDefinitionDialog_template(
      componentClassName,
      context
    ) {
      return `
<div class="${componentClassName}__container">
  ${inputAttributeDefinition(componentClassName, context)}
</div>`
    } // CONCATENATED MODULE: ./src/lib/component/EditAttributeDefinitionDialog/index.js

    const EditAttributeDefinitionDialog_componentClassName = `textae-editor__edit-attribute-definition-dialog`

    class EditAttributeDefinitionDialog extends PromiseDialog {
      constructor(attrDef) {
        super(
          'Edit attribute',
          EditAttributeDefinitionDialog_template(
            EditAttributeDefinitionDialog_componentClassName,
            attrDef
          ),
          {},
          () => {
            const pred = getInputElementValue(
              super.el,
              `.${EditAttributeDefinitionDialog_componentClassName}__pred`
            )
            const defaultValue = getInputElementValue(
              super.el,
              `.${EditAttributeDefinitionDialog_componentClassName}__default-value`
            )

            const diff = new Map()

            if (attrDef.pred !== pred) {
              diff.set('pred', pred)
            }

            if (attrDef.valueType === 'flag') {
              const label = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__label`
              )
              const color = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__color`
              )

              if (attrDef.label !== label) {
                diff.set('label', label)
              }

              if (attrDef.color !== color) {
                diff.set('color', color)
              }
            }

            if (attrDef.valueType === 'string') {
              if (attrDef.default !== defaultValue) {
                diff.set('default', defaultValue)
              }

              const mediaHeight = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__media-height`
              )

              if (attrDef.mediaHeight !== mediaHeight) {
                diff.set('mediaHeight', mediaHeight)
              }
            }

            if (attrDef.valueType === 'numeric') {
              if (isChanged(attrDef.default, defaultValue)) {
                diff.set('default', defaultValue)
              }

              const min = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__min`
              )
              const max = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__max`
              )
              const step = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__step`
              )

              if (isChanged(attrDef.min, min)) {
                diff.set('min', min)
              }

              if (isChanged(attrDef.max, max)) {
                diff.set('max', max)
              }

              if (isChanged(attrDef.step, step)) {
                diff.set('step', step)
              }
            }

            return diff
          }
        )
      }
    }

    // EXTERNAL MODULE: ./node_modules/lodash/lodash.js
    var lodash = __webpack_require__(6486) // CONCATENATED MODULE: ./src/lib/component/CreateOrEditValueOfAttributeDefinitionDialog/inputDefault.js
    /* harmony default export */ function CreateOrEditValueOfAttributeDefinitionDialog_inputDefault(
      showDefault,
      defaultValue
    ) {
      return showDefault
        ? `
    <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
      <label>
        <input
          type="checkbox"
          ${defaultValue ? `checked="checked"` : ``}
          class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__default"
        >
        default
      </label>
    </div>
    `
        : ``
    } // CONCATENATED MODULE: ./src/lib/component/CreateOrEditValueOfAttributeDefinitionDialog/template.js

    /* harmony default export */ function CreateOrEditValueOfAttributeDefinitionDialog_template(
      context
    ) {
      const {
        labelForRangeOrIdOrPattern,
        rangeOrIdOrPattern,
        showDefault,
        default: defaultValue,
        label,
        color
      } = context

      return `
<div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__container">
  <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
    <label>${labelForRangeOrIdOrPattern}</label>
    <input
      value="${rangeOrIdOrPattern || ''}"
      class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern textae-editor__promise-daialog__observable-element"
    >
  </div>
  ${CreateOrEditValueOfAttributeDefinitionDialog_inputDefault(
    showDefault,
    defaultValue
  )}
  <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
    <label>label</label>
    <input
      value="${(0, lodash.escape)(label) || ''}"
      class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__label textae-editor__promise-daialog__observable-element"
    >
  </div>
  <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
    <label>
      <input
        type="color"
        value="${color || getRandomColorString()}"
        class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__color"
      >
      color
    </label>
  </div>
</div>`
    } // CONCATENATED MODULE: ./src/lib/component/enableHTMLElement.js

    // Since the style is specified by [disabled = "disabled"],
    // set the attribute to disabled without using the disable property.
    /* harmony default export */ function enableHTMLElement(element, enable) {
      if (enable) {
        element.removeAttribute('disabled')
      } else {
        element.setAttribute('disabled', 'disabled')
      }
    } // CONCATENATED MODULE: ./src/lib/component/CreateOrEditValueOfAttributeDefinitionDialog/index.js

    class CreateOrEditValueOfAttributeDefinitionDialog extends PromiseDialog {
      constructor(valueType, value = {}) {
        const bindingObject = {
          label: value.label,
          color: value.color
        }

        switch (valueType) {
          case 'numeric':
            bindingObject.labelForRangeOrIdOrPattern = 'range'
            bindingObject.rangeOrIdOrPattern = value.range
            break
          case 'selection':
            bindingObject.labelForRangeOrIdOrPattern = 'id'
            bindingObject.rangeOrIdOrPattern = value.id
            bindingObject.showDefault = true
            bindingObject.default = value.default
            break
          case 'string':
            bindingObject.labelForRangeOrIdOrPattern = 'pattern'
            bindingObject.rangeOrIdOrPattern = value.pattern
            break
          default:
            throw new Error(`${valueType} is Uknown Attribute`)
        }

        super(
          Object.keys(value).length
            ? 'Edit attribute values'
            : 'New attribute value',
          CreateOrEditValueOfAttributeDefinitionDialog_template(bindingObject),
          {},
          () => {
            const rangeOrIdOrPattern = getInputElementValue(
              super.el,
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern'
            )

            const label = getInputElementValue(
              super.el,
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__label'
            )

            const color = getInputElementValue(
              super.el,
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__color'
            )

            // Set a key only when there is a value.
            const ret = {}
            if (label) {
              ret.label = label
            }
            if (color) {
              ret.color = color
            }

            switch (valueType) {
              case 'numeric':
                ret.range = rangeOrIdOrPattern
                break
              case 'selection':
                ret.id = rangeOrIdOrPattern

                if (
                  super.el.querySelector(
                    'input.textae-editor__create-or-edit-value-of-attribute-definition-dialog__default'
                  ).checked
                ) {
                  ret.default = true
                }

                break
              case 'string':
                ret.pattern = rangeOrIdOrPattern
                break
              default:
              // A value type is checked already.
            }

            return ret
          }
        )

        // validation range
        if (valueType === 'numeric') {
          super.el
            .querySelector(
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern'
            )
            .addEventListener('input', (e) => {
              const { value } = e.target
              try {
                new IntervalNotation(value)
                enableHTMLElement(super.button, true)
              } catch (error) {
                enableHTMLElement(super.button, false)
              }
            })
        }

        // validation pattern
        if (valueType === 'string') {
          super.el
            .querySelector(
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern'
            )
            .addEventListener('input', (e) => {
              const { value } = e.target
              try {
                new RegExp(value)
                enableHTMLElement(super.button, true)
              } catch (error) {
                enableHTMLElement(super.button, false)
              }
            })
        }

        // validation color
        super.el
          .querySelector(
            '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__color'
          )
          .addEventListener('input', (e) => {
            const { value } = e.target
            enableHTMLElement(
              super.button,
              !value || /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)
            )
          })
      }
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrag/showDropTargets.js

    /* harmony default export */ function showDropTargets(e) {
      e.target
        .closest('.textae-editor__pallet__content')
        .classList.add('textae-editor__pallet__content--dragging')
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrag/hideDropTargets.js

    /* harmony default export */ function hideDropTargets(e) {
      e.target
        .closest('.textae-editor__pallet__content')
        .classList.remove('textae-editor__pallet__content--dragging')
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrag/index.js

    /* harmony default export */ function enableAttributeTabDrag(el) {
      delegate_default()(
        el,
        '.textae-editor__pallet__attribute',
        'dragstart',
        (e) => {
          e.dataTransfer.setData(
            'application/x-textae-attribute-tab-old-index',
            e.target.dataset.index
          )
          showDropTargets(e)
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__attribute',
        'dragend',
        (e) => {
          hideDropTargets(e)
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrop.js

    /* harmony default export */ function enableAttributeTabDrop(
      el,
      commander
    ) {
      delegate_default()(
        el,
        '.textae-editor__pallet__drop-target',
        'dragover',
        (e) => {
          // Display the image after the drop.
          const width = e.target
            .closest('.textae-editor__pallet__content')
            .querySelector('.textae-editor__pallet__attribute').offsetWidth
          e.target.innerHTML = `<div style="width: ${width}px;"></div>`

          // Enable drop targets to fire drop events.
          e.preventDefault()
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__drop-target',
        'dragleave',
        (e) => {
          // Hide the image after the drop.
          e.target.innerHTML = ''
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__drop-target',
        'drop',
        (e) => {
          const oldIndex = parseInt(
            e.dataTransfer.getData(
              'application/x-textae-attribute-tab-old-index'
            )
          )
          const newIndex = parseInt(e.target.dataset.index)

          commander.invoke(
            commander.factory.moveAttributeDefintionComannd(
              oldIndex,
              oldIndex < newIndex ? newIndex - 1 : newIndex
            )
          )
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/EditNumericAttributeDialog.js

    function EditNumericAttributeDialog_template(context) {
      const { subjects, pred, min, max, step, value } = context
      return `
<div class="textae-editor__edit-numeric-attribute-dialog__container">
  <div class="textae-editor__edit-numeric-attribute-dialog__row">
    <label>Subject</label>
    <div class="textae-editor__edit-numeric-attribute-dialog__subject-row">
      <input 
      class="textae-editor__edit-numeric-attribute-dialog__subject-input"
        value="${subjects}" 
        disabled="disabled">
      <button 
        class="textae-editor__edit-numeric-attribute-dialog__subject-edit-button"
        title="properties">...</button>
    </div>
  </div>
  <div class="textae-editor__edit-numeric-attribute-dialog__row">
    <label>Predicate</label>
    <input 
      value="${pred}" 
      disabled="disabled">
  </div>
  <div class="textae-editor__edit-numeric-attribute-dialog__row ui-front">
    <label>Object</label>
    <input 
      class="textae-editor__edit-numeric-attribute-dialog__value textae-editor__promise-daialog__observable-element" 
      type="number" 
      ${typeof min === 'number' ? `min="${min}"` : ''}
      ${typeof max === 'number' ? `max="${max}"` : ''}
      step="${step}" 
      value="${value}"
      autofocus>
  </div>
</div>`
    }

    class EditNumericAttributeDialog extends PromiseDialog {
      constructor(
        attrDef,
        attribute,
        targetAttributes,
        deletable,
        editTypeValues,
        pallet
      ) {
        const buttons = []

        if (deletable) {
          buttons.unshift({
            class:
              'textae-editor__edit-numeric-attribute-dialog__remove-attribute',
            click: () => {
              this.close()
              this.resolveFunc({ newObj: null })
            }
          })
        }

        if (pallet) {
          buttons.unshift({
            text: '...',
            title: 'cofiguration',
            click: () => {
              this.close()
              pallet.show()
              pallet.showAttribute(attribute.pred)
            }
          })
        }

        super(
          `Attribute [${targetAttributes
            .map(({ id }) => id || '-')
            .join(',')}]`,
          EditNumericAttributeDialog_template({
            subjects: `${targetAttributes
              .map(({ subj }) => subj || '-')
              .join(', ')}`,
            pred: attribute.pred,
            value: attribute.obj,
            min: attrDef.min,
            max: attrDef.max,
            step: attrDef.step
          }),
          { buttons },
          () => {
            const input = super.el.querySelector(
              '.textae-editor__edit-numeric-attribute-dialog__value'
            )

            // Numeric attribute obj value type must be Number type.
            return { newObj: input.value }
          }
        )

        if (editTypeValues) {
          delegate_default()(
            super.el,
            '.textae-editor__edit-numeric-attribute-dialog__subject-edit-button',
            'click',
            () => {
              this.close()
              editTypeValues()
            }
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/openEditNumericAttributeDialog.js

    /* harmony default export */ function openEditNumericAttributeDialog(
      selectionModelEntity,
      attrDef,
      attribute,
      commander,
      editTypeValues,
      pallet
    ) {
      new EditNumericAttributeDialog(
        attrDef,
        attribute,
        selectionModelEntity.all.reduce((attrs, entity) => {
          attrs.push(entity.attributes.find((a) => a.pred == attribute.pred))
          return attrs
        }, []),
        true,
        editTypeValues,
        pallet
      )
        .open()
        .then(({ newObj }) => {
          const command = newObj
            ? commander.factory.changeAttributeObjOfItemsCommand(
                selectionModelEntity.all,
                attrDef,
                newObj
              )
            : commander.factory.removeAttributesFromItemsByPredCommand(
                selectionModelEntity.all,
                attrDef
              )

          commander.invoke(command)
        })
    } // CONCATENATED MODULE: ./src/lib/component/setSourceOfAutoComplete.js

    customize_jquery_ui_autocomplete()

    /* harmony default export */ function component_setSourceOfAutoComplete(
      inputElement,
      labelSpan,
      autocompletionWs,
      getLocalData
    ) {
      jquery_default()(inputElement).autocomplete({
        source: (request, response) => {
          if (labelSpan) {
            if (labelSpan instanceof HTMLInputElement) {
              labelSpan.value = ''
            } else {
              labelSpan.innerText = ''
            }
          }

          searchTerm(
            autocompletionWs,
            getLocalData(request.term),
            request.term,
            response
          )
        },
        minLength: 3,
        select: (_, { item }) => {
          inputElement.value = item.id

          console.log(123)
          if (labelSpan) {
            if (labelSpan instanceof HTMLInputElement) {
              labelSpan.value = item.label
            } else {
              labelSpan.innerText = item.label
            }
          }

          return false
        }
      })
    } // CONCATENATED MODULE: ./src/lib/component/EditStringAttributeDialog.js

    function EditStringAttributeDialog_template(context) {
      const { subjects, pred, value } = context

      return `
<div class="textae-editor__edit-string-attribute-dialog__container">
  <div class="textae-editor__edit-numeric-attribute-dialog__row">
    <label>Subject</label>
    <div class="textae-editor__edit-numeric-attribute-dialog__subject-row">
      <input 
      class="textae-editor__edit-numeric-attribute-dialog__subject-input"
        value="${subjects}" 
        disabled="disabled">
      <button 
        class="textae-editor__edit-numeric-attribute-dialog__subject-edit-button"
        title="properties">...</button>
    </div>
  </div>
  <div class="textae-editor__edit-string-attribute-dialog__row">
    <label>Predicate</label>
    <input 
      value="${pred}" disabled="disabled">
  </div>
  <div class="textae-editor__edit-string-attribute-dialog__row ui-front">
    <label>Object</label>
    <input
      class="textae-editor__edit-string-attribute-dialog__value textae-editor__promise-daialog__observable-element" 
      value="${value}"
      autofocus>
  </div>
  <div class="textae-editor__edit-string-attribute-dialog__row">
    <label>Label</label>
    <input 
      class="textae-editor__edit-string-attribute-dialog__label" 
      value="" disabled="disabled">
  </div>
</div>`
    }

    class EditStringAttributeDialog extends PromiseDialog {
      constructor(
        attrDef,
        attribute,
        targetAttributes,
        deletable,
        editTypeValues,
        pallet
      ) {
        const buttons = []

        if (deletable) {
          buttons.unshift({
            class:
              'textae-editor__edit-string-attribute-dialog__remove-attribute',
            click: () => {
              this.close()
              this.resolveFunc({ newObj: null })
            }
          })
        }

        if (pallet) {
          buttons.unshift({
            text: '...',
            title: 'configuration',
            click: () => {
              this.close()
              pallet.show()
              pallet.showAttribute(attribute.pred)
            }
          })
        }

        super(
          `Attribute [${targetAttributes
            .map(({ id }) => id || '-')
            .join(',')}]`,
          EditStringAttributeDialog_template({
            subjects: `${targetAttributes
              .map(({ subj }) => subj || '-')
              .join(', ')}`,
            pred: attribute.pred,
            value: attribute.obj
          }),
          { buttons },
          () => {
            const input = super.el.querySelector(
              '.textae-editor__edit-string-attribute-dialog__value'
            )

            return {
              newObj: input.value,
              newLabel: super.el.querySelector(
                '.textae-editor__edit-string-attribute-dialog__label'
              ).value
            }
          }
        )

        if (editTypeValues) {
          delegate_default()(
            super.el,
            '.textae-editor__edit-numeric-attribute-dialog__subject-edit-button',
            'click',
            () => {
              this.close()
              editTypeValues()
            }
          )
        }

        component_setSourceOfAutoComplete(
          super.el.querySelector(
            '.textae-editor__edit-string-attribute-dialog__value'
          ),
          super.el.querySelector(
            '.textae-editor__edit-string-attribute-dialog__label'
          ),
          attrDef.autocompletionWs,
          () => []
        )
      }
    } // CONCATENATED MODULE: ./src/lib/openEditStringAttributeDialog.js

    /* harmony default export */ function openEditStringAttributeDialog(
      selectionModelEntity,
      attribute,
      commander,
      attrDef,
      editTypeValues,
      pallet
    ) {
      new EditStringAttributeDialog(
        attrDef,
        attribute,
        selectionModelEntity.all.reduce((attrs, entity) => {
          attrs.push(entity.attributes.find((a) => a.pred == attribute.pred))
          return attrs
        }, []),
        true,
        editTypeValues,
        pallet
      )
        .open()
        .then(({ newObj, newLabel }) => {
          if (newObj) {
            commander.invoke(
              commander.factory.changeStringAttributeObjOfItemsCommand(
                selectionModelEntity.all,
                attrDef,
                newObj,
                newLabel
              )
            )
          } else {
            commander.invoke(
              commander.factory.removeAttributesFromItemsByPredCommand(
                selectionModelEntity.all,
                attrDef
              )
            )
          }
        })
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/index.js

    /**
     * @param {import('../../../Editor/API/Commander').default} commander
     */
    /* harmony default export */ function bindAttributeEvent(
      pallet,
      el,
      commander,
      selectionModelEntity
    ) {
      enableAttributeTabDrag(el)
      enableAttributeTabDrop(el, commander)

      delegate_default()(
        el,
        '.textae-editor__pallet__attribute',
        'click',
        (e) => {
          pallet.showAttribute(e.target.dataset['attribute'])
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__create-predicate',
        'click',
        () =>
          new CreateAttributeDefinitionDialog().open().then((attrDef) => {
            // Predicate is necessary and Ignore without predicate.
            if (attrDef.pred) {
              commander.invoke(
                commander.factory.createAttributeDefinitionCommand(attrDef)
              )
            }
          })
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__edit-predicate',
        'click',
        () =>
          new EditAttributeDefinitionDialog(pallet.attrDef)
            .open()
            .then((changedProperties) => {
              // Predicate is necessary and Ignore without predicate.
              if (
                changedProperties.size &&
                changedProperties.get('pred') !== ''
              ) {
                commander.invoke(
                  commander.factory.changeAttributeDefinitionCommand(
                    pallet.attrDef,
                    changedProperties
                  )
                )
              }
            })
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__delete-predicate',
        'click',
        () =>
          commander.invoke(
            commander.factory.deleteAttributeDefinitionCommand(pallet.attrDef)
          )
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__selection-attribute-label',
        'click',
        (e) => {
          if (
            selectionModelEntity.selectedWithAttributeOf(pallet.attrDef.pred)
          ) {
            if (
              selectionModelEntity.isDupulicatedPredAttrributeSelected(
                pallet.attrDef.pred
              )
            ) {
              alertify_default().warning(
                'An item among the selected has this attribute multiple times.'
              )
            } else {
              const command =
                commander.factory.changeAttributeObjOfItemsCommand(
                  selectionModelEntity.all,
                  pallet.attrDef,
                  e.target.dataset.id
                )
              commander.invoke(command)
            }
          } else {
            const command = commander.factory.createAttributeToItemsCommand(
              selectionModelEntity.all,
              pallet.attrDef,
              e.target.dataset.id
            )
            commander.invoke(command)
          }
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__add-attribute-value-button',
        'click',
        () =>
          new CreateOrEditValueOfAttributeDefinitionDialog(
            pallet.attrDef.valueType
          )
            .open()
            .then((value) => {
              if (value.range || value.id || value.pattern) {
                commander.invoke(
                  commander.factory.addValueToAttributeDefinitionCommand(
                    pallet.attrDef,
                    value
                  )
                )
              }
            })
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__edit-value',
        'click',
        (e) => {
          const oldValue = pallet.attrDef.values[e.target.dataset.index]
          new CreateOrEditValueOfAttributeDefinitionDialog(
            pallet.attrDef.valueType,
            oldValue
          )
            .open()
            .then((newValue) => {
              if (newValue.range || newValue.id || newValue.pattern) {
                const changed =
                  Object.keys(newValue).reduce((acc, cur) => {
                    return acc || newValue[cur] !== oldValue[cur]
                  }, false) ||
                  Object.keys(oldValue).reduce((acc, cur) => {
                    return acc || newValue[cur] !== oldValue[cur]
                  }, false)
                // Ignore if there is no change
                if (!changed) {
                  return
                }

                commander.invoke(
                  commander.factory.changeValueOfAttributeDefinitionAndObjectOfSelectionAttributeCommand(
                    pallet.attrDef.JSON,
                    e.target.dataset.index,
                    newValue
                  )
                )
              }
            })
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__remove-value',
        'click',
        (e) =>
          commander.invoke(
            commander.factory.removeValueFromAttributeDefinitionCommand(
              pallet.attrDef,
              e.target.dataset.index
            )
          )
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__add-attribute',
        'click',
        () =>
          commander.invoke(
            commander.factory.createAttributeToItemsCommand(
              selectionModelEntity.all,
              pallet.attrDef
            )
          )
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__edit-object',
        'click',
        () => {
          const attribute =
            selectionModelEntity.findSelectedAttributeWithSamePredicate(
              pallet.attrDef.pred
            )
          switch (pallet.attrDef.valueType) {
            case 'numeric':
              openEditNumericAttributeDialog(
                selectionModelEntity,
                pallet.attrDef,
                attribute,
                commander
              )
              break
            case 'string':
              openEditStringAttributeDialog(
                selectionModelEntity,
                attribute,
                commander,
                pallet.attrDef
              )
              break
            default:
              throw new Error(
                `Invalid attribute valueType: ${pallet.attrDef.valueType}`
              )
          }
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__remove-attribute',
        'click',
        () =>
          commander.invoke(
            commander.factory.removeAttributesFromItemsByPredCommand(
              selectionModelEntity.all,
              pallet.attrDef
            )
          )
      )
    }

    // EXTERNAL MODULE: ./node_modules/lodash.escape/index.js
    var lodash_escape = __webpack_require__(8686)
    var lodash_escape_default =
      /*#__PURE__*/ __webpack_require__.n(lodash_escape) // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/getSelectedEntityLabel.js
    /* harmony default export */ function getSelectedEntityLabel(
      numberOfSelectedItems
    ) {
      return numberOfSelectedItems === 1
        ? '1 item selected'
        : numberOfSelectedItems > 1
        ? `${numberOfSelectedItems} items selected`
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/attributeTabTemplate.js

    /* harmony default export */ function attributeTabTemplate(
      { pred },
      index,
      array,
      selectedPred
    ) {
      // Moving an attribute to before or after the current position does not change the position.
      const previous = array[index - 1]
      const droppable =
        pred !== selectedPred &&
        (previous ? previous.pred !== selectedPred : true)

      return `
    ${
      droppable
        ? `<span class="textae-editor__pallet__drop-target" data-index="${index}"></span>`
        : ''
    }
    <p 
      class="textae-editor__pallet__attribute${
        pred === selectedPred
          ? ' textae-editor__pallet__attribute--selected'
          : ''
      }"
      data-attribute="${pred}"
      data-index="${index}"
      ${pred === selectedPred ? 'draggable="true"' : ''}>
      ${index < 9 ? `${index + 1}:` : ''}${pred}
    </p>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/addAttributeButtonTemplate.js

    /* harmony default export */ function addAttributeButtonTemplate(context) {
      const { selectionModelItems, selectedPred } = context
      const isEntityWithoutSamePredSelected =
        selectionModelItems.selectedWithoutAttributeOf(selectedPred)

      return isEntityWithoutSamePredSelected
        ? `
      <button
        type="button"
        class="textae-editor__pallet__add-attribute"
        >add to</button>
      `
        : `
      <button
        type="button"
        class="textae-editor__pallet__add-attribute"
        disabled="disabled"
        title="All the selected items already have this attribute."
        >add to</button>
      `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/editAttributeButtonTemplate.js

    /* harmony default export */ function editAttributeButtonTemplate(context) {
      const { attrDef, selectionModelItems, selectedPred } = context
      const { valueType } = attrDef
      const isOnlyEntityWithJsutOneSamePredSelected =
        selectionModelItems.onlySelectedWithJustOneAttributeOf(selectedPred)

      return valueType === 'string' || valueType === 'numeric'
        ? isOnlyEntityWithJsutOneSamePredSelected
          ? `
        <button
          type="button"
          class="textae-editor__pallet__edit-object"
          >edit object of
        </button>
        `
          : `
        <button
          type="button"
          class="textae-editor__pallet__edit-object"
          disabled="disabled"
          title="Some selected items has zero or multi this attribute."
          >edit object of
        </button>
      `
        : ``
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/removeAttributeButtonTemplate.js

    /* harmony default export */ function removeAttributeButtonTemplate(
      context
    ) {
      const { selectionModelItems, selectedPred } = context
      const isEntityWithSamePredSelected =
        selectionModelItems.selectedWithAttributeOf(selectedPred)

      return isEntityWithSamePredSelected
        ? `
      <button
        type="button"
        class="textae-editor__pallet__remove-attribute"
        >remove from</button>
      `
        : `
      <button
        type="button"
        class="textae-editor__pallet__remove-attribute"
        disabled="disabled"
        title="None of the selected items has this attribute."
        >remove from</button>
      `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/index.js

    /* harmony default export */ function headerTemplate(context) {
      const { isLock, selectionModelItems, selectedPred, attributes, hasDiff } =
        context

      const selectedEntityLabel = getSelectedEntityLabel(
        selectionModelItems.size
      )
      const addAttribute = attributes.length < 30
      const lastAttributeSelected =
        selectedPred ===
        (attributes[attributes.length - 1] &&
          attributes[attributes.length - 1].pred)

      return `
<div class="textae-editor__pallet__header-first-row">
  <div class="textae-editor__pallet__information">
    <span class="textae-editor__pallet__lock-icon" style="display: ${
      isLock ? 'inline-block' : 'none'
    };">locked</span>
    ${
      selectedPred && selectionModelItems.size > 0
        ? `
          ${addAttributeButtonTemplate(context)}
          ${editAttributeButtonTemplate(context)}
          ${removeAttributeButtonTemplate(context)}
          the
          `
        : ``
    }
    <span class="textae-editor__pallet__selected-entity-label">${selectedEntityLabel}</span>
  </div>
  <div class="textae-editor__pallet__buttons">
    <span class="textae-editor__pallet__button textae-editor__pallet__read-button" title="Import"></span>
    <span class="textae-editor__pallet__button textae-editor__pallet__write-button ${
      hasDiff ? 'textae-editor__pallet__write-button--transit' : ''
    }" title="Upload"></span>
  </div>
</div>
<div class="textae-editor__pallet__header-second-row">
  <p class="textae-editor__pallet__attribute ${
    selectedPred ? '' : 'textae-editor__pallet__attribute--selected'
  }" data-attribute="">
    Type
  </p>
  ${attributes
    .map((a, index, array) =>
      attributeTabTemplate(a, index, array, selectedPred)
    )
    .join('\n')}
  ${
    isLock
      ? ''
      : `
        ${
          lastAttributeSelected
            ? ''
            : '<span class="textae-editor__pallet__drop-target" data-index="-1"></span>'
        }
        ${
          addAttribute
            ? `
            <p class="textae-editor__pallet__attribute textae-editor__pallet__create-predicate">
              <span class="textae-editor__pallet__create-predicate__button" title="Add a new attribute"></span>
            </p>
            `
            : ''
        }`
  }
</div>
`
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/typeTemplate.js

    /* harmony default export */ function typeTemplate(context) {
      const { types, isLock } = context

      return `
  ${headerTemplate(context)}
  <table>
    <tbody>
      <tr>
        <th>id</th>
        <th>label</th>
        <th title="Number of annotations.">#</th>
        <th>
          ${
            isLock
              ? ''
              : '<span class="textae-editor__pallet__add-button" title="Add new type"></span>'
          }
        </th>
      </tr>
      ${
        types
          ? types
              .map(
                ({
                  color = '',
                  id,
                  uri,
                  defaultType,
                  label = '',
                  useNumber
                }) => {
                  return `
      <tr class="textae-editor__pallet__row" style="background-color: ${color};">
        <td class="textae-editor__pallet__label" data-id="${lodash_escape_default()(
          id
        )}">
          <span title="${lodash_escape_default()(id)}">
            ${lodash_escape_default()(id)}
          </span>
          ${
            uri
              ? `<a href="${uri}" target="_blank"><span class="textae-editor__pallet__link"></span></a>`
              : ``
          }
          ${
            defaultType
              ? '<span class="textae-editor__pallet__default-icon" title="This type is set as a default type."></span>'
              : ''
          }
        </td>
        <td class="textae-editor__pallet__short-label">
          ${lodash_escape_default()(label)}
        </td>
        <td class="textae-editor__pallet__use-number">
          ${useNumber}
        </td>
        <td class="textae-editor__pallet__table-buttons">
          <button
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__select-all${
              useNumber ? '' : ' textae-editor__pallet__table-button--disabled'
            }"
            title="Select all the cases of this type."
            data-id="${lodash_escape_default()(id)}"
            data-use-number="${useNumber}">
          </button>
          ${
            isLock
              ? ''
              : `
          <button
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__edit-type"
            title="Edit this type." data-id="${lodash_escape_default()(id)}"
            data-color="${color}"
            data-is-default="${defaultType}">
          </button>
          <button 
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__remove${
              useNumber ? ' textae-editor__pallet__table-button--disabled' : ''
            }"
            title="${
              useNumber
                ? 'To activate this button, remove all the annotations of this type.'
                : 'Remove this type.'
            }"
            data-id="${lodash_escape_default()(id)}"
            data-label="${lodash_escape_default()(label)}">
          </button>
          `
          }
        </td>
      </tr>`
                }
              )
              .join('\n')
          : `
      <tr class="textae-editor__pallet__row">
        <td class="textae-editor__pallet__no-config" colspan="4">There is no Entity definition.</td>
      </tr>
      `
      }
    </tbody>
  </table>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/predicateControllerTemplate/editAttributeDefinitionBlockTemplate.js

    /* harmony default export */ function editAttributeDefinitionBlockTemplate(
      context
    ) {
      const { isLock, numberOfItemsUsingSelectedPred } = context

      if (isLock) {
        return `
      <button
        type="button"
        class="textae-editor__pallet__table-button textae-editor__pallet__table-button--disabled textae-editor__pallet__edit-predicate"
        disabled="disabled">
      </button>
      <button 
        type="button"
        class="textae-editor__pallet__table-button textae-editor__pallet__table-button--disabled textae-editor__pallet__delete-predicate"
        disabled="disabled">
      </button>
    `
      }

      return `
    <button
      type="button"
      class="textae-editor__pallet__table-button textae-editor__pallet__edit-predicate"
      title="Edit this predicate.">
    </button>
    ${
      numberOfItemsUsingSelectedPred.size > 0
        ? `<button 
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__table-button--disabled textae-editor__pallet__delete-predicate"
            disabled="disabled"
            title="It cannot be deleted, as this attribute is used for ${numberOfItemsUsingSelectedPred.size} items.">
          </button>`
        : `<button
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__delete-predicate"
            title="Delet this predicate.">
          </button>`
    }
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/predicateControllerTemplate/index.js

    /* harmony default export */ function predicateControllerTemplate(context) {
      const { attrDef } = context
      const { pred } = attrDef
      const { valueType } = attrDef

      return `
    <div>
      Attribute
      <span
        class="textae-editor__pallet__predicate__value-type textae-editor__pallet__predicate__value-type--${valueType}"
        title="${valueType} type">
      </span>
      "${pred}"
      ${editAttributeDefinitionBlockTemplate(context)}
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/flagAttributeTemplate.js

    /* harmony default export */ function flagAttributeTemplate(context) {
      const { label, color } = context.attrDef

      return `
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
      label: "${(0, lodash.escape)(label) || ''}"
      color: "${color || ''}"
    </div>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/valueButtonsTemplate.js

    /* harmony default export */ function valueButtonsTemplate(
      isLock,
      index,
      indelible
    ) {
      return isLock
        ? ''
        : `
  <td class="textae-editor__pallet__table-attribute-buttons">
    <button
      type="button"
      class="textae-editor__pallet__table-button textae-editor__pallet__edit-value"
      title="Edit this value." data-index="${index}">
    </button>
    <button 
      type="button"
      class="textae-editor__pallet__table-button textae-editor__pallet__remove-value${
        indelible ? ' textae-editor__pallet__table-button--disabled' : ''
      }"
      title="${
        indelible
          ? 'To activate this button, remove all the annotations of this type.'
          : 'Remove this value.'
      }"
      ${indelible ? ' disabled="disabled"' : ''}
      data-index="${index}">
    </button>
  </td>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/showAddAttributeValueButton.js

    /* harmony default export */ function showAddAttributeValueButton(isLock) {
      return isLock
        ? ''
        : `
              <th>
                <span class="textae-editor__pallet__add-attribute-value-button" title="Add new value"></span>
              </th>`
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/numericAttributeTemplate.js

    /* harmony default export */ function numericAttributeTemplate(context) {
      const { min, max, step, default: defaultValue, values } = context.attrDef
      const { isLock } = context

      return `
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
      min: ${min || '""'}
      max: ${max || '""'}
      step: ${step}
      default: ${defaultValue}
    </div>

    <table>
      <tbody>
        <tr>
          <th>range</th>
          <th>label</th>
          <th>color</th>
          ${showAddAttributeValueButton(isLock)}
        </tr>
        ${values
          .map(({ color = '', range, label = '', indelible }, index) => {
            return `
        <tr class="textae-editor__pallet__row" style="background-color: ${color};">
          <td class="textae-editor__pallet__attribute-label">
            ${range}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${(0, lodash.escape)(label)}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${color}
          </td>
          ${valueButtonsTemplate(isLock, index, indelible)}
        </tr>
      `
          })
          .join('\n')}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/selectionAttributeTemplate.js

    /* harmony default export */ function selectionAttributeTemplate(
      context,
      attributeContainer
    ) {
      const { values } = context.attrDef
      const { isLock, selectedPred } = context

      return `
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
    </div>

    <table>
      <tbody>
        <tr>
          <th>id</th>
          <th>label</th>
          <th>color</th>
          ${showAddAttributeValueButton(isLock)}
        </tr>
        ${values
          .map(
            ({ color = '', id, default: defaultValue, label = '' }, index) => {
              return `
        <tr class="textae-editor__pallet__row" style="background-color: ${color};">
          <td class="textae-editor__pallet__selection-attribute-label" data-id="${id}">
            ${id}
            ${
              defaultValue
                ? '<span class="textae-editor__pallet__default-icon" title="This type is set as a default type."></span>'
                : ''
            }
          </td>
          <td class="textae-editor__pallet__short-label">
            ${(0, lodash.escape)(label)}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${color}
          </td>
          ${valueButtonsTemplate(
            isLock,
            index,
            attributeContainer.isSelectionAttributeValueIndelible(
              // Disable to press the remove button for the value used in the selection attribute.
              selectedPred,
              id
            )
          )}
        </tr>
        `
            }
          )
          .join('\n')}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/stringAttributeTemplate.js

    /* harmony default export */ function stringAttributeTemplate(context) {
      const { default: defaultValue, mediaHeight, values } = context.attrDef
      const { isLock } = context

      return `
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
      media height: ${mediaHeight || '""'}
      default: ${(0, lodash.escape)(defaultValue)}
    </div>

    <table>
      <tbody>
        <tr>
          <th>pattern</th>
          <th>label</th>
          <th>color</th>
          ${showAddAttributeValueButton(isLock)}
        </tr>
        ${values
          .map(
            ({ color = ' ', pattern = '', label = '', indelible }, index) => {
              return `
        <tr class="textae-editor__pallet__row" style="background-color: ${color};">
          <td class="textae-editor__pallet__attribute-label">
            ${pattern}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${(0, lodash.escape)(label)}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${color}
          </td>
          ${valueButtonsTemplate(isLock, index, indelible)}
        </tr>`
            }
          )
          .join('\n')}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/index.js

    /* harmony default export */ function createContentHtml(
      types,
      hasDiff,
      selectedPred,
      selectionModelItems,
      attributeContainer,
      attributeInstances,
      isLock
    ) {
      const { attributes } = attributeContainer

      if (!selectedPred) {
        return typeTemplate({
          isLock,
          attributes,
          hasDiff,
          types,
          selectionModelItems
        })
      }

      const attrDef = attributes.find((a) => a.pred === selectedPred)

      // When you re-read the configuration,
      // you may not find the attribute definition.
      if (!attrDef) {
        return typeTemplate({
          isLock,
          attributes,
          hasDiff,
          types,
          selectionModelItems
        })
      }

      const context = {
        isLock,
        attributes,
        hasDiff,
        attrDef,
        selectedPred,
        selectionModelItems,
        numberOfItemsUsingSelectedPred: new Set(
          attributeInstances
            .filter((a) => a.pred === selectedPred)
            .map((a) => a.subj)
        )
      }

      switch (attrDef.valueType) {
        case 'flag':
          return flagAttributeTemplate(context)
        case 'numeric':
          return numericAttributeTemplate(context)
        case 'selection':
          return selectionAttributeTemplate(context, attributeContainer)
        case 'string':
          return stringAttributeTemplate(context)
        default:
          throw `attrDef.valueType is unknown attribute`
      }
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/enableDrag.js

    /* harmony default export */ function enableDrag(el) {
      for (const attributeTab of el.querySelectorAll(
        '.textae-editor__pallet__attribute'
      )) {
        attributeTab.addEventListener('mousedown', (e) => {
          // Stop event propagation to prevent the jQueryUI.dragging widget
          // from disabling the default handling of mousedown events.
          e.stopPropagation()
        })
      }
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/index.js

    class TypeValuesPallet extends Pallet {
      /**
       *
       * @param {import('../../Editor/AnnotationData/TypeDefinition').default} typeDefinition
       * @param {import('../../Editor/AttributeDefinitionContainer').default} attributeModelContainer
       */
      constructor(
        editorHTMLElement,
        eventEmitter,
        typeDefinition,
        attributeModelContainer,
        definitionContainer,
        selectionModelEntity,
        commander,
        title,
        buttonController
      ) {
        super(editorHTMLElement, title)

        this._eventEmitter = eventEmitter
        this._typeDefinition = typeDefinition
        this._attributeModelContainer = attributeModelContainer
        this._definitionContainer = definitionContainer
        this._selectionModelItems = selectionModelEntity
        this._buttonController = buttonController

        delegate_default()(
          this._el,
          `.textae-editor__pallet__read-button`,
          'click',
          () => eventEmitter.emit('textae-event.pallet.read-button.click')
        )

        delegate_default()(
          this._el,
          '.textae-editor__pallet__write-button',
          'click',
          () => eventEmitter.emit('textae-event.pallet.write-button.click')
        )

        bindAttributeEvent(this, this._el, commander, selectionModelEntity)

        eventEmitter
          .on('textae-event.type-definition.attribute.create', (pred) => {
            // Reload pallet when reverting deleted attribute.
            this.showAttribute(pred)
          })
          .on('textae-event.type-definition.attribute.change', (pred) => {
            // Reload pallet when reverting change attribute.
            this.showAttribute(pred)
          })
          .on('textae-event.type-definition.attribute.delete', () => {
            // Reload pallet when undo deleted attribute.
            this.showAttribute(null)
          })
          .on('textae-event.type-definition.attribute.move', () => {
            this.updateDisplay()
          })

        // Reload when instance addition / deletion is undo / redo.
        eventEmitter.on(
          'textae-event.annotation-data.events-observer.change',
          () => this.updateDisplay()
        )

        // Update selected entity label
        eventEmitter.on('textae-event.selection.entity.change', () =>
          this.updateDisplay()
        )

        eventEmitter
          .on('textae-event.editor.unselect', () => this.hide()) // Close pallet when selecting other editor.
          .on('textae-event.orginal-data.configuration.reset', () =>
            this.updateDisplay()
          )
          .on(`textae-event.type-definition.lock`, () => this.updateDisplay())

        // Update the palette when undoing and redoing add entity and relation definition.
        eventEmitter
          .on('textae-event.type-definition.entity.change', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.entity.delete', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.entity.change-default', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.relation.change', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.relation.delete', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.relation.change-default', () =>
            this.updateDisplay()
          )
      }

      updateDisplay() {
        super.updateDisplay()
        enableDrag(this._el, this)
      }

      showPallet() {
        this.show()
      }

      show() {
        this._selectedPred = null
        super.show()
        enableDrag(this._el, this)
      }

      showAttribute(pred) {
        this._selectedPred = pred
        this.updateDisplay()
      }

      selectLeftAttributeTab() {
        // Ignore when type is seleceted.
        if (this._selectedPred) {
          // Select type when the first attribute selected.
          if (this._selectedIndex === 0) {
            this.showAttribute()
          } else {
            this.showAttribute(
              this._attributeDefinitions[this._selectedIndex - 1].pred
            )
          }
        }
      }

      selectRightAttributeTab() {
        if (this._selectedPred) {
          // Ignore when the last attribute is selected.
          if (this._selectedIndex === this._attributeDefinitions.length - 1) {
            return
          }

          this.showAttribute(
            this._attributeDefinitions[this._selectedIndex + 1].pred
          )
        } else {
          // Select the first attribute when type selected.
          if (this._attributeDefinitions.length) {
            this.showAttribute(this._attributeDefinitions[0].pred)
          }
        }
      }

      get _selectedIndex() {
        return this._attributeDefinitions.findIndex(
          (attribute) => attribute.pred === this._selectedPred
        )
      }

      get _content() {
        return createContentHtml(
          this._definitionContainer.pallet,
          this._buttonController.diffOfConfiguration,
          this._selectedPred,
          this._selectionModelItems,
          this._typeDefinition.attribute,
          this._attributeModelContainer.all,
          this._typeDefinition.isLock
        )
      }

      get attrDef() {
        return this._typeDefinition.attribute.get(this._selectedPred)
      }

      get _attributeDefinitions() {
        return this._typeDefinition.attribute.attributes
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/AttributeEditor/createNumericAttributeOrShowEditNumericAttributeDialog.js

    /* harmony default export */ function createNumericAttributeOrShowEditNumericAttributeDialog(
      selectionModelItems,
      attrDef,
      commander,
      pallet,
      editTypeValues
    ) {
      const attribute =
        selectionModelItems.findSelectedAttributeWithSamePredicate(attrDef.pred)

      if (attribute) {
        const isOnlyEntityWithJsutOneSamePredSelected =
          selectionModelItems.onlySelectedWithJustOneAttributeOf(attrDef.pred)

        if (isOnlyEntityWithJsutOneSamePredSelected) {
          openEditNumericAttributeDialog(
            selectionModelItems,
            attrDef,
            attribute,
            commander,
            pallet,
            editTypeValues
          )
        } else {
          alertify_default().warning(
            'Some selected items has zero or multi this attribute.'
          )
        }
      } else {
        const command = commander.factory.createAttributeToItemsCommand(
          selectionModelItems.all,
          attrDef
        )
        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/AttributeEditor/createStringAttributeOrShowEditStringAttributeDialog.js

    /* harmony default export */ function createStringAttributeOrShowEditStringAttributeDialog(
      selectionModelItems,
      attrDef,
      commander,
      editTypeValues,
      pallet
    ) {
      const attribute =
        selectionModelItems.findSelectedAttributeWithSamePredicate(attrDef.pred)

      if (attribute) {
        const isOnlyEntityWithJsutOneSamePredSelected =
          selectionModelItems.onlySelectedWithJustOneAttributeOf(attrDef.pred)

        if (isOnlyEntityWithJsutOneSamePredSelected) {
          openEditStringAttributeDialog(
            selectionModelItems,
            attribute,
            commander,
            attrDef,
            editTypeValues,
            pallet
          )
        } else {
          alertify_default().warning(
            'Some selected items has zero or multi this attribute.'
          )
        }
      } else {
        const command = commander.factory.createAttributeToItemsCommand(
          selectionModelItems.all,
          attrDef
        )
        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/AttributeEditor/index.js

    class AttributeEditor {
      constructor(
        commander,
        annotationData,
        selectionModelItems,
        selectionAttributePallet,
        editTypeValues,
        typeValuesPallet
      ) {
        this._commander = commander
        this._annotationData = annotationData
        this._selectionModelItems = selectionModelItems
        this._selectionAttributePallet = selectionAttributePallet
        this._typeDefinition = annotationData.typeDefinition
        this._editTypeValues = editTypeValues
        this._typeValuesPallet = typeValuesPallet
      }

      addOrEditAt(number) {
        this._selectionAttributePallet.hide()

        const attrDef = this._typeDefinition.attribute.getAttributeAt(number)

        if (!attrDef) {
          alertify_default().warning(`Attribute No.${number} is not defined`)
          return
        }

        switch (attrDef.valueType) {
          case 'flag':
            this._commander.invoke(
              this._commander.factory.toggleFlagAttributeToItemsCommand(
                this._selectionModelItems.all,
                attrDef
              )
            )
            break
          case 'numeric':
            createNumericAttributeOrShowEditNumericAttributeDialog(
              this._selectionModelItems,
              attrDef,
              this._commander,
              this._editTypeValues,
              this._typeValuesPallet
            )
            break
          case 'selection':
            {
              if (
                this._selectionModelItems.selectedWithAttributeOf(attrDef.pred)
              ) {
                this._selectionAttributePallet.show(attrDef).then((newObj) => {
                  if (
                    this._selectionModelItems.isDupulicatedPredAttrributeSelected(
                      attrDef.pred
                    )
                  ) {
                    alertify_default().warning(
                      'An item among the selected has this attribute multiple times.'
                    )
                  } else {
                    const command =
                      this._commander.factory.changeAttributeObjOfItemsCommand(
                        this._selectionModelItems.all,
                        attrDef,
                        newObj
                      )
                    this._commander.invoke(command)
                  }
                })
              } else {
                const command =
                  this._commander.factory.createAttributeToItemsCommand(
                    this._selectionModelItems.all,
                    attrDef
                  )
                this._commander.invoke(command)
              }
            }
            break
          case 'string':
            createStringAttributeOrShowEditStringAttributeDialog(
              this._selectionModelItems,
              attrDef,
              this._commander,
              this._editTypeValues,
              this._typeValuesPallet
            )
            break
          default:
            throw `${attrDef.valueType} is unknown attribute`
        }
      }

      deleteAt(number) {
        const attrDef = this._typeDefinition.attribute.getAttributeAt(number)

        if (!attrDef) {
          alertify_default().warning(`Attribute No.${number} is not defined`)
          return
        }

        if (this._selectionModelItems.selectedWithAttributeOf(attrDef.pred)) {
          const command =
            this._commander.factory.removeAttributesFromItemsByPredCommand(
              this._selectionModelItems.all,
              attrDef
            )
          this._commander.invoke(command)
        } else {
          alertify_default().warning(
            'None of the selected items has this attribute.'
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/component/SelectionAttributePallet/template.js

    /* harmony default export */ function SelectionAttributePallet_template(
      context
    ) {
      const { values } = context.attrDef

      return `
  <div>
    <table>
      <tbody>
        <tr>
          <th>id</th>
          <th>label</th>
          <th>color</th>
        </tr>
        ${values
          .map(
            ({ color = '', id, default: defaultValue, label = '' }) =>
              `
        <tr class="textae-editor__pallet__row" style="background-color: ${color};">
          <td class="textae-editor__pallet__selection-attribute-label" data-id="${id}">
            ${id}
            ${
              defaultValue
                ? '<span class="textae-editor__pallet__default-icon" title="This type is set as a default type."></span>'
                : ''
            }
          </td>
          <td class="textae-editor__pallet__short-label">
            ${label}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${color}
          </td>
        </tr>
        `
          )
          .join('\n')}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/SelectionAttributePallet/index.js

    class SelectionAttributePallet extends Pallet {
      constructor(editorHTMLElement) {
        super(editorHTMLElement, 'Selection attribute')

        this._veil = dohtml_default().create(
          `<div style="position: fixed; right: 0; top: 0; bottom:0; left: 0; background-color: rgba(0, 0, 10, 0.3);"></div>`
        )

        // Close the SelectionAttributePallet with the Esc key.
        this._el.addEventListener('keydown', (event) => {
          if (event.code === 'Escape') {
            event.preventDefault()
            this.hide()
          }
        })
      }

      show(attrDef, zIndex = 90, opener = null) {
        this._editorHTMLElement.appendChild(this._veil)
        this._editorHTMLElement.appendChild(this.el)
        this._veil.style['z-index'] = zIndex + 1
        this._el.style['z-index'] = zIndex + 1
        this._attributeDefinition = attrDef
        super.show()

        // Focus on the close button to listen keydown events.
        // Store focusing element to revert focus when closeed.
        this._el.querySelector('.textae-editor__pallet__close-button').focus()
        this._opener = opener

        this._show = true

        return new Promise((resolve) => {
          delegate_default()(
            this._el,
            '.textae-editor__pallet__selection-attribute-label',
            'click',
            (e) => {
              this.hide()
              resolve(e.target.dataset.id)
            }
          )
        })
      }

      hide() {
        if (this._show) {
          this._editorHTMLElement.removeChild(this._veil)
          this._editorHTMLElement.removeChild(this.el)

          this._show = false
        }

        // Focus on the button used to open the palette
        // so that the Entity Edit dialog can be closed with the Esc key.
        if (this._opner) {
          this._opener.focus()
        }
      }

      get _content() {
        const values = {
          attrDef: this._attributeDefinition.JSON
        }
        return SelectionAttributePallet_template(values)
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeValuesDialog/getValues.js

    /* harmony default export */ function getValues(content) {
      const typeName = content.querySelector(
        '.textae-editor__edit-type-values-dialog__type-name'
      ).value

      const label = content.querySelector(
        '.textae-editor__edit-type-values-dialog__type-label'
      ).innerText

      const attributes = []
      for (const attr of content.querySelectorAll(
        '.textae-editor__edit-type-values-dialog__attribute'
      )) {
        attributes.push({
          id: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.id,
          subj: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.subj,
          pred: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-predicate'
          ).dataset.pred,
          obj: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.obj,
          label: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.label
        })
      }

      return { typeName, label, attributes }
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeValuesDialog/createContentHTML/toEntityHTML.js

    /* harmony default export */ function toEntityHTML(value, entityContainer) {
      const label =
        lodash_escape_default()(entityContainer.getLabel(value)) || ''

      return `
    <tr>
      <td rowspan="2"></td>
      <td>
        <span class="textae-editor__edit-type-values-dialog__type-predicate">type</span>
      </td>
      <td class="ui-front">
        <input class="textae-editor__edit-type-values-dialog__type-name textae-editor__promise-daialog__observable-element" value="${value}">
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        <span class="textae-editor__edit-type-values-dialog__type-label">${label}</span>
      </td>
    </tr>
  `
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeValuesDialog/createContentHTML/toAttributeHTML/getLabelOf.js

    /* harmony default export */ function getLabelOf(
      attribute,
      attributeContainer
    ) {
      const { pred, obj } = attribute
      const { valueType } = attributeContainer.get(pred)

      switch (valueType) {
        case 'string':
          // In the case of String attributes,
          // Labels completed by autocomplete can be reflected in attribute definitions.
          // We want to keep the label in the attribute hash until we press the OK button.
          return attribute.label || attributeContainer.getLabel(pred, obj) || ''
        case 'selection':
        case 'numeric':
        case 'flag':
          // In the case of Selection or Numeric or flag attributes,
          // we want to refer only to the label of the attribute definition.
          return attributeContainer.getLabel(pred, obj) || ''
        default:
          throw `unknown attribute type: ${valueType}`
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeValuesDialog/createContentHTML/toAttributeHTML/index.js

    /* harmony default export */ function toAttributeHTML(
      attribute,
      index,
      attributeInstances,
      attributeContainer
    ) {
      const { id, subj, pred, obj } = attribute
      const previousAttribute = attributeInstances[index - 1]
      const previousPredicate = previousAttribute && previousAttribute.pred
      const definitionIndex = attributeContainer.getIndexOf(pred)
      const { valueType } = attributeContainer.get(pred)

      return `
<tr class="textae-editor__edit-type-values-dialog__attribute">
  ${
    pred === previousPredicate
      ? `<td class="shortcut-key" rowspan="2"></td>`
      : `<td class="shortcut-key" rowspan="2">
          ${
            definitionIndex < 9
              ? `<span class="textae-editor__edit-type-values-dialog__shortcut-key" title="Shotcut key for this predicate">${
                  definitionIndex + 1
                }</span>`
              : ''
          }
        </td>
        `
  }
  <td rowspan="2">
    <span
      class="textae-editor__edit-type-values-dialog__attribute-predicate ${
        pred === previousPredicate
          ? ''
          : `textae-editor__edit-type-values-dialog__attribute-predicate--${valueType}`
      }"
      data-pred="${pred}"
      title="${valueType} type"
      >
      ${pred === previousPredicate ? '' : pred}
    </span>
  </td>
  <td>
    <span
      class="textae-editor__edit-type-values-dialog__attribute-value"
      data-id="${id}"
      data-subj="${subj || ''}""
      data-obj="${obj}"
      data-label="${getLabelOf(attribute, attributeContainer)}"
      >
      ${getLabelOf(attribute, attributeContainer) || obj}
    </span>
  </td>
</tr>
<tr>
  <td>
    <button
      type="button"
      class="textae-editor__edit-type-values-dialog__edit-attribute"
      data-pred="${pred}"
      data-index="${index}"
      ${valueType === 'flag' ? 'disabled="disabled"' : ''}>
    </button>
    <button
      type="button" 
      class="textae-editor__edit-type-values-dialog__remove-attribute" 
      data-index="${index}">
    </button>
  </td>
</tr>
`
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeValuesDialog/createContentHTML/index.js

    /* harmony default export */ function createContentHTML(
      typeName,
      attributes,
      entityContainer,
      attributeContainer,
      palletName
    ) {
      return `
    <div style="overflow-y: auto; max-height: 36em; overflow-x: hidden;">
      <table class="textae-editor__edit-type-values-dialog__table">
        <thead>
          <tr>
            <th></th>
            <th>Predicate</th>
            <th>Value/Label</th>
          </tr>
        </thead>
        <tbody>
          ${toEntityHTML(typeName, entityContainer)}
          ${attributes
            .map((a, index, list) =>
              toAttributeHTML(a, index, list, attributeContainer)
            )
            .join('')}
          </tbody>
      </table>
    </div>
    <fieldset>
      <legend>
        <span class="textae-editor__edit-type-values-dialog__open-pallet" title="${palletName} Configuration"></span>
        Available Predicates:
      </legend>
      <div class="textae-editor__edit-type-values-dialog__add-attribute-buttons">
      ${attributeContainer.attributes
        .map(
          ({ pred, valueType }) =>
            `<button
              type="button" 
              class="textae-editor__edit-type-values-dialog__add-attribute textae-editor__edit-type-values-dialog__add-attribute--${valueType}"
              data-pred="${pred}"
              ${
                attributes.some(
                  (i) =>
                    i.pred === pred &&
                    String(i.obj) ===
                      String(attributeContainer.get(pred).default)
                )
                  ? `disabled="disabled" title="This predicate is already used with its default value."`
                  : `title="${valueType} type"`
              }> ${pred}</button>`
        )
        .join(' ')}
      </div>
    </fieldset>
  `
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeValuesDialog/mergedTypeValuesOf.js

    // When you select multiple entities and display the edit dialog,
    // this is used to display the merged type name and attributes.
    /* harmony default export */ function mergedTypeValuesOf(entities) {
      const { typeName } = entities[entities.length - 1]

      const mergedAttributes = []
      for (const { attributes } of entities) {
        for (const attribute of attributes) {
          if (
            !mergedAttributes.some((a) =>
              a.equalsTo(attribute.pred, attribute.obj)
            )
          ) {
            mergedAttributes.push(attribute)
          }
        }
      }

      return new TypeValues(typeName, mergedAttributes)
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeValuesDialog/index.js

    class EditTypeValuesDialog extends PromiseDialog {
      constructor(
        editorHTMLElement,
        annotationType,
        palletName,
        entityContainer,
        attributeContainer,
        autocompletionWs,
        selectedItems,
        typeValuesPallet
      ) {
        const { typeName, attributes } = mergedTypeValuesOf(selectedItems)
        const contentHtml = createContentHTML(
          typeName,
          attributes,
          entityContainer,
          attributeContainer,
          palletName
        )

        super(
          `${annotationType} [${selectedItems
            .map(({ id }) => id)
            .join(',')}] Properties`,
          contentHtml,
          {
            maxWidth: 800
          },
          () => getValues(super.el)
        )

        // Observe edit an attribute button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__edit-attribute',
          'click',
          (e) => {
            const { pred } = e.target.dataset
            const attrDef = attributeContainer.get(pred)
            const zIndex = parseInt(
              super.el.closest('.textae-editor__dialog').style['z-index']
            )
            const { typeName, attributes } = getValues(super.el)

            switch (attrDef.valueType) {
              case 'numeric':
                new EditNumericAttributeDialog(
                  attrDef,
                  attributes[e.target.dataset.index],
                  [attributes[e.target.dataset.index]]
                )
                  .open()
                  .then(({ newObj }) => {
                    attributes[e.target.dataset.index].obj = newObj
                    this._updateDisplay(
                      typeName,
                      attributes,
                      attributeContainer,
                      entityContainer
                    )
                  })
                break
              case 'selection':
                new SelectionAttributePallet(editorHTMLElement)
                  .show(attrDef, zIndex, e.target)
                  .then((newObj) => {
                    attributes[e.target.dataset.index].obj = newObj
                    this._updateDisplay(
                      typeName,
                      attributes,
                      attributeContainer,
                      entityContainer
                    )
                  })
                break
              case 'string':
                new EditStringAttributeDialog(
                  attrDef,
                  attributes[e.target.dataset.index],
                  [attributes[e.target.dataset.index]]
                )
                  .open()
                  .then(({ newObj, newLabel }) => {
                    attributes[e.target.dataset.index].obj = newObj
                    attributes[e.target.dataset.index].label = newLabel
                    this._updateDisplay(
                      typeName,
                      attributes,
                      attributeContainer,
                      entityContainer
                    )
                  })
                break
              default:
                throw `${attrDef.valueType} is unknown attribute.`
            }
          }
        )

        // Observe remove an attribute button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__remove-attribute',
          'click',
          (e) => {
            const { index } = e.target.dataset
            const indexOfAttribute = parseInt(index)
            const { typeName, attributes } = getValues(super.el)
            this._updateDisplay(
              typeName,
              attributes.filter((_, i) => i !== indexOfAttribute),
              attributeContainer,
              entityContainer
            )
          }
        )

        // Observe open pallet button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__open-pallet',
          'click',
          () => {
            super.close()
            typeValuesPallet.show()
          }
        )

        // Observe add an attribute button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__add-attribute',
          'click',
          (e) => {
            const { pred } = e.target.dataset
            const defaultValue = attributeContainer.get(pred).default

            const { typeName, attributes } = getValues(super.el)
            this._updateDisplay(
              typeName,
              attributes
                .concat({ pred, obj: defaultValue, id: '' })
                .sort((a, b) =>
                  attributeContainer.attributeCompareFunction(a, b)
                ),
              attributeContainer,
              entityContainer
            )
          }
        )

        // Setup autocomplete
        const typeNameElement = super.el.querySelector(
          '.textae-editor__edit-type-values-dialog__type-name'
        )
        const typeLabelElement = super.el.querySelector(
          '.textae-editor__edit-type-values-dialog__type-label'
        )
        component_setSourceOfAutoComplete(
          typeNameElement,
          typeLabelElement,
          autocompletionWs,
          (term) => entityContainer.findByLabel(term)
        )
      }

      _updateDisplay(
        typeName,
        attributes,
        attributeContainer,
        entityContainer
      ) {
        const contentHtml = createContentHTML(
          typeName,
          attributes,
          entityContainer,
          attributeContainer
        )
        super.el.closest('.ui-dialog-content').innerHTML = contentHtml
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditDenotation/index.js

    class EditDenotation extends Edit {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationData,
        selectionModel,
        commander,
        buttonController,
        spanConfig,
        autocompletionWs
      ) {
        const denotationPallet = new TypeValuesPallet(
          editorHTMLElement,
          eventEmitter,
          annotationData.typeDefinition,
          annotationData.attribute,
          annotationData.typeDefinition.denotation,
          selectionModel.entity,
          commander,
          'Entity configuration',
          buttonController
        )

        const spanEditor = new SpanEditor(
          editorHTMLElement,
          annotationData,
          selectionModel,
          commander,
          buttonController,
          spanConfig
        )

        const getAutocompletionWs = () =>
          autocompletionWs || annotationData.typeDefinition.autocompletionWs

        super(
          editorHTMLElement,
          selectionModel,
          annotationData,
          denotationPallet,
          commander,
          getAutocompletionWs,
          annotationData.typeDefinition.denotation,
          'entity'
        )

        this._mouseEventHandler = new MouseEventHandler(
          editorHTMLElement,
          annotationData,
          selectionModel,
          denotationPallet,
          spanEditor
        )
        this._spanEdtior = spanEditor
        this._buttonController = buttonController
        this._textBox = editorHTMLElement.querySelector(
          '.textae-editor__text-box'
        )
        this._spanModelContainer = annotationData.span

        this._attributeEditor = new AttributeEditor(
          commander,
          annotationData,
          selectionModel.entity,
          new SelectionAttributePallet(editorHTMLElement),
          () => this.editTypeValues(),
          denotationPallet
        )
      }

      bindMouseEvents() {
        return bindMouseEvents(this._editorHTMLElement, this._mouseEventHandler)
      }

      createSpan() {
        this._spanEdtior.cerateSpanForTouchDevice()
      }

      expandSpan() {
        this._spanEdtior.expandForTouchDevice()
      }

      shrinkSpan() {
        this._spanEdtior.shrinkForTouchDevice()
      }

      applyTextSelection() {
        if (isRangeInTextBox(window.getSelection(), this._textBox)) {
          const selectionWrapper = new SelectionWrapper(
            this._spanModelContainer
          )
          const { begin, end } = new OrderedPositions(
            selectionWrapper.positionsOnAnnotation
          )
          const isSelectionTextCrossingAnySpan =
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )

          this._buttonController.updateManipulateSpanButtons(
            selectionWrapper.isParentOfBothNodesSame,
            isSelectionTextCrossingAnySpan,
            isSelectionTextCrossingAnySpan
          )
        } else {
          this._buttonController.updateManipulateSpanButtons(
            false,
            false,
            false
          )
        }
      }

      editTypeValues() {
        if (this._selectionModel.entity.some) {
          new EditTypeValuesDialog(
            this._editorHTMLelement,
            'Entity',
            'Entity',
            this._definitionContainer,
            this._annotationData.typeDefinition.attribute,
            this._getAutocompletionWs(),
            this._selectionModel.entity.all,
            this.pallet
          )
            .open()
            .then((values) => this._typeValuesChanged(values))
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditBlock/validateNewBlockSpan.js

    /* harmony default export */ function validateNewBlockSpan(
      annotationData,
      begin,
      end,
      spanID
    ) {
      // The span cross exists spans.
      if (annotationData.span.isBoundaryCrossingWithOtherSpans(begin, end)) {
        alertify_default().warning(
          'A span cannot be modifyed to make a boundary crossing.'
        )
        return false
      }

      if (annotationData.span.doesParentOrSameSpanExist(begin, end)) {
        return false
      }

      // There is a BlockSpan that is a child.
      if (
        annotationData.span.hasBlockSpanBetween(begin, end, {
          excluded: spanID
        })
      ) {
        return false
      }

      return true
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditBlock/create.js

    /* harmony default export */ function EditBlock_create(
      annotationData,
      commander,
      spanAdjuster,
      selectionWrapper,
      spanConfig
    ) {
      const { begin, end } = getNewSpan(
        annotationData.sourceDoc,
        spanAdjuster,
        selectionWrapper,
        spanConfig
      )

      if (validateNewBlockSpan(annotationData, begin, end)) {
        const command = commander.factory.createBlockSpanCommand({
          begin,
          end
        })

        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditBlock/SpanEditor.js

    class SpanEditor_SpanEditor {
      constructor(
        editorHTMLElement,
        annotationData,
        spanConfig,
        commander,
        buttonController,
        selectionModel
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._annotationData = annotationData
        this._spanConfig = spanConfig
        this._commander = commander
        this._buttonController = buttonController
        this._selectionModel = selectionModel
      }

      /**
       *
       * @param {SelectionWrapper} selectionWrapper
       */
      editFor(selectionWrapper) {
        if (selectionWrapper.isParentOfAnchorNodeTextBox) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._create(selectionWrapper)
            return
          }

          if (
            selectionWrapper.isParentOfFocusNodeDenotationSpan ||
            selectionWrapper.isParentOfFocusNodeStyleSpan
          ) {
            if (selectionWrapper.ancestorBlockSpanOfFocusNode) {
              this._shrink(selectionWrapper)
            } else {
              this._create(selectionWrapper)
            }

            return
          }

          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._shrink(selectionWrapper)
            return
          }
        }

        if (
          selectionWrapper.isParentOfAnchorNodeDenotationSpan ||
          selectionWrapper.isParentOfAnchorNodeStyleSpan
        ) {
          if (
            selectionWrapper.isParentOfFocusNodeTextBox ||
            selectionWrapper.isParentOfFocusNodeDenotationSpan ||
            selectionWrapper.isParentOfFocusNodeStyleSpan
          ) {
            if (selectionWrapper.ancestorBlockSpanOfAnchorNode) {
              if (selectionWrapper.doesFitInOneBlockSpan) {
                const { anchor, focus } = selectionWrapper.positionsOnAnnotation
                const spanOnAnchor = this._annotationData.span.get(
                  selectionWrapper.parentOfAnchorNode.id
                )
                const blockSpanOnAnchor = this._annotationData.span.get(
                  selectionWrapper.ancestorBlockSpanOfAnchorNode.id
                )

                if (
                  anchor < focus &&
                  spanOnAnchor.begin === blockSpanOnAnchor.begin
                ) {
                  this._shrink(selectionWrapper)
                } else if (
                  focus < anchor &&
                  spanOnAnchor.end === blockSpanOnAnchor.end
                ) {
                  this._shrink(selectionWrapper)
                } else {
                  clearTextSelection()
                }
              } else {
                // Expand when the selection exceeds a single block span.
                this._expand(selectionWrapper)
              }
            } else if (selectionWrapper.ancestorBlockSpanOfFocusNode) {
              this._shrink(selectionWrapper)
            } else {
              this._create(selectionWrapper)
            }

            return
          }

          // When collapsing a block containing the beginning or end of the text,
          // and also when the beginning or end of the text is a denotation or style span,
          // the anchor node is within the denotation or style span.
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._shrink(selectionWrapper)
            return
          }
        }

        if (selectionWrapper.isParentOfAnchorNodeBlockSpan) {
          if (
            selectionWrapper.isParentOfFocusNodeTextBox ||
            selectionWrapper.isParentOfFocusNodeDenotationSpan ||
            selectionWrapper.isParentOfFocusNodeStyleSpan
          ) {
            if (selectionWrapper.ancestorBlockSpanOfFocusNode) {
              this._shrink(selectionWrapper)
            } else {
              this._expand(selectionWrapper)
            }

            return
          }

          // When you shrink a block containing the beginning or end of the text,
          // the anchor node is in the block.
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            const { anchor } = selectionWrapper.positionsOnAnnotation
            const blockSpanOnFocus = this._annotationData.span.get(
              selectionWrapper.parentOfFocusNode.id
            )

            // Shrink the block span
            // only when the anchor position matches the begin or end position of the block span.
            if (
              anchor === blockSpanOnFocus.begin ||
              anchor === blockSpanOnFocus.end
            ) {
              this._shrink(selectionWrapper)
              return
            }
          }
        }

        clearTextSelection()
      }

      cerateSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._annotationData.span)

        if (selectionWrapper.isParentOfBothNodesTextBox) {
          this._create(selectionWrapper)
        }
      }

      expandForTouchDevice() {
        const expandedSpan = this._getExpandedSpanForTouchDevice()
        if (expandedSpan) {
          const { spanID, begin, end } = expandedSpan

          if (validateNewBlockSpan(this._annotationData, begin, end, spanID)) {
            this._commander.invoke(
              this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
            )
          }
        }
      }

      shrinkForTouchDevice() {
        const shrinkedSpan = this._getShrinkedSpanForTouchDevice()
        if (shrinkedSpan) {
          const { spanID, begin, end } = shrinkedSpan
          const nextSpan = getRightSpanElement(this._editorHTMLElement, spanID)

          // The span cross exists spans.
          if (
            this._annotationData.span.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )
          ) {
            alertify_default().warning(
              'A span cannot be modifyed to make a boundary crossing.'
            )
            return
          }

          // There is parant span.
          if (this._annotationData.span.hasParentOf(begin, end, spanID)) {
            return
          }

          const doesExists = this._annotationData.span.hasBlockSpan(begin, end)
          if (begin < end && !doesExists) {
            this._commander.invoke(
              this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
            )
          } else {
            this._commander.invoke(
              this._commander.factory.removeSpanCommand(spanID)
            )
            if (nextSpan) {
              this._selectionModel.selectSpan(nextSpan.id)
            }
          }
        }
      }

      _create(selectionWrapper) {
        if (
          hasCharacters(
            this._annotationData.sourceDoc,
            this._spanConfig,
            selectionWrapper
          )
        ) {
          this._selectionModel.removeAll()
          EditBlock_create(
            this._annotationData,
            this._commander,
            this._buttonController.spanAdjuster,
            selectionWrapper,
            this._spanConfig
          )
        }
        clearTextSelection()
      }

      _expand(selectionWrapper) {
        const spanID = selectionWrapper.ancestorBlockSpanOfAnchorNode.id

        this._selectionModel.removeAll()

        const { begin, end } = this._annotationData.span
          .get(spanID)
          .getExpandedInAnchorNodeToFocusNodeDirection(
            this._buttonController.spanAdjuster,
            selectionWrapper,
            this._annotationData.sourceDoc,
            this._spanConfig
          )

        if (validateNewBlockSpan(this._annotationData, begin, end, spanID)) {
          this._commander.invoke(
            this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
          )
        }

        clearTextSelection()
      }

      _shrink(selectionWrapper) {
        const spanID = selectionWrapper.ancestorBlockSpanOfFocusNode.id

        shrinkSpan(
          this._editorHTMLElement,
          this._annotationData.span,
          this._annotationData.sourceDoc,
          this._selectionModel,
          this._commander,
          this._buttonController.spanAdjuster,
          spanID,
          selectionWrapper,
          this._spanConfig,
          (begin, end) => {
            this._commander.invoke(
              this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
            )
          }
        )

        clearTextSelection()
      }

      _getExpandedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._annotationData.span)

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to expand does not exist.
        if (
          selectionWrapper.ancestorBlockSpanOfAnchorNode == null &&
          selectionWrapper.ancestorBlockSpanOfFocusNode == null
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.parentOfAnchorNode.id

          return {
            spanID,
            ...this._annotationData.span
              .get(spanID)
              .getExpandedInAnchorNodeToFocusNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.parentOfFocusNode.id

          return {
            spanID,
            ...this._annotationData.span
              .get(spanID)
              .getExpandedInFocusNodeToAnchorNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }
      }

      _getShrinkedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._annotationData.span)

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to shrink does not exist.
        if (
          selectionWrapper.ancestorBlockSpanOfAnchorNode == null &&
          selectionWrapper.ancestorBlockSpanOfFocusNode == null
        ) {
          return null
        }

        // On mobile devices,
        // do not shrink the block span when the selected text fits into one block span.
        if (
          selectionWrapper.parentOfAnchorNode ===
          selectionWrapper.parentOfFocusNode
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.parentOfAnchorNode.id

          return {
            spanID,
            ...this._annotationData.span
              .get(spanID)
              .getShortenInFocusNodeToAnchorNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.parentOfFocusNode.id

          return {
            spanID,
            ...this._annotationData.span
              .get(spanID)
              .getShotrenInAnchorNodeToFocusNodeDirection(
                this._buttonController.spanAdjuster,
                selectionWrapper,
                this._annotationData.sourceDoc,
                this._spanConfig
              )
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditBlock/bindMouseEvents.js

    /* harmony default export */ function EditBlock_bindMouseEvents(
      editorHTMLElement,
      mouseEventHandler
    ) {
      const listeners = []

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__text-box',
          'click',
          (e) => {
            if (e.target.classList.contains('textae-editor__text-box')) {
              mouseEventHandler.textBoxClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor',
          'click',
          (e) => {
            // The delegate also fires events for child elements of the selector.
            // Ignores events that occur in child elements.
            // Otherwise, you cannot select child elements.
            if (e.target.classList.contains('textae-editor')) {
              mouseEventHandler.bodyClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard',
          'mousedown',
          () => mouseEventHandler.signboardClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard__type-values',
          'click',
          (event) => {
            const entityID = getEntityHTMLelementFromChild(event.target).dataset
              .id
            mouseEventHandler.typeValuesClicked(event, entityID)
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__block',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__block')) {
              mouseEventHandler.blockSpanClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__block-hit-area',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__block-hit-area')) {
              mouseEventHandler.blockHitAreaClicked(e)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__style',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__style')) {
              mouseEventHandler.styleSpanClicked(e)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__span',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__span')) {
              mouseEventHandler.denotationSpanClicked(e)
            }
          }
        )
      )

      return listeners
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditBlock/MouseEventHandler.js

    class MouseEventHandler_MouseEventHandler {
      /**
       *
       * @param {import('./SpanEditor').default} spanEditor
       */
      constructor(
        editorHTMLElement,
        annotationData,
        selectionModel,
        spanEditor,
        pallet
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._annotationData = annotationData
        this._selectionModel = selectionModel
        this._spanEditor = spanEditor
        this._pallet = pallet
      }

      bodyClicked() {
        this._pallet.hide()
        this._selectionModel.removeAll()
      }

      textBoxClicked() {
        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          this._pallet.hide()
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
        }
      }

      blockSpanClicked() {
        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          this._pallet.hide()
          clearTextSelection()
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
        }
      }

      // Mouse events to the block span are handled by the hit area instead,
      // to show the block span shifted up half a line.
      blockHitAreaClicked(e) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (e.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        // When you create a block span and
        // click on another block span while holding down the Shift key,
        // the Selection type will be 'None'.
        if (selection.type === 'Caret' || selection.type === 'None') {
          const spanId = e.target.dataset.id

          this._selectSpanAndEntity(e, spanId)
        }
      }

      styleSpanClicked(e) {
        const selection = window.getSelection()
        if (selection.type === 'Caret') {
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
          e.stopPropagation()
        }
      }

      denotationSpanClicked(e) {
        const selection = window.getSelection()
        if (selection.type === 'Caret') {
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationData.span)
          )
          e.stopPropagation()
        }
      }

      signboardClicked() {
        this._editorHTMLElement.focus()
      }

      typeValuesClicked(event, entityID) {
        const entity = this._annotationData.entity.get(entityID)

        if (entity.isBlock) {
          if (event.ctrlKey || event.metaKey) {
            this._selectionModel.entity.toggle(entityID)
          } else {
            this._selectionModel.selectEntity(entityID)
          }

          // Select span of the selected entity.
          for (const { span } of this._selectionModel.entity.all) {
            this._selectionModel.span.add(span.id)
          }
        }
      }

      _selectSpanAndEntity(event, spanID) {
        const selectedSpanID = this._selectionModel.span.singleId
        const rangeOfSpans =
          event.shiftKey && selectedSpanID
            ? this._annotationData.span.rangeBlockSpan(selectedSpanID, spanID)
            : []

        selectSpan(this._selectionModel, rangeOfSpans, event, spanID)

        // Select entities of the selected span.
        for (const { entities } of this._selectionModel.span.all) {
          // Block span has just one entity.
          this._selectionModel.entity.add(entities[0].id)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditBlock/index.js

    class EditBlock extends Edit {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationData,
        selectionModel,
        spanConfig,
        commander,
        buttonController,
        autocompletionWs
      ) {
        const spanEditor = new SpanEditor_SpanEditor(
          editorHTMLElement,
          annotationData,
          spanConfig,
          commander,
          buttonController,
          selectionModel
        )

        const blockPallet = new TypeValuesPallet(
          editorHTMLElement,
          eventEmitter,
          annotationData.typeDefinition,
          annotationData.attribute,
          annotationData.typeDefinition.block,
          selectionModel.entity,
          commander,
          'Entity configuration',
          buttonController
        )

        const getAutocompletionWs = () =>
          autocompletionWs || annotationData.typeDefinition.autocompletionWs

        super(
          editorHTMLElement,
          selectionModel,
          annotationData,
          blockPallet,
          commander,
          getAutocompletionWs,
          annotationData.typeDefinition.block,
          'entity'
        )

        this._mouseEventHandler = new MouseEventHandler_MouseEventHandler(
          editorHTMLElement,
          annotationData,
          selectionModel,
          spanEditor,
          blockPallet
        )
        this._spanEdtior = spanEditor
        this._buttonController = buttonController
        this._textBox = editorHTMLElement.querySelector(
          '.textae-editor__text-box'
        )
        this._spanModelContainer = annotationData.span

        this._attributeEditor = new AttributeEditor(
          commander,
          annotationData,
          selectionModel.entity,
          new SelectionAttributePallet(editorHTMLElement),
          () => this.editTypeValues(),
          blockPallet
        )
      }

      bindMouseEvents() {
        return EditBlock_bindMouseEvents(
          this._editorHTMLElement,
          this._mouseEventHandler
        )
      }

      createSpan() {
        this._spanEdtior.cerateSpanForTouchDevice()
      }

      expandSpan() {
        this._spanEdtior.expandForTouchDevice()
      }

      shrinkSpan() {
        this._spanEdtior.shrinkForTouchDevice()
      }

      applyTextSelection() {
        if (isRangeInTextBox(window.getSelection(), this._textBox)) {
          const selectionWrapper = new SelectionWrapper(
            this._spanModelContainer
          )
          const { begin, end } = new OrderedPositions(
            selectionWrapper.positionsOnAnnotation
          )
          const isSelectionTextCrossingAnySpan =
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )

          this._buttonController.updateManipulateSpanButtons(
            selectionWrapper.isParentOfBothNodesTextBox,
            isSelectionTextCrossingAnySpan,
            isSelectionTextCrossingAnySpan
          )
        } else {
          this._buttonController.updateManipulateSpanButtons(
            false,
            false,
            false
          )
        }
      }

      editTypeValues() {
        if (this._selectionModel.entity.some) {
          new EditTypeValuesDialog(
            this._editorHTMLElement,
            'Block',
            'Entity',
            this._definitionContainer,
            this._annotationData.typeDefinition.attribute,
            this._getAutocompletionWs(),
            this._selectionModel.entity.all,
            this.pallet
          )
            .open()
            .then((values) => this._typeValuesChanged(values))
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditRelation/bindMouseEvents.js

    // Manupulate only entities and relations on the Edit Relation mode.
    // For support context menu.
    // Mouse up event occurs when either left or right button is clicked.
    // Change mouse events to monitor from mouseup to click since v5.0.0.
    /* harmony default export */ function EditRelation_bindMouseEvents(
      editorHTMLElement,
      mouseEventHandler
    ) {
      const listeners = []

      // In relation mode does not manipulate the child elements in the text box.
      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__text-box',
          'click',
          () => mouseEventHandler.bodyClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor',
          'click',
          (e) => {
            // The delegate also fires events for child elements of the selector.
            // Ignores events that occur in child elements.
            // Otherwise, you cannot select child elements.
            if (e.target.classList.contains('textae-editor')) {
              mouseEventHandler.bodyClicked()
            }
          }
        )
      )

      listeners.push(
        // When a relation is selected, the HTML element of the relation is recreated,
        // so the click event is not fired on the parent element.
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard',
          'mousedown',
          () => mouseEventHandler.signboardClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard__type-values',
          'click',
          (event) => {
            const entityID = getEntityHTMLelementFromChild(event.target).dataset
              .id
            mouseEventHandler.typeValuesClicked(event, entityID)
          }
        )
      )

      return listeners
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditRelation/MouseEventHandler/typeValuesClicked/updateSelectionOfEntity.js

    /* harmony default export */ function updateSelectionOfEntity(
      event,
      selectionModel,
      subjectEntityId,
      objectEntityId
    ) {
      if (event.ctrlKey || event.metaKey) {
        // Remaining selection of the subject entity.
        selectionModel.remove(objectEntityId)
      } else if (event.shiftKey) {
        selectionModel.remove(subjectEntityId)
        selectionModel.add(objectEntityId)
      } else {
        selectionModel.remove(subjectEntityId)
        selectionModel.remove(objectEntityId)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditRelation/MouseEventHandler/typeValuesClicked/index.js

    /* harmony default export */ function typeValuesClicked(
      selectionModel,
      commander,
      relationDefinitionContainer,
      event,
      entityID
    ) {
      if (!selectionModel.entity.some) {
        selectionModel.selectEntity(entityID)
      } else {
        const subjectEntityId = selectionModel.entity.singleId
        const objectEntityId = entityID

        // Cannot make a self reference relation.
        if (subjectEntityId === objectEntityId) {
          selectionModel.entity.toggle(subjectEntityId)
        } else {
          commander.invoke(
            commander.factory.createRelationCommand({
              subj: subjectEntityId,
              obj: objectEntityId,
              pred: relationDefinitionContainer.defaultType
            })
          )

          updateSelectionOfEntity(
            event,
            selectionModel.entity,
            subjectEntityId,
            objectEntityId
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditRelation/MouseEventHandler/index.js

    class EditRelation_MouseEventHandler_MouseEventHandler {
      constructor(
        editorHTMLElement,
        selectionModel,
        commander,
        typeDefinition,
        pallet
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
        this._commander = commander
        this._typeDefinition = typeDefinition
        this._pallet = pallet
      }

      bodyClicked() {
        this._pallet.hide()
        this._selectionModel.removeAll()
      }

      signboardClicked() {
        this._editorHTMLElement.focus()
      }

      typeValuesClicked(event, entityID) {
        typeValuesClicked(
          this._selectionModel,
          this._commander,
          this._typeDefinition.relation,
          event,
          entityID
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/EditRelation/index.js

    class EditRelation extends Edit {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationData,
        selectionModel,
        commander,
        autocompletionWs,
        buttonController
      ) {
        const relationPallet = new TypeValuesPallet(
          editorHTMLElement,
          eventEmitter,
          annotationData.typeDefinition,
          annotationData.attribute,
          annotationData.typeDefinition.relation,
          selectionModel.relation,
          commander,
          'Relation configuration',
          buttonController
        )

        const getAutocompletionWs = () =>
          autocompletionWs || annotationData.typeDefinition.autocompletionWs

        super(
          editorHTMLElement,
          selectionModel,
          annotationData,
          relationPallet,
          commander,
          getAutocompletionWs,
          annotationData.typeDefinition.relation,
          'relation'
        )

        this._editorHTMLElement = editorHTMLElement
        this._mouseEventHandler =
          new EditRelation_MouseEventHandler_MouseEventHandler(
            editorHTMLElement,
            selectionModel,
            commander,
            annotationData.typeDefinition,
            relationPallet
          )
        this._buttonController = buttonController
        this._attributeEditor = new AttributeEditor(
          commander,
          annotationData,
          selectionModel.relation,
          new SelectionAttributePallet(editorHTMLElement),
          () => this.editTypeValues(),
          relationPallet
        )
      }

      bindMouseEvents() {
        return EditRelation_bindMouseEvents(
          this._editorHTMLElement,
          this._mouseEventHandler
        )
      }

      applyTextSelection() {
        this._buttonController.updateManipulateSpanButtons(false, false, false)
      }

      editTypeValues() {
        if (this._selectionModel.relation.some) {
          new EditTypeValuesDialog(
            this._editorHTMLElement,
            'Relation',
            'Relation',
            this._definitionContainer,
            this._annotationData.typeDefinition.attribute,
            this._getAutocompletionWs(),
            this._selectionModel.relation.all,
            this.pallet
          )
            .open()
            .then((values) => this._typeValuesChanged(values))
        }
      }

      relationClicked(event, relation) {
        if (event.ctrlKey || event.metaKey) {
          this._selectionModel.relation.toggle(relation.id)
        } else {
          this._selectionModel.selectRelation(relation.id)
        }
      }

      typeValuesClicked(event, entity) {
        this._selectionModel.selectEntity(entity.id)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/Transition/EditorCSSClassForMode.js

    class EditorCSSClassForMode {
      constructor(editorHTMLElement) {
        this._editorHTMLElement = editorHTMLElement
      }

      setViewWithRelation() {
        this._setCssClassFor('view-with-relation')
      }

      setViewWithoutRelation() {
        this._setCssClassFor('view-without-relation')
      }

      setDenotationWithRelation() {
        this._setCssClassFor('denotation-with-relation')
      }

      setDenotationWithoutRelation() {
        this._setCssClassFor('denotation-without-relation')
      }

      setBlockWithRelation() {
        this._setCssClassFor('block-with-relation')
      }

      setBlockWithoutRelation() {
        this._setCssClassFor('block-without-relation')
      }

      setRelation() {
        this._setCssClassFor('relation')
      }

      _setCssClassFor(mode) {
        for (const cssClass of this._editorHTMLElement.classList) {
          if (cssClass.startsWith('textae-editor__mode')) {
            this._editorHTMLElement.classList.remove(cssClass)
          }
        }

        this._editorHTMLElement.classList.add(`textae-editor__mode--${mode}`)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/Transition/index.js

    class Transition {
      constructor(
        eventEmitter,
        editorHTMLElement,
        typeGap,
        noEdit,
        editEntity,
        editBlock,
        editRelation
      ) {
        this._eventEmitter = eventEmitter
        this._editorCSSClassForMode = new EditorCSSClassForMode(
          editorHTMLElement
        )
        this._typeGap = typeGap
        this._noEdit = noEdit
        this._editEntity = editEntity
        this._editBlock = editBlock
        this._editRelation = editRelation
      }

      toViewWithoutRelation() {
        this._typeGap.show = false
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          MODE.VIEW_WITHOUT_RELATION
        )

        this._noEdit()
        this._editorCSSClassForMode.setViewWithoutRelation()
      }

      toViewWithRelation() {
        this._typeGap.show = true
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          MODE.VIEW_WITH_RELATION
        )

        this._noEdit()
        this._editorCSSClassForMode.setViewWithRelation()
      }

      toEditDenotationWithoutRelation() {
        this._typeGap.show = false
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          MODE.EDIT_DENOTATION_WITHOUT_RELATION
        )

        this._noEdit()
        this._editEntity()
        this._editorCSSClassForMode.setDenotationWithoutRelation()
      }

      toEditDenotationWithRelation() {
        this._typeGap.show = true
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          MODE.EDIT_DENOTATION_WITH_RELATION
        )

        this._noEdit()
        this._editEntity()
        this._editorCSSClassForMode.setDenotationWithRelation()
      }

      toEditBlockWithoutRelation() {
        this._typeGap.show = false
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          MODE.EDIT_BLOCK_WITHOUT_RELATION
        )

        this._noEdit()
        this._editBlock()
        this._editorCSSClassForMode.setBlockWithoutRelation()
      }

      toEditBlockWithRelation() {
        this._typeGap.show = true
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          MODE.EDIT_BLOCK_WITH_RELATION
        )

        this._noEdit()
        this._editBlock()
        this._editorCSSClassForMode.setBlockWithRelation()
      }

      toEditRelation() {
        this._typeGap.show = true
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          MODE.EDIT_RELATION
        )

        this._noEdit()
        this._editRelation()
        this._editorCSSClassForMode.setRelation()
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/EditMode/index.js

    class EditMode {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationData,
        selectionModel,
        spanConfig,
        commander,
        buttonController,
        autocompletionWs
      ) {
        this._editDenotation = new EditDenotation(
          editorHTMLElement,
          eventEmitter,
          annotationData,
          selectionModel,
          commander,
          buttonController,
          spanConfig,
          autocompletionWs
        )

        this._editBlock = new EditBlock(
          editorHTMLElement,
          eventEmitter,
          annotationData,
          selectionModel,
          spanConfig,
          commander,
          buttonController,
          autocompletionWs
        )

        this._editRelation = new EditRelation(
          editorHTMLElement,
          eventEmitter,
          annotationData,
          selectionModel,
          commander,
          autocompletionWs,
          buttonController
        )

        this._listeners = []

        const transition = new Transition(
          eventEmitter,
          editorHTMLElement,
          annotationData.typeGap,
          () => {
            this.cancelSelect()
            this._unbindAllMouseEventhandler()
          },
          () => (this._listeners = this._editDenotation.bindMouseEvents()),
          () => (this._listeners = this._editBlock.bindMouseEvents()),
          () => (this._listeners = this._editRelation.bindMouseEvents())
        )
        this._stateMachine = new StateMachine(
          annotationData.relation,
          transition
        )

        this._annotationData = annotationData
        this._selectionModel = selectionModel

        eventEmitter
          .on('textae-event.editor.relation.click', (event, relation) =>
            this.currentEdit.relationClicked(event, relation)
          )
          .on('textae-event.editor.relation-bollard.click', (event, entity) =>
            this.currentEdit.typeValuesClicked(event, entity)
          )
      }

      get stateMachine() {
        return this._stateMachine
      }

      get isEditDenotation() {
        return (
          this._stateMachine.currentState ===
            MODE.EDIT_DENOTATION_WITH_RELATION ||
          this._stateMachine.currentState ===
            MODE.EDIT_DENOTATION_WITHOUT_RELATION
        )
      }

      // For an intiation transition on an annotations data loaded.
      forView() {
        if (this._annotationData.relation.some) {
          this._stateMachine.setState(MODE.VIEW_WITH_RELATION)
        } else {
          this._stateMachine.setState(MODE.VIEW_WITHOUT_RELATION)
        }
      }

      forEditable() {
        if (this._annotationData.relation.some) {
          this._stateMachine.setState(MODE.EDIT_DENOTATION_WITH_RELATION)
        } else {
          this._stateMachine.setState(MODE.EDIT_DENOTATION_WITHOUT_RELATION)
        }
      }

      cancelSelect() {
        // Close all pallets.
        this._editDenotation.pallet.hide()
        this._editBlock.pallet.hide()
        this._editRelation.pallet.hide()

        this._selectionModel.removeAll()
      }

      get isTypeValuesPalletShown() {
        return (
          this._editDenotation.pallet.visibly ||
          this._editBlock.pallet.visibly ||
          this._editRelation.pallet.visibly
        )
      }

      selectLeftAttributeTab() {
        this.currentEdit.pallet.selectLeftAttributeTab()
      }

      selectRightAttributeTab() {
        this.currentEdit.pallet.selectRightAttributeTab()
      }

      get currentEdit() {
        switch (this._stateMachine.currentState) {
          case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
          case MODE.EDIT_DENOTATION_WITH_RELATION:
            return this._editDenotation
          case MODE.EDIT_BLOCK_WITHOUT_RELATION:
          case MODE.EDIT_BLOCK_WITH_RELATION:
            return this._editBlock
          case MODE.EDIT_RELATION:
            return this._editRelation
          default:
            return {
              showPallet() {},
              selectLeftAttributeTab() {},
              selectRightAttributeTab() {},
              editTypeValues() {},
              manipulateAttribute() {},
              relationClicked() {},
              typeValuesClicked(_, entity) {
                entity.focus()
              },
              applyTextSelection() {}
            }
        }
      }

      _unbindAllMouseEventhandler() {
        for (const listner of this._listeners) {
          listner.destroy()
        }
        this._listeners = []
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/Horizontal.js

    class Horizontal {
      constructor(editorHTMLElement, selectionModel) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
      }

      left(shiftKey) {
        const nextSpan = this._searchLeft('.textae-editor__span')
        if (nextSpan) {
          if (shiftKey) {
            this._selectionModel.span.add(nextSpan.id)
          } else {
            this._selectionModel.selectSpan(nextSpan.id)
          }
          return
        }

        const nextEntity = this._searchLeft(
          '.textae-editor__grid .textae-editor__signboard'
        )
        if (nextEntity) {
          if (shiftKey) {
            this._selectionModel.entity.add(nextEntity.dataset.id)
          } else {
            this._selectionModel.selectEntity(nextEntity.dataset.id)
          }
        }
      }

      right(shiftKey) {
        const nextSpan = this._searchRight('.textae-editor__span')
        if (nextSpan) {
          if (shiftKey) {
            this._selectionModel.span.add(nextSpan.id)
          } else {
            this._selectionModel.selectSpan(nextSpan.id)
          }
          return
        }

        const nextEntity = this._searchRight(
          '.textae-editor__grid .textae-editor__signboard'
        )
        if (nextEntity) {
          if (shiftKey) {
            this._selectionModel.entity.add(nextEntity.dataset.id)
          } else {
            this._selectionModel.selectEntity(nextEntity.dataset.id)
          }
        }
      }

      _searchLeft(selector) {
        const elements = this._editorHTMLElement.querySelectorAll(selector)
        const firstSelectedIndex = [...elements].findIndex(
          (el) =>
            el.classList.contains('ui-selected') ||
            el.classList.contains('textae-editor__signboard--selected')
        )

        if (firstSelectedIndex > 0) {
          return elements[firstSelectedIndex - 1]
        }
      }

      _searchRight(selector) {
        const elements = this._editorHTMLElement.querySelectorAll(selector)
        const lastSelectedIndex = [...elements]
          .reverse()
          .findIndex(
            (el) =>
              el.classList.contains('ui-selected') ||
              el.classList.contains('textae-editor__signboard--selected')
          )

        if (elements.length - lastSelectedIndex > 0) {
          return elements[elements.length - lastSelectedIndex]
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/Vertical.js

    class Vertical {
      constructor(editorHTMLElement, selectionModel) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
      }

      up() {
        // When one span is selected.
        if (this._selectionModel.span.single) {
          const grid = this._selectionModel.span.single.gridElement
          const entity = grid.querySelector('.textae-editor__signboard')
          this._selectionModel.selectEntity(entity.dataset.id)
        }
      }

      down() {
        const selectedEntityHtmlelement = this._editorHTMLElement.querySelector(
          '.textae-editor__signboard--selected'
        )

        if (selectedEntityHtmlelement) {
          const spanId = selectedEntityHtmlelement
            .closest('.textae-editor__grid')
            .id.substring(1)

          this._selectionModel.selectSpan(spanId)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/debounce300.js

    /* harmony default export */ function debounce300(func) {
      return debounce_default()(func, 300)
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/bindChangeLockConfig.js

    /* harmony default export */ function bindChangeLockConfig(
      content,
      typeDefinition
    ) {
      delegate_default()(
        content,
        '.textae-editor__setting-dialog__lock-config-text',
        'change',
        debounce300((e) => {
          if (e.target.checked) {
            typeDefinition.lockEdit()
          } else {
            typeDefinition.unlockEdit()
          }
        })
      )
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/redrawAllEditor.js

    // Redraw all editors in tha windows.
    function redrawAllEditor() {
      const event = new Event('resize')
      window.dispatchEvent(event)
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/bindChangeLineHeight.js

    /* harmony default export */ function bindChangeLineHeight(
      content,
      textBox
    ) {
      delegate_default()(
        content,
        '.textae-editor__setting-dialog__line-height-text',
        'change',
        debounce300((e) => {
          textBox.lineHeight = e.target.value
          redrawAllEditor()
        })
      )
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/bindChangeTypeGap.js

    /* harmony default export */ function bindChangeTypeGap(
      content,
      typeGap,
      textBox
    ) {
      delegate_default()(
        content,
        '.textae-editor__setting-dialog__type-gap-text',
        'change',
        debounce300((e) => {
          typeGap.value = Number(e.target.value)
          content.querySelector(
            '.textae-editor__setting-dialog__line-height-text'
          ).value = textBox.lineHeight
        })
      )
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/index.js

    /* harmony default export */ function reflectImmediately(
      content,
      typeGap,
      typeDefinition,
      textBox
    ) {
      bindChangeTypeGap(content, typeGap, textBox)
      bindChangeLineHeight(content, textBox)
      bindChangeLockConfig(content, typeDefinition)
    } // CONCATENATED MODULE: ./package.json

    const package_namespaceObject = { i8: '9.0.2' } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/index.js
    function SettingDialog_template(context) {
      const {
        typeGap,
        typeGapDisabled,
        lineHeight,
        typeDefinitionLocked,
        version
      } = context

      return `
<div class="textae-editor__setting-dialog__container">
  <div class="textae-editor__setting-dialog__row">
    <label>Type Gap</label>
    <input 
      type="number" 
      class="textae-editor__setting-dialog__type-gap-text" 
      step="1" 
      min="0" 
      max="5" 
      value="${typeGap}" ${typeGapDisabled ? `disabled="disabled"` : ''}>
  </div>
  <div class="textae-editor__setting-dialog__row">
    <label>Line Height(px)</label>
    <input 
      type="number" class="textae-editor__setting-dialog__line-height-text" 
      step="1" 
      min="50" 
      max="500" 
      value="${lineHeight}">
  </div>
  <div class="textae-editor__setting-dialog__row">
    <label>
      <input 
        type="checkbox" 
        class="textae-editor__setting-dialog__lock-config-text"
        ${typeDefinitionLocked ? `checked="checked"` : ''}>
      Lock Edit Config
    </label>
  </div>
  <div class="textae-editor__setting-dialog__row">
    <label>Version ${version}</label>
  </div>
</div>
`
    }

    class SettingDialog extends Dialog {
      constructor(typeDefinition, typeGap, textBox) {
        const contentHtml = SettingDialog_template({
          typeGapDisabled: !typeGap.show,
          typeGap: typeGap.value,
          lineHeight: textBox.lineHeight,
          typeDefinitionLocked: typeDefinition.isLock,
          version: package_namespaceObject.i8
        })

        super('Setting', contentHtml)

        // Reflects configuration changes in real time.
        reflectImmediately(super.el, typeGap, typeDefinition, textBox)

        // Observe enter key press
        delegate_default()(super.el, `.textae-editor__dialog`, 'keyup', (e) => {
          if (e.keyCode === 13) {
            super.close()
          }
        })
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/Presenter/index.js

    class Presenter {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationData,
        selectionModel,
        commander,
        spanConfig,
        clipBoard,
        buttonController,
        autocompletionWs,
        mode
      ) {
        const editMode = new EditMode(
          editorHTMLElement,
          eventEmitter,
          annotationData,
          selectionModel,
          spanConfig,
          commander,
          buttonController,
          autocompletionWs
        )

        eventEmitter
          .on('textae-event.annotation-data.all.change', (_, multitrack) => {
            if (mode !== 'edit') {
              editMode.forView()
            } else {
              if (multitrack) {
                alertify_default().success(
                  'track annotations have been merged to root annotations.'
                )
              }
              editMode.forEditable()
            }
          })
          .on('textae-event.edit-mode.transition', (mode) => {
            switch (mode) {
              case MODE.VIEW_WITHOUT_RELATION:
              case MODE.VIEW_WITH_RELATION:
                annotationData.entity.clarifyLabelOfAll()
                break
              default:
                annotationData.entity.declarifyLabelOfAll()
            }
          })

        this._editorHTMLElement = editorHTMLElement
        this._eventEmitter = eventEmitter
        this._commander = commander
        this._selectionModel = selectionModel
        this._annotationData = annotationData
        this._buttonController = buttonController
        this._spanConfig = spanConfig
        this._clipBoard = clipBoard
        this._editMode = editMode
        this._horizontal = new Horizontal(editorHTMLElement, selectionModel)
        this._vertical = new Vertical(editorHTMLElement, selectionModel)
        this._isActive = false

        forwardMethods(this, () => this._editMode.currentEdit, [
          'createSpan',
          'expandSpan',
          'shrinkSpan',
          'showPallet',
          'selectLeftAttributeTab',
          'selectRightAttributeTab',
          'editTypeValues',
          'manipulateAttribute'
        ])
        forwardMethods(this, () => this._editMode.stateMachine, [
          'toggleSimpleMode',
          'changeModeByShortcut',
          'toViewMode',
          'toTermMode',
          'toBlockMode',
          'toRelationMode'
        ])
        forwardMethods(this, () => this._clipBoard, [
          'copyEntitiesToLocalClipboard',
          'copyEntitiesToSystemClipboard',
          'cutEntitiesToLocalClipboard',
          'cutEntitiesToSystemClipboard',
          'pasteEntitiesFromLocalClipboard',
          'pasteEntitiesFromSystemClipboard'
        ])
        forwardMethods(this, () => this._buttonController, ['toggleButton'])
      }

      removeSelectedElements() {
        const commands = this._commander.factory.removeSelectedComand()

        // Select the next element before clear selection.
        this._horizontal.right(null)

        this._commander.invoke(commands)
      }

      createEntity() {
        const command =
          this._commander.factory.createDefaultTypeEntityToSelectedSpansCommand(
            this._annotationData.typeDefinition.denotation.defaultType
          )

        if (!command.isEmpty) {
          this._commander.invoke(command)
        }
      }

      replicate() {
        const isDelimiterFunc = getIsDelimiterFunc(
          this._buttonController,
          this._spanConfig
        )

        if (this._selectionModel.span.single) {
          this._commander.invoke(
            this._commander.factory.replicateSpanCommand(
              this._selectionModel.span.single,
              this._selectionModel.span.single.entities.map(
                (e) => e.typeValues
              ),
              isDelimiterFunc
            )
          )
        } else {
          alertify_default().warning(
            'You can replicate span annotation when there is only span selected.'
          )
        }
      }

      cancelSelect() {
        this._editMode.cancelSelect()
        // Foucs the editor for ESC key
        this._editorHTMLElement.focus()
      }

      showSettingDialog() {
        new SettingDialog(
          this._annotationData.typeDefinition,
          this._annotationData.typeGap,
          this._annotationData.textBox
        ).open()
      }

      get isActive() {
        return this._isActive
      }

      active() {
        this._editorHTMLElement.classList.add('textae-editor--active')
        this._isActive = true
      }

      deactive() {
        this._editorHTMLElement.classList.remove('textae-editor--active')
        this._eventEmitter.emit('textae-event.editor.unselect')
        this._isActive = false
      }

      selectLeft(shiftKey) {
        if (this._editMode.isTypeValuesPalletShown) {
          this.selectLeftAttributeTab()
        } else {
          this._horizontal.left(shiftKey)
        }
      }

      selectRight(shiftKey) {
        if (this._editMode.isTypeValuesPalletShown) {
          this.selectRightAttributeTab()
        } else {
          this._horizontal.right(shiftKey)
        }
      }

      selectUp() {
        if (this._editMode.isEditDenotation) {
          this._vertical.up()
        }
      }

      selectDown() {
        if (this._editMode.isEditDenotation) {
          this._vertical.down()
        }
      }

      applyTextSelection() {
        if (this._isActive) {
          this._editMode.currentEdit.applyTextSelection()
        }
      }
    }

    // EXTERNAL MODULE: ./node_modules/dropzone/dist/dropzone.js
    var dropzone = __webpack_require__(2025)
    var dropzone_default = /*#__PURE__*/ __webpack_require__.n(dropzone)
    // EXTERNAL MODULE: ./node_modules/codemirror/lib/codemirror.js
    var codemirror = __webpack_require__(4631)
    var codemirror_default = /*#__PURE__*/ __webpack_require__.n(codemirror)
    // EXTERNAL MODULE: ./node_modules/codemirror/mode/javascript/javascript.js
    var javascript = __webpack_require__(6876) // CONCATENATED MODULE: ./src/lib/isJSON.js
    /* harmony default export */ function isJSON(arg) {
      if (typeof arg !== 'string') {
        return false
      }

      try {
        JSON.parse(arg)
      } catch (e) {
        return false
      }

      return true
    } // CONCATENATED MODULE: ./src/lib/component/LoadDialog/maximizeOverlay.js

    /* harmony default export */ function maximizeOverlay(overlayDropzone) {
      const { element } = overlayDropzone
      element.classList.add(
        'textae-editor__load-dialog__overlay-dropzone--maximized'
      )
      element.style.zIndex = parseInt(element.style.zIndex) + 1
    } // CONCATENATED MODULE: ./src/lib/component/LoadDialog/revertMaximizeOverlay.js

    /* harmony default export */ function revertMaximizeOverlay(
      overlayDropzone,
      zIndexOfOverlayDropzone
    ) {
      overlayDropzone.element.classList.remove(
        'textae-editor__load-dialog__overlay-dropzone--maximized'
      )
      overlayDropzone.element.style.zIndex = zIndexOfOverlayDropzone
    } // CONCATENATED MODULE: ./src/lib/component/LoadDialog/index.js

    function LoadDialog_template(context) {
      const { url } = context

      return `
<div class="textae-editor__load-dialog__container">
  <div class="textae-editor__load-dialog__row">
    <label>
      URL
    </label>
    <input 
      type="text" 
      value="${url}" 
      class="textae-editor__load-dialog__url-text">
    <input 
      type="button" 
      class="textae-editor__load-dialog__url-button"
      ${url ? `` : `disabled="disabled"`}
      value="Open">
  </div>
  <div class="textae-editor__load-dialog__row">
    <label>
      Local
    </label>
    <form class="dropzone textae-editor__load-dialog__dropzone">
      <div class="dz-message">
        Drop a file here or click to select
      </div>
    </form>
    <div class="textae-editor__load-dialog__dz-file-preview">
      <div class="dz-filename"><span data-dz-name>No file selected</span></div>
    </div>
    <input 
      type="button" 
      class="textae-editor__load-dialog__local-button"
      disabled="disabled"
      value="Open">
  </div>
  <div class="textae-editor__load-dialog__row json">
    <label>
      JSON
    </label>
    <textarea class="textae-editor__load-dialog__textarea"></textarea>
    <input type="button" value="Edit" class="edit" disabled="disabled">
    <input type="button" value="Open" class="instant" disabled="disabled">
  </div>
</div>`
    }

    const CONFIRM_DISCARD_CHANGE_MESSAGE =
      'There is a change that has not been saved. If you procceed now, you will lose it.'

    class LoadDialog extends Dialog {
      constructor(
        title,
        url,
        loadFromServer,
        readFromFile,
        readFromText,
        hasChange
      ) {
        super(title, LoadDialog_template({ url }))

        // Disabled the button to load from the URL when no URL.
        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__url-text',
          'input',
          (e) => {
            enableHTMLElement(e.target.nextElementSibling, e.target.value)
          }
        )

        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__textarea',
          'input',
          (e) => {
            enableHTMLElement(
              super.el.querySelector('[type="button"].instant'),
              e.target.value
            )
            enableHTMLElement(
              super.el.querySelector('[type="button"].edit'),
              e.target.value
            )
          }
        )

        const isUserConfirm = () =>
          !hasChange || window.confirm(CONFIRM_DISCARD_CHANGE_MESSAGE)

        // Load from the URL.
        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__url-button',
          'click',
          (e) => {
            if (isUserConfirm()) {
              loadFromServer(e.target.previousElementSibling.value)
            }
            super.close()
          }
        )

        // Load from a file.
        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__local-button',
          'click',
          () => {
            if (isUserConfirm()) {
              readFromFile(this._droppedFile)
            }

            super.close()
          }
        )

        // Load from a textarea
        delegate_default()(super.el, '[type="button"].instant', 'click', () => {
          const text = super.el.querySelector(
            '.textae-editor__load-dialog__textarea'
          ).value
          if (isUserConfirm()) {
            readFromText(text)
          }

          super.close()
        })

        // Open JSON editor
        delegate_default()(super.el, '[type="button"].edit', 'click', () => {
          this._expandDialog()
          const textarea = super.el.querySelector(
            '.textae-editor__load-dialog__textarea'
          )
          if (isJSON(textarea.value)) {
            textarea.value = JSON.stringify(JSON.parse(textarea.value), null, 2)
          }
          this._createJSONEditor(textarea)
        })
      }

      open() {
        super.open()

        const dropzoneConfig = {
          url: 'nothing', //Because it's a setting that cannot be omitted.
          previewsContainer: '.textae-editor__load-dialog__dz-file-preview',
          previewTemplate: super.el.querySelector(
            '.textae-editor__load-dialog__dz-file-preview'
          ).innerHTML
        }

        const overlayDropzone = new (dropzone_default())(
          'body > div.ui-widget-overlay.ui-front',
          {
            ...dropzoneConfig,
            clickable: false
          }
        )
        const zIndexOfOverlayDropzone = overlayDropzone.element.style.zIndex

        overlayDropzone
          .on('dragenter', () => maximizeOverlay(overlayDropzone))
          .on('dragleave', () =>
            revertMaximizeOverlay(overlayDropzone, zIndexOfOverlayDropzone)
          )
          .on('addedfile', (file) => {
            revertMaximizeOverlay(overlayDropzone, zIndexOfOverlayDropzone)
            this._showFilePreview(file)
          })

        const dialogDropzone = new (dropzone_default())(
          '.textae-editor__load-dialog__dropzone',
          dropzoneConfig
        )
        dialogDropzone.on('addedfile', (file) => {
          this._showFilePreview(file)
        })
      }

      _showFilePreview(file) {
        // Remove the previous file name.
        super.el
          .querySelector('.textae-editor__load-dialog__dz-file-preview')
          .firstElementChild.remove()

        // Add file name to title attrribute to show tooltip.
        super.el
          .querySelector('.textae-editor__load-dialog__dz-file-preview > div')
          .setAttribute('title', file.name)

        // Enables the button to open the file.
        this._droppedFile = file
        enableHTMLElement(
          super.el.querySelector('.textae-editor__load-dialog__local-button'),
          true
        )
      }

      _expandDialog() {
        super.el
          .closest('.textae-editor__dialog')
          .classList.add('textae-editor__load-dialog--expanded')
      }

      _createJSONEditor(textarea) {
        const JSONEditor = codemirror_default().fromTextArea(textarea, {
          mode: {
            name: 'javascript',
            json: true
          },
          lineNumbers: true,
          value: textarea.value
        })
        const dialogHeight = super.el.closest(
          '.textae-editor__dialog'
        ).clientHeight
        JSONEditor.setSize('auto', dialogHeight * 0.6)
        JSONEditor.on('change', (cm) => {
          textarea.value = cm.getValue()
        })
      }
    } // CONCATENATED MODULE: ./src/lib/component/createDownloadPath.js

    /* harmony default export */ function createDownloadPath(dataObject) {
      const blob = new Blob([JSON.stringify(dataObject)], {
        type: 'application/json'
      })

      return URL.createObjectURL(blob)
    } // CONCATENATED MODULE: ./src/lib/component/SaveAnnotationDialog/bind.js

    /* harmony default export */ function bind(
      eventEmitter,
      element,
      data,
      closeDialog,
      saveAnnotation
    ) {
      // Disabled the button to save to the URL when no URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'input',
        (e) => {
          enableHTMLElement(e.target.nextElementSibling, e.target.value)
        }
      )

      // Save to the URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'keyup',
        (e) => {
          if (e.keyCode === 13) {
            saveAnnotation(e.target.value)
            closeDialog()
          }
        }
      )
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-button',
        'click',
        (e) => {
          saveAnnotation(e.target.previousElementSibling.value)
          closeDialog()
        }
      )

      // Download as a JSON file.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__download-link',
        'click',
        (e) => {
          const aTag = e.target
          const downloadPath = createDownloadPath(data)
          aTag.setAttribute('href', downloadPath)
          aTag.setAttribute('download', aTag.previousElementSibling.value)
          eventEmitter.emit('textae-event.resource.annotation.save', data)
          closeDialog()
        }
      )

      delegate_default()(
        element,
        '.textae-editor__save-dialog__viewsource-link',
        'click',
        () => {
          window.open(createDownloadPath(data), '_blank')
          eventEmitter.emit('textae-event.resource.annotation.save', data)
          closeDialog()
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/SaveAnnotationDialog/index.js

    function SaveAnnotationDialog_template(context) {
      const { url, filename } = context

      return `
<div class="textae-editor__save-dialog__container">
  <div class="textae-editor__save-dialog__row">
    <label>URL</label>
    <input 
      type="text"
      value="${url}"
      class="textae-editor__save-dialog__url-text">
    <input 
      type="button"
      class="textae-editor__save-dialog__url-button"
      ${url ? '' : `disabled="disabled"`}
      value="Save">
  </div>
  <div class="textae-editor__save-dialog__row">
    <label>Local</label>
    <input
      type="text"
      value="${filename}"
      >
    <a class="textae-editor__save-dialog__download-link" href="#">Download</a>
  </div>
  <div class="textae-editor__save-dialog__row">
    <a class="textae-editor__save-dialog__viewsource-link" href="#">Click to see the json source in a new window.</a>
  </div>
</div>
`
    }

    class SaveAnnotationDialog extends Dialog {
      constructor(eventEmitter, url, filename, data, saveAnnotation) {
        super(
          'Save Annotations',
          SaveAnnotationDialog_template({ filename, url })
        )

        bind(eventEmitter, super.el, data, () => super.close(), saveAnnotation)
      }
    }

    // EXTERNAL MODULE: ./node_modules/jsondiffpatch/dist/jsondiffpatch.umd.js
    var jsondiffpatch_umd = __webpack_require__(5311) // CONCATENATED MODULE: ./src/lib/component/SaveConfigurationDialog/jsonDiff.js
    const jsond = (0, jsondiffpatch_umd.create)({
      objectHash(obj, index) {
        return obj.id || `$$index:${index}`
      }
    })

    /* harmony default export */ function jsonDiff(
      originalConfig,
      editedConfig
    ) {
      const delta = jsond.diff(originalConfig, editedConfig)
      return jsondiffpatch_umd.formatters.html.format(delta, originalConfig)
    } // CONCATENATED MODULE: ./src/lib/component/SaveConfigurationDialog/bind.js

    /* harmony default export */ function SaveConfigurationDialog_bind(
      eventEmitter,
      element,
      editedData,
      closeDialog,
      saveConfiguration
    ) {
      // Disabled the button to save to the URL when no URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'input',
        (e) => {
          enableHTMLElement(e.target.nextElementSibling, e.target.value)
        }
      )

      // Save to the URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'keyup',
        (e) => {
          if (e.keyCode === 13) {
            saveConfiguration(e.target.value)
            closeDialog()
          }
        }
      )
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-button',
        'click',
        (e) => {
          saveConfiguration(e.target.previousElementSibling.value)
          closeDialog()
        }
      )

      // Download as a JSON file.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__download-link',
        'click',
        (e) => {
          const aTag = e.target
          const downloadPath = createDownloadPath(editedData)
          aTag.setAttribute('href', downloadPath)
          aTag.setAttribute('download', aTag.previousElementSibling.value)
          eventEmitter.emit(
            'textae-event.resource.configuration.save',
            editedData
          )
          closeDialog()
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/SaveConfigurationDialog/index.js

    function SaveConfigurationDialog_template(context) {
      const { url, filename, diff } = context

      return `
<div class="textae-editor__save-dialog__container">
  <div class="textae-editor__save-dialog__row">
    <label>URL</label>
    <input 
      type="text" value="${url}" 
      class="textae-editor__save-dialog__url-text">
    <input 
      type="button" 
      class="textae-editor__save-dialog__url-button"
      ${url ? '' : `disabled="disabled"`}
      value="Save">
  </div>
  <div class="textae-editor__save-dialog__row">
    <label>Local</label>
    <input
      type="text" value="${filename}" 
      >
    <a class="textae-editor__save-dialog__download-link" href="#">Download</a>
  </div>
  <div class="textae-editor__save-dialog__row">
    <div class="textae-editor__save-dialog__diff-title">
      Configuration differences
      <span class="textae-editor__save-dialog__diff-add-legend">added</span>
      <span class="textae-editor__save-dialog__diff-remove-legend">removed</span>
    </div>
    <div class="textae-editor__save-dialog__diff-viewer">${diff}</div>
  </div>
</div>
`
    }

    class SaveConfigurationDialog extends Dialog {
      constructor(
        eventEmitter,
        url,
        filename,
        originalData,
        editedData,
        saveConfiguration
      ) {
        super(
          'Save Configurations',
          SaveConfigurationDialog_template({
            filename,
            url,
            diff: jsonDiff(originalData, editedData) || 'nothing.'
          }),

          {
            maxWidth: 550
          }
        )

        // Hide unchanged diff.
        this._$dialog.on('dialogopen', () =>
          jsondiffpatch_umd.formatters.html.hideUnchanged()
        )

        SaveConfigurationDialog_bind(
          eventEmitter,
          super.el,
          editedData,
          () => super.close(),
          saveConfiguration
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/PersistenceInterface/readFile.js

    /* harmony default export */ async function readFile(file) {
      return new Promise((resolve) => {
        const reader = new FileReader()

        reader.onload = (event) => resolve(event)
        reader.readAsText(file)
      })
    }

    // EXTERNAL MODULE: ./node_modules/path-browserify/index.js
    var path_browserify = __webpack_require__(6470)
    var path_browserify_default =
      /*#__PURE__*/ __webpack_require__.n(path_browserify) // CONCATENATED MODULE: ./src/lib/Editor/API/PersistenceInterface/isTxtFile.js
    /* harmony default export */ function isTxtFile(fileName) {
      return path_browserify_default().extname(fileName) === '.txt'
    } // CONCATENATED MODULE: ./src/lib/Editor/DataSource/toSourceString.js

    /* harmony default export */ function toSourceString(sourceType, source) {
      switch (sourceType) {
        case 'url':
          return new URL(source, location.href).href
        case 'local file':
          return `${source}(local file)`
        case 'inline':
          return 'inline'
        case 'instant':
          return 'instant'
        default:
          throw `unknown source type: ${sourceType}.`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/DataSource/index.js

    class DataSource {
      constructor(type, id, data) {
        this._type = type
        this._id = id
        this._data = data
      }

      get type() {
        return this._type
      }

      get id() {
        return this._id
      }

      get data() {
        return this._data
      }

      get displayName() {
        return toSourceString(this._type, this._id)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/PersistenceInterface/readAnnotationFile.js

    /* harmony default export */ async function readAnnotationFile(
      file,
      eventEmitter
    ) {
      const event = await readFile(file)
      const fileContent = event.target.result

      if (isTxtFile(file.name)) {
        // If this is .txt, New annotation json is made from .txt
        eventEmitter.emit(
          'textae-event.resource.annotation.load.success',
          new DataSource('local file', file.name, {
            text: fileContent
          })
        )

        return
      }

      if (isJSON(fileContent)) {
        const annotation = JSON.parse(fileContent)

        if (annotation.text) {
          eventEmitter.emit(
            'textae-event.resource.annotation.load.success',
            new DataSource('local file', file.name, annotation)
          )

          return
        }
      }

      eventEmitter.emit(
        'textae-event.resource.annotation.format.error',
        new DataSource('local file', file.name)
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/PersistenceInterface/readConfigurationFile.js

    /* harmony default export */ function readConfigurationFile(
      file,
      eventEmitter
    ) {
      readFile(file).then(({ target }) => {
        if (isJSON(target.result)) {
          eventEmitter.emit(
            'textae-event.resource.configuration.load.success',
            new DataSource('local file', file.name, JSON.parse(target.result))
          )
        } else {
          eventEmitter.emit(
            'textae-event.resource.configuration.format.error',
            new DataSource('local file', file.name)
          )
        }
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/API/PersistenceInterface/index.js

    class PersistenceInterface {
      constructor(
        eventEmitter,
        remoteResource,
        annotationData,
        getOriginalAnnotation,
        getOriginalConfig,
        saveToParameter,
        annotationDataEventsObserver,
        buttonController
      ) {
        this._eventEmitter = eventEmitter
        this._remoteResource = remoteResource
        this._annotationData = annotationData
        this._getOriginalAnnotation = getOriginalAnnotation
        this._getOriginalConfig = getOriginalConfig
        this._saveToParameter = saveToParameter
        this._annotationDataEventsObserver = annotationDataEventsObserver
        this._buttonController = buttonController

        // Store the filename of the annotation and configuration.
        this._filenameOfLastRead = {
          annotation: '',
          configuration: ''
        }

        eventEmitter
          .on('textae-event.pallet.read-button.click', () =>
            this.importConfiguration()
          )
          .on('textae-event.pallet.write-button.click', () =>
            this.uploadConfiguration()
          )
      }

      importAnnotation() {
        new LoadDialog(
          'Load Annotations',
          this._remoteResource.annotationUrl,
          (url) => this._remoteResource.loadAnnotation(url),
          (file) => {
            readAnnotationFile(file, this._eventEmitter)
            this._filenameOfLastRead.annotation = file.name
          },
          (text) => {
            if (isJSON(text)) {
              const annotation = JSON.parse(text)
              if (annotation.text) {
                this._eventEmitter.emit(
                  'textae-event.resource.annotation.load.success',
                  new DataSource('instant', null, annotation)
                )
                return
              }
            }

            this._eventEmitter.emit(
              'textae-event.resource.annotation.format.error',
              new DataSource('instant', null)
            )
          },
          this._annotationDataEventsObserver.hasChange
        ).open()
      }

      uploadAnnotation() {
        new SaveAnnotationDialog(
          this._eventEmitter,
          this._saveToParameter || this._remoteResource.annotationUrl,
          this._filenameOfLastRead.annotation,
          this._editedAnnotation,
          (url) =>
            this._remoteResource.saveAnnotation(url, this._editedAnnotation)
        ).open()
      }

      saveAnnotation() {
        this._remoteResource.saveAnnotation(
          this._saveToParameter || this._remoteResource.annotationUrl,
          this._editedAnnotation
        )
      }

      importConfiguration() {
        new LoadDialog(
          'Load Configurations',
          this._remoteResource.configurationUrl,
          (url) => this._remoteResource.loadConfigulation(url),
          (file) => {
            readConfigurationFile(file, this._eventEmitter)
            this._filenameOfLastRead.configuration = file.name
          },
          (text) => {
            if (isJSON(text)) {
              this._eventEmitter.emit(
                'textae-event.resource.configuration.load.success',
                new DataSource('instant', null, JSON.parse(text))
              )
            } else {
              this._eventEmitter.emit(
                'textae-event.resource.configuration.format.error',
                new DataSource('instant', null)
              )
            }
          },
          this._buttonController.diffOfConfiguration
        ).open()
      }

      uploadConfiguration() {
        // Merge with the original config and save the value unchanged in the editor.
        const editidConfig = {
          ...this._getOriginalConfig(),
          ...this._annotationData.typeDefinition.config
        }

        new SaveConfigurationDialog(
          this._eventEmitter,
          this._remoteResource.configurationUrl,
          this._filenameOfLastRead.configuration,
          this._getOriginalConfig(),
          editidConfig,
          (url) => this._remoteResource.saveConfiguration(url, editidConfig)
        ).open()
      }

      get _editedAnnotation() {
        return {
          ...this._getOriginalAnnotation(),
          ...this._annotationData.JSON,
          ...{
            config: this._annotationData.typeDefinition.config
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/setPushBUttons.js

    /* harmony default export */ function setPushBUttons(
      configuration,
      buttonController
    ) {
      if (configuration.autosave === true) {
        buttonController.push('write-auto')
      } else {
        buttonController.release('write-auto')
      }

      if (configuration.autolineheight === false) {
        buttonController.release('line-height-auto')
      } else {
        buttonController.push('line-height-auto')
      }

      if (configuration.boundarydetection === false) {
        buttonController.release('boundary-detection')
      } else {
        buttonController.push('boundary-detection')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/setAnnotationAndConfiguration.js

    /**
     *
     * @param {import('../AnnotationData').default} annotationData
     */
    /* harmony default export */ function setAnnotationAndConfiguration(
      validConfig,
      buttonController,
      spanConfig,
      annotationData,
      annotation
    ) {
      setPushBUttons(validConfig, buttonController)
      spanConfig.set(validConfig)
      annotationData.reset(annotation, validConfig)
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/fillInferDefinitionFromAnnotation/fill.js

    // Complement the config with the generated Attribute definition.
    // Does not override the existing Attribute definition.
    /* harmony default export */ function fill(
      config,
      newAttributeDefinitions
    ) {
      for (const newDef of newAttributeDefinitions) {
        const index = config.findIndex((a) => a.pred === newDef.pred)
        if (index !== -1) {
          config[index] = { ...newDef, ...config[index] }
        } else {
          config.push(newDef)
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/getValueType.js

    /* harmony default export */ function getValueType(obj) {
      if (obj === true) {
        return 'flag'
      } else if (typeof obj === 'number') {
        return 'numeric'
      } else if (typeof obj === 'string') {
        return 'string'
      } else {
        throw `${JSON.stringify(obj)} is an unexpected value for an Attribute.`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/getMostFrequentObject.js

    // The default value is the value of the first object of the most frequent object.
    /* harmony default export */ function getMostFrequentObject(objects) {
      const objectFrequencyMap = objects.reduce((map, obj) => {
        if (map.has(obj)) {
          return map.set(obj, map.get(obj) + 1)
        } else {
          return map.set(obj, 1)
        }
      }, new Map())

      const maximumFrequency = Math.max(...objectFrequencyMap.values())

      for (const [obj, frq] of objectFrequencyMap.entries()) {
        if (frq === maximumFrequency) {
          return obj
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/getStep.js

    // The value of step is matched to the smallest digit of all objcts.
    /* harmony default export */ function getStep(objects) {
      const numberOfDigits = Math.max(
        ...objects.map((o) => {
          const [_, smallNumber] = String(o).split('.')
          return smallNumber ? smallNumber.length : 0
        })
      )

      // The step is a small number of the specified number of digits, with the lowest digit being 1.
      return Number(
        Array.from(Array(numberOfDigits))
          .reduce((acc, _) => acc * 0.1, 1)
          .toFixed(numberOfDigits)
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/index.js

    class AnnotationsForPred {
      constructor({ pred, obj }) {
        this._pred = pred
        this._objects = [obj]
      }

      push(obj) {
        this._objects.push(obj)
      }

      // It is not possible to generate a selection attribute definition.
      // Since it is not possible to determine whether the value type is a string or a selection from the annotation,
      // it is always treated as a string.
      get definition() {
        switch (getValueType(this._objects[0])) {
          case 'flag':
            return this._prototype
          case 'numeric':
            return this._numericAttribute
          case 'string':
            return this._stringAttribute

          default:
            throw new Error(`prototype: ${JSON.stringify(this._prototype)}`)
        }
      }

      get mostFrequentObject() {
        return getMostFrequentObject(this._objects)
      }

      get _prototype() {
        return {
          pred: this._pred,
          'value type': getValueType(this._objects[0])
        }
      }

      get _numericAttribute() {
        return {
          min: Math.min(...this._objects),
          max: Math.max(...this._objects),
          step: getStep(this._objects),
          default: getMostFrequentObject(this._objects),
          ...this._prototype
        }
      }

      get _stringAttribute() {
        return {
          default: getMostFrequentObject(this._objects),
          ...this._prototype
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/getAnnotationMap.js

    /* harmony default export */ function getAnnotationMap(annotations) {
      return annotations.reduce((map, attr) => {
        if (map.has(attr.pred)) {
          map.get(attr.pred).push(attr.obj)
        } else {
          map.set(attr.pred, new AnnotationsForPred(attr))
        }
        return map
      }, new Map())
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/fillInferDefinitionFromAnnotation/inferDefinitionFromAnnotation/index.js

    // Generates a definition of an attribute by inferring a definition from the value of an annotation.
    /* harmony default export */ function inferDefinitionFromAnnotation(
      annotations
    ) {
      return [...getAnnotationMap(annotations).values()].map(
        (a) => a.definition
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/fillInferDefinitionFromAnnotation/index.js

    /* harmony default export */ function fillInferDefinitionFromAnnotation(
      config,
      annotations
    ) {
      const inferDefinitions = inferDefinitionFromAnnotation(annotations)
      return fill(config, inferDefinitions)
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/clone.js

    /* harmony default export */ function clone(config) {
      return config ? JSON.parse(JSON.stringify(config)) : {}
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/fillDefaultValueOfSelectionAttributes/getSelectionAttributes.js

    /* harmony default export */ function getSelectionAttributes(config) {
      return config.filter((a) => a['value type'] === 'selection')
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/fillDefaultValueOfSelectionAttributes/index.js

    // Sets a default value for the definition of a selection attribute that does not have a default value.
    //
    // A sample definition of the full form of the selection attribute:
    // {
    //   "pred": "denote",
    //   "value type": "selection",
    //   "values": [
    //     {
    //       "color": "#0000FF",
    //       "label": "Regulation",
    //       "id": "http://www.yahoo.co.jp/eeeeeeeeeeeeeeeeeoaoeuaoeuaoue",
    //       "default": true
    //     },
    //     {
    //       "color": "#FF0000",
    //       "id": "Cell"
    //     },
    //     {
    //       "id": "equivalentTo"
    //     }
    //   ]
    // }
    //
    // A sample of selection attribute annotation:
    // {
    //   "id": "A3",
    //   "subj": "E1:a:b",
    //   "pred": "denote",
    //   "obj": "Cell"
    // }
    /* harmony default export */ function fillDefaultValueOfSelectionAttributes(
      config,
      annotations
    ) {
      config = clone(config)

      const annotationMap = getAnnotationMap(annotations)
      for (const attr of getSelectionAttributes(config)) {
        if (!attr.values || attr.values.length === 0) {
          attr.values = [{ id: 'default', default: true }]
          continue
        }

        if (!attr.values.find((v) => v.default === true)) {
          // If this attribute is used in the annotation, it defaults to the most commonly used value.
          // Unless it is not used in the annotation, the first value is the default.
          if (annotationMap.has(attr.pred)) {
            const afp = annotationMap.get(attr.pred)
            attr.values.find(
              (v) => v.id === afp.mostFrequentObject
            ).default = true
          } else {
            attr.values[0].default = true
          }
          continue
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/fillMandatoryValueOfNumericAttributes.js

    /* harmony default export */ function fillMandatoryValueOfNumericAttributes(
      config
    ) {
      config = clone(config)

      for (const a of config.filter((a) => a['value type'] === 'numeric')) {
        if (!Object.prototype.hasOwnProperty.call(a, 'default')) {
          a.default = DEFAULT
        }
        if (!Object.prototype.hasOwnProperty.call(a, 'step')) {
          a.step = STEP
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/fillDefaultValueOfStringAttributes.js

    /* harmony default export */ function fillDefaultValueOfStringAttributes(
      config
    ) {
      config = clone(config)

      for (const a of config.filter((a) => a['value type'] === 'string')) {
        if (!Object.prototype.hasOwnProperty.call(a, 'default')) {
          a.default = ''
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/AttributeConfigurationGenerator/index.js

    class AttributeConfigurationGenerator {
      constructor(config = [], annotations = []) {
        this._annotations = annotations
        this._config = config
      }

      get configuration() {
        let newConfig = fillInferDefinitionFromAnnotation(
          this._config,
          this._annotations
        )
        newConfig = fillMandatoryValueOfNumericAttributes(newConfig)
        newConfig = fillDefaultValueOfStringAttributes(newConfig)
        newConfig = fillDefaultValueOfSelectionAttributes(
          newConfig,
          this._annotations
        )

        return newConfig
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/patchConfiguration/index.js

    /* harmony default export */ function patchConfiguration(
      annotation,
      config
    ) {
      console.assert(annotation)

      // Note that if you don't make a copy, the reference to the original attribute types will be lost.
      config = clone(config)

      config['attribute types'] = new AttributeConfigurationGenerator(
        config['attribute types'],
        annotation.attributes
      ).configuration

      if (annotation.tracks) {
        for (const track of annotation.tracks) {
          config['attribute types'] = new AttributeConfigurationGenerator(
            config['attribute types'],
            track.attributes
          ).configuration
        }
      }

      return config
    }

    // EXTERNAL MODULE: ./node_modules/ajv/dist/ajv.js
    var ajv = __webpack_require__(1581)
    var ajv_default = /*#__PURE__*/ __webpack_require__.n(ajv)
    // EXTERNAL MODULE: ./node_modules/ajv-formats/dist/index.js
    var dist = __webpack_require__(5477)
    var dist_default = /*#__PURE__*/ __webpack_require__.n(dist) // CONCATENATED MODULE: ./src/lib/Editor/API/validateConfigurationAndAlert/validateConfiguration/configurationScheme.json
    const configurationScheme_namespaceObject = JSON.parse(
      '{"$schema":"http://json-schema.org/draft-07/schema#","title":"JSON schema for texta configuration files","definitions":{"characters":{"type":"array","items":{"type":"string","minLength":1,"maxLength":1}},"color":{"pattern":"^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$","type":"string"},"default":{"type":"boolean"},"denote":{"type":"object","required":["id"],"properties":{"id":{"type":"string"},"label":{"type":"string"},"color":{"$ref":"#/definitions/color"},"default":{"$ref":"#/definitions/default"}}},"types":{"type":"array","items":{"$ref":"#/definitions/denote"}},"autocompletion_ws":{"type":"string","format":"uri-reference"}},"type":"object","properties":{"delimiter characters":{"$ref":"#/definitions/characters"},"non-edge characters":{"$ref":"#/definitions/characters"},"autocompletion_ws":{"$ref":"#/definitions/autocompletion_ws"},"autosave":{"type":"boolean"},"autolineheight":{"type":"boolean"},"boundarydetection":{"type":"boolean"},"entity types":{"$ref":"#/definitions/types"},"relation types":{"$ref":"#/definitions/types"},"attribute types":{"type":"array","items":{"type":"object","required":["pred","value type"],"properties":{"pred":{"type":"string"},"value type":{"enum":["flag","selection","string","numeric"]}},"allOf":[{"if":{"properties":{"value type":{"const":"flag"}}},"then":{"properties":{"color":{"$ref":"#/definitions/color"},"label":{"type":"string"}}}},{"if":{"properties":{"value type":{"const":"selection"}}},"then":{"required":["values"],"properties":{"values":{"type":"array","items":{"$ref":"#/definitions/denote"}}}}},{"if":{"properties":{"value type":{"const":"string"}}},"then":{"required":["default"],"properties":{"autocompletion_ws":{"$ref":"#/definitions/autocompletion_ws"},"default":{"type":"string"},"values":{"type":"array","items":{"type":"object","required":["pattern"],"properties":{"pattern":{"type":"string","format":"regex"},"label":{"type":"string"},"color":{"$ref":"#/definitions/color"}}}}}}},{"if":{"properties":{"value type":{"const":"numeric"}}},"then":{"required":["default","step"],"properties":{"default":{"type":"number"},"min":{"type":"number"},"max":{"type":"number"},"step":{"type":"number"},"values":{"type":"array","items":{"type":"object","required":["range"],"properties":{"range":{"type":"string"},"label":{"type":"string"},"color":{"$ref":"#/definitions/color"}}}}}}}]}}}}'
    ) // CONCATENATED MODULE: ./src/lib/Editor/API/validateConfigurationAndAlert/validateConfiguration/toErrorMessage.js
    /* harmony default export */ function toErrorMessage(errors) {
      for (const e of errors) {
        if (e.keyword === 'required') {
          return `Invalid configuration: The attribute type whose predicate is '${e.data.pred}' misses a mandatory property, '${e.params.missingProperty}'.`
        } else if (e.instancePath.includes('color')) {
          return eskape_default()`Invalid configuration: '${e.data}' is invalid color format.`
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/validateConfigurationAndAlert/validateConfiguration/index.js

    const validateConfiguration_ajv = new (ajv_default())({ verbose: true })
    dist_default()(validateConfiguration_ajv, ['uri-reference', 'regex'])
    const validate = validateConfiguration_ajv.compile(
      configurationScheme_namespaceObject
    )

    /* harmony default export */ function validateConfiguration(config) {
      console.assert(config, 'config is required.')

      if (!validate(config)) {
        console.warn(validate.errors)

        return toErrorMessage(validate.errors)
      }

      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/API/validateAttribueDefinitionAndAlert/hasAllValueDefinitionOfSelectionAttributes.js

    // Check for definitions of values for selection attributes.
    /* harmony default export */ function hasAllValueDefinitionOfSelectionAttributes(
      annotation,
      config
    ) {
      console.assert(
        config,
        `If you don't have a configuration, generate a configuration from the annotation.`
      )

      if (annotation.attributes) {
        const atrributeTypes = config['attribute types']

        const selectionAttributeValueWithoutDefinition = annotation.attributes
          .filter((attr) =>
            atrributeTypes.some(
              (attrDef) =>
                attrDef.pred === attr.pred &&
                attrDef['value type'] === 'selection'
            )
          )
          .filter(
            (attr) =>
              !atrributeTypes.some(
                (attrDef) =>
                  attrDef.pred === attr.pred &&
                  attrDef.values.some((v) => v.id === attr.obj)
              )
          )

        if (selectionAttributeValueWithoutDefinition.length) {
          console.warn(
            'selection attribute values without definition',
            selectionAttributeValueWithoutDefinition
          )

          return `selection attribute value definition for "${selectionAttributeValueWithoutDefinition
            .map((a) => a.obj)
            .join(', ')}" in configuration is missing. `
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/validateAttribueDefinitionAndAlert/index.js

    /* harmony default export */ function validateAttribueDefinitionAndAlert(
      annotation,
      config
    ) {
      const error = hasAllValueDefinitionOfSelectionAttributes(
        annotation,
        config
      )

      if (error) {
        alertify_default().error(error)
        return
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/API/validateConfigurationAndAlert/index.js

    /* harmony default export */ function validateConfigurationAndAlert(
      annotation,
      config
    ) {
      const patchedConfig = patchConfiguration(annotation, config)
      const errorMessage = validateConfiguration(patchedConfig)
      if (errorMessage) {
        alertify_default().error(errorMessage)

        return
      }

      return validateAttribueDefinitionAndAlert(annotation, patchedConfig)
    } // CONCATENATED MODULE: ./src/lib/Editor/API/warningIfBeginEndOfSpanAreNotInteger/areNotBeginAndEndInteger.js

    /* harmony default export */ function areNotBeginAndEndInteger(annotation) {
      if (annotation.denotations) {
        for (const denotation of annotation.denotations) {
          if (denotation.span.begin !== parseInt(denotation.span.begin)) {
            return true
          }

          if (denotation.span.end !== parseInt(denotation.span.end)) {
            return true
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/warningIfBeginEndOfSpanAreNotInteger/index.js

    /* harmony default export */ function warningIfBeginEndOfSpanAreNotInteger(
      annotation
    ) {
      if (areNotBeginAndEndInteger(annotation)) {
        alertify_default().warning(
          `In the annotation file, some of the begin and end offsets of denotations were not integer values.
      TextAE converted them to integer values.
      However, to avoid a chance of unexpected rendering, please fix them.`,
          15
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/setDefault.js

    /* harmony default export */ function setDefault(
      originalData,
      buttonController,
      spanConfig,
      annotationData
    ) {
      setAnnotationAndConfiguration(
        originalData.defaultConfiguration,
        buttonController,
        spanConfig,
        annotationData,
        originalData.defaultAnnotation
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/initAnnotation.js

    /* harmony default export */ function initAnnotation(
      spanConfig,
      annotationData,
      remoteResource,
      buttonController,
      originalData,
      annotationParameter,
      configParameter
    ) {
      if (annotationParameter.has('inlineAnnotation')) {
        // Set an inline annotation.
        const dataSource = new DataSource(
          'inline',
          null,
          JSON.parse(annotationParameter.get('inlineAnnotation'))
        )

        if (!dataSource.data.config && configParameter) {
          remoteResource.loadConfigulation(configParameter, dataSource)
        } else {
          warningIfBeginEndOfSpanAreNotInteger(dataSource.data)

          if (dataSource.data.config) {
            // When config is specified, it must be JSON.
            // For example, when we load an HTML file, we treat it as text here.
            if (typeof dataSource.data.config !== 'object') {
              alertify_default().error(
                `configuration in anntotaion file is invalid.`
              )
              return
            }
          }

          const validConfig = validateConfigurationAndAlert(
            dataSource.data,
            dataSource.data.config
          )

          if (validConfig) {
            setAnnotationAndConfiguration(
              validConfig,
              buttonController,
              spanConfig,
              annotationData,
              dataSource.data
            )

            originalData.annotation = dataSource
          }
        }
      } else if (annotationParameter.has('url')) {
        // Load an annotation from server.
        remoteResource.loadAnnotation(annotationParameter.get('url'))
      } else {
        if (configParameter) {
          remoteResource.loadConfigulation(configParameter)
        } else {
          setDefault(originalData, buttonController, spanConfig, annotationData)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/OriginalData/StatusBar/html.js

    const html = `
<div class="textae-editor__footer">
  <div class="textae-editor__footer__message"></div>
</div>
`

    /* harmony default export */ const StatusBar_html = html // CONCATENATED MODULE: ./src/lib/Editor/API/OriginalData/StatusBar/getAreaIn.js

    /* harmony default export */ function getAreaIn(container) {
      const area = container.querySelector('.textae-editor__footer__message')

      if (area) {
        return area
      }

      // The editor itself has a "white-space: pre" style for processing text that contains a series of whitespace.
      // In this case, HTML line breaks are included in the editor's height calculation.
      // Remove CRLF so that it is not included in the height calculation.
      container.insertAdjacentHTML(
        'beforeend',
        StatusBar_html.replace(/[\n\r]+/g, '')
      )
      return container.querySelector('.textae-editor__footer__message')
    } // CONCATENATED MODULE: ./src/lib/Editor/API/OriginalData/StatusBar/index.js

    class StatusBar {
      constructor(editorHTMLElement, isShow) {
        this._editorHTMLElement = editorHTMLElement
        this._isShow = isShow
      }

      set status(dataSource) {
        if (!this._isShow) {
          return
        }

        const message = dataSource.displayName

        if (message !== '') {
          getAreaIn(this._editorHTMLElement).innerHTML = isUri(message)
            ? `Source: ${`<a class="textae-editor__footer__message__link" href="${message}">${decodeURI(
                message
              )}</a>`}`
            : `Source: ${message}`
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/OriginalData/index.js

    // Manage the original annotations and the original configuration and merge the changes when you save them.
    class OriginalData {
      constructor(eventEmitter, editorHTMLElement, isShow) {
        this._eventEmitter = eventEmitter
        this._statusBar = new StatusBar(editorHTMLElement, isShow)
        this._map = new Map()

        eventEmitter
          .on('textae-event.resource.annotation.save', (editedData) => {
            this.annotation = new DataSource(null, null, editedData)
          })
          .on('textae-event.resource.configuration.save', (editedData) => {
            this.configuration = new DataSource(null, null, editedData)
          })
      }

      get defaultAnnotation() {
        return {
          text: 'Currently, the document is empty. Use the `import` button or press the key `i` to open a document with annotation.'
        }
      }

      get defaultConfiguration() {
        return patchConfiguration(this.defaultAnnotation)
      }

      get annotation() {
        return this._map.has('annotation')
          ? this._map.get('annotation').data
          : this.defaultAnnotation
      }

      set annotation(dataSource) {
        this._map.set('annotation', dataSource)
        if (dataSource.data.config) {
          this.configuration = new DataSource(
            null,
            null,
            dataSource.data.config
          )
        }

        if (dataSource.type) {
          this._statusBar.status = dataSource
        }
      }

      get configuration() {
        return this._map.has('configuration')
          ? this._map.get('configuration').data
          : {}
      }

      set configuration(dataSource) {
        this._map.set('configuration', dataSource)
        this._eventEmitter.emit('textae-event.orginal-data.configuration.reset')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/ButtonConfig/config.js

    const config_config = [
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'read',
            title: 'Import [I]'
          },
          {
            type: 'write',
            title: 'Upload [U]'
          },
          {
            type: 'write-auto',
            title: 'Upload Automatically',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'view',
            title: 'View Mode',
            push: true
          },
          {
            type: 'term',
            title: 'Term Edit Mode',
            push: true
          },
          {
            type: 'block',
            title: 'Block Edit Mode',
            push: true
          },
          {
            type: 'relation',
            title: 'Relation Edit Mode',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'simple',
            title: 'Simple View',
            push: true
          },
          {
            type: 'line-height',
            title: 'Adjust LineHeight'
          },
          {
            type: 'line-height-auto',
            title: 'Auto Adjust LineHeight',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'undo',
            title: 'Undo [Z]'
          },
          {
            type: 'redo',
            title: 'Redo [A]'
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'replicate',
            title: 'Replicate span annotation [R]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.single &&
              selectionModel.span.single.isDenotation
          },
          {
            type: 'replicate-auto',
            title: 'Auto replicate',
            push: true
          },
          {
            type: 'boundary-detection',
            title: 'Boundary Detection [B]',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': [],
          'touce device': ['control bar', 'context menu']
        },
        list: [
          { type: 'create-span', title: 'Create span' },
          { type: 'expand-span', title: 'Expand span' },
          { type: 'shrink-span', title: 'Shrink span' }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'entity',
            title: 'New entity [E]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.contains((s) => s.isDenotation)
          },
          {
            type: 'pallet'
          },
          {
            type: 'change-label',
            title: 'Change label [W]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.entity.some || selectionModel.relation.some
          },
          {
            type: 'delete',
            title: 'Delete [D]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.some ||
              selectionModel.entity.some ||
              selectionModel.relation.some
          }
        ]
      },
      {
        usage: {
          'keyboard device': [],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'copy',
            title: 'Copy [C]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.contains((s) => s.isDenotation) ||
              selectionModel.entity.contains((e) => e.isDenotation)
          },
          {
            type: 'cut',
            title: 'Cut [X]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.contains((s) => s.isDenotation) ||
              selectionModel.entity.contains((e) => e.isDenotation)
          },
          {
            type: 'paste',
            title: 'Paste [V]',
            enableWhenSelecting: (selectionModel, clipBoard) =>
              (clipBoard.hasCopyingItem && selectionModel.span.some) ||
              (clipBoard.hasCuttingItem && Boolean(selectionModel.span.single))
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'setting',
            title: 'Setting'
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar'],
          'touce device': []
        },
        list: [
          {
            type: 'help',
            title: 'Help [H]'
          }
        ]
      }
    ]

    // EXTERNAL MODULE: ./node_modules/deepcopy/umd/deepcopy.js
    var deepcopy = __webpack_require__(1245)
    var deepcopy_default = /*#__PURE__*/ __webpack_require__.n(deepcopy) // CONCATENATED MODULE: ./src/lib/Editor/isAndroid.js
    /* harmony default export */ function isAndroid() {
      // For development environments, Use the navigator.userAgent.
      // Because the navigator.userAgentData only work in the secure context(HTTPS).
      // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgentData
      return /Android/.test(navigator.userAgent)
    } // CONCATENATED MODULE: ./src/lib/Editor/ButtonConfig/index.js

    function isIOS() {
      // iPad Safari (iPadOS 14 or later) does not include the string iPad in its userAgent.
      // see https://iwb.jp/ipad-safari-javascript-useragent-is-not-ipad/
      return (
        /iPad/.test(navigator.userAgent) ||
        /iPhone/.test(navigator.userAgent) ||
        (/Macintosh/.test(navigator.userAgent) && isTouchable())
      )
    }

    class ButtonConfig {
      constructor(eventEmitter) {
        // Copy it to keep the state for each editor.
        this._config = deepcopy_default()(config_config)

        // Change the title of the palette button to match the edit mode.
        if (eventEmitter) {
          eventEmitter.on('textae-event.edit-mode.transition', (mode) => {
            let title = ''
            switch (mode) {
              case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
              case MODE.EDIT_DENOTATION_WITH_RELATION:
              case MODE.EDIT_BLOCK_WITHOUT_RELATION:
              case MODE.EDIT_BLOCK_WITH_RELATION:
                title = 'Entity Configuration'
                break
              case MODE.EDIT_RELATION:
                title = 'Relation Configuration'
                break
              default:
                title = ''
            }

            this._buttons.find(({ type }) => type === 'pallet').title = title
            eventEmitter.emit(
              'textae-event.control.pallet-button.change-title',
              title
            )
          })
        }
      }

      // Buttons to display on the control bar.
      get controlBar() {
        return this._config
          .filter(({ usage }) => {
            // To make it easier to guess the result, don't use the screen size to judge the device.
            if (isAndroid() || isIOS()) {
              return usage['touce device'].includes('control bar')
            } else {
              return usage['keyboard device'].includes('control bar')
            }
          })
          .map(({ list }) => ({
            list: list.map(({ type, title }) => ({
              type,
              title
            }))
          }))
      }

      // Buttons to display on the context menu.
      get contextMenu() {
        return this._config
          .filter(({ usage }) => {
            if (isTouchable()) {
              return usage['touce device'].includes('context menu')
            } else {
              return usage['keyboard device'].includes('context menu')
            }
          })
          .map(({ list }) => ({
            list: list.map(({ type, title }) => ({
              type,
              title
            }))
          }))
      }

      get pasteButton() {
        return this._buttons.find(({ type }) => type === 'paste')
      }

      get enabelButtonsWhenSelecting() {
        return this._buttons.filter((b) => b.enableWhenSelecting)
      }

      get pushButtons() {
        return this._buttons.filter((b) => b.push).map((b) => b.type)
      }

      get _buttons() {
        return this._config.map(({ list }) => list).flat()
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/PushButtons/Button.js

    class Button {
      constructor(name, eventEmitter = null) {
        this._name = name
        this._eventEmitter = eventEmitter
        this._isPushed = false
      }

      get name() {
        return this._name
      }

      get isPushed() {
        return this._isPushed
      }

      set isPushed(value) {
        this._isPushed = value
        this._propagate()
      }

      toggle() {
        this._isPushed = !this._isPushed
        this._propagate()
      }

      _propagate() {
        if (this._eventEmitter) {
          this._eventEmitter.emit('textae-event.control.button.push', this)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/PushButtons/index.js

    class PushButtons {
      constructor(eventEmitter) {
        this._buttons = new ButtonConfig().pushButtons.reduce((map, name) => {
          map.set(name, new Button(name, eventEmitter))
          return map
        }, new Map())

        // Bind an event.
        eventEmitter.on('textae-event.edit-mode.transition', (mode) =>
          this._setMode(mode)
        )

        // default pushed;
        this._buttons.get('boundary-detection').pushued = true
      }

      get(name) {
        return this._buttons.has(name)
          ? this._buttons.get(name)
          : new Button(name)
      }

      get names() {
        return this._buttons.keys()
      }

      _setMode(mode) {
        switch (mode) {
          case MODE.VIEW_WITHOUT_RELATION:
            this._updateModeButtons(true, false, false, false, true)
            break
          case MODE.VIEW_WITH_RELATION:
            this._updateModeButtons(true, false, false, false, false)
            break
          case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
            this._updateModeButtons(false, true, false, false, true)
            break
          case MODE.EDIT_DENOTATION_WITH_RELATION:
            this._updateModeButtons(false, true, false, false, false)
            break
          case MODE.EDIT_BLOCK_WITHOUT_RELATION:
            this._updateModeButtons(false, false, true, false, true)
            break
          case MODE.EDIT_BLOCK_WITH_RELATION:
            this._updateModeButtons(false, false, true, false, false)
            break
          case MODE.EDIT_RELATION:
            this._updateModeButtons(false, false, false, true, false)
            break
          default:
            throw `unknown edit mode!${mode}`
        }
      }

      _updateModeButtons(view, term, block, relation, simple) {
        this._buttons.get('view').isPushed = view
        this._buttons.get('term').isPushed = term
        this._buttons.get('block').isPushed = block
        this._buttons.get('relation').isPushed = relation
        this._buttons.get('simple').isPushed = simple
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/EnableState.js

    class EnableState {
      constructor(eventEmitter, selectionModel, clipBoard) {
        // Enable always enabled buttons.
        this._states = new Map([
          ['read', true],
          ['write', true],
          ['view', true],
          ['term', true],
          ['block', true],
          ['relation', true],
          ['simple', true],
          ['setting', true],
          ['help', true]
        ])

        this._eventEmitter = eventEmitter
        this._selectionModel = selectionModel
        this._clipBoard = clipBoard

        eventEmitter
          .on('textae-event.history.change', (history) => {
            // change button state
            this.enable('undo', history.hasAnythingToUndo)
            this.enable('redo', history.hasAnythingToRedo)
          })
          .on('textae-event.selection.span.change', () => this._updateButtons())
          .on('textae-event.selection.relation.change', () =>
            this._updateButtons()
          )
          .on('textae-event.selection.entity.change', () =>
            this._updateButtons()
          )
          .on('textae-event.edit-mode.transition', (mode) =>
            this._setForMode(mode)
          )
          .on('textae-event.clip-board.change', () => this._updateByClipboard())
          .on('textae-event.annotation-auto-saver.enable', (enable) =>
            this.enable('write-auto', enable)
          )
      }

      get(button) {
        return this._states.get(button)
      }

      enable(button, enable) {
        this._states.set(button, enable)
        this._propagate()
      }

      updateManipulateSpanButtons(
        enableToCreate,
        enableToExpand,
        enableToShrink
      ) {
        this._states.set('create-span', enableToCreate)
        this._states.set('expand-span', enableToExpand)
        this._states.set('shrink-span', enableToShrink)
        this._propagate()
      }

      _updateButtons() {
        for (const { type, enableWhenSelecting } of new ButtonConfig()
          .enabelButtonsWhenSelecting) {
          this.enable(
            type,
            enableWhenSelecting(this._selectionModel, this._clipBoard)
          )
        }
        this._propagate()
      }

      _updateByClipboard() {
        this.enable(
          'paste',
          new ButtonConfig().pasteButton.enableWhenSelecting(
            this._selectionModel,
            this._clipBoard
          )
        )
      }

      _propagate() {
        this._eventEmitter.emit(
          'textae-event.control.buttons.change',
          this._states.keys()
        )
      }

      _setForMode(mode) {
        switch (mode) {
          case MODE.VIEW_WITHOUT_RELATION:
          case MODE.VIEW_WITH_RELATION:
            this._updateButtonsForMode(
              true,
              false,
              false,
              false,
              false,
              false,
              false
            )
            break
          case MODE.EDIT_DENOTATION_WITHOUT_RELATION:
          case MODE.EDIT_DENOTATION_WITH_RELATION:
            this._updateButtonsForMode(true, true, true, true, true, true, true)
            break
          case MODE.EDIT_BLOCK_WITHOUT_RELATION:
          case MODE.EDIT_BLOCK_WITH_RELATION:
            this._updateButtonsForMode(
              true,
              false,
              true,
              true,
              true,
              true,
              true
            )
            break
          case MODE.EDIT_RELATION:
            this._updateButtonsForMode(
              false,
              false,
              false,
              true,
              true,
              false,
              true
            )
            break
          default:
            throw `unknown edit mode!${mode}`
        }
        this._propagate()
      }

      _updateButtonsForMode(
        simple,
        replicateAuto,
        boundaryDetection,
        lineHeight,
        lineHeightAuto,
        span,
        pallet
      ) {
        this._states.set('simple', simple)
        this._states.set('replicate-auto', replicateAuto)
        this._states.set('boundary-detection', boundaryDetection)
        this._states.set('line-height', lineHeight)
        this._states.set('line-height-auto', lineHeightAuto)
        this._states.set('create-span', span)
        this._states.set('expand-span', span)
        this._states.set('shrink-span', span)
        this._states.set('pallet', pallet)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/skipCharacters.js

    /* harmony default export */ function skipCharacters(
      getChars,
      step,
      str,
      position,
      predicate
    ) {
      while (predicate(getChars(str, position))) position += step

      return position
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/skipBlank.js

    const getNow = function (str, position) {
      return str.charAt(position)
    }
    const skipForwardBlank = function (str, position, isBlankCharacter) {
      return skipCharacters(getNow, 1, str, position, isBlankCharacter)
    }
    const skipBackBlank = function (str, position, isBlankCharacter) {
      return skipCharacters(getNow, -1, str, position, isBlankCharacter)
    }

    /* harmony default export */ const skipBlank = {
      forward: skipForwardBlank,
      back: skipBackBlank
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/SpanAdjuster.js

    class SpanAdjuster {
      backFromBegin(str, position, spanConfig) {}

      forwardFromEnd(str, position, spanConfig) {}

      forwardFromBegin(str, position, spanConfig) {}

      backFromEnd(str, position, spanConfig) {}
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/getPrev.js

    /* harmony default export */ function getPrev(str, position) {
      return [str.charAt(position), str.charAt(position - 1)]
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/backToDelimiter.js

    /* harmony default export */ function backToDelimiter(
      str,
      position,
      isDelimiter
    ) {
      return skipCharacters(getPrev, -1, str, position, (chars) => {
        // Proceed the position between two characters as (!delimiter delimiter) || (delimiter !delimiter) || (!delimiter !delimiter).
        return chars[1] && !isDelimiter(chars[0]) && !isDelimiter(chars[1])
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/getNext.js

    /* harmony default export */ function getNext(str, position) {
      return [str.charAt(position), str.charAt(position + 1)]
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/skipToDelimiter.js

    function skipToDelimiter(str, position, isDelimiter) {
      return skipCharacters(getNext, 1, str, position, (chars) => {
        // Proceed the position between two characters as (!delimiter delimiter) || (delimiter !delimiter) || (!delimiter !delimiter).
        // Return false to stop an infinite loop when the character undefined.
        return chars[1] && !isDelimiter(chars[0]) && !isDelimiter(chars[1])
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/isNotWord.js

    /* harmony default export */ function isNotWord(
      isBlankCharacter,
      isDelimiter,
      chars
    ) {
      // The word is (no charactor || blank || delimiter)(!delimiter).
      return (
        (chars[0] !== '' &&
          !isBlankCharacter(chars[1]) &&
          !isDelimiter(chars[1])) ||
        isDelimiter(chars[0])
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/skipToWord.js

    /* harmony default export */ function skipToWord(
      str,
      position,
      isWordEdge
    ) {
      return skipCharacters(getPrev, 1, str, position, isWordEdge)
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/backToWord.js

    /* harmony default export */ function backToWord(
      str,
      position,
      isWordEdge
    ) {
      return skipCharacters(getNext, -1, str, position, isWordEdge)
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/DelimiterDetectAdjuster/index.js

    class DelimiterDetectAdjuster extends SpanAdjuster {
      backFromBegin(str, beginPosition, spanConfig) {
        const nonEdgePos = skipBlank.forward(str, beginPosition, (char) =>
          spanConfig.isBlankCharacter(char)
        )
        const nonDelimPos = backToDelimiter(str, nonEdgePos, (char) =>
          spanConfig.isDelimiter(char)
        )

        return nonDelimPos
      }

      forwardFromEnd(str, endPosition, spanConfig) {
        const nonEdgePos = skipBlank.back(str, endPosition, (char) =>
          spanConfig.isBlankCharacter(char)
        )
        const nonDelimPos = skipToDelimiter(str, nonEdgePos, (char) =>
          spanConfig.isDelimiter(char)
        )

        return nonDelimPos
      }

      // adjust the beginning position of a span for shortening
      forwardFromBegin(str, beginPosition, spanConfig) {
        const isWordEdge = (chars) =>
          isNotWord(
            (char) => spanConfig.isBlankCharacter(char),
            (char) => spanConfig.isDelimiter(char),
            chars
          )

        return skipToWord(str, beginPosition, isWordEdge)
      }

      // adjust the end position of a span for shortening
      backFromEnd(str, endPosition, spanConfig) {
        const isWordEdge = (chars) =>
          isNotWord(
            (char) => spanConfig.isBlankCharacter(char),
            (char) => spanConfig.isDelimiter(char),
            chars
          )

        return backToWord(str, endPosition, isWordEdge)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/BlankSkipAdjuster.js

    class BlankSkipAdjuster extends SpanAdjuster {
      backFromBegin(str, position, spanConfig) {
        return skipBlank.forward(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }

      forwardFromEnd(str, position, spanConfig) {
        return skipBlank.back(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }

      forwardFromBegin(str, position, spanConfig) {
        return skipBlank.forward(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }

      backFromEnd(str, position, spanConfig) {
        return skipBlank.back(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/ButtonController/index.js

    class ButtonController {
      constructor(
        eventEmitter,
        selectionModel,
        clipBoard,
        annotationDataEventsObserver,
        originalData,
        typeDefinition
      ) {
        this._enableState = new EnableState(
          eventEmitter,
          selectionModel,
          clipBoard
        )
        // Save state of push control buttons.
        this._pushButtons = new PushButtons(eventEmitter)

        this._annotationDataEventsObserver = annotationDataEventsObserver

        this._buttonConfig = new ButtonConfig(eventEmitter)

        this._originalData = originalData

        this._typeDefinition = typeDefinition
      }

      get pushButtonNames() {
        return this._pushButtons.names
      }

      isPushed(buttonName) {
        return this._pushButtons.get(buttonName).isPushed
      }

      push(buttonName) {
        this._pushButtons.get(buttonName).isPushed = true
      }

      release(buttonName) {
        this._pushButtons.get(buttonName).isPushed = false
      }

      toggleButton(buttonName) {
        return this._pushButtons.get(buttonName).toggle()
      }

      get spanAdjuster() {
        return this.isPushed('boundary-detection')
          ? new DelimiterDetectAdjuster()
          : new BlankSkipAdjuster()
      }

      get controlBarButton() {
        return new ButtonConfig().controlBar.map(({ list }) => {
          const ret = []
          for (const { type, title } of list) {
            ret.push({
              type,
              title,
              pushed: this.getState(type, 'pushed'),
              disabled: this.getState(type, 'disabled'),
              trasit: this.getState(type, 'trasit')
            })
          }

          return ret
        })
      }

      get contextMenuButton() {
        return this._buttonConfig.contextMenu
          .map(({ list }) => {
            const ret = []
            for (const { type, title } of list) {
              if (!isTouchable() && this.getState(type, 'disabled')) {
                continue
              }

              ret.push({
                type,
                title,
                pushed: this.getState(type, 'pushed'),
                disabled: this.getState(type, 'disabled'),
                trasit: this.getState(type, 'trasit')
              })
            }

            return ret
          })
          .filter((list) => list.length)
      }

      getState(name, state) {
        switch (state) {
          case 'pushed':
            return this._pushButtons.get(name).isPushed
          case 'disabled':
            return !this._enableState.get(name)
          case 'transit':
            switch (name) {
              case 'write':
                return this._annotationDataEventsObserver.hasChange
              case 'pallet':
                return this.diffOfConfiguration
              default:
                new Error('Unknown name')
            }
            break
          default:
            new Error('Unknown state')
        }
      }

      updateManipulateSpanButtons(
        enableToCreate,
        enableToExpand,
        enableToShrink
      ) {
        this._enableState.updateManipulateSpanButtons(
          enableToCreate,
          enableToExpand,
          enableToShrink
        )
      }

      get diffOfConfiguration() {
        return (0, jsondiffpatch_umd.diff)(this._originalData.configuration, {
          ...this._originalData.configuration,
          ...this._typeDefinition.config
        })
      }
    } // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues
    var rnds8 = new Uint8Array(16)
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues =
          (typeof crypto !== 'undefined' &&
            crypto.getRandomValues &&
            crypto.getRandomValues.bind(crypto)) ||
          (typeof msCrypto !== 'undefined' &&
            typeof msCrypto.getRandomValues === 'function' &&
            msCrypto.getRandomValues.bind(msCrypto))

        if (!getRandomValues) {
          throw new Error(
            'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
          )
        }
      }

      return getRandomValues(rnds8)
    } // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js
    /* harmony default export */ const regex =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js
    function validate_validate(uuid) {
      return typeof uuid === 'string' && regex.test(uuid)
    }

    /* harmony default export */ const esm_browser_validate = validate_validate // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js
    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = []

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1))
    }

    function stringify(arr) {
      var offset =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (
        byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]
      ).toLowerCase() // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!esm_browser_validate(uuid)) {
        throw TypeError('Stringified UUID is invalid')
      }

      return uuid
    }

    /* harmony default export */ const esm_browser_stringify = stringify // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js
    function v4(options, buf, offset) {
      options = options || {}
      var rnds = options.random || (options.rng || rng)() // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = (rnds[6] & 0x0f) | 0x40
      rnds[8] = (rnds[8] & 0x3f) | 0x80 // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i]
        }

        return buf
      }

      return esm_browser_stringify(rnds)
    }

    /* harmony default export */ const esm_browser_v4 = v4 // CONCATENATED MODULE: ./src/lib/Editor/API/Clipboard/index.js
    class Clipboard {
      /**
       * @param {import('../Commander').default} commander
       * @param {import('../SelectionModel').default} selectionModel
       * @param {AttributeDefinitionContainer} attributeDefinitionContainer
       * */
      constructor(
        eventEmitter,
        commander,
        selectionModel,
        denotationDefinitionContainer,
        attributeDefinitionContainer,
        typeDefinition
      ) {
        this._eventEmitter = eventEmitter
        this._commander = commander
        this._selectionModel = selectionModel
        this._denotationDefinitionContainer = denotationDefinitionContainer
        this._attributeDefinitionContainer = attributeDefinitionContainer
        this._typeDefinition = typeDefinition

        // This list stores two types of things: type for copy and entity for cut.
        // Only one type is stored at a time.
        // Use one list.
        this._items = []
        this._uuid = esm_browser_v4()

        eventEmitter
          .on('textae-event.annotation-data.entity.remove', (entity) => {
            if (this.hasCuttingItem) {
              this._updateItems(this._items.filter((e) => e != entity))
            }
          })
          .on('textae-event.edit-mode.transition', () => this._updateItems())
      }

      get hasCopyingItem() {
        return this._items[0] instanceof TypeValues
      }

      get hasCuttingItem() {
        return this._items[0] instanceof EntityModel
      }

      copyEntitiesToLocalClipboard() {
        this._updateItems(this._selectionModel.copyingTargets)
      }

      copyEntitiesToSystemClipboard(clipboardEvent) {
        if (this._selectionModel.span.contains((s) => s.isBlock)) {
          return
        }

        const { copyingTargets } = this._selectionModel

        if (copyingTargets.length > 0) {
          const entityTypes = this._denotationDefinitionContainer.config.filter(
            ({ id }) => copyingTargets.some(({ typeName }) => typeName === id)
          )

          const attributeTypes =
            this._attributeDefinitionContainer.config.filter(({ pred }) =>
              copyingTargets.some(({ attributes }) =>
                attributes.some((a) => a.pred === pred)
              )
            )

          const dataString = JSON.stringify({
            typeValues: copyingTargets.map(({ JSON }) => JSON),
            config: {
              'entity types': entityTypes,
              'attribute types': attributeTypes
            }
          })

          clipboardEvent.clipboardData.setData('text/plain', dataString)
          clipboardEvent.clipboardData.setData(
            'application/x-textae-type-values',
            dataString
          )
          clipboardEvent.preventDefault()
        }
      }

      cutEntitiesToLocalClipboard() {
        const { cuttingTargets } = this._selectionModel

        //  When exactly the same entities that are being cut are selected, the cut is canceled.
        if (
          this._cuttingItems.length &&
          this._cuttingItems.every((item) => cuttingTargets.has(item)) &&
          [...cuttingTargets].every((item) => this._cuttingItems.includes(item))
        ) {
          this._updateItems()
        } else {
          this._updateItems([...cuttingTargets])
        }
      }

      cutEntitiesToSystemClipboard(clipboardEvent) {
        if (this._selectionModel.span.contains((s) => s.isBlock)) {
          return
        }

        this.cutEntitiesToLocalClipboard()

        clipboardEvent.clipboardData.setData(
          'application/x-textae-editor-uuid',
          this._uuid
        )

        this.copyEntitiesToSystemClipboard(clipboardEvent)
      }

      pasteEntitiesFromLocalClipboard() {
        if (
          this._itemsWillBeCutAndPaste.length &&
          this._selectionModel.span.single
        ) {
          this._moveEntities()
          return
        }

        if (this.hasCopyingItem) {
          const command =
            this._commander.factory.pasteTypesToSelectedSpansCommand(
              this._items
            )
          this._commander.invoke(command)
        }
      }

      pasteEntitiesFromSystemClipboard(clipboardEvent) {
        if (this._selectionModel.span.contains((s) => s.isBlock)) {
          return
        }

        const uuid = clipboardEvent.clipboardData.getData(
          'application/x-textae-editor-uuid'
        )
        if (
          uuid === this._uuid &&
          this._itemsWillBeCutAndPaste.length &&
          this._selectionModel.span.single
        ) {
          this._moveEntities()
          return
        }

        const copyData = clipboardEvent.clipboardData.getData(
          'application/x-textae-type-values'
        )

        if (copyData) {
          const data = JSON.parse(copyData)
          const newAttrDefContainer = new AttributeDefinitionContainer()
          newAttrDefContainer.definedTypes = data.config['attribute types']

          if (this._typeDefinition.isLock) {
            const typeValuesList = data.typeValues.map(
              ({ obj, attributes }) =>
                new TypeValues(
                  obj,
                  attributes.filter(
                    ({ pred }) =>
                      this._attributeDefinitionContainer.get(pred) &&
                      this._attributeDefinitionContainer.get(pred).valueType ===
                        newAttrDefContainer.get(pred).valueType
                  )
                )
            )

            const command =
              this._commander.factory.pasteTypesToSelectedSpansCommand(
                typeValuesList
              )
            this._commander.invoke(command)
          } else {
            const typeValuesList = data.typeValues.map(
              ({ obj, attributes }) =>
                new TypeValues(
                  obj,
                  attributes.filter(
                    ({ pred }) =>
                      !this._attributeDefinitionContainer.get(pred) ||
                      this._attributeDefinitionContainer.get(pred).valueType ===
                        newAttrDefContainer.get(pred).valueType
                  )
                )
            )

            const newTypes = data.config['entity types'].filter(
              ({ id }) =>
                !this._denotationDefinitionContainer.config.some(
                  (type) => type.id === id
                )
            )
            const attrDefs = data.config['attribute types'].filter(
              ({ pred }) => !this._attributeDefinitionContainer.get(pred)
            )

            const command =
              this._commander.factory.pasteTypesToSelectedSpansCommand(
                typeValuesList,
                newTypes,
                attrDefs,
                this._getNewSelectionAttributeObjects(
                  typeValuesList,
                  newAttrDefContainer
                )
              )
            this._commander.invoke(command)
          }

          if (this.hasCuttingItem) {
            this._updateItems()
          }

          return
        }
      }

      // If there is an attribute definition for the selection attribute to be added
      // but the value definition is missing, add the value definition.
      _getNewSelectionAttributeObjects(typeValuesList, newAttrDefContainer) {
        const newSelectionAttributeObjects = []
        const selectionAttibutes = typeValuesList.reduce((list, typeValue) => {
          return list.concat(
            typeValue.attributes.filter(
              ({ pred }) =>
                newAttrDefContainer.get(pred).valueType === 'selection'
            )
          )
        }, [])
        for (const { pred, obj } of selectionAttibutes) {
          if (this._attributeDefinitionContainer.get(pred)) {
            if (
              !this._attributeDefinitionContainer
                .get(pred)
                .values.some(({ id }) => id === obj)
            ) {
              const value = newAttrDefContainer
                .get(pred)
                .values.find(({ id }) => id === obj)

              newSelectionAttributeObjects.push({
                pred,
                value
              })
            }
          }
        }
        return newSelectionAttributeObjects
      }

      _moveEntities() {
        const command =
          this._commander.factory.moveEntitiesToSelectedSpanCommand(
            this._itemsWillBeCutAndPaste
          )
        this._commander.invoke(command)
        this._updateItems()
      }

      // Notify items that are cutting and items that are no longer cutting
      // in order to switch between highlighting entities that are cutting.
      _updateItems(newItems = []) {
        const oldItems = this._cuttingItems.filter((i) => !newItems.includes(i))
        this._items = newItems

        this._eventEmitter.emit(
          'textae-event.clip-board.change',
          this._cuttingItems,
          oldItems
        )
      }

      // Exclude entities of the selected span.
      // When you cut and paste an entity,
      // the destination of the entity is the selected span.
      // If the destination and source spans are the same,
      // there is no change in the model.
      // In order to cause no change in the command history,
      // if the span of the entity being cut is the same as the span being selected, the entity is not pasted.
      get _itemsWillBeCutAndPaste() {
        return this._cuttingItems.filter(
          (i) =>
            i.span.id !==
            (this._selectionModel.span.single &&
              this._selectionModel.span.single.id)
        )
      }

      get _cuttingItems() {
        return this.hasCuttingItem ? this._items : []
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/AnnotationAutoSaver.js

    class AnnotationAutoSaver {
      constructor(
        eventEmitter,
        buttonController,
        persistenceInterface,
        saveToParameter,
        annotationDataEventsObserver
      ) {
        this._buttonController = buttonController

        const debounceSaveAnnotation = debounce_default()(
          () => persistenceInterface.saveAnnotation(),
          5000
        )

        eventEmitter
          .on('textae-event.resource.annotation.load.success', () =>
            this._disabled()
          )
          .on('textae-event.resource.save.error', () => this._disabled())
          .on('textae-event.resource.annotation.url.set', (dataSource) =>
            eventEmitter.emit(
              'textae-event.annotation-auto-saver.enable',
              Boolean(saveToParameter || dataSource.id)
            )
          )
          .on('textae-event.control.button.push', ({ name, isPushed }) => {
            // If there is something to save when the 'write-auto' button is pushed,
            // it will be saved immediately.
            if (
              name === 'write-auto' &&
              isPushed === true &&
              annotationDataEventsObserver.hasChange
            ) {
              persistenceInterface.saveAnnotation()
            }
          })
          .on('textae-event.annotation-data.events-observer.change', (val) => {
            if (val && buttonController.isPushed('write-auto')) {
              debounceSaveAnnotation()
            }
          })
      }

      _disabled() {
        if (this._buttonController.isPushed('write-auto')) {
          this._buttonController.toggleButton('write-auto')
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/Control/bindEventHandler.js

    const bindEventHandler_helpDialog = new HelpDialog()

    /* harmony default export */ function bindEventHandler(el, iconEventMap) {
      // Monitor the touchestart event to get the currently selected text.
      // On the iPad, the mousedown event fires after the text is deselected.
      delegate_default()(
        el,
        '.textae-control-icon',
        'touchstart',
        ({ target }) => {
          // Ignore disabled button's events.
          if (target.classList.contains('textae-control-icon--disabled')) {
            return
          }

          const { buttonType } = target.dataset
          switch (buttonType) {
            case 'create-span':
            case 'expand-span':
            case 'shrink-span':
              iconEventMap.handle(buttonType)
              break
            default:
          }
        },
        { passive: true }
      )

      delegate_default()(el, '.textae-control-icon', 'click', ({ target }) => {
        // Ignore disabled button's events.
        if (target.classList.contains('textae-control-icon--disabled')) {
          return
        }

        const { buttonType } = target.dataset
        switch (buttonType) {
          case 'help':
            bindEventHandler_helpDialog.open()
            break
          case 'create-span':
          case 'expand-span':
          case 'shrink-span':
            // Monitor the mousedown event to get the currently selected text.
            break
          default:
            iconEventMap.handle(buttonType)
        }
      })

      const hamburgerMenuButton = el.querySelector(
        '.textae-control-humburger-menu-button'
      )
      if (hamburgerMenuButton) {
        hamburgerMenuButton.addEventListener('click', (e) =>
          e.target
            .closest('.textae-control')
            .querySelector('.textae-control-details')
            .classList.toggle('textae-control-details--force-show')
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/Control/index.js

    // The control is a control bar in an editor.
    class Control {
      constructor(html, iconEventMap) {
        const el = dohtml_default().create(html)

        this._el = el
        bindEventHandler(this._el, iconEventMap)
      }

      get el() {
        return this._el
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ControlBar/toButtonGroup/toButtonIcon.js

    /* harmony default export */ function toButtonIcon({
      type,
      title,
      classList
    }) {
      return `
<span 
class="${classList.join(' ')}" 
title="${title}" 
data-button-type="${type}">
</span>
`
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ControlBar/toButtonGroup/index.js

    /* harmony default export */ function toButtonGroup() {
      return (list) => `
  <span class="textae-control-separator"></span>
  ${list.map(toButtonIcon).join('\n')}
  `
    }

    // EXTERNAL MODULE: ./node_modules/sticky-js/index.js
    var sticky_js = __webpack_require__(5820)
    var sticky_js_default = /*#__PURE__*/ __webpack_require__.n(sticky_js) // CONCATENATED MODULE: ./src/lib/Editor/control/classify.js
    /* harmony default export */ function classify(buttonGroup) {
      return buttonGroup.map((list) => {
        const ret = []
        for (const { type, title, pushed, disabled, transit } of list) {
          const classList = [
            'textae-control-icon',
            `textae-control-${type}-button`
          ]
          if (pushed) {
            classList.push('textae-control-icon--pushed')
          }
          if (disabled) {
            classList.push('textae-control-icon--disabled')
          }
          if (transit) {
            classList.push('textae-control-icon--transit')
          }

          ret.push({ type, title, classList })
        }

        return ret
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ControlBar/index.js

    function ControlBar_template(context) {
      return `
<div class="textae-control ${
        isTouchable() ? 'textae-touch-bar' : 'textae-control-bar'
      }">
  <div class="textae-control-summary">
    <span class="textae-control-title">
      <a href="http://textae.pubannotation.org/" target="_blank">TextAE</a>
    </span>
    <button type="button" class="textae-control-humburger-menu-button" >
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" class="bi" fill="currentColor" viewBox="0 0 16 16">
        <path fill-rule="evenodd" d="M2.5 11.5A.5.5 0 0 1 3 11h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 3h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>
      </svg>
    </button>
  </div>
  <div class="textae-control-details">
    <span class="textae-control-title">
      <a href="http://textae.pubannotation.org/" target="_blank">TextAE</a>
    </span>
    ${context.map(toButtonGroup()).join('\n')}
  </div>
</div>
`
    }

    // The control is a control bar in an editor.
    class ControlBar extends Control {
      constructor(eventEmitter, buttonController, iconEventMap) {
        super(
          ControlBar_template(classify(buttonController.controlBarButton)),
          iconEventMap
        )

        this._buttonController = buttonController

        // If you use position: sticky,
        // the height of the toolbar will affect the Y coordinate of the textae-body
        // when the browser is not scrolling.
        // When the height of the toolbar is changed using the hamburger menu button,
        // the position of the textae-body will be raised or lowered.
        // When the browser is scrolling,
        // the position of the textae-body is not affected by the height of the toolbar,
        // so changing the height of the toolbar
        // will not raise or lower the position of the textae-body.
        // I would like to unify the behavior of the textae-body position
        // when scrolling with the browser and when not scrolling.
        // When displaying the hamburger menu button,
        // specify position: absolute for the toolbar
        // to exclude the toolbar from the calculation of the Y coordinate of the textae-body.
        // Instead, we will use JavaScript to adjust the position of the toolbar
        // as the browser scrolls.
        if (
          isTouchable() &&
          Math.max(document.documentElement.clientWidth, window.innerWidth) <
            768
        ) {
          new (sticky_js_default())('.textae-touch-bar', {
            stickyContainer: '.textae-editor'
          })
        }

        eventEmitter
          .on('textae-event.control.button.push', ({ name }) => {
            this._updateButton(name, 'pushed')
          })
          .on('textae-event.control.buttons.change', (buttons) => {
            for (const name of buttons) {
              this._updateButton(name, 'disabled')
            }
          })
          .on('textae-event.annotation-data.events-observer.change', () => {
            this._updateButton('write', 'transit')
          })
          .on('textae-event.control.pallet-button.change-title', (title) => {
            const button = this._el.querySelector(
              `.textae-control-pallet-button`
            )
            button.title = title
          })
          .on('textae-event.orginal-data.configuration.reset', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.entity.change', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.entity.delete', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.entity.change-default', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.relation.change', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.relation.delete', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.relation.change-default', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.create', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.change', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.delete', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.move', () =>
            this._updateButton('pallet', 'transit')
          )
      }

      _updateButton(buttonName, stateName) {
        const button = this._el.querySelector(
          `.textae-control-${buttonName}-button`
        )

        if (button) {
          if (this._buttonController.getState(buttonName, stateName)) {
            button.classList.add(`textae-control-icon--${stateName}`)
          } else {
            button.classList.remove(`textae-control-icon--${stateName}`)
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ContextMenu/toContextMenuItem.js

    /* harmony default export */ function toContextMenuItem({
      type,
      title,
      classList
    }) {
      return `<p 
    class="${classList.join(' ')}"  
    data-button-type="${type}">${title}
  </p>`
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ContextMenu/index.js

    class ContextMenu extends Control {
      constructor(editorHTMLElement, buttonController, iconEventMap) {
        super(
          `<div class="textae-control ${
            isTouchable()
              ? 'textae-android-context-menu'
              : 'textae-context-menu'
          }"></div>`,
          iconEventMap
        )

        this._editorHTMLElement = editorHTMLElement
        this._buttonController = buttonController
      }

      show(contextmenuEvent) {
        const selection = window.getSelection()

        if (isTouchable() && selection.rangeCount === 1) {
          const rectOfSelection = selection
            .getRangeAt(0)
            .getBoundingClientRect()
          const rectOfTextBox = this._editorHTMLElement
            .querySelector('.textae-editor__text-box')
            .getBoundingClientRect()

          this._showAbove(
            rectOfSelection.y -
              this._editorHTMLElement.getBoundingClientRect().y,
            rectOfSelection.x - rectOfTextBox.x
          )
        } else {
          // The context menu is `position:absolute` in the editor.
          // I want the coordinates where you right-click with the mouse,
          // starting from the upper left of the editor.
          // So the Y coordinate is pageY minus the editor's offsetTop.
          this._showLowerRight(
            contextmenuEvent.pageY - this._editorHTMLElement.offsetTop,
            contextmenuEvent.pageX
          )
        }
      }

      hide() {
        if (this._isOpen) {
          super.el.classList.remove('textae-context-menu--show')
          super.el.classList.add('textae-context-menu--hide')
        }
      }

      get _isOpen() {
        return super.el.classList.contains('textae-context-menu--show')
      }

      _showAbove(positionTop, positionLeft) {
        this._show()

        const { height } = this.el.getBoundingClientRect()
        super.el.setAttribute(
          'style',
          `top: ${positionTop - height}px; left: ${positionLeft}px`
        )
      }

      _showLowerRight(positionTop, positionLeft) {
        this._show()

        super.el.setAttribute(
          'style',
          `top: ${positionTop}px; left: ${positionLeft}px`
        )
      }

      _show() {
        const context = classify(this._buttonController.contextMenuButton)
        const html = `
    <div">
      ${context
        .map((list) => list.map(toContextMenuItem).join(''))
        .join('<p class="textae-control-separator"></p>\n')}
    </div>
    `
        super.el.replaceChildren(...dohtml_default().create(html).children)
        super.el.classList.remove('textae-context-menu--hide')
        super.el.classList.add('textae-context-menu--show')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/KeyEventMap.js

    class KeyEventMap {
      constructor(commander, presenter, persistenceInterface) {
        this._map = new Map([
          ['1', (shiftKey) => presenter.manipulateAttribute(1, shiftKey)],
          ['2', (shiftKey) => presenter.manipulateAttribute(2, shiftKey)],
          ['3', (shiftKey) => presenter.manipulateAttribute(3, shiftKey)],
          ['4', (shiftKey) => presenter.manipulateAttribute(4, shiftKey)],
          ['5', (shiftKey) => presenter.manipulateAttribute(5, shiftKey)],
          ['6', (shiftKey) => presenter.manipulateAttribute(6, shiftKey)],
          ['7', (shiftKey) => presenter.manipulateAttribute(7, shiftKey)],
          ['8', (shiftKey) => presenter.manipulateAttribute(8, shiftKey)],
          ['9', (shiftKey) => presenter.manipulateAttribute(9, shiftKey)],
          ['a', () => commander.redo()],
          ['b', () => presenter.toggleButton('boundary-detection')],
          ['d', () => presenter.removeSelectedElements()],
          ['e', () => presenter.createEntity()],
          ['f', () => presenter.changeModeByShortcut()],
          ['i', () => persistenceInterface.importAnnotation()],
          ['m', () => presenter.changeModeByShortcut()],
          ['q', () => presenter.showPallet()],
          ['r', () => presenter.replicate()],
          ['u', () => persistenceInterface.uploadAnnotation()],
          ['w', () => presenter.editTypeValues()],
          ['y', () => commander.redo()],
          ['z', () => commander.undo()],
          ['ArrowDown', () => presenter.selectDown()],
          ['ArrowLeft', (shiftKey) => presenter.selectLeft(shiftKey)],
          ['ArrowRight', (shiftKey) => presenter.selectRight(shiftKey)],
          ['ArrowUp', () => presenter.selectUp()],
          ['Backspace', () => presenter.removeSelectedElements()],
          ['Delete', () => presenter.removeSelectedElements()],
          ['Escape', () => presenter.cancelSelect()]
        ])
      }

      handle(event) {
        // The value of the key property when pressing a key while holding down the Shift key depends on the keyboard layout.
        // For example, on a US keyboard, the shift + 1 keystroke is !.
        // When shift and number key are pressed, the input value is taken from the keyCode property.
        const key =
          event.shiftKey && 48 <= event.keyCode && event.keyCode <= 57
            ? String.fromCharCode(event.keyCode)
            : event.key

        if (this._map.has(key)) {
          this._map.get(key)(event.shiftKey)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/IconEventMap.js

    class IconEventMap {
      constructor(
        commander,
        presenter,
        persistenceInterface,
        buttonController,
        annotationData
      ) {
        this._map = new Map([
          ['view', () => presenter.toViewMode()],
          ['term', () => presenter.toTermMode()],
          ['block', () => presenter.toBlockMode()],
          ['relation', () => presenter.toRelationMode()],
          ['simple', () => presenter.toggleSimpleMode()],
          ['read', () => persistenceInterface.importAnnotation()],
          ['write', () => persistenceInterface.uploadAnnotation()],
          ['undo', () => commander.undo()],
          ['redo', () => commander.redo()],
          ['replicate', () => presenter.replicate()],
          ['create-span', () => presenter.createSpan()],
          ['expand-span', () => presenter.expandSpan()],
          ['shrink-span', () => presenter.shrinkSpan()],
          ['entity', () => presenter.createEntity()],
          ['change-label', () => presenter.editTypeValues()],
          ['pallet', () => presenter.showPallet()],
          ['delete', () => presenter.removeSelectedElements()],
          ['copy', () => presenter.copyEntitiesToLocalClipboard()],
          ['cut', () => presenter.cutEntitiesToLocalClipboard()],
          ['paste', () => presenter.pasteEntitiesFromLocalClipboard()],
          ['setting', () => presenter.showSettingDialog()],
          ['line-height', () => annotationData.textBox.updateLineHeight()]
        ])

        // Set handler for push buttons.
        for (const buttonName of buttonController.pushButtonNames) {
          if (!this._map.has(buttonName)) {
            this._map.set(buttonName, () => presenter.toggleButton(buttonName))
          }
        }
      }

      handle(key) {
        if (this._map.has(key)) {
          this._map.get(key)()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationDataEventsObserver/diffOfAnnotation.js

    /* harmony default export */ function diffOfAnnotation(
      originalData,
      annotationData
    ) {
      return (0, jsondiffpatch_umd.diff)(
        prepareDiff(originalData.annotation),
        prepareDiff(annotationData.JSON)
      )
    }

    function prepareDiff({
      denotations = [],
      attributes = [],
      relations = [],
      blocks = []
    }) {
      return {
        denotations: denotations.sort(byID),
        attributes: attributes.sort(byID),
        relations: relations.sort(byID),
        blocks: blocks.sort(byID)
      }
    }

    function byID(a, b) {
      if (a.id < b.id) {
        return -1
      }
      if (a.id > b.id) {
        return 1
      }
      return 0
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationDataEventsObserver/index.js

    // Maintainance a state of which the save button is able to be push.

    class AnnotationDataEventsObserver {
      /**
       *
       * @param {import('../API/OriginalData').default} originalData
       * @param {import('../AnnotationData').default} annotationData
       */
      constructor(eventEmitter, originalData, annotationData) {
        this._originalData = originalData
        this._annotationData = annotationData
        this._observable = new (observ_default())(false)

        eventEmitter
          .on('textae-event.resource.annotation.save', () => {
            this._observable.set(false)
            this._loadedAnnotationIsModified = false
          })
          .on('textae-event.annotation-data.all.change', () =>
            this._observable.set(false)
          )
          .on('textae-event.annotation-data.span.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.span.change', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.span.remove', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.change', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.remove', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.move', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.relation.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.relation.change', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.relation.remove', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.attribute.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.attribute.remove', () =>
            this._updateState()
          )

        this._observable(() =>
          eventEmitter.emit(
            'textae-event.annotation-data.events-observer.change',
            this._observable()
          )
        )
      }

      get hasChange() {
        return this._observable()
      }

      _updateState() {
        this._observable.set(
          diffOfAnnotation(this._originalData, this._annotationData)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/RemoteResource/isServerAuthRequired.js

    // When save failed, analyze the response code and headers.
    // If the response follows the followings format, will open 'login-page-url' in a new popup window.
    // ==============================================================
    // 401 Unauthorized
    // WWW-Authenticate: ServerPage
    // Location: login-page-url
    // ==============================================================
    //
    //  Server must returns "Access-Control-Expose-Headers". Because client scripts cannot read the headers
    //  except for 'simple response header' when your requests are CORS.
    // ==============================================================
    // Access-Control-Expose-Headers: WWW-Authenticate,Location
    // ==============================================================
    /* harmony default export */ function isServerAuthRequired(httpResponse) {
      const statusCode = httpResponse.status
      const wwwAuthenticateHeader =
        httpResponse.getResponseHeader('WWW-Authenticate')
      const locationHeader = httpResponse.getResponseHeader('Location')
      const required =
        statusCode === 401 &&
        wwwAuthenticateHeader &&
        wwwAuthenticateHeader === 'ServerPage' &&
        locationHeader
      return required ? locationHeader : null
    } // CONCATENATED MODULE: ./src/lib/Editor/RemoteResource/openPopUp.js

    /* harmony default export */ function openPopUp(url) {
      const width = 600
      const height = 500

      return window.open(url, '_blank', `width=${width}, height=${height}`)
    } // CONCATENATED MODULE: ./src/lib/Editor/RemoteResource/index.js

    // A sub component to save and load data.
    class RemoteSource {
      constructor(eventEmitter) {
        this._eventEmitter = eventEmitter

        // Store the url the annotation data is loaded from per editor.
        this._urlOfLastRead = {
          annotation: '',
          config: ''
        }
      }

      get annotationUrl() {
        return this._urlOfLastRead.annotation
      }

      set annotationUrl(dataSource) {
        if (dataSource.type === 'url') {
          this._urlOfLastRead.annotation = dataSource.id
        }
      }

      get configurationUrl() {
        return this._urlOfLastRead.config
      }

      // The configuration validation is done with setConfigAndAnnotation
      // because it requires both configuration and annotation.
      // The URL is set after the validation.
      set configurationUrl(dataSource) {
        if (dataSource.type === 'url') {
          this._urlOfLastRead.config = dataSource.id
        }
      }

      loadAnnotation(url) {
        console.assert(url, 'url is necessary!')

        this._eventEmitter.emit('textae-event.resource.startLoad')

        jquery_default()
          .ajax({
            type: 'GET',
            url,
            cache: false,
            xhrFields: {
              withCredentials: true
            },
            timeout: 30000
          })
          .done((annotation) => {
            const dataSource = new DataSource('url', url, annotation)
            if (annotation && annotation.text) {
              this._eventEmitter.emit(
                'textae-event.resource.annotation.load.success',
                dataSource
              )
              this._eventEmitter.emit(
                'textae-event.resource.annotation.url.set',
                dataSource
              )
            } else {
              this._eventEmitter.emit(
                'textae-event.resource.annotation.format.error',
                dataSource
              )
            }
          })
          .fail(() => {
            alertify_default().error(
              `Could not load the file from the location you specified.: ${url}`
            )
            this._eventEmitter.emit(
              'textae-event.resource.annotation.load.error',
              url
            )
          })
          .always(() =>
            this._eventEmitter.emit('textae-event.resource.endLoad')
          )
      }

      // The second argument is the annotation you want to be notified of
      // when the configuration loading is complete.
      // This is supposed to be used when reading an annotation that does not contain a configuration
      // and then reading the configuration set by the attribute value of the textae-event.
      loadConfigulation(url, annotationDataSource = null) {
        console.assert(url, 'url is necessary!')

        this._eventEmitter.emit('textae-event.resource.startLoad')

        jquery_default()
          .ajax({
            type: 'GET',
            url,
            cache: false,
            xhrFields: {
              withCredentials: true
            },
            timeout: 30000
          })
          .done((config) => {
            this._eventEmitter.emit(
              'textae-event.resource.configuration.load.success',
              new DataSource('url', url, config),
              annotationDataSource
            )
          })
          .fail(() => {
            alertify_default().error(
              `Could not load the file from the location you specified.: ${url}`
            )
            this._eventEmitter.emit(
              'textae-event.resource.configuration.load.error',
              url
            )
          })
          .always(() =>
            this._eventEmitter.emit('textae-event.resource.endLoad')
          )
      }

      saveAnnotation(url, editedData) {
        if (url) {
          this._eventEmitter.emit('textae-event.resource.startSave')

          const opt = {
            type: 'post',
            url,
            contentType: 'application/json',
            data: JSON.stringify(editedData),
            crossDomain: true,
            xhrFields: {
              withCredentials: true
            }
          }
          const successHandler = () => {
            alertify_default().success('annotation saved')
            this._eventEmitter.emit(
              'textae-event.resource.annotation.save',
              editedData
            )
          }
          const failHandler = () => {
            alertify_default().error('could not save')
            this._eventEmitter.emit('textae-event.resource.save.error')
          }

          jquery_default()
            .ajax(opt)
            .done(successHandler)
            .fail((response) => {
              // Authenticate in popup window.
              const location = isServerAuthRequired(response)
              if (!location) {
                return failHandler()
              }

              const window = openPopUp(location)
              if (!window) {
                return failHandler()
              }

              // Watching for cross-domain pop-up windows to close.
              // https://stackoverflow.com/questions/9388380/capture-the-close-event-of-popup-window-in-javascript/48240128#48240128
              const timer = setInterval(() => {
                if (window.closed) {
                  clearInterval(timer)

                  // Retry after authentication.
                  jquery_default()
                    .ajax(opt)
                    .done(successHandler)
                    .fail(failHandler)
                    .always(() =>
                      this._eventEmitter.emit('textae-event.resource.endSave')
                    )
                }
              }, 1000)
            })
            .always(() =>
              this._eventEmitter.emit('textae-event.resource.endSave')
            )
        }
      }

      saveConfiguration(url, editedData) {
        // textae-config service is build with the Ruby on Rails 4.X.
        // To change existing files, only PATCH method is allowed on the Ruby on Rails 4.X.
        if (url) {
          const data = JSON.stringify(editedData)
          const successHandler = () => {
            alertify_default().success('configuration saved')
            this._eventEmitter.emit(
              'textae-event.resource.configuration.save',
              editedData
            )
          }

          this._eventEmitter.emit('textae-event.resource.startSave')

          jquery_default()
            .ajax({
              type: 'patch',
              url,
              contentType: 'application/json',
              data,
              crossDomain: true,
              xhrFields: {
                withCredentials: true
              }
            })
            .done(successHandler)
            .fail(() => {
              // Retry by a post method.
              this._eventEmitter.emit('textae-event.resource.startSave')

              jquery_default()
                .ajax({
                  type: 'post',
                  url,
                  contentType: 'application/json',
                  data,
                  crossDomain: true,
                  xhrFields: {
                    withCredentials: true
                  }
                })
                .done(successHandler)
                .fail(() => {
                  alertify_default().error('could not save')
                  this._eventEmitter.emit('textae-event.resource.save.error')
                })
                .always(() =>
                  this._eventEmitter.emit('textae-event.resource.endSave')
                )
            })
            .always(() =>
              this._eventEmitter.emit('textae-event.resource.endSave')
            )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/SelectionModel/SelectedItems.js

    class SelectedItems {
      constructor(emitter, kindName, annotationData) {
        this._emitter = emitter
        this._kindName = kindName
        this._modelContainer = annotationData[kindName]
      }

      add(id) {
        const modelInstance = this._modelContainer.get(id)

        console.assert(
          modelInstance,
          `${id} is not a instance of ${this._kindName}.`
        )

        if (modelInstance.isSelected) {
          return
        }

        modelInstance.select()
        this.triggerChange()
      }

      has(id) {
        const modelInstance = this._modelContainer.get(id)

        if (modelInstance) {
          return modelInstance.isSelected
        }

        return false
      }

      contains(predicate) {
        for (const v of this._modelContainer.selectedItems) {
          if (predicate(v)) {
            return true
          }
        }

        return false
      }

      get all() {
        return this._modelContainer.selectedItems
      }

      get size() {
        return this._modelContainer.selectedItems.length
      }

      get some() {
        return this.size > 0
      }

      get singleId() {
        const instance = this.single
        if (instance) {
          return instance.id
        }

        return null
      }

      get single() {
        return this.size === 1 ? this._modelContainer.selectedItems[0] : null
      }

      toggle(id) {
        if (this.has(id)) {
          this.remove(id)
        } else {
          this.add(id)
        }
      }

      remove(id) {
        if (this.has(id)) {
          this._modelContainer.get(id).deselect()
          this.triggerChange()
        }
      }

      removeInstance(modelInstance) {
        this.remove(modelInstance.id)
      }

      removeAll() {
        if (this.size === 0) return

        for (const instance of this.all) {
          instance.deselect()
        }

        this.triggerChange()
      }

      triggerChange() {
        this._emitter.emit(`textae-event.selection.${this._kindName}.change`)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/SelectionModel/SelectedItemsWithAttributes.js

    class SelectedItemsWithAttributes extends SelectedItems {
      selectedWithAttributeOf(pred) {
        return this.all.some((item) =>
          item.attributes.some((attribute) => attribute.pred === pred)
        )
      }

      onlySelectedWithJustOneAttributeOf(pred) {
        return this.all.every(
          (item) =>
            item.attributes.filter((attribute) => attribute.pred === pred)
              .length === 1
        )
      }

      selectedWithoutAttributeOf(pred) {
        return this.all.some(
          (item) =>
            !item.attributes.some((attribute) => attribute.pred === pred)
        )
      }

      isDupulicatedPredAttrributeSelected(pred) {
        return this.all.some(
          (item) =>
            item.attributes.filter((attribute) => attribute.pred === pred)
              .length > 1
        )
      }

      findSelectedWithSamePredicateAttribute(pred) {
        return this.all.find((item) =>
          item.attributes.find((attribute) => attribute.pred === pred)
        )
      }

      findSelectedAttributeWithSamePredicate(pred) {
        const itemWithSamePred =
          this.findSelectedWithSamePredicateAttribute(pred)

        if (itemWithSamePred) {
          return itemWithSamePred.attributes.find((a) => a.pred === pred)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/SelectionModel/index.js

    class SelectionModel {
      constructor(eventEmitter, annotationData) {
        this._annotationData = annotationData

        this.span = new SelectedItems(eventEmitter, 'span', annotationData)
        this.entity = new SelectedItemsWithAttributes(
          eventEmitter,
          'entity',
          annotationData
        )
        this.relation = new SelectedItemsWithAttributes(
          eventEmitter,
          'relation',
          annotationData
        )

        // Bind the selection model to the model.
        eventEmitter
          .on('textae-event.annotation-data.span.remove', (span) =>
            this.span.removeInstance(span)
          )
          .on('textae-event.annotation-data.entity.remove', (entity) =>
            this.entity.removeInstance(entity)
          )
          .on('textae-event.annotation-data.relation.remove', (relation) =>
            this.relation.removeInstance(relation)
          )
          .on('textae-event.annotation-data.all.change', () => {
            // When the annotations are reset, the view will remove all HTML elements.
            // The selection model will release the selection instance without any manipulation.
            this.span.triggerChange()
            this.entity.triggerChange()
            this.relation.triggerChange()
          })
      }

      get copyingTargets() {
        // Map entities to types, because entities may be delete.
        return [...this._selectedEntities].map(({ typeValues }) => typeValues)
      }

      get cuttingTargets() {
        return this._selectedEntities
      }

      add(modelType, id) {
        console.assert(this[modelType])
        this[modelType].add(id)
      }

      removeAll() {
        this.span.removeAll()
        this.entity.removeAll()
        this.relation.removeAll()
      }

      selectSpan(id) {
        this.removeAll()
        this.span.add(id)
      }

      selectSpanRange(rangeOfSpans) {
        this.removeAll()
        for (const id of rangeOfSpans) {
          this.span.add(id)
        }
      }

      selectEntity(id) {
        this.removeAll()
        this.entity.add(id)
      }

      selectRelation(id) {
        this.removeAll()
        this.relation.add(id)
      }

      get _selectedEntities() {
        return new Set(
          this.span.all
            .map((span) => span.entities)
            .flat()
            .concat(this.entity.all)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/API/index.js

    class API {
      constructor(
        editorHTMLElement,
        editorID,
        eventEmitter,
        annotationData,
        params
      ) {
        const spanConfig = new SpanConfig()

        // A contaier of selection state.
        const selectionModel = new SelectionModel(eventEmitter, annotationData)

        // Users can edit model only via commands.
        const commander = new Commander(
          editorHTMLElement,
          editorID,
          eventEmitter,
          annotationData,
          selectionModel
        )
        const clipBoard = new Clipboard(
          eventEmitter,
          commander,
          selectionModel,
          annotationData.denotationDefinitionContainer,
          annotationData.attributeDefinitionContainer,
          annotationData.typeDefinition
        )
        const originalData = new OriginalData(
          eventEmitter,
          editorHTMLElement,
          params.get('status_bar')
        )

        const annotationDataEventsObserver = new AnnotationDataEventsObserver(
          eventEmitter,
          originalData,
          annotationData
        )
        const buttonController = new ButtonController(
          eventEmitter,
          selectionModel,
          clipBoard,
          annotationDataEventsObserver,
          originalData,
          annotationData.typeDefinition
        )
        const presenter = new Presenter(
          editorHTMLElement,
          eventEmitter,
          annotationData,
          selectionModel,
          commander,
          spanConfig,
          clipBoard,
          buttonController,
          params.get('autocompletion_ws'),
          params.get('mode')
        )

        const remoteResource = new RemoteSource(eventEmitter)

        const persistenceInterface = new PersistenceInterface(
          eventEmitter,
          remoteResource,
          annotationData,
          () => originalData.annotation,
          () => originalData.configuration,
          params.get('annotation').get('save_to'),
          annotationDataEventsObserver,
          buttonController
        )

        new AnnotationAutoSaver(
          eventEmitter,
          buttonController,
          persistenceInterface,
          params.get('annotation').get('save_to'),
          annotationDataEventsObserver
        )

        eventEmitter
          .on('textae-event.resource.annotation.load.success', (dataSource) => {
            if (!dataSource.data.config && params.get('config')) {
              remoteResource.loadConfigulation(params.get('config'), dataSource)
            } else {
              warningIfBeginEndOfSpanAreNotInteger(dataSource.data)

              if (dataSource.data.config) {
                // When config is specified, it must be JSON.
                // For example, when we load an HTML file, we treat it as text here.
                if (typeof dataSource.data.config !== 'object') {
                  alertify_default().error(
                    `configuration in anntotaion file is invalid.`
                  )
                  return
                }
              }

              const validConfig = validateConfigurationAndAlert(
                dataSource.data,
                dataSource.data.config
              )

              if (validConfig) {
                setAnnotationAndConfiguration(
                  validConfig,
                  buttonController,
                  spanConfig,
                  annotationData,
                  dataSource.data
                )

                originalData.annotation = dataSource
                remoteResource.annotationUrl = dataSource
              }
            }
          })
          .on(
            'textae-event.resource.configuration.load.success',
            (dataSource, loadedAnnotation = null) => {
              // When config is specified, it must be JSON.
              // For example, when we load an HTML file, we treat it as text here.
              if (typeof dataSource.data !== 'object') {
                alertify_default().error(
                  `${dataSource.displayName} is not a configuration file or its format is invalid.`
                )
                return
              }

              if (loadedAnnotation) {
                warningIfBeginEndOfSpanAreNotInteger(loadedAnnotation.data)
              }

              // If an annotation that does not contain a configuration is loaded
              // and a configuration is loaded from a taxtae attribute value,
              // both the loaded configuration and the annotation are passed.
              // If only the configuration is read, the annotation is null.
              const annotation = (loadedAnnotation &&
                loadedAnnotation.data) || {
                ...originalData.annotation,
                ...annotationData.JSON
              }

              const validConfig = validateConfigurationAndAlert(
                annotation,
                dataSource.data
              )

              if (!validConfig) {
                return
              }

              setAnnotationAndConfiguration(
                validConfig,
                buttonController,
                spanConfig,
                annotationData,
                annotation
              )

              if (loadedAnnotation) {
                originalData.annotation = loadedAnnotation
                remoteResource.annotationUrl = loadedAnnotation
              }

              originalData.configuration = dataSource
              remoteResource.configurationUrl = dataSource
            }
          )

        const iconEventMap = new IconEventMap(
          commander,
          presenter,
          persistenceInterface,
          buttonController,
          annotationData
        )

        // add control bar
        const controlBarHTMLElement = new ControlBar(
          eventEmitter,
          buttonController,
          iconEventMap
        ).el
        editorHTMLElement.insertBefore(
          controlBarHTMLElement,
          editorHTMLElement.childNodes[0]
        )
        annotationData.controlBarHeight =
          controlBarHTMLElement.getBoundingClientRect().height

        initAnnotation(
          spanConfig,
          annotationData,
          remoteResource,
          buttonController,
          originalData,
          params.get('annotation'),
          params.get('config')
        )

        // add context menu
        const contextMenu = new ContextMenu(
          editorHTMLElement,
          buttonController,
          iconEventMap
        )
        editorHTMLElement.appendChild(contextMenu.el)

        editorHTMLElement.addEventListener('keyup', (event) => {
          contextMenu.hide()

          if (presenter.isActive) {
            new KeyEventMap(commander, presenter, persistenceInterface).handle(
              event
            )
          }
        })

        forwardMethods(this, () => presenter, [
          'copyEntitiesToSystemClipboard',
          'cutEntitiesToSystemClipboard',
          'pasteEntitiesFromSystemClipboard',
          'active',
          'deactive',
          'applyTextSelection'
        ])

        this._contextMenu = contextMenu
      }

      showContextMenu(contextmenuEvent) {
        this._contextMenu.show(contextmenuEvent)
      }
      hideContextMenu() {
        this._contextMenu.hide()
      }
    }

    // EXTERNAL MODULE: ./node_modules/events/events.js
    var events = __webpack_require__(7187) // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/getSource.js
    /* harmony default export */ function getSource(element) {
      // 'source' prefer to 'target'
      return element.getAttribute('source') || element.getAttribute('target')
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/getSaveToUrl.js

    /* harmony default export */ function getSaveToUrl(element) {
      // 'save_to'
      const value = element.getAttribute('save_to')

      if (value) {
        return decodeURIComponent(value)
      }

      return ''
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/getUrl.js

    /* harmony default export */ function getUrl(source) {
      if (source) {
        return decodeURIComponent(source)
      }

      return ''
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/getAnnotation.js

    /* harmony default export */ function getAnnotation(element, source) {
      const annotation = new Map()

      // Read Html text and clear it.
      // Use textContent instead of innerText,
      // to read consecutive whitespace in inline annotations without collapsing.
      const inlineAnnotation = element.textContent
      element.innerHTML = ''
      if (inlineAnnotation) {
        annotation.set('inlineAnnotation', inlineAnnotation)
      }

      // Read url.
      const url = getUrl(source)
      if (url) {
        annotation.set('url', url)
      }

      // Read save_to
      const saveTo = getSaveToUrl(element)
      if (saveTo) {
        annotation.set('save_to', getSaveToUrl(element))
      }

      return annotation
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/decodeUrl.js

    /* harmony default export */ function decodeUrl(params, name) {
      if (params.has(name)) {
        params.set(name, decodeURIComponent(params.get(name)))
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/getAttribute.js

    /* harmony default export */ function getAttribute(params, element, name) {
      if (element.getAttribute(name)) {
        params.set(name, element.getAttribute(name))
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/getConfigLockFromURL/getQueryParams.js

    /* harmony default export */ function getQueryParams(url) {
      const queryParamMap = new Map()
      const queryStr = url.split('?')[1]

      if (queryStr) {
        const parameters = queryStr.split('&')

        for (let i = 0; i < parameters.length; i++) {
          const element = parameters[i].split('=')
          const paramName = decodeURIComponent(element[0])
          const paramValue = decodeURIComponent(element[1])
          queryParamMap.set(paramName, decodeURIComponent(paramValue))
        }
      }

      return queryParamMap
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/getConfigLockFromURL/index.js

    /* harmony default export */ function getConfigLockFromURL(url) {
      if (url) {
        const queryParamMap = getQueryParams(url)

        if (queryParamMap.has('config_lock')) {
          return queryParamMap.get('config_lock')
        }
      }
      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/extractParamsFromHTMLElement/index.js

    /* harmony default export */ function extractParamsFromHTMLElement(
      element
    ) {
      const params = new Map()

      getAttribute(params, element, 'mode')
      if (element.getAttribute('control')) {
        const controlParam = element.getAttribute('control')
        if (controlParam === 'visible') {
          element.classList.add('textae-editor--control-visible')
        }
        if (
          controlParam === 'hidden' ||
          (params.get('mode') === 'view' && controlParam !== 'visible')
        ) {
          element.classList.add('textae-editor--control-hidden')
        }
      }

      getAttribute(params, element, 'status_bar')
      getAttribute(params, element, 'config')
      getAttribute(params, element, 'autocompletion_ws')

      // Decode URI encode
      decodeUrl(params, 'config')
      decodeUrl(params, 'autocompletion_ws')

      params.set('source', getSource(element))

      // Over write editor-div's config lock state by url's.
      // Url's default is 'unlock', so its default is also 'unlock'.
      const configLockFromAttr = element.getAttribute('config_lock')
      const configLockFromURL = getConfigLockFromURL(params.get('source'))
      if (configLockFromURL || configLockFromAttr) {
        params.set('config_lock', configLockFromURL || configLockFromAttr)
      }

      // Set annotation parameters.
      params.set('annotation', getAnnotation(element, params.get('source')))

      return params
    } // CONCATENATED MODULE: ./src/lib/Editor/EditorCSSClass.js

    class EditorCSSClass {
      constructor(editorHTMLElement) {
        this._editorHTMLElement = editorHTMLElement
      }
      startWait() {
        this._editorHTMLElement.classList.add('textae-editor--wait')
      }
      endWait() {
        this._editorHTMLElement.classList.remove('textae-editor--wait')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/observeElement.js

    /* harmony default export */ function observeElement(element) {
      // Prevent a selection text with shift keies.
      element.addEventListener('mousedown', (e) => {
        if (e.shiftKey) {
          e.preventDefault()
        }
      })

      // Prevent a selection of an entity by the double-click.
      delegate_default()(
        element,
        '.textae-editor__signboard',
        'mousedown',
        (e) => e.preventDefault()
      )
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/boundaryCrossingSpansTemplate.js

    /* harmony default export */ function boundaryCrossingSpansTemplate(
      boundaryCrossingSpans
    ) {
      return boundaryCrossingSpans.length
        ? `
      <table>
        <caption>Denotations or Blocks or Typesettings with boundary-cross.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="sourceProperty">source property</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>style/obj</th>
          </tr>
        </thead>
        <tbody>
          ${boundaryCrossingSpans
            .map(
              ({ id, sourceProperty, span, style, obj }) => `
          <tr>
            <td>${id || ''}</td>
            <td>${sourceProperty}</td>
            <td class="alert">${span.begin}</td>
            <td class="alert">${span.end}</td>
            <td>${style || obj}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/duplicatedAttributesTemplate.js

    /* harmony default export */ function duplicatedAttributesTemplate(
      duplicatedAttributes
    ) {
      return duplicatedAttributes.length
        ? `
      <table>
        <caption>Duplicated attributes.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="referencedItem">subj</th>
            <th>pred</th>
            <th class="referencedItem">obj</th>
          </tr>
        </thead>
        <tbody>
          ${duplicatedAttributes
            .map(
              ({ id, subj, pred, obj }) => `
          <tr>
            <td>${id || ''}</td>
            <td class="alert">${subj}</td>
            <td>${pred}</td>
            <td class="alert">${obj}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/duplicatedIDsTemplate.js

    /* harmony default export */ function duplicatedIDsTemplate(duplicatedIDs) {
      return duplicatedIDs.length
        ? `
      <table>
        <caption>Duplicated IDs in Denotations and Blocks.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="sourceProperty">source property</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>obj</th>
          </tr>
        </thead>
        <tbody>
          ${duplicatedIDs
            .map(
              ({ id, sourceProperty, span, obj }) => `
          <tr>
            <td>${id || ''}</td>
            <td>${sourceProperty}</td>
            <td class="alert">${span.begin}</td>
            <td class="alert">${span.end}</td>
            <td>${obj}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/dupulicateRangeBlocksTemplate.js

    /* harmony default export */ function dupulicateRangeBlocksTemplate(
      duplicatedRangeBlocks
    ) {
      return duplicatedRangeBlocks.length
        ? `
      <table>
        <caption>Duplicated range blocks.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>obj</th>
          </tr>
        </thead>
        <tbody>
          ${duplicatedRangeBlocks
            .map(
              ({ id, span, obj }) => `
          <tr>
            <td>${id || ''}</td>
            <td class="alert">${span.begin}</td>
            <td class="alert">${span.end}</td>
            <td>${obj}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/outOfTextBlocksTemplate.js

    /* harmony default export */ function outOfTextBlocksTemplate(
      outOfTextBlocks
    ) {
      return outOfTextBlocks.length
        ? `
      <table>
        <caption>Out of text blokcs.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>obj</th>
          </tr>
        </thead>
        <tbody>
          ${outOfTextBlocks
            .map(
              ({ id, span, obj }) => `
          <tr>
            <td>${id || ''}</td>
            <td class="alert">${span.begin}</td>
            <td class="alert">${span.end}</td>
            <td>${obj}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/outOfTextDenotationsTemplate.js

    /* harmony default export */ function outOfTextDenotationsTemplate(
      outOfTextDenotations
    ) {
      return outOfTextDenotations.length
        ? `
        <table>
          <caption>Out of text denotations.</caption>
          <thead>
            <tr>
              <th class="id">id</th>
              <th class="range">begin</th>
              <th class="range">end</th>
              <th>obj</th>
            </tr>
          </thead>
          <tbody>
            ${outOfTextDenotations
              .map(
                ({ id, span, obj }) => `
            <tr>
              <td>${id || ''}</td>
              <td class="alert">${span.begin}</td>
              <td class="alert">${span.end}</td>
              <td>${obj}</td>
            </tr>
            `
              )
              .join('\n')}
          </tbody>
        </table>`
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/outOfTextTypesettingsTemplate.js

    /* harmony default export */ function outOfTextTypesettingsTemplate(
      outOfTextTypesettings
    ) {
      return outOfTextTypesettings.length
        ? `
      <table>
        <caption>Out of text typesettings.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>style</th>
          </tr>
        </thead>
        <tbody>
          ${outOfTextTypesettings
            .map(
              ({ id, span, style }) => `
          <tr>
            <td>${id || ''}</td>
            <td class="alert">${span.begin}</td>
            <td class="alert">${span.end}</td>
            <td>${style}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/referencedEntitiesDoNotExistTemplate.js

    /* harmony default export */ function referencedEntitiesDoNotExistTemplate(
      referencedEntitiesDoNotExist
    ) {
      return referencedEntitiesDoNotExist.length
        ? `
      <table>
        <caption>Referenced entities do not exist.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="sourceProperty">source property</th>
            <th class="referencedItem">subj</th>
            <th>pred</th>
            <th class="referencedItem">obj</th>
          </tr>
        </thead>
        <tbody>
          ${referencedEntitiesDoNotExist
            .map(
              ({
                id,
                sourceProperty,
                alertSubj,
                subj,
                pred,
                alertObj,
                obj
              }) => `
          <tr>
            <td>${id || ''}</td>
            <td>${sourceProperty}</td>
            <td${alertSubj ? ' class="alert"' : ''}>${subj}</td>
            <td>${pred}</td>
            <td${alertObj ? ' class="alert"' : ''}>${obj}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/wrongRangeBlocksTemplate.js

    /* harmony default export */ function wrongRangeBlocksTemplate(
      wrongRangeBlocks
    ) {
      return wrongRangeBlocks.length
        ? `
        <table>
          <caption>Wrong range blocks.</caption>
          <thead>
            <tr>
              <th class="id">id</th>
              <th class="range">begin</th>
              <th class="range">end</th>
              <th>obj</th>
            </tr>
          </thead>
          <tbody>
            ${wrongRangeBlocks
              .map(
                ({ id, span, obj }) => `
            <tr>
              <td>${id || ''}</td>
              <td class="alert">${span.begin}</td>
              <td class="alert">${span.end}</td>
              <td>${obj}</td>
            </tr>
            `
              )
              .join('\n')}
          </tbody>
        </table>
  `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/wrongRangeDenotationsTemplate.js

    /* harmony default export */ function wrongRangeDenotationsTemplate(
      wrongRangeDenotations
    ) {
      return wrongRangeDenotations.length
        ? `
        <table>
          <caption>Wrong range denotations.</caption>
          <thead>
            <tr>
              <th class="id">id</th>
              <th class="range">begin</th>
              <th class="range">end</th>
              <th>obj</th>
            </tr>
          </thead>
          <tbody>
            ${wrongRangeDenotations
              .map(
                ({ id, span, obj }) => `
            <tr>
              <td>${id || ''}</td>
              <td class="alert">${span.begin}</td>
              <td class="alert">${span.end}</td>
              <td>${obj}</td>
            </tr>
          `
              )
              .join('\n')}
          </tbody>
        </table>`
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/wrongRangeTypesettingsTemplate.js

    /* harmony default export */ function wrongRangeTypesettingsTemplate(
      wrongRangeTypesettings
    ) {
      return wrongRangeTypesettings.length
        ? `
      <table>
        <caption>Wrong range typesettings.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>style</th>
          </tr>
        </thead>
        <tbody>
          ${wrongRangeTypesettings
            .map(
              ({ id, span, style }) => `
          <tr>
            <td>${id || ''}</td>
            <td class="alert">${span.begin}</td>
            <td class="alert">${span.end}</td>
            <td>${style}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/index.js

    class ValidationDialog extends Dialog {
      constructor(rejects) {
        const contentHtml = rejects
          .map(
            (
              {
                name,
                wrongRangeDenotations,
                outOfTextDenotations,
                wrongRangeBlocks,
                outOfTextBlocks,
                duplicatedRangeBlocks,
                wrongRangeTypesettings,
                outOfTextTypesettings,
                duplicatedIDs,
                boundaryCrossingSpans,
                referencedEntitiesDoNotExist,
                duplicatedAttributes
              },
              index
            ) => {
              return `
    ${
      index === 1
        ? `
      <div class="textae-editor__valiondate-dialog__content">
        <h1>Track annatations will be merged to the root anntations.</h1>
      </div>`
        : ''
    }
    <div class="textae-editor__valiondate-dialog__content">
      <h2>${name}</h2>
      ${wrongRangeDenotationsTemplate(wrongRangeDenotations)}
      ${outOfTextDenotationsTemplate(outOfTextDenotations)}
      ${wrongRangeBlocksTemplate(wrongRangeBlocks)}
      ${outOfTextBlocksTemplate(outOfTextBlocks)}
      ${dupulicateRangeBlocksTemplate(duplicatedRangeBlocks)}
      ${wrongRangeTypesettingsTemplate(wrongRangeTypesettings)}
      ${outOfTextTypesettingsTemplate(outOfTextTypesettings)}
      ${duplicatedIDsTemplate(duplicatedIDs)}
      ${boundaryCrossingSpansTemplate(boundaryCrossingSpans)}
      ${referencedEntitiesDoNotExistTemplate(referencedEntitiesDoNotExist)}
      ${duplicatedAttributesTemplate(duplicatedAttributes)}
    </div>
    `
            }
          )
          .join('\n')

        super('The following erroneous annotations ignored', contentHtml, {
          maxWidth: 900
        })
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/observeEventEmitter.js

    /* harmony default export */ function observeEventEmitter(eventEmitter) {
      eventEmitter
        .on(
          'textae-event.resource.annotation.format.error',
          ({ displayName }) =>
            alertify_default().error(
              `${displayName} is not a annotation file or its format is invalid.`
            )
        )
        .on(
          'textae-event.resource.configuration.format.error',
          ({ displayName }) =>
            alertify_default().error(
              `${displayName} is not a configuration file or its format is invalid.!`
            )
        )
        .on('textae-event.annotation-data.all.change', (_, __, rejects) => {
          if (rejects.some((r) => r.hasError)) {
            new ValidationDialog(rejects).open()
          }
        })
        .on(
          'textae-event.annotation-data.events-observer.change',
          (hasChange) => {
            // change leaveMessage show
            // Reloading when trying to scroll further when you are at the top on an Android device.
            // Show a confirmation dialog to prevent this.
            window.onbeforeunload = isAndroid() || hasChange ? () => true : null
          }
        )

      // Bind clipBoard events.
      eventEmitter.on('textae-event.clip-board.change', (added, removed) => {
        for (const entity of added) {
          entity.startCut()
        }

        for (const entity of removed) {
          entity.cancelCut()
        }
      })

      // Bind commander events.
      // When you have an entity with multiple attributes whose pred is the same,
      // if you redraw the HTML element of the entity every time you update the attributes,
      // you need to consider the mixed state of the attributes after the update and before the update.
      // Redraw all the Entities that were affected at the end of the command.
      eventEmitter.on(
        'textae-event.commander.attributes.change',
        (attributes) => {
          for (const subjectModel of attributes.reduce(
            (prev, curr) => prev.add(curr.subjectModel),
            new Set()
          )) {
            subjectModel.updateElement()
          }
        }
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/editorCSSClassObserve.js

    /* harmony default export */ function editorCSSClassObserve(
      eventEmitter,
      editorCSSClass
    ) {
      eventEmitter
        .on('textae-event.resource.startLoad', () => editorCSSClass.startWait())
        .on('textae-event.resource.endLoad', () => editorCSSClass.endWait())
        .on('textae-event.resource.startSave', () => editorCSSClass.startWait())
        .on('textae-event.resource.endSave', () => editorCSSClass.endWait())
    } // CONCATENATED MODULE: ./src/lib/Editor/index.js

    // model manages data objects.

    class Editor {
      constructor(
        element,
        editorID,
        startJQueryUIDialogWait,
        endJQueryUIDialogWait
      ) {
        // Add tabIndex to listen to keyboard events.
        element.tabIndex = -1

        if (isAndroid()) {
          element.classList.add('textae-editor--android')
        }

        observeElement(element)

        // Set the eventEmitter to communicate with the tool and a control.
        const eventEmitter = new events.EventEmitter()
        observeEventEmitter(eventEmitter)

        const editorCSSClass = new EditorCSSClass(element)
        editorCSSClassObserve(eventEmitter, editorCSSClass)

        const params = extractParamsFromHTMLElement(element)
        const annotationData = new AnnotationData(
          editorID,
          element,
          eventEmitter,
          editorCSSClass,
          startJQueryUIDialogWait,
          endJQueryUIDialogWait
        )
        if (params.has('config_lock') && params.get('config_lock') === 'true') {
          annotationData.typeDefinition.lockEdit()
        } else {
          annotationData.typeDefinition.unlockEdit()
        }

        const api = new API(
          element,
          editorID,
          eventEmitter,
          annotationData,
          params
        )

        forwardMethods(this, () => api, [
          'copyEntitiesToSystemClipboard',
          'cutEntitiesToSystemClipboard',
          'pasteEntitiesFromSystemClipboard',
          'active',
          'deactive',
          'applyTextSelection',
          'showContextMenu',
          'hideContextMenu'
        ])
        forwardMethods(this, () => annotationData, [
          'drawGridsInSight',
          'relayout'
        ])

        this._annotationData = annotationData
      }

      updateDenotationEntitiesWidth() {
        for (const span of this._annotationData.span.allDenotationSpans) {
          span.updateDenotationEntitiesWidth()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/textae.js

    const tool = new Tool()

    /* harmony default export */ function textae() {
      // Set position of toast messages.
      alertify_default().set('notifier', 'position', 'top-right')

      for (const element of document.querySelectorAll('.textae-editor')) {
        // Create an editor
        const editor = new Editor(
          element,
          tool.nextID,
          () => {
            // jQuery Ui dialogs are not in the editor.
            for (const dialog of document.querySelectorAll('.ui-dialog')) {
              dialog.classList.add('textae-editor--wait')
            }
            for (const dialog of document.querySelectorAll(
              '.ui-widget-overlay'
            )) {
              dialog.classList.add('textae-editor--wait')
            }
          },
          () => {
            for (const dialog of document.querySelectorAll('.ui-dialog')) {
              dialog.classList.remove('textae-editor--wait')
            }
            for (const dialog of document.querySelectorAll(
              '.ui-widget-overlay'
            )) {
              dialog.classList.remove('textae-editor--wait')
            }
          }
        )
        // Register an editor
        tool.registerEditor(element, editor)
      }
    } // CONCATENATED MODULE: ./src/index.js

    document.addEventListener('DOMContentLoaded', textae)
  })()

  /******/
})()
