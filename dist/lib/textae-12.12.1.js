/******/ ;(() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ 6870: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.formatNames = exports.fastFormats = exports.fullFormats = void 0
      function fmtDef(validate, compare) {
        return { validate, compare }
      }
      exports.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(time, compareTime),
        'date-time': fmtDef(date_time, compareDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration:
          /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri,
        'uri-reference':
          /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        'uri-template':
          /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email:
          /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname:
          /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        'json-pointer': /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        'json-pointer-uri-fragment':
          /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        'relative-json-pointer':
          /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: 'number', validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: 'number', validate: validateInt64 },
        // C-type float
        float: { type: 'number', validate: validateNumber },
        // C-type double
        double: { type: 'number', validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      }
      exports.fastFormats = {
        ...exports.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(
          /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
          compareTime
        ),
        'date-time': fmtDef(
          /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
          compareDateTime
        ),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        'uri-reference':
          /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email:
          /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      }
      exports.formatNames = Object.keys(exports.fullFormats)
      function isLeapYear(year) {
        // https://tools.ietf.org/html/rfc3339#appendix-C
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)
      }
      const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/
      const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      function date(str) {
        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
        const matches = DATE.exec(str)
        if (!matches) return false
        const year = +matches[1]
        const month = +matches[2]
        const day = +matches[3]
        return (
          month >= 1 &&
          month <= 12 &&
          day >= 1 &&
          day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])
        )
      }
      function compareDate(d1, d2) {
        if (!(d1 && d2)) return undefined
        if (d1 > d2) return 1
        if (d1 < d2) return -1
        return 0
      }
      const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i
      function time(str, withTimeZone) {
        const matches = TIME.exec(str)
        if (!matches) return false
        const hour = +matches[1]
        const minute = +matches[2]
        const second = +matches[3]
        const timeZone = matches[5]
        return (
          ((hour <= 23 && minute <= 59 && second <= 59) ||
            (hour === 23 && minute === 59 && second === 60)) &&
          (!withTimeZone || timeZone !== '')
        )
      }
      function compareTime(t1, t2) {
        if (!(t1 && t2)) return undefined
        const a1 = TIME.exec(t1)
        const a2 = TIME.exec(t2)
        if (!(a1 && a2)) return undefined
        t1 = a1[1] + a1[2] + a1[3] + (a1[4] || '')
        t2 = a2[1] + a2[2] + a2[3] + (a2[4] || '')
        if (t1 > t2) return 1
        if (t1 < t2) return -1
        return 0
      }
      const DATE_TIME_SEPARATOR = /t|\s/i
      function date_time(str) {
        // http://tools.ietf.org/html/rfc3339#section-5.6
        const dateTime = str.split(DATE_TIME_SEPARATOR)
        return (
          dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true)
        )
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2)) return undefined
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR)
        const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR)
        const res = compareDate(d1, d2)
        if (res === undefined) return undefined
        return res || compareTime(t1, t2)
      }
      const NOT_URI_FRAGMENT = /\/|:/
      const URI =
        /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i
      function uri(str) {
        // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
        return NOT_URI_FRAGMENT.test(str) && URI.test(str)
      }
      const BYTE =
        /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm
      function byte(str) {
        BYTE.lastIndex = 0
        return BYTE.test(str)
      }
      const MIN_INT32 = -(2 ** 31)
      const MAX_INT32 = 2 ** 31 - 1
      function validateInt32(value) {
        return (
          Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32
        )
      }
      function validateInt64(value) {
        // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
        return Number.isInteger(value)
      }
      function validateNumber() {
        return true
      }
      const Z_ANCHOR = /[^\\]\\Z/
      function regex(str) {
        if (Z_ANCHOR.test(str)) return false
        try {
          new RegExp(str)
          return true
        } catch (e) {
          return false
        }
      }
      //# sourceMappingURL=formats.js.map

      /***/
    },

    /***/ 5477: /***/ (module, exports, __webpack_require__) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const formats_1 = __webpack_require__(6870)
      const limit_1 = __webpack_require__(7963)
      const codegen_1 = __webpack_require__(3487)
      const fullName = new codegen_1.Name('fullFormats')
      const fastName = new codegen_1.Name('fastFormats')
      const formatsPlugin = (ajv, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats(ajv, opts, formats_1.fullFormats, fullName)
          return ajv
        }
        const [formats, exportName] =
          opts.mode === 'fast'
            ? [formats_1.fastFormats, fastName]
            : [formats_1.fullFormats, fullName]
        const list = opts.formats || formats_1.formatNames
        addFormats(ajv, list, formats, exportName)
        if (opts.keywords) limit_1.default(ajv)
        return ajv
      }
      formatsPlugin.get = (name, mode = 'full') => {
        const formats =
          mode === 'fast' ? formats_1.fastFormats : formats_1.fullFormats
        const f = formats[name]
        if (!f) throw new Error(`Unknown format "${name}"`)
        return f
      }
      function addFormats(ajv, list, fs, exportName) {
        var _a
        var _b
        ;(_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0
          ? _a
          : (_b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`)
        for (const f of list) ajv.addFormat(f, fs[f])
      }
      module.exports = exports = formatsPlugin
      Object.defineProperty(exports, '__esModule', { value: true })
      exports['default'] = formatsPlugin
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 7963: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.formatLimitDefinition = void 0
      const ajv_1 = __webpack_require__(1581)
      const codegen_1 = __webpack_require__(3487)
      const ops = codegen_1.operators
      const KWDs = {
        formatMaximum: { okStr: '<=', ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: '>=', ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: '<', ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: '>', ok: ops.GT, fail: ops.LTE }
      }
      const error = {
        message: ({ keyword, schemaCode }) =>
          codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) =>
          codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      }
      exports.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: 'string',
        schemaType: 'string',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword, it } = cxt
          const { opts, self } = it
          if (!opts.validateFormats) return
          const fCxt = new ajv_1.KeywordCxt(
            it,
            self.RULES.all.format.definition,
            'format'
          )
          if (fCxt.$data) validate$DataFormat()
          else validateFormat()
          function validate$DataFormat() {
            const fmts = gen.scopeValue('formats', {
              ref: self.formats,
              code: opts.code.formats
            })
            const fmt = gen.const(
              'fmt',
              codegen_1._`${fmts}[${fCxt.schemaCode}]`
            )
            cxt.fail$data(
              codegen_1.or(
                codegen_1._`typeof ${fmt} != "object"`,
                codegen_1._`${fmt} instanceof RegExp`,
                codegen_1._`typeof ${fmt}.compare != "function"`,
                compareCode(fmt)
              )
            )
          }
          function validateFormat() {
            const format = fCxt.schema
            const fmtDef = self.formats[format]
            if (!fmtDef || fmtDef === true) return
            if (
              typeof fmtDef != 'object' ||
              fmtDef instanceof RegExp ||
              typeof fmtDef.compare != 'function'
            ) {
              throw new Error(
                `"${keyword}": format "${format}" does not define "compare" function`
              )
            }
            const fmt = gen.scopeValue('formats', {
              key: format,
              ref: fmtDef,
              code: opts.code.formats
                ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(
                    format
                  )}`
                : undefined
            })
            cxt.fail$data(compareCode(fmt))
          }
          function compareCode(fmt) {
            return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`
          }
        },
        dependencies: ['format']
      }
      const formatLimitPlugin = (ajv) => {
        ajv.addKeyword(exports.formatLimitDefinition)
        return ajv
      }
      exports['default'] = formatLimitPlugin
      //# sourceMappingURL=limit.js.map

      /***/
    },

    /***/ 1581: /***/ (module, exports, __webpack_require__) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.MissingRefError =
        exports.ValidationError =
        exports.CodeGen =
        exports.Name =
        exports.nil =
        exports.stringify =
        exports.str =
        exports._ =
        exports.KeywordCxt =
          void 0
      const core_1 = __webpack_require__(7159)
      const draft7_1 = __webpack_require__(3924)
      const discriminator_1 = __webpack_require__(1240)
      const draft7MetaSchema = __webpack_require__(98)
      const META_SUPPORT_DATA = ['/properties']
      const META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema'
      class Ajv extends core_1.default {
        _addVocabularies() {
          super._addVocabularies()
          draft7_1.default.forEach((v) => this.addVocabulary(v))
          if (this.opts.discriminator) this.addKeyword(discriminator_1.default)
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema()
          if (!this.opts.meta) return
          const metaSchema = this.opts.$data
            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
            : draft7MetaSchema
          this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)
          this.refs['http://json-schema.org/schema'] = META_SCHEMA_ID
        }
        defaultMeta() {
          return (this.opts.defaultMeta =
            super.defaultMeta() ||
            (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))
        }
      }
      module.exports = exports = Ajv
      Object.defineProperty(exports, '__esModule', { value: true })
      exports['default'] = Ajv
      var validate_1 = __webpack_require__(4815)
      Object.defineProperty(exports, 'KeywordCxt', {
        enumerable: true,
        get: function () {
          return validate_1.KeywordCxt
        }
      })
      var codegen_1 = __webpack_require__(3487)
      Object.defineProperty(exports, '_', {
        enumerable: true,
        get: function () {
          return codegen_1._
        }
      })
      Object.defineProperty(exports, 'str', {
        enumerable: true,
        get: function () {
          return codegen_1.str
        }
      })
      Object.defineProperty(exports, 'stringify', {
        enumerable: true,
        get: function () {
          return codegen_1.stringify
        }
      })
      Object.defineProperty(exports, 'nil', {
        enumerable: true,
        get: function () {
          return codegen_1.nil
        }
      })
      Object.defineProperty(exports, 'Name', {
        enumerable: true,
        get: function () {
          return codegen_1.Name
        }
      })
      Object.defineProperty(exports, 'CodeGen', {
        enumerable: true,
        get: function () {
          return codegen_1.CodeGen
        }
      })
      var validation_error_1 = __webpack_require__(7426)
      Object.defineProperty(exports, 'ValidationError', {
        enumerable: true,
        get: function () {
          return validation_error_1.default
        }
      })
      var ref_error_1 = __webpack_require__(6646)
      Object.defineProperty(exports, 'MissingRefError', {
        enumerable: true,
        get: function () {
          return ref_error_1.default
        }
      })
      //# sourceMappingURL=ajv.js.map

      /***/
    },

    /***/ 7023: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.regexpCode =
        exports.getEsmExportName =
        exports.getProperty =
        exports.safeStringify =
        exports.stringify =
        exports.strConcat =
        exports.addCodeArg =
        exports.str =
        exports._ =
        exports.nil =
        exports._Code =
        exports.Name =
        exports.IDENTIFIER =
        exports._CodeOrName =
          void 0
      class _CodeOrName {}
      exports._CodeOrName = _CodeOrName
      exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i
      class Name extends _CodeOrName {
        constructor(s) {
          super()
          if (!exports.IDENTIFIER.test(s))
            throw new Error('CodeGen: name must be a valid identifier')
          this.str = s
        }
        toString() {
          return this.str
        }
        emptyStr() {
          return false
        }
        get names() {
          return { [this.str]: 1 }
        }
      }
      exports.Name = Name
      class _Code extends _CodeOrName {
        constructor(code) {
          super()
          this._items = typeof code === 'string' ? [code] : code
        }
        toString() {
          return this.str
        }
        emptyStr() {
          if (this._items.length > 1) return false
          const item = this._items[0]
          return item === '' || item === '""'
        }
        get str() {
          var _a
          return (_a = this._str) !== null && _a !== void 0
            ? _a
            : (this._str = this._items.reduce((s, c) => `${s}${c}`, ''))
        }
        get names() {
          var _a
          return (_a = this._names) !== null && _a !== void 0
            ? _a
            : (this._names = this._items.reduce((names, c) => {
                if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1
                return names
              }, {}))
        }
      }
      exports._Code = _Code
      exports.nil = new _Code('')
      function _(strs, ...args) {
        const code = [strs[0]]
        let i = 0
        while (i < args.length) {
          addCodeArg(code, args[i])
          code.push(strs[++i])
        }
        return new _Code(code)
      }
      exports._ = _
      const plus = new _Code('+')
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])]
        let i = 0
        while (i < args.length) {
          expr.push(plus)
          addCodeArg(expr, args[i])
          expr.push(plus, safeStringify(strs[++i]))
        }
        optimize(expr)
        return new _Code(expr)
      }
      exports.str = str
      function addCodeArg(code, arg) {
        if (arg instanceof _Code) code.push(...arg._items)
        else if (arg instanceof Name) code.push(arg)
        else code.push(interpolate(arg))
      }
      exports.addCodeArg = addCodeArg
      function optimize(expr) {
        let i = 1
        while (i < expr.length - 1) {
          if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1])
            if (res !== undefined) {
              expr.splice(i - 1, 3, res)
              continue
            }
            expr[i++] = '+'
          }
          i++
        }
      }
      function mergeExprItems(a, b) {
        if (b === '""') return a
        if (a === '""') return b
        if (typeof a == 'string') {
          if (b instanceof Name || a[a.length - 1] !== '"') return
          if (typeof b != 'string') return `${a.slice(0, -1)}${b}"`
          if (b[0] === '"') return a.slice(0, -1) + b.slice(1)
          return
        }
        if (typeof b == 'string' && b[0] === '"' && !(a instanceof Name))
          return `"${a}${b.slice(1)}`
        return
      }
      function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`
      }
      exports.strConcat = strConcat
      // TODO do not allow arrays here
      function interpolate(x) {
        return typeof x == 'number' || typeof x == 'boolean' || x === null
          ? x
          : safeStringify(Array.isArray(x) ? x.join(',') : x)
      }
      function stringify(x) {
        return new _Code(safeStringify(x))
      }
      exports.stringify = stringify
      function safeStringify(x) {
        return JSON.stringify(x)
          .replace(/\u2028/g, '\\u2028')
          .replace(/\u2029/g, '\\u2029')
      }
      exports.safeStringify = safeStringify
      function getProperty(key) {
        return typeof key == 'string' && exports.IDENTIFIER.test(key)
          ? new _Code(`.${key}`)
          : _`[${key}]`
      }
      exports.getProperty = getProperty
      //Does best effort to format the name properly
      function getEsmExportName(key) {
        if (typeof key == 'string' && exports.IDENTIFIER.test(key)) {
          return new _Code(`${key}`)
        }
        throw new Error(
          `CodeGen: invalid export name: ${key}, use explicit $id name mapping`
        )
      }
      exports.getEsmExportName = getEsmExportName
      function regexpCode(rx) {
        return new _Code(rx.toString())
      }
      exports.regexpCode = regexpCode
      //# sourceMappingURL=code.js.map

      /***/
    },

    /***/ 3487: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.or =
        exports.and =
        exports.not =
        exports.CodeGen =
        exports.operators =
        exports.varKinds =
        exports.ValueScopeName =
        exports.ValueScope =
        exports.Scope =
        exports.Name =
        exports.regexpCode =
        exports.stringify =
        exports.getProperty =
        exports.nil =
        exports.strConcat =
        exports.str =
        exports._ =
          void 0
      const code_1 = __webpack_require__(7023)
      const scope_1 = __webpack_require__(8490)
      var code_2 = __webpack_require__(7023)
      Object.defineProperty(exports, '_', {
        enumerable: true,
        get: function () {
          return code_2._
        }
      })
      Object.defineProperty(exports, 'str', {
        enumerable: true,
        get: function () {
          return code_2.str
        }
      })
      Object.defineProperty(exports, 'strConcat', {
        enumerable: true,
        get: function () {
          return code_2.strConcat
        }
      })
      Object.defineProperty(exports, 'nil', {
        enumerable: true,
        get: function () {
          return code_2.nil
        }
      })
      Object.defineProperty(exports, 'getProperty', {
        enumerable: true,
        get: function () {
          return code_2.getProperty
        }
      })
      Object.defineProperty(exports, 'stringify', {
        enumerable: true,
        get: function () {
          return code_2.stringify
        }
      })
      Object.defineProperty(exports, 'regexpCode', {
        enumerable: true,
        get: function () {
          return code_2.regexpCode
        }
      })
      Object.defineProperty(exports, 'Name', {
        enumerable: true,
        get: function () {
          return code_2.Name
        }
      })
      var scope_2 = __webpack_require__(8490)
      Object.defineProperty(exports, 'Scope', {
        enumerable: true,
        get: function () {
          return scope_2.Scope
        }
      })
      Object.defineProperty(exports, 'ValueScope', {
        enumerable: true,
        get: function () {
          return scope_2.ValueScope
        }
      })
      Object.defineProperty(exports, 'ValueScopeName', {
        enumerable: true,
        get: function () {
          return scope_2.ValueScopeName
        }
      })
      Object.defineProperty(exports, 'varKinds', {
        enumerable: true,
        get: function () {
          return scope_2.varKinds
        }
      })
      exports.operators = {
        GT: new code_1._Code('>'),
        GTE: new code_1._Code('>='),
        LT: new code_1._Code('<'),
        LTE: new code_1._Code('<='),
        EQ: new code_1._Code('==='),
        NEQ: new code_1._Code('!=='),
        NOT: new code_1._Code('!'),
        OR: new code_1._Code('||'),
        AND: new code_1._Code('&&'),
        ADD: new code_1._Code('+')
      }
      class Node {
        optimizeNodes() {
          return this
        }
        optimizeNames(_names, _constants) {
          return this
        }
      }
      class Def extends Node {
        constructor(varKind, name, rhs) {
          super()
          this.varKind = varKind
          this.name = name
          this.rhs = rhs
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind
          const rhs = this.rhs === undefined ? '' : ` = ${this.rhs}`
          return `${varKind} ${this.name}${rhs};` + _n
        }
        optimizeNames(names, constants) {
          if (!names[this.name.str]) return
          if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)
          return this
        }
        get names() {
          return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {}
        }
      }
      class Assign extends Node {
        constructor(lhs, rhs, sideEffects) {
          super()
          this.lhs = lhs
          this.rhs = rhs
          this.sideEffects = sideEffects
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n
        }
        optimizeNames(names, constants) {
          if (
            this.lhs instanceof code_1.Name &&
            !names[this.lhs.str] &&
            !this.sideEffects
          )
            return
          this.rhs = optimizeExpr(this.rhs, names, constants)
          return this
        }
        get names() {
          const names =
            this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names }
          return addExprNames(names, this.rhs)
        }
      }
      class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects)
          this.op = op
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n
        }
      }
      class Label extends Node {
        constructor(label) {
          super()
          this.label = label
          this.names = {}
        }
        render({ _n }) {
          return `${this.label}:` + _n
        }
      }
      class Break extends Node {
        constructor(label) {
          super()
          this.label = label
          this.names = {}
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : ''
          return `break${label};` + _n
        }
      }
      class Throw extends Node {
        constructor(error) {
          super()
          this.error = error
        }
        render({ _n }) {
          return `throw ${this.error};` + _n
        }
        get names() {
          return this.error.names
        }
      }
      class AnyCode extends Node {
        constructor(code) {
          super()
          this.code = code
        }
        render({ _n }) {
          return `${this.code};` + _n
        }
        optimizeNodes() {
          return `${this.code}` ? this : undefined
        }
        optimizeNames(names, constants) {
          this.code = optimizeExpr(this.code, names, constants)
          return this
        }
        get names() {
          return this.code instanceof code_1._CodeOrName ? this.code.names : {}
        }
      }
      class ParentNode extends Node {
        constructor(nodes = []) {
          super()
          this.nodes = nodes
        }
        render(opts) {
          return this.nodes.reduce((code, n) => code + n.render(opts), '')
        }
        optimizeNodes() {
          const { nodes } = this
          let i = nodes.length
          while (i--) {
            const n = nodes[i].optimizeNodes()
            if (Array.isArray(n)) nodes.splice(i, 1, ...n)
            else if (n) nodes[i] = n
            else nodes.splice(i, 1)
          }
          return nodes.length > 0 ? this : undefined
        }
        optimizeNames(names, constants) {
          const { nodes } = this
          let i = nodes.length
          while (i--) {
            // iterating backwards improves 1-pass optimization
            const n = nodes[i]
            if (n.optimizeNames(names, constants)) continue
            subtractNames(names, n.names)
            nodes.splice(i, 1)
          }
          return nodes.length > 0 ? this : undefined
        }
        get names() {
          return this.nodes.reduce((names, n) => addNames(names, n.names), {})
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return '{' + opts._n + super.render(opts) + '}' + opts._n
        }
      }
      class Root extends ParentNode {}
      class Else extends BlockNode {}
      Else.kind = 'else'
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes)
          this.condition = condition
        }
        render(opts) {
          let code = `if(${this.condition})` + super.render(opts)
          if (this.else) code += 'else ' + this.else.render(opts)
          return code
        }
        optimizeNodes() {
          super.optimizeNodes()
          const cond = this.condition
          if (cond === true) return this.nodes // else is ignored here
          let e = this.else
          if (e) {
            const ns = e.optimizeNodes()
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns
          }
          if (e) {
            if (cond === false) return e instanceof If ? e : e.nodes
            if (this.nodes.length) return this
            return new If(not(cond), e instanceof If ? [e] : e.nodes)
          }
          if (cond === false || !this.nodes.length) return undefined
          return this
        }
        optimizeNames(names, constants) {
          var _a
          this.else =
            (_a = this.else) === null || _a === void 0
              ? void 0
              : _a.optimizeNames(names, constants)
          if (!(super.optimizeNames(names, constants) || this.else)) return
          this.condition = optimizeExpr(this.condition, names, constants)
          return this
        }
        get names() {
          const names = super.names
          addExprNames(names, this.condition)
          if (this.else) addNames(names, this.else.names)
          return names
        }
      }
      If.kind = 'if'
      class For extends BlockNode {}
      For.kind = 'for'
      class ForLoop extends For {
        constructor(iteration) {
          super()
          this.iteration = iteration
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts)
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants)) return
          this.iteration = optimizeExpr(this.iteration, names, constants)
          return this
        }
        get names() {
          return addNames(super.names, this.iteration.names)
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from, to) {
          super()
          this.varKind = varKind
          this.name = name
          this.from = from
          this.to = to
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind
          const { name, from, to } = this
          return (
            `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` +
            super.render(opts)
          )
        }
        get names() {
          const names = addExprNames(super.names, this.from)
          return addExprNames(names, this.to)
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super()
          this.loop = loop
          this.varKind = varKind
          this.name = name
          this.iterable = iterable
        }
        render(opts) {
          return (
            `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
            super.render(opts)
          )
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants)) return
          this.iterable = optimizeExpr(this.iterable, names, constants)
          return this
        }
        get names() {
          return addNames(super.names, this.iterable.names)
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super()
          this.name = name
          this.args = args
          this.async = async
        }
        render(opts) {
          const _async = this.async ? 'async ' : ''
          return (
            `${_async}function ${this.name}(${this.args})` + super.render(opts)
          )
        }
      }
      Func.kind = 'func'
      class Return extends ParentNode {
        render(opts) {
          return 'return ' + super.render(opts)
        }
      }
      Return.kind = 'return'
      class Try extends BlockNode {
        render(opts) {
          let code = 'try' + super.render(opts)
          if (this.catch) code += this.catch.render(opts)
          if (this.finally) code += this.finally.render(opts)
          return code
        }
        optimizeNodes() {
          var _a, _b
          super.optimizeNodes()
          ;(_a = this.catch) === null || _a === void 0
            ? void 0
            : _a.optimizeNodes()
          ;(_b = this.finally) === null || _b === void 0
            ? void 0
            : _b.optimizeNodes()
          return this
        }
        optimizeNames(names, constants) {
          var _a, _b
          super.optimizeNames(names, constants)
          ;(_a = this.catch) === null || _a === void 0
            ? void 0
            : _a.optimizeNames(names, constants)
          ;(_b = this.finally) === null || _b === void 0
            ? void 0
            : _b.optimizeNames(names, constants)
          return this
        }
        get names() {
          const names = super.names
          if (this.catch) addNames(names, this.catch.names)
          if (this.finally) addNames(names, this.finally.names)
          return names
        }
      }
      class Catch extends BlockNode {
        constructor(error) {
          super()
          this.error = error
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts)
        }
      }
      Catch.kind = 'catch'
      class Finally extends BlockNode {
        render(opts) {
          return 'finally' + super.render(opts)
        }
      }
      Finally.kind = 'finally'
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {}
          this._blockStarts = []
          this._constants = {}
          this.opts = { ...opts, _n: opts.lines ? '\n' : '' }
          this._extScope = extScope
          this._scope = new scope_1.Scope({ parent: extScope })
          this._nodes = [new Root()]
        }
        toString() {
          return this._root.render(this.opts)
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix)
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix)
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value)
          const vs =
            this._values[name.prefix] || (this._values[name.prefix] = new Set())
          vs.add(name)
          return name
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef)
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values)
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values)
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix)
          if (rhs !== undefined && constant) this._constants[name.str] = rhs
          this._leafNode(new Def(varKind, name, rhs))
          return name
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant)
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant)
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant)
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects))
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs))
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
          if (typeof c == 'function') c()
          else if (c !== code_1.nil) this._leafNode(new AnyCode(c))
          return this
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
          const code = ['{']
          for (const [key, value] of keyValues) {
            if (code.length > 1) code.push(',')
            code.push(key)
            if (key !== value || this.opts.es5) {
              code.push(':')
              ;(0, code_1.addCodeArg)(code, value)
            }
          }
          code.push('}')
          return new code_1._Code(code)
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition))
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf()
          } else if (thenBody) {
            this.code(thenBody).endIf()
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body')
          }
          return this
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition))
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else())
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else)
        }
        _for(node, forBody) {
          this._blockNode(node)
          if (forBody) this.code(forBody).endFor()
          return this
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody)
        }
        // `for` statement for a range of values
        forRange(
          nameOrPrefix,
          from,
          to,
          forBody,
          varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let
        ) {
          const name = this._scope.toName(nameOrPrefix)
          return this._for(new ForRange(varKind, name, from, to), () =>
            forBody(name)
          )
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(
          nameOrPrefix,
          iterable,
          forBody,
          varKind = scope_1.varKinds.const
        ) {
          const name = this._scope.toName(nameOrPrefix)
          if (this.opts.es5) {
            const arr =
              iterable instanceof code_1.Name
                ? iterable
                : this.var('_arr', iterable)
            return this.forRange('_i', 0, (0, code_1._)`${arr}.length`, (i) => {
              this.var(name, (0, code_1._)`${arr}[${i}]`)
              forBody(name)
            })
          }
          return this._for(new ForIter('of', varKind, name, iterable), () =>
            forBody(name)
          )
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(
          nameOrPrefix,
          obj,
          forBody,
          varKind = this.opts.es5
            ? scope_1.varKinds.var
            : scope_1.varKinds.const
        ) {
          if (this.opts.ownProperties) {
            return this.forOf(
              nameOrPrefix,
              (0, code_1._)`Object.keys(${obj})`,
              forBody
            )
          }
          const name = this._scope.toName(nameOrPrefix)
          return this._for(new ForIter('in', varKind, name, obj), () =>
            forBody(name)
          )
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For)
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label(label))
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label))
        }
        // `return` statement
        return(value) {
          const node = new Return()
          this._blockNode(node)
          this.code(value)
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node')
          return this._endBlockNode(Return)
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"')
          const node = new Try()
          this._blockNode(node)
          this.code(tryBody)
          if (catchCode) {
            const error = this.name('e')
            this._currNode = node.catch = new Catch(error)
            catchCode(error)
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally()
            this.code(finallyCode)
          }
          return this._endBlockNode(Catch, Finally)
        }
        // `throw` statement
        throw(error) {
          return this._leafNode(new Throw(error))
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length)
          if (body) this.code(body).endBlock(nodeCount)
          return this
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop()
          if (len === undefined)
            throw new Error('CodeGen: not in self-balancing block')
          const toClose = this._nodes.length - len
          if (
            toClose < 0 ||
            (nodeCount !== undefined && toClose !== nodeCount)
          ) {
            throw new Error(
              `CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`
            )
          }
          this._nodes.length = len
          return this
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_1.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async))
          if (funcBody) this.code(funcBody).endFunc()
          return this
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func)
        }
        optimize(n = 1) {
          while (n-- > 0) {
            this._root.optimizeNodes()
            this._root.optimizeNames(this._root.names, this._constants)
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node)
          return this
        }
        _blockNode(node) {
          this._currNode.nodes.push(node)
          this._nodes.push(node)
        }
        _endBlockNode(N1, N2) {
          const n = this._currNode
          if (n instanceof N1 || (N2 && n instanceof N2)) {
            this._nodes.pop()
            return this
          }
          throw new Error(
            `CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`
          )
        }
        _elseNode(node) {
          const n = this._currNode
          if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"')
          }
          this._currNode = n.else = node
          return this
        }
        get _root() {
          return this._nodes[0]
        }
        get _currNode() {
          const ns = this._nodes
          return ns[ns.length - 1]
        }
        set _currNode(node) {
          const ns = this._nodes
          ns[ns.length - 1] = node
        }
      }
      exports.CodeGen = CodeGen
      function addNames(names, from) {
        for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)
        return names
      }
      function addExprNames(names, from) {
        return from instanceof code_1._CodeOrName
          ? addNames(names, from.names)
          : names
      }
      function optimizeExpr(expr, names, constants) {
        if (expr instanceof code_1.Name) return replaceName(expr)
        if (!canOptimize(expr)) return expr
        return new code_1._Code(
          expr._items.reduce((items, c) => {
            if (c instanceof code_1.Name) c = replaceName(c)
            if (c instanceof code_1._Code) items.push(...c._items)
            else items.push(c)
            return items
          }, [])
        )
        function replaceName(n) {
          const c = constants[n.str]
          if (c === undefined || names[n.str] !== 1) return n
          delete names[n.str]
          return c
        }
        function canOptimize(e) {
          return (
            e instanceof code_1._Code &&
            e._items.some(
              (c) =>
                c instanceof code_1.Name &&
                names[c.str] === 1 &&
                constants[c.str] !== undefined
            )
          )
        }
      }
      function subtractNames(names, from) {
        for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)
      }
      function not(x) {
        return typeof x == 'boolean' || typeof x == 'number' || x === null
          ? !x
          : (0, code_1._)`!${par(x)}`
      }
      exports.not = not
      const andCode = mappend(exports.operators.AND)
      // boolean AND (&&) expression with the passed arguments
      function and(...args) {
        return args.reduce(andCode)
      }
      exports.and = and
      const orCode = mappend(exports.operators.OR)
      // boolean OR (||) expression with the passed arguments
      function or(...args) {
        return args.reduce(orCode)
      }
      exports.or = or
      function mappend(op) {
        return (x, y) =>
          x === code_1.nil
            ? y
            : y === code_1.nil
              ? x
              : (0, code_1._)`${par(x)} ${op} ${par(y)}`
      }
      function par(x) {
        return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`
      }
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 8490: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.ValueScope =
        exports.ValueScopeName =
        exports.Scope =
        exports.varKinds =
        exports.UsedValueState =
          void 0
      const code_1 = __webpack_require__(7023)
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`)
          this.value = name.value
        }
      }
      var UsedValueState
      ;(function (UsedValueState) {
        UsedValueState[(UsedValueState['Started'] = 0)] = 'Started'
        UsedValueState[(UsedValueState['Completed'] = 1)] = 'Completed'
      })(
        (UsedValueState =
          exports.UsedValueState || (exports.UsedValueState = {}))
      )
      exports.varKinds = {
        const: new code_1.Name('const'),
        let: new code_1.Name('let'),
        var: new code_1.Name('var')
      }
      class Scope {
        constructor({ prefixes, parent } = {}) {
          this._names = {}
          this._prefixes = prefixes
          this._parent = parent
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_1.Name
            ? nameOrPrefix
            : this.name(nameOrPrefix)
        }
        name(prefix) {
          return new code_1.Name(this._newName(prefix))
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix)
          return `${prefix}${ng.index++}`
        }
        _nameGroup(prefix) {
          var _a, _b
          if (
            ((_b =
              (_a = this._parent) === null || _a === void 0
                ? void 0
                : _a._prefixes) === null || _b === void 0
              ? void 0
              : _b.has(prefix)) ||
            (this._prefixes && !this._prefixes.has(prefix))
          ) {
            throw new Error(
              `CodeGen: prefix "${prefix}" is not allowed in this scope`
            )
          }
          return (this._names[prefix] = { prefix, index: 0 })
        }
      }
      exports.Scope = Scope
      class ValueScopeName extends code_1.Name {
        constructor(prefix, nameStr) {
          super(nameStr)
          this.prefix = prefix
        }
        setValue(value, { property, itemIndex }) {
          this.value = value
          this.scopePath = (0, code_1._)`.${new code_1.Name(
            property
          )}[${itemIndex}]`
        }
      }
      exports.ValueScopeName = ValueScopeName
      const line = (0, code_1._)`\n`
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts)
          this._values = {}
          this._scope = opts.scope
          this.opts = { ...opts, _n: opts.lines ? line : code_1.nil }
        }
        get() {
          return this._scope
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix))
        }
        value(nameOrPrefix, value) {
          var _a
          if (value.ref === undefined)
            throw new Error('CodeGen: ref must be passed in value')
          const name = this.toName(nameOrPrefix)
          const { prefix } = name
          const valueKey =
            (_a = value.key) !== null && _a !== void 0 ? _a : value.ref
          let vs = this._values[prefix]
          if (vs) {
            const _name = vs.get(valueKey)
            if (_name) return _name
          } else {
            vs = this._values[prefix] = new Map()
          }
          vs.set(valueKey, name)
          const s = this._scope[prefix] || (this._scope[prefix] = [])
          const itemIndex = s.length
          s[itemIndex] = value.ref
          name.setValue(value, { property: prefix, itemIndex })
          return name
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix]
          if (!vs) return
          return vs.get(keyOrRef)
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === undefined)
              throw new Error(`CodeGen: name "${name}" has no value`)
            return (0, code_1._)`${scopeName}${name.scopePath}`
          })
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(
            values,
            (name) => {
              if (name.value === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`)
              return name.value.code
            },
            usedValues,
            getCode
          )
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code = code_1.nil
          for (const prefix in values) {
            const vs = values[prefix]
            if (!vs) continue
            const nameSet = (usedValues[prefix] =
              usedValues[prefix] || new Map())
            vs.forEach((name) => {
              if (nameSet.has(name)) return
              nameSet.set(name, UsedValueState.Started)
              let c = valueCode(name)
              if (c) {
                const def = this.opts.es5
                  ? exports.varKinds.var
                  : exports.varKinds.const
                code = (0,
                code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`
              } else if (
                (c =
                  getCode === null || getCode === void 0
                    ? void 0
                    : getCode(name))
              ) {
                code = (0, code_1._)`${code}${c}${this.opts._n}`
              } else {
                throw new ValueError(name)
              }
              nameSet.set(name, UsedValueState.Completed)
            })
          }
          return code
        }
      }
      exports.ValueScope = ValueScope
      //# sourceMappingURL=scope.js.map

      /***/
    },

    /***/ 4181: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.extendErrors =
        exports.resetErrorsCount =
        exports.reportExtraError =
        exports.reportError =
        exports.keyword$DataError =
        exports.keywordError =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const names_1 = __webpack_require__(2141)
      exports.keywordError = {
        message: ({ keyword }) =>
          (0, codegen_1.str)`must pass "${keyword}" keyword validation`
      }
      exports.keyword$DataError = {
        message: ({ keyword, schemaType }) =>
          schemaType
            ? (0,
              codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)`
            : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
      }
      function reportError(
        cxt,
        error = exports.keywordError,
        errorPaths,
        overrideAllErrors
      ) {
        const { it } = cxt
        const { gen, compositeRule, allErrors } = it
        const errObj = errorObjectCode(cxt, error, errorPaths)
        if (
          overrideAllErrors !== null && overrideAllErrors !== void 0
            ? overrideAllErrors
            : compositeRule || allErrors
        ) {
          addError(gen, errObj)
        } else {
          returnErrors(it, (0, codegen_1._)`[${errObj}]`)
        }
      }
      exports.reportError = reportError
      function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it } = cxt
        const { gen, compositeRule, allErrors } = it
        const errObj = errorObjectCode(cxt, error, errorPaths)
        addError(gen, errObj)
        if (!(compositeRule || allErrors)) {
          returnErrors(it, names_1.default.vErrors)
        }
      }
      exports.reportExtraError = reportExtraError
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount)
        gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () =>
          gen.if(
            errsCount,
            () =>
              gen.assign(
                (0, codegen_1._)`${names_1.default.vErrors}.length`,
                errsCount
              ),
            () => gen.assign(names_1.default.vErrors, null)
          )
        )
      }
      exports.resetErrorsCount = resetErrorsCount
      function extendErrors({
        gen,
        keyword,
        schemaValue,
        data,
        errsCount,
        it
      }) {
        /* istanbul ignore if */
        if (errsCount === undefined) throw new Error('ajv implementation error')
        const err = gen.name('err')
        gen.forRange('i', errsCount, names_1.default.errors, (i) => {
          gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`)
          gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () =>
            gen.assign(
              (0, codegen_1._)`${err}.instancePath`,
              (0, codegen_1.strConcat)(
                names_1.default.instancePath,
                it.errorPath
              )
            )
          )
          gen.assign(
            (0, codegen_1._)`${err}.schemaPath`,
            (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`
          )
          if (it.opts.verbose) {
            gen.assign((0, codegen_1._)`${err}.schema`, schemaValue)
            gen.assign((0, codegen_1._)`${err}.data`, data)
          }
        })
      }
      exports.extendErrors = extendErrors
      function addError(gen, errObj) {
        const err = gen.const('err', errObj)
        gen.if(
          (0, codegen_1._)`${names_1.default.vErrors} === null`,
          () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`),
          (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`
        )
        gen.code((0, codegen_1._)`${names_1.default.errors}++`)
      }
      function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it
        if (schemaEnv.$async) {
          gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`)
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, errs)
          gen.return(false)
        }
      }
      const E = {
        keyword: new codegen_1.Name('keyword'),
        schemaPath: new codegen_1.Name('schemaPath'),
        params: new codegen_1.Name('params'),
        propertyName: new codegen_1.Name('propertyName'),
        message: new codegen_1.Name('message'),
        schema: new codegen_1.Name('schema'),
        parentSchema: new codegen_1.Name('parentSchema')
      }
      function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it
        if (createErrors === false) return (0, codegen_1._)`{}`
        return errorObject(cxt, error, errorPaths)
      }
      function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt
        const keyValues = [
          errorInstancePath(it, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ]
        extraErrorProps(cxt, error, keyValues)
        return gen.object(...keyValues)
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath
          ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(
              instancePath,
              util_1.Type.Str
            )}`
          : errorPath
        return [
          names_1.default.instancePath,
          (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)
        ]
      }
      function errorSchemaPath(
        { keyword, it: { errSchemaPath } },
        { schemaPath, parentSchema }
      ) {
        let schPath = parentSchema
          ? errSchemaPath
          : (0, codegen_1.str)`${errSchemaPath}/${keyword}`
        if (schemaPath) {
          schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(
            schemaPath,
            util_1.Type.Str
          )}`
        }
        return [E.schemaPath, schPath]
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword, data, schemaValue, it } = cxt
        const { opts, propertyName, topSchemaRef, schemaPath } = it
        keyValues.push(
          [E.keyword, keyword],
          [
            E.params,
            typeof params == 'function'
              ? params(cxt)
              : params || (0, codegen_1._)`{}`
          ]
        )
        if (opts.messages) {
          keyValues.push([
            E.message,
            typeof message == 'function' ? message(cxt) : message
          ])
        }
        if (opts.verbose) {
          keyValues.push(
            [E.schema, schemaValue],
            [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`],
            [names_1.default.data, data]
          )
        }
        if (propertyName) keyValues.push([E.propertyName, propertyName])
      }
      //# sourceMappingURL=errors.js.map

      /***/
    },

    /***/ 5173: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.resolveSchema =
        exports.getCompilingSchema =
        exports.resolveRef =
        exports.compileSchema =
        exports.SchemaEnv =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const validation_error_1 = __webpack_require__(7426)
      const names_1 = __webpack_require__(2141)
      const resolve_1 = __webpack_require__(2531)
      const util_1 = __webpack_require__(6776)
      const validate_1 = __webpack_require__(4815)
      class SchemaEnv {
        constructor(env) {
          var _a
          this.refs = {}
          this.dynamicAnchors = {}
          let schema
          if (typeof env.schema == 'object') schema = env.schema
          this.schema = env.schema
          this.schemaId = env.schemaId
          this.root = env.root || this
          this.baseId =
            (_a = env.baseId) !== null && _a !== void 0
              ? _a
              : (0, resolve_1.normalizeId)(
                  schema === null || schema === void 0
                    ? void 0
                    : schema[env.schemaId || '$id']
                )
          this.schemaPath = env.schemaPath
          this.localRefs = env.localRefs
          this.meta = env.meta
          this.$async =
            schema === null || schema === void 0 ? void 0 : schema.$async
          this.refs = {}
        }
      }
      exports.SchemaEnv = SchemaEnv
      // let codeSize = 0
      // let nodeCount = 0
      // Compiles schema in SchemaEnv
      function compileSchema(sch) {
        // TODO refactor - remove compilations
        const _sch = getCompilingSchema.call(this, sch)
        if (_sch) return _sch
        const rootId = (0, resolve_1.getFullPath)(
          this.opts.uriResolver,
          sch.root.baseId
        ) // TODO if getFullPath removed 1 tests fails
        const { es5, lines } = this.opts.code
        const { ownProperties } = this.opts
        const gen = new codegen_1.CodeGen(this.scope, {
          es5,
          lines,
          ownProperties
        })
        let _ValidationError
        if (sch.$async) {
          _ValidationError = gen.scopeValue('Error', {
            ref: validation_error_1.default,
            code: (0,
            codegen_1._)`require("ajv/dist/runtime/validation_error").default`
          })
        }
        const validateName = gen.scopeName('validate')
        sch.validateName = validateName
        const schemaCxt = {
          gen,
          allErrors: this.opts.allErrors,
          data: names_1.default.data,
          parentData: names_1.default.parentData,
          parentDataProperty: names_1.default.parentDataProperty,
          dataNames: [names_1.default.data],
          dataPathArr: [codegen_1.nil],
          dataLevel: 0,
          dataTypes: [],
          definedProperties: new Set(),
          topSchemaRef: gen.scopeValue(
            'schema',
            this.opts.code.source === true
              ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
              : { ref: sch.schema }
          ),
          validateName,
          ValidationError: _ValidationError,
          schema: sch.schema,
          schemaEnv: sch,
          rootId,
          baseId: sch.baseId || rootId,
          schemaPath: codegen_1.nil,
          errSchemaPath: sch.schemaPath || (this.opts.jtd ? '' : '#'),
          errorPath: (0, codegen_1._)`""`,
          opts: this.opts,
          self: this
        }
        let sourceCode
        try {
          this._compilations.add(sch)
          ;(0, validate_1.validateFunctionCode)(schemaCxt)
          gen.optimize(this.opts.code.optimize)
          // gen.optimize(1)
          const validateCode = gen.toString()
          sourceCode = `${gen.scopeRefs(
            names_1.default.scope
          )}return ${validateCode}`
          // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
          if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch)
          // console.log("\n\n\n *** \n", sourceCode)
          const makeValidate = new Function(
            `${names_1.default.self}`,
            `${names_1.default.scope}`,
            sourceCode
          )
          const validate = makeValidate(this, this.scope.get())
          this.scope.value(validateName, { ref: validate })
          validate.errors = null
          validate.schema = sch.schema
          validate.schemaEnv = sch
          if (sch.$async) validate.$async = true
          if (this.opts.code.source === true) {
            validate.source = {
              validateName,
              validateCode,
              scopeValues: gen._values
            }
          }
          if (this.opts.unevaluated) {
            const { props, items } = schemaCxt
            validate.evaluated = {
              props: props instanceof codegen_1.Name ? undefined : props,
              items: items instanceof codegen_1.Name ? undefined : items,
              dynamicProps: props instanceof codegen_1.Name,
              dynamicItems: items instanceof codegen_1.Name
            }
            if (validate.source)
              validate.source.evaluated = (0, codegen_1.stringify)(
                validate.evaluated
              )
          }
          sch.validate = validate
          return sch
        } catch (e) {
          delete sch.validate
          delete sch.validateName
          if (sourceCode)
            this.logger.error(
              'Error compiling schema, function code:',
              sourceCode
            )
          // console.log("\n\n\n *** \n", sourceCode, this.opts)
          throw e
        } finally {
          this._compilations.delete(sch)
        }
      }
      exports.compileSchema = compileSchema
      function resolveRef(root, baseId, ref) {
        var _a
        ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref)
        const schOrFunc = root.refs[ref]
        if (schOrFunc) return schOrFunc
        let _sch = resolve.call(this, root, ref)
        if (_sch === undefined) {
          const schema =
            (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref] // TODO maybe localRefs should hold SchemaEnv
          const { schemaId } = this.opts
          if (schema) _sch = new SchemaEnv({ schema, schemaId, root, baseId })
        }
        if (_sch === undefined) return
        return (root.refs[ref] = inlineOrCompile.call(this, _sch))
      }
      exports.resolveRef = resolveRef
      function inlineOrCompile(sch) {
        if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
          return sch.schema
        return sch.validate ? sch : compileSchema.call(this, sch)
      }
      // Index of schema compilation in the currently compiled list
      function getCompilingSchema(schEnv) {
        for (const sch of this._compilations) {
          if (sameSchemaEnv(sch, schEnv)) return sch
        }
      }
      exports.getCompilingSchema = getCompilingSchema
      function sameSchemaEnv(s1, s2) {
        return (
          s1.schema === s2.schema &&
          s1.root === s2.root &&
          s1.baseId === s2.baseId
        )
      }
      // resolve and compile the references ($ref)
      // TODO returns AnySchemaObject (if the schema can be inlined) or validation function
      function resolve(
        root, // information about the root schema for the current schema
        ref // reference to resolve
      ) {
        let sch
        while (typeof (sch = this.refs[ref]) == 'string') ref = sch
        return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)
      }
      // Resolve schema, its root and baseId
      function resolveSchema(
        root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
        ref // reference to resolve
      ) {
        const p = this.opts.uriResolver.parse(ref)
        const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p)
        let baseId = (0, resolve_1.getFullPath)(
          this.opts.uriResolver,
          root.baseId,
          undefined
        )
        // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
          return getJsonPointer.call(this, p, root)
        }
        const id = (0, resolve_1.normalizeId)(refPath)
        const schOrRef = this.refs[id] || this.schemas[id]
        if (typeof schOrRef == 'string') {
          const sch = resolveSchema.call(this, root, schOrRef)
          if (
            typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !==
            'object'
          )
            return
          return getJsonPointer.call(this, p, sch)
        }
        if (
          typeof (schOrRef === null || schOrRef === void 0
            ? void 0
            : schOrRef.schema) !== 'object'
        )
          return
        if (!schOrRef.validate) compileSchema.call(this, schOrRef)
        if (id === (0, resolve_1.normalizeId)(ref)) {
          const { schema } = schOrRef
          const { schemaId } = this.opts
          const schId = schema[schemaId]
          if (schId)
            baseId = (0, resolve_1.resolveUrl)(
              this.opts.uriResolver,
              baseId,
              schId
            )
          return new SchemaEnv({ schema, schemaId, root, baseId })
        }
        return getJsonPointer.call(this, p, schOrRef)
      }
      exports.resolveSchema = resolveSchema
      const PREVENT_SCOPE_CHANGE = new Set([
        'properties',
        'patternProperties',
        'enum',
        'dependencies',
        'definitions'
      ])
      function getJsonPointer(parsedRef, { baseId, schema, root }) {
        var _a
        if (
          ((_a = parsedRef.fragment) === null || _a === void 0
            ? void 0
            : _a[0]) !== '/'
        )
          return
        for (const part of parsedRef.fragment.slice(1).split('/')) {
          if (typeof schema === 'boolean') return
          const partSchema = schema[(0, util_1.unescapeFragment)(part)]
          if (partSchema === undefined) return
          schema = partSchema
          // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
          const schId = typeof schema === 'object' && schema[this.opts.schemaId]
          if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(
              this.opts.uriResolver,
              baseId,
              schId
            )
          }
        }
        let env
        if (
          typeof schema != 'boolean' &&
          schema.$ref &&
          !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)
        ) {
          const $ref = (0, resolve_1.resolveUrl)(
            this.opts.uriResolver,
            baseId,
            schema.$ref
          )
          env = resolveSchema.call(this, root, $ref)
        }
        // even though resolution failed we need to return SchemaEnv to throw exception
        // so that compileAsync loads missing schema.
        const { schemaId } = this.opts
        env = env || new SchemaEnv({ schema, schemaId, root, baseId })
        if (env.schema !== env.root.schema) return env
        return undefined
      }
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 2141: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const names = {
        // validation function arguments
        data: new codegen_1.Name('data'),
        // args passed from referencing schema
        valCxt: new codegen_1.Name('valCxt'),
        instancePath: new codegen_1.Name('instancePath'),
        parentData: new codegen_1.Name('parentData'),
        parentDataProperty: new codegen_1.Name('parentDataProperty'),
        rootData: new codegen_1.Name('rootData'),
        dynamicAnchors: new codegen_1.Name('dynamicAnchors'),
        // function scoped variables
        vErrors: new codegen_1.Name('vErrors'),
        errors: new codegen_1.Name('errors'),
        this: new codegen_1.Name('this'),
        // "globals"
        self: new codegen_1.Name('self'),
        scope: new codegen_1.Name('scope'),
        // JTD serialize/parse name for JSON string and position
        json: new codegen_1.Name('json'),
        jsonPos: new codegen_1.Name('jsonPos'),
        jsonLen: new codegen_1.Name('jsonLen'),
        jsonPart: new codegen_1.Name('jsonPart')
      }
      exports['default'] = names
      //# sourceMappingURL=names.js.map

      /***/
    },

    /***/ 6646: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const resolve_1 = __webpack_require__(2531)
      class MissingRefError extends Error {
        constructor(resolver, baseId, ref, msg) {
          super(msg || `can't resolve reference ${ref} from id ${baseId}`)
          this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref)
          this.missingSchema = (0, resolve_1.normalizeId)(
            (0, resolve_1.getFullPath)(resolver, this.missingRef)
          )
        }
      }
      exports['default'] = MissingRefError
      //# sourceMappingURL=ref_error.js.map

      /***/
    },

    /***/ 2531: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.getSchemaRefs =
        exports.resolveUrl =
        exports.normalizeId =
        exports._getFullPath =
        exports.getFullPath =
        exports.inlineRef =
          void 0
      const util_1 = __webpack_require__(6776)
      const equal = __webpack_require__(4063)
      const traverse = __webpack_require__(9461)
      // TODO refactor to use keyword definitions
      const SIMPLE_INLINED = new Set([
        'type',
        'format',
        'pattern',
        'maxLength',
        'minLength',
        'maxProperties',
        'minProperties',
        'maxItems',
        'minItems',
        'maximum',
        'minimum',
        'uniqueItems',
        'multipleOf',
        'required',
        'enum',
        'const'
      ])
      function inlineRef(schema, limit = true) {
        if (typeof schema == 'boolean') return true
        if (limit === true) return !hasRef(schema)
        if (!limit) return false
        return countKeys(schema) <= limit
      }
      exports.inlineRef = inlineRef
      const REF_KEYWORDS = new Set([
        '$ref',
        '$recursiveRef',
        '$recursiveAnchor',
        '$dynamicRef',
        '$dynamicAnchor'
      ])
      function hasRef(schema) {
        for (const key in schema) {
          if (REF_KEYWORDS.has(key)) return true
          const sch = schema[key]
          if (Array.isArray(sch) && sch.some(hasRef)) return true
          if (typeof sch == 'object' && hasRef(sch)) return true
        }
        return false
      }
      function countKeys(schema) {
        let count = 0
        for (const key in schema) {
          if (key === '$ref') return Infinity
          count++
          if (SIMPLE_INLINED.has(key)) continue
          if (typeof schema[key] == 'object') {
            ;(0, util_1.eachItem)(
              schema[key],
              (sch) => (count += countKeys(sch))
            )
          }
          if (count === Infinity) return Infinity
        }
        return count
      }
      function getFullPath(resolver, id = '', normalize) {
        if (normalize !== false) id = normalizeId(id)
        const p = resolver.parse(id)
        return _getFullPath(resolver, p)
      }
      exports.getFullPath = getFullPath
      function _getFullPath(resolver, p) {
        const serialized = resolver.serialize(p)
        return serialized.split('#')[0] + '#'
      }
      exports._getFullPath = _getFullPath
      const TRAILING_SLASH_HASH = /#\/?$/
      function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, '') : ''
      }
      exports.normalizeId = normalizeId
      function resolveUrl(resolver, baseId, id) {
        id = normalizeId(id)
        return resolver.resolve(baseId, id)
      }
      exports.resolveUrl = resolveUrl
      const ANCHOR = /^[a-z_][-a-z0-9._]*$/i
      function getSchemaRefs(schema, baseId) {
        if (typeof schema == 'boolean') return {}
        const { schemaId, uriResolver } = this.opts
        const schId = normalizeId(schema[schemaId] || baseId)
        const baseIds = { '': schId }
        const pathPrefix = getFullPath(uriResolver, schId, false)
        const localRefs = {}
        const schemaRefs = new Set()
        traverse(
          schema,
          { allKeys: true },
          (sch, jsonPtr, _, parentJsonPtr) => {
            if (parentJsonPtr === undefined) return
            const fullPath = pathPrefix + jsonPtr
            let baseId = baseIds[parentJsonPtr]
            if (typeof sch[schemaId] == 'string')
              baseId = addRef.call(this, sch[schemaId])
            addAnchor.call(this, sch.$anchor)
            addAnchor.call(this, sch.$dynamicAnchor)
            baseIds[jsonPtr] = baseId
            function addRef(ref) {
              // eslint-disable-next-line @typescript-eslint/unbound-method
              const _resolve = this.opts.uriResolver.resolve
              ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)
              if (schemaRefs.has(ref)) throw ambiguos(ref)
              schemaRefs.add(ref)
              let schOrRef = this.refs[ref]
              if (typeof schOrRef == 'string') schOrRef = this.refs[schOrRef]
              if (typeof schOrRef == 'object') {
                checkAmbiguosRef(sch, schOrRef.schema, ref)
              } else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === '#') {
                  checkAmbiguosRef(sch, localRefs[ref], ref)
                  localRefs[ref] = sch
                } else {
                  this.refs[ref] = fullPath
                }
              }
              return ref
            }
            function addAnchor(anchor) {
              if (typeof anchor == 'string') {
                if (!ANCHOR.test(anchor))
                  throw new Error(`invalid anchor "${anchor}"`)
                addRef.call(this, `#${anchor}`)
              }
            }
          }
        )
        return localRefs
        function checkAmbiguosRef(sch1, sch2, ref) {
          if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)
        }
        function ambiguos(ref) {
          return new Error(
            `reference "${ref}" resolves to more than one schema`
          )
        }
      }
      exports.getSchemaRefs = getSchemaRefs
      //# sourceMappingURL=resolve.js.map

      /***/
    },

    /***/ 3141: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.getRules = exports.isJSONType = void 0
      const _jsonTypes = [
        'string',
        'number',
        'integer',
        'boolean',
        'null',
        'object',
        'array'
      ]
      const jsonTypes = new Set(_jsonTypes)
      function isJSONType(x) {
        return typeof x == 'string' && jsonTypes.has(x)
      }
      exports.isJSONType = isJSONType
      function getRules() {
        const groups = {
          number: { type: 'number', rules: [] },
          string: { type: 'string', rules: [] },
          array: { type: 'array', rules: [] },
          object: { type: 'object', rules: [] }
        }
        return {
          types: { ...groups, integer: true, boolean: true, null: true },
          rules: [
            { rules: [] },
            groups.number,
            groups.string,
            groups.array,
            groups.object
          ],
          post: { rules: [] },
          all: {},
          keywords: {}
        }
      }
      exports.getRules = getRules
      //# sourceMappingURL=rules.js.map

      /***/
    },

    /***/ 6776: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.checkStrictMode =
        exports.getErrorPath =
        exports.Type =
        exports.useFunc =
        exports.setEvaluated =
        exports.evaluatedPropsToName =
        exports.mergeEvaluated =
        exports.eachItem =
        exports.unescapeJsonPointer =
        exports.escapeJsonPointer =
        exports.escapeFragment =
        exports.unescapeFragment =
        exports.schemaRefOrVal =
        exports.schemaHasRulesButRef =
        exports.schemaHasRules =
        exports.checkUnknownRules =
        exports.alwaysValidSchema =
        exports.toHash =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const code_1 = __webpack_require__(7023)
      // TODO refactor to use Set
      function toHash(arr) {
        const hash = {}
        for (const item of arr) hash[item] = true
        return hash
      }
      exports.toHash = toHash
      function alwaysValidSchema(it, schema) {
        if (typeof schema == 'boolean') return schema
        if (Object.keys(schema).length === 0) return true
        checkUnknownRules(it, schema)
        return !schemaHasRules(schema, it.self.RULES.all)
      }
      exports.alwaysValidSchema = alwaysValidSchema
      function checkUnknownRules(it, schema = it.schema) {
        const { opts, self } = it
        if (!opts.strictSchema) return
        if (typeof schema === 'boolean') return
        const rules = self.RULES.keywords
        for (const key in schema) {
          if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`)
        }
      }
      exports.checkUnknownRules = checkUnknownRules
      function schemaHasRules(schema, rules) {
        if (typeof schema == 'boolean') return !schema
        for (const key in schema) if (rules[key]) return true
        return false
      }
      exports.schemaHasRules = schemaHasRules
      function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == 'boolean') return !schema
        for (const key in schema)
          if (key !== '$ref' && RULES.all[key]) return true
        return false
      }
      exports.schemaHasRulesButRef = schemaHasRulesButRef
      function schemaRefOrVal(
        { topSchemaRef, schemaPath },
        schema,
        keyword,
        $data
      ) {
        if (!$data) {
          if (typeof schema == 'number' || typeof schema == 'boolean')
            return schema
          if (typeof schema == 'string') return (0, codegen_1._)`${schema}`
        }
        return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0,
        codegen_1.getProperty)(keyword)}`
      }
      exports.schemaRefOrVal = schemaRefOrVal
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str))
      }
      exports.unescapeFragment = unescapeFragment
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str))
      }
      exports.escapeFragment = escapeFragment
      function escapeJsonPointer(str) {
        if (typeof str == 'number') return `${str}`
        return str.replace(/~/g, '~0').replace(/\//g, '~1')
      }
      exports.escapeJsonPointer = escapeJsonPointer
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, '/').replace(/~0/g, '~')
      }
      exports.unescapeJsonPointer = unescapeJsonPointer
      function eachItem(xs, f) {
        if (Array.isArray(xs)) {
          for (const x of xs) f(x)
        } else {
          f(xs)
        }
      }
      exports.eachItem = eachItem
      function makeMergeEvaluated({
        mergeNames,
        mergeToName,
        mergeValues,
        resultToName
      }) {
        return (gen, from, to, toName) => {
          const res =
            to === undefined
              ? from
              : to instanceof codegen_1.Name
                ? (from instanceof codegen_1.Name
                    ? mergeNames(gen, from, to)
                    : mergeToName(gen, from, to),
                  to)
                : from instanceof codegen_1.Name
                  ? (mergeToName(gen, to, from), from)
                  : mergeValues(from, to)
          return toName === codegen_1.Name && !(res instanceof codegen_1.Name)
            ? resultToName(gen, res)
            : res
        }
      }
      exports.mergeEvaluated = {
        props: makeMergeEvaluated({
          mergeNames: (gen, from, to) =>
            gen.if(
              (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
              () => {
                gen.if(
                  (0, codegen_1._)`${from} === true`,
                  () => gen.assign(to, true),
                  () =>
                    gen
                      .assign(to, (0, codegen_1._)`${to} || {}`)
                      .code((0, codegen_1._)`Object.assign(${to}, ${from})`)
                )
              }
            ),
          mergeToName: (gen, from, to) =>
            gen.if((0, codegen_1._)`${to} !== true`, () => {
              if (from === true) {
                gen.assign(to, true)
              } else {
                gen.assign(to, (0, codegen_1._)`${to} || {}`)
                setEvaluated(gen, to, from)
              }
            }),
          mergeValues: (from, to) =>
            from === true ? true : { ...from, ...to },
          resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
          mergeNames: (gen, from, to) =>
            gen.if(
              (0, codegen_1._)`${to} !== true && ${from} !== undefined`,
              () =>
                gen.assign(
                  to,
                  (0,
                  codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`
                )
            ),
          mergeToName: (gen, from, to) =>
            gen.if((0, codegen_1._)`${to} !== true`, () =>
              gen.assign(
                to,
                from === true
                  ? true
                  : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`
              )
            ),
          mergeValues: (from, to) =>
            from === true ? true : Math.max(from, to),
          resultToName: (gen, items) => gen.var('items', items)
        })
      }
      function evaluatedPropsToName(gen, ps) {
        if (ps === true) return gen.var('props', true)
        const props = gen.var('props', (0, codegen_1._)`{}`)
        if (ps !== undefined) setEvaluated(gen, props, ps)
        return props
      }
      exports.evaluatedPropsToName = evaluatedPropsToName
      function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p) =>
          gen.assign(
            (0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`,
            true
          )
        )
      }
      exports.setEvaluated = setEvaluated
      const snippets = {}
      function useFunc(gen, f) {
        return gen.scopeValue('func', {
          ref: f,
          code:
            snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
        })
      }
      exports.useFunc = useFunc
      var Type
      ;(function (Type) {
        Type[(Type['Num'] = 0)] = 'Num'
        Type[(Type['Str'] = 1)] = 'Str'
      })((Type = exports.Type || (exports.Type = {})))
      function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        // let path
        if (dataProp instanceof codegen_1.Name) {
          const isNumber = dataPropType === Type.Num
          return jsPropertySyntax
            ? isNumber
              ? (0, codegen_1._)`"[" + ${dataProp} + "]"`
              : (0, codegen_1._)`"['" + ${dataProp} + "']"`
            : isNumber
              ? (0, codegen_1._)`"/" + ${dataProp}`
              : (0,
                codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")` // TODO maybe use global escapePointer
        }
        return jsPropertySyntax
          ? (0, codegen_1.getProperty)(dataProp).toString()
          : '/' + escapeJsonPointer(dataProp)
      }
      exports.getErrorPath = getErrorPath
      function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode) return
        msg = `strict mode: ${msg}`
        if (mode === true) throw new Error(msg)
        it.self.logger.warn(msg)
      }
      exports.checkStrictMode = checkStrictMode
      //# sourceMappingURL=util.js.map

      /***/
    },

    /***/ 8876: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.shouldUseRule =
        exports.shouldUseGroup =
        exports.schemaHasRulesForType =
          void 0
      function schemaHasRulesForType({ schema, self }, type) {
        const group = self.RULES.types[type]
        return group && group !== true && shouldUseGroup(schema, group)
      }
      exports.schemaHasRulesForType = schemaHasRulesForType
      function shouldUseGroup(schema, group) {
        return group.rules.some((rule) => shouldUseRule(schema, rule))
      }
      exports.shouldUseGroup = shouldUseGroup
      function shouldUseRule(schema, rule) {
        var _a
        return (
          schema[rule.keyword] !== undefined ||
          ((_a = rule.definition.implements) === null || _a === void 0
            ? void 0
            : _a.some((kwd) => schema[kwd] !== undefined))
        )
      }
      exports.shouldUseRule = shouldUseRule
      //# sourceMappingURL=applicability.js.map

      /***/
    },

    /***/ 5667: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0
      const errors_1 = __webpack_require__(4181)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const boolError = {
        message: 'boolean schema is false'
      }
      function topBoolOrEmptySchema(it) {
        const { gen, schema, validateName } = it
        if (schema === false) {
          falseSchemaError(it, false)
        } else if (typeof schema == 'object' && schema.$async === true) {
          gen.return(names_1.default.data)
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, null)
          gen.return(true)
        }
      }
      exports.topBoolOrEmptySchema = topBoolOrEmptySchema
      function boolOrEmptySchema(it, valid) {
        const { gen, schema } = it
        if (schema === false) {
          gen.var(valid, false) // TODO var
          falseSchemaError(it)
        } else {
          gen.var(valid, true) // TODO var
        }
      }
      exports.boolOrEmptySchema = boolOrEmptySchema
      function falseSchemaError(it, overrideAllErrors) {
        const { gen, data } = it
        // TODO maybe some other interface should be used for non-keyword validation errors...
        const cxt = {
          gen,
          keyword: 'false schema',
          data,
          schema: false,
          schemaCode: false,
          schemaValue: false,
          params: {},
          it
        }
        ;(0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors)
      }
      //# sourceMappingURL=boolSchema.js.map

      /***/
    },

    /***/ 453: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.reportTypeError =
        exports.checkDataTypes =
        exports.checkDataType =
        exports.coerceAndCheckDataType =
        exports.getJSONTypes =
        exports.getSchemaTypes =
        exports.DataType =
          void 0
      const rules_1 = __webpack_require__(3141)
      const applicability_1 = __webpack_require__(8876)
      const errors_1 = __webpack_require__(4181)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      var DataType
      ;(function (DataType) {
        DataType[(DataType['Correct'] = 0)] = 'Correct'
        DataType[(DataType['Wrong'] = 1)] = 'Wrong'
      })((DataType = exports.DataType || (exports.DataType = {})))
      function getSchemaTypes(schema) {
        const types = getJSONTypes(schema.type)
        const hasNull = types.includes('null')
        if (hasNull) {
          if (schema.nullable === false)
            throw new Error('type: null contradicts nullable: false')
        } else {
          if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"')
          }
          if (schema.nullable === true) types.push('null')
        }
        return types
      }
      exports.getSchemaTypes = getSchemaTypes
      function getJSONTypes(ts) {
        const types = Array.isArray(ts) ? ts : ts ? [ts] : []
        if (types.every(rules_1.isJSONType)) return types
        throw new Error(
          'type must be JSONType or JSONType[]: ' + types.join(',')
        )
      }
      exports.getJSONTypes = getJSONTypes
      function coerceAndCheckDataType(it, types) {
        const { gen, data, opts } = it
        const coerceTo = coerceToTypes(types, opts.coerceTypes)
        const checkTypes =
          types.length > 0 &&
          !(
            coerceTo.length === 0 &&
            types.length === 1 &&
            (0, applicability_1.schemaHasRulesForType)(it, types[0])
          )
        if (checkTypes) {
          const wrongType = checkDataTypes(
            types,
            data,
            opts.strictNumbers,
            DataType.Wrong
          )
          gen.if(wrongType, () => {
            if (coerceTo.length) coerceData(it, types, coerceTo)
            else reportTypeError(it)
          })
        }
        return checkTypes
      }
      exports.coerceAndCheckDataType = coerceAndCheckDataType
      const COERCIBLE = new Set([
        'string',
        'number',
        'integer',
        'boolean',
        'null'
      ])
      function coerceToTypes(types, coerceTypes) {
        return coerceTypes
          ? types.filter(
              (t) =>
                COERCIBLE.has(t) || (coerceTypes === 'array' && t === 'array')
            )
          : []
      }
      function coerceData(it, types, coerceTo) {
        const { gen, data, opts } = it
        const dataType = gen.let('dataType', (0, codegen_1._)`typeof ${data}`)
        const coerced = gen.let('coerced', (0, codegen_1._)`undefined`)
        if (opts.coerceTypes === 'array') {
          gen.if(
            (0,
            codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`,
            () =>
              gen
                .assign(data, (0, codegen_1._)`${data}[0]`)
                .assign(dataType, (0, codegen_1._)`typeof ${data}`)
                .if(checkDataTypes(types, data, opts.strictNumbers), () =>
                  gen.assign(coerced, data)
                )
          )
        }
        gen.if((0, codegen_1._)`${coerced} !== undefined`)
        for (const t of coerceTo) {
          if (
            COERCIBLE.has(t) ||
            (t === 'array' && opts.coerceTypes === 'array')
          ) {
            coerceSpecificType(t)
          }
        }
        gen.else()
        reportTypeError(it)
        gen.endIf()
        gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
          gen.assign(data, coerced)
          assignParentData(it, coerced)
        })
        function coerceSpecificType(t) {
          switch (t) {
            case 'string':
              gen
                .elseIf(
                  (0,
                  codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`
                )
                .assign(coerced, (0, codegen_1._)`"" + ${data}`)
                .elseIf((0, codegen_1._)`${data} === null`)
                .assign(coerced, (0, codegen_1._)`""`)
              return
            case 'number':
              gen
                .elseIf(
                  (0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`
                )
                .assign(coerced, (0, codegen_1._)`+${data}`)
              return
            case 'integer':
              gen
                .elseIf(
                  (0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`
                )
                .assign(coerced, (0, codegen_1._)`+${data}`)
              return
            case 'boolean':
              gen
                .elseIf(
                  (0,
                  codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`
                )
                .assign(coerced, false)
                .elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`)
                .assign(coerced, true)
              return
            case 'null':
              gen.elseIf(
                (0,
                codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`
              )
              gen.assign(coerced, null)
              return
            case 'array':
              gen
                .elseIf(
                  (0,
                  codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`
                )
                .assign(coerced, (0, codegen_1._)`[${data}]`)
          }
        }
      }
      function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        // TODO use gen.property
        gen.if((0, codegen_1._)`${parentData} !== undefined`, () =>
          gen.assign(
            (0, codegen_1._)`${parentData}[${parentDataProperty}]`,
            expr
          )
        )
      }
      function checkDataType(
        dataType,
        data,
        strictNums,
        correct = DataType.Correct
      ) {
        const EQ =
          correct === DataType.Correct
            ? codegen_1.operators.EQ
            : codegen_1.operators.NEQ
        let cond
        switch (dataType) {
          case 'null':
            return (0, codegen_1._)`${data} ${EQ} null`
          case 'array':
            cond = (0, codegen_1._)`Array.isArray(${data})`
            break
          case 'object':
            cond = (0,
            codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`
            break
          case 'integer':
            cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`)
            break
          case 'number':
            cond = numCond()
            break
          default:
            return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`
        }
        return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond)
        function numCond(_cond = codegen_1.nil) {
          return (0, codegen_1.and)(
            (0, codegen_1._)`typeof ${data} == "number"`,
            _cond,
            strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil
          )
        }
      }
      exports.checkDataType = checkDataType
      function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
          return checkDataType(dataTypes[0], data, strictNums, correct)
        }
        let cond
        const types = (0, util_1.toHash)(dataTypes)
        if (types.array && types.object) {
          const notObj = (0, codegen_1._)`typeof ${data} != "object"`
          cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`
          delete types.null
          delete types.array
          delete types.object
        } else {
          cond = codegen_1.nil
        }
        if (types.number) delete types.integer
        for (const t in types)
          cond = (0, codegen_1.and)(
            cond,
            checkDataType(t, data, strictNums, correct)
          )
        return cond
      }
      exports.checkDataTypes = checkDataTypes
      const typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) =>
          typeof schema == 'string'
            ? (0, codegen_1._)`{type: ${schema}}`
            : (0, codegen_1._)`{type: ${schemaValue}}`
      }
      function reportTypeError(it) {
        const cxt = getTypeErrorContext(it)
        ;(0, errors_1.reportError)(cxt, typeError)
      }
      exports.reportTypeError = reportTypeError
      function getTypeErrorContext(it) {
        const { gen, data, schema } = it
        const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, 'type')
        return {
          gen,
          keyword: 'type',
          data,
          schema: schema.type,
          schemaCode,
          schemaValue: schemaCode,
          parentSchema: schema,
          params: {},
          it
        }
      }
      //# sourceMappingURL=dataType.js.map

      /***/
    },

    /***/ 313: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.assignDefaults = void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      function assignDefaults(it, ty) {
        const { properties, items } = it.schema
        if (ty === 'object' && properties) {
          for (const key in properties) {
            assignDefault(it, key, properties[key].default)
          }
        } else if (ty === 'array' && Array.isArray(items)) {
          items.forEach((sch, i) => assignDefault(it, i, sch.default))
        }
      }
      exports.assignDefaults = assignDefaults
      function assignDefault(it, prop, defaultValue) {
        const { gen, compositeRule, data, opts } = it
        if (defaultValue === undefined) return
        const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
          prop
        )}`
        if (compositeRule) {
          ;(0, util_1.checkStrictMode)(
            it,
            `default is ignored for: ${childData}`
          )
          return
        }
        let condition = (0, codegen_1._)`${childData} === undefined`
        if (opts.useDefaults === 'empty') {
          condition = (0,
          codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`
        }
        // `${childData} === undefined` +
        // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
        gen.if(
          condition,
          (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(
            defaultValue
          )}`
        )
      }
      //# sourceMappingURL=defaults.js.map

      /***/
    },

    /***/ 4815: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.getData =
        exports.KeywordCxt =
        exports.validateFunctionCode =
          void 0
      const boolSchema_1 = __webpack_require__(5667)
      const dataType_1 = __webpack_require__(453)
      const applicability_1 = __webpack_require__(8876)
      const dataType_2 = __webpack_require__(453)
      const defaults_1 = __webpack_require__(313)
      const keyword_1 = __webpack_require__(5005)
      const subschema_1 = __webpack_require__(3099)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const resolve_1 = __webpack_require__(2531)
      const util_1 = __webpack_require__(6776)
      const errors_1 = __webpack_require__(4181)
      // schema compilation - generates validation function, subschemaCode (below) is used for subschemas
      function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
          checkKeywords(it)
          if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it)
            return
          }
        }
        validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it))
      }
      exports.validateFunctionCode = validateFunctionCode
      function validateFunction(
        { gen, validateName, schema, schemaEnv, opts },
        body
      ) {
        if (opts.code.es5) {
          gen.func(
            validateName,
            (0,
            codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`,
            schemaEnv.$async,
            () => {
              gen.code(
                (0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`
              )
              destructureValCxtES5(gen, opts)
              gen.code(body)
            }
          )
        } else {
          gen.func(
            validateName,
            (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(
              opts
            )}`,
            schemaEnv.$async,
            () => gen.code(funcSourceUrl(schema, opts)).code(body)
          )
        }
      }
      function destructureValCxt(opts) {
        return (0, codegen_1._)`{${names_1.default.instancePath}="", ${
          names_1.default.parentData
        }, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${
          names_1.default.data
        }${
          opts.dynamicRef
            ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}`
            : codegen_1.nil
        }}={}`
      }
      function destructureValCxtES5(gen, opts) {
        gen.if(
          names_1.default.valCxt,
          () => {
            gen.var(
              names_1.default.instancePath,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`
            )
            gen.var(
              names_1.default.parentData,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`
            )
            gen.var(
              names_1.default.parentDataProperty,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`
            )
            gen.var(
              names_1.default.rootData,
              (0,
              codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`
            )
            if (opts.dynamicRef)
              gen.var(
                names_1.default.dynamicAnchors,
                (0,
                codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`
              )
          },
          () => {
            gen.var(names_1.default.instancePath, (0, codegen_1._)`""`)
            gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`)
            gen.var(
              names_1.default.parentDataProperty,
              (0, codegen_1._)`undefined`
            )
            gen.var(names_1.default.rootData, names_1.default.data)
            if (opts.dynamicRef)
              gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`)
          }
        )
      }
      function topSchemaObjCode(it) {
        const { schema, opts, gen } = it
        validateFunction(it, () => {
          if (opts.$comment && schema.$comment) commentKeyword(it)
          checkNoDefault(it)
          gen.let(names_1.default.vErrors, null)
          gen.let(names_1.default.errors, 0)
          if (opts.unevaluated) resetEvaluated(it)
          typeAndKeywords(it)
          returnResults(it)
        })
        return
      }
      function resetEvaluated(it) {
        // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
        const { gen, validateName } = it
        it.evaluated = gen.const(
          'evaluated',
          (0, codegen_1._)`${validateName}.evaluated`
        )
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () =>
          gen.assign(
            (0, codegen_1._)`${it.evaluated}.props`,
            (0, codegen_1._)`undefined`
          )
        )
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () =>
          gen.assign(
            (0, codegen_1._)`${it.evaluated}.items`,
            (0, codegen_1._)`undefined`
          )
        )
      }
      function funcSourceUrl(schema, opts) {
        const schId = typeof schema == 'object' && schema[opts.schemaId]
        return schId && (opts.code.source || opts.code.process)
          ? (0, codegen_1._)`/*# sourceURL=${schId} */`
          : codegen_1.nil
      }
      // schema compilation - this function is used recursively to generate code for sub-schemas
      function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
          checkKeywords(it)
          if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid)
            return
          }
        }
        ;(0, boolSchema_1.boolOrEmptySchema)(it, valid)
      }
      function schemaCxtHasRules({ schema, self }) {
        if (typeof schema == 'boolean') return !schema
        for (const key in schema) if (self.RULES.all[key]) return true
        return false
      }
      function isSchemaObj(it) {
        return typeof it.schema != 'boolean'
      }
      function subSchemaObjCode(it, valid) {
        const { schema, gen, opts } = it
        if (opts.$comment && schema.$comment) commentKeyword(it)
        updateContext(it)
        checkAsyncSchema(it)
        const errsCount = gen.const('_errs', names_1.default.errors)
        typeAndKeywords(it, errsCount)
        // TODO var
        gen.var(
          valid,
          (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`
        )
      }
      function checkKeywords(it) {
        ;(0, util_1.checkUnknownRules)(it)
        checkRefsAndKeywords(it)
      }
      function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)
        const types = (0, dataType_1.getSchemaTypes)(it.schema)
        const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types)
        schemaKeywords(it, types, !checkedTypes, errsCount)
      }
      function checkRefsAndKeywords(it) {
        const { schema, errSchemaPath, opts, self } = it
        if (
          schema.$ref &&
          opts.ignoreKeywordsWithRef &&
          (0, util_1.schemaHasRulesButRef)(schema, self.RULES)
        ) {
          self.logger.warn(
            `$ref: keywords ignored in schema at path "${errSchemaPath}"`
          )
        }
      }
      function checkNoDefault(it) {
        const { schema, opts } = it
        if (
          schema.default !== undefined &&
          opts.useDefaults &&
          opts.strictSchema
        ) {
          ;(0, util_1.checkStrictMode)(
            it,
            'default is ignored in the schema root'
          )
        }
      }
      function updateContext(it) {
        const schId = it.schema[it.opts.schemaId]
        if (schId)
          it.baseId = (0, resolve_1.resolveUrl)(
            it.opts.uriResolver,
            it.baseId,
            schId
          )
      }
      function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
          throw new Error('async schema in sync schema')
      }
      function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
        const msg = schema.$comment
        if (opts.$comment === true) {
          gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`)
        } else if (typeof opts.$comment == 'function') {
          const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`
          const rootName = gen.scopeValue('root', { ref: schemaEnv.root })
          gen.code(
            (0,
            codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`
          )
        }
      }
      function returnResults(it) {
        const { gen, schemaEnv, validateName, ValidationError, opts } = it
        if (schemaEnv.$async) {
          // TODO assign unevaluated
          gen.if(
            (0, codegen_1._)`${names_1.default.errors} === 0`,
            () => gen.return(names_1.default.data),
            () =>
              gen.throw(
                (0,
                codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`
              )
          )
        } else {
          gen.assign(
            (0, codegen_1._)`${validateName}.errors`,
            names_1.default.vErrors
          )
          if (opts.unevaluated) assignEvaluated(it)
          gen.return((0, codegen_1._)`${names_1.default.errors} === 0`)
        }
      }
      function assignEvaluated({ gen, evaluated, props, items }) {
        if (props instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.props`, props)
        if (items instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.items`, items)
      }
      function schemaKeywords(it, types, typeErrors, errsCount) {
        const { gen, schema, data, allErrors, opts, self } = it
        const { RULES } = self
        if (
          schema.$ref &&
          (opts.ignoreKeywordsWithRef ||
            !(0, util_1.schemaHasRulesButRef)(schema, RULES))
        ) {
          gen.block(() => keywordCode(it, '$ref', RULES.all.$ref.definition)) // TODO typecast
          return
        }
        if (!opts.jtd) checkStrictTypes(it, types)
        gen.block(() => {
          for (const group of RULES.rules) groupKeywords(group)
          groupKeywords(RULES.post)
        })
        function groupKeywords(group) {
          if (!(0, applicability_1.shouldUseGroup)(schema, group)) return
          if (group.type) {
            gen.if(
              (0, dataType_2.checkDataType)(
                group.type,
                data,
                opts.strictNumbers
              )
            )
            iterateKeywords(it, group)
            if (types.length === 1 && types[0] === group.type && typeErrors) {
              gen.else()
              ;(0, dataType_2.reportTypeError)(it)
            }
            gen.endIf()
          } else {
            iterateKeywords(it, group)
          }
          // TODO make it "ok" call?
          if (!allErrors)
            gen.if(
              (0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`
            )
        }
      }
      function iterateKeywords(it, group) {
        const {
          gen,
          schema,
          opts: { useDefaults }
        } = it
        if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type)
        gen.block(() => {
          for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
              keywordCode(it, rule.keyword, rule.definition, group.type)
            }
          }
        })
      }
      function checkStrictTypes(it, types) {
        if (it.schemaEnv.meta || !it.opts.strictTypes) return
        checkContextTypes(it, types)
        if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)
        checkKeywordTypes(it, it.dataTypes)
      }
      function checkContextTypes(it, types) {
        if (!types.length) return
        if (!it.dataTypes.length) {
          it.dataTypes = types
          return
        }
        types.forEach((t) => {
          if (!includesType(it.dataTypes, t)) {
            strictTypesError(
              it,
              `type "${t}" not allowed by context "${it.dataTypes.join(',')}"`
            )
          }
        })
        narrowSchemaTypes(it, types)
      }
      function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes('null'))) {
          strictTypesError(
            it,
            'use allowUnionTypes to allow union type keyword'
          )
        }
      }
      function checkKeywordTypes(it, ts) {
        const rules = it.self.RULES.all
        for (const keyword in rules) {
          const rule = rules[keyword]
          if (
            typeof rule == 'object' &&
            (0, applicability_1.shouldUseRule)(it.schema, rule)
          ) {
            const { type } = rule.definition
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
              strictTypesError(
                it,
                `missing type "${type.join(',')}" for keyword "${keyword}"`
              )
            }
          }
        }
      }
      function hasApplicableType(schTs, kwdT) {
        return (
          schTs.includes(kwdT) ||
          (kwdT === 'number' && schTs.includes('integer'))
        )
      }
      function includesType(ts, t) {
        return ts.includes(t) || (t === 'integer' && ts.includes('number'))
      }
      function narrowSchemaTypes(it, withTypes) {
        const ts = []
        for (const t of it.dataTypes) {
          if (includesType(withTypes, t)) ts.push(t)
          else if (withTypes.includes('integer') && t === 'number')
            ts.push('integer')
        }
        it.dataTypes = ts
      }
      function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath
        msg += ` at "${schemaPath}" (strictTypes)`
        ;(0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes)
      }
      class KeywordCxt {
        constructor(it, def, keyword) {
          ;(0, keyword_1.validateKeywordUsage)(it, def, keyword)
          this.gen = it.gen
          this.allErrors = it.allErrors
          this.keyword = keyword
          this.data = it.data
          this.schema = it.schema[keyword]
          this.$data =
            def.$data && it.opts.$data && this.schema && this.schema.$data
          this.schemaValue = (0, util_1.schemaRefOrVal)(
            it,
            this.schema,
            keyword,
            this.$data
          )
          this.schemaType = def.schemaType
          this.parentSchema = it.schema
          this.params = {}
          this.it = it
          this.def = def
          if (this.$data) {
            this.schemaCode = it.gen.const('vSchema', getData(this.$data, it))
          } else {
            this.schemaCode = this.schemaValue
            if (
              !(0, keyword_1.validSchemaType)(
                this.schema,
                def.schemaType,
                def.allowUndefined
              )
            ) {
              throw new Error(
                `${keyword} value must be ${JSON.stringify(def.schemaType)}`
              )
            }
          }
          if ('code' in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const('_errs', names_1.default.errors)
          }
        }
        result(condition, successAction, failAction) {
          this.failResult(
            (0, codegen_1.not)(condition),
            successAction,
            failAction
          )
        }
        failResult(condition, successAction, failAction) {
          this.gen.if(condition)
          if (failAction) failAction()
          else this.error()
          if (successAction) {
            this.gen.else()
            successAction()
            if (this.allErrors) this.gen.endIf()
          } else {
            if (this.allErrors) this.gen.endIf()
            else this.gen.else()
          }
        }
        pass(condition, failAction) {
          this.failResult((0, codegen_1.not)(condition), undefined, failAction)
        }
        fail(condition) {
          if (condition === undefined) {
            this.error()
            if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize
            return
          }
          this.gen.if(condition)
          this.error()
          if (this.allErrors) this.gen.endIf()
          else this.gen.else()
        }
        fail$data(condition) {
          if (!this.$data) return this.fail(condition)
          const { schemaCode } = this
          this.fail(
            (0, codegen_1._)`${schemaCode} !== undefined && (${(0,
            codegen_1.or)(this.invalid$data(), condition)})`
          )
        }
        error(append, errorParams, errorPaths) {
          if (errorParams) {
            this.setParams(errorParams)
            this._error(append, errorPaths)
            this.setParams({})
            return
          }
          this._error(append, errorPaths)
        }
        _error(append, errorPaths) {
          ;(append ? errors_1.reportExtraError : errors_1.reportError)(
            this,
            this.def.error,
            errorPaths
          )
        }
        $dataError() {
          ;(0, errors_1.reportError)(
            this,
            this.def.$dataError || errors_1.keyword$DataError
          )
        }
        reset() {
          if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition')
          ;(0, errors_1.resetErrorsCount)(this.gen, this.errsCount)
        }
        ok(cond) {
          if (!this.allErrors) this.gen.if(cond)
        }
        setParams(obj, assign) {
          if (assign) Object.assign(this.params, obj)
          else this.params = obj
        }
        block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
          this.gen.block(() => {
            this.check$data(valid, $dataValid)
            codeBlock()
          })
        }
        check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
          if (!this.$data) return
          const { gen, schemaCode, schemaType, def } = this
          gen.if(
            (0, codegen_1.or)(
              (0, codegen_1._)`${schemaCode} === undefined`,
              $dataValid
            )
          )
          if (valid !== codegen_1.nil) gen.assign(valid, true)
          if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data())
            this.$dataError()
            if (valid !== codegen_1.nil) gen.assign(valid, false)
          }
          gen.else()
        }
        invalid$data() {
          const { gen, schemaCode, schemaType, def, it } = this
          return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema())
          function wrong$DataType() {
            if (schemaType.length) {
              /* istanbul ignore if */
              if (!(schemaCode instanceof codegen_1.Name))
                throw new Error('ajv implementation error')
              const st = Array.isArray(schemaType) ? schemaType : [schemaType]
              return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(
                st,
                schemaCode,
                it.opts.strictNumbers,
                dataType_2.DataType.Wrong
              )}`
            }
            return codegen_1.nil
          }
          function invalid$DataSchema() {
            if (def.validateSchema) {
              const validateSchemaRef = gen.scopeValue('validate$data', {
                ref: def.validateSchema
              }) // TODO value.code for standalone
              return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`
            }
            return codegen_1.nil
          }
        }
        subschema(appl, valid) {
          const subschema = (0, subschema_1.getSubschema)(this.it, appl)
          ;(0, subschema_1.extendSubschemaData)(subschema, this.it, appl)
          ;(0, subschema_1.extendSubschemaMode)(subschema, appl)
          const nextContext = {
            ...this.it,
            ...subschema,
            items: undefined,
            props: undefined
          }
          subschemaCode(nextContext, valid)
          return nextContext
        }
        mergeEvaluated(schemaCxt, toName) {
          const { it, gen } = this
          if (!it.opts.unevaluated) return
          if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(
              gen,
              schemaCxt.props,
              it.props,
              toName
            )
          }
          if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(
              gen,
              schemaCxt.items,
              it.items,
              toName
            )
          }
        }
        mergeValidEvaluated(schemaCxt, valid) {
          const { it, gen } = this
          if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name))
            return true
          }
        }
      }
      exports.KeywordCxt = KeywordCxt
      function keywordCode(it, keyword, def, ruleType) {
        const cxt = new KeywordCxt(it, def, keyword)
        if ('code' in def) {
          def.code(cxt, ruleType)
        } else if (cxt.$data && def.validate) {
          ;(0, keyword_1.funcKeywordCode)(cxt, def)
        } else if ('macro' in def) {
          ;(0, keyword_1.macroKeywordCode)(cxt, def)
        } else if (def.compile || def.validate) {
          ;(0, keyword_1.funcKeywordCode)(cxt, def)
        }
      }
      const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/
      const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/
      function getData($data, { dataLevel, dataNames, dataPathArr }) {
        let jsonPointer
        let data
        if ($data === '') return names_1.default.rootData
        if ($data[0] === '/') {
          if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`)
          jsonPointer = $data
          data = names_1.default.rootData
        } else {
          const matches = RELATIVE_JSON_POINTER.exec($data)
          if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)
          const up = +matches[1]
          jsonPointer = matches[2]
          if (jsonPointer === '#') {
            if (up >= dataLevel) throw new Error(errorMsg('property/index', up))
            return dataPathArr[dataLevel - up]
          }
          if (up > dataLevel) throw new Error(errorMsg('data', up))
          data = dataNames[dataLevel - up]
          if (!jsonPointer) return data
        }
        let expr = data
        const segments = jsonPointer.split('/')
        for (const segment of segments) {
          if (segment) {
            data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
              (0, util_1.unescapeJsonPointer)(segment)
            )}`
            expr = (0, codegen_1._)`${expr} && ${data}`
          }
        }
        return expr
        function errorMsg(pointerType, up) {
          return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`
        }
      }
      exports.getData = getData
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 5005: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateKeywordUsage =
        exports.validSchemaType =
        exports.funcKeywordCode =
        exports.macroKeywordCode =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const code_1 = __webpack_require__(412)
      const errors_1 = __webpack_require__(4181)
      function macroKeywordCode(cxt, def) {
        const { gen, keyword, schema, parentSchema, it } = cxt
        const macroSchema = def.macro.call(it.self, schema, parentSchema, it)
        const schemaRef = useKeyword(gen, keyword, macroSchema)
        if (it.opts.validateSchema !== false)
          it.self.validateSchema(macroSchema, true)
        const valid = gen.name('valid')
        cxt.subschema(
          {
            schema: macroSchema,
            schemaPath: codegen_1.nil,
            errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            topSchemaRef: schemaRef,
            compositeRule: true
          },
          valid
        )
        cxt.pass(valid, () => cxt.error(true))
      }
      exports.macroKeywordCode = macroKeywordCode
      function funcKeywordCode(cxt, def) {
        var _a
        const { gen, keyword, schema, parentSchema, $data, it } = cxt
        checkAsyncKeyword(it, def)
        const validate =
          !$data && def.compile
            ? def.compile.call(it.self, schema, parentSchema, it)
            : def.validate
        const validateRef = useKeyword(gen, keyword, validate)
        const valid = gen.let('valid')
        cxt.block$data(valid, validateKeyword)
        cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid)
        function validateKeyword() {
          if (def.errors === false) {
            assignValid()
            if (def.modifying) modifyData(cxt)
            reportErrs(() => cxt.error())
          } else {
            const ruleErrs = def.async ? validateAsync() : validateSync()
            if (def.modifying) modifyData(cxt)
            reportErrs(() => addErrs(cxt, ruleErrs))
          }
        }
        function validateAsync() {
          const ruleErrs = gen.let('ruleErrs', null)
          gen.try(
            () => assignValid((0, codegen_1._)`await `),
            (e) =>
              gen.assign(valid, false).if(
                (0, codegen_1._)`${e} instanceof ${it.ValidationError}`,
                () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`),
                () => gen.throw(e)
              )
          )
          return ruleErrs
        }
        function validateSync() {
          const validateErrs = (0, codegen_1._)`${validateRef}.errors`
          gen.assign(validateErrs, null)
          assignValid(codegen_1.nil)
          return validateErrs
        }
        function assignValid(
          _await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil
        ) {
          const passCxt = it.opts.passContext
            ? names_1.default.this
            : names_1.default.self
          const passSchema = !(
            ('compile' in def && !$data) ||
            def.schema === false
          )
          gen.assign(
            valid,
            (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(
              cxt,
              validateRef,
              passCxt,
              passSchema
            )}`,
            def.modifying
          )
        }
        function reportErrs(errors) {
          var _a
          gen.if(
            (0, codegen_1.not)(
              (_a = def.valid) !== null && _a !== void 0 ? _a : valid
            ),
            errors
          )
        }
      }
      exports.funcKeywordCode = funcKeywordCode
      function modifyData(cxt) {
        const { gen, data, it } = cxt
        gen.if(it.parentData, () =>
          gen.assign(
            data,
            (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`
          )
        )
      }
      function addErrs(cxt, errs) {
        const { gen } = cxt
        gen.if(
          (0, codegen_1._)`Array.isArray(${errs})`,
          () => {
            gen
              .assign(
                names_1.default.vErrors,
                (0,
                codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
              )
              .assign(
                names_1.default.errors,
                (0, codegen_1._)`${names_1.default.vErrors}.length`
              )
            ;(0, errors_1.extendErrors)(cxt)
          },
          () => cxt.error()
        )
      }
      function checkAsyncKeyword({ schemaEnv }, def) {
        if (def.async && !schemaEnv.$async)
          throw new Error('async keyword in sync schema')
      }
      function useKeyword(gen, keyword, result) {
        if (result === undefined)
          throw new Error(`keyword "${keyword}" failed to compile`)
        return gen.scopeValue(
          'keyword',
          typeof result == 'function'
            ? { ref: result }
            : { ref: result, code: (0, codegen_1.stringify)(result) }
        )
      }
      function validSchemaType(schema, schemaType, allowUndefined = false) {
        // TODO add tests
        return (
          !schemaType.length ||
          schemaType.some((st) =>
            st === 'array'
              ? Array.isArray(schema)
              : st === 'object'
                ? schema && typeof schema == 'object' && !Array.isArray(schema)
                : typeof schema == st ||
                  (allowUndefined && typeof schema == 'undefined')
          )
        )
      }
      exports.validSchemaType = validSchemaType
      function validateKeywordUsage(
        { schema, opts, self, errSchemaPath },
        def,
        keyword
      ) {
        /* istanbul ignore if */
        if (
          Array.isArray(def.keyword)
            ? !def.keyword.includes(keyword)
            : def.keyword !== keyword
        ) {
          throw new Error('ajv implementation error')
        }
        const deps = def.dependencies
        if (
          deps === null || deps === void 0
            ? void 0
            : deps.some(
                (kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)
              )
        ) {
          throw new Error(
            `parent schema must have dependencies of ${keyword}: ${deps.join(
              ','
            )}`
          )
        }
        if (def.validateSchema) {
          const valid = def.validateSchema(schema[keyword])
          if (!valid) {
            const msg =
              `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
              self.errorsText(def.validateSchema.errors)
            if (opts.validateSchema === 'log') self.logger.error(msg)
            else throw new Error(msg)
          }
        }
      }
      exports.validateKeywordUsage = validateKeywordUsage
      //# sourceMappingURL=keyword.js.map

      /***/
    },

    /***/ 3099: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.extendSubschemaMode =
        exports.extendSubschemaData =
        exports.getSubschema =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      function getSubschema(
        it,
        { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }
      ) {
        if (keyword !== undefined && schema !== undefined) {
          throw new Error(
            'both "keyword" and "schema" passed, only one allowed'
          )
        }
        if (keyword !== undefined) {
          const sch = it.schema[keyword]
          return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
                codegen_1.getProperty)(keyword)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`
              }
            : {
                schema: sch[schemaProp],
                schemaPath: (0, codegen_1._)`${it.schemaPath}${(0,
                codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(
                  schemaProp
                )}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0,
                util_1.escapeFragment)(schemaProp)}`
              }
        }
        if (schema !== undefined) {
          if (
            schemaPath === undefined ||
            errSchemaPath === undefined ||
            topSchemaRef === undefined
          ) {
            throw new Error(
              '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
            )
          }
          return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath
          }
        }
        throw new Error('either "keyword" or "schema" must be passed')
      }
      exports.getSubschema = getSubschema
      function extendSubschemaData(
        subschema,
        it,
        { dataProp, dataPropType: dpType, data, dataTypes, propertyName }
      ) {
        if (data !== undefined && dataProp !== undefined) {
          throw new Error('both "data" and "dataProp" passed, only one allowed')
        }
        const { gen } = it
        if (dataProp !== undefined) {
          const { errorPath, dataPathArr, opts } = it
          const nextData = gen.let(
            'data',
            (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`,
            true
          )
          dataContextProps(nextData)
          subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0,
          util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`
          subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`
          subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]
        }
        if (data !== undefined) {
          const nextData =
            data instanceof codegen_1.Name ? data : gen.let('data', data, true) // replaceable if used once?
          dataContextProps(nextData)
          if (propertyName !== undefined) subschema.propertyName = propertyName
          // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
        }
        if (dataTypes) subschema.dataTypes = dataTypes
        function dataContextProps(_nextData) {
          subschema.data = _nextData
          subschema.dataLevel = it.dataLevel + 1
          subschema.dataTypes = []
          it.definedProperties = new Set()
          subschema.parentData = it.data
          subschema.dataNames = [...it.dataNames, _nextData]
        }
      }
      exports.extendSubschemaData = extendSubschemaData
      function extendSubschemaMode(
        subschema,
        {
          jtdDiscriminator,
          jtdMetadata,
          compositeRule,
          createErrors,
          allErrors
        }
      ) {
        if (compositeRule !== undefined) subschema.compositeRule = compositeRule
        if (createErrors !== undefined) subschema.createErrors = createErrors
        if (allErrors !== undefined) subschema.allErrors = allErrors
        subschema.jtdDiscriminator = jtdDiscriminator // not inherited
        subschema.jtdMetadata = jtdMetadata // not inherited
      }
      exports.extendSubschemaMode = extendSubschemaMode
      //# sourceMappingURL=subschema.js.map

      /***/
    },

    /***/ 7159: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.CodeGen =
        exports.Name =
        exports.nil =
        exports.stringify =
        exports.str =
        exports._ =
        exports.KeywordCxt =
          void 0
      var validate_1 = __webpack_require__(4815)
      Object.defineProperty(exports, 'KeywordCxt', {
        enumerable: true,
        get: function () {
          return validate_1.KeywordCxt
        }
      })
      var codegen_1 = __webpack_require__(3487)
      Object.defineProperty(exports, '_', {
        enumerable: true,
        get: function () {
          return codegen_1._
        }
      })
      Object.defineProperty(exports, 'str', {
        enumerable: true,
        get: function () {
          return codegen_1.str
        }
      })
      Object.defineProperty(exports, 'stringify', {
        enumerable: true,
        get: function () {
          return codegen_1.stringify
        }
      })
      Object.defineProperty(exports, 'nil', {
        enumerable: true,
        get: function () {
          return codegen_1.nil
        }
      })
      Object.defineProperty(exports, 'Name', {
        enumerable: true,
        get: function () {
          return codegen_1.Name
        }
      })
      Object.defineProperty(exports, 'CodeGen', {
        enumerable: true,
        get: function () {
          return codegen_1.CodeGen
        }
      })
      const validation_error_1 = __webpack_require__(7426)
      const ref_error_1 = __webpack_require__(6646)
      const rules_1 = __webpack_require__(3141)
      const compile_1 = __webpack_require__(5173)
      const codegen_2 = __webpack_require__(3487)
      const resolve_1 = __webpack_require__(2531)
      const dataType_1 = __webpack_require__(453)
      const util_1 = __webpack_require__(6776)
      const $dataRefSchema = __webpack_require__(4775)
      const uri_1 = __webpack_require__(3589)
      const defaultRegExp = (str, flags) => new RegExp(str, flags)
      defaultRegExp.code = 'new RegExp'
      const META_IGNORE_OPTIONS = [
        'removeAdditional',
        'useDefaults',
        'coerceTypes'
      ]
      const EXT_SCOPE_NAMES = new Set([
        'validate',
        'serialize',
        'parse',
        'wrapper',
        'root',
        'schema',
        'keyword',
        'pattern',
        'formats',
        'validate$data',
        'func',
        'obj',
        'Error'
      ])
      const removedOptions = {
        errorDataPath: '',
        format: '`validateFormats: false` can be used instead.',
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: 'Deprecated jsPropertySyntax can be used instead.',
        extendRefs: 'Deprecated ignoreKeywordsWithRef can be used instead.',
        missingRefs:
          'Pass empty schema with $id that should be ignored to ajv.addSchema.',
        processCode:
          'Use option `code: {process: (code, schemaEnv: object) => string}`',
        sourceCode: 'Use option `code: {source: true}`',
        strictDefaults: 'It is default now, see option `strict`.',
        strictKeywords: 'It is default now, see option `strict`.',
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats:
          'Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).',
        cache: 'Map is used as cache, schema object as key.',
        serialize: 'Map is used as cache, schema object as key.',
        ajvErrors: 'It is default now.'
      }
      const deprecatedOptions = {
        ignoreKeywordsWithRef: '',
        jsPropertySyntax: '',
        unicode:
          '"minLength"/"maxLength" account for unicode characters by default.'
      }
      const MAX_EXPRESSION = 200
      // eslint-disable-next-line complexity
      function requiredOptions(o) {
        var _a,
          _b,
          _c,
          _d,
          _e,
          _f,
          _g,
          _h,
          _j,
          _k,
          _l,
          _m,
          _o,
          _p,
          _q,
          _r,
          _s,
          _t,
          _u,
          _v,
          _w,
          _x,
          _y,
          _z,
          _0
        const s = o.strict
        const _optz =
          (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize
        const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0
        const regExp =
          (_c =
            (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !==
            null && _c !== void 0
            ? _c
            : defaultRegExp
        const uriResolver =
          (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default
        return {
          strictSchema:
            (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !==
              null && _f !== void 0
              ? _f
              : true,
          strictNumbers:
            (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !==
              null && _h !== void 0
              ? _h
              : true,
          strictTypes:
            (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !==
              null && _k !== void 0
              ? _k
              : 'log',
          strictTuples:
            (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !==
              null && _m !== void 0
              ? _m
              : 'log',
          strictRequired:
            (_p =
              (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !==
              null && _p !== void 0
              ? _p
              : false,
          code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
          loopRequired:
            (_q = o.loopRequired) !== null && _q !== void 0
              ? _q
              : MAX_EXPRESSION,
          loopEnum:
            (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : '$id',
          addUsedSchema:
            (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema:
            (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats:
            (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp:
            (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver: uriResolver
        }
      }
      class Ajv {
        constructor(opts = {}) {
          this.schemas = {}
          this.refs = {}
          this.formats = {}
          this._compilations = new Set()
          this._loading = {}
          this._cache = new Map()
          opts = this.opts = { ...opts, ...requiredOptions(opts) }
          const { es5, lines } = this.opts.code
          this.scope = new codegen_2.ValueScope({
            scope: {},
            prefixes: EXT_SCOPE_NAMES,
            es5,
            lines
          })
          this.logger = getLogger(opts.logger)
          const formatOpt = opts.validateFormats
          opts.validateFormats = false
          this.RULES = (0, rules_1.getRules)()
          checkOptions.call(this, removedOptions, opts, 'NOT SUPPORTED')
          checkOptions.call(this, deprecatedOptions, opts, 'DEPRECATED', 'warn')
          this._metaOpts = getMetaSchemaOptions.call(this)
          if (opts.formats) addInitialFormats.call(this)
          this._addVocabularies()
          this._addDefaultMetaSchema()
          if (opts.keywords) addInitialKeywords.call(this, opts.keywords)
          if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta)
          addInitialSchemas.call(this)
          opts.validateFormats = formatOpt
        }
        _addVocabularies() {
          this.addKeyword('$async')
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts
          let _dataRefSchema = $dataRefSchema
          if (schemaId === 'id') {
            _dataRefSchema = { ...$dataRefSchema }
            _dataRefSchema.id = _dataRefSchema.$id
            delete _dataRefSchema.$id
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts
          return (this.opts.defaultMeta =
            typeof meta == 'object' ? meta[schemaId] || meta : undefined)
        }
        validate(
          schemaKeyRef, // key, ref or schema object
          data // to be validated
        ) {
          let v
          if (typeof schemaKeyRef == 'string') {
            v = this.getSchema(schemaKeyRef)
            if (!v)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`)
          } else {
            v = this.compile(schemaKeyRef)
          }
          const valid = v(data)
          if (!('$async' in v)) this.errors = v.errors
          return valid
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta)
          return sch.validate || this._compileSchemaEnv(sch)
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != 'function') {
            throw new Error('options.loadSchema should be a function')
          }
          const { loadSchema } = this.opts
          return runCompileAsync.call(this, schema, meta)
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema)
            const sch = this._addSchema(_schema, _meta)
            return sch.validate || _compileAsync.call(this, sch)
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true)
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch)
            } catch (e) {
              if (!(e instanceof ref_error_1.default)) throw e
              checkLoaded.call(this, e)
              await loadMissingSchema.call(this, e.missingSchema)
              return _compileAsync.call(this, sch)
            }
          }
          function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
              throw new Error(
                `AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`
              )
            }
          }
          async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref)
            if (!this.refs[ref])
              await loadMetaSchema.call(this, _schema.$schema)
            if (!this.refs[ref]) this.addSchema(_schema, ref, meta)
          }
          async function _loadSchema(ref) {
            const p = this._loading[ref]
            if (p) return p
            try {
              return await (this._loading[ref] = loadSchema(ref))
            } finally {
              delete this._loading[ref]
            }
          }
        }
        // Adds schema to the instance
        addSchema(
          schema, // If array is passed, `key` will be ignored
          key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
          _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
          _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
        ) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, undefined, _meta, _validateSchema)
            return this
          }
          let id
          if (typeof schema === 'object') {
            const { schemaId } = this.opts
            id = schema[schemaId]
            if (id !== undefined && typeof id != 'string') {
              throw new Error(`schema ${schemaId} must be string`)
            }
          }
          key = (0, resolve_1.normalizeId)(key || id)
          this._checkUnique(key)
          this.schemas[key] = this._addSchema(
            schema,
            _meta,
            key,
            _validateSchema,
            true
          )
          return this
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(
          schema,
          key, // schema key
          _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
        ) {
          this.addSchema(schema, key, true, _validateSchema)
          return this
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == 'boolean') return true
          let $schema
          $schema = schema.$schema
          if ($schema !== undefined && typeof $schema != 'string') {
            throw new Error('$schema must be a string')
          }
          $schema = $schema || this.opts.defaultMeta || this.defaultMeta()
          if (!$schema) {
            this.logger.warn('meta-schema not available')
            this.errors = null
            return true
          }
          const valid = this.validate($schema, schema)
          if (!valid && throwOrLogError) {
            const message = 'schema is invalid: ' + this.errorsText()
            if (this.opts.validateSchema === 'log') this.logger.error(message)
            else throw new Error(message)
          }
          return valid
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch
          while (typeof (sch = getSchEnv.call(this, keyRef)) == 'string')
            keyRef = sch
          if (sch === undefined) {
            const { schemaId } = this.opts
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId })
            sch = compile_1.resolveSchema.call(this, root, keyRef)
            if (!sch) return
            this.refs[keyRef] = sch
          }
          return sch.validate || this._compileSchemaEnv(sch)
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef)
            this._removeAllSchemas(this.refs, schemaKeyRef)
            return this
          }
          switch (typeof schemaKeyRef) {
            case 'undefined':
              this._removeAllSchemas(this.schemas)
              this._removeAllSchemas(this.refs)
              this._cache.clear()
              return this
            case 'string': {
              const sch = getSchEnv.call(this, schemaKeyRef)
              if (typeof sch == 'object') this._cache.delete(sch.schema)
              delete this.schemas[schemaKeyRef]
              delete this.refs[schemaKeyRef]
              return this
            }
            case 'object': {
              const cacheKey = schemaKeyRef
              this._cache.delete(cacheKey)
              let id = schemaKeyRef[this.opts.schemaId]
              if (id) {
                id = (0, resolve_1.normalizeId)(id)
                delete this.schemas[id]
                delete this.refs[id]
              }
              return this
            }
            default:
              throw new Error('ajv.removeSchema: invalid parameter')
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions) {
          for (const def of definitions) this.addKeyword(def)
          return this
        }
        addKeyword(
          kwdOrDef,
          def // deprecated
        ) {
          let keyword
          if (typeof kwdOrDef == 'string') {
            keyword = kwdOrDef
            if (typeof def == 'object') {
              this.logger.warn(
                'these parameters are deprecated, see docs for addKeyword'
              )
              def.keyword = keyword
            }
          } else if (typeof kwdOrDef == 'object' && def === undefined) {
            def = kwdOrDef
            keyword = def.keyword
            if (Array.isArray(keyword) && !keyword.length) {
              throw new Error(
                'addKeywords: keyword must be string or non-empty array'
              )
            }
          } else {
            throw new Error('invalid addKeywords parameters')
          }
          checkKeyword.call(this, keyword, def)
          if (!def) {
            ;(0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd))
            return this
          }
          keywordMetaschema.call(this, def)
          const definition = {
            ...def,
            type: (0, dataType_1.getJSONTypes)(def.type),
            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
          }
          ;(0, util_1.eachItem)(
            keyword,
            definition.type.length === 0
              ? (k) => addRule.call(this, k, definition)
              : (k) =>
                  definition.type.forEach((t) =>
                    addRule.call(this, k, definition, t)
                  )
          )
          return this
        }
        getKeyword(keyword) {
          const rule = this.RULES.all[keyword]
          return typeof rule == 'object' ? rule.definition : !!rule
        }
        // Remove keyword
        removeKeyword(keyword) {
          // TODO return type should be Ajv
          const { RULES } = this
          delete RULES.keywords[keyword]
          delete RULES.all[keyword]
          for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword)
            if (i >= 0) group.rules.splice(i, 1)
          }
          return this
        }
        // Add format
        addFormat(name, format) {
          if (typeof format == 'string') format = new RegExp(format)
          this.formats[name] = format
          return this
        }
        errorsText(
          errors = this.errors, // optional array of validation errors
          { separator = ', ', dataVar = 'data' } = {} // optional options with properties `separator` and `dataVar`
        ) {
          if (!errors || errors.length === 0) return 'No errors'
          return errors
            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
            .reduce((text, msg) => text + separator + msg)
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
          const rules = this.RULES.all
          metaSchema = JSON.parse(JSON.stringify(metaSchema))
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split('/').slice(1) // first segment is an empty string
            let keywords = metaSchema
            for (const seg of segments) keywords = keywords[seg]
            for (const key in rules) {
              const rule = rules[key]
              if (typeof rule != 'object') continue
              const { $data } = rule.definition
              const schema = keywords[key]
              if ($data && schema) keywords[key] = schemaOrData(schema)
            }
          }
          return metaSchema
        }
        _removeAllSchemas(schemas, regex) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef]
            if (!regex || regex.test(keyRef)) {
              if (typeof sch == 'string') {
                delete schemas[keyRef]
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema)
                delete schemas[keyRef]
              }
            }
          }
        }
        _addSchema(
          schema,
          meta,
          baseId,
          validateSchema = this.opts.validateSchema,
          addSchema = this.opts.addUsedSchema
        ) {
          let id
          const { schemaId } = this.opts
          if (typeof schema == 'object') {
            id = schema[schemaId]
          } else {
            if (this.opts.jtd) throw new Error('schema must be object')
            else if (typeof schema != 'boolean')
              throw new Error('schema must be object or boolean')
          }
          let sch = this._cache.get(schema)
          if (sch !== undefined) return sch
          baseId = (0, resolve_1.normalizeId)(id || baseId)
          const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId)
          sch = new compile_1.SchemaEnv({
            schema,
            schemaId,
            meta,
            baseId,
            localRefs
          })
          this._cache.set(sch.schema, sch)
          if (addSchema && !baseId.startsWith('#')) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (baseId) this._checkUnique(baseId)
            this.refs[baseId] = sch
          }
          if (validateSchema) this.validateSchema(schema, true)
          return sch
        }
        _checkUnique(id) {
          if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`)
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta) this._compileMetaSchema(sch)
          else compile_1.compileSchema.call(this, sch)
          /* istanbul ignore if */
          if (!sch.validate) throw new Error('ajv implementation error')
          return sch.validate
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts
          this.opts = this._metaOpts
          try {
            compile_1.compileSchema.call(this, sch)
          } finally {
            this.opts = currentOpts
          }
        }
      }
      exports['default'] = Ajv
      Ajv.ValidationError = validation_error_1.default
      Ajv.MissingRefError = ref_error_1.default
      function checkOptions(checkOpts, options, msg, log = 'error') {
        for (const key in checkOpts) {
          const opt = key
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_1.normalizeId)(keyRef) // TODO tests fail without this line
        return this.schemas[keyRef] || this.refs[keyRef]
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas
        if (!optsSchemas) return
        if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)
        else
          for (const key in optsSchemas) this.addSchema(optsSchemas[key], key)
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format = this.opts.formats[name]
          if (format) this.addFormat(name, format)
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs)
          return
        }
        this.logger.warn('keywords option as map is deprecated, pass array')
        for (const keyword in defs) {
          const def = defs[keyword]
          if (!def.keyword) def.keyword = keyword
          this.addKeyword(def)
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts }
        for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]
        return metaOpts
      }
      const noLogs = { log() {}, warn() {}, error() {} }
      function getLogger(logger) {
        if (logger === false) return noLogs
        if (logger === undefined) return console
        if (logger.log && logger.warn && logger.error) return logger
        throw new Error('logger must implement log, warn and error methods')
      }
      const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i
      function checkKeyword(keyword, def) {
        const { RULES } = this
        ;(0, util_1.eachItem)(keyword, (kwd) => {
          if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`)
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`)
        })
        if (!def) return
        if (def.$data && !('code' in def || 'validate' in def)) {
          throw new Error(
            '$data keyword must have "code" or "validate" function'
          )
        }
      }
      function addRule(keyword, definition, dataType) {
        var _a
        const post =
          definition === null || definition === void 0
            ? void 0
            : definition.post
        if (dataType && post)
          throw new Error('keyword with "post" flag cannot have "type"')
        const { RULES } = this
        let ruleGroup = post
          ? RULES.post
          : RULES.rules.find(({ type: t }) => t === dataType)
        if (!ruleGroup) {
          ruleGroup = { type: dataType, rules: [] }
          RULES.rules.push(ruleGroup)
        }
        RULES.keywords[keyword] = true
        if (!definition) return
        const rule = {
          keyword,
          definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
          }
        }
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before)
        else ruleGroup.rules.push(rule)
        RULES.all[keyword] = rule
        ;(_a = definition.implements) === null || _a === void 0
          ? void 0
          : _a.forEach((kwd) => this.addKeyword(kwd))
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)
        if (i >= 0) {
          ruleGroup.rules.splice(i, 0, rule)
        } else {
          ruleGroup.rules.push(rule)
          this.logger.warn(`rule ${before} is not defined`)
        }
      }
      function keywordMetaschema(def) {
        let { metaSchema } = def
        if (metaSchema === undefined) return
        if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)
        def.validateSchema = this.compile(metaSchema, true)
      }
      const $dataRef = {
        $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#'
      }
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] }
      }
      //# sourceMappingURL=core.js.map

      /***/
    },

    /***/ 3510: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      // https://github.com/ajv-validator/ajv/issues/889
      const equal = __webpack_require__(4063)
      equal.code = 'require("ajv/dist/runtime/equal").default'
      exports['default'] = equal
      //# sourceMappingURL=equal.js.map

      /***/
    },

    /***/ 4499: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      // https://mathiasbynens.be/notes/javascript-encoding
      // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
      function ucs2length(str) {
        const len = str.length
        let length = 0
        let pos = 0
        let value
        while (pos < len) {
          length++
          value = str.charCodeAt(pos++)
          if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos)
            if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate
          }
        }
        return length
      }
      exports['default'] = ucs2length
      ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default'
      //# sourceMappingURL=ucs2length.js.map

      /***/
    },

    /***/ 3589: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const uri = __webpack_require__(540)
      uri.code = 'require("ajv/dist/runtime/uri").default'
      exports['default'] = uri
      //# sourceMappingURL=uri.js.map

      /***/
    },

    /***/ 7426: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      class ValidationError extends Error {
        constructor(errors) {
          super('validation failed')
          this.errors = errors
          this.ajv = this.validation = true
        }
      }
      exports['default'] = ValidationError
      //# sourceMappingURL=validation_error.js.map

      /***/
    },

    /***/ 4783: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateAdditionalItems = void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { len } }) =>
          (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      }
      const def = {
        keyword: 'additionalItems',
        type: 'array',
        schemaType: ['boolean', 'object'],
        before: 'uniqueItems',
        error,
        code(cxt) {
          const { parentSchema, it } = cxt
          const { items } = parentSchema
          if (!Array.isArray(items)) {
            ;(0, util_1.checkStrictMode)(
              it,
              '"additionalItems" is ignored when "items" is not an array of schemas'
            )
            return
          }
          validateAdditionalItems(cxt, items)
        }
      }
      function validateAdditionalItems(cxt, items) {
        const { gen, schema, data, keyword, it } = cxt
        it.items = true
        const len = gen.const('len', (0, codegen_1._)`${data}.length`)
        if (schema === false) {
          cxt.setParams({ len: items.length })
          cxt.pass((0, codegen_1._)`${len} <= ${items.length}`)
        } else if (
          typeof schema == 'object' &&
          !(0, util_1.alwaysValidSchema)(it, schema)
        ) {
          const valid = gen.var(
            'valid',
            (0, codegen_1._)`${len} <= ${items.length}`
          ) // TODO var
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid))
          cxt.ok(valid)
        }
        function validateItems(valid) {
          gen.forRange('i', items.length, len, (i) => {
            cxt.subschema(
              { keyword, dataProp: i, dataPropType: util_1.Type.Num },
              valid
            )
            if (!it.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break())
          })
        }
      }
      exports.validateAdditionalItems = validateAdditionalItems
      exports['default'] = def
      //# sourceMappingURL=additionalItems.js.map

      /***/
    },

    /***/ 9351: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: 'must NOT have additional properties',
        params: ({ params }) =>
          (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
      }
      const def = {
        keyword: 'additionalProperties',
        type: ['object'],
        schemaType: ['boolean', 'object'],
        allowUndefined: true,
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, errsCount, it } = cxt
          /* istanbul ignore if */
          if (!errsCount) throw new Error('ajv implementation error')
          const { allErrors, opts } = it
          it.props = true
          if (
            opts.removeAdditional !== 'all' &&
            (0, util_1.alwaysValidSchema)(it, schema)
          )
            return
          const props = (0, code_1.allSchemaProperties)(parentSchema.properties)
          const patProps = (0, code_1.allSchemaProperties)(
            parentSchema.patternProperties
          )
          checkAdditionalProperties()
          cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`)
          function checkAdditionalProperties() {
            gen.forIn('key', data, (key) => {
              if (!props.length && !patProps.length) additionalPropertyCode(key)
              else gen.if(isAdditional(key), () => additionalPropertyCode(key))
            })
          }
          function isAdditional(key) {
            let definedProp
            if (props.length > 8) {
              // TODO maybe an option instead of hard-coded 8?
              const propsSchema = (0, util_1.schemaRefOrVal)(
                it,
                parentSchema.properties,
                'properties'
              )
              definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key)
            } else if (props.length) {
              definedProp = (0, codegen_1.or)(
                ...props.map((p) => (0, codegen_1._)`${key} === ${p}`)
              )
            } else {
              definedProp = codegen_1.nil
            }
            if (patProps.length) {
              definedProp = (0, codegen_1.or)(
                definedProp,
                ...patProps.map(
                  (p) =>
                    (0, codegen_1._)`${(0, code_1.usePattern)(
                      cxt,
                      p
                    )}.test(${key})`
                )
              )
            }
            return (0, codegen_1.not)(definedProp)
          }
          function deleteAdditional(key) {
            gen.code((0, codegen_1._)`delete ${data}[${key}]`)
          }
          function additionalPropertyCode(key) {
            if (
              opts.removeAdditional === 'all' ||
              (opts.removeAdditional && schema === false)
            ) {
              deleteAdditional(key)
              return
            }
            if (schema === false) {
              cxt.setParams({ additionalProperty: key })
              cxt.error()
              if (!allErrors) gen.break()
              return
            }
            if (
              typeof schema == 'object' &&
              !(0, util_1.alwaysValidSchema)(it, schema)
            ) {
              const valid = gen.name('valid')
              if (opts.removeAdditional === 'failing') {
                applyAdditionalSchema(key, valid, false)
                gen.if((0, codegen_1.not)(valid), () => {
                  cxt.reset()
                  deleteAdditional(key)
                })
              } else {
                applyAdditionalSchema(key, valid)
                if (!allErrors)
                  gen.if((0, codegen_1.not)(valid), () => gen.break())
              }
            }
          }
          function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
              keyword: 'additionalProperties',
              dataProp: key,
              dataPropType: util_1.Type.Str
            }
            if (errors === false) {
              Object.assign(subschema, {
                compositeRule: true,
                createErrors: false,
                allErrors: false
              })
            }
            cxt.subschema(subschema, valid)
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=additionalProperties.js.map

      /***/
    },

    /***/ 1125: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: 'allOf',
        schemaType: 'array',
        code(cxt) {
          const { gen, schema, it } = cxt
          /* istanbul ignore if */
          if (!Array.isArray(schema))
            throw new Error('ajv implementation error')
          const valid = gen.name('valid')
          schema.forEach((sch, i) => {
            if ((0, util_1.alwaysValidSchema)(it, sch)) return
            const schCxt = cxt.subschema(
              { keyword: 'allOf', schemaProp: i },
              valid
            )
            cxt.ok(valid)
            cxt.mergeEvaluated(schCxt)
          })
        }
      }
      exports['default'] = def
      //# sourceMappingURL=allOf.js.map

      /***/
    },

    /***/ 19: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const def = {
        keyword: 'anyOf',
        schemaType: 'array',
        trackErrors: true,
        code: code_1.validateUnion,
        error: { message: 'must match a schema in anyOf' }
      }
      exports['default'] = def
      //# sourceMappingURL=anyOf.js.map

      /***/
    },

    /***/ 9864: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { min, max } }) =>
          max === undefined
            ? (0, codegen_1.str)`must contain at least ${min} valid item(s)`
            : (0,
              codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min, max } }) =>
          max === undefined
            ? (0, codegen_1._)`{minContains: ${min}}`
            : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
      }
      const def = {
        keyword: 'contains',
        type: 'array',
        schemaType: ['object', 'boolean'],
        before: 'uniqueItems',
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt
          let min
          let max
          const { minContains, maxContains } = parentSchema
          if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains
            max = maxContains
          } else {
            min = 1
          }
          const len = gen.const('len', (0, codegen_1._)`${data}.length`)
          cxt.setParams({ min, max })
          if (max === undefined && min === 0) {
            ;(0, util_1.checkStrictMode)(
              it,
              `"minContains" == 0 without "maxContains": "contains" keyword ignored`
            )
            return
          }
          if (max !== undefined && min > max) {
            ;(0, util_1.checkStrictMode)(
              it,
              `"minContains" > "maxContains" is always invalid`
            )
            cxt.fail()
            return
          }
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1._)`${len} >= ${min}`
            if (max !== undefined)
              cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`
            cxt.pass(cond)
            return
          }
          it.items = true
          const valid = gen.name('valid')
          if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()))
          } else if (min === 0) {
            gen.let(valid, true)
            if (max !== undefined)
              gen.if(
                (0, codegen_1._)`${data}.length > 0`,
                validateItemsWithCount
              )
          } else {
            gen.let(valid, false)
            validateItemsWithCount()
          }
          cxt.result(valid, () => cxt.reset())
          function validateItemsWithCount() {
            const schValid = gen.name('_valid')
            const count = gen.let('count', 0)
            validateItems(schValid, () =>
              gen.if(schValid, () => checkLimits(count))
            )
          }
          function validateItems(_valid, block) {
            gen.forRange('i', 0, len, (i) => {
              cxt.subschema(
                {
                  keyword: 'contains',
                  dataProp: i,
                  dataPropType: util_1.Type.Num,
                  compositeRule: true
                },
                _valid
              )
              block()
            })
          }
          function checkLimits(count) {
            gen.code((0, codegen_1._)`${count}++`)
            if (max === undefined) {
              gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
                gen.assign(valid, true).break()
              )
            } else {
              gen.if((0, codegen_1._)`${count} > ${max}`, () =>
                gen.assign(valid, false).break()
              )
              if (min === 1) gen.assign(valid, true)
              else
                gen.if((0, codegen_1._)`${count} >= ${min}`, () =>
                  gen.assign(valid, true)
                )
            }
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=contains.js.map

      /***/
    },

    /***/ 7772: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateSchemaDeps =
        exports.validatePropertyDeps =
        exports.error =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const code_1 = __webpack_require__(412)
      exports.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? 'property' : 'properties'
          return (0,
          codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`
        },
        params: ({
          params: { property, depsCount, deps, missingProperty }
        }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}` // TODO change to reference
      }
      const def = {
        keyword: 'dependencies',
        type: 'object',
        schemaType: 'object',
        error: exports.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt)
          validatePropertyDeps(cxt, propDeps)
          validateSchemaDeps(cxt, schDeps)
        }
      }
      function splitDependencies({ schema }) {
        const propertyDeps = {}
        const schemaDeps = {}
        for (const key in schema) {
          if (key === '__proto__') continue
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps
          deps[key] = schema[key]
        }
        return [propertyDeps, schemaDeps]
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt
        if (Object.keys(propertyDeps).length === 0) return
        const missing = gen.let('missing')
        for (const prop in propertyDeps) {
          const deps = propertyDeps[prop]
          if (deps.length === 0) continue
          const hasProperty = (0, code_1.propertyInData)(
            gen,
            data,
            prop,
            it.opts.ownProperties
          )
          cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(', ')
          })
          if (it.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                ;(0, code_1.checkReportMissingProp)(cxt, depProp)
              }
            })
          } else {
            gen.if(
              (0, codegen_1._)`${hasProperty} && (${(0,
              code_1.checkMissingProp)(cxt, deps, missing)})`
            )
            ;(0, code_1.reportMissingProp)(cxt, missing)
            gen.else()
          }
        }
      }
      exports.validatePropertyDeps = validatePropertyDeps
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword, it } = cxt
        const valid = gen.name('valid')
        for (const prop in schemaDeps) {
          if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue
          gen.if(
            (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid)
              cxt.mergeValidEvaluated(schCxt, valid)
            },
            () => gen.var(valid, true) // TODO var
          )
          cxt.ok(valid)
        }
      }
      exports.validateSchemaDeps = validateSchemaDeps
      exports['default'] = def
      //# sourceMappingURL=dependencies.js.map

      /***/
    },

    /***/ 9434: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params }) =>
          (0, codegen_1.str)`must match "${params.ifClause}" schema`,
        params: ({ params }) =>
          (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
      }
      const def = {
        keyword: 'if',
        schemaType: ['object', 'boolean'],
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, parentSchema, it } = cxt
          if (
            parentSchema.then === undefined &&
            parentSchema.else === undefined
          ) {
            ;(0, util_1.checkStrictMode)(
              it,
              '"if" without "then" and "else" is ignored'
            )
          }
          const hasThen = hasSchema(it, 'then')
          const hasElse = hasSchema(it, 'else')
          if (!hasThen && !hasElse) return
          const valid = gen.let('valid', true)
          const schValid = gen.name('_valid')
          validateIf()
          cxt.reset()
          if (hasThen && hasElse) {
            const ifClause = gen.let('ifClause')
            cxt.setParams({ ifClause })
            gen.if(
              schValid,
              validateClause('then', ifClause),
              validateClause('else', ifClause)
            )
          } else if (hasThen) {
            gen.if(schValid, validateClause('then'))
          } else {
            gen.if((0, codegen_1.not)(schValid), validateClause('else'))
          }
          cxt.pass(valid, () => cxt.error(true))
          function validateIf() {
            const schCxt = cxt.subschema(
              {
                keyword: 'if',
                compositeRule: true,
                createErrors: false,
                allErrors: false
              },
              schValid
            )
            cxt.mergeEvaluated(schCxt)
          }
          function validateClause(keyword, ifClause) {
            return () => {
              const schCxt = cxt.subschema({ keyword }, schValid)
              gen.assign(valid, schValid)
              cxt.mergeValidEvaluated(schCxt, valid)
              if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`)
              else cxt.setParams({ ifClause: keyword })
            }
          }
        }
      }
      function hasSchema(it, keyword) {
        const schema = it.schema[keyword]
        return (
          schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema)
        )
      }
      exports['default'] = def
      //# sourceMappingURL=if.js.map

      /***/
    },

    /***/ 8200: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const additionalItems_1 = __webpack_require__(4783)
      const prefixItems_1 = __webpack_require__(2924)
      const items_1 = __webpack_require__(4665)
      const items2020_1 = __webpack_require__(1119)
      const contains_1 = __webpack_require__(9864)
      const dependencies_1 = __webpack_require__(7772)
      const propertyNames_1 = __webpack_require__(3708)
      const additionalProperties_1 = __webpack_require__(9351)
      const properties_1 = __webpack_require__(6239)
      const patternProperties_1 = __webpack_require__(2296)
      const not_1 = __webpack_require__(5697)
      const anyOf_1 = __webpack_require__(19)
      const oneOf_1 = __webpack_require__(4200)
      const allOf_1 = __webpack_require__(1125)
      const if_1 = __webpack_require__(9434)
      const thenElse_1 = __webpack_require__(6552)
      function getApplicator(draft2020 = false) {
        const applicator = [
          // any
          not_1.default,
          anyOf_1.default,
          oneOf_1.default,
          allOf_1.default,
          if_1.default,
          thenElse_1.default,
          // object
          propertyNames_1.default,
          additionalProperties_1.default,
          dependencies_1.default,
          properties_1.default,
          patternProperties_1.default
        ]
        // array
        if (draft2020)
          applicator.push(prefixItems_1.default, items2020_1.default)
        else applicator.push(additionalItems_1.default, items_1.default)
        applicator.push(contains_1.default)
        return applicator
      }
      exports['default'] = getApplicator
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 4665: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateTuple = void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const code_1 = __webpack_require__(412)
      const def = {
        keyword: 'items',
        type: 'array',
        schemaType: ['object', 'array', 'boolean'],
        before: 'uniqueItems',
        code(cxt) {
          const { schema, it } = cxt
          if (Array.isArray(schema))
            return validateTuple(cxt, 'additionalItems', schema)
          it.items = true
          if ((0, util_1.alwaysValidSchema)(it, schema)) return
          cxt.ok((0, code_1.validateArray)(cxt))
        }
      }
      function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen, parentSchema, data, keyword, it } = cxt
        checkStrictTuple(parentSchema)
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
          it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items)
        }
        const valid = gen.name('valid')
        const len = gen.const('len', (0, codegen_1._)`${data}.length`)
        schArr.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch)) return
          gen.if((0, codegen_1._)`${len} > ${i}`, () =>
            cxt.subschema(
              {
                keyword,
                schemaProp: i,
                dataProp: i
              },
              valid
            )
          )
          cxt.ok(valid)
        })
        function checkStrictTuple(sch) {
          const { opts, errSchemaPath } = it
          const l = schArr.length
          const fullTuple =
            l === sch.minItems &&
            (l === sch.maxItems || sch[extraItems] === false)
          if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`
            ;(0, util_1.checkStrictMode)(it, msg, opts.strictTuples)
          }
        }
      }
      exports.validateTuple = validateTuple
      exports['default'] = def
      //# sourceMappingURL=items.js.map

      /***/
    },

    /***/ 1119: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const code_1 = __webpack_require__(412)
      const additionalItems_1 = __webpack_require__(4783)
      const error = {
        message: ({ params: { len } }) =>
          (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      }
      const def = {
        keyword: 'items',
        type: 'array',
        schemaType: ['object', 'boolean'],
        before: 'uniqueItems',
        error,
        code(cxt) {
          const { schema, parentSchema, it } = cxt
          const { prefixItems } = parentSchema
          it.items = true
          if ((0, util_1.alwaysValidSchema)(it, schema)) return
          if (prefixItems)
            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems)
          else cxt.ok((0, code_1.validateArray)(cxt))
        }
      }
      exports['default'] = def
      //# sourceMappingURL=items2020.js.map

      /***/
    },

    /***/ 5697: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: 'not',
        schemaType: ['object', 'boolean'],
        trackErrors: true,
        code(cxt) {
          const { gen, schema, it } = cxt
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            cxt.fail()
            return
          }
          const valid = gen.name('valid')
          cxt.subschema(
            {
              keyword: 'not',
              compositeRule: true,
              createErrors: false,
              allErrors: false
            },
            valid
          )
          cxt.failResult(
            valid,
            () => cxt.reset(),
            () => cxt.error()
          )
        },
        error: { message: 'must NOT be valid' }
      }
      exports['default'] = def
      //# sourceMappingURL=not.js.map

      /***/
    },

    /***/ 4200: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: 'must match exactly one schema in oneOf',
        params: ({ params }) =>
          (0, codegen_1._)`{passingSchemas: ${params.passing}}`
      }
      const def = {
        keyword: 'oneOf',
        schemaType: 'array',
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, it } = cxt
          /* istanbul ignore if */
          if (!Array.isArray(schema))
            throw new Error('ajv implementation error')
          if (it.opts.discriminator && parentSchema.discriminator) return
          const schArr = schema
          const valid = gen.let('valid', false)
          const passing = gen.let('passing', null)
          const schValid = gen.name('_valid')
          cxt.setParams({ passing })
          // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
          gen.block(validateOneOf)
          cxt.result(
            valid,
            () => cxt.reset(),
            () => cxt.error(true)
          )
          function validateOneOf() {
            schArr.forEach((sch, i) => {
              let schCxt
              if ((0, util_1.alwaysValidSchema)(it, sch)) {
                gen.var(schValid, true)
              } else {
                schCxt = cxt.subschema(
                  {
                    keyword: 'oneOf',
                    schemaProp: i,
                    compositeRule: true
                  },
                  schValid
                )
              }
              if (i > 0) {
                gen
                  .if((0, codegen_1._)`${schValid} && ${valid}`)
                  .assign(valid, false)
                  .assign(passing, (0, codegen_1._)`[${passing}, ${i}]`)
                  .else()
              }
              gen.if(schValid, () => {
                gen.assign(valid, true)
                gen.assign(passing, i)
                if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name)
              })
            })
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=oneOf.js.map

      /***/
    },

    /***/ 2296: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const util_2 = __webpack_require__(6776)
      const def = {
        keyword: 'patternProperties',
        type: 'object',
        schemaType: 'object',
        code(cxt) {
          const { gen, schema, data, parentSchema, it } = cxt
          const { opts } = it
          const patterns = (0, code_1.allSchemaProperties)(schema)
          const alwaysValidPatterns = patterns.filter((p) =>
            (0, util_1.alwaysValidSchema)(it, schema[p])
          )
          if (
            patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
              (!it.opts.unevaluated || it.props === true))
          ) {
            return
          }
          const checkProperties =
            opts.strictSchema &&
            !opts.allowMatchingProperties &&
            parentSchema.properties
          const valid = gen.name('valid')
          if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props)
          }
          const { props } = it
          validatePatternProperties()
          function validatePatternProperties() {
            for (const pat of patterns) {
              if (checkProperties) checkMatchingProperties(pat)
              if (it.allErrors) {
                validateProperties(pat)
              } else {
                gen.var(valid, true) // TODO var
                validateProperties(pat)
                gen.if(valid)
              }
            }
          }
          function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
              if (new RegExp(pat).test(prop)) {
                ;(0, util_1.checkStrictMode)(
                  it,
                  `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`
                )
              }
            }
          }
          function validateProperties(pat) {
            gen.forIn('key', data, (key) => {
              gen.if(
                (0, codegen_1._)`${(0, code_1.usePattern)(
                  cxt,
                  pat
                )}.test(${key})`,
                () => {
                  const alwaysValid = alwaysValidPatterns.includes(pat)
                  if (!alwaysValid) {
                    cxt.subschema(
                      {
                        keyword: 'patternProperties',
                        schemaProp: pat,
                        dataProp: key,
                        dataPropType: util_2.Type.Str
                      },
                      valid
                    )
                  }
                  if (it.opts.unevaluated && props !== true) {
                    gen.assign((0, codegen_1._)`${props}[${key}]`, true)
                  } else if (!alwaysValid && !it.allErrors) {
                    // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                    // or if all properties were evaluated (props === true)
                    gen.if((0, codegen_1.not)(valid), () => gen.break())
                  }
                }
              )
            })
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=patternProperties.js.map

      /***/
    },

    /***/ 2924: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const items_1 = __webpack_require__(4665)
      const def = {
        keyword: 'prefixItems',
        type: 'array',
        schemaType: ['array'],
        before: 'uniqueItems',
        code: (cxt) => (0, items_1.validateTuple)(cxt, 'items')
      }
      exports['default'] = def
      //# sourceMappingURL=prefixItems.js.map

      /***/
    },

    /***/ 6239: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const validate_1 = __webpack_require__(4815)
      const code_1 = __webpack_require__(412)
      const util_1 = __webpack_require__(6776)
      const additionalProperties_1 = __webpack_require__(9351)
      const def = {
        keyword: 'properties',
        type: 'object',
        schemaType: 'object',
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt
          if (
            it.opts.removeAdditional === 'all' &&
            parentSchema.additionalProperties === undefined
          ) {
            additionalProperties_1.default.code(
              new validate_1.KeywordCxt(
                it,
                additionalProperties_1.default,
                'additionalProperties'
              )
            )
          }
          const allProps = (0, code_1.allSchemaProperties)(schema)
          for (const prop of allProps) {
            it.definedProperties.add(prop)
          }
          if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(
              gen,
              (0, util_1.toHash)(allProps),
              it.props
            )
          }
          const properties = allProps.filter(
            (p) => !(0, util_1.alwaysValidSchema)(it, schema[p])
          )
          if (properties.length === 0) return
          const valid = gen.name('valid')
          for (const prop of properties) {
            if (hasDefault(prop)) {
              applyPropertySchema(prop)
            } else {
              gen.if(
                (0, code_1.propertyInData)(
                  gen,
                  data,
                  prop,
                  it.opts.ownProperties
                )
              )
              applyPropertySchema(prop)
              if (!it.allErrors) gen.else().var(valid, true)
              gen.endIf()
            }
            cxt.it.definedProperties.add(prop)
            cxt.ok(valid)
          }
          function hasDefault(prop) {
            return (
              it.opts.useDefaults &&
              !it.compositeRule &&
              schema[prop].default !== undefined
            )
          }
          function applyPropertySchema(prop) {
            cxt.subschema(
              {
                keyword: 'properties',
                schemaProp: prop,
                dataProp: prop
              },
              valid
            )
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=properties.js.map

      /***/
    },

    /***/ 3708: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: 'property name must be valid',
        params: ({ params }) =>
          (0, codegen_1._)`{propertyName: ${params.propertyName}}`
      }
      const def = {
        keyword: 'propertyNames',
        type: 'object',
        schemaType: ['object', 'boolean'],
        error,
        code(cxt) {
          const { gen, schema, data, it } = cxt
          if ((0, util_1.alwaysValidSchema)(it, schema)) return
          const valid = gen.name('valid')
          gen.forIn('key', data, (key) => {
            cxt.setParams({ propertyName: key })
            cxt.subschema(
              {
                keyword: 'propertyNames',
                data: key,
                dataTypes: ['string'],
                propertyName: key,
                compositeRule: true
              },
              valid
            )
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(true)
              if (!it.allErrors) gen.break()
            })
          })
          cxt.ok(valid)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=propertyNames.js.map

      /***/
    },

    /***/ 6552: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: ['then', 'else'],
        schemaType: ['object', 'boolean'],
        code({ keyword, parentSchema, it }) {
          if (parentSchema.if === undefined)
            (0, util_1.checkStrictMode)(
              it,
              `"${keyword}" without "if" is ignored`
            )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=thenElse.js.map

      /***/
    },

    /***/ 412: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.validateUnion =
        exports.validateArray =
        exports.usePattern =
        exports.callValidateCode =
        exports.schemaProperties =
        exports.allSchemaProperties =
        exports.noPropertyInData =
        exports.propertyInData =
        exports.isOwnProperty =
        exports.hasPropFunc =
        exports.reportMissingProp =
        exports.checkMissingProp =
        exports.checkReportMissingProp =
          void 0
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const names_1 = __webpack_require__(2141)
      const util_2 = __webpack_require__(6776)
      function checkReportMissingProp(cxt, prop) {
        const { gen, data, it } = cxt
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
          cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true)
          cxt.error()
        })
      }
      exports.checkReportMissingProp = checkReportMissingProp
      function checkMissingProp(
        { gen, data, it: { opts } },
        properties,
        missing
      ) {
        return (0, codegen_1.or)(
          ...properties.map((prop) =>
            (0, codegen_1.and)(
              noPropertyInData(gen, data, prop, opts.ownProperties),
              (0, codegen_1._)`${missing} = ${prop}`
            )
          )
        )
      }
      exports.checkMissingProp = checkMissingProp
      function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true)
        cxt.error()
      }
      exports.reportMissingProp = reportMissingProp
      function hasPropFunc(gen) {
        return gen.scopeValue('func', {
          // eslint-disable-next-line @typescript-eslint/unbound-method
          ref: Object.prototype.hasOwnProperty,
          code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
        })
      }
      exports.hasPropFunc = hasPropFunc
      function isOwnProperty(gen, data, property) {
        return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`
      }
      exports.isOwnProperty = isOwnProperty
      function propertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
          property
        )} !== undefined`
        return ownProperties
          ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}`
          : cond
      }
      exports.propertyInData = propertyInData
      function noPropertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(
          property
        )} === undefined`
        return ownProperties
          ? (0, codegen_1.or)(
              cond,
              (0, codegen_1.not)(isOwnProperty(gen, data, property))
            )
          : cond
      }
      exports.noPropertyInData = noPropertyInData
      function allSchemaProperties(schemaMap) {
        return schemaMap
          ? Object.keys(schemaMap).filter((p) => p !== '__proto__')
          : []
      }
      exports.allSchemaProperties = allSchemaProperties
      function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter(
          (p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p])
        )
      }
      exports.schemaProperties = schemaProperties
      function callValidateCode(
        {
          schemaCode,
          data,
          it: { gen, topSchemaRef, schemaPath, errorPath },
          it
        },
        func,
        context,
        passSchema
      ) {
        const dataAndSchema = passSchema
          ? (0,
            codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}`
          : data
        const valCxt = [
          [
            names_1.default.instancePath,
            (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)
          ],
          [names_1.default.parentData, it.parentData],
          [names_1.default.parentDataProperty, it.parentDataProperty],
          [names_1.default.rootData, names_1.default.rootData]
        ]
        if (it.opts.dynamicRef)
          valCxt.push([
            names_1.default.dynamicAnchors,
            names_1.default.dynamicAnchors
          ])
        const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(
          ...valCxt
        )}`
        return context !== codegen_1.nil
          ? (0, codegen_1._)`${func}.call(${context}, ${args})`
          : (0, codegen_1._)`${func}(${args})`
      }
      exports.callValidateCode = callValidateCode
      const newRegExp = (0, codegen_1._)`new RegExp`
      function usePattern({ gen, it: { opts } }, pattern) {
        const u = opts.unicodeRegExp ? 'u' : ''
        const { regExp } = opts.code
        const rx = regExp(pattern, u)
        return gen.scopeValue('pattern', {
          key: rx.toString(),
          ref: rx,
          code: (0, codegen_1._)`${
            regExp.code === 'new RegExp'
              ? newRegExp
              : (0, util_2.useFunc)(gen, regExp)
          }(${pattern}, ${u})`
        })
      }
      exports.usePattern = usePattern
      function validateArray(cxt) {
        const { gen, data, keyword, it } = cxt
        const valid = gen.name('valid')
        if (it.allErrors) {
          const validArr = gen.let('valid', true)
          validateItems(() => gen.assign(validArr, false))
          return validArr
        }
        gen.var(valid, true)
        validateItems(() => gen.break())
        return valid
        function validateItems(notValid) {
          const len = gen.const('len', (0, codegen_1._)`${data}.length`)
          gen.forRange('i', 0, len, (i) => {
            cxt.subschema(
              {
                keyword,
                dataProp: i,
                dataPropType: util_1.Type.Num
              },
              valid
            )
            gen.if((0, codegen_1.not)(valid), notValid)
          })
        }
      }
      exports.validateArray = validateArray
      function validateUnion(cxt) {
        const { gen, schema, keyword, it } = cxt
        /* istanbul ignore if */
        if (!Array.isArray(schema)) throw new Error('ajv implementation error')
        const alwaysValid = schema.some((sch) =>
          (0, util_1.alwaysValidSchema)(it, sch)
        )
        if (alwaysValid && !it.opts.unevaluated) return
        const valid = gen.let('valid', false)
        const schValid = gen.name('_valid')
        gen.block(() =>
          schema.forEach((_sch, i) => {
            const schCxt = cxt.subschema(
              {
                keyword,
                schemaProp: i,
                compositeRule: true
              },
              schValid
            )
            gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`)
            const merged = cxt.mergeValidEvaluated(schCxt, schValid)
            // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
            // or if all properties and items were evaluated (it.props === true && it.items === true)
            if (!merged) gen.if((0, codegen_1.not)(valid))
          })
        )
        cxt.result(
          valid,
          () => cxt.reset(),
          () => cxt.error(true)
        )
      }
      exports.validateUnion = validateUnion
      //# sourceMappingURL=code.js.map

      /***/
    },

    /***/ 8386: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const def = {
        keyword: 'id',
        code() {
          throw new Error(
            'NOT SUPPORTED: keyword "id", use "$id" for schema ID'
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=id.js.map

      /***/
    },

    /***/ 5684: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const id_1 = __webpack_require__(8386)
      const ref_1 = __webpack_require__(8280)
      const core = [
        '$schema',
        '$id',
        '$defs',
        '$vocabulary',
        { keyword: '$comment' },
        'definitions',
        id_1.default,
        ref_1.default
      ]
      exports['default'] = core
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 8280: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.callRef = exports.getValidate = void 0
      const ref_error_1 = __webpack_require__(6646)
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const names_1 = __webpack_require__(2141)
      const compile_1 = __webpack_require__(5173)
      const util_1 = __webpack_require__(6776)
      const def = {
        keyword: '$ref',
        schemaType: 'string',
        code(cxt) {
          const { gen, schema: $ref, it } = cxt
          const { baseId, schemaEnv: env, validateName, opts, self } = it
          const { root } = env
          if (($ref === '#' || $ref === '#/') && baseId === root.baseId)
            return callRootRef()
          const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref)
          if (schOrEnv === undefined)
            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref)
          if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv)
          return inlineRefSchema(schOrEnv)
          function callRootRef() {
            if (env === root) return callRef(cxt, validateName, env, env.$async)
            const rootName = gen.scopeValue('root', { ref: root })
            return callRef(
              cxt,
              (0, codegen_1._)`${rootName}.validate`,
              root,
              root.$async
            )
          }
          function callValidate(sch) {
            const v = getValidate(cxt, sch)
            callRef(cxt, v, sch, sch.$async)
          }
          function inlineRefSchema(sch) {
            const schName = gen.scopeValue(
              'schema',
              opts.code.source === true
                ? { ref: sch, code: (0, codegen_1.stringify)(sch) }
                : { ref: sch }
            )
            const valid = gen.name('valid')
            const schCxt = cxt.subschema(
              {
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref
              },
              valid
            )
            cxt.mergeEvaluated(schCxt)
            cxt.ok(valid)
          }
        }
      }
      function getValidate(cxt, sch) {
        const { gen } = cxt
        return sch.validate
          ? gen.scopeValue('validate', { ref: sch.validate })
          : (0, codegen_1._)`${gen.scopeValue('wrapper', {
              ref: sch
            })}.validate`
      }
      exports.getValidate = getValidate
      function callRef(cxt, v, sch, $async) {
        const { gen, it } = cxt
        const { allErrors, schemaEnv: env, opts } = it
        const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil
        if ($async) callAsyncRef()
        else callSyncRef()
        function callAsyncRef() {
          if (!env.$async)
            throw new Error('async schema referenced by sync schema')
          const valid = gen.let('valid')
          gen.try(
            () => {
              gen.code(
                (0, codegen_1._)`await ${(0, code_1.callValidateCode)(
                  cxt,
                  v,
                  passCxt
                )}`
              )
              addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result
              if (!allErrors) gen.assign(valid, true)
            },
            (e) => {
              gen.if(
                (0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`,
                () => gen.throw(e)
              )
              addErrorsFrom(e)
              if (!allErrors) gen.assign(valid, false)
            }
          )
          cxt.ok(valid)
        }
        function callSyncRef() {
          cxt.result(
            (0, code_1.callValidateCode)(cxt, v, passCxt),
            () => addEvaluatedFrom(v),
            () => addErrorsFrom(v)
          )
        }
        function addErrorsFrom(source) {
          const errs = (0, codegen_1._)`${source}.errors`
          gen.assign(
            names_1.default.vErrors,
            (0,
            codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`
          ) // TODO tagged
          gen.assign(
            names_1.default.errors,
            (0, codegen_1._)`${names_1.default.vErrors}.length`
          )
        }
        function addEvaluatedFrom(source) {
          var _a
          if (!it.opts.unevaluated) return
          const schEvaluated =
            (_a = sch === null || sch === void 0 ? void 0 : sch.validate) ===
              null || _a === void 0
              ? void 0
              : _a.evaluated
          // TODO refactor
          if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
              if (schEvaluated.props !== undefined) {
                it.props = util_1.mergeEvaluated.props(
                  gen,
                  schEvaluated.props,
                  it.props
                )
              }
            } else {
              const props = gen.var(
                'props',
                (0, codegen_1._)`${source}.evaluated.props`
              )
              it.props = util_1.mergeEvaluated.props(
                gen,
                props,
                it.props,
                codegen_1.Name
              )
            }
          }
          if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
              if (schEvaluated.items !== undefined) {
                it.items = util_1.mergeEvaluated.items(
                  gen,
                  schEvaluated.items,
                  it.items
                )
              }
            } else {
              const items = gen.var(
                'items',
                (0, codegen_1._)`${source}.evaluated.items`
              )
              it.items = util_1.mergeEvaluated.items(
                gen,
                items,
                it.items,
                codegen_1.Name
              )
            }
          }
        }
      }
      exports.callRef = callRef
      exports['default'] = def
      //# sourceMappingURL=ref.js.map

      /***/
    },

    /***/ 1240: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const types_1 = __webpack_require__(9306)
      const compile_1 = __webpack_require__(5173)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { discrError, tagName } }) =>
          discrError === types_1.DiscrError.Tag
            ? `tag "${tagName}" must be string`
            : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError, tag, tagName } }) =>
          (0,
          codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
      }
      const def = {
        keyword: 'discriminator',
        type: 'object',
        schemaType: 'object',
        error,
        code(cxt) {
          const { gen, data, schema, parentSchema, it } = cxt
          const { oneOf } = parentSchema
          if (!it.opts.discriminator) {
            throw new Error('discriminator: requires discriminator option')
          }
          const tagName = schema.propertyName
          if (typeof tagName != 'string')
            throw new Error('discriminator: requires propertyName')
          if (schema.mapping)
            throw new Error('discriminator: mapping is not supported')
          if (!oneOf) throw new Error('discriminator: requires oneOf keyword')
          const valid = gen.let('valid', false)
          const tag = gen.const(
            'tag',
            (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`
          )
          gen.if(
            (0, codegen_1._)`typeof ${tag} == "string"`,
            () => validateMapping(),
            () =>
              cxt.error(false, {
                discrError: types_1.DiscrError.Tag,
                tag,
                tagName
              })
          )
          cxt.ok(valid)
          function validateMapping() {
            const mapping = getMapping()
            gen.if(false)
            for (const tagValue in mapping) {
              gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`)
              gen.assign(valid, applyTagSchema(mapping[tagValue]))
            }
            gen.else()
            cxt.error(false, {
              discrError: types_1.DiscrError.Mapping,
              tag,
              tagName
            })
            gen.endIf()
          }
          function applyTagSchema(schemaProp) {
            const _valid = gen.name('valid')
            const schCxt = cxt.subschema(
              { keyword: 'oneOf', schemaProp },
              _valid
            )
            cxt.mergeEvaluated(schCxt, codegen_1.Name)
            return _valid
          }
          function getMapping() {
            var _a
            const oneOfMapping = {}
            const topRequired = hasRequired(parentSchema)
            let tagRequired = true
            for (let i = 0; i < oneOf.length; i++) {
              let sch = oneOf[i]
              if (
                (sch === null || sch === void 0 ? void 0 : sch.$ref) &&
                !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)
              ) {
                sch = compile_1.resolveRef.call(
                  it.self,
                  it.schemaEnv.root,
                  it.baseId,
                  sch === null || sch === void 0 ? void 0 : sch.$ref
                )
                if (sch instanceof compile_1.SchemaEnv) sch = sch.schema
              }
              const propSch =
                (_a =
                  sch === null || sch === void 0 ? void 0 : sch.properties) ===
                  null || _a === void 0
                  ? void 0
                  : _a[tagName]
              if (typeof propSch != 'object') {
                throw new Error(
                  `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`
                )
              }
              tagRequired = tagRequired && (topRequired || hasRequired(sch))
              addMappings(propSch, i)
            }
            if (!tagRequired)
              throw new Error(`discriminator: "${tagName}" must be required`)
            return oneOfMapping
            function hasRequired({ required }) {
              return Array.isArray(required) && required.includes(tagName)
            }
            function addMappings(sch, i) {
              if (sch.const) {
                addMapping(sch.const, i)
              } else if (sch.enum) {
                for (const tagValue of sch.enum) {
                  addMapping(tagValue, i)
                }
              } else {
                throw new Error(
                  `discriminator: "properties/${tagName}" must have "const" or "enum"`
                )
              }
            }
            function addMapping(tagValue, i) {
              if (typeof tagValue != 'string' || tagValue in oneOfMapping) {
                throw new Error(
                  `discriminator: "${tagName}" values must be unique strings`
                )
              }
              oneOfMapping[tagValue] = i
            }
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 9306: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.DiscrError = void 0
      var DiscrError
      ;(function (DiscrError) {
        DiscrError['Tag'] = 'tag'
        DiscrError['Mapping'] = 'mapping'
      })((DiscrError = exports.DiscrError || (exports.DiscrError = {})))
      //# sourceMappingURL=types.js.map

      /***/
    },

    /***/ 3924: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const core_1 = __webpack_require__(5684)
      const validation_1 = __webpack_require__(2649)
      const applicator_1 = __webpack_require__(8200)
      const format_1 = __webpack_require__(9502)
      const metadata_1 = __webpack_require__(6167)
      const draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        (0, applicator_1.default)(),
        format_1.default,
        metadata_1.metadataVocabulary,
        metadata_1.contentVocabulary
      ]
      exports['default'] = draft7Vocabularies
      //# sourceMappingURL=draft7.js.map

      /***/
    },

    /***/ 9651: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message: ({ schemaCode }) =>
          (0, codegen_1.str)`must match format "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
      }
      const def = {
        keyword: 'format',
        type: ['number', 'string'],
        schemaType: 'string',
        $data: true,
        error,
        code(cxt, ruleType) {
          const { gen, data, $data, schema, schemaCode, it } = cxt
          const { opts, errSchemaPath, schemaEnv, self } = it
          if (!opts.validateFormats) return
          if ($data) validate$DataFormat()
          else validateFormat()
          function validate$DataFormat() {
            const fmts = gen.scopeValue('formats', {
              ref: self.formats,
              code: opts.code.formats
            })
            const fDef = gen.const(
              'fDef',
              (0, codegen_1._)`${fmts}[${schemaCode}]`
            )
            const fType = gen.let('fType')
            const format = gen.let('format')
            // TODO simplify
            gen.if(
              (0,
              codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`,
              () =>
                gen
                  .assign(fType, (0, codegen_1._)`${fDef}.type || "string"`)
                  .assign(format, (0, codegen_1._)`${fDef}.validate`),
              () =>
                gen
                  .assign(fType, (0, codegen_1._)`"string"`)
                  .assign(format, fDef)
            )
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()))
            function unknownFmt() {
              if (opts.strictSchema === false) return codegen_1.nil
              return (0, codegen_1._)`${schemaCode} && !${format}`
            }
            function invalidFmt() {
              const callFormat = schemaEnv.$async
                ? (0,
                  codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                : (0, codegen_1._)`${format}(${data})`
              const validData = (0,
              codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`
              return (0,
              codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`
            }
          }
          function validateFormat() {
            const formatDef = self.formats[schema]
            if (!formatDef) {
              unknownFormat()
              return
            }
            if (formatDef === true) return
            const [fmtType, format, fmtRef] = getFormat(formatDef)
            if (fmtType === ruleType) cxt.pass(validCondition())
            function unknownFormat() {
              if (opts.strictSchema === false) {
                self.logger.warn(unknownMsg())
                return
              }
              throw new Error(unknownMsg())
              function unknownMsg() {
                return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`
              }
            }
            function getFormat(fmtDef) {
              const code =
                fmtDef instanceof RegExp
                  ? (0, codegen_1.regexpCode)(fmtDef)
                  : opts.code.formats
                    ? (0, codegen_1._)`${opts.code.formats}${(0,
                      codegen_1.getProperty)(schema)}`
                    : undefined
              const fmt = gen.scopeValue('formats', {
                key: schema,
                ref: fmtDef,
                code
              })
              if (typeof fmtDef == 'object' && !(fmtDef instanceof RegExp)) {
                return [
                  fmtDef.type || 'string',
                  fmtDef.validate,
                  (0, codegen_1._)`${fmt}.validate`
                ]
              }
              return ['string', fmtDef, fmt]
            }
            function validCondition() {
              if (
                typeof formatDef == 'object' &&
                !(formatDef instanceof RegExp) &&
                formatDef.async
              ) {
                if (!schemaEnv.$async)
                  throw new Error('async format in sync schema')
                return (0, codegen_1._)`await ${fmtRef}(${data})`
              }
              return typeof format == 'function'
                ? (0, codegen_1._)`${fmtRef}(${data})`
                : (0, codegen_1._)`${fmtRef}.test(${data})`
            }
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=format.js.map

      /***/
    },

    /***/ 9502: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const format_1 = __webpack_require__(9651)
      const format = [format_1.default]
      exports['default'] = format
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 6167: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.contentVocabulary = exports.metadataVocabulary = void 0
      exports.metadataVocabulary = [
        'title',
        'description',
        'default',
        'deprecated',
        'readOnly',
        'writeOnly',
        'examples'
      ]
      exports.contentVocabulary = [
        'contentMediaType',
        'contentEncoding',
        'contentSchema'
      ]
      //# sourceMappingURL=metadata.js.map

      /***/
    },

    /***/ 4693: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const equal_1 = __webpack_require__(3510)
      const error = {
        message: 'must be equal to constant',
        params: ({ schemaCode }) =>
          (0, codegen_1._)`{allowedValue: ${schemaCode}}`
      }
      const def = {
        keyword: 'const',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schemaCode, schema } = cxt
          if ($data || (schema && typeof schema == 'object')) {
            cxt.fail$data(
              (0, codegen_1._)`!${(0, util_1.useFunc)(
                gen,
                equal_1.default
              )}(${data}, ${schemaCode})`
            )
          } else {
            cxt.fail((0, codegen_1._)`${schema} !== ${data}`)
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=const.js.map

      /***/
    },

    /***/ 966: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const equal_1 = __webpack_require__(3510)
      const error = {
        message: 'must be equal to one of the allowed values',
        params: ({ schemaCode }) =>
          (0, codegen_1._)`{allowedValues: ${schemaCode}}`
      }
      const def = {
        keyword: 'enum',
        schemaType: 'array',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, schemaCode, it } = cxt
          if (!$data && schema.length === 0)
            throw new Error('enum must have non-empty array')
          const useLoop = schema.length >= it.opts.loopEnum
          let eql
          const getEql = () =>
            eql !== null && eql !== void 0
              ? eql
              : (eql = (0, util_1.useFunc)(gen, equal_1.default))
          let valid
          if (useLoop || $data) {
            valid = gen.let('valid')
            cxt.block$data(valid, loopEnum)
          } else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
              throw new Error('ajv implementation error')
            const vSchema = gen.const('vSchema', schemaCode)
            valid = (0, codegen_1.or)(
              ...schema.map((_x, i) => equalCode(vSchema, i))
            )
          }
          cxt.pass(valid)
          function loopEnum() {
            gen.assign(valid, false)
            gen.forOf('v', schemaCode, (v) =>
              gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () =>
                gen.assign(valid, true).break()
              )
            )
          }
          function equalCode(vSchema, i) {
            const sch = schema[i]
            return typeof sch === 'object' && sch !== null
              ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])`
              : (0, codegen_1._)`${data} === ${sch}`
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=enum.js.map

      /***/
    },

    /***/ 2649: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const limitNumber_1 = __webpack_require__(3983)
      const multipleOf_1 = __webpack_require__(430)
      const limitLength_1 = __webpack_require__(3229)
      const pattern_1 = __webpack_require__(4336)
      const limitProperties_1 = __webpack_require__(498)
      const required_1 = __webpack_require__(3301)
      const limitItems_1 = __webpack_require__(1687)
      const uniqueItems_1 = __webpack_require__(2958)
      const const_1 = __webpack_require__(4693)
      const enum_1 = __webpack_require__(966)
      const validation = [
        // number
        limitNumber_1.default,
        multipleOf_1.default,
        // string
        limitLength_1.default,
        pattern_1.default,
        // object
        limitProperties_1.default,
        required_1.default,
        // array
        limitItems_1.default,
        uniqueItems_1.default,
        // any
        { keyword: 'type', schemaType: ['string', 'array'] },
        { keyword: 'nullable', schemaType: 'boolean' },
        const_1.default,
        enum_1.default
      ]
      exports['default'] = validation
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 1687: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === 'maxItems' ? 'more' : 'fewer'
          return (0,
          codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      }
      const def = {
        keyword: ['maxItems', 'minItems'],
        type: 'array',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt
          const op =
            keyword === 'maxItems'
              ? codegen_1.operators.GT
              : codegen_1.operators.LT
          cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitItems.js.map

      /***/
    },

    /***/ 3229: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const ucs2length_1 = __webpack_require__(4499)
      const error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === 'maxLength' ? 'more' : 'fewer'
          return (0,
          codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      }
      const def = {
        keyword: ['maxLength', 'minLength'],
        type: 'string',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode, it } = cxt
          const op =
            keyword === 'maxLength'
              ? codegen_1.operators.GT
              : codegen_1.operators.LT
          const len =
            it.opts.unicode === false
              ? (0, codegen_1._)`${data}.length`
              : (0, codegen_1._)`${(0, util_1.useFunc)(
                  cxt.gen,
                  ucs2length_1.default
                )}(${data})`
          cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitLength.js.map

      /***/
    },

    /***/ 3983: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const ops = codegen_1.operators
      const KWDs = {
        maximum: { okStr: '<=', ok: ops.LTE, fail: ops.GT },
        minimum: { okStr: '>=', ok: ops.GTE, fail: ops.LT },
        exclusiveMaximum: { okStr: '<', ok: ops.LT, fail: ops.GTE },
        exclusiveMinimum: { okStr: '>', ok: ops.GT, fail: ops.LTE }
      }
      const error = {
        message: ({ keyword, schemaCode }) =>
          (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
        params: ({ keyword, schemaCode }) =>
          (0,
          codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
      }
      const def = {
        keyword: Object.keys(KWDs),
        type: 'number',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt
          cxt.fail$data(
            (0,
            codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitNumber.js.map

      /***/
    },

    /***/ 498: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message({ keyword, schemaCode }) {
          const comp = keyword === 'maxProperties' ? 'more' : 'fewer'
          return (0,
          codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      }
      const def = {
        keyword: ['maxProperties', 'minProperties'],
        type: 'object',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { keyword, data, schemaCode } = cxt
          const op =
            keyword === 'maxProperties'
              ? codegen_1.operators.GT
              : codegen_1.operators.LT
          cxt.fail$data(
            (0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=limitProperties.js.map

      /***/
    },

    /***/ 430: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message: ({ schemaCode }) =>
          (0, codegen_1.str)`must be multiple of ${schemaCode}`,
        params: ({ schemaCode }) =>
          (0, codegen_1._)`{multipleOf: ${schemaCode}}`
      }
      const def = {
        keyword: 'multipleOf',
        type: 'number',
        schemaType: 'number',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, it } = cxt
          // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
          const prec = it.opts.multipleOfPrecision
          const res = gen.let('res')
          const invalid = prec
            ? (0,
              codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1._)`${res} !== parseInt(${res})`
          cxt.fail$data(
            (0,
            codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`
          )
        }
      }
      exports['default'] = def
      //# sourceMappingURL=multipleOf.js.map

      /***/
    },

    /***/ 4336: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const error = {
        message: ({ schemaCode }) =>
          (0, codegen_1.str)`must match pattern "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
      }
      const def = {
        keyword: 'pattern',
        type: 'string',
        schemaType: 'string',
        $data: true,
        error,
        code(cxt) {
          const { data, $data, schema, schemaCode, it } = cxt
          // TODO regexp should be wrapped in try/catchs
          const u = it.opts.unicodeRegExp ? 'u' : ''
          const regExp = $data
            ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))`
            : (0, code_1.usePattern)(cxt, schema)
          cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`)
        }
      }
      exports['default'] = def
      //# sourceMappingURL=pattern.js.map

      /***/
    },

    /***/ 3301: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const code_1 = __webpack_require__(412)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const error = {
        message: ({ params: { missingProperty } }) =>
          (0, codegen_1.str)`must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty } }) =>
          (0, codegen_1._)`{missingProperty: ${missingProperty}}`
      }
      const def = {
        keyword: 'required',
        type: 'object',
        schemaType: 'array',
        $data: true,
        error,
        code(cxt) {
          const { gen, schema, schemaCode, data, $data, it } = cxt
          const { opts } = it
          if (!$data && schema.length === 0) return
          const useLoop = schema.length >= opts.loopRequired
          if (it.allErrors) allErrorsMode()
          else exitOnErrorMode()
          if (opts.strictRequired) {
            const props = cxt.parentSchema.properties
            const { definedProperties } = cxt.it
            for (const requiredKey of schema) {
              if (
                (props === null || props === void 0
                  ? void 0
                  : props[requiredKey]) === undefined &&
                !definedProperties.has(requiredKey)
              ) {
                const schemaPath = it.schemaEnv.baseId + it.errSchemaPath
                const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`
                ;(0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired)
              }
            }
          }
          function allErrorsMode() {
            if (useLoop || $data) {
              cxt.block$data(codegen_1.nil, loopAllRequired)
            } else {
              for (const prop of schema) {
                ;(0, code_1.checkReportMissingProp)(cxt, prop)
              }
            }
          }
          function exitOnErrorMode() {
            const missing = gen.let('missing')
            if (useLoop || $data) {
              const valid = gen.let('valid', true)
              cxt.block$data(valid, () => loopUntilMissing(missing, valid))
              cxt.ok(valid)
            } else {
              gen.if((0, code_1.checkMissingProp)(cxt, schema, missing))
              ;(0, code_1.reportMissingProp)(cxt, missing)
              gen.else()
            }
          }
          function loopAllRequired() {
            gen.forOf('prop', schemaCode, (prop) => {
              cxt.setParams({ missingProperty: prop })
              gen.if(
                (0, code_1.noPropertyInData)(
                  gen,
                  data,
                  prop,
                  opts.ownProperties
                ),
                () => cxt.error()
              )
            })
          }
          function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing })
            gen.forOf(
              missing,
              schemaCode,
              () => {
                gen.assign(
                  valid,
                  (0, code_1.propertyInData)(
                    gen,
                    data,
                    missing,
                    opts.ownProperties
                  )
                )
                gen.if((0, codegen_1.not)(valid), () => {
                  cxt.error()
                  gen.break()
                })
              },
              codegen_1.nil
            )
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=required.js.map

      /***/
    },

    /***/ 2958: /***/ (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const dataType_1 = __webpack_require__(453)
      const codegen_1 = __webpack_require__(3487)
      const util_1 = __webpack_require__(6776)
      const equal_1 = __webpack_require__(3510)
      const error = {
        message: ({ params: { i, j } }) =>
          (0,
          codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
        params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
      }
      const def = {
        keyword: 'uniqueItems',
        type: 'array',
        schemaType: 'boolean',
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt
          if (!$data && !schema) return
          const valid = gen.let('valid')
          const itemTypes = parentSchema.items
            ? (0, dataType_1.getSchemaTypes)(parentSchema.items)
            : []
          cxt.block$data(
            valid,
            validateUniqueItems,
            (0, codegen_1._)`${schemaCode} === false`
          )
          cxt.ok(valid)
          function validateUniqueItems() {
            const i = gen.let('i', (0, codegen_1._)`${data}.length`)
            const j = gen.let('j')
            cxt.setParams({ i, j })
            gen.assign(valid, true)
            gen.if((0, codegen_1._)`${i} > 1`, () =>
              (canOptimize() ? loopN : loopN2)(i, j)
            )
          }
          function canOptimize() {
            return (
              itemTypes.length > 0 &&
              !itemTypes.some((t) => t === 'object' || t === 'array')
            )
          }
          function loopN(i, j) {
            const item = gen.name('item')
            const wrongType = (0, dataType_1.checkDataTypes)(
              itemTypes,
              item,
              it.opts.strictNumbers,
              dataType_1.DataType.Wrong
            )
            const indices = gen.const('indices', (0, codegen_1._)`{}`)
            gen.for((0, codegen_1._)`;${i}--;`, () => {
              gen.let(item, (0, codegen_1._)`${data}[${i}]`)
              gen.if(wrongType, (0, codegen_1._)`continue`)
              if (itemTypes.length > 1)
                gen.if(
                  (0, codegen_1._)`typeof ${item} == "string"`,
                  (0, codegen_1._)`${item} += "_"`
                )
              gen
                .if(
                  (0, codegen_1._)`typeof ${indices}[${item}] == "number"`,
                  () => {
                    gen.assign(j, (0, codegen_1._)`${indices}[${item}]`)
                    cxt.error()
                    gen.assign(valid, false).break()
                  }
                )
                .code((0, codegen_1._)`${indices}[${item}] = ${i}`)
            })
          }
          function loopN2(i, j) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default)
            const outer = gen.name('outer')
            gen.label(outer).for((0, codegen_1._)`;${i}--;`, () =>
              gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () =>
                gen.if(
                  (0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`,
                  () => {
                    cxt.error()
                    gen.assign(valid, false).break(outer)
                  }
                )
              )
            )
          }
        }
      }
      exports['default'] = def
      //# sourceMappingURL=uniqueItems.js.map

      /***/
    },

    /***/ 8307: /***/ function (module, exports) {
      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__ /**
       * alertifyjs 1.13.1 http://alertifyjs.com
       * AlertifyJS is a javascript framework for developing pretty browser dialogs and notifications.
       * Copyright 2019 Mohammad Younes <Mohammad@alertifyjs.com> (http://alertifyjs.com)
       * Licensed under GPL 3 <https://opensource.org/licenses/gpl-3.0>*/
      ;(function (window) {
        'use strict'
        var NOT_DISABLED_NOT_RESET = ':not(:disabled):not(.ajs-reset)'
        /**
         * Keys enum
         * @type {Object}
         */
        var keys = {
          ENTER: 13,
          ESC: 27,
          F1: 112,
          F12: 123,
          LEFT: 37,
          RIGHT: 39,
          TAB: 9
        }
        /**
         * Default options
         * @type {Object}
         */
        var defaults = {
          autoReset: true,
          basic: false,
          closable: true,
          closableByDimmer: true,
          invokeOnCloseOff: false,
          frameless: false,
          defaultFocusOff: false,
          maintainFocus: true, //global default not per instance, applies to all dialogs
          maximizable: true,
          modal: true,
          movable: true,
          moveBounded: false,
          overflow: true,
          padding: true,
          pinnable: true,
          pinned: true,
          preventBodyShift: false, //global default not per instance, applies to all dialogs
          resizable: true,
          startMaximized: false,
          transition: 'pulse',
          transitionOff: false,
          tabbable: [
            'button',
            '[href]',
            'input',
            'select',
            'textarea',
            '[tabindex]:not([tabindex^="-"])' + NOT_DISABLED_NOT_RESET
          ].join(NOT_DISABLED_NOT_RESET + ','), //global
          notifier: {
            delay: 5,
            position: 'bottom-right',
            closeButton: false,
            classes: {
              base: 'alertify-notifier',
              prefix: 'ajs-',
              message: 'ajs-message',
              top: 'ajs-top',
              right: 'ajs-right',
              bottom: 'ajs-bottom',
              left: 'ajs-left',
              center: 'ajs-center',
              visible: 'ajs-visible',
              hidden: 'ajs-hidden',
              close: 'ajs-close'
            }
          },
          glossary: {
            title: 'AlertifyJS',
            ok: 'OK',
            cancel: 'Cancel',
            acccpt: 'Accept',
            deny: 'Deny',
            confirm: 'Confirm',
            decline: 'Decline',
            close: 'Close',
            maximize: 'Maximize',
            restore: 'Restore'
          },
          theme: {
            input: 'ajs-input',
            ok: 'ajs-ok',
            cancel: 'ajs-cancel'
          },
          hooks: {
            preinit: function () {},
            postinit: function () {}
          }
        }

        //holds open dialogs instances
        var openDialogs = []

        /**
         * [Helper]  Adds the specified class(es) to the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be added to the class attribute of the element.
         *
         * @return {undefined}
         */
        function addClass(element, classNames) {
          element.className += ' ' + classNames
        }

        /**
         * [Helper]  Removes the specified class(es) from the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be removed from the class attribute of the element.
         *
         * @return {undefined}
         */
        function removeClass(element, classNames) {
          var original = element.className.split(' ')
          var toBeRemoved = classNames.split(' ')
          for (var x = 0; x < toBeRemoved.length; x += 1) {
            var index = original.indexOf(toBeRemoved[x])
            if (index > -1) {
              original.splice(index, 1)
            }
          }
          element.className = original.join(' ')
        }

        /**
         * [Helper]  Checks if the document is RTL
         *
         * @return {Boolean} True if the document is RTL, false otherwise.
         */
        function isRightToLeft() {
          return window.getComputedStyle(document.body).direction === 'rtl'
        }
        /**
         * [Helper]  Get the document current scrollTop
         *
         * @return {Number} current document scrollTop value
         */
        function getScrollTop() {
          return (
            (document.documentElement && document.documentElement.scrollTop) ||
            document.body.scrollTop
          )
        }

        /**
         * [Helper]  Get the document current scrollLeft
         *
         * @return {Number} current document scrollLeft value
         */
        function getScrollLeft() {
          return (
            (document.documentElement && document.documentElement.scrollLeft) ||
            document.body.scrollLeft
          )
        }

        /**
         * Helper: clear contents
         *
         */
        function clearContents(element) {
          while (element.lastChild) {
            element.removeChild(element.lastChild)
          }
        }
        /**
         * Extends a given prototype by merging properties from base into sub.
         *
         * @sub {Object} sub The prototype being overwritten.
         * @base {Object} base The prototype being written.
         *
         * @return {Object} The extended prototype.
         */
        function copy(src) {
          if (null === src) {
            return src
          }
          var cpy
          if (Array.isArray(src)) {
            cpy = []
            for (var x = 0; x < src.length; x += 1) {
              cpy.push(copy(src[x]))
            }
            return cpy
          }

          if (src instanceof Date) {
            return new Date(src.getTime())
          }

          if (src instanceof RegExp) {
            cpy = new RegExp(src.source)
            cpy.global = src.global
            cpy.ignoreCase = src.ignoreCase
            cpy.multiline = src.multiline
            cpy.lastIndex = src.lastIndex
            return cpy
          }

          if (typeof src === 'object') {
            cpy = {}
            // copy dialog pototype over definition.
            for (var prop in src) {
              if (src.hasOwnProperty(prop)) {
                cpy[prop] = copy(src[prop])
              }
            }
            return cpy
          }
          return src
        }
        /**
         * Helper: destruct the dialog
         *
         */
        function destruct(instance, initialize) {
          if (instance.elements) {
            //delete the dom and it's references.
            var root = instance.elements.root
            root.parentNode.removeChild(root)
            delete instance.elements
            //copy back initial settings.
            instance.settings = copy(instance.__settings)
            //re-reference init function.
            instance.__init = initialize
            //delete __internal variable to allow re-initialization.
            delete instance.__internal
          }
        }

        /**
         * Test to check if passive event listeners are supported.
         */
        var IsPassiveSupported = false
        try {
          var options = Object.defineProperty({}, 'passive', {
            get: function () {
              IsPassiveSupported = true
            }
          })
          window.addEventListener('test', options, options)
          window.removeEventListener('test', options, options)
        } catch (e) {}

        /**
         * Removes an event listener
         *
         * @param {HTMLElement} el The EventTarget to register the listenr on.
         * @param {string} event The event type to listen for.
         * @param {Function} handler The function to handle the event.
         * @param {boolean} useCapture Specifices if the event to be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.
         * @param {boolean} passive A Boolean which, if true, indicates that the function specified by listener will never call preventDefault().
         */
        var on = function (el, event, fn, useCapture, passive) {
          el.addEventListener(
            event,
            fn,
            IsPassiveSupported
              ? { capture: useCapture, passive: passive }
              : useCapture === true
          )
        }

        /**
         * Removes an event listener
         *
         * @param {HTMLElement} el The EventTarget to unregister the listenr from.
         * @param {string} event The event type to remove.
         * @param {Function} fn The event handler to remove.
         * @param {boolean} useCapture Specifices if the event to be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.
         * @param {boolean} passive A Boolean which, if true, indicates that the function specified by listener will never call preventDefault().
         */
        var off = function (el, event, fn, useCapture, passive) {
          el.removeEventListener(
            event,
            fn,
            IsPassiveSupported
              ? { capture: useCapture, passive: passive }
              : useCapture === true
          )
        }

        /**
     * Prevent default event from firing
     *
     * @param  {Event} event Event object
     * @return {undefined}

    function prevent ( event ) {
        if ( event ) {
            if ( event.preventDefault ) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        }
    }
    */
        var transition = (function () {
          var t, type
          var supported = false
          var transitions = {
            animation: 'animationend',
            OAnimation: 'oAnimationEnd oanimationend',
            msAnimation: 'MSAnimationEnd',
            MozAnimation: 'animationend',
            WebkitAnimation: 'webkitAnimationEnd'
          }

          for (t in transitions) {
            if (document.documentElement.style[t] !== undefined) {
              type = transitions[t]
              supported = true
              break
            }
          }

          return {
            type: type,
            supported: supported
          }
        })()

        /**
         * Creates event handler delegate that sends the instance as last argument.
         *
         * @return {Function}    a function wrapper which sends the instance as last argument.
         */
        function delegate(context, method) {
          return function () {
            if (arguments.length > 0) {
              var args = []
              for (var x = 0; x < arguments.length; x += 1) {
                args.push(arguments[x])
              }
              args.push(context)
              return method.apply(context, args)
            }
            return method.apply(context, [null, context])
          }
        }
        /**
         * Helper for creating a dialog close event.
         *
         * @return {object}
         */
        function createCloseEvent(index, button) {
          return {
            index: index,
            button: button,
            cancel: false
          }
        }
        /**
         * Helper for dispatching events.
         *
         * @param  {string} evenType The type of the event to disptach.
         * @param  {object} instance The dialog instance disptaching the event.
         *
         * @return   {any}   The result of the invoked function.
         */
        function dispatchEvent(eventType, instance) {
          if (typeof instance.get(eventType) === 'function') {
            return instance.get(eventType).call(instance)
          }
        }

        /**
         * Super class for all dialogs
         *
         * @return {Object}		base dialog prototype
         */
        var dialog = (function () {
          var //holds the list of used keys.
            usedKeys = [],
            //dummy variable, used to trigger dom reflow.
            reflow = null,
            //holds body tab index in case it has any.
            tabindex = false,
            //condition for detecting safari
            isSafari =
              window.navigator.userAgent.indexOf('Safari') > -1 &&
              window.navigator.userAgent.indexOf('Chrome') < 0,
            //dialog building blocks
            templates = {
              dimmer: '<div class="ajs-dimmer"></div>',
              /*tab index required to fire click event before body focus*/
              modal: '<div class="ajs-modal" tabindex="0"></div>',
              dialog: '<div class="ajs-dialog" tabindex="0"></div>',
              reset: '<button class="ajs-reset"></button>',
              commands:
                '<div class="ajs-commands"><button class="ajs-pin"></button><button class="ajs-maximize"></button><button class="ajs-close"></button></div>',
              header: '<div class="ajs-header"></div>',
              body: '<div class="ajs-body"></div>',
              content: '<div class="ajs-content"></div>',
              footer: '<div class="ajs-footer"></div>',
              buttons: {
                primary: '<div class="ajs-primary ajs-buttons"></div>',
                auxiliary: '<div class="ajs-auxiliary ajs-buttons"></div>'
              },
              button: '<button class="ajs-button"></button>',
              resizeHandle: '<div class="ajs-handle"></div>'
            },
            //common class names
            classes = {
              animationIn: 'ajs-in',
              animationOut: 'ajs-out',
              base: 'alertify',
              basic: 'ajs-basic',
              capture: 'ajs-capture',
              closable: 'ajs-closable',
              fixed: 'ajs-fixed',
              frameless: 'ajs-frameless',
              hidden: 'ajs-hidden',
              maximize: 'ajs-maximize',
              maximized: 'ajs-maximized',
              maximizable: 'ajs-maximizable',
              modeless: 'ajs-modeless',
              movable: 'ajs-movable',
              noSelection: 'ajs-no-selection',
              noOverflow: 'ajs-no-overflow',
              noPadding: 'ajs-no-padding',
              pin: 'ajs-pin',
              pinnable: 'ajs-pinnable',
              prefix: 'ajs-',
              resizable: 'ajs-resizable',
              restore: 'ajs-restore',
              shake: 'ajs-shake',
              unpinned: 'ajs-unpinned',
              noTransition: 'ajs-no-transition'
            }

          /**
           * Helper: initializes the dialog instance
           *
           * @return	{Number}	The total count of currently open modals.
           */
          function initialize(instance) {
            if (!instance.__internal) {
              //invoke preinit global hook
              alertify.defaults.hooks.preinit(instance)
              //no need to expose init after this.
              delete instance.__init

              //keep a copy of initial dialog settings
              if (!instance.__settings) {
                instance.__settings = copy(instance.settings)
              }

              //get dialog buttons/focus setup
              var setup
              if (typeof instance.setup === 'function') {
                setup = instance.setup()
                setup.options = setup.options || {}
                setup.focus = setup.focus || {}
              } else {
                setup = {
                  buttons: [],
                  focus: {
                    element: null,
                    select: false
                  },
                  options: {}
                }
              }

              //initialize hooks object.
              if (typeof instance.hooks !== 'object') {
                instance.hooks = {}
              }

              //copy buttons defintion
              var buttonsDefinition = []
              if (Array.isArray(setup.buttons)) {
                for (var b = 0; b < setup.buttons.length; b += 1) {
                  var ref = setup.buttons[b],
                    cpy = {}
                  for (var i in ref) {
                    if (ref.hasOwnProperty(i)) {
                      cpy[i] = ref[i]
                    }
                  }
                  buttonsDefinition.push(cpy)
                }
              }

              var internal = (instance.__internal = {
                /**
                 * Flag holding the open state of the dialog
                 *
                 * @type {Boolean}
                 */
                isOpen: false,
                /**
                 * Active element is the element that will receive focus after
                 * closing the dialog. It defaults as the body tag, but gets updated
                 * to the last focused element before the dialog was opened.
                 *
                 * @type {Node}
                 */
                activeElement: document.body,
                timerIn: undefined,
                timerOut: undefined,
                buttons: buttonsDefinition,
                focus: setup.focus,
                options: {
                  title: undefined,
                  modal: undefined,
                  basic: undefined,
                  frameless: undefined,
                  defaultFocusOff: undefined,
                  pinned: undefined,
                  movable: undefined,
                  moveBounded: undefined,
                  resizable: undefined,
                  autoReset: undefined,
                  closable: undefined,
                  closableByDimmer: undefined,
                  invokeOnCloseOff: undefined,
                  maximizable: undefined,
                  startMaximized: undefined,
                  pinnable: undefined,
                  transition: undefined,
                  transitionOff: undefined,
                  padding: undefined,
                  overflow: undefined,
                  onshow: undefined,
                  onclosing: undefined,
                  onclose: undefined,
                  onfocus: undefined,
                  onmove: undefined,
                  onmoved: undefined,
                  onresize: undefined,
                  onresized: undefined,
                  onmaximize: undefined,
                  onmaximized: undefined,
                  onrestore: undefined,
                  onrestored: undefined
                },
                resetHandler: undefined,
                beginMoveHandler: undefined,
                beginResizeHandler: undefined,
                bringToFrontHandler: undefined,
                modalClickHandler: undefined,
                buttonsClickHandler: undefined,
                commandsClickHandler: undefined,
                transitionInHandler: undefined,
                transitionOutHandler: undefined,
                destroy: undefined
              })

              var elements = {}
              //root node
              elements.root = document.createElement('div')
              //prevent FOUC in case of async styles loading.
              elements.root.style.display = 'none'
              elements.root.className =
                classes.base + ' ' + classes.hidden + ' '

              elements.root.innerHTML = templates.dimmer + templates.modal

              //dimmer
              elements.dimmer = elements.root.firstChild

              //dialog
              elements.modal = elements.root.lastChild
              elements.modal.innerHTML = templates.dialog
              elements.dialog = elements.modal.firstChild
              elements.dialog.innerHTML =
                templates.reset +
                templates.commands +
                templates.header +
                templates.body +
                templates.footer +
                templates.resizeHandle +
                templates.reset

              //reset links
              elements.reset = []
              elements.reset.push(elements.dialog.firstChild)
              elements.reset.push(elements.dialog.lastChild)

              //commands
              elements.commands = {}
              elements.commands.container = elements.reset[0].nextSibling
              elements.commands.pin = elements.commands.container.firstChild
              elements.commands.maximize = elements.commands.pin.nextSibling
              elements.commands.close = elements.commands.maximize.nextSibling

              //header
              elements.header = elements.commands.container.nextSibling

              //body
              elements.body = elements.header.nextSibling
              elements.body.innerHTML = templates.content
              elements.content = elements.body.firstChild

              //footer
              elements.footer = elements.body.nextSibling
              elements.footer.innerHTML =
                templates.buttons.auxiliary + templates.buttons.primary

              //resize handle
              elements.resizeHandle = elements.footer.nextSibling

              //buttons
              elements.buttons = {}
              elements.buttons.auxiliary = elements.footer.firstChild
              elements.buttons.primary = elements.buttons.auxiliary.nextSibling
              elements.buttons.primary.innerHTML = templates.button
              elements.buttonTemplate = elements.buttons.primary.firstChild
              //remove button template
              elements.buttons.primary.removeChild(elements.buttonTemplate)

              for (var x = 0; x < instance.__internal.buttons.length; x += 1) {
                var button = instance.__internal.buttons[x]

                // add to the list of used keys.
                if (usedKeys.indexOf(button.key) < 0) {
                  usedKeys.push(button.key)
                }

                button.element = elements.buttonTemplate.cloneNode()
                button.element.innerHTML = button.text
                if (
                  typeof button.className === 'string' &&
                  button.className !== ''
                ) {
                  addClass(button.element, button.className)
                }
                for (var key in button.attrs) {
                  if (key !== 'className' && button.attrs.hasOwnProperty(key)) {
                    button.element.setAttribute(key, button.attrs[key])
                  }
                }
                if (button.scope === 'auxiliary') {
                  elements.buttons.auxiliary.appendChild(button.element)
                } else {
                  elements.buttons.primary.appendChild(button.element)
                }
              }
              //make elements pubic
              instance.elements = elements

              //save event handlers delegates
              internal.resetHandler = delegate(instance, onReset)
              internal.beginMoveHandler = delegate(instance, beginMove)
              internal.beginResizeHandler = delegate(instance, beginResize)
              internal.bringToFrontHandler = delegate(instance, bringToFront)
              internal.modalClickHandler = delegate(instance, modalClickHandler)
              internal.buttonsClickHandler = delegate(
                instance,
                buttonsClickHandler
              )
              internal.commandsClickHandler = delegate(
                instance,
                commandsClickHandler
              )
              internal.transitionInHandler = delegate(
                instance,
                handleTransitionInEvent
              )
              internal.transitionOutHandler = delegate(
                instance,
                handleTransitionOutEvent
              )

              //settings
              for (var opKey in internal.options) {
                if (setup.options[opKey] !== undefined) {
                  // if found in user options
                  instance.set(opKey, setup.options[opKey])
                } else if (alertify.defaults.hasOwnProperty(opKey)) {
                  // else if found in defaults options
                  instance.set(opKey, alertify.defaults[opKey])
                } else if (opKey === 'title') {
                  // else if title key, use alertify.defaults.glossary
                  instance.set(opKey, alertify.defaults.glossary[opKey])
                }
              }

              // allow dom customization
              if (typeof instance.build === 'function') {
                instance.build()
              }

              //invoke postinit global hook
              alertify.defaults.hooks.postinit(instance)
            }

            //add to the end of the DOM tree.
            document.body.appendChild(instance.elements.root)
          }

          /**
           * Helper: maintains scroll position
           *
           */
          var scrollX, scrollY
          function saveScrollPosition() {
            scrollX = getScrollLeft()
            scrollY = getScrollTop()
          }
          function restoreScrollPosition() {
            window.scrollTo(scrollX, scrollY)
          }

          /**
           * Helper: adds/removes no-overflow class from body
           *
           */
          function ensureNoOverflow() {
            var requiresNoOverflow = 0
            for (var x = 0; x < openDialogs.length; x += 1) {
              var instance = openDialogs[x]
              if (instance.isModal() || instance.isMaximized()) {
                requiresNoOverflow += 1
              }
            }
            if (
              requiresNoOverflow === 0 &&
              document.body.className.indexOf(classes.noOverflow) >= 0
            ) {
              //last open modal or last maximized one
              removeClass(document.body, classes.noOverflow)
              preventBodyShift(false)
            } else if (
              requiresNoOverflow > 0 &&
              document.body.className.indexOf(classes.noOverflow) < 0
            ) {
              //first open modal or first maximized one
              preventBodyShift(true)
              addClass(document.body, classes.noOverflow)
            }
          }
          var top = '',
            topScroll = 0
          /**
           * Helper: prevents body shift.
           *
           */
          function preventBodyShift(add) {
            if (alertify.defaults.preventBodyShift) {
              if (
                add &&
                document.documentElement.scrollHeight >
                  document.documentElement.clientHeight
              ) {
                //&& openDialogs[openDialogs.length-1].elements.dialog.clientHeight <= document.documentElement.clientHeight){
                topScroll = scrollY
                top = window.getComputedStyle(document.body).top
                addClass(document.body, classes.fixed)
                document.body.style.top = -scrollY + 'px'
              } else if (!add) {
                scrollY = topScroll
                document.body.style.top = top
                removeClass(document.body, classes.fixed)
                restoreScrollPosition()
              }
            }
          }

          /**
           * Sets the name of the transition used to show/hide the dialog
           *
           * @param {Object} instance The dilog instance.
           *
           */
          function updateTransition(instance, value, oldValue) {
            if (typeof oldValue === 'string') {
              removeClass(instance.elements.root, classes.prefix + oldValue)
            }
            addClass(instance.elements.root, classes.prefix + value)
            reflow = instance.elements.root.offsetWidth
          }

          /**
           * Toggles the dialog no transition
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateTransitionOff(instance) {
            if (instance.get('transitionOff')) {
              // add class
              addClass(instance.elements.root, classes.noTransition)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.noTransition)
            }
          }

          /**
           * Toggles the dialog display mode
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateDisplayMode(instance) {
            if (instance.get('modal')) {
              //make modal
              removeClass(instance.elements.root, classes.modeless)

              //only if open
              if (instance.isOpen()) {
                unbindModelessEvents(instance)

                //in case a pinned modless dialog was made modal while open.
                updateAbsPositionFix(instance)

                ensureNoOverflow()
              }
            } else {
              //make modelss
              addClass(instance.elements.root, classes.modeless)

              //only if open
              if (instance.isOpen()) {
                bindModelessEvents(instance)

                //in case pin/unpin was called while a modal is open
                updateAbsPositionFix(instance)

                ensureNoOverflow()
              }
            }
          }

          /**
           * Toggles the dialog basic view mode
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateBasicMode(instance) {
            if (instance.get('basic')) {
              // add class
              addClass(instance.elements.root, classes.basic)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.basic)
            }
          }

          /**
           * Toggles the dialog frameless view mode
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function updateFramelessMode(instance) {
            if (instance.get('frameless')) {
              // add class
              addClass(instance.elements.root, classes.frameless)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.frameless)
            }
          }

          /**
           * Helper: Brings the modeless dialog to front, attached to modeless dialogs.
           *
           * @param {Event} event Focus event
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bringToFront(event, instance) {
            // Do not bring to front if preceeded by an open modal
            var index = openDialogs.indexOf(instance)
            for (var x = index + 1; x < openDialogs.length; x += 1) {
              if (openDialogs[x].isModal()) {
                return
              }
            }

            // Bring to front by making it the last child.
            if (document.body.lastChild !== instance.elements.root) {
              document.body.appendChild(instance.elements.root)
              //also make sure its at the end of the list
              openDialogs.splice(openDialogs.indexOf(instance), 1)
              openDialogs.push(instance)
              setFocus(instance)
            }

            return false
          }

          /**
           * Helper: reflects dialogs options updates
           *
           * @param {Object} instance The dilog instance.
           * @param {String} option The updated option name.
           *
           * @return	{undefined}
           */
          function optionUpdated(instance, option, oldValue, newValue) {
            switch (option) {
              case 'title':
                instance.setHeader(newValue)
                break
              case 'modal':
                updateDisplayMode(instance)
                break
              case 'basic':
                updateBasicMode(instance)
                break
              case 'frameless':
                updateFramelessMode(instance)
                break
              case 'pinned':
                updatePinned(instance)
                break
              case 'closable':
                updateClosable(instance)
                break
              case 'maximizable':
                updateMaximizable(instance)
                break
              case 'pinnable':
                updatePinnable(instance)
                break
              case 'movable':
                updateMovable(instance)
                break
              case 'resizable':
                updateResizable(instance)
                break
              case 'padding':
                if (newValue) {
                  removeClass(instance.elements.root, classes.noPadding)
                } else if (
                  instance.elements.root.className.indexOf(classes.noPadding) <
                  0
                ) {
                  addClass(instance.elements.root, classes.noPadding)
                }
                break
              case 'overflow':
                if (newValue) {
                  removeClass(instance.elements.root, classes.noOverflow)
                } else if (
                  instance.elements.root.className.indexOf(classes.noOverflow) <
                  0
                ) {
                  addClass(instance.elements.root, classes.noOverflow)
                }
                break
              case 'transition':
                updateTransition(instance, newValue, oldValue)
                break
              case 'transitionOff':
                updateTransitionOff(instance)
                break
            }

            // internal on option updated event
            if (typeof instance.hooks.onupdate === 'function') {
              instance.hooks.onupdate.call(instance, option, oldValue, newValue)
            }
          }

          /**
           * Helper: reflects dialogs options updates
           *
           * @param {Object} instance The dilog instance.
           * @param {Object} obj The object to set/get a value on/from.
           * @param {Function} callback The callback function to call if the key was found.
           * @param {String|Object} key A string specifying a propery name or a collection of key value pairs.
           * @param {Object} value Optional, the value associated with the key (in case it was a string).
           * @param {String} option The updated option name.
           *
           * @return	{Object} result object
           *	The result objects has an 'op' property, indicating of this is a SET or GET operation.
           *		GET:
           *		- found: a flag indicating if the key was found or not.
           *		- value: the property value.
           *		SET:
           *		- items: a list of key value pairs of the properties being set.
           *				each contains:
           *					- found: a flag indicating if the key was found or not.
           *					- key: the property key.
           *					- value: the property value.
           */
          function update(instance, obj, callback, key, value) {
            var result = { op: undefined, items: [] }
            if (typeof value === 'undefined' && typeof key === 'string') {
              //get
              result.op = 'get'
              if (obj.hasOwnProperty(key)) {
                result.found = true
                result.value = obj[key]
              } else {
                result.found = false
                result.value = undefined
              }
            } else {
              var old
              //set
              result.op = 'set'
              if (typeof key === 'object') {
                //set multiple
                var args = key
                for (var prop in args) {
                  if (obj.hasOwnProperty(prop)) {
                    if (obj[prop] !== args[prop]) {
                      old = obj[prop]
                      obj[prop] = args[prop]
                      callback.call(instance, prop, old, args[prop])
                    }
                    result.items.push({
                      key: prop,
                      value: args[prop],
                      found: true
                    })
                  } else {
                    result.items.push({
                      key: prop,
                      value: args[prop],
                      found: false
                    })
                  }
                }
              } else if (typeof key === 'string') {
                //set single
                if (obj.hasOwnProperty(key)) {
                  if (obj[key] !== value) {
                    old = obj[key]
                    obj[key] = value
                    callback.call(instance, key, old, value)
                  }
                  result.items.push({ key: key, value: value, found: true })
                } else {
                  result.items.push({ key: key, value: value, found: false })
                }
              } else {
                //invalid params
                throw new Error('args must be a string or object')
              }
            }
            return result
          }

          /**
           * Triggers a close event.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function triggerClose(instance) {
            var found
            triggerCallback(instance, function (button) {
              return (found =
                instance.get('invokeOnCloseOff') !== true &&
                button.invokeOnClose === true)
            })
            //none of the buttons registered as onclose callback
            //close the dialog
            if (!found && instance.isOpen()) {
              instance.close()
            }
          }

          /**
           * Dialogs commands event handler, attached to the dialog commands element.
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function commandsClickHandler(event, instance) {
            var target = event.srcElement || event.target
            switch (target) {
              case instance.elements.commands.pin:
                if (!instance.isPinned()) {
                  pin(instance)
                } else {
                  unpin(instance)
                }
                break
              case instance.elements.commands.maximize:
                if (!instance.isMaximized()) {
                  maximize(instance)
                } else {
                  restore(instance)
                }
                break
              case instance.elements.commands.close:
                triggerClose(instance)
                break
            }
            return false
          }

          /**
           * Helper: pins the modeless dialog.
           *
           * @param {Object} instance	The dialog instance.
           *
           * @return {undefined}
           */
          function pin(instance) {
            //pin the dialog
            instance.set('pinned', true)
          }

          /**
           * Helper: unpins the modeless dialog.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function unpin(instance) {
            //unpin the dialog
            instance.set('pinned', false)
          }

          /**
           * Helper: enlarges the dialog to fill the entire screen.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function maximize(instance) {
            // allow custom `onmaximize` method
            dispatchEvent('onmaximize', instance)
            //maximize the dialog
            addClass(instance.elements.root, classes.maximized)
            if (instance.isOpen()) {
              ensureNoOverflow()
            }
            // allow custom `onmaximized` method
            dispatchEvent('onmaximized', instance)
          }

          /**
           * Helper: returns the dialog to its former size.
           *
           * @param {Object} instance	The dilog instance.
           *
           * @return {undefined}
           */
          function restore(instance) {
            // allow custom `onrestore` method
            dispatchEvent('onrestore', instance)
            //maximize the dialog
            removeClass(instance.elements.root, classes.maximized)
            if (instance.isOpen()) {
              ensureNoOverflow()
            }
            // allow custom `onrestored` method
            dispatchEvent('onrestored', instance)
          }

          /**
           * Show or hide the maximize box.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updatePinnable(instance) {
            if (instance.get('pinnable')) {
              // add class
              addClass(instance.elements.root, classes.pinnable)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.pinnable)
            }
          }

          /**
           * Helper: Fixes the absolutly positioned modal div position.
           *
           * @param {Object} instance The dialog instance.
           *
           * @return {undefined}
           */
          function addAbsPositionFix(instance) {
            var scrollLeft = getScrollLeft()
            instance.elements.modal.style.marginTop = getScrollTop() + 'px'
            instance.elements.modal.style.marginLeft = scrollLeft + 'px'
            instance.elements.modal.style.marginRight = -scrollLeft + 'px'
          }

          /**
           * Helper: Removes the absolutly positioned modal div position fix.
           *
           * @param {Object} instance The dialog instance.
           *
           * @return {undefined}
           */
          function removeAbsPositionFix(instance) {
            var marginTop = parseInt(
              instance.elements.modal.style.marginTop,
              10
            )
            var marginLeft = parseInt(
              instance.elements.modal.style.marginLeft,
              10
            )
            instance.elements.modal.style.marginTop = ''
            instance.elements.modal.style.marginLeft = ''
            instance.elements.modal.style.marginRight = ''

            if (instance.isOpen()) {
              var top = 0,
                left = 0
              if (instance.elements.dialog.style.top !== '') {
                top = parseInt(instance.elements.dialog.style.top, 10)
              }
              instance.elements.dialog.style.top =
                top + (marginTop - getScrollTop()) + 'px'

              if (instance.elements.dialog.style.left !== '') {
                left = parseInt(instance.elements.dialog.style.left, 10)
              }
              instance.elements.dialog.style.left =
                left + (marginLeft - getScrollLeft()) + 'px'
            }
          }
          /**
           * Helper: Adds/Removes the absolutly positioned modal div position fix based on its pinned setting.
           *
           * @param {Object} instance The dialog instance.
           *
           * @return {undefined}
           */
          function updateAbsPositionFix(instance) {
            // if modeless and unpinned add fix
            if (!instance.get('modal') && !instance.get('pinned')) {
              addAbsPositionFix(instance)
            } else {
              removeAbsPositionFix(instance)
            }
          }
          /**
           * Toggles the dialog position lock | modeless only.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to make it modal, false otherwise.
           *
           * @return {undefined}
           */
          function updatePinned(instance) {
            if (instance.get('pinned')) {
              removeClass(instance.elements.root, classes.unpinned)
              if (instance.isOpen()) {
                removeAbsPositionFix(instance)
              }
            } else {
              addClass(instance.elements.root, classes.unpinned)
              if (instance.isOpen() && !instance.isModal()) {
                addAbsPositionFix(instance)
              }
            }
          }

          /**
           * Show or hide the maximize box.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateMaximizable(instance) {
            if (instance.get('maximizable')) {
              // add class
              addClass(instance.elements.root, classes.maximizable)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.maximizable)
            }
          }

          /**
           * Show or hide the close box.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateClosable(instance) {
            if (instance.get('closable')) {
              // add class
              addClass(instance.elements.root, classes.closable)
              bindClosableEvents(instance)
            } else {
              // remove class
              removeClass(instance.elements.root, classes.closable)
              unbindClosableEvents(instance)
            }
          }

          var cancelClick = false, // flag to cancel click event if already handled by end resize event (the mousedown, mousemove, mouseup sequence fires a click event.).
            modalClickHandlerTS = 0 // stores last click timestamp to prevent executing the handler twice on double click.
          /**
           * Helper: closes the modal dialog when clicking the modal
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function modalClickHandler(event, instance) {
            if (
              event.timeStamp - modalClickHandlerTS > 200 &&
              (modalClickHandlerTS = event.timeStamp) &&
              !cancelClick
            ) {
              var target = event.srcElement || event.target
              if (
                instance.get('closableByDimmer') === true &&
                target === instance.elements.modal
              ) {
                triggerClose(instance)
              }
            }
            cancelClick = false
          }

          // stores last call timestamp to prevent triggering the callback twice.
          var callbackTS = 0
          // flag to cancel keyup event if already handled by click event (pressing Enter on a focusted button).
          var cancelKeyup = false
          /**
           * Helper: triggers a button callback
           *
           * @param {Object}		The dilog instance.
           * @param {Function}	Callback to check which button triggered the event.
           *
           * @return {undefined}
           */
          function triggerCallback(instance, check) {
            if (Date.now() - callbackTS > 200 && (callbackTS = Date.now())) {
              for (
                var idx = 0;
                idx < instance.__internal.buttons.length;
                idx += 1
              ) {
                var button = instance.__internal.buttons[idx]
                if (!button.element.disabled && check(button)) {
                  var closeEvent = createCloseEvent(idx, button)
                  if (typeof instance.callback === 'function') {
                    instance.callback.apply(instance, [closeEvent])
                  }
                  //close the dialog only if not canceled.
                  if (closeEvent.cancel === false) {
                    instance.close()
                  }
                  break
                }
              }
            }
          }

          /**
           * Clicks event handler, attached to the dialog footer.
           *
           * @param {Event}		DOM event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function buttonsClickHandler(event, instance) {
            var target = event.srcElement || event.target
            triggerCallback(instance, function (button) {
              // if this button caused the click, cancel keyup event
              return button.element === target && (cancelKeyup = true)
            })
          }

          /**
           * Keyup event handler, attached to the document.body
           *
           * @param {Event}		DOM event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function keyupHandler(event) {
            //hitting enter while button has focus will trigger keyup too.
            //ignore if handled by clickHandler
            if (cancelKeyup) {
              cancelKeyup = false
              return
            }
            var instance = openDialogs[openDialogs.length - 1]
            var keyCode = event.keyCode
            if (
              instance.__internal.buttons.length === 0 &&
              keyCode === keys.ESC &&
              instance.get('closable') === true
            ) {
              triggerClose(instance)
              return false
            } else if (usedKeys.indexOf(keyCode) > -1) {
              triggerCallback(instance, function (button) {
                return button.key === keyCode
              })
              return false
            }
          }
          /**
           * Keydown event handler, attached to the document.body
           *
           * @param {Event}		DOM event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function keydownHandler(event) {
            var instance = openDialogs[openDialogs.length - 1]
            var keyCode = event.keyCode
            if (keyCode === keys.LEFT || keyCode === keys.RIGHT) {
              var buttons = instance.__internal.buttons
              for (var x = 0; x < buttons.length; x += 1) {
                if (document.activeElement === buttons[x].element) {
                  switch (keyCode) {
                    case keys.LEFT:
                      buttons[(x || buttons.length) - 1].element.focus()
                      return
                    case keys.RIGHT:
                      buttons[(x + 1) % buttons.length].element.focus()
                      return
                  }
                }
              }
            } else if (
              keyCode < keys.F12 + 1 &&
              keyCode > keys.F1 - 1 &&
              usedKeys.indexOf(keyCode) > -1
            ) {
              event.preventDefault()
              event.stopPropagation()
              triggerCallback(instance, function (button) {
                return button.key === keyCode
              })
              return false
            }
          }

          /**
           * Sets focus to proper dialog element
           *
           * @param {Object} instance The dilog instance.
           * @param {Node} [resetTarget=undefined] DOM element to reset focus to.
           *
           * @return {undefined}
           */
          function setFocus(instance, resetTarget) {
            // reset target has already been determined.
            if (resetTarget) {
              resetTarget.focus()
            } else {
              // current instance focus settings
              var focus = instance.__internal.focus
              // the focus element.
              var element = focus.element

              switch (typeof focus.element) {
                // a number means a button index
                case 'number':
                  if (instance.__internal.buttons.length > focus.element) {
                    //in basic view, skip focusing the buttons.
                    if (instance.get('basic') === true) {
                      element = instance.elements.reset[0]
                    } else {
                      element =
                        instance.__internal.buttons[focus.element].element
                    }
                  }
                  break
                // a string means querySelector to select from dialog body contents.
                case 'string':
                  element = instance.elements.body.querySelector(focus.element)
                  break
                // a function should return the focus element.
                case 'function':
                  element = focus.element.call(instance)
                  break
              }

              // if no focus element, default to first reset element.
              if (
                instance.get('defaultFocusOff') === true ||
                ((typeof element === 'undefined' || element === null) &&
                  instance.__internal.buttons.length === 0)
              ) {
                element = instance.elements.reset[0]
              }
              // focus
              if (element && element.focus) {
                element.focus()
                // if selectable
                if (focus.select && element.select) {
                  element.select()
                }
              }
            }
          }

          /**
           * Focus event handler, attached to document.body and dialogs own reset links.
           * handles the focus for modal dialogs only.
           *
           * @param {Event} event DOM focus event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function onReset(event, instance) {
            // should work on last modal if triggered from document.body
            if (!instance) {
              for (var x = openDialogs.length - 1; x > -1; x -= 1) {
                if (openDialogs[x].isModal()) {
                  instance = openDialogs[x]
                  break
                }
              }
            }

            if (instance) {
              // if modal
              if (instance.isModal()) {
                // determine reset target to enable forward/backward tab cycle.
                var firstReset = instance.elements.reset[0],
                  lastReset = instance.elements.reset[1],
                  lastFocusedElement = event.relatedTarget,
                  within = instance.elements.root.contains(lastFocusedElement),
                  target = event.srcElement || event.target,
                  resetTarget

                //if the previous focused element element was outside the modal do nthing
                if (
                  /*first show */
                  (target === firstReset && !within) ||
                  /*focus cycle */
                  (target === lastReset && lastFocusedElement === firstReset)
                ) {
                  return
                } else if (target === lastReset || target === document.body) {
                  resetTarget = firstReset
                } else if (
                  target === firstReset &&
                  lastFocusedElement === lastReset
                ) {
                  resetTarget = findTabbable(instance)
                } else if (target === firstReset && within) {
                  resetTarget = findTabbable(instance, true)
                }
                // focus
                setFocus(instance, resetTarget)
              }
            }
          }
          function findTabbable(instance, last) {
            var tabbables = [].slice.call(
              instance.elements.dialog.querySelectorAll(defaults.tabbable)
            )
            if (last) {
              tabbables.reverse()
            }
            for (var x = 0; x < tabbables.length; x += 1) {
              var tabbable = tabbables[x]
              //check if visible
              if (
                !!(
                  tabbable.offsetParent ||
                  tabbable.offsetWidth ||
                  tabbable.offsetHeight ||
                  tabbable.getClientRects().length
                )
              ) {
                return tabbable
              }
            }
          }
          function recycleTab(event) {
            var instance = openDialogs[openDialogs.length - 1]
            if (instance && event.shiftKey && event.keyCode === keys.TAB) {
              instance.elements.reset[1].focus()
            }
          }
          /**
           * Transition in transitionend event handler.
           *
           * @param {Event}		TransitionEnd event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function handleTransitionInEvent(event, instance) {
            // clear the timer
            clearTimeout(instance.__internal.timerIn)

            // once transition is complete, set focus
            setFocus(instance)

            // allow handling key up after transition ended.
            cancelKeyup = false

            // allow custom `onfocus` method
            dispatchEvent('onfocus', instance)

            // unbind the event
            off(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionInHandler
            )

            removeClass(instance.elements.root, classes.animationIn)
          }

          /**
           * Transition out transitionend event handler.
           *
           * @param {Event}		TransitionEnd event object.
           * @param {Object}		The dilog instance.
           *
           * @return {undefined}
           */
          function handleTransitionOutEvent(event, instance) {
            // clear the timer
            clearTimeout(instance.__internal.timerOut)
            // unbind the event
            off(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionOutHandler
            )

            // reset move updates
            resetMove(instance)
            // reset resize updates
            resetResize(instance)

            // restore if maximized
            if (instance.isMaximized() && !instance.get('startMaximized')) {
              restore(instance)
            }

            //destory the instance
            if (typeof instance.__internal.destroy === 'function') {
              instance.__internal.destroy.apply(instance)
            }
          }
          /* Controls moving a dialog around */
          //holde the current moving instance
          var movable = null,
            //holds the current X offset when move starts
            offsetX = 0,
            //holds the current Y offset when move starts
            offsetY = 0,
            xProp = 'pageX',
            yProp = 'pageY',
            bounds = null,
            refreshTop = false,
            moveDelegate = null
          /**
           * Helper: sets the element top/left coordinates
           *
           * @param {Event} event	DOM event object.
           * @param {Node} element The element being moved.
           *
           * @return {undefined}
           */
          function moveElement(event, element) {
            var left = event[xProp] - offsetX,
              top = event[yProp] - offsetY

            if (refreshTop) {
              top -= document.body.scrollTop
            }

            element.style.left = left + 'px'
            element.style.top = top + 'px'
          }
          /**
           * Helper: sets the element top/left coordinates within screen bounds
           *
           * @param {Event} event	DOM event object.
           * @param {Node} element The element being moved.
           *
           * @return {undefined}
           */
          function moveElementBounded(event, element) {
            var left = event[xProp] - offsetX,
              top = event[yProp] - offsetY

            if (refreshTop) {
              top -= document.body.scrollTop
            }

            element.style.left =
              Math.min(bounds.maxLeft, Math.max(bounds.minLeft, left)) + 'px'
            if (refreshTop) {
              element.style.top =
                Math.min(bounds.maxTop, Math.max(bounds.minTop, top)) + 'px'
            } else {
              element.style.top = Math.max(bounds.minTop, top) + 'px'
            }
          }

          /**
           * Triggers the start of a move event, attached to the header element mouse down event.
           * Adds no-selection class to the body, disabling selection while moving.
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {Boolean} false
           */
          function beginMove(event, instance) {
            if (
              resizable === null &&
              !instance.isMaximized() &&
              instance.get('movable')
            ) {
              var eventSrc,
                left = 0,
                top = 0
              if (event.type === 'touchstart') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
                xProp = 'clientX'
                yProp = 'clientY'
              } else if (event.button === 0) {
                eventSrc = event
              }

              if (eventSrc) {
                var element = instance.elements.dialog
                addClass(element, classes.capture)

                if (element.style.left) {
                  left = parseInt(element.style.left, 10)
                }

                if (element.style.top) {
                  top = parseInt(element.style.top, 10)
                }

                offsetX = eventSrc[xProp] - left
                offsetY = eventSrc[yProp] - top

                if (instance.isModal()) {
                  offsetY += instance.elements.modal.scrollTop
                } else if (instance.isPinned()) {
                  offsetY -= document.body.scrollTop
                }

                if (instance.get('moveBounded')) {
                  var current = element,
                    offsetLeft = -left,
                    offsetTop = -top

                  //calc offset
                  do {
                    offsetLeft += current.offsetLeft
                    offsetTop += current.offsetTop
                  } while ((current = current.offsetParent))

                  bounds = {
                    maxLeft: offsetLeft,
                    minLeft: -offsetLeft,
                    maxTop:
                      document.documentElement.clientHeight -
                      element.clientHeight -
                      offsetTop,
                    minTop: -offsetTop
                  }
                  moveDelegate = moveElementBounded
                } else {
                  bounds = null
                  moveDelegate = moveElement
                }

                // allow custom `onmove` method
                dispatchEvent('onmove', instance)

                refreshTop = !instance.isModal() && instance.isPinned()
                movable = instance
                moveDelegate(eventSrc, element)
                addClass(document.body, classes.noSelection)
                return false
              }
            }
          }

          /**
           * The actual move handler,  attached to document.body mousemove event.
           *
           * @param {Event} event	DOM event object.
           *
           * @return {undefined}
           */
          function move(event) {
            if (movable) {
              var eventSrc
              if (event.type === 'touchmove') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
              } else if (event.button === 0) {
                eventSrc = event
              }
              if (eventSrc) {
                moveDelegate(eventSrc, movable.elements.dialog)
              }
            }
          }

          /**
           * Triggers the end of a move event,  attached to document.body mouseup event.
           * Removes no-selection class from document.body, allowing selection.
           *
           * @return {undefined}
           */
          function endMove() {
            if (movable) {
              var instance = movable
              movable = bounds = null
              removeClass(document.body, classes.noSelection)
              removeClass(instance.elements.dialog, classes.capture)
              // allow custom `onmoved` method
              dispatchEvent('onmoved', instance)
            }
          }

          /**
           * Resets any changes made by moving the element to its original state,
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function resetMove(instance) {
            movable = null
            var element = instance.elements.dialog
            element.style.left = element.style.top = ''
          }

          /**
           * Updates the dialog move behavior.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateMovable(instance) {
            if (instance.get('movable')) {
              // add class
              addClass(instance.elements.root, classes.movable)
              if (instance.isOpen()) {
                bindMovableEvents(instance)
              }
            } else {
              //reset
              resetMove(instance)
              // remove class
              removeClass(instance.elements.root, classes.movable)
              if (instance.isOpen()) {
                unbindMovableEvents(instance)
              }
            }
          }

          /* Controls moving a dialog around */
          //holde the current instance being resized
          var resizable = null,
            //holds the staring left offset when resize starts.
            startingLeft = Number.Nan,
            //holds the staring width when resize starts.
            startingWidth = 0,
            //holds the initial width when resized for the first time.
            minWidth = 0,
            //holds the offset of the resize handle.
            handleOffset = 0
          /**
           * Helper: sets the element width/height and updates left coordinate if neccessary.
           *
           * @param {Event} event	DOM mousemove event object.
           * @param {Node} element The element being moved.
           * @param {Boolean} pinned A flag indicating if the element being resized is pinned to the screen.
           *
           * @return {undefined}
           */
          function resizeElement(event, element, pageRelative) {
            //calculate offsets from 0,0
            var current = element
            var offsetLeft = 0
            var offsetTop = 0
            do {
              offsetLeft += current.offsetLeft
              offsetTop += current.offsetTop
            } while ((current = current.offsetParent))

            // determine X,Y coordinates.
            var X, Y
            if (pageRelative === true) {
              X = event.pageX
              Y = event.pageY
            } else {
              X = event.clientX
              Y = event.clientY
            }
            // rtl handling
            var isRTL = isRightToLeft()
            if (isRTL) {
              // reverse X
              X = document.body.offsetWidth - X
              // if has a starting left, calculate offsetRight
              if (!isNaN(startingLeft)) {
                offsetLeft =
                  document.body.offsetWidth - offsetLeft - element.offsetWidth
              }
            }

            // set width/height
            element.style.height = Y - offsetTop + handleOffset + 'px'
            element.style.width = X - offsetLeft + handleOffset + 'px'

            // if the element being resized has a starting left, maintain it.
            // the dialog is centered, divide by half the offset to maintain the margins.
            if (!isNaN(startingLeft)) {
              var diff = Math.abs(element.offsetWidth - startingWidth) * 0.5
              if (isRTL) {
                //negate the diff, why?
                //when growing it should decrease left
                //when shrinking it should increase left
                diff *= -1
              }
              if (element.offsetWidth > startingWidth) {
                //growing
                element.style.left = startingLeft + diff + 'px'
              } else if (element.offsetWidth >= minWidth) {
                //shrinking
                element.style.left = startingLeft - diff + 'px'
              }
            }
          }

          /**
           * Triggers the start of a resize event, attached to the resize handle element mouse down event.
           * Adds no-selection class to the body, disabling selection while moving.
           *
           * @param {Event} event	DOM event object.
           * @param {Object} instance The dilog instance.
           *
           * @return {Boolean} false
           */
          function beginResize(event, instance) {
            if (!instance.isMaximized()) {
              var eventSrc
              if (event.type === 'touchstart') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
              } else if (event.button === 0) {
                eventSrc = event
              }
              if (eventSrc) {
                // allow custom `onresize` method
                dispatchEvent('onresize', instance)

                resizable = instance
                handleOffset = instance.elements.resizeHandle.offsetHeight / 2
                var element = instance.elements.dialog
                addClass(element, classes.capture)
                startingLeft = parseInt(element.style.left, 10)
                element.style.height = element.offsetHeight + 'px'
                element.style.minHeight =
                  instance.elements.header.offsetHeight +
                  instance.elements.footer.offsetHeight +
                  'px'
                element.style.width =
                  (startingWidth = element.offsetWidth) + 'px'

                if (element.style.maxWidth !== 'none') {
                  element.style.minWidth =
                    (minWidth = element.offsetWidth) + 'px'
                }
                element.style.maxWidth = 'none'
                addClass(document.body, classes.noSelection)
                return false
              }
            }
          }

          /**
           * The actual resize handler,  attached to document.body mousemove event.
           *
           * @param {Event} event	DOM event object.
           *
           * @return {undefined}
           */
          function resize(event) {
            if (resizable) {
              var eventSrc
              if (event.type === 'touchmove') {
                event.preventDefault()
                eventSrc = event.targetTouches[0]
              } else if (event.button === 0) {
                eventSrc = event
              }
              if (eventSrc) {
                resizeElement(
                  eventSrc,
                  resizable.elements.dialog,
                  !resizable.get('modal') && !resizable.get('pinned')
                )
              }
            }
          }

          /**
           * Triggers the end of a resize event,  attached to document.body mouseup event.
           * Removes no-selection class from document.body, allowing selection.
           *
           * @return {undefined}
           */
          function endResize() {
            if (resizable) {
              var instance = resizable
              resizable = null
              removeClass(document.body, classes.noSelection)
              removeClass(instance.elements.dialog, classes.capture)
              cancelClick = true
              // allow custom `onresized` method
              dispatchEvent('onresized', instance)
            }
          }

          /**
           * Resets any changes made by resizing the element to its original state.
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function resetResize(instance) {
            resizable = null
            var element = instance.elements.dialog
            if (element.style.maxWidth === 'none') {
              //clear inline styles.
              element.style.maxWidth =
                element.style.minWidth =
                element.style.width =
                element.style.height =
                element.style.minHeight =
                element.style.left =
                  ''
              //reset variables.
              startingLeft = Number.Nan
              startingWidth = minWidth = handleOffset = 0
            }
          }

          /**
           * Updates the dialog move behavior.
           *
           * @param {Object} instance The dilog instance.
           * @param {Boolean} on True to add the behavior, removes it otherwise.
           *
           * @return {undefined}
           */
          function updateResizable(instance) {
            if (instance.get('resizable')) {
              // add class
              addClass(instance.elements.root, classes.resizable)
              if (instance.isOpen()) {
                bindResizableEvents(instance)
              }
            } else {
              //reset
              resetResize(instance)
              // remove class
              removeClass(instance.elements.root, classes.resizable)
              if (instance.isOpen()) {
                unbindResizableEvents(instance)
              }
            }
          }

          /**
           * Reset move/resize on window resize.
           *
           * @param {Event} event	window resize event object.
           *
           * @return {undefined}
           */
          function windowResize(/*event*/) {
            for (var x = 0; x < openDialogs.length; x += 1) {
              var instance = openDialogs[x]
              if (instance.get('autoReset')) {
                resetMove(instance)
                resetResize(instance)
              }
            }
          }
          /**
           * Bind dialogs events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindEvents(instance) {
            // if first dialog, hook global handlers
            if (openDialogs.length === 1) {
              //global
              on(window, 'resize', windowResize)
              on(document.body, 'keyup', keyupHandler)
              on(document.body, 'keydown', keydownHandler)
              on(document.body, 'focus', onReset)

              //move
              on(document.documentElement, 'mousemove', move)
              on(document.documentElement, 'touchmove', move, false, false)
              on(document.documentElement, 'mouseup', endMove)
              on(document.documentElement, 'touchend', endMove)
              //resize
              on(document.documentElement, 'mousemove', resize)
              on(document.documentElement, 'touchmove', resize, false, false)
              on(document.documentElement, 'mouseup', endResize)
              on(document.documentElement, 'touchend', endResize)
            }

            // common events
            on(
              instance.elements.commands.container,
              'click',
              instance.__internal.commandsClickHandler
            )
            on(
              instance.elements.footer,
              'click',
              instance.__internal.buttonsClickHandler
            )
            on(
              instance.elements.reset[0],
              'focusin',
              instance.__internal.resetHandler
            )
            on(instance.elements.reset[0], 'keydown', recycleTab)
            on(
              instance.elements.reset[1],
              'focusin',
              instance.__internal.resetHandler
            )

            //prevent handling key up when dialog is being opened by a key stroke.
            cancelKeyup = true
            // hook in transition handler
            on(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionInHandler
            )

            // modelss only events
            if (!instance.get('modal')) {
              bindModelessEvents(instance)
            }

            // resizable
            if (instance.get('resizable')) {
              bindResizableEvents(instance)
            }

            // movable
            if (instance.get('movable')) {
              bindMovableEvents(instance)
            }
          }

          /**
           * Unbind dialogs events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindEvents(instance) {
            // if last dialog, remove global handlers
            if (openDialogs.length === 1) {
              //global
              off(window, 'resize', windowResize)
              off(document.body, 'keyup', keyupHandler)
              off(document.body, 'keydown', keydownHandler)
              off(document.body, 'focus', onReset)
              //move
              off(document.documentElement, 'mousemove', move)
              off(document.documentElement, 'mouseup', endMove)
              //resize
              off(document.documentElement, 'mousemove', resize)
              off(document.documentElement, 'mouseup', endResize)
            }

            // common events
            off(
              instance.elements.commands.container,
              'click',
              instance.__internal.commandsClickHandler
            )
            off(
              instance.elements.footer,
              'click',
              instance.__internal.buttonsClickHandler
            )
            off(
              instance.elements.reset[0],
              'focusin',
              instance.__internal.resetHandler
            )
            off(instance.elements.reset[0], 'keydown', recycleTab)
            off(
              instance.elements.reset[1],
              'focusin',
              instance.__internal.resetHandler
            )

            // hook out transition handler
            on(
              instance.elements.dialog,
              transition.type,
              instance.__internal.transitionOutHandler
            )

            // modelss only events
            if (!instance.get('modal')) {
              unbindModelessEvents(instance)
            }

            // movable
            if (instance.get('movable')) {
              unbindMovableEvents(instance)
            }

            // resizable
            if (instance.get('resizable')) {
              unbindResizableEvents(instance)
            }
          }

          /**
           * Bind modeless specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindModelessEvents(instance) {
            on(
              instance.elements.dialog,
              'focus',
              instance.__internal.bringToFrontHandler,
              true
            )
          }

          /**
           * Unbind modeless specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindModelessEvents(instance) {
            off(
              instance.elements.dialog,
              'focus',
              instance.__internal.bringToFrontHandler,
              true
            )
          }

          /**
           * Bind movable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindMovableEvents(instance) {
            on(
              instance.elements.header,
              'mousedown',
              instance.__internal.beginMoveHandler
            )
            on(
              instance.elements.header,
              'touchstart',
              instance.__internal.beginMoveHandler,
              false,
              false
            )
          }

          /**
           * Unbind movable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindMovableEvents(instance) {
            off(
              instance.elements.header,
              'mousedown',
              instance.__internal.beginMoveHandler
            )
            off(
              instance.elements.header,
              'touchstart',
              instance.__internal.beginMoveHandler,
              false,
              false
            )
          }

          /**
           * Bind resizable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindResizableEvents(instance) {
            on(
              instance.elements.resizeHandle,
              'mousedown',
              instance.__internal.beginResizeHandler
            )
            on(
              instance.elements.resizeHandle,
              'touchstart',
              instance.__internal.beginResizeHandler,
              false,
              false
            )
          }

          /**
           * Unbind resizable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindResizableEvents(instance) {
            off(
              instance.elements.resizeHandle,
              'mousedown',
              instance.__internal.beginResizeHandler
            )
            off(
              instance.elements.resizeHandle,
              'touchstart',
              instance.__internal.beginResizeHandler,
              false,
              false
            )
          }

          /**
           * Bind closable events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function bindClosableEvents(instance) {
            on(
              instance.elements.modal,
              'click',
              instance.__internal.modalClickHandler
            )
          }

          /**
           * Unbind closable specific events
           *
           * @param {Object} instance The dilog instance.
           *
           * @return {undefined}
           */
          function unbindClosableEvents(instance) {
            off(
              instance.elements.modal,
              'click',
              instance.__internal.modalClickHandler
            )
          }
          // dialog API
          return {
            __init: initialize,
            /**
             * Check if dialog is currently open
             *
             * @return {Boolean}
             */
            isOpen: function () {
              return this.__internal.isOpen
            },
            isModal: function () {
              return this.elements.root.className.indexOf(classes.modeless) < 0
            },
            isMaximized: function () {
              return (
                this.elements.root.className.indexOf(classes.maximized) > -1
              )
            },
            isPinned: function () {
              return this.elements.root.className.indexOf(classes.unpinned) < 0
            },
            maximize: function () {
              if (!this.isMaximized()) {
                maximize(this)
              }
              return this
            },
            restore: function () {
              if (this.isMaximized()) {
                restore(this)
              }
              return this
            },
            pin: function () {
              if (!this.isPinned()) {
                pin(this)
              }
              return this
            },
            unpin: function () {
              if (this.isPinned()) {
                unpin(this)
              }
              return this
            },
            bringToFront: function () {
              bringToFront(null, this)
              return this
            },
            /**
             * Move the dialog to a specific x/y coordinates
             *
             * @param {Number} x    The new dialog x coordinate in pixels.
             * @param {Number} y    The new dialog y coordinate in pixels.
             *
             * @return {Object} The dialog instance.
             */
            moveTo: function (x, y) {
              if (!isNaN(x) && !isNaN(y)) {
                // allow custom `onmove` method
                dispatchEvent('onmove', this)

                var element = this.elements.dialog,
                  current = element,
                  offsetLeft = 0,
                  offsetTop = 0

                //subtract existing left,top
                if (element.style.left) {
                  offsetLeft -= parseInt(element.style.left, 10)
                }
                if (element.style.top) {
                  offsetTop -= parseInt(element.style.top, 10)
                }
                //calc offset
                do {
                  offsetLeft += current.offsetLeft
                  offsetTop += current.offsetTop
                } while ((current = current.offsetParent))

                //calc left, top
                var left = x - offsetLeft
                var top = y - offsetTop

                //// rtl handling
                if (isRightToLeft()) {
                  left *= -1
                }

                element.style.left = left + 'px'
                element.style.top = top + 'px'

                // allow custom `onmoved` method
                dispatchEvent('onmoved', this)
              }
              return this
            },
            /**
             * Resize the dialog to a specific width/height (the dialog must be 'resizable').
             * The dialog can be resized to:
             *  A minimum width equal to the initial display width
             *  A minimum height equal to the sum of header/footer heights.
             *
             *
             * @param {Number or String} width    The new dialog width in pixels or in percent.
             * @param {Number or String} height   The new dialog height in pixels or in percent.
             *
             * @return {Object} The dialog instance.
             */
            resizeTo: function (width, height) {
              var w = parseFloat(width),
                h = parseFloat(height),
                regex = /(\d*\.\d+|\d+)%/
              if (!isNaN(w) && !isNaN(h) && this.get('resizable') === true) {
                // allow custom `onresize` method
                dispatchEvent('onresize', this)

                if (('' + width).match(regex)) {
                  w = (w / 100) * document.documentElement.clientWidth
                }

                if (('' + height).match(regex)) {
                  h = (h / 100) * document.documentElement.clientHeight
                }

                var element = this.elements.dialog
                if (element.style.maxWidth !== 'none') {
                  element.style.minWidth =
                    (minWidth = element.offsetWidth) + 'px'
                }
                element.style.maxWidth = 'none'
                element.style.minHeight =
                  this.elements.header.offsetHeight +
                  this.elements.footer.offsetHeight +
                  'px'
                element.style.width = w + 'px'
                element.style.height = h + 'px'

                // allow custom `onresized` method
                dispatchEvent('onresized', this)
              }
              return this
            },
            /**
             * Gets or Sets dialog settings/options
             *
             * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
             * @param {Object} value Optional, the value associated with the key (in case it was a string).
             *
             * @return {undefined}
             */
            setting: function (key, value) {
              var self = this
              var result = update(
                this,
                this.__internal.options,
                function (k, o, n) {
                  optionUpdated(self, k, o, n)
                },
                key,
                value
              )
              if (result.op === 'get') {
                if (result.found) {
                  return result.value
                } else if (typeof this.settings !== 'undefined') {
                  return update(
                    this,
                    this.settings,
                    this.settingUpdated || function () {},
                    key,
                    value
                  ).value
                } else {
                  return undefined
                }
              } else if (result.op === 'set') {
                if (result.items.length > 0) {
                  var callback = this.settingUpdated || function () {}
                  for (var x = 0; x < result.items.length; x += 1) {
                    var item = result.items[x]
                    if (!item.found && typeof this.settings !== 'undefined') {
                      update(
                        this,
                        this.settings,
                        callback,
                        item.key,
                        item.value
                      )
                    }
                  }
                }
                return this
              }
            },
            /**
             * [Alias] Sets dialog settings/options
             */
            set: function (key, value) {
              this.setting(key, value)
              return this
            },
            /**
             * [Alias] Gets dialog settings/options
             */
            get: function (key) {
              return this.setting(key)
            },
            /**
             * Sets dialog header
             * @content {string or element}
             *
             * @return {undefined}
             */
            setHeader: function (content) {
              if (typeof content === 'string') {
                clearContents(this.elements.header)
                this.elements.header.innerHTML = content
              } else if (
                content instanceof window.HTMLElement &&
                this.elements.header.firstChild !== content
              ) {
                clearContents(this.elements.header)
                this.elements.header.appendChild(content)
              }
              return this
            },
            /**
             * Sets dialog contents
             * @content {string or element}
             *
             * @return {undefined}
             */
            setContent: function (content) {
              if (typeof content === 'string') {
                clearContents(this.elements.content)
                this.elements.content.innerHTML = content
              } else if (
                content instanceof window.HTMLElement &&
                this.elements.content.firstChild !== content
              ) {
                clearContents(this.elements.content)
                this.elements.content.appendChild(content)
              }
              return this
            },
            /**
             * Show the dialog as modal
             *
             * @return {Object} the dialog instance.
             */
            showModal: function (className) {
              return this.show(true, className)
            },
            /**
             * Show the dialog
             *
             * @return {Object} the dialog instance.
             */
            show: function (modal, className) {
              // ensure initialization
              initialize(this)

              if (!this.__internal.isOpen) {
                // add to open dialogs
                this.__internal.isOpen = true
                openDialogs.push(this)

                // save last focused element
                if (alertify.defaults.maintainFocus) {
                  this.__internal.activeElement = document.activeElement
                }

                // set tabindex attribute on body element this allows script to give it focusable
                if (!document.body.hasAttribute('tabindex')) {
                  document.body.setAttribute('tabindex', (tabindex = '0'))
                }

                //allow custom dom manipulation updates before showing the dialog.
                if (typeof this.prepare === 'function') {
                  this.prepare()
                }

                bindEvents(this)

                if (modal !== undefined) {
                  this.set('modal', modal)
                }

                //save scroll to prevent document jump
                saveScrollPosition()

                ensureNoOverflow()

                // allow custom dialog class on show
                if (typeof className === 'string' && className !== '') {
                  this.__internal.className = className
                  addClass(this.elements.root, className)
                }

                // maximize if start maximized
                if (this.get('startMaximized')) {
                  this.maximize()
                } else if (this.isMaximized()) {
                  restore(this)
                }

                updateAbsPositionFix(this)
                this.elements.root.removeAttribute('style')
                removeClass(this.elements.root, classes.animationOut)
                addClass(this.elements.root, classes.animationIn)

                // set 1s fallback in case transition event doesn't fire
                clearTimeout(this.__internal.timerIn)
                this.__internal.timerIn = setTimeout(
                  this.__internal.transitionInHandler,
                  transition.supported ? 1000 : 100
                )

                if (isSafari) {
                  // force desktop safari reflow
                  var root = this.elements.root
                  root.style.display = 'none'
                  setTimeout(function () {
                    root.style.display = 'block'
                  }, 0)
                }

                //reflow
                reflow = this.elements.root.offsetWidth

                // show dialog
                removeClass(this.elements.root, classes.hidden)

                //restore scroll to prevent document jump
                restoreScrollPosition()

                // internal on show event
                if (typeof this.hooks.onshow === 'function') {
                  this.hooks.onshow.call(this)
                }

                // allow custom `onshow` method
                dispatchEvent('onshow', this)
              } else {
                // reset move updates
                resetMove(this)
                // reset resize updates
                resetResize(this)
                // shake the dialog to indicate its already open
                addClass(this.elements.dialog, classes.shake)
                var self = this
                setTimeout(function () {
                  removeClass(self.elements.dialog, classes.shake)
                }, 200)
              }
              return this
            },
            /**
             * Close the dialog
             *
             * @return {Object} The dialog instance
             */
            close: function () {
              if (this.__internal.isOpen) {
                // custom `onclosing` event
                if (dispatchEvent('onclosing', this) !== false) {
                  unbindEvents(this)

                  removeClass(this.elements.root, classes.animationIn)
                  addClass(this.elements.root, classes.animationOut)

                  // set 1s fallback in case transition event doesn't fire
                  clearTimeout(this.__internal.timerOut)
                  this.__internal.timerOut = setTimeout(
                    this.__internal.transitionOutHandler,
                    transition.supported ? 1000 : 100
                  )
                  // hide dialog
                  addClass(this.elements.root, classes.hidden)
                  //reflow
                  reflow = this.elements.modal.offsetWidth

                  // return focus to the last active element
                  if (
                    alertify.defaults.maintainFocus &&
                    this.__internal.activeElement
                  ) {
                    this.__internal.activeElement.focus()
                    this.__internal.activeElement = null
                  }

                  // remove custom dialog class on hide
                  if (
                    typeof this.__internal.className !== 'undefined' &&
                    this.__internal.className !== ''
                  ) {
                    removeClass(this.elements.root, this.__internal.className)
                  }

                  // internal on close event
                  if (typeof this.hooks.onclose === 'function') {
                    this.hooks.onclose.call(this)
                  }

                  // allow custom `onclose` method
                  dispatchEvent('onclose', this)

                  //remove from open dialogs
                  openDialogs.splice(openDialogs.indexOf(this), 1)
                  this.__internal.isOpen = false

                  ensureNoOverflow()
                }
              }
              // last dialog and tab index was set by us, remove it.
              if (!openDialogs.length && tabindex === '0') {
                document.body.removeAttribute('tabindex')
              }
              return this
            },
            /**
             * Close all open dialogs except this.
             *
             * @return {undefined}
             */
            closeOthers: function () {
              alertify.closeAll(this)
              return this
            },
            /**
             * Destroys this dialog instance
             *
             * @return {undefined}
             */
            destroy: function () {
              if (this.__internal) {
                if (this.__internal.isOpen) {
                  //mark dialog for destruction, this will be called on tranistionOut event.
                  this.__internal.destroy = function () {
                    destruct(this, initialize)
                  }
                  //close the dialog to unbind all events.
                  this.close()
                } else if (!this.__internal.destroy) {
                  destruct(this, initialize)
                }
              }
              return this
            }
          }
        })()
        var notifier = (function () {
          var reflow,
            element,
            openInstances = [],
            classes = defaults.notifier.classes,
            baseClass = classes.base
          /**
           * Helper: initializes the notifier instance
           *
           */
          function initialize(instance) {
            if (!instance.__internal) {
              instance.__internal = {
                position: alertify.defaults.notifier.position,
                delay: alertify.defaults.notifier.delay
              }

              element = document.createElement('DIV')
              var transitionOff =
                'transitionOff' in defaults.notifier
                  ? defaults.notifier.transitionOff
                  : defaults.transitionOff
              if (transitionOff) {
                baseClass = classes.base + ' ajs-no-transition'
              }
              updatePosition(instance)
            }

            //add to DOM tree.
            if (element.parentNode !== document.body) {
              document.body.appendChild(element)
            }
          }

          function pushInstance(instance) {
            instance.__internal.pushed = true
            openInstances.push(instance)
          }
          function popInstance(instance) {
            openInstances.splice(openInstances.indexOf(instance), 1)
            instance.__internal.pushed = false
          }
          /**
           * Helper: update the notifier instance position
           *
           */
          function updatePosition(instance) {
            element.className = baseClass
            switch (instance.__internal.position) {
              case 'top-right':
                addClass(element, classes.top + ' ' + classes.right)
                break
              case 'top-left':
                addClass(element, classes.top + ' ' + classes.left)
                break
              case 'top-center':
                addClass(element, classes.top + ' ' + classes.center)
                break
              case 'bottom-left':
                addClass(element, classes.bottom + ' ' + classes.left)
                break
              case 'bottom-center':
                addClass(element, classes.bottom + ' ' + classes.center)
                break

              default:
              case 'bottom-right':
                addClass(element, classes.bottom + ' ' + classes.right)
                break
            }
          }

          /**
           * creates a new notification message
           *
           * @param  {DOMElement} message	The notifier message element
           * @param  {Number} wait   Time (in ms) to wait before the message is dismissed, a value of 0 means keep open till clicked.
           * @param  {Function} callback A callback function to be invoked when the message is dismissed.
           *
           * @return {undefined}
           */
          function create(div, callback) {
            function clickDelegate(event, instance) {
              if (
                !instance.__internal.closeButton ||
                event.target.getAttribute('data-close') === 'true'
              ) {
                instance.dismiss(true)
              }
            }

            function transitionDone(event, instance) {
              // unbind event
              off(instance.element, transition.type, transitionDone)
              // remove the message
              element.removeChild(instance.element)
            }

            function initialize(instance) {
              if (!instance.__internal) {
                instance.__internal = {
                  pushed: false,
                  delay: undefined,
                  timer: undefined,
                  clickHandler: undefined,
                  transitionEndHandler: undefined,
                  transitionTimeout: undefined
                }
                instance.__internal.clickHandler = delegate(
                  instance,
                  clickDelegate
                )
                instance.__internal.transitionEndHandler = delegate(
                  instance,
                  transitionDone
                )
              }
              return instance
            }
            function clearTimers(instance) {
              clearTimeout(instance.__internal.timer)
              clearTimeout(instance.__internal.transitionTimeout)
            }
            return initialize({
              /* notification DOM element*/
              element: div,
              /*
               * Pushes a notification message
               * @param {string or DOMElement} content The notification message content
               * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
               *
               */
              push: function (_content, _wait) {
                if (!this.__internal.pushed) {
                  pushInstance(this)
                  clearTimers(this)

                  var content, wait
                  switch (arguments.length) {
                    case 0:
                      wait = this.__internal.delay
                      break
                    case 1:
                      if (typeof _content === 'number') {
                        wait = _content
                      } else {
                        content = _content
                        wait = this.__internal.delay
                      }
                      break
                    case 2:
                      content = _content
                      wait = _wait
                      break
                  }
                  this.__internal.closeButton =
                    alertify.defaults.notifier.closeButton
                  // set contents
                  if (typeof content !== 'undefined') {
                    this.setContent(content)
                  }
                  // append or insert
                  if (notifier.__internal.position.indexOf('top') < 0) {
                    element.appendChild(this.element)
                  } else {
                    element.insertBefore(this.element, element.firstChild)
                  }
                  reflow = this.element.offsetWidth
                  addClass(this.element, classes.visible)
                  // attach click event
                  on(this.element, 'click', this.__internal.clickHandler)
                  return this.delay(wait)
                }
                return this
              },
              /*
               * {Function} callback function to be invoked before dismissing the notification message.
               * Remarks: A return value === 'false' will cancel the dismissal
               *
               */
              ondismiss: function () {},
              /*
               * {Function} callback function to be invoked when the message is dismissed.
               *
               */
              callback: callback,
              /*
               * Dismisses the notification message
               * @param {Boolean} clicked A flag indicating if the dismissal was caused by a click.
               *
               */
              dismiss: function (clicked) {
                if (this.__internal.pushed) {
                  clearTimers(this)
                  if (
                    !(
                      typeof this.ondismiss === 'function' &&
                      this.ondismiss.call(this) === false
                    )
                  ) {
                    //detach click event
                    off(this.element, 'click', this.__internal.clickHandler)
                    // ensure element exists
                    if (
                      typeof this.element !== 'undefined' &&
                      this.element.parentNode === element
                    ) {
                      //transition end or fallback
                      this.__internal.transitionTimeout = setTimeout(
                        this.__internal.transitionEndHandler,
                        transition.supported ? 1000 : 100
                      )
                      removeClass(this.element, classes.visible)

                      // custom callback on dismiss
                      if (typeof this.callback === 'function') {
                        this.callback.call(this, clicked)
                      }
                    }
                    popInstance(this)
                  }
                }
                return this
              },
              /*
               * Delays the notification message dismissal
               * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
               *
               */
              delay: function (wait) {
                clearTimers(this)
                this.__internal.delay =
                  typeof wait !== 'undefined' && !isNaN(+wait)
                    ? +wait
                    : notifier.__internal.delay
                if (this.__internal.delay > 0) {
                  var self = this
                  this.__internal.timer = setTimeout(function () {
                    self.dismiss()
                  }, this.__internal.delay * 1000)
                }
                return this
              },
              /*
               * Sets the notification message contents
               * @param {string or DOMElement} content The notification message content
               *
               */
              setContent: function (content) {
                if (typeof content === 'string') {
                  clearContents(this.element)
                  this.element.innerHTML = content
                } else if (
                  content instanceof window.HTMLElement &&
                  this.element.firstChild !== content
                ) {
                  clearContents(this.element)
                  this.element.appendChild(content)
                }
                if (this.__internal.closeButton) {
                  var close = document.createElement('span')
                  addClass(close, classes.close)
                  close.setAttribute('data-close', true)
                  this.element.appendChild(close)
                }
                return this
              },
              /*
               * Dismisses all open notifications except this.
               *
               */
              dismissOthers: function () {
                notifier.dismissAll(this)
                return this
              }
            })
          }

          //notifier api
          return {
            /**
             * Gets or Sets notifier settings.
             *
             * @param {string} key The setting name
             * @param {Variant} value The setting value.
             *
             * @return {Object}	if the called as a setter, return the notifier instance.
             */
            setting: function (key, value) {
              //ensure init
              initialize(this)

              if (typeof value === 'undefined') {
                //get
                return this.__internal[key]
              } else {
                //set
                switch (key) {
                  case 'position':
                    this.__internal.position = value
                    updatePosition(this)
                    break
                  case 'delay':
                    this.__internal.delay = value
                    break
                }
              }
              return this
            },
            /**
             * [Alias] Sets dialog settings/options
             */
            set: function (key, value) {
              this.setting(key, value)
              return this
            },
            /**
             * [Alias] Gets dialog settings/options
             */
            get: function (key) {
              return this.setting(key)
            },
            /**
             * Creates a new notification message
             *
             * @param {string} type The type of notification message (simply a CSS class name 'ajs-{type}' to be added).
             * @param {Function} callback  A callback function to be invoked when the message is dismissed.
             *
             * @return {undefined}
             */
            create: function (type, callback) {
              //ensure notifier init
              initialize(this)
              //create new notification message
              var div = document.createElement('div')
              div.className =
                classes.message +
                (typeof type === 'string' && type !== ''
                  ? ' ' + classes.prefix + type
                  : '')
              return create(div, callback)
            },
            /**
             * Dismisses all open notifications.
             *
             * @param {Object} excpet [optional] The notification object to exclude from dismissal.
             *
             */
            dismissAll: function (except) {
              var clone = openInstances.slice(0)
              for (var x = 0; x < clone.length; x += 1) {
                var instance = clone[x]
                if (except === undefined || except !== instance) {
                  instance.dismiss()
                }
              }
            }
          }
        })()

        /**
         * Alertify public API
         * This contains everything that is exposed through the alertify object.
         *
         * @return {Object}
         */
        function Alertify() {
          // holds a references of created dialogs
          var dialogs = {}

          /**
           * Extends a given prototype by merging properties from base into sub.
           *
           * @sub {Object} sub The prototype being overwritten.
           * @base {Object} base The prototype being written.
           *
           * @return {Object} The extended prototype.
           */
          function extend(sub, base) {
            // copy dialog pototype over definition.
            for (var prop in base) {
              if (base.hasOwnProperty(prop)) {
                sub[prop] = base[prop]
              }
            }
            return sub
          }

          /**
           * Helper: returns a dialog instance from saved dialogs.
           * and initializes the dialog if its not already initialized.
           *
           * @name {String} name The dialog name.
           *
           * @return {Object} The dialog instance.
           */
          function get_dialog(name) {
            var dialog = dialogs[name].dialog
            //initialize the dialog if its not already initialized.
            if (dialog && typeof dialog.__init === 'function') {
              dialog.__init(dialog)
            }
            return dialog
          }

          /**
           * Helper:  registers a new dialog definition.
           *
           * @name {String} name The dialog name.
           * @Factory {Function} Factory a function resposible for creating dialog prototype.
           * @transient {Boolean} transient True to create a new dialog instance each time the dialog is invoked, false otherwise.
           * @base {String} base the name of another dialog to inherit from.
           *
           * @return {Object} The dialog definition.
           */
          function register(name, Factory, transient, base) {
            var definition = {
              dialog: null,
              factory: Factory
            }

            //if this is based on an existing dialog, create a new definition
            //by applying the new protoype over the existing one.
            if (base !== undefined) {
              definition.factory = function () {
                return extend(new dialogs[base].factory(), new Factory())
              }
            }

            if (!transient) {
              //create a new definition based on dialog
              definition.dialog = extend(new definition.factory(), dialog)
            }
            return (dialogs[name] = definition)
          }

          return {
            /**
             * Alertify defaults
             *
             * @type {Object}
             */
            defaults: defaults,
            /**
             * Dialogs factory
             *
             * @param {string}      Dialog name.
             * @param {Function}    A Dialog factory function.
             * @param {Boolean}     Indicates whether to create a singleton or transient dialog.
             * @param {String}      The name of the base type to inherit from.
             */
            dialog: function (name, Factory, transient, base) {
              // get request, create a new instance and return it.
              if (typeof Factory !== 'function') {
                return get_dialog(name)
              }

              if (this.hasOwnProperty(name)) {
                throw new Error('alertify.dialog: name already exists')
              }

              // register the dialog
              var definition = register(name, Factory, transient, base)

              if (transient) {
                // make it public
                this[name] = function () {
                  //if passed with no params, consider it a get request
                  if (arguments.length === 0) {
                    return definition.dialog
                  } else {
                    var instance = extend(new definition.factory(), dialog)
                    //ensure init
                    if (instance && typeof instance.__init === 'function') {
                      instance.__init(instance)
                    }
                    instance['main'].apply(instance, arguments)
                    return instance['show'].apply(instance)
                  }
                }
              } else {
                // make it public
                this[name] = function () {
                  //ensure init
                  if (
                    definition.dialog &&
                    typeof definition.dialog.__init === 'function'
                  ) {
                    definition.dialog.__init(definition.dialog)
                  }
                  //if passed with no params, consider it a get request
                  if (arguments.length === 0) {
                    return definition.dialog
                  } else {
                    var dialog = definition.dialog
                    dialog['main'].apply(definition.dialog, arguments)
                    return dialog['show'].apply(definition.dialog)
                  }
                }
              }
            },
            /**
             * Close all open dialogs.
             *
             * @param {Object} excpet [optional] The dialog object to exclude from closing.
             *
             * @return {undefined}
             */
            closeAll: function (except) {
              var clone = openDialogs.slice(0)
              for (var x = 0; x < clone.length; x += 1) {
                var instance = clone[x]
                if (except === undefined || except !== instance) {
                  instance.close()
                }
              }
            },
            /**
             * Gets or Sets dialog settings/options. if the dialog is transient, this call does nothing.
             *
             * @param {string} name The dialog name.
             * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
             * @param {Variant} value Optional, the value associated with the key (in case it was a string).
             *
             * @return {undefined}
             */
            setting: function (name, key, value) {
              if (name === 'notifier') {
                return notifier.setting(key, value)
              }

              var dialog = get_dialog(name)
              if (dialog) {
                return dialog.setting(key, value)
              }
            },
            /**
             * [Alias] Sets dialog settings/options
             */
            set: function (name, key, value) {
              return this.setting(name, key, value)
            },
            /**
             * [Alias] Gets dialog settings/options
             */
            get: function (name, key) {
              return this.setting(name, key)
            },
            /**
             * Creates a new notification message.
             * If a type is passed, a class name "ajs-{type}" will be added.
             * This allows for custom look and feel for various types of notifications.
             *
             * @param  {String | DOMElement}    [message=undefined]		Message text
             * @param  {String}                 [type='']				Type of log message
             * @param  {String}                 [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}               [callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            notify: function (message, type, wait, callback) {
              return notifier.create(type, callback).push(message, wait)
            },
            /**
             * Creates a new notification message.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            message: function (message, wait, callback) {
              return notifier.create(null, callback).push(message, wait)
            },
            /**
             * Creates a new notification message of type 'success'.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            success: function (message, wait, callback) {
              return notifier.create('success', callback).push(message, wait)
            },
            /**
             * Creates a new notification message of type 'error'.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            error: function (message, wait, callback) {
              return notifier.create('error', callback).push(message, wait)
            },
            /**
             * Creates a new notification message of type 'warning'.
             *
             * @param  {String}		[message=undefined]		Message text
             * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
             * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
             *
             * @return {Object} Notification object.
             */
            warning: function (message, wait, callback) {
              return notifier.create('warning', callback).push(message, wait)
            },
            /**
             * Dismisses all open notifications
             *
             * @return {undefined}
             */
            dismissAll: function () {
              notifier.dismissAll()
            }
          }
        }
        var alertify = new Alertify()

        /**
         * Alert dialog definition
         *
         * invoked by:
         *	alertify.alert(message);
         *	alertify.alert(title, message);
         *	alertify.alert(message, onok);
         *	alertify.alert(title, message, onok);
         */
        alertify.dialog('alert', function () {
          return {
            main: function (_title, _message, _onok) {
              var title, message, onok
              switch (arguments.length) {
                case 1:
                  message = _title
                  break
                case 2:
                  if (typeof _message === 'function') {
                    message = _title
                    onok = _message
                  } else {
                    title = _title
                    message = _message
                  }
                  break
                case 3:
                  title = _title
                  message = _message
                  onok = _onok
                  break
              }
              this.set('title', title)
              this.set('message', message)
              this.set('onok', onok)
              return this
            },
            setup: function () {
              return {
                buttons: [
                  {
                    text: alertify.defaults.glossary.ok,
                    key: keys.ESC,
                    invokeOnClose: true,
                    className: alertify.defaults.theme.ok
                  }
                ],
                focus: {
                  element: 0,
                  select: false
                },
                options: {
                  maximizable: false,
                  resizable: false
                }
              }
            },
            build: function () {
              // nothing
            },
            prepare: function () {
              //nothing
            },
            setMessage: function (message) {
              this.setContent(message)
            },
            settings: {
              message: undefined,
              onok: undefined,
              label: undefined
            },
            settingUpdated: function (key, oldValue, newValue) {
              switch (key) {
                case 'message':
                  this.setMessage(newValue)
                  break
                case 'label':
                  if (this.__internal.buttons[0].element) {
                    this.__internal.buttons[0].element.innerHTML = newValue
                  }
                  break
              }
            },
            callback: function (closeEvent) {
              if (typeof this.get('onok') === 'function') {
                var returnValue = this.get('onok').call(this, closeEvent)
                if (typeof returnValue !== 'undefined') {
                  closeEvent.cancel = !returnValue
                }
              }
            }
          }
        })
        /**
         * Confirm dialog object
         *
         *	alertify.confirm(message);
         *	alertify.confirm(message, onok);
         *	alertify.confirm(message, onok, oncancel);
         *	alertify.confirm(title, message, onok, oncancel);
         */
        alertify.dialog('confirm', function () {
          var autoConfirm = {
            timer: null,
            index: null,
            text: null,
            duration: null,
            task: function (event, self) {
              if (self.isOpen()) {
                self.__internal.buttons[autoConfirm.index].element.innerHTML =
                  autoConfirm.text +
                  ' (&#8207;' +
                  autoConfirm.duration +
                  '&#8207;) '
                autoConfirm.duration -= 1
                if (autoConfirm.duration === -1) {
                  clearAutoConfirm(self)
                  var button = self.__internal.buttons[autoConfirm.index]
                  var closeEvent = createCloseEvent(autoConfirm.index, button)

                  if (typeof self.callback === 'function') {
                    self.callback.apply(self, [closeEvent])
                  }
                  //close the dialog.
                  if (closeEvent.close !== false) {
                    self.close()
                  }
                }
              } else {
                clearAutoConfirm(self)
              }
            }
          }

          function clearAutoConfirm(self) {
            if (autoConfirm.timer !== null) {
              clearInterval(autoConfirm.timer)
              autoConfirm.timer = null
              self.__internal.buttons[autoConfirm.index].element.innerHTML =
                autoConfirm.text
            }
          }

          function startAutoConfirm(self, index, duration) {
            clearAutoConfirm(self)
            autoConfirm.duration = duration
            autoConfirm.index = index
            autoConfirm.text = self.__internal.buttons[index].element.innerHTML
            autoConfirm.timer = setInterval(
              delegate(self, autoConfirm.task),
              1000
            )
            autoConfirm.task(null, self)
          }

          return {
            main: function (_title, _message, _onok, _oncancel) {
              var title, message, onok, oncancel
              switch (arguments.length) {
                case 1:
                  message = _title
                  break
                case 2:
                  message = _title
                  onok = _message
                  break
                case 3:
                  message = _title
                  onok = _message
                  oncancel = _onok
                  break
                case 4:
                  title = _title
                  message = _message
                  onok = _onok
                  oncancel = _oncancel
                  break
              }
              this.set('title', title)
              this.set('message', message)
              this.set('onok', onok)
              this.set('oncancel', oncancel)
              return this
            },
            setup: function () {
              return {
                buttons: [
                  {
                    text: alertify.defaults.glossary.ok,
                    key: keys.ENTER,
                    className: alertify.defaults.theme.ok
                  },
                  {
                    text: alertify.defaults.glossary.cancel,
                    key: keys.ESC,
                    invokeOnClose: true,
                    className: alertify.defaults.theme.cancel
                  }
                ],
                focus: {
                  element: 0,
                  select: false
                },
                options: {
                  maximizable: false,
                  resizable: false
                }
              }
            },
            build: function () {
              //nothing
            },
            prepare: function () {
              //nothing
            },
            setMessage: function (message) {
              this.setContent(message)
            },
            settings: {
              message: null,
              labels: null,
              onok: null,
              oncancel: null,
              defaultFocus: null,
              reverseButtons: null
            },
            settingUpdated: function (key, oldValue, newValue) {
              switch (key) {
                case 'message':
                  this.setMessage(newValue)
                  break
                case 'labels':
                  if ('ok' in newValue && this.__internal.buttons[0].element) {
                    this.__internal.buttons[0].text = newValue.ok
                    this.__internal.buttons[0].element.innerHTML = newValue.ok
                  }
                  if (
                    'cancel' in newValue &&
                    this.__internal.buttons[1].element
                  ) {
                    this.__internal.buttons[1].text = newValue.cancel
                    this.__internal.buttons[1].element.innerHTML =
                      newValue.cancel
                  }
                  break
                case 'reverseButtons':
                  if (newValue === true) {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[0].element
                    )
                  } else {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[1].element
                    )
                  }
                  break
                case 'defaultFocus':
                  this.__internal.focus.element = newValue === 'ok' ? 0 : 1
                  break
              }
            },
            callback: function (closeEvent) {
              clearAutoConfirm(this)
              var returnValue
              switch (closeEvent.index) {
                case 0:
                  if (typeof this.get('onok') === 'function') {
                    returnValue = this.get('onok').call(this, closeEvent)
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  break
                case 1:
                  if (typeof this.get('oncancel') === 'function') {
                    returnValue = this.get('oncancel').call(this, closeEvent)
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  break
              }
            },
            autoOk: function (duration) {
              startAutoConfirm(this, 0, duration)
              return this
            },
            autoCancel: function (duration) {
              startAutoConfirm(this, 1, duration)
              return this
            }
          }
        })
        /**
         * Prompt dialog object
         *
         * invoked by:
         *	alertify.prompt(message);
         *	alertify.prompt(message, value);
         *	alertify.prompt(message, value, onok);
         *	alertify.prompt(message, value, onok, oncancel);
         *	alertify.prompt(title, message, value, onok, oncancel);
         */
        alertify.dialog('prompt', function () {
          var input = document.createElement('INPUT')
          var p = document.createElement('P')
          return {
            main: function (_title, _message, _value, _onok, _oncancel) {
              var title, message, value, onok, oncancel
              switch (arguments.length) {
                case 1:
                  message = _title
                  break
                case 2:
                  message = _title
                  value = _message
                  break
                case 3:
                  message = _title
                  value = _message
                  onok = _value
                  break
                case 4:
                  message = _title
                  value = _message
                  onok = _value
                  oncancel = _onok
                  break
                case 5:
                  title = _title
                  message = _message
                  value = _value
                  onok = _onok
                  oncancel = _oncancel
                  break
              }
              this.set('title', title)
              this.set('message', message)
              this.set('value', value)
              this.set('onok', onok)
              this.set('oncancel', oncancel)
              return this
            },
            setup: function () {
              return {
                buttons: [
                  {
                    text: alertify.defaults.glossary.ok,
                    key: keys.ENTER,
                    className: alertify.defaults.theme.ok
                  },
                  {
                    text: alertify.defaults.glossary.cancel,
                    key: keys.ESC,
                    invokeOnClose: true,
                    className: alertify.defaults.theme.cancel
                  }
                ],
                focus: {
                  element: input,
                  select: true
                },
                options: {
                  maximizable: false,
                  resizable: false
                }
              }
            },
            build: function () {
              input.className = alertify.defaults.theme.input
              input.setAttribute('type', 'text')
              input.value = this.get('value')
              this.elements.content.appendChild(p)
              this.elements.content.appendChild(input)
            },
            prepare: function () {
              //nothing
            },
            setMessage: function (message) {
              if (typeof message === 'string') {
                clearContents(p)
                p.innerHTML = message
              } else if (
                message instanceof window.HTMLElement &&
                p.firstChild !== message
              ) {
                clearContents(p)
                p.appendChild(message)
              }
            },
            settings: {
              message: undefined,
              labels: undefined,
              onok: undefined,
              oncancel: undefined,
              value: '',
              type: 'text',
              reverseButtons: undefined
            },
            settingUpdated: function (key, oldValue, newValue) {
              switch (key) {
                case 'message':
                  this.setMessage(newValue)
                  break
                case 'value':
                  input.value = newValue
                  break
                case 'type':
                  switch (newValue) {
                    case 'text':
                    case 'color':
                    case 'date':
                    case 'datetime-local':
                    case 'email':
                    case 'month':
                    case 'number':
                    case 'password':
                    case 'search':
                    case 'tel':
                    case 'time':
                    case 'week':
                      input.type = newValue
                      break
                    default:
                      input.type = 'text'
                      break
                  }
                  break
                case 'labels':
                  if (newValue.ok && this.__internal.buttons[0].element) {
                    this.__internal.buttons[0].element.innerHTML = newValue.ok
                  }
                  if (newValue.cancel && this.__internal.buttons[1].element) {
                    this.__internal.buttons[1].element.innerHTML =
                      newValue.cancel
                  }
                  break
                case 'reverseButtons':
                  if (newValue === true) {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[0].element
                    )
                  } else {
                    this.elements.buttons.primary.appendChild(
                      this.__internal.buttons[1].element
                    )
                  }
                  break
              }
            },
            callback: function (closeEvent) {
              var returnValue
              switch (closeEvent.index) {
                case 0:
                  this.settings.value = input.value
                  if (typeof this.get('onok') === 'function') {
                    returnValue = this.get('onok').call(
                      this,
                      closeEvent,
                      this.settings.value
                    )
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  break
                case 1:
                  if (typeof this.get('oncancel') === 'function') {
                    returnValue = this.get('oncancel').call(this, closeEvent)
                    if (typeof returnValue !== 'undefined') {
                      closeEvent.cancel = !returnValue
                    }
                  }
                  if (!closeEvent.cancel) {
                    input.value = this.settings.value
                  }
                  break
              }
            }
          }
        })

        // CommonJS
        if (true && typeof module.exports === 'object') {
          module.exports = alertify
          // AMD
        } else if (true) {
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
          (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return alertify
          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
          // window
        } else {
        }
      })(typeof window !== 'undefined' ? window : this)

      /***/
    },

    /***/ 296: /***/ (module) => {
      function debounce(function_, wait = 100, options = {}) {
        if (typeof function_ !== 'function') {
          throw new TypeError(
            `Expected the first parameter to be a function, got \`${typeof function_}\`.`
          )
        }

        if (wait < 0) {
          throw new RangeError('`wait` must not be negative.')
        }

        // TODO: Deprecate the boolean parameter at some point.
        const { immediate } =
          typeof options === 'boolean' ? { immediate: options } : options

        let storedContext
        let storedArguments
        let timeoutId
        let timestamp
        let result

        function later() {
          const last = Date.now() - timestamp

          if (last < wait && last >= 0) {
            timeoutId = setTimeout(later, wait - last)
          } else {
            timeoutId = undefined

            if (!immediate) {
              const callContext = storedContext
              const callArguments = storedArguments
              storedContext = undefined
              storedArguments = undefined
              result = function_.apply(callContext, callArguments)
            }
          }
        }

        const debounced = function (...arguments_) {
          if (storedContext && this !== storedContext) {
            throw new Error('Debounced method called with different contexts.')
          }

          storedContext = this // eslint-disable-line unicorn/no-this-assignment
          storedArguments = arguments_
          timestamp = Date.now()

          const callNow = immediate && !timeoutId

          if (!timeoutId) {
            timeoutId = setTimeout(later, wait)
          }

          if (callNow) {
            const callContext = storedContext
            const callArguments = storedArguments
            storedContext = undefined
            storedArguments = undefined
            result = function_.apply(callContext, callArguments)
          }

          return result
        }

        debounced.clear = () => {
          if (!timeoutId) {
            return
          }

          clearTimeout(timeoutId)
          timeoutId = undefined
        }

        debounced.flush = () => {
          if (!timeoutId) {
            return
          }

          const callContext = storedContext
          const callArguments = storedArguments
          storedContext = undefined
          storedArguments = undefined
          result = function_.apply(callContext, callArguments)

          clearTimeout(timeoutId)
          timeoutId = undefined
        }

        return debounced
      }

      // Adds compatibility for ES modules
      module.exports.debounce = debounce

      module.exports = debounce

      /***/
    },

    /***/ 2828: /***/ (module) => {
      var DOCUMENT_NODE_TYPE = 9

      /**
       * A polyfill for Element.matches()
       */
      if (typeof Element !== 'undefined' && !Element.prototype.matches) {
        var proto = Element.prototype

        proto.matches =
          proto.matchesSelector ||
          proto.mozMatchesSelector ||
          proto.msMatchesSelector ||
          proto.oMatchesSelector ||
          proto.webkitMatchesSelector
      }

      /**
       * Finds the closest parent that matches a selector.
       *
       * @param {Element} element
       * @param {String} selector
       * @return {Function}
       */
      function closest(element, selector) {
        while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
          if (
            typeof element.matches === 'function' &&
            element.matches(selector)
          ) {
            return element
          }
          element = element.parentNode
        }
      }

      module.exports = closest

      /***/
    },

    /***/ 9438: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      var closest = __webpack_require__(2828)

      /**
       * Delegates event to a selector.
       *
       * @param {Element} element
       * @param {String} selector
       * @param {String} type
       * @param {Function} callback
       * @param {Boolean} useCapture
       * @return {Object}
       */
      function _delegate(element, selector, type, callback, useCapture) {
        var listenerFn = listener.apply(this, arguments)

        element.addEventListener(type, listenerFn, useCapture)

        return {
          destroy: function () {
            element.removeEventListener(type, listenerFn, useCapture)
          }
        }
      }

      /**
       * Delegates event to a selector.
       *
       * @param {Element|String|Array} [elements]
       * @param {String} selector
       * @param {String} type
       * @param {Function} callback
       * @param {Boolean} useCapture
       * @return {Object}
       */
      function delegate(elements, selector, type, callback, useCapture) {
        // Handle the regular Element usage
        if (typeof elements.addEventListener === 'function') {
          return _delegate.apply(null, arguments)
        }

        // Handle Element-less usage, it defaults to global delegation
        if (typeof type === 'function') {
          // Use `document` as the first parameter, then apply arguments
          // This is a short way to .unshift `arguments` without running into deoptimizations
          return _delegate.bind(null, document).apply(null, arguments)
        }

        // Handle Selector-based usage
        if (typeof elements === 'string') {
          elements = document.querySelectorAll(elements)
        }

        // Handle Array-like based usage
        return Array.prototype.map.call(elements, function (element) {
          return _delegate(element, selector, type, callback, useCapture)
        })
      }

      /**
       * Finds closest match and invokes callback.
       *
       * @param {Element} element
       * @param {String} selector
       * @param {String} type
       * @param {Function} callback
       * @return {Function}
       */
      function listener(element, selector, type, callback) {
        return function (e) {
          e.delegateTarget = closest(e.target, selector)

          if (e.delegateTarget) {
            callback.call(element, e)
          }
        }
      }

      module.exports = delegate

      /***/
    },

    /***/ 1182: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      module.exports = __webpack_require__(9269)

      /***/
    },

    /***/ 9269: /***/ (module) => {
      function toArray(value) {
        if (value === null || value === undefined) return []
        else return Array.isArray(value) ? value : [value]
      }

      /**
       * dohtml
       * @type {{create: dom.create, isValidNode: dom.isValidNode, render: dom.render}}
       */
      var dom = {
        /**
         * Create DOM element
         * @param str html string or a single tag
         * @returns {Element | Node | null}
         */
        create: function (str) {
          var element
          str = str.trim()

          if (/<.*>/g.test(str)) {
            var template = document.createElement('div')
            template.innerHTML = str
            element = template.firstChild
          } else {
            element = document.createElement(str)
          }

          if (!this.isValidNode(element)) throw new Error('Element not valid')
          return element
        },

        /**
         * Check if is a valid Node
         * @param {*} el
         * @returns {Boolean}
         */
        isValidNode: function (el) {
          return el && 'nodeType' in el
        },

        /**
         * Append multiple elements into target element
         * @param {Element} target
         * @param {Array | Element} els
         * @returns {Element | Node | Error}
         */
        render: function (target, els) {
          els = toArray(els)
          if (!this.isValidNode(target))
            throw new Error('Require a valid HTML Element')

          els.forEach(function (el) {
            target.appendChild(el)
          })
          return target
        }
      }

      module.exports = dom

      /***/
    },

    /***/ 2025: /***/ (module) => {
      ;(function webpackUniversalModuleDefinition(root, factory) {
        if (true) module.exports = factory()
        else {
          var i, a
        }
      })(self, function () {
        return /******/ (function () {
          // webpackBootstrap
          /******/ var __webpack_modules__ = {
            /***/ 3099: /***/ function (module) {
              module.exports = function (it) {
                if (typeof it != 'function') {
                  throw TypeError(String(it) + ' is not a function')
                }
                return it
              }

              /***/
            },

            /***/ 6077: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_703__
            ) {
              var isObject = __nested_webpack_require_703__(111)

              module.exports = function (it) {
                if (!isObject(it) && it !== null) {
                  throw TypeError("Can't set " + String(it) + ' as a prototype')
                }
                return it
              }

              /***/
            },

            /***/ 1223: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_1001__
            ) {
              var wellKnownSymbol = __nested_webpack_require_1001__(5112)
              var create = __nested_webpack_require_1001__(30)
              var definePropertyModule = __nested_webpack_require_1001__(3070)

              var UNSCOPABLES = wellKnownSymbol('unscopables')
              var ArrayPrototype = Array.prototype

              // Array.prototype[@@unscopables]
              // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
              if (ArrayPrototype[UNSCOPABLES] == undefined) {
                definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                  configurable: true,
                  value: create(null)
                })
              }

              // add a key to Array.prototype[@@unscopables]
              module.exports = function (key) {
                ArrayPrototype[UNSCOPABLES][key] = true
              }

              /***/
            },

            /***/ 1530: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_1715__
            ) {
              'use strict'

              var charAt = __nested_webpack_require_1715__(8710).charAt

              // `AdvanceStringIndex` abstract operation
              // https://tc39.es/ecma262/#sec-advancestringindex
              module.exports = function (S, index, unicode) {
                return index + (unicode ? charAt(S, index).length : 1)
              }

              /***/
            },

            /***/ 5787: /***/ function (module) {
              module.exports = function (it, Constructor, name) {
                if (!(it instanceof Constructor)) {
                  throw TypeError(
                    'Incorrect ' + (name ? name + ' ' : '') + 'invocation'
                  )
                }
                return it
              }

              /***/
            },

            /***/ 9670: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_2317__
            ) {
              var isObject = __nested_webpack_require_2317__(111)

              module.exports = function (it) {
                if (!isObject(it)) {
                  throw TypeError(String(it) + ' is not an object')
                }
                return it
              }

              /***/
            },

            /***/ 4019: /***/ function (module) {
              module.exports =
                typeof ArrayBuffer !== 'undefined' &&
                typeof DataView !== 'undefined'

              /***/
            },

            /***/ 260: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_2726__
            ) {
              'use strict'

              var NATIVE_ARRAY_BUFFER = __nested_webpack_require_2726__(4019)
              var DESCRIPTORS = __nested_webpack_require_2726__(9781)
              var global = __nested_webpack_require_2726__(7854)
              var isObject = __nested_webpack_require_2726__(111)
              var has = __nested_webpack_require_2726__(6656)
              var classof = __nested_webpack_require_2726__(648)
              var createNonEnumerableProperty =
                __nested_webpack_require_2726__(8880)
              var redefine = __nested_webpack_require_2726__(1320)
              var defineProperty = __nested_webpack_require_2726__(3070).f
              var getPrototypeOf = __nested_webpack_require_2726__(9518)
              var setPrototypeOf = __nested_webpack_require_2726__(7674)
              var wellKnownSymbol = __nested_webpack_require_2726__(5112)
              var uid = __nested_webpack_require_2726__(9711)

              var Int8Array = global.Int8Array
              var Int8ArrayPrototype = Int8Array && Int8Array.prototype
              var Uint8ClampedArray = global.Uint8ClampedArray
              var Uint8ClampedArrayPrototype =
                Uint8ClampedArray && Uint8ClampedArray.prototype
              var TypedArray = Int8Array && getPrototypeOf(Int8Array)
              var TypedArrayPrototype =
                Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype)
              var ObjectPrototype = Object.prototype
              var isPrototypeOf = ObjectPrototype.isPrototypeOf

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG')
              // Fixing native typed arrays in Opera Presto crashes the browser, see #595
              var NATIVE_ARRAY_BUFFER_VIEWS =
                NATIVE_ARRAY_BUFFER &&
                !!setPrototypeOf &&
                classof(global.opera) !== 'Opera'
              var TYPED_ARRAY_TAG_REQIRED = false
              var NAME

              var TypedArrayConstructorsList = {
                Int8Array: 1,
                Uint8Array: 1,
                Uint8ClampedArray: 1,
                Int16Array: 2,
                Uint16Array: 2,
                Int32Array: 4,
                Uint32Array: 4,
                Float32Array: 4,
                Float64Array: 8
              }

              var BigIntArrayConstructorsList = {
                BigInt64Array: 8,
                BigUint64Array: 8
              }

              var isView = function isView(it) {
                if (!isObject(it)) return false
                var klass = classof(it)
                return (
                  klass === 'DataView' ||
                  has(TypedArrayConstructorsList, klass) ||
                  has(BigIntArrayConstructorsList, klass)
                )
              }

              var isTypedArray = function (it) {
                if (!isObject(it)) return false
                var klass = classof(it)
                return (
                  has(TypedArrayConstructorsList, klass) ||
                  has(BigIntArrayConstructorsList, klass)
                )
              }

              var aTypedArray = function (it) {
                if (isTypedArray(it)) return it
                throw TypeError('Target is not a typed array')
              }

              var aTypedArrayConstructor = function (C) {
                if (setPrototypeOf) {
                  if (isPrototypeOf.call(TypedArray, C)) return C
                } else
                  for (var ARRAY in TypedArrayConstructorsList)
                    if (has(TypedArrayConstructorsList, NAME)) {
                      var TypedArrayConstructor = global[ARRAY]
                      if (
                        TypedArrayConstructor &&
                        (C === TypedArrayConstructor ||
                          isPrototypeOf.call(TypedArrayConstructor, C))
                      ) {
                        return C
                      }
                    }
                throw TypeError('Target is not a typed array constructor')
              }

              var exportTypedArrayMethod = function (KEY, property, forced) {
                if (!DESCRIPTORS) return
                if (forced)
                  for (var ARRAY in TypedArrayConstructorsList) {
                    var TypedArrayConstructor = global[ARRAY]
                    if (
                      TypedArrayConstructor &&
                      has(TypedArrayConstructor.prototype, KEY)
                    ) {
                      delete TypedArrayConstructor.prototype[KEY]
                    }
                  }
                if (!TypedArrayPrototype[KEY] || forced) {
                  redefine(
                    TypedArrayPrototype,
                    KEY,
                    forced
                      ? property
                      : (NATIVE_ARRAY_BUFFER_VIEWS &&
                          Int8ArrayPrototype[KEY]) ||
                          property
                  )
                }
              }

              var exportTypedArrayStaticMethod = function (
                KEY,
                property,
                forced
              ) {
                var ARRAY, TypedArrayConstructor
                if (!DESCRIPTORS) return
                if (setPrototypeOf) {
                  if (forced)
                    for (ARRAY in TypedArrayConstructorsList) {
                      TypedArrayConstructor = global[ARRAY]
                      if (
                        TypedArrayConstructor &&
                        has(TypedArrayConstructor, KEY)
                      ) {
                        delete TypedArrayConstructor[KEY]
                      }
                    }
                  if (!TypedArray[KEY] || forced) {
                    // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
                    try {
                      return redefine(
                        TypedArray,
                        KEY,
                        forced
                          ? property
                          : (NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY]) ||
                              property
                      )
                    } catch (error) {
                      /* empty */
                    }
                  } else return
                }
                for (ARRAY in TypedArrayConstructorsList) {
                  TypedArrayConstructor = global[ARRAY]
                  if (
                    TypedArrayConstructor &&
                    (!TypedArrayConstructor[KEY] || forced)
                  ) {
                    redefine(TypedArrayConstructor, KEY, property)
                  }
                }
              }

              for (NAME in TypedArrayConstructorsList) {
                if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false
              }

              // WebKit bug - typed arrays constructors prototype is Object.prototype
              if (
                !NATIVE_ARRAY_BUFFER_VIEWS ||
                typeof TypedArray != 'function' ||
                TypedArray === Function.prototype
              ) {
                // eslint-disable-next-line no-shadow -- safe
                TypedArray = function TypedArray() {
                  throw TypeError('Incorrect invocation')
                }
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray)
                  }
              }

              if (
                !NATIVE_ARRAY_BUFFER_VIEWS ||
                !TypedArrayPrototype ||
                TypedArrayPrototype === ObjectPrototype
              ) {
                TypedArrayPrototype = TypedArray.prototype
                if (NATIVE_ARRAY_BUFFER_VIEWS)
                  for (NAME in TypedArrayConstructorsList) {
                    if (global[NAME])
                      setPrototypeOf(
                        global[NAME].prototype,
                        TypedArrayPrototype
                      )
                  }
              }

              // WebKit bug - one more object in Uint8ClampedArray prototype chain
              if (
                NATIVE_ARRAY_BUFFER_VIEWS &&
                getPrototypeOf(Uint8ClampedArrayPrototype) !==
                  TypedArrayPrototype
              ) {
                setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype)
              }

              if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
                TYPED_ARRAY_TAG_REQIRED = true
                defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
                  get: function () {
                    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined
                  }
                })
                for (NAME in TypedArrayConstructorsList)
                  if (global[NAME]) {
                    createNonEnumerableProperty(
                      global[NAME],
                      TYPED_ARRAY_TAG,
                      NAME
                    )
                  }
              }

              module.exports = {
                NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
                TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
                aTypedArray: aTypedArray,
                aTypedArrayConstructor: aTypedArrayConstructor,
                exportTypedArrayMethod: exportTypedArrayMethod,
                exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
                isView: isView,
                isTypedArray: isTypedArray,
                TypedArray: TypedArray,
                TypedArrayPrototype: TypedArrayPrototype
              }

              /***/
            },

            /***/ 3331: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_8934__
            ) {
              'use strict'

              var global = __nested_webpack_require_8934__(7854)
              var DESCRIPTORS = __nested_webpack_require_8934__(9781)
              var NATIVE_ARRAY_BUFFER = __nested_webpack_require_8934__(4019)
              var createNonEnumerableProperty =
                __nested_webpack_require_8934__(8880)
              var redefineAll = __nested_webpack_require_8934__(2248)
              var fails = __nested_webpack_require_8934__(7293)
              var anInstance = __nested_webpack_require_8934__(5787)
              var toInteger = __nested_webpack_require_8934__(9958)
              var toLength = __nested_webpack_require_8934__(7466)
              var toIndex = __nested_webpack_require_8934__(7067)
              var IEEE754 = __nested_webpack_require_8934__(1179)
              var getPrototypeOf = __nested_webpack_require_8934__(9518)
              var setPrototypeOf = __nested_webpack_require_8934__(7674)
              var getOwnPropertyNames = __nested_webpack_require_8934__(8006).f
              var defineProperty = __nested_webpack_require_8934__(3070).f
              var arrayFill = __nested_webpack_require_8934__(1285)
              var setToStringTag = __nested_webpack_require_8934__(8003)
              var InternalStateModule = __nested_webpack_require_8934__(9909)

              var getInternalState = InternalStateModule.get
              var setInternalState = InternalStateModule.set
              var ARRAY_BUFFER = 'ArrayBuffer'
              var DATA_VIEW = 'DataView'
              var PROTOTYPE = 'prototype'
              var WRONG_LENGTH = 'Wrong length'
              var WRONG_INDEX = 'Wrong index'
              var NativeArrayBuffer = global[ARRAY_BUFFER]
              var $ArrayBuffer = NativeArrayBuffer
              var $DataView = global[DATA_VIEW]
              var $DataViewPrototype = $DataView && $DataView[PROTOTYPE]
              var ObjectPrototype = Object.prototype
              var RangeError = global.RangeError

              var packIEEE754 = IEEE754.pack
              var unpackIEEE754 = IEEE754.unpack

              var packInt8 = function (number) {
                return [number & 0xff]
              }

              var packInt16 = function (number) {
                return [number & 0xff, (number >> 8) & 0xff]
              }

              var packInt32 = function (number) {
                return [
                  number & 0xff,
                  (number >> 8) & 0xff,
                  (number >> 16) & 0xff,
                  (number >> 24) & 0xff
                ]
              }

              var unpackInt32 = function (buffer) {
                return (
                  (buffer[3] << 24) |
                  (buffer[2] << 16) |
                  (buffer[1] << 8) |
                  buffer[0]
                )
              }

              var packFloat32 = function (number) {
                return packIEEE754(number, 23, 4)
              }

              var packFloat64 = function (number) {
                return packIEEE754(number, 52, 8)
              }

              var addGetter = function (Constructor, key) {
                defineProperty(Constructor[PROTOTYPE], key, {
                  get: function () {
                    return getInternalState(this)[key]
                  }
                })
              }

              var get = function (view, count, index, isLittleEndian) {
                var intIndex = toIndex(index)
                var store = getInternalState(view)
                if (intIndex + count > store.byteLength)
                  throw RangeError(WRONG_INDEX)
                var bytes = getInternalState(store.buffer).bytes
                var start = intIndex + store.byteOffset
                var pack = bytes.slice(start, start + count)
                return isLittleEndian ? pack : pack.reverse()
              }

              var set = function (
                view,
                count,
                index,
                conversion,
                value,
                isLittleEndian
              ) {
                var intIndex = toIndex(index)
                var store = getInternalState(view)
                if (intIndex + count > store.byteLength)
                  throw RangeError(WRONG_INDEX)
                var bytes = getInternalState(store.buffer).bytes
                var start = intIndex + store.byteOffset
                var pack = conversion(+value)
                for (var i = 0; i < count; i++)
                  bytes[start + i] = pack[isLittleEndian ? i : count - i - 1]
              }

              if (!NATIVE_ARRAY_BUFFER) {
                $ArrayBuffer = function ArrayBuffer(length) {
                  anInstance(this, $ArrayBuffer, ARRAY_BUFFER)
                  var byteLength = toIndex(length)
                  setInternalState(this, {
                    bytes: arrayFill.call(new Array(byteLength), 0),
                    byteLength: byteLength
                  })
                  if (!DESCRIPTORS) this.byteLength = byteLength
                }

                $DataView = function DataView(buffer, byteOffset, byteLength) {
                  anInstance(this, $DataView, DATA_VIEW)
                  anInstance(buffer, $ArrayBuffer, DATA_VIEW)
                  var bufferLength = getInternalState(buffer).byteLength
                  var offset = toInteger(byteOffset)
                  if (offset < 0 || offset > bufferLength)
                    throw RangeError('Wrong offset')
                  byteLength =
                    byteLength === undefined
                      ? bufferLength - offset
                      : toLength(byteLength)
                  if (offset + byteLength > bufferLength)
                    throw RangeError(WRONG_LENGTH)
                  setInternalState(this, {
                    buffer: buffer,
                    byteLength: byteLength,
                    byteOffset: offset
                  })
                  if (!DESCRIPTORS) {
                    this.buffer = buffer
                    this.byteLength = byteLength
                    this.byteOffset = offset
                  }
                }

                if (DESCRIPTORS) {
                  addGetter($ArrayBuffer, 'byteLength')
                  addGetter($DataView, 'buffer')
                  addGetter($DataView, 'byteLength')
                  addGetter($DataView, 'byteOffset')
                }

                redefineAll($DataView[PROTOTYPE], {
                  getInt8: function getInt8(byteOffset) {
                    return (get(this, 1, byteOffset)[0] << 24) >> 24
                  },
                  getUint8: function getUint8(byteOffset) {
                    return get(this, 1, byteOffset)[0]
                  },
                  getInt16: function getInt16(byteOffset /* , littleEndian */) {
                    var bytes = get(
                      this,
                      2,
                      byteOffset,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                    return (((bytes[1] << 8) | bytes[0]) << 16) >> 16
                  },
                  getUint16: function getUint16(
                    byteOffset /* , littleEndian */
                  ) {
                    var bytes = get(
                      this,
                      2,
                      byteOffset,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                    return (bytes[1] << 8) | bytes[0]
                  },
                  getInt32: function getInt32(byteOffset /* , littleEndian */) {
                    return unpackInt32(
                      get(
                        this,
                        4,
                        byteOffset,
                        arguments.length > 1 ? arguments[1] : undefined
                      )
                    )
                  },
                  getUint32: function getUint32(
                    byteOffset /* , littleEndian */
                  ) {
                    return (
                      unpackInt32(
                        get(
                          this,
                          4,
                          byteOffset,
                          arguments.length > 1 ? arguments[1] : undefined
                        )
                      ) >>> 0
                    )
                  },
                  getFloat32: function getFloat32(
                    byteOffset /* , littleEndian */
                  ) {
                    return unpackIEEE754(
                      get(
                        this,
                        4,
                        byteOffset,
                        arguments.length > 1 ? arguments[1] : undefined
                      ),
                      23
                    )
                  },
                  getFloat64: function getFloat64(
                    byteOffset /* , littleEndian */
                  ) {
                    return unpackIEEE754(
                      get(
                        this,
                        8,
                        byteOffset,
                        arguments.length > 1 ? arguments[1] : undefined
                      ),
                      52
                    )
                  },
                  setInt8: function setInt8(byteOffset, value) {
                    set(this, 1, byteOffset, packInt8, value)
                  },
                  setUint8: function setUint8(byteOffset, value) {
                    set(this, 1, byteOffset, packInt8, value)
                  },
                  setInt16: function setInt16(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      2,
                      byteOffset,
                      packInt16,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setUint16: function setUint16(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      2,
                      byteOffset,
                      packInt16,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setInt32: function setInt32(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      4,
                      byteOffset,
                      packInt32,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setUint32: function setUint32(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      4,
                      byteOffset,
                      packInt32,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setFloat32: function setFloat32(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      4,
                      byteOffset,
                      packFloat32,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  },
                  setFloat64: function setFloat64(
                    byteOffset,
                    value /* , littleEndian */
                  ) {
                    set(
                      this,
                      8,
                      byteOffset,
                      packFloat64,
                      value,
                      arguments.length > 2 ? arguments[2] : undefined
                    )
                  }
                })
              } else {
                /* eslint-disable no-new -- required for testing */
                if (
                  !fails(function () {
                    NativeArrayBuffer(1)
                  }) ||
                  !fails(function () {
                    new NativeArrayBuffer(-1)
                  }) ||
                  fails(function () {
                    new NativeArrayBuffer()
                    new NativeArrayBuffer(1.5)
                    new NativeArrayBuffer(NaN)
                    return NativeArrayBuffer.name != ARRAY_BUFFER
                  })
                ) {
                  /* eslint-enable no-new -- required for testing */
                  $ArrayBuffer = function ArrayBuffer(length) {
                    anInstance(this, $ArrayBuffer)
                    return new NativeArrayBuffer(toIndex(length))
                  }
                  var ArrayBufferPrototype = ($ArrayBuffer[PROTOTYPE] =
                    NativeArrayBuffer[PROTOTYPE])
                  for (
                    var keys = getOwnPropertyNames(NativeArrayBuffer),
                      j = 0,
                      key;
                    keys.length > j;

                  ) {
                    if (!((key = keys[j++]) in $ArrayBuffer)) {
                      createNonEnumerableProperty(
                        $ArrayBuffer,
                        key,
                        NativeArrayBuffer[key]
                      )
                    }
                  }
                  ArrayBufferPrototype.constructor = $ArrayBuffer
                }

                // WebKit bug - the same parent prototype for typed arrays and data view
                if (
                  setPrototypeOf &&
                  getPrototypeOf($DataViewPrototype) !== ObjectPrototype
                ) {
                  setPrototypeOf($DataViewPrototype, ObjectPrototype)
                }

                // iOS Safari 7.x bug
                var testView = new $DataView(new $ArrayBuffer(2))
                var nativeSetInt8 = $DataViewPrototype.setInt8
                testView.setInt8(0, 2147483648)
                testView.setInt8(1, 2147483649)
                if (testView.getInt8(0) || !testView.getInt8(1))
                  redefineAll(
                    $DataViewPrototype,
                    {
                      setInt8: function setInt8(byteOffset, value) {
                        nativeSetInt8.call(
                          this,
                          byteOffset,
                          (value << 24) >> 24
                        )
                      },
                      setUint8: function setUint8(byteOffset, value) {
                        nativeSetInt8.call(
                          this,
                          byteOffset,
                          (value << 24) >> 24
                        )
                      }
                    },
                    { unsafe: true }
                  )
              }

              setToStringTag($ArrayBuffer, ARRAY_BUFFER)
              setToStringTag($DataView, DATA_VIEW)

              module.exports = {
                ArrayBuffer: $ArrayBuffer,
                DataView: $DataView
              }

              /***/
            },

            /***/ 1048: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_17881__
            ) {
              'use strict'

              var toObject = __nested_webpack_require_17881__(7908)
              var toAbsoluteIndex = __nested_webpack_require_17881__(1400)
              var toLength = __nested_webpack_require_17881__(7466)

              var min = Math.min

              // `Array.prototype.copyWithin` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.copywithin
              module.exports =
                [].copyWithin ||
                function copyWithin(
                  target /* = 0 */,
                  start /* = 0, end = @length */
                ) {
                  var O = toObject(this)
                  var len = toLength(O.length)
                  var to = toAbsoluteIndex(target, len)
                  var from = toAbsoluteIndex(start, len)
                  var end = arguments.length > 2 ? arguments[2] : undefined
                  var count = min(
                    (end === undefined ? len : toAbsoluteIndex(end, len)) -
                      from,
                    len - to
                  )
                  var inc = 1
                  if (from < to && to < from + count) {
                    inc = -1
                    from += count - 1
                    to += count - 1
                  }
                  while (count-- > 0) {
                    if (from in O) O[to] = O[from]
                    else delete O[to]
                    to += inc
                    from += inc
                  }
                  return O
                }

              /***/
            },

            /***/ 1285: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_18911__
            ) {
              'use strict'

              var toObject = __nested_webpack_require_18911__(7908)
              var toAbsoluteIndex = __nested_webpack_require_18911__(1400)
              var toLength = __nested_webpack_require_18911__(7466)

              // `Array.prototype.fill` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.fill
              module.exports = function fill(
                value /* , start = 0, end = @length */
              ) {
                var O = toObject(this)
                var length = toLength(O.length)
                var argumentsLength = arguments.length
                var index = toAbsoluteIndex(
                  argumentsLength > 1 ? arguments[1] : undefined,
                  length
                )
                var end = argumentsLength > 2 ? arguments[2] : undefined
                var endPos =
                  end === undefined ? length : toAbsoluteIndex(end, length)
                while (endPos > index) O[index++] = value
                return O
              }

              /***/
            },

            /***/ 8533: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_19717__
            ) {
              'use strict'

              var $forEach = __nested_webpack_require_19717__(2092).forEach
              var arrayMethodIsStrict = __nested_webpack_require_19717__(9341)

              var STRICT_METHOD = arrayMethodIsStrict('forEach')

              // `Array.prototype.forEach` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.foreach
              module.exports = !STRICT_METHOD
                ? function forEach(callbackfn /* , thisArg */) {
                    return $forEach(
                      this,
                      callbackfn,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                  }
                : [].forEach

              /***/
            },

            /***/ 8457: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_20278__
            ) {
              'use strict'

              var bind = __nested_webpack_require_20278__(9974)
              var toObject = __nested_webpack_require_20278__(7908)
              var callWithSafeIterationClosing =
                __nested_webpack_require_20278__(3411)
              var isArrayIteratorMethod = __nested_webpack_require_20278__(7659)
              var toLength = __nested_webpack_require_20278__(7466)
              var createProperty = __nested_webpack_require_20278__(6135)
              var getIteratorMethod = __nested_webpack_require_20278__(1246)

              // `Array.from` method implementation
              // https://tc39.es/ecma262/#sec-array.from
              module.exports = function from(
                arrayLike /* , mapfn = undefined, thisArg = undefined */
              ) {
                var O = toObject(arrayLike)
                var C = typeof this == 'function' ? this : Array
                var argumentsLength = arguments.length
                var mapfn = argumentsLength > 1 ? arguments[1] : undefined
                var mapping = mapfn !== undefined
                var iteratorMethod = getIteratorMethod(O)
                var index = 0
                var length, result, step, iterator, next, value
                if (mapping)
                  mapfn = bind(
                    mapfn,
                    argumentsLength > 2 ? arguments[2] : undefined,
                    2
                  )
                // if the target is not iterable or it's an array with the default iterator - use a simple case
                if (
                  iteratorMethod != undefined &&
                  !(C == Array && isArrayIteratorMethod(iteratorMethod))
                ) {
                  iterator = iteratorMethod.call(O)
                  next = iterator.next
                  result = new C()
                  for (; !(step = next.call(iterator)).done; index++) {
                    value = mapping
                      ? callWithSafeIterationClosing(
                          iterator,
                          mapfn,
                          [step.value, index],
                          true
                        )
                      : step.value
                    createProperty(result, index, value)
                  }
                } else {
                  length = toLength(O.length)
                  result = new C(length)
                  for (; length > index; index++) {
                    value = mapping ? mapfn(O[index], index) : O[index]
                    createProperty(result, index, value)
                  }
                }
                result.length = index
                return result
              }

              /***/
            },

            /***/ 1318: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_22092__
            ) {
              var toIndexedObject = __nested_webpack_require_22092__(5656)
              var toLength = __nested_webpack_require_22092__(7466)
              var toAbsoluteIndex = __nested_webpack_require_22092__(1400)

              // `Array.prototype.{ indexOf, includes }` methods implementation
              var createMethod = function (IS_INCLUDES) {
                return function ($this, el, fromIndex) {
                  var O = toIndexedObject($this)
                  var length = toLength(O.length)
                  var index = toAbsoluteIndex(fromIndex, length)
                  var value
                  // Array#includes uses SameValueZero equality algorithm
                  // eslint-disable-next-line no-self-compare -- NaN check
                  if (IS_INCLUDES && el != el)
                    while (length > index) {
                      value = O[index++]
                      // eslint-disable-next-line no-self-compare -- NaN check
                      if (value != value) return true
                      // Array#indexOf ignores holes, Array#includes - not
                    }
                  else
                    for (; length > index; index++) {
                      if ((IS_INCLUDES || index in O) && O[index] === el)
                        return IS_INCLUDES || index || 0
                    }
                  return !IS_INCLUDES && -1
                }
              }

              module.exports = {
                // `Array.prototype.includes` method
                // https://tc39.es/ecma262/#sec-array.prototype.includes
                includes: createMethod(true),
                // `Array.prototype.indexOf` method
                // https://tc39.es/ecma262/#sec-array.prototype.indexof
                indexOf: createMethod(false)
              }

              /***/
            },

            /***/ 2092: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_23446__
            ) {
              var bind = __nested_webpack_require_23446__(9974)
              var IndexedObject = __nested_webpack_require_23446__(8361)
              var toObject = __nested_webpack_require_23446__(7908)
              var toLength = __nested_webpack_require_23446__(7466)
              var arraySpeciesCreate = __nested_webpack_require_23446__(5417)

              var push = [].push

              // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
              var createMethod = function (TYPE) {
                var IS_MAP = TYPE == 1
                var IS_FILTER = TYPE == 2
                var IS_SOME = TYPE == 3
                var IS_EVERY = TYPE == 4
                var IS_FIND_INDEX = TYPE == 6
                var IS_FILTER_OUT = TYPE == 7
                var NO_HOLES = TYPE == 5 || IS_FIND_INDEX
                return function ($this, callbackfn, that, specificCreate) {
                  var O = toObject($this)
                  var self = IndexedObject(O)
                  var boundFunction = bind(callbackfn, that, 3)
                  var length = toLength(self.length)
                  var index = 0
                  var create = specificCreate || arraySpeciesCreate
                  var target = IS_MAP
                    ? create($this, length)
                    : IS_FILTER || IS_FILTER_OUT
                      ? create($this, 0)
                      : undefined
                  var value, result
                  for (; length > index; index++)
                    if (NO_HOLES || index in self) {
                      value = self[index]
                      result = boundFunction(value, index, O)
                      if (TYPE) {
                        if (IS_MAP) target[index] = result // map
                        else if (result)
                          switch (TYPE) {
                            case 3:
                              return true // some
                            case 5:
                              return value // find
                            case 6:
                              return index // findIndex
                            case 2:
                              push.call(target, value) // filter
                          }
                        else
                          switch (TYPE) {
                            case 4:
                              return false // every
                            case 7:
                              push.call(target, value) // filterOut
                          }
                      }
                    }
                  return IS_FIND_INDEX
                    ? -1
                    : IS_SOME || IS_EVERY
                      ? IS_EVERY
                      : target
                }
              }

              module.exports = {
                // `Array.prototype.forEach` method
                // https://tc39.es/ecma262/#sec-array.prototype.foreach
                forEach: createMethod(0),
                // `Array.prototype.map` method
                // https://tc39.es/ecma262/#sec-array.prototype.map
                map: createMethod(1),
                // `Array.prototype.filter` method
                // https://tc39.es/ecma262/#sec-array.prototype.filter
                filter: createMethod(2),
                // `Array.prototype.some` method
                // https://tc39.es/ecma262/#sec-array.prototype.some
                some: createMethod(3),
                // `Array.prototype.every` method
                // https://tc39.es/ecma262/#sec-array.prototype.every
                every: createMethod(4),
                // `Array.prototype.find` method
                // https://tc39.es/ecma262/#sec-array.prototype.find
                find: createMethod(5),
                // `Array.prototype.findIndex` method
                // https://tc39.es/ecma262/#sec-array.prototype.findIndex
                findIndex: createMethod(6),
                // `Array.prototype.filterOut` method
                // https://github.com/tc39/proposal-array-filtering
                filterOut: createMethod(7)
              }

              /***/
            },

            /***/ 6583: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_26271__
            ) {
              'use strict'

              var toIndexedObject = __nested_webpack_require_26271__(5656)
              var toInteger = __nested_webpack_require_26271__(9958)
              var toLength = __nested_webpack_require_26271__(7466)
              var arrayMethodIsStrict = __nested_webpack_require_26271__(9341)

              var min = Math.min
              var nativeLastIndexOf = [].lastIndexOf
              var NEGATIVE_ZERO =
                !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0
              var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf')
              var FORCED = NEGATIVE_ZERO || !STRICT_METHOD

              // `Array.prototype.lastIndexOf` method implementation
              // https://tc39.es/ecma262/#sec-array.prototype.lastindexof
              module.exports = FORCED
                ? function lastIndexOf(
                    searchElement /* , fromIndex = @[*-1] */
                  ) {
                    // convert -0 to +0
                    if (NEGATIVE_ZERO)
                      return nativeLastIndexOf.apply(this, arguments) || 0
                    var O = toIndexedObject(this)
                    var length = toLength(O.length)
                    var index = length - 1
                    if (arguments.length > 1)
                      index = min(index, toInteger(arguments[1]))
                    if (index < 0) index = length + index
                    for (; index >= 0; index--)
                      if (index in O && O[index] === searchElement)
                        return index || 0
                    return -1
                  }
                : nativeLastIndexOf

              /***/
            },

            /***/ 1194: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_27452__
            ) {
              var fails = __nested_webpack_require_27452__(7293)
              var wellKnownSymbol = __nested_webpack_require_27452__(5112)
              var V8_VERSION = __nested_webpack_require_27452__(7392)

              var SPECIES = wellKnownSymbol('species')

              module.exports = function (METHOD_NAME) {
                // We can't use this feature detection in V8 since it causes
                // deoptimization and serious performance degradation
                // https://github.com/zloirock/core-js/issues/677
                return (
                  V8_VERSION >= 51 ||
                  !fails(function () {
                    var array = []
                    var constructor = (array.constructor = {})
                    constructor[SPECIES] = function () {
                      return { foo: 1 }
                    }
                    return array[METHOD_NAME](Boolean).foo !== 1
                  })
                )
              }

              /***/
            },

            /***/ 9341: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_28188__
            ) {
              'use strict'

              var fails = __nested_webpack_require_28188__(7293)

              module.exports = function (METHOD_NAME, argument) {
                var method = [][METHOD_NAME]
                return (
                  !!method &&
                  fails(function () {
                    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
                    method.call(
                      null,
                      argument ||
                        function () {
                          throw 1
                        },
                      1
                    )
                  })
                )
              }

              /***/
            },

            /***/ 3671: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_28629__
            ) {
              var aFunction = __nested_webpack_require_28629__(3099)
              var toObject = __nested_webpack_require_28629__(7908)
              var IndexedObject = __nested_webpack_require_28629__(8361)
              var toLength = __nested_webpack_require_28629__(7466)

              // `Array.prototype.{ reduce, reduceRight }` methods implementation
              var createMethod = function (IS_RIGHT) {
                return function (that, callbackfn, argumentsLength, memo) {
                  aFunction(callbackfn)
                  var O = toObject(that)
                  var self = IndexedObject(O)
                  var length = toLength(O.length)
                  var index = IS_RIGHT ? length - 1 : 0
                  var i = IS_RIGHT ? -1 : 1
                  if (argumentsLength < 2)
                    while (true) {
                      if (index in self) {
                        memo = self[index]
                        index += i
                        break
                      }
                      index += i
                      if (IS_RIGHT ? index < 0 : length <= index) {
                        throw TypeError(
                          'Reduce of empty array with no initial value'
                        )
                      }
                    }
                  for (; IS_RIGHT ? index >= 0 : length > index; index += i)
                    if (index in self) {
                      memo = callbackfn(memo, self[index], index, O)
                    }
                  return memo
                }
              }

              module.exports = {
                // `Array.prototype.reduce` method
                // https://tc39.es/ecma262/#sec-array.prototype.reduce
                left: createMethod(false),
                // `Array.prototype.reduceRight` method
                // https://tc39.es/ecma262/#sec-array.prototype.reduceright
                right: createMethod(true)
              }

              /***/
            },

            /***/ 5417: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_30017__
            ) {
              var isObject = __nested_webpack_require_30017__(111)
              var isArray = __nested_webpack_require_30017__(3157)
              var wellKnownSymbol = __nested_webpack_require_30017__(5112)

              var SPECIES = wellKnownSymbol('species')

              // `ArraySpeciesCreate` abstract operation
              // https://tc39.es/ecma262/#sec-arrayspeciescreate
              module.exports = function (originalArray, length) {
                var C
                if (isArray(originalArray)) {
                  C = originalArray.constructor
                  // cross-realm fallback
                  if (
                    typeof C == 'function' &&
                    (C === Array || isArray(C.prototype))
                  )
                    C = undefined
                  else if (isObject(C)) {
                    C = C[SPECIES]
                    if (C === null) C = undefined
                  }
                }
                return new (C === undefined ? Array : C)(
                  length === 0 ? 0 : length
                )
              }

              /***/
            },

            /***/ 3411: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_30798__
            ) {
              var anObject = __nested_webpack_require_30798__(9670)
              var iteratorClose = __nested_webpack_require_30798__(9212)

              // call something on iterator step with safe closing on error
              module.exports = function (iterator, fn, value, ENTRIES) {
                try {
                  return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value)
                  // 7.4.6 IteratorClose(iterator, completion)
                } catch (error) {
                  iteratorClose(iterator)
                  throw error
                }
              }

              /***/
            },

            /***/ 7072: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_31303__
            ) {
              var wellKnownSymbol = __nested_webpack_require_31303__(5112)

              var ITERATOR = wellKnownSymbol('iterator')
              var SAFE_CLOSING = false

              try {
                var called = 0
                var iteratorWithReturn = {
                  next: function () {
                    return { done: !!called++ }
                  },
                  return: function () {
                    SAFE_CLOSING = true
                  }
                }
                iteratorWithReturn[ITERATOR] = function () {
                  return this
                }
                // eslint-disable-next-line no-throw-literal -- required for testing
                Array.from(iteratorWithReturn, function () {
                  throw 2
                })
              } catch (error) {
                /* empty */
              }

              module.exports = function (exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING) return false
                var ITERATION_SUPPORT = false
                try {
                  var object = {}
                  object[ITERATOR] = function () {
                    return {
                      next: function () {
                        return { done: (ITERATION_SUPPORT = true) }
                      }
                    }
                  }
                  exec(object)
                } catch (error) {
                  /* empty */
                }
                return ITERATION_SUPPORT
              }

              /***/
            },

            /***/ 4326: /***/ function (module) {
              var toString = {}.toString

              module.exports = function (it) {
                return toString.call(it).slice(8, -1)
              }

              /***/
            },

            /***/ 648: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_32503__
            ) {
              var TO_STRING_TAG_SUPPORT = __nested_webpack_require_32503__(1694)
              var classofRaw = __nested_webpack_require_32503__(4326)
              var wellKnownSymbol = __nested_webpack_require_32503__(5112)

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              // ES3 wrong here
              var CORRECT_ARGUMENTS =
                classofRaw(
                  (function () {
                    return arguments
                  })()
                ) == 'Arguments'

              // fallback for IE11 Script Access Denied error
              var tryGet = function (it, key) {
                try {
                  return it[key]
                } catch (error) {
                  /* empty */
                }
              }

              // getting tag from ES6+ `Object.prototype.toString`
              module.exports = TO_STRING_TAG_SUPPORT
                ? classofRaw
                : function (it) {
                    var O, tag, result
                    return it === undefined
                      ? 'Undefined'
                      : it === null
                        ? 'Null'
                        : // @@toStringTag case
                          typeof (tag = tryGet(
                              (O = Object(it)),
                              TO_STRING_TAG
                            )) == 'string'
                          ? tag
                          : // builtinTag case
                            CORRECT_ARGUMENTS
                            ? classofRaw(O)
                            : // ES3 arguments fallback
                              (result = classofRaw(O)) == 'Object' &&
                                typeof O.callee == 'function'
                              ? 'Arguments'
                              : result
                  }

              /***/
            },

            /***/ 9920: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_33565__
            ) {
              var has = __nested_webpack_require_33565__(6656)
              var ownKeys = __nested_webpack_require_33565__(3887)
              var getOwnPropertyDescriptorModule =
                __nested_webpack_require_33565__(1236)
              var definePropertyModule = __nested_webpack_require_33565__(3070)

              module.exports = function (target, source) {
                var keys = ownKeys(source)
                var defineProperty = definePropertyModule.f
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i]
                  if (!has(target, key))
                    defineProperty(
                      target,
                      key,
                      getOwnPropertyDescriptor(source, key)
                    )
                }
              }

              /***/
            },

            /***/ 8544: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_34217__
            ) {
              var fails = __nested_webpack_require_34217__(7293)

              module.exports = !fails(function () {
                function F() {
                  /* empty */
                }
                F.prototype.constructor = null
                return Object.getPrototypeOf(new F()) !== F.prototype
              })

              /***/
            },

            /***/ 4994: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_34520__
            ) {
              'use strict'

              var IteratorPrototype =
                __nested_webpack_require_34520__(3383).IteratorPrototype
              var create = __nested_webpack_require_34520__(30)
              var createPropertyDescriptor =
                __nested_webpack_require_34520__(9114)
              var setToStringTag = __nested_webpack_require_34520__(8003)
              var Iterators = __nested_webpack_require_34520__(7497)

              var returnThis = function () {
                return this
              }

              module.exports = function (IteratorConstructor, NAME, next) {
                var TO_STRING_TAG = NAME + ' Iterator'
                IteratorConstructor.prototype = create(IteratorPrototype, {
                  next: createPropertyDescriptor(1, next)
                })
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true)
                Iterators[TO_STRING_TAG] = returnThis
                return IteratorConstructor
              }

              /***/
            },

            /***/ 8880: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_35290__
            ) {
              var DESCRIPTORS = __nested_webpack_require_35290__(9781)
              var definePropertyModule = __nested_webpack_require_35290__(3070)
              var createPropertyDescriptor =
                __nested_webpack_require_35290__(9114)

              module.exports = DESCRIPTORS
                ? function (object, key, value) {
                    return definePropertyModule.f(
                      object,
                      key,
                      createPropertyDescriptor(1, value)
                    )
                  }
                : function (object, key, value) {
                    object[key] = value
                    return object
                  }

              /***/
            },

            /***/ 9114: /***/ function (module) {
              module.exports = function (bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value: value
                }
              }

              /***/
            },

            /***/ 6135: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_35996__
            ) {
              'use strict'

              var toPrimitive = __nested_webpack_require_35996__(7593)
              var definePropertyModule = __nested_webpack_require_35996__(3070)
              var createPropertyDescriptor =
                __nested_webpack_require_35996__(9114)

              module.exports = function (object, key, value) {
                var propertyKey = toPrimitive(key)
                if (propertyKey in object)
                  definePropertyModule.f(
                    object,
                    propertyKey,
                    createPropertyDescriptor(0, value)
                  )
                else object[propertyKey] = value
              }

              /***/
            },

            /***/ 654: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_36503__
            ) {
              'use strict'

              var $ = __nested_webpack_require_36503__(2109)
              var createIteratorConstructor =
                __nested_webpack_require_36503__(4994)
              var getPrototypeOf = __nested_webpack_require_36503__(9518)
              var setPrototypeOf = __nested_webpack_require_36503__(7674)
              var setToStringTag = __nested_webpack_require_36503__(8003)
              var createNonEnumerableProperty =
                __nested_webpack_require_36503__(8880)
              var redefine = __nested_webpack_require_36503__(1320)
              var wellKnownSymbol = __nested_webpack_require_36503__(5112)
              var IS_PURE = __nested_webpack_require_36503__(1913)
              var Iterators = __nested_webpack_require_36503__(7497)
              var IteratorsCore = __nested_webpack_require_36503__(3383)

              var IteratorPrototype = IteratorsCore.IteratorPrototype
              var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS
              var ITERATOR = wellKnownSymbol('iterator')
              var KEYS = 'keys'
              var VALUES = 'values'
              var ENTRIES = 'entries'

              var returnThis = function () {
                return this
              }

              module.exports = function (
                Iterable,
                NAME,
                IteratorConstructor,
                next,
                DEFAULT,
                IS_SET,
                FORCED
              ) {
                createIteratorConstructor(IteratorConstructor, NAME, next)

                var getIterationMethod = function (KIND) {
                  if (KIND === DEFAULT && defaultIterator)
                    return defaultIterator
                  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                    return IterablePrototype[KIND]
                  switch (KIND) {
                    case KEYS:
                      return function keys() {
                        return new IteratorConstructor(this, KIND)
                      }
                    case VALUES:
                      return function values() {
                        return new IteratorConstructor(this, KIND)
                      }
                    case ENTRIES:
                      return function entries() {
                        return new IteratorConstructor(this, KIND)
                      }
                  }
                  return function () {
                    return new IteratorConstructor(this)
                  }
                }

                var TO_STRING_TAG = NAME + ' Iterator'
                var INCORRECT_VALUES_NAME = false
                var IterablePrototype = Iterable.prototype
                var nativeIterator =
                  IterablePrototype[ITERATOR] ||
                  IterablePrototype['@@iterator'] ||
                  (DEFAULT && IterablePrototype[DEFAULT])
                var defaultIterator =
                  (!BUGGY_SAFARI_ITERATORS && nativeIterator) ||
                  getIterationMethod(DEFAULT)
                var anyNativeIterator =
                  NAME == 'Array'
                    ? IterablePrototype.entries || nativeIterator
                    : nativeIterator
                var CurrentIteratorPrototype, methods, KEY

                // fix native
                if (anyNativeIterator) {
                  CurrentIteratorPrototype = getPrototypeOf(
                    anyNativeIterator.call(new Iterable())
                  )
                  if (
                    IteratorPrototype !== Object.prototype &&
                    CurrentIteratorPrototype.next
                  ) {
                    if (
                      !IS_PURE &&
                      getPrototypeOf(CurrentIteratorPrototype) !==
                        IteratorPrototype
                    ) {
                      if (setPrototypeOf) {
                        setPrototypeOf(
                          CurrentIteratorPrototype,
                          IteratorPrototype
                        )
                      } else if (
                        typeof CurrentIteratorPrototype[ITERATOR] != 'function'
                      ) {
                        createNonEnumerableProperty(
                          CurrentIteratorPrototype,
                          ITERATOR,
                          returnThis
                        )
                      }
                    }
                    // Set @@toStringTag to native iterators
                    setToStringTag(
                      CurrentIteratorPrototype,
                      TO_STRING_TAG,
                      true,
                      true
                    )
                    if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis
                  }
                }

                // fix Array#{values, @@iterator}.name in V8 / FF
                if (
                  DEFAULT == VALUES &&
                  nativeIterator &&
                  nativeIterator.name !== VALUES
                ) {
                  INCORRECT_VALUES_NAME = true
                  defaultIterator = function values() {
                    return nativeIterator.call(this)
                  }
                }

                // define iterator
                if (
                  (!IS_PURE || FORCED) &&
                  IterablePrototype[ITERATOR] !== defaultIterator
                ) {
                  createNonEnumerableProperty(
                    IterablePrototype,
                    ITERATOR,
                    defaultIterator
                  )
                }
                Iterators[NAME] = defaultIterator

                // export additional methods
                if (DEFAULT) {
                  methods = {
                    values: getIterationMethod(VALUES),
                    keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                    entries: getIterationMethod(ENTRIES)
                  }
                  if (FORCED)
                    for (KEY in methods) {
                      if (
                        BUGGY_SAFARI_ITERATORS ||
                        INCORRECT_VALUES_NAME ||
                        !(KEY in IterablePrototype)
                      ) {
                        redefine(IterablePrototype, KEY, methods[KEY])
                      }
                    }
                  else
                    $(
                      {
                        target: NAME,
                        proto: true,
                        forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                      },
                      methods
                    )
                }

                return methods
              }

              /***/
            },

            /***/ 9781: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_40475__
            ) {
              var fails = __nested_webpack_require_40475__(7293)

              // Detect IE8's incomplete defineProperty implementation
              module.exports = !fails(function () {
                return (
                  Object.defineProperty({}, 1, {
                    get: function () {
                      return 7
                    }
                  })[1] != 7
                )
              })

              /***/
            },

            /***/ 317: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_40795__
            ) {
              var global = __nested_webpack_require_40795__(7854)
              var isObject = __nested_webpack_require_40795__(111)

              var document = global.document
              // typeof document.createElement is 'object' in old IE
              var EXISTS =
                isObject(document) && isObject(document.createElement)

              module.exports = function (it) {
                return EXISTS ? document.createElement(it) : {}
              }

              /***/
            },

            /***/ 8324: /***/ function (module) {
              // iterable DOM collections
              // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
              module.exports = {
                CSSRuleList: 0,
                CSSStyleDeclaration: 0,
                CSSValueList: 0,
                ClientRectList: 0,
                DOMRectList: 0,
                DOMStringList: 0,
                DOMTokenList: 1,
                DataTransferItemList: 0,
                FileList: 0,
                HTMLAllCollection: 0,
                HTMLCollection: 0,
                HTMLFormElement: 0,
                HTMLSelectElement: 0,
                MediaList: 0,
                MimeTypeArray: 0,
                NamedNodeMap: 0,
                NodeList: 1,
                PaintRequestList: 0,
                Plugin: 0,
                PluginArray: 0,
                SVGLengthList: 0,
                SVGNumberList: 0,
                SVGPathSegList: 0,
                SVGPointList: 0,
                SVGStringList: 0,
                SVGTransformList: 0,
                SourceBufferList: 0,
                StyleSheetList: 0,
                TextTrackCueList: 0,
                TextTrackList: 0,
                TouchList: 0
              }

              /***/
            },

            /***/ 8113: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_42025__
            ) {
              var getBuiltIn = __nested_webpack_require_42025__(5005)

              module.exports = getBuiltIn('navigator', 'userAgent') || ''

              /***/
            },

            /***/ 7392: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_42230__
            ) {
              var global = __nested_webpack_require_42230__(7854)
              var userAgent = __nested_webpack_require_42230__(8113)

              var process = global.process
              var versions = process && process.versions
              var v8 = versions && versions.v8
              var match, version

              if (v8) {
                match = v8.split('.')
                version = match[0] + match[1]
              } else if (userAgent) {
                match = userAgent.match(/Edge\/(\d+)/)
                if (!match || match[1] >= 74) {
                  match = userAgent.match(/Chrome\/(\d+)/)
                  if (match) version = match[1]
                }
              }

              module.exports = version && +version

              /***/
            },

            /***/ 748: /***/ function (module) {
              // IE8- don't enum bug keys
              module.exports = [
                'constructor',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'toLocaleString',
                'toString',
                'valueOf'
              ]

              /***/
            },

            /***/ 2109: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_43065__
            ) {
              var global = __nested_webpack_require_43065__(7854)
              var getOwnPropertyDescriptor =
                __nested_webpack_require_43065__(1236).f
              var createNonEnumerableProperty =
                __nested_webpack_require_43065__(8880)
              var redefine = __nested_webpack_require_43065__(1320)
              var setGlobal = __nested_webpack_require_43065__(3505)
              var copyConstructorProperties =
                __nested_webpack_require_43065__(9920)
              var isForced = __nested_webpack_require_43065__(4705)

              /*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
              module.exports = function (options, source) {
                var TARGET = options.target
                var GLOBAL = options.global
                var STATIC = options.stat
                var FORCED,
                  target,
                  key,
                  targetProperty,
                  sourceProperty,
                  descriptor
                if (GLOBAL) {
                  target = global
                } else if (STATIC) {
                  target = global[TARGET] || setGlobal(TARGET, {})
                } else {
                  target = (global[TARGET] || {}).prototype
                }
                if (target)
                  for (key in source) {
                    sourceProperty = source[key]
                    if (options.noTargetGet) {
                      descriptor = getOwnPropertyDescriptor(target, key)
                      targetProperty = descriptor && descriptor.value
                    } else targetProperty = target[key]
                    FORCED = isForced(
                      GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key,
                      options.forced
                    )
                    // contained in target
                    if (!FORCED && targetProperty !== undefined) {
                      if (typeof sourceProperty === typeof targetProperty)
                        continue
                      copyConstructorProperties(sourceProperty, targetProperty)
                    }
                    // add a flag to not completely full polyfills
                    if (
                      options.sham ||
                      (targetProperty && targetProperty.sham)
                    ) {
                      createNonEnumerableProperty(sourceProperty, 'sham', true)
                    }
                    // extend global
                    redefine(target, key, sourceProperty, options)
                  }
              }

              /***/
            },

            /***/ 7293: /***/ function (module) {
              module.exports = function (exec) {
                try {
                  return !!exec()
                } catch (error) {
                  return true
                }
              }

              /***/
            },

            /***/ 7007: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_45726__
            ) {
              'use strict'

              // TODO: Remove from `core-js@4` since it's moved to entry points
              __nested_webpack_require_45726__(4916)
              var redefine = __nested_webpack_require_45726__(1320)
              var fails = __nested_webpack_require_45726__(7293)
              var wellKnownSymbol = __nested_webpack_require_45726__(5112)
              var regexpExec = __nested_webpack_require_45726__(2261)
              var createNonEnumerableProperty =
                __nested_webpack_require_45726__(8880)

              var SPECIES = wellKnownSymbol('species')

              var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
                // #replace needs built-in support for named groups.
                // #match works fine because it just return the exec results, even if it has
                // a "grops" property.
                var re = /./
                re.exec = function () {
                  var result = []
                  result.groups = { a: '7' }
                  return result
                }
                return ''.replace(re, '$<a>') !== '7'
              })

              // IE <= 11 replaces $0 with the whole match, as if it was $&
              // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
              var REPLACE_KEEPS_$0 = (function () {
                return 'a'.replace(/./, '$0') === '$0'
              })()

              var REPLACE = wellKnownSymbol('replace')
              // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
              var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
                if (/./[REPLACE]) {
                  return /./[REPLACE]('a', '$0') === ''
                }
                return false
              })()

              // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
              // Weex JS has frozen built-in prototypes, so use try / catch wrapper
              var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
                // eslint-disable-next-line regexp/no-empty-group -- required for testing
                var re = /(?:)/
                var originalExec = re.exec
                re.exec = function () {
                  return originalExec.apply(this, arguments)
                }
                var result = 'ab'.split(re)
                return (
                  result.length !== 2 || result[0] !== 'a' || result[1] !== 'b'
                )
              })

              module.exports = function (KEY, length, exec, sham) {
                var SYMBOL = wellKnownSymbol(KEY)

                var DELEGATES_TO_SYMBOL = !fails(function () {
                  // String methods call symbol-named RegEp methods
                  var O = {}
                  O[SYMBOL] = function () {
                    return 7
                  }
                  return ''[KEY](O) != 7
                })

                var DELEGATES_TO_EXEC =
                  DELEGATES_TO_SYMBOL &&
                  !fails(function () {
                    // Symbol-named RegExp methods call .exec
                    var execCalled = false
                    var re = /a/

                    if (KEY === 'split') {
                      // We can't use real regex here since it causes deoptimization
                      // and serious performance degradation in V8
                      // https://github.com/zloirock/core-js/issues/306
                      re = {}
                      // RegExp[@@split] doesn't call the regex's exec method, but first creates
                      // a new one. We need to return the patched regex when creating the new one.
                      re.constructor = {}
                      re.constructor[SPECIES] = function () {
                        return re
                      }
                      re.flags = ''
                      re[SYMBOL] = /./[SYMBOL]
                    }

                    re.exec = function () {
                      execCalled = true
                      return null
                    }

                    re[SYMBOL]('')
                    return !execCalled
                  })

                if (
                  !DELEGATES_TO_SYMBOL ||
                  !DELEGATES_TO_EXEC ||
                  (KEY === 'replace' &&
                    !(
                      REPLACE_SUPPORTS_NAMED_GROUPS &&
                      REPLACE_KEEPS_$0 &&
                      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                    )) ||
                  (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
                ) {
                  var nativeRegExpMethod = /./[SYMBOL]
                  var methods = exec(
                    SYMBOL,
                    ''[KEY],
                    function (
                      nativeMethod,
                      regexp,
                      str,
                      arg2,
                      forceStringMethod
                    ) {
                      if (regexp.exec === regexpExec) {
                        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                          // The native String method already delegates to @@method (this
                          // polyfilled function), leasing to infinite recursion.
                          // We avoid it by directly calling the native @@method method.
                          return {
                            done: true,
                            value: nativeRegExpMethod.call(regexp, str, arg2)
                          }
                        }
                        return {
                          done: true,
                          value: nativeMethod.call(str, regexp, arg2)
                        }
                      }
                      return { done: false }
                    },
                    {
                      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
                      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:
                        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                    }
                  )
                  var stringMethod = methods[0]
                  var regexMethod = methods[1]

                  redefine(String.prototype, KEY, stringMethod)
                  redefine(
                    RegExp.prototype,
                    SYMBOL,
                    length == 2
                      ? // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
                        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
                        function (string, arg) {
                          return regexMethod.call(string, this, arg)
                        }
                      : // 21.2.5.6 RegExp.prototype[@@match](string)
                        // 21.2.5.9 RegExp.prototype[@@search](string)
                        function (string) {
                          return regexMethod.call(string, this)
                        }
                  )
                }

                if (sham)
                  createNonEnumerableProperty(
                    RegExp.prototype[SYMBOL],
                    'sham',
                    true
                  )
              }

              /***/
            },

            /***/ 9974: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_50488__
            ) {
              var aFunction = __nested_webpack_require_50488__(3099)

              // optional / simple context binding
              module.exports = function (fn, that, length) {
                aFunction(fn)
                if (that === undefined) return fn
                switch (length) {
                  case 0:
                    return function () {
                      return fn.call(that)
                    }
                  case 1:
                    return function (a) {
                      return fn.call(that, a)
                    }
                  case 2:
                    return function (a, b) {
                      return fn.call(that, a, b)
                    }
                  case 3:
                    return function (a, b, c) {
                      return fn.call(that, a, b, c)
                    }
                }
                return function (/* ...args */) {
                  return fn.apply(that, arguments)
                }
              }

              /***/
            },

            /***/ 5005: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_51177__
            ) {
              var path = __nested_webpack_require_51177__(857)
              var global = __nested_webpack_require_51177__(7854)

              var aFunction = function (variable) {
                return typeof variable == 'function' ? variable : undefined
              }

              module.exports = function (namespace, method) {
                return arguments.length < 2
                  ? aFunction(path[namespace]) || aFunction(global[namespace])
                  : (path[namespace] && path[namespace][method]) ||
                      (global[namespace] && global[namespace][method])
              }

              /***/
            },

            /***/ 1246: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_51701__
            ) {
              var classof = __nested_webpack_require_51701__(648)
              var Iterators = __nested_webpack_require_51701__(7497)
              var wellKnownSymbol = __nested_webpack_require_51701__(5112)

              var ITERATOR = wellKnownSymbol('iterator')

              module.exports = function (it) {
                if (it != undefined)
                  return (
                    it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)]
                  )
              }

              /***/
            },

            /***/ 8554: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_52112__
            ) {
              var anObject = __nested_webpack_require_52112__(9670)
              var getIteratorMethod = __nested_webpack_require_52112__(1246)

              module.exports = function (it) {
                var iteratorMethod = getIteratorMethod(it)
                if (typeof iteratorMethod != 'function') {
                  throw TypeError(String(it) + ' is not iterable')
                }
                return anObject(iteratorMethod.call(it))
              }

              /***/
            },

            /***/ 647: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_52531__
            ) {
              var toObject = __nested_webpack_require_52531__(7908)

              var floor = Math.floor
              var replace = ''.replace
              var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g
              var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g

              // https://tc39.es/ecma262/#sec-getsubstitution
              module.exports = function (
                matched,
                str,
                position,
                captures,
                namedCaptures,
                replacement
              ) {
                var tailPos = position + matched.length
                var m = captures.length
                var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED
                if (namedCaptures !== undefined) {
                  namedCaptures = toObject(namedCaptures)
                  symbols = SUBSTITUTION_SYMBOLS
                }
                return replace.call(replacement, symbols, function (match, ch) {
                  var capture
                  switch (ch.charAt(0)) {
                    case '$':
                      return '$'
                    case '&':
                      return matched
                    case '`':
                      return str.slice(0, position)
                    case "'":
                      return str.slice(tailPos)
                    case '<':
                      capture = namedCaptures[ch.slice(1, -1)]
                      break
                    default: // \d\d?
                      var n = +ch
                      if (n === 0) return match
                      if (n > m) {
                        var f = floor(n / 10)
                        if (f === 0) return match
                        if (f <= m)
                          return captures[f - 1] === undefined
                            ? ch.charAt(1)
                            : captures[f - 1] + ch.charAt(1)
                        return match
                      }
                      capture = captures[n - 1]
                  }
                  return capture === undefined ? '' : capture
                })
              }

              /***/
            },

            /***/ 7854: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_53970__
            ) {
              var check = function (it) {
                return it && it.Math == Math && it
              }

              // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
              module.exports =
                /* global globalThis -- safe */
                check(typeof globalThis == 'object' && globalThis) ||
                check(typeof window == 'object' && window) ||
                check(typeof self == 'object' && self) ||
                check(
                  typeof __nested_webpack_require_53970__.g == 'object' &&
                    __nested_webpack_require_53970__.g
                ) ||
                // eslint-disable-next-line no-new-func -- fallback
                (function () {
                  return this
                })() ||
                Function('return this')()

              /***/
            },

            /***/ 6656: /***/ function (module) {
              var hasOwnProperty = {}.hasOwnProperty

              module.exports = function (it, key) {
                return hasOwnProperty.call(it, key)
              }

              /***/
            },

            /***/ 3501: /***/ function (module) {
              module.exports = {}

              /***/
            },

            /***/ 490: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_54852__
            ) {
              var getBuiltIn = __nested_webpack_require_54852__(5005)

              module.exports = getBuiltIn('document', 'documentElement')

              /***/
            },

            /***/ 4664: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_55056__
            ) {
              var DESCRIPTORS = __nested_webpack_require_55056__(9781)
              var fails = __nested_webpack_require_55056__(7293)
              var createElement = __nested_webpack_require_55056__(317)

              // Thank's IE8 for his funny defineProperty
              module.exports =
                !DESCRIPTORS &&
                !fails(function () {
                  return (
                    Object.defineProperty(createElement('div'), 'a', {
                      get: function () {
                        return 7
                      }
                    }).a != 7
                  )
                })

              /***/
            },

            /***/ 1179: /***/ function (module) {
              // IEEE754 conversions based on https://github.com/feross/ieee754
              var abs = Math.abs
              var pow = Math.pow
              var floor = Math.floor
              var log = Math.log
              var LN2 = Math.LN2

              var pack = function (number, mantissaLength, bytes) {
                var buffer = new Array(bytes)
                var exponentLength = bytes * 8 - mantissaLength - 1
                var eMax = (1 << exponentLength) - 1
                var eBias = eMax >> 1
                var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0
                var sign =
                  number < 0 || (number === 0 && 1 / number < 0) ? 1 : 0
                var index = 0
                var exponent, mantissa, c
                number = abs(number)
                // eslint-disable-next-line no-self-compare -- NaN check
                if (number != number || number === Infinity) {
                  // eslint-disable-next-line no-self-compare -- NaN check
                  mantissa = number != number ? 1 : 0
                  exponent = eMax
                } else {
                  exponent = floor(log(number) / LN2)
                  if (number * (c = pow(2, -exponent)) < 1) {
                    exponent--
                    c *= 2
                  }
                  if (exponent + eBias >= 1) {
                    number += rt / c
                  } else {
                    number += rt * pow(2, 1 - eBias)
                  }
                  if (number * c >= 2) {
                    exponent++
                    c /= 2
                  }
                  if (exponent + eBias >= eMax) {
                    mantissa = 0
                    exponent = eMax
                  } else if (exponent + eBias >= 1) {
                    mantissa = (number * c - 1) * pow(2, mantissaLength)
                    exponent = exponent + eBias
                  } else {
                    mantissa =
                      number * pow(2, eBias - 1) * pow(2, mantissaLength)
                    exponent = 0
                  }
                }
                for (
                  ;
                  mantissaLength >= 8;
                  buffer[index++] = mantissa & 255,
                    mantissa /= 256,
                    mantissaLength -= 8
                );
                exponent = (exponent << mantissaLength) | mantissa
                exponentLength += mantissaLength
                for (
                  ;
                  exponentLength > 0;
                  buffer[index++] = exponent & 255,
                    exponent /= 256,
                    exponentLength -= 8
                );
                buffer[--index] |= sign * 128
                return buffer
              }

              var unpack = function (buffer, mantissaLength) {
                var bytes = buffer.length
                var exponentLength = bytes * 8 - mantissaLength - 1
                var eMax = (1 << exponentLength) - 1
                var eBias = eMax >> 1
                var nBits = exponentLength - 7
                var index = bytes - 1
                var sign = buffer[index--]
                var exponent = sign & 127
                var mantissa
                sign >>= 7
                for (
                  ;
                  nBits > 0;
                  exponent = exponent * 256 + buffer[index], index--, nBits -= 8
                );
                mantissa = exponent & ((1 << -nBits) - 1)
                exponent >>= -nBits
                nBits += mantissaLength
                for (
                  ;
                  nBits > 0;
                  mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8
                );
                if (exponent === 0) {
                  exponent = 1 - eBias
                } else if (exponent === eMax) {
                  return mantissa ? NaN : sign ? -Infinity : Infinity
                } else {
                  mantissa = mantissa + pow(2, mantissaLength)
                  exponent = exponent - eBias
                }
                return (
                  (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength)
                )
              }

              module.exports = {
                pack: pack,
                unpack: unpack
              }

              /***/
            },

            /***/ 8361: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_58329__
            ) {
              var fails = __nested_webpack_require_58329__(7293)
              var classof = __nested_webpack_require_58329__(4326)

              var split = ''.split

              // fallback for non-array-like ES3 and non-enumerable old V8 strings
              module.exports = fails(function () {
                // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
                // eslint-disable-next-line no-prototype-builtins -- safe
                return !Object('z').propertyIsEnumerable(0)
              })
                ? function (it) {
                    return classof(it) == 'String'
                      ? split.call(it, '')
                      : Object(it)
                  }
                : Object

              /***/
            },

            /***/ 9587: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_58925__
            ) {
              var isObject = __nested_webpack_require_58925__(111)
              var setPrototypeOf = __nested_webpack_require_58925__(7674)

              // makes subclassing work correct for wrapped built-ins
              module.exports = function ($this, dummy, Wrapper) {
                var NewTarget, NewTargetPrototype
                if (
                  // it can work only with native `setPrototypeOf`
                  setPrototypeOf &&
                  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
                  typeof (NewTarget = dummy.constructor) == 'function' &&
                  NewTarget !== Wrapper &&
                  isObject((NewTargetPrototype = NewTarget.prototype)) &&
                  NewTargetPrototype !== Wrapper.prototype
                )
                  setPrototypeOf($this, NewTargetPrototype)
                return $this
              }

              /***/
            },

            /***/ 2788: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_59686__
            ) {
              var store = __nested_webpack_require_59686__(5465)

              var functionToString = Function.toString

              // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
              if (typeof store.inspectSource != 'function') {
                store.inspectSource = function (it) {
                  return functionToString.call(it)
                }
              }

              module.exports = store.inspectSource

              /***/
            },

            /***/ 9909: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_60112__
            ) {
              var NATIVE_WEAK_MAP = __nested_webpack_require_60112__(8536)
              var global = __nested_webpack_require_60112__(7854)
              var isObject = __nested_webpack_require_60112__(111)
              var createNonEnumerableProperty =
                __nested_webpack_require_60112__(8880)
              var objectHas = __nested_webpack_require_60112__(6656)
              var shared = __nested_webpack_require_60112__(5465)
              var sharedKey = __nested_webpack_require_60112__(6200)
              var hiddenKeys = __nested_webpack_require_60112__(3501)

              var WeakMap = global.WeakMap
              var set, get, has

              var enforce = function (it) {
                return has(it) ? get(it) : set(it, {})
              }

              var getterFor = function (TYPE) {
                return function (it) {
                  var state
                  if (!isObject(it) || (state = get(it)).type !== TYPE) {
                    throw TypeError(
                      'Incompatible receiver, ' + TYPE + ' required'
                    )
                  }
                  return state
                }
              }

              if (NATIVE_WEAK_MAP) {
                var store = shared.state || (shared.state = new WeakMap())
                var wmget = store.get
                var wmhas = store.has
                var wmset = store.set
                set = function (it, metadata) {
                  metadata.facade = it
                  wmset.call(store, it, metadata)
                  return metadata
                }
                get = function (it) {
                  return wmget.call(store, it) || {}
                }
                has = function (it) {
                  return wmhas.call(store, it)
                }
              } else {
                var STATE = sharedKey('state')
                hiddenKeys[STATE] = true
                set = function (it, metadata) {
                  metadata.facade = it
                  createNonEnumerableProperty(it, STATE, metadata)
                  return metadata
                }
                get = function (it) {
                  return objectHas(it, STATE) ? it[STATE] : {}
                }
                has = function (it) {
                  return objectHas(it, STATE)
                }
              }

              module.exports = {
                set: set,
                get: get,
                has: has,
                enforce: enforce,
                getterFor: getterFor
              }

              /***/
            },

            /***/ 7659: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_61804__
            ) {
              var wellKnownSymbol = __nested_webpack_require_61804__(5112)
              var Iterators = __nested_webpack_require_61804__(7497)

              var ITERATOR = wellKnownSymbol('iterator')
              var ArrayPrototype = Array.prototype

              // check on default Array iterator
              module.exports = function (it) {
                return (
                  it !== undefined &&
                  (Iterators.Array === it || ArrayPrototype[ITERATOR] === it)
                )
              }

              /***/
            },

            /***/ 3157: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_62240__
            ) {
              var classof = __nested_webpack_require_62240__(4326)

              // `IsArray` abstract operation
              // https://tc39.es/ecma262/#sec-isarray
              module.exports =
                Array.isArray ||
                function isArray(arg) {
                  return classof(arg) == 'Array'
                }

              /***/
            },

            /***/ 4705: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_62548__
            ) {
              var fails = __nested_webpack_require_62548__(7293)

              var replacement = /#|\.prototype\./

              var isForced = function (feature, detection) {
                var value = data[normalize(feature)]
                return value == POLYFILL
                  ? true
                  : value == NATIVE
                    ? false
                    : typeof detection == 'function'
                      ? fails(detection)
                      : !!detection
              }

              var normalize = (isForced.normalize = function (string) {
                return String(string).replace(replacement, '.').toLowerCase()
              })

              var data = (isForced.data = {})
              var NATIVE = (isForced.NATIVE = 'N')
              var POLYFILL = (isForced.POLYFILL = 'P')

              module.exports = isForced

              /***/
            },

            /***/ 111: /***/ function (module) {
              module.exports = function (it) {
                return typeof it === 'object'
                  ? it !== null
                  : typeof it === 'function'
              }

              /***/
            },

            /***/ 1913: /***/ function (module) {
              module.exports = false

              /***/
            },

            /***/ 7850: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_63453__
            ) {
              var isObject = __nested_webpack_require_63453__(111)
              var classof = __nested_webpack_require_63453__(4326)
              var wellKnownSymbol = __nested_webpack_require_63453__(5112)

              var MATCH = wellKnownSymbol('match')

              // `IsRegExp` abstract operation
              // https://tc39.es/ecma262/#sec-isregexp
              module.exports = function (it) {
                var isRegExp
                return (
                  isObject(it) &&
                  ((isRegExp = it[MATCH]) !== undefined
                    ? !!isRegExp
                    : classof(it) == 'RegExp')
                )
              }

              /***/
            },

            /***/ 9212: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_63953__
            ) {
              var anObject = __nested_webpack_require_63953__(9670)

              module.exports = function (iterator) {
                var returnMethod = iterator['return']
                if (returnMethod !== undefined) {
                  return anObject(returnMethod.call(iterator)).value
                }
              }

              /***/
            },

            /***/ 3383: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_64274__
            ) {
              'use strict'

              var fails = __nested_webpack_require_64274__(7293)
              var getPrototypeOf = __nested_webpack_require_64274__(9518)
              var createNonEnumerableProperty =
                __nested_webpack_require_64274__(8880)
              var has = __nested_webpack_require_64274__(6656)
              var wellKnownSymbol = __nested_webpack_require_64274__(5112)
              var IS_PURE = __nested_webpack_require_64274__(1913)

              var ITERATOR = wellKnownSymbol('iterator')
              var BUGGY_SAFARI_ITERATORS = false

              var returnThis = function () {
                return this
              }

              // `%IteratorPrototype%` object
              // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
              var IteratorPrototype,
                PrototypeOfArrayIteratorPrototype,
                arrayIterator

              if ([].keys) {
                arrayIterator = [].keys()
                // Safari 8 has buggy iterators w/o `next`
                if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true
                else {
                  PrototypeOfArrayIteratorPrototype = getPrototypeOf(
                    getPrototypeOf(arrayIterator)
                  )
                  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                    IteratorPrototype = PrototypeOfArrayIteratorPrototype
                }
              }

              var NEW_ITERATOR_PROTOTYPE =
                IteratorPrototype == undefined ||
                fails(function () {
                  var test = {}
                  // FF44- legacy iterators case
                  return IteratorPrototype[ITERATOR].call(test) !== test
                })

              if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {}

              // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
              if (
                (!IS_PURE || NEW_ITERATOR_PROTOTYPE) &&
                !has(IteratorPrototype, ITERATOR)
              ) {
                createNonEnumerableProperty(
                  IteratorPrototype,
                  ITERATOR,
                  returnThis
                )
              }

              module.exports = {
                IteratorPrototype: IteratorPrototype,
                BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
              }

              /***/
            },

            /***/ 7497: /***/ function (module) {
              module.exports = {}

              /***/
            },

            /***/ 133: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_65970__
            ) {
              var fails = __nested_webpack_require_65970__(7293)

              module.exports =
                !!Object.getOwnPropertySymbols &&
                !fails(function () {
                  // Chrome 38 Symbol has incorrect toString conversion
                  /* global Symbol -- required for testing */
                  return !String(Symbol())
                })

              /***/
            },

            /***/ 590: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_66314__
            ) {
              var fails = __nested_webpack_require_66314__(7293)
              var wellKnownSymbol = __nested_webpack_require_66314__(5112)
              var IS_PURE = __nested_webpack_require_66314__(1913)

              var ITERATOR = wellKnownSymbol('iterator')

              module.exports = !fails(function () {
                var url = new URL('b?a=1&b=2&c=3', 'http://a')
                var searchParams = url.searchParams
                var result = ''
                url.pathname = 'c%20d'
                searchParams.forEach(function (value, key) {
                  searchParams['delete']('b')
                  result += key + value
                })
                return (
                  (IS_PURE && !url.toJSON) ||
                  !searchParams.sort ||
                  url.href !== 'http://a/c%20d?a=1&c=3' ||
                  searchParams.get('c') !== '3' ||
                  String(new URLSearchParams('?a=1')) !== 'a=1' ||
                  !searchParams[ITERATOR] ||
                  // throws in Edge
                  new URL('https://a@b').username !== 'a' ||
                  new URLSearchParams(new URLSearchParams('a=b')).get('a') !==
                    'b' ||
                  // not punycoded in Edge
                  new URL('http://тест').host !== 'xn--e1aybc' ||
                  // not escaped in Chrome 62-
                  new URL('http://a#б').hash !== '#%D0%B1' ||
                  // fails in Chrome 66-
                  result !== 'a1c3' ||
                  // throws in Safari
                  new URL('http://x', undefined).host !== 'x'
                )
              })

              /***/
            },

            /***/ 8536: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_67534__
            ) {
              var global = __nested_webpack_require_67534__(7854)
              var inspectSource = __nested_webpack_require_67534__(2788)

              var WeakMap = global.WeakMap

              module.exports =
                typeof WeakMap === 'function' &&
                /native code/.test(inspectSource(WeakMap))

              /***/
            },

            /***/ 1574: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_67846__
            ) {
              'use strict'

              var DESCRIPTORS = __nested_webpack_require_67846__(9781)
              var fails = __nested_webpack_require_67846__(7293)
              var objectKeys = __nested_webpack_require_67846__(1956)
              var getOwnPropertySymbolsModule =
                __nested_webpack_require_67846__(5181)
              var propertyIsEnumerableModule =
                __nested_webpack_require_67846__(5296)
              var toObject = __nested_webpack_require_67846__(7908)
              var IndexedObject = __nested_webpack_require_67846__(8361)

              var nativeAssign = Object.assign
              var defineProperty = Object.defineProperty

              // `Object.assign` method
              // https://tc39.es/ecma262/#sec-object.assign
              module.exports =
                !nativeAssign ||
                fails(function () {
                  // should have correct order of operations (Edge bug)
                  if (
                    DESCRIPTORS &&
                    nativeAssign(
                      { b: 1 },
                      nativeAssign(
                        defineProperty({}, 'a', {
                          enumerable: true,
                          get: function () {
                            defineProperty(this, 'b', {
                              value: 3,
                              enumerable: false
                            })
                          }
                        }),
                        { b: 2 }
                      )
                    ).b !== 1
                  )
                    return true
                  // should work with symbols and should have deterministic property order (V8 bug)
                  var A = {}
                  var B = {}
                  /* global Symbol -- required for testing */
                  var symbol = Symbol()
                  var alphabet = 'abcdefghijklmnopqrst'
                  A[symbol] = 7
                  alphabet.split('').forEach(function (chr) {
                    B[chr] = chr
                  })
                  return (
                    nativeAssign({}, A)[symbol] != 7 ||
                    objectKeys(nativeAssign({}, B)).join('') != alphabet
                  )
                })
                  ? function assign(target, source) {
                      // eslint-disable-line no-unused-vars -- required for `.length`
                      var T = toObject(target)
                      var argumentsLength = arguments.length
                      var index = 1
                      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f
                      var propertyIsEnumerable = propertyIsEnumerableModule.f
                      while (argumentsLength > index) {
                        var S = IndexedObject(arguments[index++])
                        var keys = getOwnPropertySymbols
                          ? objectKeys(S).concat(getOwnPropertySymbols(S))
                          : objectKeys(S)
                        var length = keys.length
                        var j = 0
                        var key
                        while (length > j) {
                          key = keys[j++]
                          if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))
                            T[key] = S[key]
                        }
                      }
                      return T
                    }
                  : nativeAssign

              /***/
            },

            /***/ 30: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_69941__
            ) {
              var anObject = __nested_webpack_require_69941__(9670)
              var defineProperties = __nested_webpack_require_69941__(6048)
              var enumBugKeys = __nested_webpack_require_69941__(748)
              var hiddenKeys = __nested_webpack_require_69941__(3501)
              var html = __nested_webpack_require_69941__(490)
              var documentCreateElement = __nested_webpack_require_69941__(317)
              var sharedKey = __nested_webpack_require_69941__(6200)

              var GT = '>'
              var LT = '<'
              var PROTOTYPE = 'prototype'
              var SCRIPT = 'script'
              var IE_PROTO = sharedKey('IE_PROTO')

              var EmptyConstructor = function () {
                /* empty */
              }

              var scriptTag = function (content) {
                return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT
              }

              // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
              var NullProtoObjectViaActiveX = function (activeXDocument) {
                activeXDocument.write(scriptTag(''))
                activeXDocument.close()
                var temp = activeXDocument.parentWindow.Object
                activeXDocument = null // avoid memory leak
                return temp
              }

              // Create object with fake `null` prototype: use iframe Object with cleared prototype
              var NullProtoObjectViaIFrame = function () {
                // Thrash, waste and sodomy: IE GC bug
                var iframe = documentCreateElement('iframe')
                var JS = 'java' + SCRIPT + ':'
                var iframeDocument
                iframe.style.display = 'none'
                html.appendChild(iframe)
                // https://github.com/zloirock/core-js/issues/475
                iframe.src = String(JS)
                iframeDocument = iframe.contentWindow.document
                iframeDocument.open()
                iframeDocument.write(scriptTag('document.F=Object'))
                iframeDocument.close()
                return iframeDocument.F
              }

              // Check for document.domain and active x support
              // No need to use active x approach when document.domain is not set
              // see https://github.com/es-shims/es5-shim/issues/150
              // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
              // avoid IE GC bug
              var activeXDocument
              var NullProtoObject = function () {
                try {
                  /* global ActiveXObject -- old IE */
                  activeXDocument =
                    document.domain && new ActiveXObject('htmlfile')
                } catch (error) {
                  /* ignore */
                }
                NullProtoObject = activeXDocument
                  ? NullProtoObjectViaActiveX(activeXDocument)
                  : NullProtoObjectViaIFrame()
                var length = enumBugKeys.length
                while (length--)
                  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]
                return NullProtoObject()
              }

              hiddenKeys[IE_PROTO] = true

              // `Object.create` method
              // https://tc39.es/ecma262/#sec-object.create
              module.exports =
                Object.create ||
                function create(O, Properties) {
                  var result
                  if (O !== null) {
                    EmptyConstructor[PROTOTYPE] = anObject(O)
                    result = new EmptyConstructor()
                    EmptyConstructor[PROTOTYPE] = null
                    // add "__proto__" for Object.getPrototypeOf polyfill
                    result[IE_PROTO] = O
                  } else result = NullProtoObject()
                  return Properties === undefined
                    ? result
                    : defineProperties(result, Properties)
                }

              /***/
            },

            /***/ 6048: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_72835__
            ) {
              var DESCRIPTORS = __nested_webpack_require_72835__(9781)
              var definePropertyModule = __nested_webpack_require_72835__(3070)
              var anObject = __nested_webpack_require_72835__(9670)
              var objectKeys = __nested_webpack_require_72835__(1956)

              // `Object.defineProperties` method
              // https://tc39.es/ecma262/#sec-object.defineproperties
              module.exports = DESCRIPTORS
                ? Object.defineProperties
                : function defineProperties(O, Properties) {
                    anObject(O)
                    var keys = objectKeys(Properties)
                    var length = keys.length
                    var index = 0
                    var key
                    while (length > index)
                      definePropertyModule.f(
                        O,
                        (key = keys[index++]),
                        Properties[key]
                      )
                    return O
                  }

              /***/
            },

            /***/ 3070: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_73525__
            ) {
              var DESCRIPTORS = __nested_webpack_require_73525__(9781)
              var IE8_DOM_DEFINE = __nested_webpack_require_73525__(4664)
              var anObject = __nested_webpack_require_73525__(9670)
              var toPrimitive = __nested_webpack_require_73525__(7593)

              var nativeDefineProperty = Object.defineProperty

              // `Object.defineProperty` method
              // https://tc39.es/ecma262/#sec-object.defineproperty
              exports.f = DESCRIPTORS
                ? nativeDefineProperty
                : function defineProperty(O, P, Attributes) {
                    anObject(O)
                    P = toPrimitive(P, true)
                    anObject(Attributes)
                    if (IE8_DOM_DEFINE)
                      try {
                        return nativeDefineProperty(O, P, Attributes)
                      } catch (error) {
                        /* empty */
                      }
                    if ('get' in Attributes || 'set' in Attributes)
                      throw TypeError('Accessors not supported')
                    if ('value' in Attributes) O[P] = Attributes.value
                    return O
                  }

              /***/
            },

            /***/ 1236: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_74380__
            ) {
              var DESCRIPTORS = __nested_webpack_require_74380__(9781)
              var propertyIsEnumerableModule =
                __nested_webpack_require_74380__(5296)
              var createPropertyDescriptor =
                __nested_webpack_require_74380__(9114)
              var toIndexedObject = __nested_webpack_require_74380__(5656)
              var toPrimitive = __nested_webpack_require_74380__(7593)
              var has = __nested_webpack_require_74380__(6656)
              var IE8_DOM_DEFINE = __nested_webpack_require_74380__(4664)

              var nativeGetOwnPropertyDescriptor =
                Object.getOwnPropertyDescriptor

              // `Object.getOwnPropertyDescriptor` method
              // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
              exports.f = DESCRIPTORS
                ? nativeGetOwnPropertyDescriptor
                : function getOwnPropertyDescriptor(O, P) {
                    O = toIndexedObject(O)
                    P = toPrimitive(P, true)
                    if (IE8_DOM_DEFINE)
                      try {
                        return nativeGetOwnPropertyDescriptor(O, P)
                      } catch (error) {
                        /* empty */
                      }
                    if (has(O, P))
                      return createPropertyDescriptor(
                        !propertyIsEnumerableModule.f.call(O, P),
                        O[P]
                      )
                  }

              /***/
            },

            /***/ 8006: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_75368__
            ) {
              var internalObjectKeys = __nested_webpack_require_75368__(6324)
              var enumBugKeys = __nested_webpack_require_75368__(748)

              var hiddenKeys = enumBugKeys.concat('length', 'prototype')

              // `Object.getOwnPropertyNames` method
              // https://tc39.es/ecma262/#sec-object.getownpropertynames
              exports.f =
                Object.getOwnPropertyNames ||
                function getOwnPropertyNames(O) {
                  return internalObjectKeys(O, hiddenKeys)
                }

              /***/
            },

            /***/ 5181: /***/ function (__unused_webpack_module, exports) {
              exports.f = Object.getOwnPropertySymbols

              /***/
            },

            /***/ 9518: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_75966__
            ) {
              var has = __nested_webpack_require_75966__(6656)
              var toObject = __nested_webpack_require_75966__(7908)
              var sharedKey = __nested_webpack_require_75966__(6200)
              var CORRECT_PROTOTYPE_GETTER =
                __nested_webpack_require_75966__(8544)

              var IE_PROTO = sharedKey('IE_PROTO')
              var ObjectPrototype = Object.prototype

              // `Object.getPrototypeOf` method
              // https://tc39.es/ecma262/#sec-object.getprototypeof
              module.exports = CORRECT_PROTOTYPE_GETTER
                ? Object.getPrototypeOf
                : function (O) {
                    O = toObject(O)
                    if (has(O, IE_PROTO)) return O[IE_PROTO]
                    if (
                      typeof O.constructor == 'function' &&
                      O instanceof O.constructor
                    ) {
                      return O.constructor.prototype
                    }
                    return O instanceof Object ? ObjectPrototype : null
                  }

              /***/
            },

            /***/ 6324: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_76729__
            ) {
              var has = __nested_webpack_require_76729__(6656)
              var toIndexedObject = __nested_webpack_require_76729__(5656)
              var indexOf = __nested_webpack_require_76729__(1318).indexOf
              var hiddenKeys = __nested_webpack_require_76729__(3501)

              module.exports = function (object, names) {
                var O = toIndexedObject(object)
                var i = 0
                var result = []
                var key
                for (key in O)
                  !has(hiddenKeys, key) && has(O, key) && result.push(key)
                // Don't enum bug & hidden keys
                while (names.length > i)
                  if (has(O, (key = names[i++]))) {
                    ~indexOf(result, key) || result.push(key)
                  }
                return result
              }

              /***/
            },

            /***/ 1956: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_77369__
            ) {
              var internalObjectKeys = __nested_webpack_require_77369__(6324)
              var enumBugKeys = __nested_webpack_require_77369__(748)

              // `Object.keys` method
              // https://tc39.es/ecma262/#sec-object.keys
              module.exports =
                Object.keys ||
                function keys(O) {
                  return internalObjectKeys(O, enumBugKeys)
                }

              /***/
            },

            /***/ 5296: /***/ function (__unused_webpack_module, exports) {
              'use strict'

              var nativePropertyIsEnumerable = {}.propertyIsEnumerable
              var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor

              // Nashorn ~ JDK8 bug
              var NASHORN_BUG =
                getOwnPropertyDescriptor &&
                !nativePropertyIsEnumerable.call({ 1: 2 }, 1)

              // `Object.prototype.propertyIsEnumerable` method implementation
              // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
              exports.f = NASHORN_BUG
                ? function propertyIsEnumerable(V) {
                    var descriptor = getOwnPropertyDescriptor(this, V)
                    return !!descriptor && descriptor.enumerable
                  }
                : nativePropertyIsEnumerable

              /***/
            },

            /***/ 7674: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_78394__
            ) {
              /* eslint-disable no-proto -- safe */
              var anObject = __nested_webpack_require_78394__(9670)
              var aPossiblePrototype = __nested_webpack_require_78394__(6077)

              // `Object.setPrototypeOf` method
              // https://tc39.es/ecma262/#sec-object.setprototypeof
              // Works with __proto__ only. Old v8 can't work with null proto objects.
              module.exports =
                Object.setPrototypeOf ||
                ('__proto__' in {}
                  ? (function () {
                      var CORRECT_SETTER = false
                      var test = {}
                      var setter
                      try {
                        setter = Object.getOwnPropertyDescriptor(
                          Object.prototype,
                          '__proto__'
                        ).set
                        setter.call(test, [])
                        CORRECT_SETTER = test instanceof Array
                      } catch (error) {
                        /* empty */
                      }
                      return function setPrototypeOf(O, proto) {
                        anObject(O)
                        aPossiblePrototype(proto)
                        if (CORRECT_SETTER) setter.call(O, proto)
                        else O.__proto__ = proto
                        return O
                      }
                    })()
                  : undefined)

              /***/
            },

            /***/ 288: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_79325__
            ) {
              'use strict'

              var TO_STRING_TAG_SUPPORT = __nested_webpack_require_79325__(1694)
              var classof = __nested_webpack_require_79325__(648)

              // `Object.prototype.toString` method implementation
              // https://tc39.es/ecma262/#sec-object.prototype.tostring
              module.exports = TO_STRING_TAG_SUPPORT
                ? {}.toString
                : function toString() {
                    return '[object ' + classof(this) + ']'
                  }

              /***/
            },

            /***/ 3887: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_79769__
            ) {
              var getBuiltIn = __nested_webpack_require_79769__(5005)
              var getOwnPropertyNamesModule =
                __nested_webpack_require_79769__(8006)
              var getOwnPropertySymbolsModule =
                __nested_webpack_require_79769__(5181)
              var anObject = __nested_webpack_require_79769__(9670)

              // all object keys, includes non-enumerable and symbols
              module.exports =
                getBuiltIn('Reflect', 'ownKeys') ||
                function ownKeys(it) {
                  var keys = getOwnPropertyNamesModule.f(anObject(it))
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f
                  return getOwnPropertySymbols
                    ? keys.concat(getOwnPropertySymbols(it))
                    : keys
                }

              /***/
            },

            /***/ 857: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_80406__
            ) {
              var global = __nested_webpack_require_80406__(7854)

              module.exports = global

              /***/
            },

            /***/ 2248: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_80571__
            ) {
              var redefine = __nested_webpack_require_80571__(1320)

              module.exports = function (target, src, options) {
                for (var key in src) redefine(target, key, src[key], options)
                return target
              }

              /***/
            },

            /***/ 1320: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_80849__
            ) {
              var global = __nested_webpack_require_80849__(7854)
              var createNonEnumerableProperty =
                __nested_webpack_require_80849__(8880)
              var has = __nested_webpack_require_80849__(6656)
              var setGlobal = __nested_webpack_require_80849__(3505)
              var inspectSource = __nested_webpack_require_80849__(2788)
              var InternalStateModule = __nested_webpack_require_80849__(9909)

              var getInternalState = InternalStateModule.get
              var enforceInternalState = InternalStateModule.enforce
              var TEMPLATE = String(String).split('String')

              ;(module.exports = function (O, key, value, options) {
                var unsafe = options ? !!options.unsafe : false
                var simple = options ? !!options.enumerable : false
                var noTargetGet = options ? !!options.noTargetGet : false
                var state
                if (typeof value == 'function') {
                  if (typeof key == 'string' && !has(value, 'name')) {
                    createNonEnumerableProperty(value, 'name', key)
                  }
                  state = enforceInternalState(value)
                  if (!state.source) {
                    state.source = TEMPLATE.join(
                      typeof key == 'string' ? key : ''
                    )
                  }
                }
                if (O === global) {
                  if (simple) O[key] = value
                  else setGlobal(key, value)
                  return
                } else if (!unsafe) {
                  delete O[key]
                } else if (!noTargetGet && O[key]) {
                  simple = true
                }
                if (simple) O[key] = value
                else createNonEnumerableProperty(O, key, value)
                // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
              })(Function.prototype, 'toString', function toString() {
                return (
                  (typeof this == 'function' &&
                    getInternalState(this).source) ||
                  inspectSource(this)
                )
              })

              /***/
            },

            /***/ 7651: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_82466__
            ) {
              var classof = __nested_webpack_require_82466__(4326)
              var regexpExec = __nested_webpack_require_82466__(2261)

              // `RegExpExec` abstract operation
              // https://tc39.es/ecma262/#sec-regexpexec
              module.exports = function (R, S) {
                var exec = R.exec
                if (typeof exec === 'function') {
                  var result = exec.call(R, S)
                  if (typeof result !== 'object') {
                    throw TypeError(
                      'RegExp exec method returned something other than an Object or null'
                    )
                  }
                  return result
                }

                if (classof(R) !== 'RegExp') {
                  throw TypeError('RegExp#exec called on incompatible receiver')
                }

                return regexpExec.call(R, S)
              }

              /***/
            },

            /***/ 2261: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_83158__
            ) {
              'use strict'

              var regexpFlags = __nested_webpack_require_83158__(7066)
              var stickyHelpers = __nested_webpack_require_83158__(2999)

              var nativeExec = RegExp.prototype.exec
              // This always refers to the native implementation, because the
              // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
              // which loads this file before patching the method.
              var nativeReplace = String.prototype.replace

              var patchedExec = nativeExec

              var UPDATES_LAST_INDEX_WRONG = (function () {
                var re1 = /a/
                var re2 = /b*/g
                nativeExec.call(re1, 'a')
                nativeExec.call(re2, 'a')
                return re1.lastIndex !== 0 || re2.lastIndex !== 0
              })()

              var UNSUPPORTED_Y =
                stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET

              // nonparticipating capturing group, copied from es5-shim's String#split patch.
              // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
              var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined

              var PATCH =
                UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y

              if (PATCH) {
                patchedExec = function exec(str) {
                  var re = this
                  var lastIndex, reCopy, match, i
                  var sticky = UNSUPPORTED_Y && re.sticky
                  var flags = regexpFlags.call(re)
                  var source = re.source
                  var charsAdded = 0
                  var strCopy = str

                  if (sticky) {
                    flags = flags.replace('y', '')
                    if (flags.indexOf('g') === -1) {
                      flags += 'g'
                    }

                    strCopy = String(str).slice(re.lastIndex)
                    // Support anchored sticky behavior.
                    if (
                      re.lastIndex > 0 &&
                      (!re.multiline ||
                        (re.multiline && str[re.lastIndex - 1] !== '\n'))
                    ) {
                      source = '(?: ' + source + ')'
                      strCopy = ' ' + strCopy
                      charsAdded++
                    }
                    // ^(? + rx + ) is needed, in combination with some str slicing, to
                    // simulate the 'y' flag.
                    reCopy = new RegExp('^(?:' + source + ')', flags)
                  }

                  if (NPCG_INCLUDED) {
                    reCopy = new RegExp('^' + source + '$(?!\\s)', flags)
                  }
                  if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex

                  match = nativeExec.call(sticky ? reCopy : re, strCopy)

                  if (sticky) {
                    if (match) {
                      match.input = match.input.slice(charsAdded)
                      match[0] = match[0].slice(charsAdded)
                      match.index = re.lastIndex
                      re.lastIndex += match[0].length
                    } else re.lastIndex = 0
                  } else if (UPDATES_LAST_INDEX_WRONG && match) {
                    re.lastIndex = re.global
                      ? match.index + match[0].length
                      : lastIndex
                  }
                  if (NPCG_INCLUDED && match && match.length > 1) {
                    // Fix browsers whose `exec` methods don't consistently return `undefined`
                    // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
                    nativeReplace.call(match[0], reCopy, function () {
                      for (i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) match[i] = undefined
                      }
                    })
                  }

                  return match
                }
              }

              module.exports = patchedExec

              /***/
            },

            /***/ 7066: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_86176__
            ) {
              'use strict'

              var anObject = __nested_webpack_require_86176__(9670)

              // `RegExp.prototype.flags` getter implementation
              // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
              module.exports = function () {
                var that = anObject(this)
                var result = ''
                if (that.global) result += 'g'
                if (that.ignoreCase) result += 'i'
                if (that.multiline) result += 'm'
                if (that.dotAll) result += 's'
                if (that.unicode) result += 'u'
                if (that.sticky) result += 'y'
                return result
              }

              /***/
            },

            /***/ 2999: /***/ function (
              __unused_webpack_module,
              exports,
              __nested_webpack_require_86753__
            ) {
              'use strict'

              var fails = __nested_webpack_require_86753__(7293)

              // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
              // so we use an intermediate function.
              function RE(s, f) {
                return RegExp(s, f)
              }

              exports.UNSUPPORTED_Y = fails(function () {
                // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
                var re = RE('a', 'y')
                re.lastIndex = 2
                return re.exec('abcd') != null
              })

              exports.BROKEN_CARET = fails(function () {
                // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
                var re = RE('^r', 'gy')
                re.lastIndex = 2
                return re.exec('str') != null
              })

              /***/
            },

            /***/ 4488: /***/ function (module) {
              // `RequireObjectCoercible` abstract operation
              // https://tc39.es/ecma262/#sec-requireobjectcoercible
              module.exports = function (it) {
                if (it == undefined)
                  throw TypeError("Can't call method on " + it)
                return it
              }

              /***/
            },

            /***/ 3505: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_87737__
            ) {
              var global = __nested_webpack_require_87737__(7854)
              var createNonEnumerableProperty =
                __nested_webpack_require_87737__(8880)

              module.exports = function (key, value) {
                try {
                  createNonEnumerableProperty(global, key, value)
                } catch (error) {
                  global[key] = value
                }
                return value
              }

              /***/
            },

            /***/ 6340: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_88106__
            ) {
              'use strict'

              var getBuiltIn = __nested_webpack_require_88106__(5005)
              var definePropertyModule = __nested_webpack_require_88106__(3070)
              var wellKnownSymbol = __nested_webpack_require_88106__(5112)
              var DESCRIPTORS = __nested_webpack_require_88106__(9781)

              var SPECIES = wellKnownSymbol('species')

              module.exports = function (CONSTRUCTOR_NAME) {
                var Constructor = getBuiltIn(CONSTRUCTOR_NAME)
                var defineProperty = definePropertyModule.f

                if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                  defineProperty(Constructor, SPECIES, {
                    configurable: true,
                    get: function () {
                      return this
                    }
                  })
                }
              }

              /***/
            },

            /***/ 8003: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_88786__
            ) {
              var defineProperty = __nested_webpack_require_88786__(3070).f
              var has = __nested_webpack_require_88786__(6656)
              var wellKnownSymbol = __nested_webpack_require_88786__(5112)

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')

              module.exports = function (it, TAG, STATIC) {
                if (
                  it &&
                  !has((it = STATIC ? it : it.prototype), TO_STRING_TAG)
                ) {
                  defineProperty(it, TO_STRING_TAG, {
                    configurable: true,
                    value: TAG
                  })
                }
              }

              /***/
            },

            /***/ 6200: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_89271__
            ) {
              var shared = __nested_webpack_require_89271__(2309)
              var uid = __nested_webpack_require_89271__(9711)

              var keys = shared('keys')

              module.exports = function (key) {
                return keys[key] || (keys[key] = uid(key))
              }

              /***/
            },

            /***/ 5465: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_89559__
            ) {
              var global = __nested_webpack_require_89559__(7854)
              var setGlobal = __nested_webpack_require_89559__(3505)

              var SHARED = '__core-js_shared__'
              var store = global[SHARED] || setGlobal(SHARED, {})

              module.exports = store

              /***/
            },

            /***/ 2309: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_89855__
            ) {
              var IS_PURE = __nested_webpack_require_89855__(1913)
              var store = __nested_webpack_require_89855__(5465)

              ;(module.exports = function (key, value) {
                return (
                  store[key] || (store[key] = value !== undefined ? value : {})
                )
              })('versions', []).push({
                version: '3.9.0',
                mode: IS_PURE ? 'pure' : 'global',
                copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
              })

              /***/
            },

            /***/ 6707: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_90288__
            ) {
              var anObject = __nested_webpack_require_90288__(9670)
              var aFunction = __nested_webpack_require_90288__(3099)
              var wellKnownSymbol = __nested_webpack_require_90288__(5112)

              var SPECIES = wellKnownSymbol('species')

              // `SpeciesConstructor` abstract operation
              // https://tc39.es/ecma262/#sec-speciesconstructor
              module.exports = function (O, defaultConstructor) {
                var C = anObject(O).constructor
                var S
                return C === undefined ||
                  (S = anObject(C)[SPECIES]) == undefined
                  ? defaultConstructor
                  : aFunction(S)
              }

              /***/
            },

            /***/ 8710: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_90863__
            ) {
              var toInteger = __nested_webpack_require_90863__(9958)
              var requireObjectCoercible =
                __nested_webpack_require_90863__(4488)

              // `String.prototype.{ codePointAt, at }` methods implementation
              var createMethod = function (CONVERT_TO_STRING) {
                return function ($this, pos) {
                  var S = String(requireObjectCoercible($this))
                  var position = toInteger(pos)
                  var size = S.length
                  var first, second
                  if (position < 0 || position >= size)
                    return CONVERT_TO_STRING ? '' : undefined
                  first = S.charCodeAt(position)
                  return first < 0xd800 ||
                    first > 0xdbff ||
                    position + 1 === size ||
                    (second = S.charCodeAt(position + 1)) < 0xdc00 ||
                    second > 0xdfff
                    ? CONVERT_TO_STRING
                      ? S.charAt(position)
                      : first
                    : CONVERT_TO_STRING
                      ? S.slice(position, position + 2)
                      : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000
                }
              }

              module.exports = {
                // `String.prototype.codePointAt` method
                // https://tc39.es/ecma262/#sec-string.prototype.codepointat
                codeAt: createMethod(false),
                // `String.prototype.at` method
                // https://github.com/mathiasbynens/String.prototype.at
                charAt: createMethod(true)
              }

              /***/
            },

            /***/ 3197: /***/ function (module) {
              'use strict'

              // based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
              var maxInt = 2147483647 // aka. 0x7FFFFFFF or 2^31-1
              var base = 36
              var tMin = 1
              var tMax = 26
              var skew = 38
              var damp = 700
              var initialBias = 72
              var initialN = 128 // 0x80
              var delimiter = '-' // '\x2D'
              var regexNonASCII = /[^\0-\u007E]/ // non-ASCII chars
              var regexSeparators = /[.\u3002\uFF0E\uFF61]/g // RFC 3490 separators
              var OVERFLOW_ERROR =
                'Overflow: input needs wider integers to process'
              var baseMinusTMin = base - tMin
              var floor = Math.floor
              var stringFromCharCode = String.fromCharCode

              /**
               * Creates an array containing the numeric code points of each Unicode
               * character in the string. While JavaScript uses UCS-2 internally,
               * this function will convert a pair of surrogate halves (each of which
               * UCS-2 exposes as separate characters) into a single code point,
               * matching UTF-16.
               */
              var ucs2decode = function (string) {
                var output = []
                var counter = 0
                var length = string.length
                while (counter < length) {
                  var value = string.charCodeAt(counter++)
                  if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                    // It's a high surrogate, and there is a next character.
                    var extra = string.charCodeAt(counter++)
                    if ((extra & 0xfc00) == 0xdc00) {
                      // Low surrogate.
                      output.push(
                        ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                      )
                    } else {
                      // It's an unmatched surrogate; only append this code unit, in case the
                      // next code unit is the high surrogate of a surrogate pair.
                      output.push(value)
                      counter--
                    }
                  } else {
                    output.push(value)
                  }
                }
                return output
              }

              /**
               * Converts a digit/integer into a basic code point.
               */
              var digitToBasic = function (digit) {
                //  0..25 map to ASCII a..z or A..Z
                // 26..35 map to ASCII 0..9
                return digit + 22 + 75 * (digit < 26)
              }

              /**
               * Bias adaptation function as per section 3.4 of RFC 3492.
               * https://tools.ietf.org/html/rfc3492#section-3.4
               */
              var adapt = function (delta, numPoints, firstTime) {
                var k = 0
                delta = firstTime ? floor(delta / damp) : delta >> 1
                delta += floor(delta / numPoints)
                for (; delta > (baseMinusTMin * tMax) >> 1; k += base) {
                  delta = floor(delta / baseMinusTMin)
                }
                return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew))
              }

              /**
               * Converts a string of Unicode symbols (e.g. a domain name label) to a
               * Punycode string of ASCII-only symbols.
               */
              // eslint-disable-next-line max-statements -- TODO
              var encode = function (input) {
                var output = []

                // Convert the input in UCS-2 to an array of Unicode code points.
                input = ucs2decode(input)

                // Cache the length.
                var inputLength = input.length

                // Initialize the state.
                var n = initialN
                var delta = 0
                var bias = initialBias
                var i, currentValue

                // Handle the basic code points.
                for (i = 0; i < input.length; i++) {
                  currentValue = input[i]
                  if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue))
                  }
                }

                var basicLength = output.length // number of basic code points.
                var handledCPCount = basicLength // number of code points that have been handled;

                // Finish the basic string with a delimiter unless it's empty.
                if (basicLength) {
                  output.push(delimiter)
                }

                // Main encoding loop:
                while (handledCPCount < inputLength) {
                  // All non-basic code points < n have been handled already. Find the next larger one:
                  var m = maxInt
                  for (i = 0; i < input.length; i++) {
                    currentValue = input[i]
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue
                    }
                  }

                  // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
                  var handledCPCountPlusOne = handledCPCount + 1
                  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    throw RangeError(OVERFLOW_ERROR)
                  }

                  delta += (m - n) * handledCPCountPlusOne
                  n = m

                  for (i = 0; i < input.length; i++) {
                    currentValue = input[i]
                    if (currentValue < n && ++delta > maxInt) {
                      throw RangeError(OVERFLOW_ERROR)
                    }
                    if (currentValue == n) {
                      // Represent delta as a generalized variable-length integer.
                      var q = delta
                      for (var k = base /* no condition */; ; k += base) {
                        var t =
                          k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
                        if (q < t) break
                        var qMinusT = q - t
                        var baseMinusT = base - t
                        output.push(
                          stringFromCharCode(
                            digitToBasic(t + (qMinusT % baseMinusT))
                          )
                        )
                        q = floor(qMinusT / baseMinusT)
                      }

                      output.push(stringFromCharCode(digitToBasic(q)))
                      bias = adapt(
                        delta,
                        handledCPCountPlusOne,
                        handledCPCount == basicLength
                      )
                      delta = 0
                      ++handledCPCount
                    }
                  }

                  ++delta
                  ++n
                }
                return output.join('')
              }

              module.exports = function (input) {
                var encoded = []
                var labels = input
                  .toLowerCase()
                  .replace(regexSeparators, '\u002E')
                  .split('.')
                var i, label
                for (i = 0; i < labels.length; i++) {
                  label = labels[i]
                  encoded.push(
                    regexNonASCII.test(label) ? 'xn--' + encode(label) : label
                  )
                }
                return encoded.join('.')
              }

              /***/
            },

            /***/ 6091: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_97360__
            ) {
              var fails = __nested_webpack_require_97360__(7293)
              var whitespaces = __nested_webpack_require_97360__(1361)

              var non = '\u200B\u0085\u180E'

              // check that a method works with the correct list
              // of whitespaces and has a correct name
              module.exports = function (METHOD_NAME) {
                return fails(function () {
                  return (
                    !!whitespaces[METHOD_NAME]() ||
                    non[METHOD_NAME]() != non ||
                    whitespaces[METHOD_NAME].name !== METHOD_NAME
                  )
                })
              }

              /***/
            },

            /***/ 3111: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_97868__
            ) {
              var requireObjectCoercible =
                __nested_webpack_require_97868__(4488)
              var whitespaces = __nested_webpack_require_97868__(1361)

              var whitespace = '[' + whitespaces + ']'
              var ltrim = RegExp('^' + whitespace + whitespace + '*')
              var rtrim = RegExp(whitespace + whitespace + '*$')

              // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
              var createMethod = function (TYPE) {
                return function ($this) {
                  var string = String(requireObjectCoercible($this))
                  if (TYPE & 1) string = string.replace(ltrim, '')
                  if (TYPE & 2) string = string.replace(rtrim, '')
                  return string
                }
              }

              module.exports = {
                // `String.prototype.{ trimLeft, trimStart }` methods
                // https://tc39.es/ecma262/#sec-string.prototype.trimstart
                start: createMethod(1),
                // `String.prototype.{ trimRight, trimEnd }` methods
                // https://tc39.es/ecma262/#sec-string.prototype.trimend
                end: createMethod(2),
                // `String.prototype.trim` method
                // https://tc39.es/ecma262/#sec-string.prototype.trim
                trim: createMethod(3)
              }

              /***/
            },

            /***/ 1400: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_98992__
            ) {
              var toInteger = __nested_webpack_require_98992__(9958)

              var max = Math.max
              var min = Math.min

              // Helper for a popular repeating case of the spec:
              // Let integer be ? ToInteger(index).
              // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
              module.exports = function (index, length) {
                var integer = toInteger(index)
                return integer < 0
                  ? max(integer + length, 0)
                  : min(integer, length)
              }

              /***/
            },

            /***/ 7067: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_99521__
            ) {
              var toInteger = __nested_webpack_require_99521__(9958)
              var toLength = __nested_webpack_require_99521__(7466)

              // `ToIndex` abstract operation
              // https://tc39.es/ecma262/#sec-toindex
              module.exports = function (it) {
                if (it === undefined) return 0
                var number = toInteger(it)
                var length = toLength(number)
                if (number !== length) throw RangeError('Wrong length or index')
                return length
              }

              /***/
            },

            /***/ 5656: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_99996__
            ) {
              // toObject with fallback for non-array-like ES3 strings
              var IndexedObject = __nested_webpack_require_99996__(8361)
              var requireObjectCoercible =
                __nested_webpack_require_99996__(4488)

              module.exports = function (it) {
                return IndexedObject(requireObjectCoercible(it))
              }

              /***/
            },

            /***/ 9958: /***/ function (module) {
              var ceil = Math.ceil
              var floor = Math.floor

              // `ToInteger` abstract operation
              // https://tc39.es/ecma262/#sec-tointeger
              module.exports = function (argument) {
                return isNaN((argument = +argument))
                  ? 0
                  : (argument > 0 ? floor : ceil)(argument)
              }

              /***/
            },

            /***/ 7466: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_100645__
            ) {
              var toInteger = __nested_webpack_require_100645__(9958)

              var min = Math.min

              // `ToLength` abstract operation
              // https://tc39.es/ecma262/#sec-tolength
              module.exports = function (argument) {
                return argument > 0
                  ? min(toInteger(argument), 0x1fffffffffffff)
                  : 0 // 2 ** 53 - 1 == 9007199254740991
              }

              /***/
            },

            /***/ 7908: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101032__
            ) {
              var requireObjectCoercible =
                __nested_webpack_require_101032__(4488)

              // `ToObject` abstract operation
              // https://tc39.es/ecma262/#sec-toobject
              module.exports = function (argument) {
                return Object(requireObjectCoercible(argument))
              }

              /***/
            },

            /***/ 4590: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101355__
            ) {
              var toPositiveInteger = __nested_webpack_require_101355__(3002)

              module.exports = function (it, BYTES) {
                var offset = toPositiveInteger(it)
                if (offset % BYTES) throw RangeError('Wrong offset')
                return offset
              }

              /***/
            },

            /***/ 3002: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101660__
            ) {
              var toInteger = __nested_webpack_require_101660__(9958)

              module.exports = function (it) {
                var result = toInteger(it)
                if (result < 0)
                  throw RangeError("The argument can't be less than 0")
                return result
              }

              /***/
            },

            /***/ 7593: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_101959__
            ) {
              var isObject = __nested_webpack_require_101959__(111)

              // `ToPrimitive` abstract operation
              // https://tc39.es/ecma262/#sec-toprimitive
              // instead of the ES6 spec version, we didn't implement @@toPrimitive case
              // and the second argument - flag - preferred type is a string
              module.exports = function (input, PREFERRED_STRING) {
                if (!isObject(input)) return input
                var fn, val
                if (
                  PREFERRED_STRING &&
                  typeof (fn = input.toString) == 'function' &&
                  !isObject((val = fn.call(input)))
                )
                  return val
                if (
                  typeof (fn = input.valueOf) == 'function' &&
                  !isObject((val = fn.call(input)))
                )
                  return val
                if (
                  !PREFERRED_STRING &&
                  typeof (fn = input.toString) == 'function' &&
                  !isObject((val = fn.call(input)))
                )
                  return val
                throw TypeError("Can't convert object to primitive value")
              }

              /***/
            },

            /***/ 1694: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_102821__
            ) {
              var wellKnownSymbol = __nested_webpack_require_102821__(5112)

              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              var test = {}

              test[TO_STRING_TAG] = 'z'

              module.exports = String(test) === '[object z]'

              /***/
            },

            /***/ 9843: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_103114__
            ) {
              'use strict'

              var $ = __nested_webpack_require_103114__(2109)
              var global = __nested_webpack_require_103114__(7854)
              var DESCRIPTORS = __nested_webpack_require_103114__(9781)
              var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS =
                __nested_webpack_require_103114__(3832)
              var ArrayBufferViewCore = __nested_webpack_require_103114__(260)
              var ArrayBufferModule = __nested_webpack_require_103114__(3331)
              var anInstance = __nested_webpack_require_103114__(5787)
              var createPropertyDescriptor =
                __nested_webpack_require_103114__(9114)
              var createNonEnumerableProperty =
                __nested_webpack_require_103114__(8880)
              var toLength = __nested_webpack_require_103114__(7466)
              var toIndex = __nested_webpack_require_103114__(7067)
              var toOffset = __nested_webpack_require_103114__(4590)
              var toPrimitive = __nested_webpack_require_103114__(7593)
              var has = __nested_webpack_require_103114__(6656)
              var classof = __nested_webpack_require_103114__(648)
              var isObject = __nested_webpack_require_103114__(111)
              var create = __nested_webpack_require_103114__(30)
              var setPrototypeOf = __nested_webpack_require_103114__(7674)
              var getOwnPropertyNames =
                __nested_webpack_require_103114__(8006).f
              var typedArrayFrom = __nested_webpack_require_103114__(7321)
              var forEach = __nested_webpack_require_103114__(2092).forEach
              var setSpecies = __nested_webpack_require_103114__(6340)
              var definePropertyModule = __nested_webpack_require_103114__(3070)
              var getOwnPropertyDescriptorModule =
                __nested_webpack_require_103114__(1236)
              var InternalStateModule = __nested_webpack_require_103114__(9909)
              var inheritIfRequired = __nested_webpack_require_103114__(9587)

              var getInternalState = InternalStateModule.get
              var setInternalState = InternalStateModule.set
              var nativeDefineProperty = definePropertyModule.f
              var nativeGetOwnPropertyDescriptor =
                getOwnPropertyDescriptorModule.f
              var round = Math.round
              var RangeError = global.RangeError
              var ArrayBuffer = ArrayBufferModule.ArrayBuffer
              var DataView = ArrayBufferModule.DataView
              var NATIVE_ARRAY_BUFFER_VIEWS =
                ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS
              var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG
              var TypedArray = ArrayBufferViewCore.TypedArray
              var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype
              var aTypedArrayConstructor =
                ArrayBufferViewCore.aTypedArrayConstructor
              var isTypedArray = ArrayBufferViewCore.isTypedArray
              var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT'
              var WRONG_LENGTH = 'Wrong length'

              var fromList = function (C, list) {
                var index = 0
                var length = list.length
                var result = new (aTypedArrayConstructor(C))(length)
                while (length > index) result[index] = list[index++]
                return result
              }

              var addGetter = function (it, key) {
                nativeDefineProperty(it, key, {
                  get: function () {
                    return getInternalState(this)[key]
                  }
                })
              }

              var isArrayBuffer = function (it) {
                var klass
                return (
                  it instanceof ArrayBuffer ||
                  (klass = classof(it)) == 'ArrayBuffer' ||
                  klass == 'SharedArrayBuffer'
                )
              }

              var isTypedArrayIndex = function (target, key) {
                return (
                  isTypedArray(target) &&
                  typeof key != 'symbol' &&
                  key in target &&
                  String(+key) == String(key)
                )
              }

              var wrappedGetOwnPropertyDescriptor =
                function getOwnPropertyDescriptor(target, key) {
                  return isTypedArrayIndex(
                    target,
                    (key = toPrimitive(key, true))
                  )
                    ? createPropertyDescriptor(2, target[key])
                    : nativeGetOwnPropertyDescriptor(target, key)
                }

              var wrappedDefineProperty = function defineProperty(
                target,
                key,
                descriptor
              ) {
                if (
                  isTypedArrayIndex(target, (key = toPrimitive(key, true))) &&
                  isObject(descriptor) &&
                  has(descriptor, 'value') &&
                  !has(descriptor, 'get') &&
                  !has(descriptor, 'set') &&
                  // TODO: add validation descriptor w/o calling accessors
                  !descriptor.configurable &&
                  (!has(descriptor, 'writable') || descriptor.writable) &&
                  (!has(descriptor, 'enumerable') || descriptor.enumerable)
                ) {
                  target[key] = descriptor.value
                  return target
                }
                return nativeDefineProperty(target, key, descriptor)
              }

              if (DESCRIPTORS) {
                if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                  getOwnPropertyDescriptorModule.f =
                    wrappedGetOwnPropertyDescriptor
                  definePropertyModule.f = wrappedDefineProperty
                  addGetter(TypedArrayPrototype, 'buffer')
                  addGetter(TypedArrayPrototype, 'byteOffset')
                  addGetter(TypedArrayPrototype, 'byteLength')
                  addGetter(TypedArrayPrototype, 'length')
                }

                $(
                  {
                    target: 'Object',
                    stat: true,
                    forced: !NATIVE_ARRAY_BUFFER_VIEWS
                  },
                  {
                    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
                    defineProperty: wrappedDefineProperty
                  }
                )

                module.exports = function (TYPE, wrapper, CLAMPED) {
                  var BYTES = TYPE.match(/\d+$/)[0] / 8
                  var CONSTRUCTOR_NAME =
                    TYPE + (CLAMPED ? 'Clamped' : '') + 'Array'
                  var GETTER = 'get' + TYPE
                  var SETTER = 'set' + TYPE
                  var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME]
                  var TypedArrayConstructor = NativeTypedArrayConstructor
                  var TypedArrayConstructorPrototype =
                    TypedArrayConstructor && TypedArrayConstructor.prototype
                  var exported = {}

                  var getter = function (that, index) {
                    var data = getInternalState(that)
                    return data.view[GETTER](
                      index * BYTES + data.byteOffset,
                      true
                    )
                  }

                  var setter = function (that, index, value) {
                    var data = getInternalState(that)
                    if (CLAMPED)
                      value =
                        (value = round(value)) < 0
                          ? 0
                          : value > 0xff
                            ? 0xff
                            : value & 0xff
                    data.view[SETTER](
                      index * BYTES + data.byteOffset,
                      value,
                      true
                    )
                  }

                  var addElement = function (that, index) {
                    nativeDefineProperty(that, index, {
                      get: function () {
                        return getter(this, index)
                      },
                      set: function (value) {
                        return setter(this, index, value)
                      },
                      enumerable: true
                    })
                  }

                  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                    TypedArrayConstructor = wrapper(
                      function (that, data, offset, $length) {
                        anInstance(
                          that,
                          TypedArrayConstructor,
                          CONSTRUCTOR_NAME
                        )
                        var index = 0
                        var byteOffset = 0
                        var buffer, byteLength, length
                        if (!isObject(data)) {
                          length = toIndex(data)
                          byteLength = length * BYTES
                          buffer = new ArrayBuffer(byteLength)
                        } else if (isArrayBuffer(data)) {
                          buffer = data
                          byteOffset = toOffset(offset, BYTES)
                          var $len = data.byteLength
                          if ($length === undefined) {
                            if ($len % BYTES) throw RangeError(WRONG_LENGTH)
                            byteLength = $len - byteOffset
                            if (byteLength < 0) throw RangeError(WRONG_LENGTH)
                          } else {
                            byteLength = toLength($length) * BYTES
                            if (byteLength + byteOffset > $len)
                              throw RangeError(WRONG_LENGTH)
                          }
                          length = byteLength / BYTES
                        } else if (isTypedArray(data)) {
                          return fromList(TypedArrayConstructor, data)
                        } else {
                          return typedArrayFrom.call(
                            TypedArrayConstructor,
                            data
                          )
                        }
                        setInternalState(that, {
                          buffer: buffer,
                          byteOffset: byteOffset,
                          byteLength: byteLength,
                          length: length,
                          view: new DataView(buffer)
                        })
                        while (index < length) addElement(that, index++)
                      }
                    )

                    if (setPrototypeOf)
                      setPrototypeOf(TypedArrayConstructor, TypedArray)
                    TypedArrayConstructorPrototype =
                      TypedArrayConstructor.prototype =
                        create(TypedArrayPrototype)
                  } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
                    TypedArrayConstructor = wrapper(
                      function (dummy, data, typedArrayOffset, $length) {
                        anInstance(
                          dummy,
                          TypedArrayConstructor,
                          CONSTRUCTOR_NAME
                        )
                        return inheritIfRequired(
                          (function () {
                            if (!isObject(data))
                              return new NativeTypedArrayConstructor(
                                toIndex(data)
                              )
                            if (isArrayBuffer(data))
                              return $length !== undefined
                                ? new NativeTypedArrayConstructor(
                                    data,
                                    toOffset(typedArrayOffset, BYTES),
                                    $length
                                  )
                                : typedArrayOffset !== undefined
                                  ? new NativeTypedArrayConstructor(
                                      data,
                                      toOffset(typedArrayOffset, BYTES)
                                    )
                                  : new NativeTypedArrayConstructor(data)
                            if (isTypedArray(data))
                              return fromList(TypedArrayConstructor, data)
                            return typedArrayFrom.call(
                              TypedArrayConstructor,
                              data
                            )
                          })(),
                          dummy,
                          TypedArrayConstructor
                        )
                      }
                    )

                    if (setPrototypeOf)
                      setPrototypeOf(TypedArrayConstructor, TypedArray)
                    forEach(
                      getOwnPropertyNames(NativeTypedArrayConstructor),
                      function (key) {
                        if (!(key in TypedArrayConstructor)) {
                          createNonEnumerableProperty(
                            TypedArrayConstructor,
                            key,
                            NativeTypedArrayConstructor[key]
                          )
                        }
                      }
                    )
                    TypedArrayConstructor.prototype =
                      TypedArrayConstructorPrototype
                  }

                  if (
                    TypedArrayConstructorPrototype.constructor !==
                    TypedArrayConstructor
                  ) {
                    createNonEnumerableProperty(
                      TypedArrayConstructorPrototype,
                      'constructor',
                      TypedArrayConstructor
                    )
                  }

                  if (TYPED_ARRAY_TAG) {
                    createNonEnumerableProperty(
                      TypedArrayConstructorPrototype,
                      TYPED_ARRAY_TAG,
                      CONSTRUCTOR_NAME
                    )
                  }

                  exported[CONSTRUCTOR_NAME] = TypedArrayConstructor

                  $(
                    {
                      global: true,
                      forced:
                        TypedArrayConstructor != NativeTypedArrayConstructor,
                      sham: !NATIVE_ARRAY_BUFFER_VIEWS
                    },
                    exported
                  )

                  if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
                    createNonEnumerableProperty(
                      TypedArrayConstructor,
                      BYTES_PER_ELEMENT,
                      BYTES
                    )
                  }

                  if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
                    createNonEnumerableProperty(
                      TypedArrayConstructorPrototype,
                      BYTES_PER_ELEMENT,
                      BYTES
                    )
                  }

                  setSpecies(CONSTRUCTOR_NAME)
                }
              } else
                module.exports = function () {
                  /* empty */
                }

              /***/
            },

            /***/ 3832: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_112503__
            ) {
              /* eslint-disable no-new -- required for testing */
              var global = __nested_webpack_require_112503__(7854)
              var fails = __nested_webpack_require_112503__(7293)
              var checkCorrectnessOfIteration =
                __nested_webpack_require_112503__(7072)
              var NATIVE_ARRAY_BUFFER_VIEWS =
                __nested_webpack_require_112503__(260).NATIVE_ARRAY_BUFFER_VIEWS

              var ArrayBuffer = global.ArrayBuffer
              var Int8Array = global.Int8Array

              module.exports =
                !NATIVE_ARRAY_BUFFER_VIEWS ||
                !fails(function () {
                  Int8Array(1)
                }) ||
                !fails(function () {
                  new Int8Array(-1)
                }) ||
                !checkCorrectnessOfIteration(function (iterable) {
                  new Int8Array()
                  new Int8Array(null)
                  new Int8Array(1.5)
                  new Int8Array(iterable)
                }, true) ||
                fails(function () {
                  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
                  return (
                    new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1
                  )
                })

              /***/
            },

            /***/ 3074: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_113426__
            ) {
              var aTypedArrayConstructor =
                __nested_webpack_require_113426__(260).aTypedArrayConstructor
              var speciesConstructor = __nested_webpack_require_113426__(6707)

              module.exports = function (instance, list) {
                var C = speciesConstructor(instance, instance.constructor)
                var index = 0
                var length = list.length
                var result = new (aTypedArrayConstructor(C))(length)
                while (length > index) result[index] = list[index++]
                return result
              }

              /***/
            },

            /***/ 7321: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_113940__
            ) {
              var toObject = __nested_webpack_require_113940__(7908)
              var toLength = __nested_webpack_require_113940__(7466)
              var getIteratorMethod = __nested_webpack_require_113940__(1246)
              var isArrayIteratorMethod =
                __nested_webpack_require_113940__(7659)
              var bind = __nested_webpack_require_113940__(9974)
              var aTypedArrayConstructor =
                __nested_webpack_require_113940__(260).aTypedArrayConstructor

              module.exports = function from(source /* , mapfn, thisArg */) {
                var O = toObject(source)
                var argumentsLength = arguments.length
                var mapfn = argumentsLength > 1 ? arguments[1] : undefined
                var mapping = mapfn !== undefined
                var iteratorMethod = getIteratorMethod(O)
                var i, length, result, step, iterator, next
                if (
                  iteratorMethod != undefined &&
                  !isArrayIteratorMethod(iteratorMethod)
                ) {
                  iterator = iteratorMethod.call(O)
                  next = iterator.next
                  O = []
                  while (!(step = next.call(iterator)).done) {
                    O.push(step.value)
                  }
                }
                if (mapping && argumentsLength > 2) {
                  mapfn = bind(mapfn, arguments[2], 2)
                }
                length = toLength(O.length)
                result = new (aTypedArrayConstructor(this))(length)
                for (i = 0; length > i; i++) {
                  result[i] = mapping ? mapfn(O[i], i) : O[i]
                }
                return result
              }

              /***/
            },

            /***/ 9711: /***/ function (module) {
              var id = 0
              var postfix = Math.random()

              module.exports = function (key) {
                return (
                  'Symbol(' +
                  String(key === undefined ? '' : key) +
                  ')_' +
                  (++id + postfix).toString(36)
                )
              }

              /***/
            },

            /***/ 3307: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_115419__
            ) {
              var NATIVE_SYMBOL = __nested_webpack_require_115419__(133)

              module.exports =
                NATIVE_SYMBOL &&
                /* global Symbol -- safe */
                !Symbol.sham &&
                typeof Symbol.iterator == 'symbol'

              /***/
            },

            /***/ 5112: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_115685__
            ) {
              var global = __nested_webpack_require_115685__(7854)
              var shared = __nested_webpack_require_115685__(2309)
              var has = __nested_webpack_require_115685__(6656)
              var uid = __nested_webpack_require_115685__(9711)
              var NATIVE_SYMBOL = __nested_webpack_require_115685__(133)
              var USE_SYMBOL_AS_UID = __nested_webpack_require_115685__(3307)

              var WellKnownSymbolsStore = shared('wks')
              var Symbol = global.Symbol
              var createWellKnownSymbol = USE_SYMBOL_AS_UID
                ? Symbol
                : (Symbol && Symbol.withoutSetter) || uid

              module.exports = function (name) {
                if (!has(WellKnownSymbolsStore, name)) {
                  if (NATIVE_SYMBOL && has(Symbol, name))
                    WellKnownSymbolsStore[name] = Symbol[name]
                  else
                    WellKnownSymbolsStore[name] = createWellKnownSymbol(
                      'Symbol.' + name
                    )
                }
                return WellKnownSymbolsStore[name]
              }

              /***/
            },

            /***/ 1361: /***/ function (module) {
              // a string of all valid unicode whitespaces
              module.exports =
                '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
                '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'

              /***/
            },

            /***/ 8264: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_116785__
            ) {
              'use strict'

              var $ = __nested_webpack_require_116785__(2109)
              var global = __nested_webpack_require_116785__(7854)
              var arrayBufferModule = __nested_webpack_require_116785__(3331)
              var setSpecies = __nested_webpack_require_116785__(6340)

              var ARRAY_BUFFER = 'ArrayBuffer'
              var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER]
              var NativeArrayBuffer = global[ARRAY_BUFFER]

              // `ArrayBuffer` constructor
              // https://tc39.es/ecma262/#sec-arraybuffer-constructor
              $(
                { global: true, forced: NativeArrayBuffer !== ArrayBuffer },
                {
                  ArrayBuffer: ArrayBuffer
                }
              )

              setSpecies(ARRAY_BUFFER)

              /***/
            },

            /***/ 2222: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_117427__
            ) {
              'use strict'

              var $ = __nested_webpack_require_117427__(2109)
              var fails = __nested_webpack_require_117427__(7293)
              var isArray = __nested_webpack_require_117427__(3157)
              var isObject = __nested_webpack_require_117427__(111)
              var toObject = __nested_webpack_require_117427__(7908)
              var toLength = __nested_webpack_require_117427__(7466)
              var createProperty = __nested_webpack_require_117427__(6135)
              var arraySpeciesCreate = __nested_webpack_require_117427__(5417)
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_117427__(1194)
              var wellKnownSymbol = __nested_webpack_require_117427__(5112)
              var V8_VERSION = __nested_webpack_require_117427__(7392)

              var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable')
              var MAX_SAFE_INTEGER = 0x1fffffffffffff
              var MAXIMUM_ALLOWED_INDEX_EXCEEDED =
                'Maximum allowed index exceeded'

              // We can't use this feature detection in V8 since it causes
              // deoptimization and serious performance degradation
              // https://github.com/zloirock/core-js/issues/679
              var IS_CONCAT_SPREADABLE_SUPPORT =
                V8_VERSION >= 51 ||
                !fails(function () {
                  var array = []
                  array[IS_CONCAT_SPREADABLE] = false
                  return array.concat()[0] !== array
                })

              var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat')

              var isConcatSpreadable = function (O) {
                if (!isObject(O)) return false
                var spreadable = O[IS_CONCAT_SPREADABLE]
                return spreadable !== undefined ? !!spreadable : isArray(O)
              }

              var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT

              // `Array.prototype.concat` method
              // https://tc39.es/ecma262/#sec-array.prototype.concat
              // with adding support of @@isConcatSpreadable and @@species
              $(
                { target: 'Array', proto: true, forced: FORCED },
                {
                  // eslint-disable-next-line no-unused-vars -- required for `.length`
                  concat: function concat(arg) {
                    var O = toObject(this)
                    var A = arraySpeciesCreate(O, 0)
                    var n = 0
                    var i, k, length, len, E
                    for (i = -1, length = arguments.length; i < length; i++) {
                      E = i === -1 ? O : arguments[i]
                      if (isConcatSpreadable(E)) {
                        len = toLength(E.length)
                        if (n + len > MAX_SAFE_INTEGER)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED)
                        for (k = 0; k < len; k++, n++)
                          if (k in E) createProperty(A, n, E[k])
                      } else {
                        if (n >= MAX_SAFE_INTEGER)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED)
                        createProperty(A, n++, E)
                      }
                    }
                    A.length = n
                    return A
                  }
                }
              )

              /***/
            },

            /***/ 7327: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_119834__
            ) {
              'use strict'

              var $ = __nested_webpack_require_119834__(2109)
              var $filter = __nested_webpack_require_119834__(2092).filter
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_119834__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter')

              // `Array.prototype.filter` method
              // https://tc39.es/ecma262/#sec-array.prototype.filter
              // with adding support of @@species
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  filter: function filter(callbackfn /* , thisArg */) {
                    return $filter(
                      this,
                      callbackfn,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                  }
                }
              )

              /***/
            },

            /***/ 2772: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_120523__
            ) {
              'use strict'

              var $ = __nested_webpack_require_120523__(2109)
              var $indexOf = __nested_webpack_require_120523__(1318).indexOf
              var arrayMethodIsStrict = __nested_webpack_require_120523__(9341)

              var nativeIndexOf = [].indexOf

              var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0
              var STRICT_METHOD = arrayMethodIsStrict('indexOf')

              // `Array.prototype.indexOf` method
              // https://tc39.es/ecma262/#sec-array.prototype.indexof
              $(
                {
                  target: 'Array',
                  proto: true,
                  forced: NEGATIVE_ZERO || !STRICT_METHOD
                },
                {
                  indexOf: function indexOf(
                    searchElement /* , fromIndex = 0 */
                  ) {
                    return NEGATIVE_ZERO
                      ? // convert -0 to +0
                        nativeIndexOf.apply(this, arguments) || 0
                      : $indexOf(
                          this,
                          searchElement,
                          arguments.length > 1 ? arguments[1] : undefined
                        )
                  }
                }
              )

              /***/
            },

            /***/ 6992: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_121364__
            ) {
              'use strict'

              var toIndexedObject = __nested_webpack_require_121364__(5656)
              var addToUnscopables = __nested_webpack_require_121364__(1223)
              var Iterators = __nested_webpack_require_121364__(7497)
              var InternalStateModule = __nested_webpack_require_121364__(9909)
              var defineIterator = __nested_webpack_require_121364__(654)

              var ARRAY_ITERATOR = 'Array Iterator'
              var setInternalState = InternalStateModule.set
              var getInternalState =
                InternalStateModule.getterFor(ARRAY_ITERATOR)

              // `Array.prototype.entries` method
              // https://tc39.es/ecma262/#sec-array.prototype.entries
              // `Array.prototype.keys` method
              // https://tc39.es/ecma262/#sec-array.prototype.keys
              // `Array.prototype.values` method
              // https://tc39.es/ecma262/#sec-array.prototype.values
              // `Array.prototype[@@iterator]` method
              // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
              // `CreateArrayIterator` internal method
              // https://tc39.es/ecma262/#sec-createarrayiterator
              module.exports = defineIterator(
                Array,
                'Array',
                function (iterated, kind) {
                  setInternalState(this, {
                    type: ARRAY_ITERATOR,
                    target: toIndexedObject(iterated), // target
                    index: 0, // next index
                    kind: kind // kind
                  })
                  // `%ArrayIteratorPrototype%.next` method
                  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
                },
                function () {
                  var state = getInternalState(this)
                  var target = state.target
                  var kind = state.kind
                  var index = state.index++
                  if (!target || index >= target.length) {
                    state.target = undefined
                    return { value: undefined, done: true }
                  }
                  if (kind == 'keys') return { value: index, done: false }
                  if (kind == 'values')
                    return { value: target[index], done: false }
                  return { value: [index, target[index]], done: false }
                },
                'values'
              )

              // argumentsList[@@iterator] is %ArrayProto_values%
              // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
              // https://tc39.es/ecma262/#sec-createmappedargumentsobject
              Iterators.Arguments = Iterators.Array

              // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
              addToUnscopables('keys')
              addToUnscopables('values')
              addToUnscopables('entries')

              /***/
            },

            /***/ 1249: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_123565__
            ) {
              'use strict'

              var $ = __nested_webpack_require_123565__(2109)
              var $map = __nested_webpack_require_123565__(2092).map
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_123565__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map')

              // `Array.prototype.map` method
              // https://tc39.es/ecma262/#sec-array.prototype.map
              // with adding support of @@species
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  map: function map(callbackfn /* , thisArg */) {
                    return $map(
                      this,
                      callbackfn,
                      arguments.length > 1 ? arguments[1] : undefined
                    )
                  }
                }
              )

              /***/
            },

            /***/ 7042: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_124230__
            ) {
              'use strict'

              var $ = __nested_webpack_require_124230__(2109)
              var isObject = __nested_webpack_require_124230__(111)
              var isArray = __nested_webpack_require_124230__(3157)
              var toAbsoluteIndex = __nested_webpack_require_124230__(1400)
              var toLength = __nested_webpack_require_124230__(7466)
              var toIndexedObject = __nested_webpack_require_124230__(5656)
              var createProperty = __nested_webpack_require_124230__(6135)
              var wellKnownSymbol = __nested_webpack_require_124230__(5112)
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_124230__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice')

              var SPECIES = wellKnownSymbol('species')
              var nativeSlice = [].slice
              var max = Math.max

              // `Array.prototype.slice` method
              // https://tc39.es/ecma262/#sec-array.prototype.slice
              // fallback for not array-like ES3 strings and DOM objects
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  slice: function slice(start, end) {
                    var O = toIndexedObject(this)
                    var length = toLength(O.length)
                    var k = toAbsoluteIndex(start, length)
                    var fin = toAbsoluteIndex(
                      end === undefined ? length : end,
                      length
                    )
                    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
                    var Constructor, result, n
                    if (isArray(O)) {
                      Constructor = O.constructor
                      // cross-realm fallback
                      if (
                        typeof Constructor == 'function' &&
                        (Constructor === Array ||
                          isArray(Constructor.prototype))
                      ) {
                        Constructor = undefined
                      } else if (isObject(Constructor)) {
                        Constructor = Constructor[SPECIES]
                        if (Constructor === null) Constructor = undefined
                      }
                      if (Constructor === Array || Constructor === undefined) {
                        return nativeSlice.call(O, k, fin)
                      }
                    }
                    result = new (
                      Constructor === undefined ? Array : Constructor
                    )(max(fin - k, 0))
                    for (n = 0; k < fin; k++, n++)
                      if (k in O) createProperty(result, n, O[k])
                    result.length = n
                    return result
                  }
                }
              )

              /***/
            },

            /***/ 561: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_126211__
            ) {
              'use strict'

              var $ = __nested_webpack_require_126211__(2109)
              var toAbsoluteIndex = __nested_webpack_require_126211__(1400)
              var toInteger = __nested_webpack_require_126211__(9958)
              var toLength = __nested_webpack_require_126211__(7466)
              var toObject = __nested_webpack_require_126211__(7908)
              var arraySpeciesCreate = __nested_webpack_require_126211__(5417)
              var createProperty = __nested_webpack_require_126211__(6135)
              var arrayMethodHasSpeciesSupport =
                __nested_webpack_require_126211__(1194)

              var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice')

              var max = Math.max
              var min = Math.min
              var MAX_SAFE_INTEGER = 0x1fffffffffffff
              var MAXIMUM_ALLOWED_LENGTH_EXCEEDED =
                'Maximum allowed length exceeded'

              // `Array.prototype.splice` method
              // https://tc39.es/ecma262/#sec-array.prototype.splice
              // with adding support of @@species
              $(
                { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT },
                {
                  splice: function splice(start, deleteCount /* , ...items */) {
                    var O = toObject(this)
                    var len = toLength(O.length)
                    var actualStart = toAbsoluteIndex(start, len)
                    var argumentsLength = arguments.length
                    var insertCount, actualDeleteCount, A, k, from, to
                    if (argumentsLength === 0) {
                      insertCount = actualDeleteCount = 0
                    } else if (argumentsLength === 1) {
                      insertCount = 0
                      actualDeleteCount = len - actualStart
                    } else {
                      insertCount = argumentsLength - 2
                      actualDeleteCount = min(
                        max(toInteger(deleteCount), 0),
                        len - actualStart
                      )
                    }
                    if (
                      len + insertCount - actualDeleteCount >
                      MAX_SAFE_INTEGER
                    ) {
                      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED)
                    }
                    A = arraySpeciesCreate(O, actualDeleteCount)
                    for (k = 0; k < actualDeleteCount; k++) {
                      from = actualStart + k
                      if (from in O) createProperty(A, k, O[from])
                    }
                    A.length = actualDeleteCount
                    if (insertCount < actualDeleteCount) {
                      for (k = actualStart; k < len - actualDeleteCount; k++) {
                        from = k + actualDeleteCount
                        to = k + insertCount
                        if (from in O) O[to] = O[from]
                        else delete O[to]
                      }
                      for (
                        k = len;
                        k > len - actualDeleteCount + insertCount;
                        k--
                      )
                        delete O[k - 1]
                    } else if (insertCount > actualDeleteCount) {
                      for (k = len - actualDeleteCount; k > actualStart; k--) {
                        from = k + actualDeleteCount - 1
                        to = k + insertCount - 1
                        if (from in O) O[to] = O[from]
                        else delete O[to]
                      }
                    }
                    for (k = 0; k < insertCount; k++) {
                      O[k + actualStart] = arguments[k + 2]
                    }
                    O.length = len - actualDeleteCount + insertCount
                    return A
                  }
                }
              )

              /***/
            },

            /***/ 8309: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_128857__
            ) {
              var DESCRIPTORS = __nested_webpack_require_128857__(9781)
              var defineProperty = __nested_webpack_require_128857__(3070).f

              var FunctionPrototype = Function.prototype
              var FunctionPrototypeToString = FunctionPrototype.toString
              var nameRE = /^\s*function ([^ (]*)/
              var NAME = 'name'

              // Function instances `.name` property
              // https://tc39.es/ecma262/#sec-function-instances-name
              if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
                defineProperty(FunctionPrototype, NAME, {
                  configurable: true,
                  get: function () {
                    try {
                      return FunctionPrototypeToString.call(this).match(
                        nameRE
                      )[1]
                    } catch (error) {
                      return ''
                    }
                  }
                })
              }

              /***/
            },

            /***/ 489: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_129614__
            ) {
              var $ = __nested_webpack_require_129614__(2109)
              var fails = __nested_webpack_require_129614__(7293)
              var toObject = __nested_webpack_require_129614__(7908)
              var nativeGetPrototypeOf = __nested_webpack_require_129614__(9518)
              var CORRECT_PROTOTYPE_GETTER =
                __nested_webpack_require_129614__(8544)

              var FAILS_ON_PRIMITIVES = fails(function () {
                nativeGetPrototypeOf(1)
              })

              // `Object.getPrototypeOf` method
              // https://tc39.es/ecma262/#sec-object.getprototypeof
              $(
                {
                  target: 'Object',
                  stat: true,
                  forced: FAILS_ON_PRIMITIVES,
                  sham: !CORRECT_PROTOTYPE_GETTER
                },
                {
                  getPrototypeOf: function getPrototypeOf(it) {
                    return nativeGetPrototypeOf(toObject(it))
                  }
                }
              )

              /***/
            },

            /***/ 1539: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_130327__
            ) {
              var TO_STRING_TAG_SUPPORT =
                __nested_webpack_require_130327__(1694)
              var redefine = __nested_webpack_require_130327__(1320)
              var toString = __nested_webpack_require_130327__(288)

              // `Object.prototype.toString` method
              // https://tc39.es/ecma262/#sec-object.prototype.tostring
              if (!TO_STRING_TAG_SUPPORT) {
                redefine(Object.prototype, 'toString', toString, {
                  unsafe: true
                })
              }

              /***/
            },

            /***/ 4916: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_130780__
            ) {
              'use strict'

              var $ = __nested_webpack_require_130780__(2109)
              var exec = __nested_webpack_require_130780__(2261)

              // `RegExp.prototype.exec` method
              // https://tc39.es/ecma262/#sec-regexp.prototype.exec
              $(
                { target: 'RegExp', proto: true, forced: /./.exec !== exec },
                {
                  exec: exec
                }
              )

              /***/
            },

            /***/ 9714: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_131156__
            ) {
              'use strict'

              var redefine = __nested_webpack_require_131156__(1320)
              var anObject = __nested_webpack_require_131156__(9670)
              var fails = __nested_webpack_require_131156__(7293)
              var flags = __nested_webpack_require_131156__(7066)

              var TO_STRING = 'toString'
              var RegExpPrototype = RegExp.prototype
              var nativeToString = RegExpPrototype[TO_STRING]

              var NOT_GENERIC = fails(function () {
                return (
                  nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'
                )
              })
              // FF44- RegExp#toString has a wrong name
              var INCORRECT_NAME = nativeToString.name != TO_STRING

              // `RegExp.prototype.toString` method
              // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
              if (NOT_GENERIC || INCORRECT_NAME) {
                redefine(
                  RegExp.prototype,
                  TO_STRING,
                  function toString() {
                    var R = anObject(this)
                    var p = String(R.source)
                    var rf = R.flags
                    var f = String(
                      rf === undefined &&
                        R instanceof RegExp &&
                        !('flags' in RegExpPrototype)
                        ? flags.call(R)
                        : rf
                    )
                    return '/' + p + '/' + f
                  },
                  { unsafe: true }
                )
              }

              /***/
            },

            /***/ 8783: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_132221__
            ) {
              'use strict'

              var charAt = __nested_webpack_require_132221__(8710).charAt
              var InternalStateModule = __nested_webpack_require_132221__(9909)
              var defineIterator = __nested_webpack_require_132221__(654)

              var STRING_ITERATOR = 'String Iterator'
              var setInternalState = InternalStateModule.set
              var getInternalState =
                InternalStateModule.getterFor(STRING_ITERATOR)

              // `String.prototype[@@iterator]` method
              // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
              defineIterator(
                String,
                'String',
                function (iterated) {
                  setInternalState(this, {
                    type: STRING_ITERATOR,
                    string: String(iterated),
                    index: 0
                  })
                  // `%StringIteratorPrototype%.next` method
                  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
                },
                function next() {
                  var state = getInternalState(this)
                  var string = state.string
                  var index = state.index
                  var point
                  if (index >= string.length)
                    return { value: undefined, done: true }
                  point = charAt(string, index)
                  state.index += point.length
                  return { value: point, done: false }
                }
              )

              /***/
            },

            /***/ 4723: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_133333__
            ) {
              'use strict'

              var fixRegExpWellKnownSymbolLogic =
                __nested_webpack_require_133333__(7007)
              var anObject = __nested_webpack_require_133333__(9670)
              var toLength = __nested_webpack_require_133333__(7466)
              var requireObjectCoercible =
                __nested_webpack_require_133333__(4488)
              var advanceStringIndex = __nested_webpack_require_133333__(1530)
              var regExpExec = __nested_webpack_require_133333__(7651)

              // @@match logic
              fixRegExpWellKnownSymbolLogic(
                'match',
                1,
                function (MATCH, nativeMatch, maybeCallNative) {
                  return [
                    // `String.prototype.match` method
                    // https://tc39.es/ecma262/#sec-string.prototype.match
                    function match(regexp) {
                      var O = requireObjectCoercible(this)
                      var matcher =
                        regexp == undefined ? undefined : regexp[MATCH]
                      return matcher !== undefined
                        ? matcher.call(regexp, O)
                        : new RegExp(regexp)[MATCH](String(O))
                    },
                    // `RegExp.prototype[@@match]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
                    function (regexp) {
                      var res = maybeCallNative(nativeMatch, regexp, this)
                      if (res.done) return res.value

                      var rx = anObject(regexp)
                      var S = String(this)

                      if (!rx.global) return regExpExec(rx, S)

                      var fullUnicode = rx.unicode
                      rx.lastIndex = 0
                      var A = []
                      var n = 0
                      var result
                      while ((result = regExpExec(rx, S)) !== null) {
                        var matchStr = String(result[0])
                        A[n] = matchStr
                        if (matchStr === '')
                          rx.lastIndex = advanceStringIndex(
                            S,
                            toLength(rx.lastIndex),
                            fullUnicode
                          )
                        n++
                      }
                      return n === 0 ? null : A
                    }
                  ]
                }
              )

              /***/
            },

            /***/ 5306: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_134975__
            ) {
              'use strict'

              var fixRegExpWellKnownSymbolLogic =
                __nested_webpack_require_134975__(7007)
              var anObject = __nested_webpack_require_134975__(9670)
              var toLength = __nested_webpack_require_134975__(7466)
              var toInteger = __nested_webpack_require_134975__(9958)
              var requireObjectCoercible =
                __nested_webpack_require_134975__(4488)
              var advanceStringIndex = __nested_webpack_require_134975__(1530)
              var getSubstitution = __nested_webpack_require_134975__(647)
              var regExpExec = __nested_webpack_require_134975__(7651)

              var max = Math.max
              var min = Math.min

              var maybeToString = function (it) {
                return it === undefined ? it : String(it)
              }

              // @@replace logic
              fixRegExpWellKnownSymbolLogic(
                'replace',
                2,
                function (REPLACE, nativeReplace, maybeCallNative, reason) {
                  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE =
                    reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0
                  var UNSAFE_SUBSTITUTE =
                    REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0'

                  return [
                    // `String.prototype.replace` method
                    // https://tc39.es/ecma262/#sec-string.prototype.replace
                    function replace(searchValue, replaceValue) {
                      var O = requireObjectCoercible(this)
                      var replacer =
                        searchValue == undefined
                          ? undefined
                          : searchValue[REPLACE]
                      return replacer !== undefined
                        ? replacer.call(searchValue, O, replaceValue)
                        : nativeReplace.call(
                            String(O),
                            searchValue,
                            replaceValue
                          )
                    },
                    // `RegExp.prototype[@@replace]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
                    function (regexp, replaceValue) {
                      if (
                        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE &&
                          REPLACE_KEEPS_$0) ||
                        (typeof replaceValue === 'string' &&
                          replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
                      ) {
                        var res = maybeCallNative(
                          nativeReplace,
                          regexp,
                          this,
                          replaceValue
                        )
                        if (res.done) return res.value
                      }

                      var rx = anObject(regexp)
                      var S = String(this)

                      var functionalReplace = typeof replaceValue === 'function'
                      if (!functionalReplace)
                        replaceValue = String(replaceValue)

                      var global = rx.global
                      if (global) {
                        var fullUnicode = rx.unicode
                        rx.lastIndex = 0
                      }
                      var results = []
                      while (true) {
                        var result = regExpExec(rx, S)
                        if (result === null) break

                        results.push(result)
                        if (!global) break

                        var matchStr = String(result[0])
                        if (matchStr === '')
                          rx.lastIndex = advanceStringIndex(
                            S,
                            toLength(rx.lastIndex),
                            fullUnicode
                          )
                      }

                      var accumulatedResult = ''
                      var nextSourcePosition = 0
                      for (var i = 0; i < results.length; i++) {
                        result = results[i]

                        var matched = String(result[0])
                        var position = max(
                          min(toInteger(result.index), S.length),
                          0
                        )
                        var captures = []
                        // NOTE: This is equivalent to
                        //   captures = result.slice(1).map(maybeToString)
                        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                        for (var j = 1; j < result.length; j++)
                          captures.push(maybeToString(result[j]))
                        var namedCaptures = result.groups
                        if (functionalReplace) {
                          var replacerArgs = [matched].concat(
                            captures,
                            position,
                            S
                          )
                          if (namedCaptures !== undefined)
                            replacerArgs.push(namedCaptures)
                          var replacement = String(
                            replaceValue.apply(undefined, replacerArgs)
                          )
                        } else {
                          replacement = getSubstitution(
                            matched,
                            S,
                            position,
                            captures,
                            namedCaptures,
                            replaceValue
                          )
                        }
                        if (position >= nextSourcePosition) {
                          accumulatedResult +=
                            S.slice(nextSourcePosition, position) + replacement
                          nextSourcePosition = position + matched.length
                        }
                      }
                      return accumulatedResult + S.slice(nextSourcePosition)
                    }
                  ]
                }
              )

              /***/
            },

            /***/ 3123: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_139010__
            ) {
              'use strict'

              var fixRegExpWellKnownSymbolLogic =
                __nested_webpack_require_139010__(7007)
              var isRegExp = __nested_webpack_require_139010__(7850)
              var anObject = __nested_webpack_require_139010__(9670)
              var requireObjectCoercible =
                __nested_webpack_require_139010__(4488)
              var speciesConstructor = __nested_webpack_require_139010__(6707)
              var advanceStringIndex = __nested_webpack_require_139010__(1530)
              var toLength = __nested_webpack_require_139010__(7466)
              var callRegExpExec = __nested_webpack_require_139010__(7651)
              var regexpExec = __nested_webpack_require_139010__(2261)
              var fails = __nested_webpack_require_139010__(7293)

              var arrayPush = [].push
              var min = Math.min
              var MAX_UINT32 = 0xffffffff

              // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
              var SUPPORTS_Y = !fails(function () {
                return !RegExp(MAX_UINT32, 'y')
              })

              // @@split logic
              fixRegExpWellKnownSymbolLogic(
                'split',
                2,
                function (SPLIT, nativeSplit, maybeCallNative) {
                  var internalSplit
                  if (
                    'abbc'.split(/(b)*/)[1] == 'c' ||
                    // eslint-disable-next-line regexp/no-empty-group -- required for testing
                    'test'.split(/(?:)/, -1).length != 4 ||
                    'ab'.split(/(?:ab)*/).length != 2 ||
                    '.'.split(/(.?)(.?)/).length != 4 ||
                    // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
                    '.'.split(/()()/).length > 1 ||
                    ''.split(/.?/).length
                  ) {
                    // based on es5-shim implementation, need to rework it
                    internalSplit = function (separator, limit) {
                      var string = String(requireObjectCoercible(this))
                      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0
                      if (lim === 0) return []
                      if (separator === undefined) return [string]
                      // If `separator` is not a regex, use native split
                      if (!isRegExp(separator)) {
                        return nativeSplit.call(string, separator, lim)
                      }
                      var output = []
                      var flags =
                        (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline ? 'm' : '') +
                        (separator.unicode ? 'u' : '') +
                        (separator.sticky ? 'y' : '')
                      var lastLastIndex = 0
                      // Make `global` and avoid `lastIndex` issues by working with a copy
                      var separatorCopy = new RegExp(
                        separator.source,
                        flags + 'g'
                      )
                      var match, lastIndex, lastLength
                      while ((match = regexpExec.call(separatorCopy, string))) {
                        lastIndex = separatorCopy.lastIndex
                        if (lastIndex > lastLastIndex) {
                          output.push(string.slice(lastLastIndex, match.index))
                          if (match.length > 1 && match.index < string.length)
                            arrayPush.apply(output, match.slice(1))
                          lastLength = match[0].length
                          lastLastIndex = lastIndex
                          if (output.length >= lim) break
                        }
                        if (separatorCopy.lastIndex === match.index)
                          separatorCopy.lastIndex++ // Avoid an infinite loop
                      }
                      if (lastLastIndex === string.length) {
                        if (lastLength || !separatorCopy.test(''))
                          output.push('')
                      } else output.push(string.slice(lastLastIndex))
                      return output.length > lim ? output.slice(0, lim) : output
                    }
                    // Chakra, V8
                  } else if ('0'.split(undefined, 0).length) {
                    internalSplit = function (separator, limit) {
                      return separator === undefined && limit === 0
                        ? []
                        : nativeSplit.call(this, separator, limit)
                    }
                  } else internalSplit = nativeSplit

                  return [
                    // `String.prototype.split` method
                    // https://tc39.es/ecma262/#sec-string.prototype.split
                    function split(separator, limit) {
                      var O = requireObjectCoercible(this)
                      var splitter =
                        separator == undefined ? undefined : separator[SPLIT]
                      return splitter !== undefined
                        ? splitter.call(separator, O, limit)
                        : internalSplit.call(String(O), separator, limit)
                    },
                    // `RegExp.prototype[@@split]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
                    //
                    // NOTE: This cannot be properly polyfilled in engines that don't support
                    // the 'y' flag.
                    function (regexp, limit) {
                      var res = maybeCallNative(
                        internalSplit,
                        regexp,
                        this,
                        limit,
                        internalSplit !== nativeSplit
                      )
                      if (res.done) return res.value

                      var rx = anObject(regexp)
                      var S = String(this)
                      var C = speciesConstructor(rx, RegExp)

                      var unicodeMatching = rx.unicode
                      var flags =
                        (rx.ignoreCase ? 'i' : '') +
                        (rx.multiline ? 'm' : '') +
                        (rx.unicode ? 'u' : '') +
                        (SUPPORTS_Y ? 'y' : 'g')

                      // ^(? + rx + ) is needed, in combination with some S slicing, to
                      // simulate the 'y' flag.
                      var splitter = new C(
                        SUPPORTS_Y ? rx : '^(?:' + rx.source + ')',
                        flags
                      )
                      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0
                      if (lim === 0) return []
                      if (S.length === 0)
                        return callRegExpExec(splitter, S) === null ? [S] : []
                      var p = 0
                      var q = 0
                      var A = []
                      while (q < S.length) {
                        splitter.lastIndex = SUPPORTS_Y ? q : 0
                        var z = callRegExpExec(
                          splitter,
                          SUPPORTS_Y ? S : S.slice(q)
                        )
                        var e
                        if (
                          z === null ||
                          (e = min(
                            toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)),
                            S.length
                          )) === p
                        ) {
                          q = advanceStringIndex(S, q, unicodeMatching)
                        } else {
                          A.push(S.slice(p, q))
                          if (A.length === lim) return A
                          for (var i = 1; i <= z.length - 1; i++) {
                            A.push(z[i])
                            if (A.length === lim) return A
                          }
                          q = p = e
                        }
                      }
                      A.push(S.slice(p))
                      return A
                    }
                  ]
                },
                !SUPPORTS_Y
              )

              /***/
            },

            /***/ 3210: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_144619__
            ) {
              'use strict'

              var $ = __nested_webpack_require_144619__(2109)
              var $trim = __nested_webpack_require_144619__(3111).trim
              var forcedStringTrimMethod =
                __nested_webpack_require_144619__(6091)

              // `String.prototype.trim` method
              // https://tc39.es/ecma262/#sec-string.prototype.trim
              $(
                {
                  target: 'String',
                  proto: true,
                  forced: forcedStringTrimMethod('trim')
                },
                {
                  trim: function trim() {
                    return $trim(this)
                  }
                }
              )

              /***/
            },

            /***/ 2990: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_145111__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_145111__(260)
              var $copyWithin = __nested_webpack_require_145111__(1048)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.copyWithin` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
              exportTypedArrayMethod(
                'copyWithin',
                function copyWithin(target, start /* , end */) {
                  return $copyWithin.call(
                    aTypedArray(this),
                    target,
                    start,
                    arguments.length > 2 ? arguments[2] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 8927: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_145777__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_145777__(260)
              var $every = __nested_webpack_require_145777__(2092).every

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.every` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
              exportTypedArrayMethod(
                'every',
                function every(callbackfn /* , thisArg */) {
                  return $every(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 3105: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_146412__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_146412__(260)
              var $fill = __nested_webpack_require_146412__(1285)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.fill` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              exportTypedArrayMethod(
                'fill',
                function fill(value /* , start, end */) {
                  return $fill.apply(aTypedArray(this), arguments)
                }
              )

              /***/
            },

            /***/ 5035: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_147058__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_147058__(260)
              var $filter = __nested_webpack_require_147058__(2092).filter
              var fromSpeciesAndList = __nested_webpack_require_147058__(3074)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.filter` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
              exportTypedArrayMethod(
                'filter',
                function filter(callbackfn /* , thisArg */) {
                  var list = $filter(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                  return fromSpeciesAndList(this, list)
                }
              )

              /***/
            },

            /***/ 7174: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_147797__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_147797__(260)
              var $findIndex = __nested_webpack_require_147797__(2092).findIndex

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.findIndex` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
              exportTypedArrayMethod(
                'findIndex',
                function findIndex(predicate /* , thisArg */) {
                  return $findIndex(
                    aTypedArray(this),
                    predicate,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 4345: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_148458__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_148458__(260)
              var $find = __nested_webpack_require_148458__(2092).find

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.find` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
              exportTypedArrayMethod(
                'find',
                function find(predicate /* , thisArg */) {
                  return $find(
                    aTypedArray(this),
                    predicate,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 2846: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_149084__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_149084__(260)
              var $forEach = __nested_webpack_require_149084__(2092).forEach

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.forEach` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
              exportTypedArrayMethod(
                'forEach',
                function forEach(callbackfn /* , thisArg */) {
                  $forEach(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 4731: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_149726__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_149726__(260)
              var $includes = __nested_webpack_require_149726__(1318).includes

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.includes` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
              exportTypedArrayMethod(
                'includes',
                function includes(searchElement /* , fromIndex */) {
                  return $includes(
                    aTypedArray(this),
                    searchElement,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 7209: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_150390__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_150390__(260)
              var $indexOf = __nested_webpack_require_150390__(1318).indexOf

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.indexOf` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
              exportTypedArrayMethod(
                'indexOf',
                function indexOf(searchElement /* , fromIndex */) {
                  return $indexOf(
                    aTypedArray(this),
                    searchElement,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 6319: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_151047__
            ) {
              'use strict'

              var global = __nested_webpack_require_151047__(7854)
              var ArrayBufferViewCore = __nested_webpack_require_151047__(260)
              var ArrayIterators = __nested_webpack_require_151047__(6992)
              var wellKnownSymbol = __nested_webpack_require_151047__(5112)

              var ITERATOR = wellKnownSymbol('iterator')
              var Uint8Array = global.Uint8Array
              var arrayValues = ArrayIterators.values
              var arrayKeys = ArrayIterators.keys
              var arrayEntries = ArrayIterators.entries
              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var nativeTypedArrayIterator =
                Uint8Array && Uint8Array.prototype[ITERATOR]

              var CORRECT_ITER_NAME =
                !!nativeTypedArrayIterator &&
                (nativeTypedArrayIterator.name == 'values' ||
                  nativeTypedArrayIterator.name == undefined)

              var typedArrayValues = function values() {
                return arrayValues.call(aTypedArray(this))
              }

              // `%TypedArray%.prototype.entries` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
              exportTypedArrayMethod('entries', function entries() {
                return arrayEntries.call(aTypedArray(this))
              })
              // `%TypedArray%.prototype.keys` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
              exportTypedArrayMethod('keys', function keys() {
                return arrayKeys.call(aTypedArray(this))
              })
              // `%TypedArray%.prototype.values` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
              exportTypedArrayMethod(
                'values',
                typedArrayValues,
                !CORRECT_ITER_NAME
              )
              // `%TypedArray%.prototype[@@iterator]` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
              exportTypedArrayMethod(
                ITERATOR,
                typedArrayValues,
                !CORRECT_ITER_NAME
              )

              /***/
            },

            /***/ 8867: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_152782__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_152782__(260)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $join = [].join

              // `%TypedArray%.prototype.join` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              exportTypedArrayMethod('join', function join(separator) {
                return $join.apply(aTypedArray(this), arguments)
              })

              /***/
            },

            /***/ 7789: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_153395__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_153395__(260)
              var $lastIndexOf = __nested_webpack_require_153395__(6583)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.lastIndexOf` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
              // eslint-disable-next-line no-unused-vars -- required for `.length`
              exportTypedArrayMethod(
                'lastIndexOf',
                function lastIndexOf(searchElement /* , fromIndex */) {
                  return $lastIndexOf.apply(aTypedArray(this), arguments)
                }
              )

              /***/
            },

            /***/ 3739: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_154090__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_154090__(260)
              var $map = __nested_webpack_require_154090__(2092).map
              var speciesConstructor = __nested_webpack_require_154090__(6707)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var aTypedArrayConstructor =
                ArrayBufferViewCore.aTypedArrayConstructor
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.map` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
              exportTypedArrayMethod(
                'map',
                function map(mapfn /* , thisArg */) {
                  return $map(
                    aTypedArray(this),
                    mapfn,
                    arguments.length > 1 ? arguments[1] : undefined,
                    function (O, length) {
                      return new (aTypedArrayConstructor(
                        speciesConstructor(O, O.constructor)
                      ))(length)
                    }
                  )
                }
              )

              /***/
            },

            /***/ 4483: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_154941__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_154941__(260)
              var $reduceRight = __nested_webpack_require_154941__(3671).right

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.reduceRicht` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
              exportTypedArrayMethod(
                'reduceRight',
                function reduceRight(callbackfn /* , initialValue */) {
                  return $reduceRight(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 9368: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_155635__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_155635__(260)
              var $reduce = __nested_webpack_require_155635__(3671).left

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.reduce` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
              exportTypedArrayMethod(
                'reduce',
                function reduce(callbackfn /* , initialValue */) {
                  return $reduce(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 2056: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_156298__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_156298__(260)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var floor = Math.floor

              // `%TypedArray%.prototype.reverse` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
              exportTypedArrayMethod('reverse', function reverse() {
                var that = this
                var length = aTypedArray(that).length
                var middle = floor(length / 2)
                var index = 0
                var value
                while (index < middle) {
                  value = that[index]
                  that[index++] = that[--length]
                  that[length] = value
                }
                return that
              })

              /***/
            },

            /***/ 3462: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_157051__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_157051__(260)
              var toLength = __nested_webpack_require_157051__(7466)
              var toOffset = __nested_webpack_require_157051__(4590)
              var toObject = __nested_webpack_require_157051__(7908)
              var fails = __nested_webpack_require_157051__(7293)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              var FORCED = fails(function () {
                /* global Int8Array -- safe */
                new Int8Array(1).set({})
              })

              // `%TypedArray%.prototype.set` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
              exportTypedArrayMethod(
                'set',
                function set(arrayLike /* , offset */) {
                  aTypedArray(this)
                  var offset = toOffset(
                    arguments.length > 1 ? arguments[1] : undefined,
                    1
                  )
                  var length = this.length
                  var src = toObject(arrayLike)
                  var len = toLength(src.length)
                  var index = 0
                  if (len + offset > length) throw RangeError('Wrong length')
                  while (index < len) this[offset + index] = src[index++]
                },
                FORCED
              )

              /***/
            },

            /***/ 678: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_158136__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_158136__(260)
              var speciesConstructor = __nested_webpack_require_158136__(6707)
              var fails = __nested_webpack_require_158136__(7293)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var aTypedArrayConstructor =
                ArrayBufferViewCore.aTypedArrayConstructor
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $slice = [].slice

              var FORCED = fails(function () {
                /* global Int8Array -- safe */
                new Int8Array(1).slice()
              })

              // `%TypedArray%.prototype.slice` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
              exportTypedArrayMethod(
                'slice',
                function slice(start, end) {
                  var list = $slice.call(aTypedArray(this), start, end)
                  var C = speciesConstructor(this, this.constructor)
                  var index = 0
                  var length = list.length
                  var result = new (aTypedArrayConstructor(C))(length)
                  while (length > index) result[index] = list[index++]
                  return result
                },
                FORCED
              )

              /***/
            },

            /***/ 7462: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_159191__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_159191__(260)
              var $some = __nested_webpack_require_159191__(2092).some

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.some` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
              exportTypedArrayMethod(
                'some',
                function some(callbackfn /* , thisArg */) {
                  return $some(
                    aTypedArray(this),
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined
                  )
                }
              )

              /***/
            },

            /***/ 3824: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_159819__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_159819__(260)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $sort = [].sort

              // `%TypedArray%.prototype.sort` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
              exportTypedArrayMethod('sort', function sort(comparefn) {
                return $sort.call(aTypedArray(this), comparefn)
              })

              /***/
            },

            /***/ 5021: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_160362__
            ) {
              'use strict'

              var ArrayBufferViewCore = __nested_webpack_require_160362__(260)
              var toLength = __nested_webpack_require_160362__(7466)
              var toAbsoluteIndex = __nested_webpack_require_160362__(1400)
              var speciesConstructor = __nested_webpack_require_160362__(6707)

              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod

              // `%TypedArray%.prototype.subarray` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
              exportTypedArrayMethod('subarray', function subarray(begin, end) {
                var O = aTypedArray(this)
                var length = O.length
                var beginIndex = toAbsoluteIndex(begin, length)
                return new (speciesConstructor(O, O.constructor))(
                  O.buffer,
                  O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
                  toLength(
                    (end === undefined
                      ? length
                      : toAbsoluteIndex(end, length)) - beginIndex
                  )
                )
              })

              /***/
            },

            /***/ 2974: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_161310__
            ) {
              'use strict'

              var global = __nested_webpack_require_161310__(7854)
              var ArrayBufferViewCore = __nested_webpack_require_161310__(260)
              var fails = __nested_webpack_require_161310__(7293)

              var Int8Array = global.Int8Array
              var aTypedArray = ArrayBufferViewCore.aTypedArray
              var exportTypedArrayMethod =
                ArrayBufferViewCore.exportTypedArrayMethod
              var $toLocaleString = [].toLocaleString
              var $slice = [].slice

              // iOS Safari 6.x fails here
              var TO_LOCALE_STRING_BUG =
                !!Int8Array &&
                fails(function () {
                  $toLocaleString.call(new Int8Array(1))
                })

              var FORCED =
                fails(function () {
                  return (
                    [1, 2].toLocaleString() !=
                    new Int8Array([1, 2]).toLocaleString()
                  )
                }) ||
                !fails(function () {
                  Int8Array.prototype.toLocaleString.call([1, 2])
                })

              // `%TypedArray%.prototype.toLocaleString` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
              exportTypedArrayMethod(
                'toLocaleString',
                function toLocaleString() {
                  return $toLocaleString.apply(
                    TO_LOCALE_STRING_BUG
                      ? $slice.call(aTypedArray(this))
                      : aTypedArray(this),
                    arguments
                  )
                },
                FORCED
              )

              /***/
            },

            /***/ 5016: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_162445__
            ) {
              'use strict'

              var exportTypedArrayMethod =
                __nested_webpack_require_162445__(260).exportTypedArrayMethod
              var fails = __nested_webpack_require_162445__(7293)
              var global = __nested_webpack_require_162445__(7854)

              var Uint8Array = global.Uint8Array
              var Uint8ArrayPrototype =
                (Uint8Array && Uint8Array.prototype) || {}
              var arrayToString = [].toString
              var arrayJoin = [].join

              if (
                fails(function () {
                  arrayToString.call({})
                })
              ) {
                arrayToString = function toString() {
                  return arrayJoin.call(this)
                }
              }

              var IS_NOT_ARRAY_METHOD =
                Uint8ArrayPrototype.toString != arrayToString

              // `%TypedArray%.prototype.toString` method
              // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
              exportTypedArrayMethod(
                'toString',
                arrayToString,
                IS_NOT_ARRAY_METHOD
              )

              /***/
            },

            /***/ 2472: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_163286__
            ) {
              var createTypedArrayConstructor =
                __nested_webpack_require_163286__(9843)

              // `Uint8Array` constructor
              // https://tc39.es/ecma262/#sec-typedarray-objects
              createTypedArrayConstructor('Uint8', function (init) {
                return function Uint8Array(data, byteOffset, length) {
                  return init(this, data, byteOffset, length)
                }
              })

              /***/
            },

            /***/ 4747: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_163713__
            ) {
              var global = __nested_webpack_require_163713__(7854)
              var DOMIterables = __nested_webpack_require_163713__(8324)
              var forEach = __nested_webpack_require_163713__(8533)
              var createNonEnumerableProperty =
                __nested_webpack_require_163713__(8880)

              for (var COLLECTION_NAME in DOMIterables) {
                var Collection = global[COLLECTION_NAME]
                var CollectionPrototype = Collection && Collection.prototype
                // some Chrome versions have non-configurable methods on DOMTokenList
                if (
                  CollectionPrototype &&
                  CollectionPrototype.forEach !== forEach
                )
                  try {
                    createNonEnumerableProperty(
                      CollectionPrototype,
                      'forEach',
                      forEach
                    )
                  } catch (error) {
                    CollectionPrototype.forEach = forEach
                  }
              }

              /***/
            },

            /***/ 3948: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_164461__
            ) {
              var global = __nested_webpack_require_164461__(7854)
              var DOMIterables = __nested_webpack_require_164461__(8324)
              var ArrayIteratorMethods = __nested_webpack_require_164461__(6992)
              var createNonEnumerableProperty =
                __nested_webpack_require_164461__(8880)
              var wellKnownSymbol = __nested_webpack_require_164461__(5112)

              var ITERATOR = wellKnownSymbol('iterator')
              var TO_STRING_TAG = wellKnownSymbol('toStringTag')
              var ArrayValues = ArrayIteratorMethods.values

              for (var COLLECTION_NAME in DOMIterables) {
                var Collection = global[COLLECTION_NAME]
                var CollectionPrototype = Collection && Collection.prototype
                if (CollectionPrototype) {
                  // some Chrome versions have non-configurable methods on DOMTokenList
                  if (CollectionPrototype[ITERATOR] !== ArrayValues)
                    try {
                      createNonEnumerableProperty(
                        CollectionPrototype,
                        ITERATOR,
                        ArrayValues
                      )
                    } catch (error) {
                      CollectionPrototype[ITERATOR] = ArrayValues
                    }
                  if (!CollectionPrototype[TO_STRING_TAG]) {
                    createNonEnumerableProperty(
                      CollectionPrototype,
                      TO_STRING_TAG,
                      COLLECTION_NAME
                    )
                  }
                  if (DOMIterables[COLLECTION_NAME])
                    for (var METHOD_NAME in ArrayIteratorMethods) {
                      // some Chrome versions have non-configurable methods on DOMTokenList
                      if (
                        CollectionPrototype[METHOD_NAME] !==
                        ArrayIteratorMethods[METHOD_NAME]
                      )
                        try {
                          createNonEnumerableProperty(
                            CollectionPrototype,
                            METHOD_NAME,
                            ArrayIteratorMethods[METHOD_NAME]
                          )
                        } catch (error) {
                          CollectionPrototype[METHOD_NAME] =
                            ArrayIteratorMethods[METHOD_NAME]
                        }
                    }
                }
              }

              /***/
            },

            /***/ 1637: /***/ function (
              module,
              __unused_webpack_exports,
              __nested_webpack_require_166049__
            ) {
              'use strict'

              // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
              __nested_webpack_require_166049__(6992)
              var $ = __nested_webpack_require_166049__(2109)
              var getBuiltIn = __nested_webpack_require_166049__(5005)
              var USE_NATIVE_URL = __nested_webpack_require_166049__(590)
              var redefine = __nested_webpack_require_166049__(1320)
              var redefineAll = __nested_webpack_require_166049__(2248)
              var setToStringTag = __nested_webpack_require_166049__(8003)
              var createIteratorConstructor =
                __nested_webpack_require_166049__(4994)
              var InternalStateModule = __nested_webpack_require_166049__(9909)
              var anInstance = __nested_webpack_require_166049__(5787)
              var hasOwn = __nested_webpack_require_166049__(6656)
              var bind = __nested_webpack_require_166049__(9974)
              var classof = __nested_webpack_require_166049__(648)
              var anObject = __nested_webpack_require_166049__(9670)
              var isObject = __nested_webpack_require_166049__(111)
              var create = __nested_webpack_require_166049__(30)
              var createPropertyDescriptor =
                __nested_webpack_require_166049__(9114)
              var getIterator = __nested_webpack_require_166049__(8554)
              var getIteratorMethod = __nested_webpack_require_166049__(1246)
              var wellKnownSymbol = __nested_webpack_require_166049__(5112)

              var $fetch = getBuiltIn('fetch')
              var Headers = getBuiltIn('Headers')
              var ITERATOR = wellKnownSymbol('iterator')
              var URL_SEARCH_PARAMS = 'URLSearchParams'
              var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator'
              var setInternalState = InternalStateModule.set
              var getInternalParamsState =
                InternalStateModule.getterFor(URL_SEARCH_PARAMS)
              var getInternalIteratorState = InternalStateModule.getterFor(
                URL_SEARCH_PARAMS_ITERATOR
              )

              var plus = /\+/g
              var sequences = Array(4)

              var percentSequence = function (bytes) {
                return (
                  sequences[bytes - 1] ||
                  (sequences[bytes - 1] = RegExp(
                    '((?:%[\\da-f]{2}){' + bytes + '})',
                    'gi'
                  ))
                )
              }

              var percentDecode = function (sequence) {
                try {
                  return decodeURIComponent(sequence)
                } catch (error) {
                  return sequence
                }
              }

              var deserialize = function (it) {
                var result = it.replace(plus, ' ')
                var bytes = 4
                try {
                  return decodeURIComponent(result)
                } catch (error) {
                  while (bytes) {
                    result = result.replace(
                      percentSequence(bytes--),
                      percentDecode
                    )
                  }
                  return result
                }
              }

              var find = /[!'()~]|%20/g

              var replace = {
                '!': '%21',
                "'": '%27',
                '(': '%28',
                ')': '%29',
                '~': '%7E',
                '%20': '+'
              }

              var replacer = function (match) {
                return replace[match]
              }

              var serialize = function (it) {
                return encodeURIComponent(it).replace(find, replacer)
              }

              var parseSearchParams = function (result, query) {
                if (query) {
                  var attributes = query.split('&')
                  var index = 0
                  var attribute, entry
                  while (index < attributes.length) {
                    attribute = attributes[index++]
                    if (attribute.length) {
                      entry = attribute.split('=')
                      result.push({
                        key: deserialize(entry.shift()),
                        value: deserialize(entry.join('='))
                      })
                    }
                  }
                }
              }

              var updateSearchParams = function (query) {
                this.entries.length = 0
                parseSearchParams(this.entries, query)
              }

              var validateArgumentsLength = function (passed, required) {
                if (passed < required) throw TypeError('Not enough arguments')
              }

              var URLSearchParamsIterator = createIteratorConstructor(
                function Iterator(params, kind) {
                  setInternalState(this, {
                    type: URL_SEARCH_PARAMS_ITERATOR,
                    iterator: getIterator(
                      getInternalParamsState(params).entries
                    ),
                    kind: kind
                  })
                },
                'Iterator',
                function next() {
                  var state = getInternalIteratorState(this)
                  var kind = state.kind
                  var step = state.iterator.next()
                  var entry = step.value
                  if (!step.done) {
                    step.value =
                      kind === 'keys'
                        ? entry.key
                        : kind === 'values'
                          ? entry.value
                          : [entry.key, entry.value]
                  }
                  return step
                }
              )

              // `URLSearchParams` constructor
              // https://url.spec.whatwg.org/#interface-urlsearchparams
              var URLSearchParamsConstructor =
                function URLSearchParams(/* init */) {
                  anInstance(
                    this,
                    URLSearchParamsConstructor,
                    URL_SEARCH_PARAMS
                  )
                  var init = arguments.length > 0 ? arguments[0] : undefined
                  var that = this
                  var entries = []
                  var iteratorMethod,
                    iterator,
                    next,
                    step,
                    entryIterator,
                    entryNext,
                    first,
                    second,
                    key

                  setInternalState(that, {
                    type: URL_SEARCH_PARAMS,
                    entries: entries,
                    updateURL: function () {
                      /* empty */
                    },
                    updateSearchParams: updateSearchParams
                  })

                  if (init !== undefined) {
                    if (isObject(init)) {
                      iteratorMethod = getIteratorMethod(init)
                      if (typeof iteratorMethod === 'function') {
                        iterator = iteratorMethod.call(init)
                        next = iterator.next
                        while (!(step = next.call(iterator)).done) {
                          entryIterator = getIterator(anObject(step.value))
                          entryNext = entryIterator.next
                          if (
                            (first = entryNext.call(entryIterator)).done ||
                            (second = entryNext.call(entryIterator)).done ||
                            !entryNext.call(entryIterator).done
                          )
                            throw TypeError('Expected sequence with length 2')
                          entries.push({
                            key: first.value + '',
                            value: second.value + ''
                          })
                        }
                      } else
                        for (key in init)
                          if (hasOwn(init, key))
                            entries.push({ key: key, value: init[key] + '' })
                    } else {
                      parseSearchParams(
                        entries,
                        typeof init === 'string'
                          ? init.charAt(0) === '?'
                            ? init.slice(1)
                            : init
                          : init + ''
                      )
                    }
                  }
                }

              var URLSearchParamsPrototype =
                URLSearchParamsConstructor.prototype

              redefineAll(
                URLSearchParamsPrototype,
                {
                  // `URLSearchParams.prototype.append` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
                  append: function append(name, value) {
                    validateArgumentsLength(arguments.length, 2)
                    var state = getInternalParamsState(this)
                    state.entries.push({ key: name + '', value: value + '' })
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.delete` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
                  delete: function (name) {
                    validateArgumentsLength(arguments.length, 1)
                    var state = getInternalParamsState(this)
                    var entries = state.entries
                    var key = name + ''
                    var index = 0
                    while (index < entries.length) {
                      if (entries[index].key === key) entries.splice(index, 1)
                      else index++
                    }
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.get` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
                  get: function get(name) {
                    validateArgumentsLength(arguments.length, 1)
                    var entries = getInternalParamsState(this).entries
                    var key = name + ''
                    var index = 0
                    for (; index < entries.length; index++) {
                      if (entries[index].key === key)
                        return entries[index].value
                    }
                    return null
                  },
                  // `URLSearchParams.prototype.getAll` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
                  getAll: function getAll(name) {
                    validateArgumentsLength(arguments.length, 1)
                    var entries = getInternalParamsState(this).entries
                    var key = name + ''
                    var result = []
                    var index = 0
                    for (; index < entries.length; index++) {
                      if (entries[index].key === key)
                        result.push(entries[index].value)
                    }
                    return result
                  },
                  // `URLSearchParams.prototype.has` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
                  has: function has(name) {
                    validateArgumentsLength(arguments.length, 1)
                    var entries = getInternalParamsState(this).entries
                    var key = name + ''
                    var index = 0
                    while (index < entries.length) {
                      if (entries[index++].key === key) return true
                    }
                    return false
                  },
                  // `URLSearchParams.prototype.set` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
                  set: function set(name, value) {
                    validateArgumentsLength(arguments.length, 1)
                    var state = getInternalParamsState(this)
                    var entries = state.entries
                    var found = false
                    var key = name + ''
                    var val = value + ''
                    var index = 0
                    var entry
                    for (; index < entries.length; index++) {
                      entry = entries[index]
                      if (entry.key === key) {
                        if (found) entries.splice(index--, 1)
                        else {
                          found = true
                          entry.value = val
                        }
                      }
                    }
                    if (!found) entries.push({ key: key, value: val })
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.sort` method
                  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
                  sort: function sort() {
                    var state = getInternalParamsState(this)
                    var entries = state.entries
                    // Array#sort is not stable in some engines
                    var slice = entries.slice()
                    var entry, entriesIndex, sliceIndex
                    entries.length = 0
                    for (
                      sliceIndex = 0;
                      sliceIndex < slice.length;
                      sliceIndex++
                    ) {
                      entry = slice[sliceIndex]
                      for (
                        entriesIndex = 0;
                        entriesIndex < sliceIndex;
                        entriesIndex++
                      ) {
                        if (entries[entriesIndex].key > entry.key) {
                          entries.splice(entriesIndex, 0, entry)
                          break
                        }
                      }
                      if (entriesIndex === sliceIndex) entries.push(entry)
                    }
                    state.updateURL()
                  },
                  // `URLSearchParams.prototype.forEach` method
                  forEach: function forEach(callback /* , thisArg */) {
                    var entries = getInternalParamsState(this).entries
                    var boundFunction = bind(
                      callback,
                      arguments.length > 1 ? arguments[1] : undefined,
                      3
                    )
                    var index = 0
                    var entry
                    while (index < entries.length) {
                      entry = entries[index++]
                      boundFunction(entry.value, entry.key, this)
                    }
                  },
                  // `URLSearchParams.prototype.keys` method
                  keys: function keys() {
                    return new URLSearchParamsIterator(this, 'keys')
                  },
                  // `URLSearchParams.prototype.values` method
                  values: function values() {
                    return new URLSearchParamsIterator(this, 'values')
                  },
                  // `URLSearchParams.prototype.entries` method
                  entries: function entries() {
                    return new URLSearchParamsIterator(this, 'entries')
                  }
                },
                { enumerable: true }
              )

              // `URLSearchParams.prototype[@@iterator]` method
              redefine(
                URLSearchParamsPrototype,
                ITERATOR,
                URLSearchParamsPrototype.entries
              )

              // `URLSearchParams.prototype.toString` method
              // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
              redefine(
                URLSearchParamsPrototype,
                'toString',
                function toString() {
                  var entries = getInternalParamsState(this).entries
                  var result = []
                  var index = 0
                  var entry
                  while (index < entries.length) {
                    entry = entries[index++]
                    result.push(
                      serialize(entry.key) + '=' + serialize(entry.value)
                    )
                  }
                  return result.join('&')
                },
                { enumerable: true }
              )

              setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS)

              $(
                { global: true, forced: !USE_NATIVE_URL },
                {
                  URLSearchParams: URLSearchParamsConstructor
                }
              )

              // Wrap `fetch` for correct work with polyfilled `URLSearchParams`
              // https://github.com/zloirock/core-js/issues/674
              if (
                !USE_NATIVE_URL &&
                typeof $fetch == 'function' &&
                typeof Headers == 'function'
              ) {
                $(
                  { global: true, enumerable: true, forced: true },
                  {
                    fetch: function fetch(input /* , init */) {
                      var args = [input]
                      var init, body, headers
                      if (arguments.length > 1) {
                        init = arguments[1]
                        if (isObject(init)) {
                          body = init.body
                          if (classof(body) === URL_SEARCH_PARAMS) {
                            headers = init.headers
                              ? new Headers(init.headers)
                              : new Headers()
                            if (!headers.has('content-type')) {
                              headers.set(
                                'content-type',
                                'application/x-www-form-urlencoded;charset=UTF-8'
                              )
                            }
                            init = create(init, {
                              body: createPropertyDescriptor(0, String(body)),
                              headers: createPropertyDescriptor(0, headers)
                            })
                          }
                        }
                        args.push(init)
                      }
                      return $fetch.apply(this, args)
                    }
                  }
                )
              }

              module.exports = {
                URLSearchParams: URLSearchParamsConstructor,
                getState: getInternalParamsState
              }

              /***/
            },

            /***/ 285: /***/ function (
              __unused_webpack_module,
              __unused_webpack_exports,
              __nested_webpack_require_177789__
            ) {
              'use strict'

              // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
              __nested_webpack_require_177789__(8783)
              var $ = __nested_webpack_require_177789__(2109)
              var DESCRIPTORS = __nested_webpack_require_177789__(9781)
              var USE_NATIVE_URL = __nested_webpack_require_177789__(590)
              var global = __nested_webpack_require_177789__(7854)
              var defineProperties = __nested_webpack_require_177789__(6048)
              var redefine = __nested_webpack_require_177789__(1320)
              var anInstance = __nested_webpack_require_177789__(5787)
              var has = __nested_webpack_require_177789__(6656)
              var assign = __nested_webpack_require_177789__(1574)
              var arrayFrom = __nested_webpack_require_177789__(8457)
              var codeAt = __nested_webpack_require_177789__(8710).codeAt
              var toASCII = __nested_webpack_require_177789__(3197)
              var setToStringTag = __nested_webpack_require_177789__(8003)
              var URLSearchParamsModule =
                __nested_webpack_require_177789__(1637)
              var InternalStateModule = __nested_webpack_require_177789__(9909)

              var NativeURL = global.URL
              var URLSearchParams = URLSearchParamsModule.URLSearchParams
              var getInternalSearchParamsState = URLSearchParamsModule.getState
              var setInternalState = InternalStateModule.set
              var getInternalURLState = InternalStateModule.getterFor('URL')
              var floor = Math.floor
              var pow = Math.pow

              var INVALID_AUTHORITY = 'Invalid authority'
              var INVALID_SCHEME = 'Invalid scheme'
              var INVALID_HOST = 'Invalid host'
              var INVALID_PORT = 'Invalid port'

              var ALPHA = /[A-Za-z]/
              var ALPHANUMERIC = /[\d+-.A-Za-z]/
              var DIGIT = /\d/
              var HEX_START = /^(0x|0X)/
              var OCT = /^[0-7]+$/
              var DEC = /^\d+$/
              var HEX = /^[\dA-Fa-f]+$/
              /* eslint-disable no-control-regex -- safe */
              var FORBIDDEN_HOST_CODE_POINT =
                /[\u0000\t\u000A\u000D #%/:?@[\\]]/
              var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT =
                /[\u0000\t\u000A\u000D #/:?@[\\]]/
              var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE =
                /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g
              var TAB_AND_NEW_LINE = /[\t\u000A\u000D]/g
              /* eslint-enable no-control-regex -- safe */
              var EOF

              var parseHost = function (url, input) {
                var result, codePoints, index
                if (input.charAt(0) == '[') {
                  if (input.charAt(input.length - 1) != ']') return INVALID_HOST
                  result = parseIPv6(input.slice(1, -1))
                  if (!result) return INVALID_HOST
                  url.host = result
                  // opaque host
                } else if (!isSpecial(url)) {
                  if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))
                    return INVALID_HOST
                  result = ''
                  codePoints = arrayFrom(input)
                  for (index = 0; index < codePoints.length; index++) {
                    result += percentEncode(
                      codePoints[index],
                      C0ControlPercentEncodeSet
                    )
                  }
                  url.host = result
                } else {
                  input = toASCII(input)
                  if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST
                  result = parseIPv4(input)
                  if (result === null) return INVALID_HOST
                  url.host = result
                }
              }

              var parseIPv4 = function (input) {
                var parts = input.split('.')
                var partsLength, numbers, index, part, radix, number, ipv4
                if (parts.length && parts[parts.length - 1] == '') {
                  parts.pop()
                }
                partsLength = parts.length
                if (partsLength > 4) return input
                numbers = []
                for (index = 0; index < partsLength; index++) {
                  part = parts[index]
                  if (part == '') return input
                  radix = 10
                  if (part.length > 1 && part.charAt(0) == '0') {
                    radix = HEX_START.test(part) ? 16 : 8
                    part = part.slice(radix == 8 ? 1 : 2)
                  }
                  if (part === '') {
                    number = 0
                  } else {
                    if (
                      !(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)
                    )
                      return input
                    number = parseInt(part, radix)
                  }
                  numbers.push(number)
                }
                for (index = 0; index < partsLength; index++) {
                  number = numbers[index]
                  if (index == partsLength - 1) {
                    if (number >= pow(256, 5 - partsLength)) return null
                  } else if (number > 255) return null
                }
                ipv4 = numbers.pop()
                for (index = 0; index < numbers.length; index++) {
                  ipv4 += numbers[index] * pow(256, 3 - index)
                }
                return ipv4
              }

              // eslint-disable-next-line max-statements -- TODO
              var parseIPv6 = function (input) {
                var address = [0, 0, 0, 0, 0, 0, 0, 0]
                var pieceIndex = 0
                var compress = null
                var pointer = 0
                var value, length, numbersSeen, ipv4Piece, number, swaps, swap

                var char = function () {
                  return input.charAt(pointer)
                }

                if (char() == ':') {
                  if (input.charAt(1) != ':') return
                  pointer += 2
                  pieceIndex++
                  compress = pieceIndex
                }
                while (char()) {
                  if (pieceIndex == 8) return
                  if (char() == ':') {
                    if (compress !== null) return
                    pointer++
                    pieceIndex++
                    compress = pieceIndex
                    continue
                  }
                  value = length = 0
                  while (length < 4 && HEX.test(char())) {
                    value = value * 16 + parseInt(char(), 16)
                    pointer++
                    length++
                  }
                  if (char() == '.') {
                    if (length == 0) return
                    pointer -= length
                    if (pieceIndex > 6) return
                    numbersSeen = 0
                    while (char()) {
                      ipv4Piece = null
                      if (numbersSeen > 0) {
                        if (char() == '.' && numbersSeen < 4) pointer++
                        else return
                      }
                      if (!DIGIT.test(char())) return
                      while (DIGIT.test(char())) {
                        number = parseInt(char(), 10)
                        if (ipv4Piece === null) ipv4Piece = number
                        else if (ipv4Piece == 0) return
                        else ipv4Piece = ipv4Piece * 10 + number
                        if (ipv4Piece > 255) return
                        pointer++
                      }
                      address[pieceIndex] =
                        address[pieceIndex] * 256 + ipv4Piece
                      numbersSeen++
                      if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++
                    }
                    if (numbersSeen != 4) return
                    break
                  } else if (char() == ':') {
                    pointer++
                    if (!char()) return
                  } else if (char()) return
                  address[pieceIndex++] = value
                }
                if (compress !== null) {
                  swaps = pieceIndex - compress
                  pieceIndex = 7
                  while (pieceIndex != 0 && swaps > 0) {
                    swap = address[pieceIndex]
                    address[pieceIndex--] = address[compress + swaps - 1]
                    address[compress + --swaps] = swap
                  }
                } else if (pieceIndex != 8) return
                return address
              }

              var findLongestZeroSequence = function (ipv6) {
                var maxIndex = null
                var maxLength = 1
                var currStart = null
                var currLength = 0
                var index = 0
                for (; index < 8; index++) {
                  if (ipv6[index] !== 0) {
                    if (currLength > maxLength) {
                      maxIndex = currStart
                      maxLength = currLength
                    }
                    currStart = null
                    currLength = 0
                  } else {
                    if (currStart === null) currStart = index
                    ++currLength
                  }
                }
                if (currLength > maxLength) {
                  maxIndex = currStart
                  maxLength = currLength
                }
                return maxIndex
              }

              var serializeHost = function (host) {
                var result, index, compress, ignore0
                // ipv4
                if (typeof host == 'number') {
                  result = []
                  for (index = 0; index < 4; index++) {
                    result.unshift(host % 256)
                    host = floor(host / 256)
                  }
                  return result.join('.')
                  // ipv6
                } else if (typeof host == 'object') {
                  result = ''
                  compress = findLongestZeroSequence(host)
                  for (index = 0; index < 8; index++) {
                    if (ignore0 && host[index] === 0) continue
                    if (ignore0) ignore0 = false
                    if (compress === index) {
                      result += index ? ':' : '::'
                      ignore0 = true
                    } else {
                      result += host[index].toString(16)
                      if (index < 7) result += ':'
                    }
                  }
                  return '[' + result + ']'
                }
                return host
              }

              var C0ControlPercentEncodeSet = {}
              var fragmentPercentEncodeSet = assign(
                {},
                C0ControlPercentEncodeSet,
                {
                  ' ': 1,
                  '"': 1,
                  '<': 1,
                  '>': 1,
                  '`': 1
                }
              )
              var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
                '#': 1,
                '?': 1,
                '{': 1,
                '}': 1
              })
              var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
                '/': 1,
                ':': 1,
                ';': 1,
                '=': 1,
                '@': 1,
                '[': 1,
                '\\': 1,
                ']': 1,
                '^': 1,
                '|': 1
              })

              var percentEncode = function (char, set) {
                var code = codeAt(char, 0)
                return code > 0x20 && code < 0x7f && !has(set, char)
                  ? char
                  : encodeURIComponent(char)
              }

              var specialSchemes = {
                ftp: 21,
                file: null,
                http: 80,
                https: 443,
                ws: 80,
                wss: 443
              }

              var isSpecial = function (url) {
                return has(specialSchemes, url.scheme)
              }

              var includesCredentials = function (url) {
                return url.username != '' || url.password != ''
              }

              var cannotHaveUsernamePasswordPort = function (url) {
                return !url.host || url.cannotBeABaseURL || url.scheme == 'file'
              }

              var isWindowsDriveLetter = function (string, normalized) {
                var second
                return (
                  string.length == 2 &&
                  ALPHA.test(string.charAt(0)) &&
                  ((second = string.charAt(1)) == ':' ||
                    (!normalized && second == '|'))
                )
              }

              var startsWithWindowsDriveLetter = function (string) {
                var third
                return (
                  string.length > 1 &&
                  isWindowsDriveLetter(string.slice(0, 2)) &&
                  (string.length == 2 ||
                    (third = string.charAt(2)) === '/' ||
                    third === '\\' ||
                    third === '?' ||
                    third === '#')
                )
              }

              var shortenURLsPath = function (url) {
                var path = url.path
                var pathSize = path.length
                if (
                  pathSize &&
                  (url.scheme != 'file' ||
                    pathSize != 1 ||
                    !isWindowsDriveLetter(path[0], true))
                ) {
                  path.pop()
                }
              }

              var isSingleDot = function (segment) {
                return segment === '.' || segment.toLowerCase() === '%2e'
              }

              var isDoubleDot = function (segment) {
                segment = segment.toLowerCase()
                return (
                  segment === '..' ||
                  segment === '%2e.' ||
                  segment === '.%2e' ||
                  segment === '%2e%2e'
                )
              }

              // States:
              var SCHEME_START = {}
              var SCHEME = {}
              var NO_SCHEME = {}
              var SPECIAL_RELATIVE_OR_AUTHORITY = {}
              var PATH_OR_AUTHORITY = {}
              var RELATIVE = {}
              var RELATIVE_SLASH = {}
              var SPECIAL_AUTHORITY_SLASHES = {}
              var SPECIAL_AUTHORITY_IGNORE_SLASHES = {}
              var AUTHORITY = {}
              var HOST = {}
              var HOSTNAME = {}
              var PORT = {}
              var FILE = {}
              var FILE_SLASH = {}
              var FILE_HOST = {}
              var PATH_START = {}
              var PATH = {}
              var CANNOT_BE_A_BASE_URL_PATH = {}
              var QUERY = {}
              var FRAGMENT = {}

              // eslint-disable-next-line max-statements -- TODO
              var parseURL = function (url, input, stateOverride, base) {
                var state = stateOverride || SCHEME_START
                var pointer = 0
                var buffer = ''
                var seenAt = false
                var seenBracket = false
                var seenPasswordToken = false
                var codePoints, char, bufferCodePoints, failure

                if (!stateOverride) {
                  url.scheme = ''
                  url.username = ''
                  url.password = ''
                  url.host = null
                  url.port = null
                  url.path = []
                  url.query = null
                  url.fragment = null
                  url.cannotBeABaseURL = false
                  input = input.replace(
                    LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE,
                    ''
                  )
                }

                input = input.replace(TAB_AND_NEW_LINE, '')

                codePoints = arrayFrom(input)

                while (pointer <= codePoints.length) {
                  char = codePoints[pointer]
                  switch (state) {
                    case SCHEME_START:
                      if (char && ALPHA.test(char)) {
                        buffer += char.toLowerCase()
                        state = SCHEME
                      } else if (!stateOverride) {
                        state = NO_SCHEME
                        continue
                      } else return INVALID_SCHEME
                      break

                    case SCHEME:
                      if (
                        char &&
                        (ALPHANUMERIC.test(char) ||
                          char == '+' ||
                          char == '-' ||
                          char == '.')
                      ) {
                        buffer += char.toLowerCase()
                      } else if (char == ':') {
                        if (
                          stateOverride &&
                          (isSpecial(url) != has(specialSchemes, buffer) ||
                            (buffer == 'file' &&
                              (includesCredentials(url) ||
                                url.port !== null)) ||
                            (url.scheme == 'file' && !url.host))
                        )
                          return
                        url.scheme = buffer
                        if (stateOverride) {
                          if (
                            isSpecial(url) &&
                            specialSchemes[url.scheme] == url.port
                          )
                            url.port = null
                          return
                        }
                        buffer = ''
                        if (url.scheme == 'file') {
                          state = FILE
                        } else if (
                          isSpecial(url) &&
                          base &&
                          base.scheme == url.scheme
                        ) {
                          state = SPECIAL_RELATIVE_OR_AUTHORITY
                        } else if (isSpecial(url)) {
                          state = SPECIAL_AUTHORITY_SLASHES
                        } else if (codePoints[pointer + 1] == '/') {
                          state = PATH_OR_AUTHORITY
                          pointer++
                        } else {
                          url.cannotBeABaseURL = true
                          url.path.push('')
                          state = CANNOT_BE_A_BASE_URL_PATH
                        }
                      } else if (!stateOverride) {
                        buffer = ''
                        state = NO_SCHEME
                        pointer = 0
                        continue
                      } else return INVALID_SCHEME
                      break

                    case NO_SCHEME:
                      if (!base || (base.cannotBeABaseURL && char != '#'))
                        return INVALID_SCHEME
                      if (base.cannotBeABaseURL && char == '#') {
                        url.scheme = base.scheme
                        url.path = base.path.slice()
                        url.query = base.query
                        url.fragment = ''
                        url.cannotBeABaseURL = true
                        state = FRAGMENT
                        break
                      }
                      state = base.scheme == 'file' ? FILE : RELATIVE
                      continue

                    case SPECIAL_RELATIVE_OR_AUTHORITY:
                      if (char == '/' && codePoints[pointer + 1] == '/') {
                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES
                        pointer++
                      } else {
                        state = RELATIVE
                        continue
                      }
                      break

                    case PATH_OR_AUTHORITY:
                      if (char == '/') {
                        state = AUTHORITY
                        break
                      } else {
                        state = PATH
                        continue
                      }

                    case RELATIVE:
                      url.scheme = base.scheme
                      if (char == EOF) {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.query = base.query
                      } else if (
                        char == '/' ||
                        (char == '\\' && isSpecial(url))
                      ) {
                        state = RELATIVE_SLASH
                      } else if (char == '?') {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.query = ''
                        state = QUERY
                      } else if (char == '#') {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.query = base.query
                        url.fragment = ''
                        state = FRAGMENT
                      } else {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        url.path = base.path.slice()
                        url.path.pop()
                        state = PATH
                        continue
                      }
                      break

                    case RELATIVE_SLASH:
                      if (isSpecial(url) && (char == '/' || char == '\\')) {
                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES
                      } else if (char == '/') {
                        state = AUTHORITY
                      } else {
                        url.username = base.username
                        url.password = base.password
                        url.host = base.host
                        url.port = base.port
                        state = PATH
                        continue
                      }
                      break

                    case SPECIAL_AUTHORITY_SLASHES:
                      state = SPECIAL_AUTHORITY_IGNORE_SLASHES
                      if (char != '/' || buffer.charAt(pointer + 1) != '/')
                        continue
                      pointer++
                      break

                    case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                      if (char != '/' && char != '\\') {
                        state = AUTHORITY
                        continue
                      }
                      break

                    case AUTHORITY:
                      if (char == '@') {
                        if (seenAt) buffer = '%40' + buffer
                        seenAt = true
                        bufferCodePoints = arrayFrom(buffer)
                        for (var i = 0; i < bufferCodePoints.length; i++) {
                          var codePoint = bufferCodePoints[i]
                          if (codePoint == ':' && !seenPasswordToken) {
                            seenPasswordToken = true
                            continue
                          }
                          var encodedCodePoints = percentEncode(
                            codePoint,
                            userinfoPercentEncodeSet
                          )
                          if (seenPasswordToken)
                            url.password += encodedCodePoints
                          else url.username += encodedCodePoints
                        }
                        buffer = ''
                      } else if (
                        char == EOF ||
                        char == '/' ||
                        char == '?' ||
                        char == '#' ||
                        (char == '\\' && isSpecial(url))
                      ) {
                        if (seenAt && buffer == '') return INVALID_AUTHORITY
                        pointer -= arrayFrom(buffer).length + 1
                        buffer = ''
                        state = HOST
                      } else buffer += char
                      break

                    case HOST:
                    case HOSTNAME:
                      if (stateOverride && url.scheme == 'file') {
                        state = FILE_HOST
                        continue
                      } else if (char == ':' && !seenBracket) {
                        if (buffer == '') return INVALID_HOST
                        failure = parseHost(url, buffer)
                        if (failure) return failure
                        buffer = ''
                        state = PORT
                        if (stateOverride == HOSTNAME) return
                      } else if (
                        char == EOF ||
                        char == '/' ||
                        char == '?' ||
                        char == '#' ||
                        (char == '\\' && isSpecial(url))
                      ) {
                        if (isSpecial(url) && buffer == '') return INVALID_HOST
                        if (
                          stateOverride &&
                          buffer == '' &&
                          (includesCredentials(url) || url.port !== null)
                        )
                          return
                        failure = parseHost(url, buffer)
                        if (failure) return failure
                        buffer = ''
                        state = PATH_START
                        if (stateOverride) return
                        continue
                      } else {
                        if (char == '[') seenBracket = true
                        else if (char == ']') seenBracket = false
                        buffer += char
                      }
                      break

                    case PORT:
                      if (DIGIT.test(char)) {
                        buffer += char
                      } else if (
                        char == EOF ||
                        char == '/' ||
                        char == '?' ||
                        char == '#' ||
                        (char == '\\' && isSpecial(url)) ||
                        stateOverride
                      ) {
                        if (buffer != '') {
                          var port = parseInt(buffer, 10)
                          if (port > 0xffff) return INVALID_PORT
                          url.port =
                            isSpecial(url) &&
                            port === specialSchemes[url.scheme]
                              ? null
                              : port
                          buffer = ''
                        }
                        if (stateOverride) return
                        state = PATH_START
                        continue
                      } else return INVALID_PORT
                      break

                    case FILE:
                      url.scheme = 'file'
                      if (char == '/' || char == '\\') state = FILE_SLASH
                      else if (base && base.scheme == 'file') {
                        if (char == EOF) {
                          url.host = base.host
                          url.path = base.path.slice()
                          url.query = base.query
                        } else if (char == '?') {
                          url.host = base.host
                          url.path = base.path.slice()
                          url.query = ''
                          state = QUERY
                        } else if (char == '#') {
                          url.host = base.host
                          url.path = base.path.slice()
                          url.query = base.query
                          url.fragment = ''
                          state = FRAGMENT
                        } else {
                          if (
                            !startsWithWindowsDriveLetter(
                              codePoints.slice(pointer).join('')
                            )
                          ) {
                            url.host = base.host
                            url.path = base.path.slice()
                            shortenURLsPath(url)
                          }
                          state = PATH
                          continue
                        }
                      } else {
                        state = PATH
                        continue
                      }
                      break

                    case FILE_SLASH:
                      if (char == '/' || char == '\\') {
                        state = FILE_HOST
                        break
                      }
                      if (
                        base &&
                        base.scheme == 'file' &&
                        !startsWithWindowsDriveLetter(
                          codePoints.slice(pointer).join('')
                        )
                      ) {
                        if (isWindowsDriveLetter(base.path[0], true))
                          url.path.push(base.path[0])
                        else url.host = base.host
                      }
                      state = PATH
                      continue

                    case FILE_HOST:
                      if (
                        char == EOF ||
                        char == '/' ||
                        char == '\\' ||
                        char == '?' ||
                        char == '#'
                      ) {
                        if (!stateOverride && isWindowsDriveLetter(buffer)) {
                          state = PATH
                        } else if (buffer == '') {
                          url.host = ''
                          if (stateOverride) return
                          state = PATH_START
                        } else {
                          failure = parseHost(url, buffer)
                          if (failure) return failure
                          if (url.host == 'localhost') url.host = ''
                          if (stateOverride) return
                          buffer = ''
                          state = PATH_START
                        }
                        continue
                      } else buffer += char
                      break

                    case PATH_START:
                      if (isSpecial(url)) {
                        state = PATH
                        if (char != '/' && char != '\\') continue
                      } else if (!stateOverride && char == '?') {
                        url.query = ''
                        state = QUERY
                      } else if (!stateOverride && char == '#') {
                        url.fragment = ''
                        state = FRAGMENT
                      } else if (char != EOF) {
                        state = PATH
                        if (char != '/') continue
                      }
                      break

                    case PATH:
                      if (
                        char == EOF ||
                        char == '/' ||
                        (char == '\\' && isSpecial(url)) ||
                        (!stateOverride && (char == '?' || char == '#'))
                      ) {
                        if (isDoubleDot(buffer)) {
                          shortenURLsPath(url)
                          if (
                            char != '/' &&
                            !(char == '\\' && isSpecial(url))
                          ) {
                            url.path.push('')
                          }
                        } else if (isSingleDot(buffer)) {
                          if (
                            char != '/' &&
                            !(char == '\\' && isSpecial(url))
                          ) {
                            url.path.push('')
                          }
                        } else {
                          if (
                            url.scheme == 'file' &&
                            !url.path.length &&
                            isWindowsDriveLetter(buffer)
                          ) {
                            if (url.host) url.host = ''
                            buffer = buffer.charAt(0) + ':' // normalize windows drive letter
                          }
                          url.path.push(buffer)
                        }
                        buffer = ''
                        if (
                          url.scheme == 'file' &&
                          (char == EOF || char == '?' || char == '#')
                        ) {
                          while (url.path.length > 1 && url.path[0] === '') {
                            url.path.shift()
                          }
                        }
                        if (char == '?') {
                          url.query = ''
                          state = QUERY
                        } else if (char == '#') {
                          url.fragment = ''
                          state = FRAGMENT
                        }
                      } else {
                        buffer += percentEncode(char, pathPercentEncodeSet)
                      }
                      break

                    case CANNOT_BE_A_BASE_URL_PATH:
                      if (char == '?') {
                        url.query = ''
                        state = QUERY
                      } else if (char == '#') {
                        url.fragment = ''
                        state = FRAGMENT
                      } else if (char != EOF) {
                        url.path[0] += percentEncode(
                          char,
                          C0ControlPercentEncodeSet
                        )
                      }
                      break

                    case QUERY:
                      if (!stateOverride && char == '#') {
                        url.fragment = ''
                        state = FRAGMENT
                      } else if (char != EOF) {
                        if (char == "'" && isSpecial(url)) url.query += '%27'
                        else if (char == '#') url.query += '%23'
                        else
                          url.query += percentEncode(
                            char,
                            C0ControlPercentEncodeSet
                          )
                      }
                      break

                    case FRAGMENT:
                      if (char != EOF)
                        url.fragment += percentEncode(
                          char,
                          fragmentPercentEncodeSet
                        )
                      break
                  }

                  pointer++
                }
              }

              // `URL` constructor
              // https://url.spec.whatwg.org/#url-class
              var URLConstructor = function URL(url /* , base */) {
                var that = anInstance(this, URLConstructor, 'URL')
                var base = arguments.length > 1 ? arguments[1] : undefined
                var urlString = String(url)
                var state = setInternalState(that, { type: 'URL' })
                var baseState, failure
                if (base !== undefined) {
                  if (base instanceof URLConstructor)
                    baseState = getInternalURLState(base)
                  else {
                    failure = parseURL((baseState = {}), String(base))
                    if (failure) throw TypeError(failure)
                  }
                }
                failure = parseURL(state, urlString, null, baseState)
                if (failure) throw TypeError(failure)
                var searchParams = (state.searchParams = new URLSearchParams())
                var searchParamsState =
                  getInternalSearchParamsState(searchParams)
                searchParamsState.updateSearchParams(state.query)
                searchParamsState.updateURL = function () {
                  state.query = String(searchParams) || null
                }
                if (!DESCRIPTORS) {
                  that.href = serializeURL.call(that)
                  that.origin = getOrigin.call(that)
                  that.protocol = getProtocol.call(that)
                  that.username = getUsername.call(that)
                  that.password = getPassword.call(that)
                  that.host = getHost.call(that)
                  that.hostname = getHostname.call(that)
                  that.port = getPort.call(that)
                  that.pathname = getPathname.call(that)
                  that.search = getSearch.call(that)
                  that.searchParams = getSearchParams.call(that)
                  that.hash = getHash.call(that)
                }
              }

              var URLPrototype = URLConstructor.prototype

              var serializeURL = function () {
                var url = getInternalURLState(this)
                var scheme = url.scheme
                var username = url.username
                var password = url.password
                var host = url.host
                var port = url.port
                var path = url.path
                var query = url.query
                var fragment = url.fragment
                var output = scheme + ':'
                if (host !== null) {
                  output += '//'
                  if (includesCredentials(url)) {
                    output += username + (password ? ':' + password : '') + '@'
                  }
                  output += serializeHost(host)
                  if (port !== null) output += ':' + port
                } else if (scheme == 'file') output += '//'
                output += url.cannotBeABaseURL
                  ? path[0]
                  : path.length
                    ? '/' + path.join('/')
                    : ''
                if (query !== null) output += '?' + query
                if (fragment !== null) output += '#' + fragment
                return output
              }

              var getOrigin = function () {
                var url = getInternalURLState(this)
                var scheme = url.scheme
                var port = url.port
                if (scheme == 'blob')
                  try {
                    return new URL(scheme.path[0]).origin
                  } catch (error) {
                    return 'null'
                  }
                if (scheme == 'file' || !isSpecial(url)) return 'null'
                return (
                  scheme +
                  '://' +
                  serializeHost(url.host) +
                  (port !== null ? ':' + port : '')
                )
              }

              var getProtocol = function () {
                return getInternalURLState(this).scheme + ':'
              }

              var getUsername = function () {
                return getInternalURLState(this).username
              }

              var getPassword = function () {
                return getInternalURLState(this).password
              }

              var getHost = function () {
                var url = getInternalURLState(this)
                var host = url.host
                var port = url.port
                return host === null
                  ? ''
                  : port === null
                    ? serializeHost(host)
                    : serializeHost(host) + ':' + port
              }

              var getHostname = function () {
                var host = getInternalURLState(this).host
                return host === null ? '' : serializeHost(host)
              }

              var getPort = function () {
                var port = getInternalURLState(this).port
                return port === null ? '' : String(port)
              }

              var getPathname = function () {
                var url = getInternalURLState(this)
                var path = url.path
                return url.cannotBeABaseURL
                  ? path[0]
                  : path.length
                    ? '/' + path.join('/')
                    : ''
              }

              var getSearch = function () {
                var query = getInternalURLState(this).query
                return query ? '?' + query : ''
              }

              var getSearchParams = function () {
                return getInternalURLState(this).searchParams
              }

              var getHash = function () {
                var fragment = getInternalURLState(this).fragment
                return fragment ? '#' + fragment : ''
              }

              var accessorDescriptor = function (getter, setter) {
                return {
                  get: getter,
                  set: setter,
                  configurable: true,
                  enumerable: true
                }
              }

              if (DESCRIPTORS) {
                defineProperties(URLPrototype, {
                  // `URL.prototype.href` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-href
                  href: accessorDescriptor(serializeURL, function (href) {
                    var url = getInternalURLState(this)
                    var urlString = String(href)
                    var failure = parseURL(url, urlString)
                    if (failure) throw TypeError(failure)
                    getInternalSearchParamsState(
                      url.searchParams
                    ).updateSearchParams(url.query)
                  }),
                  // `URL.prototype.origin` getter
                  // https://url.spec.whatwg.org/#dom-url-origin
                  origin: accessorDescriptor(getOrigin),
                  // `URL.prototype.protocol` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-protocol
                  protocol: accessorDescriptor(
                    getProtocol,
                    function (protocol) {
                      var url = getInternalURLState(this)
                      parseURL(url, String(protocol) + ':', SCHEME_START)
                    }
                  ),
                  // `URL.prototype.username` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-username
                  username: accessorDescriptor(
                    getUsername,
                    function (username) {
                      var url = getInternalURLState(this)
                      var codePoints = arrayFrom(String(username))
                      if (cannotHaveUsernamePasswordPort(url)) return
                      url.username = ''
                      for (var i = 0; i < codePoints.length; i++) {
                        url.username += percentEncode(
                          codePoints[i],
                          userinfoPercentEncodeSet
                        )
                      }
                    }
                  ),
                  // `URL.prototype.password` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-password
                  password: accessorDescriptor(
                    getPassword,
                    function (password) {
                      var url = getInternalURLState(this)
                      var codePoints = arrayFrom(String(password))
                      if (cannotHaveUsernamePasswordPort(url)) return
                      url.password = ''
                      for (var i = 0; i < codePoints.length; i++) {
                        url.password += percentEncode(
                          codePoints[i],
                          userinfoPercentEncodeSet
                        )
                      }
                    }
                  ),
                  // `URL.prototype.host` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-host
                  host: accessorDescriptor(getHost, function (host) {
                    var url = getInternalURLState(this)
                    if (url.cannotBeABaseURL) return
                    parseURL(url, String(host), HOST)
                  }),
                  // `URL.prototype.hostname` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-hostname
                  hostname: accessorDescriptor(
                    getHostname,
                    function (hostname) {
                      var url = getInternalURLState(this)
                      if (url.cannotBeABaseURL) return
                      parseURL(url, String(hostname), HOSTNAME)
                    }
                  ),
                  // `URL.prototype.port` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-port
                  port: accessorDescriptor(getPort, function (port) {
                    var url = getInternalURLState(this)
                    if (cannotHaveUsernamePasswordPort(url)) return
                    port = String(port)
                    if (port == '') url.port = null
                    else parseURL(url, port, PORT)
                  }),
                  // `URL.prototype.pathname` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-pathname
                  pathname: accessorDescriptor(
                    getPathname,
                    function (pathname) {
                      var url = getInternalURLState(this)
                      if (url.cannotBeABaseURL) return
                      url.path = []
                      parseURL(url, pathname + '', PATH_START)
                    }
                  ),
                  // `URL.prototype.search` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-search
                  search: accessorDescriptor(getSearch, function (search) {
                    var url = getInternalURLState(this)
                    search = String(search)
                    if (search == '') {
                      url.query = null
                    } else {
                      if ('?' == search.charAt(0)) search = search.slice(1)
                      url.query = ''
                      parseURL(url, search, QUERY)
                    }
                    getInternalSearchParamsState(
                      url.searchParams
                    ).updateSearchParams(url.query)
                  }),
                  // `URL.prototype.searchParams` getter
                  // https://url.spec.whatwg.org/#dom-url-searchparams
                  searchParams: accessorDescriptor(getSearchParams),
                  // `URL.prototype.hash` accessors pair
                  // https://url.spec.whatwg.org/#dom-url-hash
                  hash: accessorDescriptor(getHash, function (hash) {
                    var url = getInternalURLState(this)
                    hash = String(hash)
                    if (hash == '') {
                      url.fragment = null
                      return
                    }
                    if ('#' == hash.charAt(0)) hash = hash.slice(1)
                    url.fragment = ''
                    parseURL(url, hash, FRAGMENT)
                  })
                })
              }

              // `URL.prototype.toJSON` method
              // https://url.spec.whatwg.org/#dom-url-tojson
              redefine(
                URLPrototype,
                'toJSON',
                function toJSON() {
                  return serializeURL.call(this)
                },
                { enumerable: true }
              )

              // `URL.prototype.toString` method
              // https://url.spec.whatwg.org/#URL-stringification-behavior
              redefine(
                URLPrototype,
                'toString',
                function toString() {
                  return serializeURL.call(this)
                },
                { enumerable: true }
              )

              if (NativeURL) {
                var nativeCreateObjectURL = NativeURL.createObjectURL
                var nativeRevokeObjectURL = NativeURL.revokeObjectURL
                // `URL.createObjectURL` method
                // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
                // eslint-disable-next-line no-unused-vars -- required for `.length`
                if (nativeCreateObjectURL)
                  redefine(
                    URLConstructor,
                    'createObjectURL',
                    function createObjectURL(blob) {
                      return nativeCreateObjectURL.apply(NativeURL, arguments)
                    }
                  )
                // `URL.revokeObjectURL` method
                // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
                // eslint-disable-next-line no-unused-vars -- required for `.length`
                if (nativeRevokeObjectURL)
                  redefine(
                    URLConstructor,
                    'revokeObjectURL',
                    function revokeObjectURL(url) {
                      return nativeRevokeObjectURL.apply(NativeURL, arguments)
                    }
                  )
              }

              setToStringTag(URLConstructor, 'URL')

              $(
                { global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS },
                {
                  URL: URLConstructor
                }
              )

              /***/
            }

            /******/
          }
          /************************************************************************/
          /******/ // The module cache
          /******/ var __webpack_module_cache__ = {}
          /******/
          /******/ // The require function
          /******/ function __nested_webpack_require_210484__(moduleId) {
            /******/ // Check if module is in cache
            /******/ if (__webpack_module_cache__[moduleId]) {
              /******/ return __webpack_module_cache__[moduleId].exports
              /******/
            }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module = (__webpack_module_cache__[moduleId] = {
              /******/ // no module.id needed
              /******/ // no module.loaded needed
              /******/ exports: {}
              /******/
            })
            /******/
            /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](
              module,
              module.exports,
              __nested_webpack_require_210484__
            )
            /******/
            /******/ // Return the exports of the module
            /******/ return module.exports
            /******/
          }
          /******/
          /************************************************************************/
          /******/ /* webpack/runtime/define property getters */
          /******/ !(function () {
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_210484__.d = function (
              exports,
              definition
            ) {
              /******/ for (var key in definition) {
                /******/ if (
                  __nested_webpack_require_210484__.o(definition, key) &&
                  !__nested_webpack_require_210484__.o(exports, key)
                ) {
                  /******/ Object.defineProperty(exports, key, {
                    enumerable: true,
                    get: definition[key]
                  })
                  /******/
                }
                /******/
              }
              /******/
            }
            /******/
          })()
          /******/
          /******/ /* webpack/runtime/global */
          /******/ !(function () {
            /******/ __nested_webpack_require_210484__.g = (function () {
              /******/ if (typeof globalThis === 'object') return globalThis
              /******/ try {
                /******/ return this || new Function('return this')()
                /******/
              } catch (e) {
                /******/ if (typeof window === 'object') return window
                /******/
              }
              /******/
            })()
            /******/
          })()
          /******/
          /******/ /* webpack/runtime/hasOwnProperty shorthand */
          /******/ !(function () {
            /******/ __nested_webpack_require_210484__.o = function (
              obj,
              prop
            ) {
              return Object.prototype.hasOwnProperty.call(obj, prop)
            }
            /******/
          })()
          /******/
          /******/ /* webpack/runtime/make namespace object */
          /******/ !(function () {
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_210484__.r = function (exports) {
              /******/ if (
                typeof Symbol !== 'undefined' &&
                Symbol.toStringTag
              ) {
                /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                  value: 'Module'
                })
                /******/
              }
              /******/ Object.defineProperty(exports, '__esModule', {
                value: true
              })
              /******/
            }
            /******/
          })()
          /******/
          /************************************************************************/
          var __nested_webpack_exports__ = {}
          // This entry need to be wrapped in an IIFE because it need to be in strict mode.
          !(function () {
            'use strict'
            // ESM COMPAT FLAG
            __nested_webpack_require_210484__.r(__nested_webpack_exports__)

            // EXPORTS
            __nested_webpack_require_210484__.d(__nested_webpack_exports__, {
              Dropzone: function () {
                return /* reexport */ Dropzone
              },
              default: function () {
                return /* binding */ dropzone_dist
              }
            })

            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
            var es_array_concat = __nested_webpack_require_210484__(2222)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
            var es_array_filter = __nested_webpack_require_210484__(7327)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
            var es_array_index_of = __nested_webpack_require_210484__(2772)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
            var es_array_iterator = __nested_webpack_require_210484__(6992)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
            var es_array_map = __nested_webpack_require_210484__(1249)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
            var es_array_slice = __nested_webpack_require_210484__(7042)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
            var es_array_splice = __nested_webpack_require_210484__(561)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.constructor.js
            var es_array_buffer_constructor =
              __nested_webpack_require_210484__(8264)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
            var es_function_name = __nested_webpack_require_210484__(8309)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
            var es_object_get_prototype_of =
              __nested_webpack_require_210484__(489)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
            var es_object_to_string = __nested_webpack_require_210484__(1539)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
            var es_regexp_exec = __nested_webpack_require_210484__(4916)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
            var es_regexp_to_string = __nested_webpack_require_210484__(9714)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
            var es_string_iterator = __nested_webpack_require_210484__(8783)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
            var es_string_match = __nested_webpack_require_210484__(4723)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
            var es_string_replace = __nested_webpack_require_210484__(5306)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
            var es_string_split = __nested_webpack_require_210484__(3123)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
            var es_string_trim = __nested_webpack_require_210484__(3210)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.uint8-array.js
            var es_typed_array_uint8_array =
              __nested_webpack_require_210484__(2472)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.copy-within.js
            var es_typed_array_copy_within =
              __nested_webpack_require_210484__(2990)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.every.js
            var es_typed_array_every = __nested_webpack_require_210484__(8927)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.fill.js
            var es_typed_array_fill = __nested_webpack_require_210484__(3105)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.filter.js
            var es_typed_array_filter = __nested_webpack_require_210484__(5035)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find.js
            var es_typed_array_find = __nested_webpack_require_210484__(4345)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find-index.js
            var es_typed_array_find_index =
              __nested_webpack_require_210484__(7174)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.for-each.js
            var es_typed_array_for_each =
              __nested_webpack_require_210484__(2846)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.includes.js
            var es_typed_array_includes =
              __nested_webpack_require_210484__(4731)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.index-of.js
            var es_typed_array_index_of =
              __nested_webpack_require_210484__(7209)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.iterator.js
            var es_typed_array_iterator =
              __nested_webpack_require_210484__(6319)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.join.js
            var es_typed_array_join = __nested_webpack_require_210484__(8867)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.last-index-of.js
            var es_typed_array_last_index_of =
              __nested_webpack_require_210484__(7789)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.map.js
            var es_typed_array_map = __nested_webpack_require_210484__(3739)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce.js
            var es_typed_array_reduce = __nested_webpack_require_210484__(9368)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce-right.js
            var es_typed_array_reduce_right =
              __nested_webpack_require_210484__(4483)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reverse.js
            var es_typed_array_reverse = __nested_webpack_require_210484__(2056)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
            var es_typed_array_set = __nested_webpack_require_210484__(3462)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.slice.js
            var es_typed_array_slice = __nested_webpack_require_210484__(678)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.some.js
            var es_typed_array_some = __nested_webpack_require_210484__(7462)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js
            var es_typed_array_sort = __nested_webpack_require_210484__(3824)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.subarray.js
            var es_typed_array_subarray =
              __nested_webpack_require_210484__(5021)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-locale-string.js
            var es_typed_array_to_locale_string =
              __nested_webpack_require_210484__(2974)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-string.js
            var es_typed_array_to_string =
              __nested_webpack_require_210484__(5016)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
            var web_dom_collections_for_each =
              __nested_webpack_require_210484__(4747)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
            var web_dom_collections_iterator =
              __nested_webpack_require_210484__(3948)
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.js
            var web_url = __nested_webpack_require_210484__(285) // CONCATENATED MODULE: ./src/emitter.js
            function _createForOfIteratorHelper(o, allowArrayLike) {
              var it
              if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
                if (
                  Array.isArray(o) ||
                  (it = _unsupportedIterableToArray(o)) ||
                  (allowArrayLike && o && typeof o.length === 'number')
                ) {
                  if (it) o = it
                  var i = 0
                  var F = function F() {}
                  return {
                    s: F,
                    n: function n() {
                      if (i >= o.length) return { done: true }
                      return { done: false, value: o[i++] }
                    },
                    e: function e(_e) {
                      throw _e
                    },
                    f: F
                  }
                }
                throw new TypeError(
                  'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                )
              }
              var normalCompletion = true,
                didErr = false,
                err
              return {
                s: function s() {
                  it = o[Symbol.iterator]()
                },
                n: function n() {
                  var step = it.next()
                  normalCompletion = step.done
                  return step
                },
                e: function e(_e2) {
                  didErr = true
                  err = _e2
                },
                f: function f() {
                  try {
                    if (!normalCompletion && it.return != null) it.return()
                  } finally {
                    if (didErr) throw err
                  }
                }
              }
            }

            function _unsupportedIterableToArray(o, minLen) {
              if (!o) return
              if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
              var n = Object.prototype.toString.call(o).slice(8, -1)
              if (n === 'Object' && o.constructor) n = o.constructor.name
              if (n === 'Map' || n === 'Set') return Array.from(o)
              if (
                n === 'Arguments' ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return _arrayLikeToArray(o, minLen)
            }

            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
              }
              return arr2
            }

            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function')
              }
            }

            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }

            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps)
              if (staticProps) _defineProperties(Constructor, staticProps)
              return Constructor
            }

            // The Emitter class provides the ability to call `.on()` on Dropzone to listen
            // to events.
            // It is strongly based on component's emitter class, and I removed the
            // functionality because of the dependency hell with different frameworks.
            var Emitter = /*#__PURE__*/ (function () {
              function Emitter() {
                _classCallCheck(this, Emitter)
              }

              _createClass(Emitter, [
                {
                  key: 'on',
                  // Add an event listener for given event
                  value: function on(event, fn) {
                    this._callbacks = this._callbacks || {} // Create namespace for this event

                    if (!this._callbacks[event]) {
                      this._callbacks[event] = []
                    }

                    this._callbacks[event].push(fn)

                    return this
                  }
                },
                {
                  key: 'emit',
                  value: function emit(event) {
                    this._callbacks = this._callbacks || {}
                    var callbacks = this._callbacks[event]

                    for (
                      var _len = arguments.length,
                        args = new Array(_len > 1 ? _len - 1 : 0),
                        _key = 1;
                      _key < _len;
                      _key++
                    ) {
                      args[_key - 1] = arguments[_key]
                    }

                    if (callbacks) {
                      var _iterator = _createForOfIteratorHelper(
                          callbacks,
                          true
                        ),
                        _step

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var callback = _step.value
                          callback.apply(this, args)
                        }
                      } catch (err) {
                        _iterator.e(err)
                      } finally {
                        _iterator.f()
                      }
                    } // trigger a corresponding DOM event

                    if (this.element) {
                      this.element.dispatchEvent(
                        this.makeEvent('dropzone:' + event, {
                          args: args
                        })
                      )
                    }

                    return this
                  }
                },
                {
                  key: 'makeEvent',
                  value: function makeEvent(eventName, detail) {
                    var params = {
                      bubbles: true,
                      cancelable: true,
                      detail: detail
                    }

                    if (typeof window.CustomEvent === 'function') {
                      return new CustomEvent(eventName, params)
                    } else {
                      // IE 11 support
                      // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
                      var evt = document.createEvent('CustomEvent')
                      evt.initCustomEvent(
                        eventName,
                        params.bubbles,
                        params.cancelable,
                        params.detail
                      )
                      return evt
                    }
                  } // Remove event listener for given event. If fn is not provided, all event
                  // listeners for that event will be removed. If neither is provided, all
                  // event listeners will be removed.
                },
                {
                  key: 'off',
                  value: function off(event, fn) {
                    if (!this._callbacks || arguments.length === 0) {
                      this._callbacks = {}
                      return this
                    } // specific event

                    var callbacks = this._callbacks[event]

                    if (!callbacks) {
                      return this
                    } // remove all handlers

                    if (arguments.length === 1) {
                      delete this._callbacks[event]
                      return this
                    } // remove specific handler

                    for (var i = 0; i < callbacks.length; i++) {
                      var callback = callbacks[i]

                      if (callback === fn) {
                        callbacks.splice(i, 1)
                        break
                      }
                    }

                    return this
                  }
                }
              ])

              return Emitter
            })() // CONCATENATED MODULE: ./src/preview-template.html

            // Module
            var code =
              '<div class="dz-preview dz-file-preview"> <div class="dz-image"><img data-dz-thumbnail/></div> <div class="dz-details"> <div class="dz-size"><span data-dz-size></span></div> <div class="dz-filename"><span data-dz-name></span></div> </div> <div class="dz-progress"> <span class="dz-upload" data-dz-uploadprogress></span> </div> <div class="dz-error-message"><span data-dz-errormessage></span></div> <div class="dz-success-mark"> <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <title>Check</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <path d="M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" stroke-opacity="0.198794158" stroke="#747474" fill-opacity="0.816519475" fill="#FFFFFF"></path> </g> </svg> </div> <div class="dz-error-mark"> <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <title>Error</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g stroke="#747474" stroke-opacity="0.198794158" fill="#FFFFFF" fill-opacity="0.816519475"> <path d="M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z"></path> </g> </g> </svg> </div> </div> '
            // Exports
            /* harmony default export */ var preview_template = code // CONCATENATED MODULE: ./src/options.js
            function options_createForOfIteratorHelper(o, allowArrayLike) {
              var it
              if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
                if (
                  Array.isArray(o) ||
                  (it = options_unsupportedIterableToArray(o)) ||
                  (allowArrayLike && o && typeof o.length === 'number')
                ) {
                  if (it) o = it
                  var i = 0
                  var F = function F() {}
                  return {
                    s: F,
                    n: function n() {
                      if (i >= o.length) return { done: true }
                      return { done: false, value: o[i++] }
                    },
                    e: function e(_e) {
                      throw _e
                    },
                    f: F
                  }
                }
                throw new TypeError(
                  'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                )
              }
              var normalCompletion = true,
                didErr = false,
                err
              return {
                s: function s() {
                  it = o[Symbol.iterator]()
                },
                n: function n() {
                  var step = it.next()
                  normalCompletion = step.done
                  return step
                },
                e: function e(_e2) {
                  didErr = true
                  err = _e2
                },
                f: function f() {
                  try {
                    if (!normalCompletion && it.return != null) it.return()
                  } finally {
                    if (didErr) throw err
                  }
                }
              }
            }

            function options_unsupportedIterableToArray(o, minLen) {
              if (!o) return
              if (typeof o === 'string')
                return options_arrayLikeToArray(o, minLen)
              var n = Object.prototype.toString.call(o).slice(8, -1)
              if (n === 'Object' && o.constructor) n = o.constructor.name
              if (n === 'Map' || n === 'Set') return Array.from(o)
              if (
                n === 'Arguments' ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return options_arrayLikeToArray(o, minLen)
            }

            function options_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
              }
              return arr2
            }

            var defaultOptions = {
              /**
               * Has to be specified on elements other than form (or when the form
               * doesn't have an `action` attribute). You can also
               * provide a function that will be called with `files` and
               * must return the url (since `v3.12.0`)
               */
              url: null,

              /**
               * Can be changed to `"put"` if necessary. You can also provide a function
               * that will be called with `files` and must return the method (since `v3.12.0`).
               */
              method: 'post',

              /**
               * Will be set on the XHRequest.
               */
              withCredentials: false,

              /**
               * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
               * If set to null or 0, no timeout is going to be set.
               */
              timeout: null,

              /**
               * How many file uploads to process in parallel (See the
               * Enqueuing file uploads documentation section for more info)
               */
              parallelUploads: 2,

              /**
               * Whether to send multiple files in one request. If
               * this it set to true, then the fallback file input element will
               * have the `multiple` attribute as well. This option will
               * also trigger additional events (like `processingmultiple`). See the events
               * documentation section for more information.
               */
              uploadMultiple: false,

              /**
               * Whether you want files to be uploaded in chunks to your server. This can't be
               * used in combination with `uploadMultiple`.
               *
               * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
               */
              chunking: false,

              /**
               * If `chunking` is enabled, this defines whether **every** file should be chunked,
               * even if the file size is below chunkSize. This means, that the additional chunk
               * form data will be submitted and the `chunksUploaded` callback will be invoked.
               */
              forceChunking: false,

              /**
               * If `chunking` is `true`, then this defines the chunk size in bytes.
               */
              chunkSize: 2000000,

              /**
               * If `true`, the individual chunks of a file are being uploaded simultaneously.
               */
              parallelChunkUploads: false,

              /**
               * Whether a chunk should be retried if it fails.
               */
              retryChunks: false,

              /**
               * If `retryChunks` is true, how many times should it be retried.
               */
              retryChunksLimit: 3,

              /**
               * The maximum filesize (in bytes) that is allowed to be uploaded.
               */
              maxFilesize: 256,

              /**
               * The name of the file param that gets transferred.
               * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
               * Dropzone will append `[]` to the name.
               */
              paramName: 'file',

              /**
               * Whether thumbnails for images should be generated
               */
              createImageThumbnails: true,

              /**
               * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
               */
              maxThumbnailFilesize: 10,

              /**
               * If `null`, the ratio of the image will be used to calculate it.
               */
              thumbnailWidth: 120,

              /**
               * The same as `thumbnailWidth`. If both are null, images will not be resized.
               */
              thumbnailHeight: 120,

              /**
               * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
               * Can be either `contain` or `crop`.
               */
              thumbnailMethod: 'crop',

              /**
               * If set, images will be resized to these dimensions before being **uploaded**.
               * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
               * ratio of the file will be preserved.
               *
               * The `options.transformFile` function uses these options, so if the `transformFile` function
               * is overridden, these options don't do anything.
               */
              resizeWidth: null,

              /**
               * See `resizeWidth`.
               */
              resizeHeight: null,

              /**
               * The mime type of the resized image (before it gets uploaded to the server).
               * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
               * See `resizeWidth` for more information.
               */
              resizeMimeType: null,

              /**
               * The quality of the resized images. See `resizeWidth`.
               */
              resizeQuality: 0.8,

              /**
               * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
               * Can be either `contain` or `crop`.
               */
              resizeMethod: 'contain',

              /**
               * The base that is used to calculate the **displayed** filesize. You can
               * change this to 1024 if you would rather display kibibytes, mebibytes,
               * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
               * not `1 kilobyte`. You can change this to `1024` if you don't care about
               * validity.
               */
              filesizeBase: 1000,

              /**
               * If not `null` defines how many files this Dropzone handles. If it exceeds,
               * the event `maxfilesexceeded` will be called. The dropzone element gets the
               * class `dz-max-files-reached` accordingly so you can provide visual
               * feedback.
               */
              maxFiles: null,

              /**
               * An optional object to send additional headers to the server. Eg:
               * `{ "My-Awesome-Header": "header value" }`
               */
              headers: null,

              /**
               * If `true`, the dropzone element itself will be clickable, if `false`
               * nothing will be clickable.
               *
               * You can also pass an HTML element, a CSS selector (for multiple elements)
               * or an array of those. In that case, all of those elements will trigger an
               * upload when clicked.
               */
              clickable: true,

              /**
               * Whether hidden files in directories should be ignored.
               */
              ignoreHiddenFiles: true,

              /**
               * The default implementation of `accept` checks the file's mime type or
               * extension against this list. This is a comma separated list of mime
               * types or file extensions.
               *
               * Eg.: `image/*,application/pdf,.psd`
               *
               * If the Dropzone is `clickable` this option will also be used as
               * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
               * parameter on the hidden file input as well.
               */
              acceptedFiles: null,

              /**
               * **Deprecated!**
               * Use acceptedFiles instead.
               */
              acceptedMimeTypes: null,

              /**
               * If false, files will be added to the queue but the queue will not be
               * processed automatically.
               * This can be useful if you need some additional user input before sending
               * files (or if you want want all files sent at once).
               * If you're ready to send the file simply call `myDropzone.processQueue()`.
               *
               * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
               * section for more information.
               */
              autoProcessQueue: true,

              /**
               * If false, files added to the dropzone will not be queued by default.
               * You'll have to call `enqueueFile(file)` manually.
               */
              autoQueue: true,

              /**
               * If `true`, this will add a link to every file preview to remove or cancel (if
               * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
               * and `dictRemoveFile` options are used for the wording.
               */
              addRemoveLinks: false,

              /**
               * Defines where to display the file previews – if `null` the
               * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
               * selector. The element should have the `dropzone-previews` class so
               * the previews are displayed properly.
               */
              previewsContainer: null,

              /**
               * Set this to `true` if you don't want previews to be shown.
               */
              disablePreviews: false,

              /**
               * This is the element the hidden input field (which is used when clicking on the
               * dropzone to trigger file selection) will be appended to. This might
               * be important in case you use frameworks to switch the content of your page.
               *
               * Can be a selector string, or an element directly.
               */
              hiddenInputContainer: 'body',

              /**
               * If null, no capture type will be specified
               * If camera, mobile devices will skip the file selection and choose camera
               * If microphone, mobile devices will skip the file selection and choose the microphone
               * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
               * On apple devices multiple must be set to false.  AcceptedFiles may need to
               * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
               */
              capture: null,

              /**
               * **Deprecated**. Use `renameFile` instead.
               */
              renameFilename: null,

              /**
               * A function that is invoked before the file is uploaded to the server and renames the file.
               * This function gets the `File` as argument and can use the `file.name`. The actual name of the
               * file that gets used during the upload can be accessed through `file.upload.filename`.
               */
              renameFile: null,

              /**
               * If `true` the fallback will be forced. This is very useful to test your server
               * implementations first and make sure that everything works as
               * expected without dropzone if you experience problems, and to test
               * how your fallbacks will look.
               */
              forceFallback: false,

              /**
               * The text used before any files are dropped.
               */
              dictDefaultMessage: 'Drop files here to upload',

              /**
               * The text that replaces the default message text it the browser is not supported.
               */
              dictFallbackMessage:
                "Your browser does not support drag'n'drop file uploads.",

              /**
               * The text that will be added before the fallback form.
               * If you provide a  fallback element yourself, or if this option is `null` this will
               * be ignored.
               */
              dictFallbackText:
                'Please use the fallback form below to upload your files like in the olden days.',

              /**
               * If the filesize is too big.
               * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
               */
              dictFileTooBig:
                'File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.',

              /**
               * If the file doesn't match the file type.
               */
              dictInvalidFileType: "You can't upload files of this type.",

              /**
               * If the server response was invalid.
               * `{{statusCode}}` will be replaced with the servers status code.
               */
              dictResponseError: 'Server responded with {{statusCode}} code.',

              /**
               * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
               */
              dictCancelUpload: 'Cancel upload',

              /**
               * The text that is displayed if an upload was manually canceled
               */
              dictUploadCanceled: 'Upload canceled.',

              /**
               * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
               */
              dictCancelUploadConfirmation:
                'Are you sure you want to cancel this upload?',

              /**
               * If `addRemoveLinks` is true, the text to be used to remove a file.
               */
              dictRemoveFile: 'Remove file',

              /**
               * If this is not null, then the user will be prompted before removing a file.
               */
              dictRemoveFileConfirmation: null,

              /**
               * Displayed if `maxFiles` is st and exceeded.
               * The string `{{maxFiles}}` will be replaced by the configuration value.
               */
              dictMaxFilesExceeded: 'You can not upload any more files.',

              /**
               * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
               * `b` for bytes.
               */
              dictFileSizeUnits: {
                tb: 'TB',
                gb: 'GB',
                mb: 'MB',
                kb: 'KB',
                b: 'b'
              },

              /**
               * Called when dropzone initialized
               * You can add event listeners here
               */
              init: function init() {},

              /**
               * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
               * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
               * of a function, this needs to return a map.
               *
               * The default implementation does nothing for normal uploads, but adds relevant information for
               * chunked uploads.
               *
               * This is the same as adding hidden input fields in the form element.
               */
              params: function params(files, xhr, chunk) {
                if (chunk) {
                  return {
                    dzuuid: chunk.file.upload.uuid,
                    dzchunkindex: chunk.index,
                    dztotalfilesize: chunk.file.size,
                    dzchunksize: this.options.chunkSize,
                    dztotalchunkcount: chunk.file.upload.totalChunkCount,
                    dzchunkbyteoffset: chunk.index * this.options.chunkSize
                  }
                }
              },

              /**
               * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
               * and a `done` function as parameters.
               *
               * If the done function is invoked without arguments, the file is "accepted" and will
               * be processed. If you pass an error message, the file is rejected, and the error
               * message will be displayed.
               * This function will not be called if the file is too big or doesn't match the mime types.
               */
              accept: function accept(file, done) {
                return done()
              },

              /**
               * The callback that will be invoked when all chunks have been uploaded for a file.
               * It gets the file for which the chunks have been uploaded as the first parameter,
               * and the `done` function as second. `done()` needs to be invoked when everything
               * needed to finish the upload process is done.
               */
              chunksUploaded: function chunksUploaded(file, done) {
                done()
              },

              /**
               * Gets called when the browser is not supported.
               * The default implementation shows the fallback input field and adds
               * a text.
               */
              fallback: function fallback() {
                // This code should pass in IE7... :(
                var messageElement
                this.element.className = ''.concat(
                  this.element.className,
                  ' dz-browser-not-supported'
                )

                var _iterator = options_createForOfIteratorHelper(
                    this.element.getElementsByTagName('div'),
                    true
                  ),
                  _step

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var child = _step.value

                    if (/(^| )dz-message($| )/.test(child.className)) {
                      messageElement = child
                      child.className = 'dz-message' // Removes the 'dz-default' class

                      break
                    }
                  }
                } catch (err) {
                  _iterator.e(err)
                } finally {
                  _iterator.f()
                }

                if (!messageElement) {
                  messageElement = Dropzone.createElement(
                    '<div class="dz-message"><span></span></div>'
                  )
                  this.element.appendChild(messageElement)
                }

                var span = messageElement.getElementsByTagName('span')[0]

                if (span) {
                  if (span.textContent != null) {
                    span.textContent = this.options.dictFallbackMessage
                  } else if (span.innerText != null) {
                    span.innerText = this.options.dictFallbackMessage
                  }
                }

                return this.element.appendChild(this.getFallbackForm())
              },

              /**
               * Gets called to calculate the thumbnail dimensions.
               *
               * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
               *
               *  - `srcWidth` & `srcHeight` (required)
               *  - `trgWidth` & `trgHeight` (required)
               *  - `srcX` & `srcY` (optional, default `0`)
               *  - `trgX` & `trgY` (optional, default `0`)
               *
               * Those values are going to be used by `ctx.drawImage()`.
               */
              resize: function resize(file, width, height, resizeMethod) {
                var info = {
                  srcX: 0,
                  srcY: 0,
                  srcWidth: file.width,
                  srcHeight: file.height
                }
                var srcRatio = file.width / file.height // Automatically calculate dimensions if not specified

                if (width == null && height == null) {
                  width = info.srcWidth
                  height = info.srcHeight
                } else if (width == null) {
                  width = height * srcRatio
                } else if (height == null) {
                  height = width / srcRatio
                } // Make sure images aren't upscaled

                width = Math.min(width, info.srcWidth)
                height = Math.min(height, info.srcHeight)
                var trgRatio = width / height

                if (info.srcWidth > width || info.srcHeight > height) {
                  // Image is bigger and needs rescaling
                  if (resizeMethod === 'crop') {
                    if (srcRatio > trgRatio) {
                      info.srcHeight = file.height
                      info.srcWidth = info.srcHeight * trgRatio
                    } else {
                      info.srcWidth = file.width
                      info.srcHeight = info.srcWidth / trgRatio
                    }
                  } else if (resizeMethod === 'contain') {
                    // Method 'contain'
                    if (srcRatio > trgRatio) {
                      height = width / srcRatio
                    } else {
                      width = height * srcRatio
                    }
                  } else {
                    throw new Error(
                      "Unknown resizeMethod '".concat(resizeMethod, "'")
                    )
                  }
                }

                info.srcX = (file.width - info.srcWidth) / 2
                info.srcY = (file.height - info.srcHeight) / 2
                info.trgWidth = width
                info.trgHeight = height
                return info
              },

              /**
               * Can be used to transform the file (for example, resize an image if necessary).
               *
               * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
               * images according to those dimensions.
               *
               * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
               * to be invoked with the file when the transformation is done.
               */
              transformFile: function transformFile(file, done) {
                if (
                  (this.options.resizeWidth || this.options.resizeHeight) &&
                  file.type.match(/image.*/)
                ) {
                  return this.resizeImage(
                    file,
                    this.options.resizeWidth,
                    this.options.resizeHeight,
                    this.options.resizeMethod,
                    done
                  )
                } else {
                  return done(file)
                }
              },

              /**
               * A string that contains the template used for each dropped
               * file. Change it to fulfill your needs but make sure to properly
               * provide all elements.
               *
               * If you want to use an actual HTML element instead of providing a String
               * as a config option, you could create a div with the id `tpl`,
               * put the template inside it and provide the element like this:
               *
               *     document
               *       .querySelector('#tpl')
               *       .innerHTML
               *
               */
              previewTemplate: preview_template,

              /*
   Those functions register themselves to the events on init and handle all
   the user interface specific stuff. Overwriting them won't break the upload
   but can break the way it's displayed.
   You can overwrite them if you don't like the default behavior. If you just
   want to add an additional event handler, register it on the dropzone object
   and don't overwrite those options.
   */
              // Those are self explanatory and simply concern the DragnDrop.
              drop: function drop(e) {
                return this.element.classList.remove('dz-drag-hover')
              },
              dragstart: function dragstart(e) {},
              dragend: function dragend(e) {
                return this.element.classList.remove('dz-drag-hover')
              },
              dragenter: function dragenter(e) {
                return this.element.classList.add('dz-drag-hover')
              },
              dragover: function dragover(e) {
                return this.element.classList.add('dz-drag-hover')
              },
              dragleave: function dragleave(e) {
                return this.element.classList.remove('dz-drag-hover')
              },
              paste: function paste(e) {},
              // Called whenever there are no files left in the dropzone anymore, and the
              // dropzone should be displayed as if in the initial state.
              reset: function reset() {
                return this.element.classList.remove('dz-started')
              },
              // Called when a file is added to the queue
              // Receives `file`
              addedfile: function addedfile(file) {
                var _this = this

                if (this.element === this.previewsContainer) {
                  this.element.classList.add('dz-started')
                }

                if (this.previewsContainer && !this.options.disablePreviews) {
                  file.previewElement = Dropzone.createElement(
                    this.options.previewTemplate.trim()
                  )
                  file.previewTemplate = file.previewElement // Backwards compatibility

                  this.previewsContainer.appendChild(file.previewElement)

                  var _iterator2 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll('[data-dz-name]'),
                      true
                    ),
                    _step2

                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var node = _step2.value
                      node.textContent = file.name
                    }
                  } catch (err) {
                    _iterator2.e(err)
                  } finally {
                    _iterator2.f()
                  }

                  var _iterator3 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll('[data-dz-size]'),
                      true
                    ),
                    _step3

                  try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                      node = _step3.value
                      node.innerHTML = this.filesize(file.size)
                    }
                  } catch (err) {
                    _iterator3.e(err)
                  } finally {
                    _iterator3.f()
                  }

                  if (this.options.addRemoveLinks) {
                    file._removeLink = Dropzone.createElement(
                      '<a class="dz-remove" href="javascript:undefined;" data-dz-remove>'.concat(
                        this.options.dictRemoveFile,
                        '</a>'
                      )
                    )
                    file.previewElement.appendChild(file._removeLink)
                  }

                  var removeFileEvent = function removeFileEvent(e) {
                    e.preventDefault()
                    e.stopPropagation()

                    if (file.status === Dropzone.UPLOADING) {
                      return Dropzone.confirm(
                        _this.options.dictCancelUploadConfirmation,
                        function () {
                          return _this.removeFile(file)
                        }
                      )
                    } else {
                      if (_this.options.dictRemoveFileConfirmation) {
                        return Dropzone.confirm(
                          _this.options.dictRemoveFileConfirmation,
                          function () {
                            return _this.removeFile(file)
                          }
                        )
                      } else {
                        return _this.removeFile(file)
                      }
                    }
                  }

                  var _iterator4 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll('[data-dz-remove]'),
                      true
                    ),
                    _step4

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                      var removeLink = _step4.value
                      removeLink.addEventListener('click', removeFileEvent)
                    }
                  } catch (err) {
                    _iterator4.e(err)
                  } finally {
                    _iterator4.f()
                  }
                }
              },
              // Called whenever a file is removed.
              removedfile: function removedfile(file) {
                if (
                  file.previewElement != null &&
                  file.previewElement.parentNode != null
                ) {
                  file.previewElement.parentNode.removeChild(
                    file.previewElement
                  )
                }

                return this._updateMaxFilesReachedClass()
              },
              // Called when a thumbnail has been generated
              // Receives `file` and `dataUrl`
              thumbnail: function thumbnail(file, dataUrl) {
                if (file.previewElement) {
                  file.previewElement.classList.remove('dz-file-preview')

                  var _iterator5 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll(
                        '[data-dz-thumbnail]'
                      ),
                      true
                    ),
                    _step5

                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                      var thumbnailElement = _step5.value
                      thumbnailElement.alt = file.name
                      thumbnailElement.src = dataUrl
                    }
                  } catch (err) {
                    _iterator5.e(err)
                  } finally {
                    _iterator5.f()
                  }

                  return setTimeout(function () {
                    return file.previewElement.classList.add('dz-image-preview')
                  }, 1)
                }
              },
              // Called whenever an error occurs
              // Receives `file` and `message`
              error: function error(file, message) {
                if (file.previewElement) {
                  file.previewElement.classList.add('dz-error')

                  if (typeof message !== 'string' && message.error) {
                    message = message.error
                  }

                  var _iterator6 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll(
                        '[data-dz-errormessage]'
                      ),
                      true
                    ),
                    _step6

                  try {
                    for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                      var node = _step6.value
                      node.textContent = message
                    }
                  } catch (err) {
                    _iterator6.e(err)
                  } finally {
                    _iterator6.f()
                  }
                }
              },
              errormultiple: function errormultiple() {},
              // Called when a file gets processed. Since there is a cue, not all added
              // files are processed immediately.
              // Receives `file`
              processing: function processing(file) {
                if (file.previewElement) {
                  file.previewElement.classList.add('dz-processing')

                  if (file._removeLink) {
                    return (file._removeLink.innerHTML =
                      this.options.dictCancelUpload)
                  }
                }
              },
              processingmultiple: function processingmultiple() {},
              // Called whenever the upload progress gets updated.
              // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
              // To get the total number of bytes of the file, use `file.size`
              uploadprogress: function uploadprogress(
                file,
                progress,
                bytesSent
              ) {
                if (file.previewElement) {
                  var _iterator7 = options_createForOfIteratorHelper(
                      file.previewElement.querySelectorAll(
                        '[data-dz-uploadprogress]'
                      ),
                      true
                    ),
                    _step7

                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                      var node = _step7.value
                      node.nodeName === 'PROGRESS'
                        ? (node.value = progress)
                        : (node.style.width = ''.concat(progress, '%'))
                    }
                  } catch (err) {
                    _iterator7.e(err)
                  } finally {
                    _iterator7.f()
                  }
                }
              },
              // Called whenever the total upload progress gets updated.
              // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
              totaluploadprogress: function totaluploadprogress() {},
              // Called just before the file is sent. Gets the `xhr` object as second
              // parameter, so you can modify it (for example to add a CSRF token) and a
              // `formData` object to add additional information.
              sending: function sending() {},
              sendingmultiple: function sendingmultiple() {},
              // When the complete upload is finished and successful
              // Receives `file`
              success: function success(file) {
                if (file.previewElement) {
                  return file.previewElement.classList.add('dz-success')
                }
              },
              successmultiple: function successmultiple() {},
              // When the upload is canceled.
              canceled: function canceled(file) {
                return this.emit('error', file, this.options.dictUploadCanceled)
              },
              canceledmultiple: function canceledmultiple() {},
              // When the upload is finished, either with success or an error.
              // Receives `file`
              complete: function complete(file) {
                if (file._removeLink) {
                  file._removeLink.innerHTML = this.options.dictRemoveFile
                }

                if (file.previewElement) {
                  return file.previewElement.classList.add('dz-complete')
                }
              },
              completemultiple: function completemultiple() {},
              maxfilesexceeded: function maxfilesexceeded() {},
              maxfilesreached: function maxfilesreached() {},
              queuecomplete: function queuecomplete() {},
              addedfiles: function addedfiles() {}
            }
            /* harmony default export */ var src_options = defaultOptions // CONCATENATED MODULE: ./src/dropzone.js
            function _typeof(obj) {
              '@babel/helpers - typeof'
              if (
                typeof Symbol === 'function' &&
                typeof Symbol.iterator === 'symbol'
              ) {
                _typeof = function _typeof(obj) {
                  return typeof obj
                }
              } else {
                _typeof = function _typeof(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj
                }
              }
              return _typeof(obj)
            }

            function dropzone_createForOfIteratorHelper(o, allowArrayLike) {
              var it
              if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
                if (
                  Array.isArray(o) ||
                  (it = dropzone_unsupportedIterableToArray(o)) ||
                  (allowArrayLike && o && typeof o.length === 'number')
                ) {
                  if (it) o = it
                  var i = 0
                  var F = function F() {}
                  return {
                    s: F,
                    n: function n() {
                      if (i >= o.length) return { done: true }
                      return { done: false, value: o[i++] }
                    },
                    e: function e(_e) {
                      throw _e
                    },
                    f: F
                  }
                }
                throw new TypeError(
                  'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
                )
              }
              var normalCompletion = true,
                didErr = false,
                err
              return {
                s: function s() {
                  it = o[Symbol.iterator]()
                },
                n: function n() {
                  var step = it.next()
                  normalCompletion = step.done
                  return step
                },
                e: function e(_e2) {
                  didErr = true
                  err = _e2
                },
                f: function f() {
                  try {
                    if (!normalCompletion && it.return != null) it.return()
                  } finally {
                    if (didErr) throw err
                  }
                }
              }
            }

            function dropzone_unsupportedIterableToArray(o, minLen) {
              if (!o) return
              if (typeof o === 'string')
                return dropzone_arrayLikeToArray(o, minLen)
              var n = Object.prototype.toString.call(o).slice(8, -1)
              if (n === 'Object' && o.constructor) n = o.constructor.name
              if (n === 'Map' || n === 'Set') return Array.from(o)
              if (
                n === 'Arguments' ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return dropzone_arrayLikeToArray(o, minLen)
            }

            function dropzone_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i]
              }
              return arr2
            }

            function dropzone_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function')
              }
            }

            function dropzone_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }

            function dropzone_createClass(
              Constructor,
              protoProps,
              staticProps
            ) {
              if (protoProps)
                dropzone_defineProperties(Constructor.prototype, protoProps)
              if (staticProps)
                dropzone_defineProperties(Constructor, staticProps)
              return Constructor
            }

            function _inherits(subClass, superClass) {
              if (typeof superClass !== 'function' && superClass !== null) {
                throw new TypeError(
                  'Super expression must either be null or a function'
                )
              }
              subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                  }
                }
              )
              if (superClass) _setPrototypeOf(subClass, superClass)
            }

            function _setPrototypeOf(o, p) {
              _setPrototypeOf =
                Object.setPrototypeOf ||
                function _setPrototypeOf(o, p) {
                  o.__proto__ = p
                  return o
                }
              return _setPrototypeOf(o, p)
            }

            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct()
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived),
                  result
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor
                  result = Reflect.construct(Super, arguments, NewTarget)
                } else {
                  result = Super.apply(this, arguments)
                }
                return _possibleConstructorReturn(this, result)
              }
            }

            function _possibleConstructorReturn(self, call) {
              if (
                call &&
                (_typeof(call) === 'object' || typeof call === 'function')
              ) {
                return call
              }
              return _assertThisInitialized(self)
            }

            function _assertThisInitialized(self) {
              if (self === void 0) {
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                )
              }
              return self
            }

            function _isNativeReflectConstruct() {
              if (typeof Reflect === 'undefined' || !Reflect.construct)
                return false
              if (Reflect.construct.sham) return false
              if (typeof Proxy === 'function') return true
              try {
                Date.prototype.toString.call(
                  Reflect.construct(Date, [], function () {})
                )
                return true
              } catch (e) {
                return false
              }
            }

            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o)
                  }
              return _getPrototypeOf(o)
            }

            var Dropzone = /*#__PURE__*/ (function (_Emitter) {
              _inherits(Dropzone, _Emitter)

              var _super = _createSuper(Dropzone)

              function Dropzone(el, options) {
                var _this

                dropzone_classCallCheck(this, Dropzone)

                _this = _super.call(this)
                var fallback, left
                _this.element = el // For backwards compatibility since the version was in the prototype previously

                _this.version = Dropzone.version
                _this.clickableElements = []
                _this.listeners = []
                _this.files = [] // All files

                if (typeof _this.element === 'string') {
                  _this.element = document.querySelector(_this.element)
                } // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.

                if (!_this.element || _this.element.nodeType == null) {
                  throw new Error('Invalid dropzone element.')
                }

                if (_this.element.dropzone) {
                  throw new Error('Dropzone already attached.')
                } // Now add this dropzone to the instances.

                Dropzone.instances.push(_assertThisInitialized(_this)) // Put the dropzone inside the element itself.

                _this.element.dropzone = _assertThisInitialized(_this)
                var elementOptions =
                  (left = Dropzone.optionsForElement(_this.element)) != null
                    ? left
                    : {}
                _this.options = Dropzone.extend(
                  {},
                  src_options,
                  elementOptions,
                  options != null ? options : {}
                )
                _this.options.previewTemplate =
                  _this.options.previewTemplate.replace(/\n*/g, '') // If the browser failed, just call the fallback and leave

                if (
                  _this.options.forceFallback ||
                  !Dropzone.isBrowserSupported()
                ) {
                  return _possibleConstructorReturn(
                    _this,
                    _this.options.fallback.call(_assertThisInitialized(_this))
                  )
                } // @options.url = @element.getAttribute "action" unless @options.url?

                if (_this.options.url == null) {
                  _this.options.url = _this.element.getAttribute('action')
                }

                if (!_this.options.url) {
                  throw new Error('No URL provided.')
                }

                if (
                  _this.options.acceptedFiles &&
                  _this.options.acceptedMimeTypes
                ) {
                  throw new Error(
                    "You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated."
                  )
                }

                if (_this.options.uploadMultiple && _this.options.chunking) {
                  throw new Error(
                    'You cannot set both: uploadMultiple and chunking.'
                  )
                } // Backwards compatibility

                if (_this.options.acceptedMimeTypes) {
                  _this.options.acceptedFiles = _this.options.acceptedMimeTypes
                  delete _this.options.acceptedMimeTypes
                } // Backwards compatibility

                if (_this.options.renameFilename != null) {
                  _this.options.renameFile = function (file) {
                    return _this.options.renameFilename.call(
                      _assertThisInitialized(_this),
                      file.name,
                      file
                    )
                  }
                }

                if (typeof _this.options.method === 'string') {
                  _this.options.method = _this.options.method.toUpperCase()
                }

                if (
                  (fallback = _this.getExistingFallback()) &&
                  fallback.parentNode
                ) {
                  // Remove the fallback
                  fallback.parentNode.removeChild(fallback)
                } // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false

                if (_this.options.previewsContainer !== false) {
                  if (_this.options.previewsContainer) {
                    _this.previewsContainer = Dropzone.getElement(
                      _this.options.previewsContainer,
                      'previewsContainer'
                    )
                  } else {
                    _this.previewsContainer = _this.element
                  }
                }

                if (_this.options.clickable) {
                  if (_this.options.clickable === true) {
                    _this.clickableElements = [_this.element]
                  } else {
                    _this.clickableElements = Dropzone.getElements(
                      _this.options.clickable,
                      'clickable'
                    )
                  }
                }

                _this.init()

                return _this
              } // Returns all files that have been accepted

              dropzone_createClass(
                Dropzone,
                [
                  {
                    key: 'getAcceptedFiles',
                    value: function getAcceptedFiles() {
                      return this.files
                        .filter(function (file) {
                          return file.accepted
                        })
                        .map(function (file) {
                          return file
                        })
                    } // Returns all files that have been rejected
                    // Not sure when that's going to be useful, but added for completeness.
                  },
                  {
                    key: 'getRejectedFiles',
                    value: function getRejectedFiles() {
                      return this.files
                        .filter(function (file) {
                          return !file.accepted
                        })
                        .map(function (file) {
                          return file
                        })
                    }
                  },
                  {
                    key: 'getFilesWithStatus',
                    value: function getFilesWithStatus(status) {
                      return this.files
                        .filter(function (file) {
                          return file.status === status
                        })
                        .map(function (file) {
                          return file
                        })
                    } // Returns all files that are in the queue
                  },
                  {
                    key: 'getQueuedFiles',
                    value: function getQueuedFiles() {
                      return this.getFilesWithStatus(Dropzone.QUEUED)
                    }
                  },
                  {
                    key: 'getUploadingFiles',
                    value: function getUploadingFiles() {
                      return this.getFilesWithStatus(Dropzone.UPLOADING)
                    }
                  },
                  {
                    key: 'getAddedFiles',
                    value: function getAddedFiles() {
                      return this.getFilesWithStatus(Dropzone.ADDED)
                    } // Files that are either queued or uploading
                  },
                  {
                    key: 'getActiveFiles',
                    value: function getActiveFiles() {
                      return this.files
                        .filter(function (file) {
                          return (
                            file.status === Dropzone.UPLOADING ||
                            file.status === Dropzone.QUEUED
                          )
                        })
                        .map(function (file) {
                          return file
                        })
                    } // The function that gets called when Dropzone is initialized. You
                    // can (and should) setup event listeners inside this function.
                  },
                  {
                    key: 'init',
                    value: function init() {
                      var _this2 = this

                      // In case it isn't set already
                      if (this.element.tagName === 'form') {
                        this.element.setAttribute(
                          'enctype',
                          'multipart/form-data'
                        )
                      }

                      if (
                        this.element.classList.contains('dropzone') &&
                        !this.element.querySelector('.dz-message')
                      ) {
                        this.element.appendChild(
                          Dropzone.createElement(
                            '<div class="dz-default dz-message"><button class="dz-button" type="button">'.concat(
                              this.options.dictDefaultMessage,
                              '</button></div>'
                            )
                          )
                        )
                      }

                      if (this.clickableElements.length) {
                        var setupHiddenFileInput =
                          function setupHiddenFileInput() {
                            if (_this2.hiddenFileInput) {
                              _this2.hiddenFileInput.parentNode.removeChild(
                                _this2.hiddenFileInput
                              )
                            }

                            _this2.hiddenFileInput =
                              document.createElement('input')

                            _this2.hiddenFileInput.setAttribute('type', 'file')

                            if (
                              _this2.options.maxFiles === null ||
                              _this2.options.maxFiles > 1
                            ) {
                              _this2.hiddenFileInput.setAttribute(
                                'multiple',
                                'multiple'
                              )
                            }

                            _this2.hiddenFileInput.className = 'dz-hidden-input'

                            if (_this2.options.acceptedFiles !== null) {
                              _this2.hiddenFileInput.setAttribute(
                                'accept',
                                _this2.options.acceptedFiles
                              )
                            }

                            if (_this2.options.capture !== null) {
                              _this2.hiddenFileInput.setAttribute(
                                'capture',
                                _this2.options.capture
                              )
                            } // Making sure that no one can "tab" into this field.

                            _this2.hiddenFileInput.setAttribute(
                              'tabindex',
                              '-1'
                            ) // Not setting `display="none"` because some browsers don't accept clicks
                            // on elements that aren't displayed.

                            _this2.hiddenFileInput.style.visibility = 'hidden'
                            _this2.hiddenFileInput.style.position = 'absolute'
                            _this2.hiddenFileInput.style.top = '0'
                            _this2.hiddenFileInput.style.left = '0'
                            _this2.hiddenFileInput.style.height = '0'
                            _this2.hiddenFileInput.style.width = '0'
                            Dropzone.getElement(
                              _this2.options.hiddenInputContainer,
                              'hiddenInputContainer'
                            ).appendChild(_this2.hiddenFileInput)

                            _this2.hiddenFileInput.addEventListener(
                              'change',
                              function () {
                                var files = _this2.hiddenFileInput.files

                                if (files.length) {
                                  var _iterator =
                                      dropzone_createForOfIteratorHelper(
                                        files,
                                        true
                                      ),
                                    _step

                                  try {
                                    for (
                                      _iterator.s();
                                      !(_step = _iterator.n()).done;

                                    ) {
                                      var file = _step.value

                                      _this2.addFile(file)
                                    }
                                  } catch (err) {
                                    _iterator.e(err)
                                  } finally {
                                    _iterator.f()
                                  }
                                }

                                _this2.emit('addedfiles', files)

                                setupHiddenFileInput()
                              }
                            )
                          }

                        setupHiddenFileInput()
                      }

                      this.URL =
                        window.URL !== null ? window.URL : window.webkitURL // Setup all event listeners on the Dropzone object itself.
                      // They're not in @setupEventListeners() because they shouldn't be removed
                      // again when the dropzone gets disabled.

                      var _iterator2 = dropzone_createForOfIteratorHelper(
                          this.events,
                          true
                        ),
                        _step2

                      try {
                        for (
                          _iterator2.s();
                          !(_step2 = _iterator2.n()).done;

                        ) {
                          var eventName = _step2.value
                          this.on(eventName, this.options[eventName])
                        }
                      } catch (err) {
                        _iterator2.e(err)
                      } finally {
                        _iterator2.f()
                      }

                      this.on('uploadprogress', function () {
                        return _this2.updateTotalUploadProgress()
                      })
                      this.on('removedfile', function () {
                        return _this2.updateTotalUploadProgress()
                      })
                      this.on('canceled', function (file) {
                        return _this2.emit('complete', file)
                      }) // Emit a `queuecomplete` event if all files finished uploading.

                      this.on('complete', function (file) {
                        if (
                          _this2.getAddedFiles().length === 0 &&
                          _this2.getUploadingFiles().length === 0 &&
                          _this2.getQueuedFiles().length === 0
                        ) {
                          // This needs to be deferred so that `queuecomplete` really triggers after `complete`
                          return setTimeout(function () {
                            return _this2.emit('queuecomplete')
                          }, 0)
                        }
                      })

                      var containsFiles = function containsFiles(e) {
                        if (e.dataTransfer.types) {
                          // Because e.dataTransfer.types is an Object in
                          // IE, we need to iterate like this instead of
                          // using e.dataTransfer.types.some()
                          for (
                            var i = 0;
                            i < e.dataTransfer.types.length;
                            i++
                          ) {
                            if (e.dataTransfer.types[i] === 'Files') return true
                          }
                        }

                        return false
                      }

                      var noPropagation = function noPropagation(e) {
                        // If there are no files, we don't want to stop
                        // propagation so we don't interfere with other
                        // drag and drop behaviour.
                        if (!containsFiles(e)) return
                        e.stopPropagation()

                        if (e.preventDefault) {
                          return e.preventDefault()
                        } else {
                          return (e.returnValue = false)
                        }
                      } // Create the listeners

                      this.listeners = [
                        {
                          element: this.element,
                          events: {
                            dragstart: function dragstart(e) {
                              return _this2.emit('dragstart', e)
                            },
                            dragenter: function dragenter(e) {
                              noPropagation(e)
                              return _this2.emit('dragenter', e)
                            },
                            dragover: function dragover(e) {
                              // Makes it possible to drag files from chrome's download bar
                              // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                              // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                              var efct

                              try {
                                efct = e.dataTransfer.effectAllowed
                              } catch (error) {}

                              e.dataTransfer.dropEffect =
                                'move' === efct || 'linkMove' === efct
                                  ? 'move'
                                  : 'copy'
                              noPropagation(e)
                              return _this2.emit('dragover', e)
                            },
                            dragleave: function dragleave(e) {
                              return _this2.emit('dragleave', e)
                            },
                            drop: function drop(e) {
                              noPropagation(e)
                              return _this2.drop(e)
                            },
                            dragend: function dragend(e) {
                              return _this2.emit('dragend', e)
                            }
                          } // This is disabled right now, because the browsers don't implement it properly.
                          // "paste": (e) =>
                          //   noPropagation e
                          //   @paste e
                        }
                      ]
                      this.clickableElements.forEach(
                        function (clickableElement) {
                          return _this2.listeners.push({
                            element: clickableElement,
                            events: {
                              click: function click(evt) {
                                // Only the actual dropzone or the message element should trigger file selection
                                if (
                                  clickableElement !== _this2.element ||
                                  evt.target === _this2.element ||
                                  Dropzone.elementInside(
                                    evt.target,
                                    _this2.element.querySelector('.dz-message')
                                  )
                                ) {
                                  _this2.hiddenFileInput.click() // Forward the click
                                }

                                return true
                              }
                            }
                          })
                        }
                      )
                      this.enable()
                      return this.options.init.call(this)
                    } // Not fully tested yet
                  },
                  {
                    key: 'destroy',
                    value: function destroy() {
                      this.disable()
                      this.removeAllFiles(true)

                      if (
                        this.hiddenFileInput != null
                          ? this.hiddenFileInput.parentNode
                          : undefined
                      ) {
                        this.hiddenFileInput.parentNode.removeChild(
                          this.hiddenFileInput
                        )
                        this.hiddenFileInput = null
                      }

                      delete this.element.dropzone
                      return Dropzone.instances.splice(
                        Dropzone.instances.indexOf(this),
                        1
                      )
                    }
                  },
                  {
                    key: 'updateTotalUploadProgress',
                    value: function updateTotalUploadProgress() {
                      var totalUploadProgress
                      var totalBytesSent = 0
                      var totalBytes = 0
                      var activeFiles = this.getActiveFiles()

                      if (activeFiles.length) {
                        var _iterator3 = dropzone_createForOfIteratorHelper(
                            this.getActiveFiles(),
                            true
                          ),
                          _step3

                        try {
                          for (
                            _iterator3.s();
                            !(_step3 = _iterator3.n()).done;

                          ) {
                            var file = _step3.value
                            totalBytesSent += file.upload.bytesSent
                            totalBytes += file.upload.total
                          }
                        } catch (err) {
                          _iterator3.e(err)
                        } finally {
                          _iterator3.f()
                        }

                        totalUploadProgress =
                          (100 * totalBytesSent) / totalBytes
                      } else {
                        totalUploadProgress = 100
                      }

                      return this.emit(
                        'totaluploadprogress',
                        totalUploadProgress,
                        totalBytes,
                        totalBytesSent
                      )
                    } // @options.paramName can be a function taking one parameter rather than a string.
                    // A parameter name for a file is obtained simply by calling this with an index number.
                  },
                  {
                    key: '_getParamName',
                    value: function _getParamName(n) {
                      if (typeof this.options.paramName === 'function') {
                        return this.options.paramName(n)
                      } else {
                        return ''
                          .concat(this.options.paramName)
                          .concat(
                            this.options.uploadMultiple
                              ? '['.concat(n, ']')
                              : ''
                          )
                      }
                    } // If @options.renameFile is a function,
                    // the function will be used to rename the file.name before appending it to the formData
                  },
                  {
                    key: '_renameFile',
                    value: function _renameFile(file) {
                      if (typeof this.options.renameFile !== 'function') {
                        return file.name
                      }

                      return this.options.renameFile(file)
                    } // Returns a form that can be used as fallback if the browser does not support DragnDrop
                    //
                    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
                    // This code has to pass in IE7 :(
                  },
                  {
                    key: 'getFallbackForm',
                    value: function getFallbackForm() {
                      var existingFallback, form

                      if ((existingFallback = this.getExistingFallback())) {
                        return existingFallback
                      }

                      var fieldsString = '<div class="dz-fallback">'

                      if (this.options.dictFallbackText) {
                        fieldsString += '<p>'.concat(
                          this.options.dictFallbackText,
                          '</p>'
                        )
                      }

                      fieldsString += '<input type="file" name="'
                        .concat(this._getParamName(0), '" ')
                        .concat(
                          this.options.uploadMultiple
                            ? 'multiple="multiple"'
                            : undefined,
                          ' /><input type="submit" value="Upload!"></div>'
                        )
                      var fields = Dropzone.createElement(fieldsString)

                      if (this.element.tagName !== 'FORM') {
                        form = Dropzone.createElement(
                          '<form action="'
                            .concat(
                              this.options.url,
                              '" enctype="multipart/form-data" method="'
                            )
                            .concat(this.options.method, '"></form>')
                        )
                        form.appendChild(fields)
                      } else {
                        // Make sure that the enctype and method attributes are set properly
                        this.element.setAttribute(
                          'enctype',
                          'multipart/form-data'
                        )
                        this.element.setAttribute('method', this.options.method)
                      }

                      return form != null ? form : fields
                    } // Returns the fallback elements if they exist already
                    //
                    // This code has to pass in IE7 :(
                  },
                  {
                    key: 'getExistingFallback',
                    value: function getExistingFallback() {
                      var getFallback = function getFallback(elements) {
                        var _iterator4 = dropzone_createForOfIteratorHelper(
                            elements,
                            true
                          ),
                          _step4

                        try {
                          for (
                            _iterator4.s();
                            !(_step4 = _iterator4.n()).done;

                          ) {
                            var el = _step4.value

                            if (/(^| )fallback($| )/.test(el.className)) {
                              return el
                            }
                          }
                        } catch (err) {
                          _iterator4.e(err)
                        } finally {
                          _iterator4.f()
                        }
                      }

                      for (
                        var _i = 0, _arr = ['div', 'form'];
                        _i < _arr.length;
                        _i++
                      ) {
                        var tagName = _arr[_i]
                        var fallback

                        if (
                          (fallback = getFallback(
                            this.element.getElementsByTagName(tagName)
                          ))
                        ) {
                          return fallback
                        }
                      }
                    } // Activates all listeners stored in @listeners
                  },
                  {
                    key: 'setupEventListeners',
                    value: function setupEventListeners() {
                      return this.listeners.map(function (elementListeners) {
                        return (function () {
                          var result = []

                          for (var event in elementListeners.events) {
                            var listener = elementListeners.events[event]
                            result.push(
                              elementListeners.element.addEventListener(
                                event,
                                listener,
                                false
                              )
                            )
                          }

                          return result
                        })()
                      })
                    } // Deactivates all listeners stored in @listeners
                  },
                  {
                    key: 'removeEventListeners',
                    value: function removeEventListeners() {
                      return this.listeners.map(function (elementListeners) {
                        return (function () {
                          var result = []

                          for (var event in elementListeners.events) {
                            var listener = elementListeners.events[event]
                            result.push(
                              elementListeners.element.removeEventListener(
                                event,
                                listener,
                                false
                              )
                            )
                          }

                          return result
                        })()
                      })
                    } // Removes all event listeners and cancels all files in the queue or being processed.
                  },
                  {
                    key: 'disable',
                    value: function disable() {
                      var _this3 = this

                      this.clickableElements.forEach(function (element) {
                        return element.classList.remove('dz-clickable')
                      })
                      this.removeEventListeners()
                      this.disabled = true
                      return this.files.map(function (file) {
                        return _this3.cancelUpload(file)
                      })
                    }
                  },
                  {
                    key: 'enable',
                    value: function enable() {
                      delete this.disabled
                      this.clickableElements.forEach(function (element) {
                        return element.classList.add('dz-clickable')
                      })
                      return this.setupEventListeners()
                    } // Returns a nicely formatted filesize
                  },
                  {
                    key: 'filesize',
                    value: function filesize(size) {
                      var selectedSize = 0
                      var selectedUnit = 'b'

                      if (size > 0) {
                        var units = ['tb', 'gb', 'mb', 'kb', 'b']

                        for (var i = 0; i < units.length; i++) {
                          var unit = units[i]
                          var cutoff =
                            Math.pow(this.options.filesizeBase, 4 - i) / 10

                          if (size >= cutoff) {
                            selectedSize =
                              size / Math.pow(this.options.filesizeBase, 4 - i)
                            selectedUnit = unit
                            break
                          }
                        }

                        selectedSize = Math.round(10 * selectedSize) / 10 // Cutting of digits
                      }

                      return '<strong>'
                        .concat(selectedSize, '</strong> ')
                        .concat(this.options.dictFileSizeUnits[selectedUnit])
                    } // Adds or removes the `dz-max-files-reached` class from the form.
                  },
                  {
                    key: '_updateMaxFilesReachedClass',
                    value: function _updateMaxFilesReachedClass() {
                      if (
                        this.options.maxFiles != null &&
                        this.getAcceptedFiles().length >= this.options.maxFiles
                      ) {
                        if (
                          this.getAcceptedFiles().length ===
                          this.options.maxFiles
                        ) {
                          this.emit('maxfilesreached', this.files)
                        }

                        return this.element.classList.add(
                          'dz-max-files-reached'
                        )
                      } else {
                        return this.element.classList.remove(
                          'dz-max-files-reached'
                        )
                      }
                    }
                  },
                  {
                    key: 'drop',
                    value: function drop(e) {
                      if (!e.dataTransfer) {
                        return
                      }

                      this.emit('drop', e) // Convert the FileList to an Array
                      // This is necessary for IE11

                      var files = []

                      for (var i = 0; i < e.dataTransfer.files.length; i++) {
                        files[i] = e.dataTransfer.files[i]
                      } // Even if it's a folder, files.length will contain the folders.

                      if (files.length) {
                        var items = e.dataTransfer.items

                        if (
                          items &&
                          items.length &&
                          items[0].webkitGetAsEntry != null
                        ) {
                          // The browser supports dropping of folders, so handle items instead of files
                          this._addFilesFromItems(items)
                        } else {
                          this.handleFiles(files)
                        }
                      }

                      this.emit('addedfiles', files)
                    }
                  },
                  {
                    key: 'paste',
                    value: function paste(e) {
                      if (
                        __guard__(
                          e != null ? e.clipboardData : undefined,
                          function (x) {
                            return x.items
                          }
                        ) == null
                      ) {
                        return
                      }

                      this.emit('paste', e)
                      var items = e.clipboardData.items

                      if (items.length) {
                        return this._addFilesFromItems(items)
                      }
                    }
                  },
                  {
                    key: 'handleFiles',
                    value: function handleFiles(files) {
                      var _iterator5 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step5

                      try {
                        for (
                          _iterator5.s();
                          !(_step5 = _iterator5.n()).done;

                        ) {
                          var file = _step5.value
                          this.addFile(file)
                        }
                      } catch (err) {
                        _iterator5.e(err)
                      } finally {
                        _iterator5.f()
                      }
                    } // When a folder is dropped (or files are pasted), items must be handled
                    // instead of files.
                  },
                  {
                    key: '_addFilesFromItems',
                    value: function _addFilesFromItems(items) {
                      var _this4 = this

                      return (function () {
                        var result = []

                        var _iterator6 = dropzone_createForOfIteratorHelper(
                            items,
                            true
                          ),
                          _step6

                        try {
                          for (
                            _iterator6.s();
                            !(_step6 = _iterator6.n()).done;

                          ) {
                            var item = _step6.value
                            var entry

                            if (
                              item.webkitGetAsEntry != null &&
                              (entry = item.webkitGetAsEntry())
                            ) {
                              if (entry.isFile) {
                                result.push(_this4.addFile(item.getAsFile()))
                              } else if (entry.isDirectory) {
                                // Append all files from that directory to files
                                result.push(
                                  _this4._addFilesFromDirectory(
                                    entry,
                                    entry.name
                                  )
                                )
                              } else {
                                result.push(undefined)
                              }
                            } else if (item.getAsFile != null) {
                              if (item.kind == null || item.kind === 'file') {
                                result.push(_this4.addFile(item.getAsFile()))
                              } else {
                                result.push(undefined)
                              }
                            } else {
                              result.push(undefined)
                            }
                          }
                        } catch (err) {
                          _iterator6.e(err)
                        } finally {
                          _iterator6.f()
                        }

                        return result
                      })()
                    } // Goes through the directory, and adds each file it finds recursively
                  },
                  {
                    key: '_addFilesFromDirectory',
                    value: function _addFilesFromDirectory(directory, path) {
                      var _this5 = this

                      var dirReader = directory.createReader()

                      var errorHandler = function errorHandler(error) {
                        return __guardMethod__(console, 'log', function (o) {
                          return o.log(error)
                        })
                      }

                      var readEntries = function readEntries() {
                        return dirReader.readEntries(function (entries) {
                          if (entries.length > 0) {
                            var _iterator7 = dropzone_createForOfIteratorHelper(
                                entries,
                                true
                              ),
                              _step7

                            try {
                              for (
                                _iterator7.s();
                                !(_step7 = _iterator7.n()).done;

                              ) {
                                var entry = _step7.value

                                if (entry.isFile) {
                                  entry.file(function (file) {
                                    if (
                                      _this5.options.ignoreHiddenFiles &&
                                      file.name.substring(0, 1) === '.'
                                    ) {
                                      return
                                    }

                                    file.fullPath = ''
                                      .concat(path, '/')
                                      .concat(file.name)
                                    return _this5.addFile(file)
                                  })
                                } else if (entry.isDirectory) {
                                  _this5._addFilesFromDirectory(
                                    entry,
                                    ''.concat(path, '/').concat(entry.name)
                                  )
                                }
                              } // Recursively call readEntries() again, since browser only handle
                              // the first 100 entries.
                              // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                            } catch (err) {
                              _iterator7.e(err)
                            } finally {
                              _iterator7.f()
                            }

                            readEntries()
                          }

                          return null
                        }, errorHandler)
                      }

                      return readEntries()
                    } // If `done()` is called without argument the file is accepted
                    // If you call it with an error message, the file is rejected
                    // (This allows for asynchronous validation)
                    //
                    // This function checks the filesize, and if the file.type passes the
                    // `acceptedFiles` check.
                  },
                  {
                    key: 'accept',
                    value: function accept(file, done) {
                      if (
                        this.options.maxFilesize &&
                        file.size > this.options.maxFilesize * 1024 * 1024
                      ) {
                        done(
                          this.options.dictFileTooBig
                            .replace(
                              '{{filesize}}',
                              Math.round(file.size / 1024 / 10.24) / 100
                            )
                            .replace(
                              '{{maxFilesize}}',
                              this.options.maxFilesize
                            )
                        )
                      } else if (
                        !Dropzone.isValidFile(file, this.options.acceptedFiles)
                      ) {
                        done(this.options.dictInvalidFileType)
                      } else if (
                        this.options.maxFiles != null &&
                        this.getAcceptedFiles().length >= this.options.maxFiles
                      ) {
                        done(
                          this.options.dictMaxFilesExceeded.replace(
                            '{{maxFiles}}',
                            this.options.maxFiles
                          )
                        )
                        this.emit('maxfilesexceeded', file)
                      } else {
                        this.options.accept.call(this, file, done)
                      }
                    }
                  },
                  {
                    key: 'addFile',
                    value: function addFile(file) {
                      var _this6 = this

                      file.upload = {
                        uuid: Dropzone.uuidv4(),
                        progress: 0,
                        // Setting the total upload size to file.size for the beginning
                        // It's actual different than the size to be transmitted.
                        total: file.size,
                        bytesSent: 0,
                        filename: this._renameFile(file) // Not setting chunking information here, because the acutal data — and
                        // thus the chunks — might change if `options.transformFile` is set
                        // and does something to the data.
                      }
                      this.files.push(file)
                      file.status = Dropzone.ADDED
                      this.emit('addedfile', file)

                      this._enqueueThumbnail(file)

                      this.accept(file, function (error) {
                        if (error) {
                          file.accepted = false

                          _this6._errorProcessing([file], error) // Will set the file.status
                        } else {
                          file.accepted = true

                          if (_this6.options.autoQueue) {
                            _this6.enqueueFile(file)
                          } // Will set .accepted = true
                        }

                        _this6._updateMaxFilesReachedClass()
                      })
                    } // Wrapper for enqueueFile
                  },
                  {
                    key: 'enqueueFiles',
                    value: function enqueueFiles(files) {
                      var _iterator8 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step8

                      try {
                        for (
                          _iterator8.s();
                          !(_step8 = _iterator8.n()).done;

                        ) {
                          var file = _step8.value
                          this.enqueueFile(file)
                        }
                      } catch (err) {
                        _iterator8.e(err)
                      } finally {
                        _iterator8.f()
                      }

                      return null
                    }
                  },
                  {
                    key: 'enqueueFile',
                    value: function enqueueFile(file) {
                      var _this7 = this

                      if (
                        file.status === Dropzone.ADDED &&
                        file.accepted === true
                      ) {
                        file.status = Dropzone.QUEUED

                        if (this.options.autoProcessQueue) {
                          return setTimeout(function () {
                            return _this7.processQueue()
                          }, 0) // Deferring the call
                        }
                      } else {
                        throw new Error(
                          "This file can't be queued because it has already been processed or was rejected."
                        )
                      }
                    }
                  },
                  {
                    key: '_enqueueThumbnail',
                    value: function _enqueueThumbnail(file) {
                      var _this8 = this

                      if (
                        this.options.createImageThumbnails &&
                        file.type.match(/image.*/) &&
                        file.size <=
                          this.options.maxThumbnailFilesize * 1024 * 1024
                      ) {
                        this._thumbnailQueue.push(file)

                        return setTimeout(function () {
                          return _this8._processThumbnailQueue()
                        }, 0) // Deferring the call
                      }
                    }
                  },
                  {
                    key: '_processThumbnailQueue',
                    value: function _processThumbnailQueue() {
                      var _this9 = this

                      if (
                        this._processingThumbnail ||
                        this._thumbnailQueue.length === 0
                      ) {
                        return
                      }

                      this._processingThumbnail = true

                      var file = this._thumbnailQueue.shift()

                      return this.createThumbnail(
                        file,
                        this.options.thumbnailWidth,
                        this.options.thumbnailHeight,
                        this.options.thumbnailMethod,
                        true,
                        function (dataUrl) {
                          _this9.emit('thumbnail', file, dataUrl)

                          _this9._processingThumbnail = false
                          return _this9._processThumbnailQueue()
                        }
                      )
                    } // Can be called by the user to remove a file
                  },
                  {
                    key: 'removeFile',
                    value: function removeFile(file) {
                      if (file.status === Dropzone.UPLOADING) {
                        this.cancelUpload(file)
                      }

                      this.files = without(this.files, file)
                      this.emit('removedfile', file)

                      if (this.files.length === 0) {
                        return this.emit('reset')
                      }
                    } // Removes all files that aren't currently processed from the list
                  },
                  {
                    key: 'removeAllFiles',
                    value: function removeAllFiles(cancelIfNecessary) {
                      // Create a copy of files since removeFile() changes the @files array.
                      if (cancelIfNecessary == null) {
                        cancelIfNecessary = false
                      }

                      var _iterator9 = dropzone_createForOfIteratorHelper(
                          this.files.slice(),
                          true
                        ),
                        _step9

                      try {
                        for (
                          _iterator9.s();
                          !(_step9 = _iterator9.n()).done;

                        ) {
                          var file = _step9.value

                          if (
                            file.status !== Dropzone.UPLOADING ||
                            cancelIfNecessary
                          ) {
                            this.removeFile(file)
                          }
                        }
                      } catch (err) {
                        _iterator9.e(err)
                      } finally {
                        _iterator9.f()
                      }

                      return null
                    } // Resizes an image before it gets sent to the server. This function is the default behavior of
                    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
                    // the resized blob.
                  },
                  {
                    key: 'resizeImage',
                    value: function resizeImage(
                      file,
                      width,
                      height,
                      resizeMethod,
                      callback
                    ) {
                      var _this10 = this

                      return this.createThumbnail(
                        file,
                        width,
                        height,
                        resizeMethod,
                        true,
                        function (dataUrl, canvas) {
                          if (canvas == null) {
                            // The image has not been resized
                            return callback(file)
                          } else {
                            var resizeMimeType = _this10.options.resizeMimeType

                            if (resizeMimeType == null) {
                              resizeMimeType = file.type
                            }

                            var resizedDataURL = canvas.toDataURL(
                              resizeMimeType,
                              _this10.options.resizeQuality
                            )

                            if (
                              resizeMimeType === 'image/jpeg' ||
                              resizeMimeType === 'image/jpg'
                            ) {
                              // Now add the original EXIF information
                              resizedDataURL = ExifRestore.restore(
                                file.dataURL,
                                resizedDataURL
                              )
                            }

                            return callback(
                              Dropzone.dataURItoBlob(resizedDataURL)
                            )
                          }
                        }
                      )
                    }
                  },
                  {
                    key: 'createThumbnail',
                    value: function createThumbnail(
                      file,
                      width,
                      height,
                      resizeMethod,
                      fixOrientation,
                      callback
                    ) {
                      var _this11 = this

                      var fileReader = new FileReader()

                      fileReader.onload = function () {
                        file.dataURL = fileReader.result // Don't bother creating a thumbnail for SVG images since they're vector

                        if (file.type === 'image/svg+xml') {
                          if (callback != null) {
                            callback(fileReader.result)
                          }

                          return
                        }

                        _this11.createThumbnailFromUrl(
                          file,
                          width,
                          height,
                          resizeMethod,
                          fixOrientation,
                          callback
                        )
                      }

                      fileReader.readAsDataURL(file)
                    } // `mockFile` needs to have these attributes:
                    //
                    //     { name: 'name', size: 12345, imageUrl: '' }
                    //
                    // `callback` will be invoked when the image has been downloaded and displayed.
                    // `crossOrigin` will be added to the `img` tag when accessing the file.
                  },
                  {
                    key: 'displayExistingFile',
                    value: function displayExistingFile(
                      mockFile,
                      imageUrl,
                      callback,
                      crossOrigin
                    ) {
                      var _this12 = this

                      var resizeThumbnail =
                        arguments.length > 4 && arguments[4] !== undefined
                          ? arguments[4]
                          : true
                      this.emit('addedfile', mockFile)
                      this.emit('complete', mockFile)

                      if (!resizeThumbnail) {
                        this.emit('thumbnail', mockFile, imageUrl)
                        if (callback) callback()
                      } else {
                        var onDone = function onDone(thumbnail) {
                          _this12.emit('thumbnail', mockFile, thumbnail)

                          if (callback) callback()
                        }

                        mockFile.dataURL = imageUrl
                        this.createThumbnailFromUrl(
                          mockFile,
                          this.options.thumbnailWidth,
                          this.options.thumbnailHeight,
                          this.options.thumbnailMethod,
                          this.options.fixOrientation,
                          onDone,
                          crossOrigin
                        )
                      }
                    }
                  },
                  {
                    key: 'createThumbnailFromUrl',
                    value: function createThumbnailFromUrl(
                      file,
                      width,
                      height,
                      resizeMethod,
                      fixOrientation,
                      callback,
                      crossOrigin
                    ) {
                      var _this13 = this

                      // Not using `new Image` here because of a bug in latest Chrome versions.
                      // See https://github.com/enyo/dropzone/pull/226
                      var img = document.createElement('img')

                      if (crossOrigin) {
                        img.crossOrigin = crossOrigin
                      } // fixOrientation is not needed anymore with browsers handling imageOrientation

                      fixOrientation =
                        getComputedStyle(document.body)['imageOrientation'] ==
                        'from-image'
                          ? false
                          : fixOrientation

                      img.onload = function () {
                        var loadExif = function loadExif(callback) {
                          return callback(1)
                        }

                        if (
                          typeof EXIF !== 'undefined' &&
                          EXIF !== null &&
                          fixOrientation
                        ) {
                          loadExif = function loadExif(callback) {
                            return EXIF.getData(img, function () {
                              return callback(EXIF.getTag(this, 'Orientation'))
                            })
                          }
                        }

                        return loadExif(function (orientation) {
                          file.width = img.width
                          file.height = img.height

                          var resizeInfo = _this13.options.resize.call(
                            _this13,
                            file,
                            width,
                            height,
                            resizeMethod
                          )

                          var canvas = document.createElement('canvas')
                          var ctx = canvas.getContext('2d')
                          canvas.width = resizeInfo.trgWidth
                          canvas.height = resizeInfo.trgHeight

                          if (orientation > 4) {
                            canvas.width = resizeInfo.trgHeight
                            canvas.height = resizeInfo.trgWidth
                          }

                          switch (orientation) {
                            case 2:
                              // horizontal flip
                              ctx.translate(canvas.width, 0)
                              ctx.scale(-1, 1)
                              break

                            case 3:
                              // 180° rotate left
                              ctx.translate(canvas.width, canvas.height)
                              ctx.rotate(Math.PI)
                              break

                            case 4:
                              // vertical flip
                              ctx.translate(0, canvas.height)
                              ctx.scale(1, -1)
                              break

                            case 5:
                              // vertical flip + 90 rotate right
                              ctx.rotate(0.5 * Math.PI)
                              ctx.scale(1, -1)
                              break

                            case 6:
                              // 90° rotate right
                              ctx.rotate(0.5 * Math.PI)
                              ctx.translate(0, -canvas.width)
                              break

                            case 7:
                              // horizontal flip + 90 rotate right
                              ctx.rotate(0.5 * Math.PI)
                              ctx.translate(canvas.height, -canvas.width)
                              ctx.scale(-1, 1)
                              break

                            case 8:
                              // 90° rotate left
                              ctx.rotate(-0.5 * Math.PI)
                              ctx.translate(-canvas.height, 0)
                              break
                          } // This is a bugfix for iOS' scaling bug.

                          drawImageIOSFix(
                            ctx,
                            img,
                            resizeInfo.srcX != null ? resizeInfo.srcX : 0,
                            resizeInfo.srcY != null ? resizeInfo.srcY : 0,
                            resizeInfo.srcWidth,
                            resizeInfo.srcHeight,
                            resizeInfo.trgX != null ? resizeInfo.trgX : 0,
                            resizeInfo.trgY != null ? resizeInfo.trgY : 0,
                            resizeInfo.trgWidth,
                            resizeInfo.trgHeight
                          )
                          var thumbnail = canvas.toDataURL('image/png')

                          if (callback != null) {
                            return callback(thumbnail, canvas)
                          }
                        })
                      }

                      if (callback != null) {
                        img.onerror = callback
                      }

                      return (img.src = file.dataURL)
                    } // Goes through the queue and processes files if there aren't too many already.
                  },
                  {
                    key: 'processQueue',
                    value: function processQueue() {
                      var parallelUploads = this.options.parallelUploads
                      var processingLength = this.getUploadingFiles().length
                      var i = processingLength // There are already at least as many files uploading than should be

                      if (processingLength >= parallelUploads) {
                        return
                      }

                      var queuedFiles = this.getQueuedFiles()

                      if (!(queuedFiles.length > 0)) {
                        return
                      }

                      if (this.options.uploadMultiple) {
                        // The files should be uploaded in one request
                        return this.processFiles(
                          queuedFiles.slice(
                            0,
                            parallelUploads - processingLength
                          )
                        )
                      } else {
                        while (i < parallelUploads) {
                          if (!queuedFiles.length) {
                            return
                          } // Nothing left to process

                          this.processFile(queuedFiles.shift())
                          i++
                        }
                      }
                    } // Wrapper for `processFiles`
                  },
                  {
                    key: 'processFile',
                    value: function processFile(file) {
                      return this.processFiles([file])
                    } // Loads the file, then calls finishedLoading()
                  },
                  {
                    key: 'processFiles',
                    value: function processFiles(files) {
                      var _iterator10 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step10

                      try {
                        for (
                          _iterator10.s();
                          !(_step10 = _iterator10.n()).done;

                        ) {
                          var file = _step10.value
                          file.processing = true // Backwards compatibility

                          file.status = Dropzone.UPLOADING
                          this.emit('processing', file)
                        }
                      } catch (err) {
                        _iterator10.e(err)
                      } finally {
                        _iterator10.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('processingmultiple', files)
                      }

                      return this.uploadFiles(files)
                    }
                  },
                  {
                    key: '_getFilesWithXhr',
                    value: function _getFilesWithXhr(xhr) {
                      var files
                      return (files = this.files
                        .filter(function (file) {
                          return file.xhr === xhr
                        })
                        .map(function (file) {
                          return file
                        }))
                    } // Cancels the file upload and sets the status to CANCELED
                    // **if** the file is actually being uploaded.
                    // If it's still in the queue, the file is being removed from it and the status
                    // set to CANCELED.
                  },
                  {
                    key: 'cancelUpload',
                    value: function cancelUpload(file) {
                      if (file.status === Dropzone.UPLOADING) {
                        var groupedFiles = this._getFilesWithXhr(file.xhr)

                        var _iterator11 = dropzone_createForOfIteratorHelper(
                            groupedFiles,
                            true
                          ),
                          _step11

                        try {
                          for (
                            _iterator11.s();
                            !(_step11 = _iterator11.n()).done;

                          ) {
                            var groupedFile = _step11.value
                            groupedFile.status = Dropzone.CANCELED
                          }
                        } catch (err) {
                          _iterator11.e(err)
                        } finally {
                          _iterator11.f()
                        }

                        if (typeof file.xhr !== 'undefined') {
                          file.xhr.abort()
                        }

                        var _iterator12 = dropzone_createForOfIteratorHelper(
                            groupedFiles,
                            true
                          ),
                          _step12

                        try {
                          for (
                            _iterator12.s();
                            !(_step12 = _iterator12.n()).done;

                          ) {
                            var _groupedFile = _step12.value
                            this.emit('canceled', _groupedFile)
                          }
                        } catch (err) {
                          _iterator12.e(err)
                        } finally {
                          _iterator12.f()
                        }

                        if (this.options.uploadMultiple) {
                          this.emit('canceledmultiple', groupedFiles)
                        }
                      } else if (
                        file.status === Dropzone.ADDED ||
                        file.status === Dropzone.QUEUED
                      ) {
                        file.status = Dropzone.CANCELED
                        this.emit('canceled', file)

                        if (this.options.uploadMultiple) {
                          this.emit('canceledmultiple', [file])
                        }
                      }

                      if (this.options.autoProcessQueue) {
                        return this.processQueue()
                      }
                    }
                  },
                  {
                    key: 'resolveOption',
                    value: function resolveOption(option) {
                      if (typeof option === 'function') {
                        for (
                          var _len = arguments.length,
                            args = new Array(_len > 1 ? _len - 1 : 0),
                            _key = 1;
                          _key < _len;
                          _key++
                        ) {
                          args[_key - 1] = arguments[_key]
                        }

                        return option.apply(this, args)
                      }

                      return option
                    }
                  },
                  {
                    key: 'uploadFile',
                    value: function uploadFile(file) {
                      return this.uploadFiles([file])
                    }
                  },
                  {
                    key: 'uploadFiles',
                    value: function uploadFiles(files) {
                      var _this14 = this

                      this._transformFiles(files, function (transformedFiles) {
                        if (_this14.options.chunking) {
                          // Chunking is not allowed to be used with `uploadMultiple` so we know
                          // that there is only __one__file.
                          var transformedFile = transformedFiles[0]
                          files[0].upload.chunked =
                            _this14.options.chunking &&
                            (_this14.options.forceChunking ||
                              transformedFile.size > _this14.options.chunkSize)
                          files[0].upload.totalChunkCount = Math.ceil(
                            transformedFile.size / _this14.options.chunkSize
                          )
                        }

                        if (files[0].upload.chunked) {
                          // This file should be sent in chunks!
                          // If the chunking option is set, we **know** that there can only be **one** file, since
                          // uploadMultiple is not allowed with this option.
                          var file = files[0]
                          var _transformedFile = transformedFiles[0]
                          var startedChunkCount = 0
                          file.upload.chunks = []

                          var handleNextChunk = function handleNextChunk() {
                            var chunkIndex = 0 // Find the next item in file.upload.chunks that is not defined yet.

                            while (
                              file.upload.chunks[chunkIndex] !== undefined
                            ) {
                              chunkIndex++
                            } // This means, that all chunks have already been started.

                            if (chunkIndex >= file.upload.totalChunkCount)
                              return
                            startedChunkCount++
                            var start = chunkIndex * _this14.options.chunkSize
                            var end = Math.min(
                              start + _this14.options.chunkSize,
                              _transformedFile.size
                            )
                            var dataBlock = {
                              name: _this14._getParamName(0),
                              data: _transformedFile.webkitSlice
                                ? _transformedFile.webkitSlice(start, end)
                                : _transformedFile.slice(start, end),
                              filename: file.upload.filename,
                              chunkIndex: chunkIndex
                            }
                            file.upload.chunks[chunkIndex] = {
                              file: file,
                              index: chunkIndex,
                              dataBlock: dataBlock,
                              // In case we want to retry.
                              status: Dropzone.UPLOADING,
                              progress: 0,
                              retries: 0 // The number of times this block has been retried.
                            }

                            _this14._uploadData(files, [dataBlock])
                          }

                          file.upload.finishedChunkUpload = function (
                            chunk,
                            response
                          ) {
                            var allFinished = true
                            chunk.status = Dropzone.SUCCESS // Clear the data from the chunk

                            chunk.dataBlock = null // Leaving this reference to xhr intact here will cause memory leaks in some browsers

                            chunk.xhr = null

                            for (
                              var i = 0;
                              i < file.upload.totalChunkCount;
                              i++
                            ) {
                              if (file.upload.chunks[i] === undefined) {
                                return handleNextChunk()
                              }

                              if (
                                file.upload.chunks[i].status !==
                                Dropzone.SUCCESS
                              ) {
                                allFinished = false
                              }
                            }

                            if (allFinished) {
                              _this14.options.chunksUploaded(file, function () {
                                _this14._finished(files, response, null)
                              })
                            }
                          }

                          if (_this14.options.parallelChunkUploads) {
                            for (
                              var i = 0;
                              i < file.upload.totalChunkCount;
                              i++
                            ) {
                              handleNextChunk()
                            }
                          } else {
                            handleNextChunk()
                          }
                        } else {
                          var dataBlocks = []

                          for (var _i2 = 0; _i2 < files.length; _i2++) {
                            dataBlocks[_i2] = {
                              name: _this14._getParamName(_i2),
                              data: transformedFiles[_i2],
                              filename: files[_i2].upload.filename
                            }
                          }

                          _this14._uploadData(files, dataBlocks)
                        }
                      })
                    } /// Returns the right chunk for given file and xhr
                  },
                  {
                    key: '_getChunk',
                    value: function _getChunk(file, xhr) {
                      for (var i = 0; i < file.upload.totalChunkCount; i++) {
                        if (
                          file.upload.chunks[i] !== undefined &&
                          file.upload.chunks[i].xhr === xhr
                        ) {
                          return file.upload.chunks[i]
                        }
                      }
                    } // This function actually uploads the file(s) to the server.
                    // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed
                    // files, or individual chunks for chunked upload).
                  },
                  {
                    key: '_uploadData',
                    value: function _uploadData(files, dataBlocks) {
                      var _this15 = this

                      var xhr = new XMLHttpRequest() // Put the xhr object in the file objects to be able to reference it later.

                      var _iterator13 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step13

                      try {
                        for (
                          _iterator13.s();
                          !(_step13 = _iterator13.n()).done;

                        ) {
                          var file = _step13.value
                          file.xhr = xhr
                        }
                      } catch (err) {
                        _iterator13.e(err)
                      } finally {
                        _iterator13.f()
                      }

                      if (files[0].upload.chunked) {
                        // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk
                        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr =
                          xhr
                      }

                      var method = this.resolveOption(
                        this.options.method,
                        files
                      )
                      var url = this.resolveOption(this.options.url, files)
                      xhr.open(method, url, true) // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8

                      var timeout = this.resolveOption(
                        this.options.timeout,
                        files
                      )
                      if (timeout)
                        xhr.timeout = this.resolveOption(
                          this.options.timeout,
                          files
                        ) // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179

                      xhr.withCredentials = !!this.options.withCredentials

                      xhr.onload = function (e) {
                        _this15._finishedUploading(files, xhr, e)
                      }

                      xhr.ontimeout = function () {
                        _this15._handleUploadError(
                          files,
                          xhr,
                          'Request timedout after '.concat(
                            _this15.options.timeout / 1000,
                            ' seconds'
                          )
                        )
                      }

                      xhr.onerror = function () {
                        _this15._handleUploadError(files, xhr)
                      } // Some browsers do not have the .upload property

                      var progressObj = xhr.upload != null ? xhr.upload : xhr

                      progressObj.onprogress = function (e) {
                        return _this15._updateFilesUploadProgress(files, xhr, e)
                      }

                      var headers = {
                        Accept: 'application/json',
                        'Cache-Control': 'no-cache',
                        'X-Requested-With': 'XMLHttpRequest'
                      }

                      if (this.options.headers) {
                        Dropzone.extend(headers, this.options.headers)
                      }

                      for (var headerName in headers) {
                        var headerValue = headers[headerName]

                        if (headerValue) {
                          xhr.setRequestHeader(headerName, headerValue)
                        }
                      }

                      var formData = new FormData() // Adding all @options parameters

                      if (this.options.params) {
                        var additionalParams = this.options.params

                        if (typeof additionalParams === 'function') {
                          additionalParams = additionalParams.call(
                            this,
                            files,
                            xhr,
                            files[0].upload.chunked
                              ? this._getChunk(files[0], xhr)
                              : null
                          )
                        }

                        for (var key in additionalParams) {
                          var value = additionalParams[key]

                          if (Array.isArray(value)) {
                            // The additional parameter contains an array,
                            // so lets iterate over it to attach each value
                            // individually.
                            for (var i = 0; i < value.length; i++) {
                              formData.append(key, value[i])
                            }
                          } else {
                            formData.append(key, value)
                          }
                        }
                      } // Let the user add additional data if necessary

                      var _iterator14 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step14

                      try {
                        for (
                          _iterator14.s();
                          !(_step14 = _iterator14.n()).done;

                        ) {
                          var _file = _step14.value
                          this.emit('sending', _file, xhr, formData)
                        }
                      } catch (err) {
                        _iterator14.e(err)
                      } finally {
                        _iterator14.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('sendingmultiple', files, xhr, formData)
                      }

                      this._addFormElementData(formData) // Finally add the files
                      // Has to be last because some servers (eg: S3) expect the file to be the last parameter

                      for (var _i3 = 0; _i3 < dataBlocks.length; _i3++) {
                        var dataBlock = dataBlocks[_i3]
                        formData.append(
                          dataBlock.name,
                          dataBlock.data,
                          dataBlock.filename
                        )
                      }

                      this.submitRequest(xhr, formData, files)
                    } // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
                  },
                  {
                    key: '_transformFiles',
                    value: function _transformFiles(files, done) {
                      var _this16 = this

                      var transformedFiles = [] // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.

                      var doneCounter = 0

                      var _loop = function _loop(i) {
                        _this16.options.transformFile.call(
                          _this16,
                          files[i],
                          function (transformedFile) {
                            transformedFiles[i] = transformedFile

                            if (++doneCounter === files.length) {
                              done(transformedFiles)
                            }
                          }
                        )
                      }

                      for (var i = 0; i < files.length; i++) {
                        _loop(i)
                      }
                    } // Takes care of adding other input elements of the form to the AJAX request
                  },
                  {
                    key: '_addFormElementData',
                    value: function _addFormElementData(formData) {
                      // Take care of other input elements
                      if (this.element.tagName === 'FORM') {
                        var _iterator15 = dropzone_createForOfIteratorHelper(
                            this.element.querySelectorAll(
                              'input, textarea, select, button'
                            ),
                            true
                          ),
                          _step15

                        try {
                          for (
                            _iterator15.s();
                            !(_step15 = _iterator15.n()).done;

                          ) {
                            var input = _step15.value
                            var inputName = input.getAttribute('name')
                            var inputType = input.getAttribute('type')
                            if (inputType) inputType = inputType.toLowerCase() // If the input doesn't have a name, we can't use it.

                            if (
                              typeof inputName === 'undefined' ||
                              inputName === null
                            )
                              continue

                            if (
                              input.tagName === 'SELECT' &&
                              input.hasAttribute('multiple')
                            ) {
                              // Possibly multiple values
                              var _iterator16 =
                                  dropzone_createForOfIteratorHelper(
                                    input.options,
                                    true
                                  ),
                                _step16

                              try {
                                for (
                                  _iterator16.s();
                                  !(_step16 = _iterator16.n()).done;

                                ) {
                                  var option = _step16.value

                                  if (option.selected) {
                                    formData.append(inputName, option.value)
                                  }
                                }
                              } catch (err) {
                                _iterator16.e(err)
                              } finally {
                                _iterator16.f()
                              }
                            } else if (
                              !inputType ||
                              (inputType !== 'checkbox' &&
                                inputType !== 'radio') ||
                              input.checked
                            ) {
                              formData.append(inputName, input.value)
                            }
                          }
                        } catch (err) {
                          _iterator15.e(err)
                        } finally {
                          _iterator15.f()
                        }
                      }
                    } // Invoked when there is new progress information about given files.
                    // If e is not provided, it is assumed that the upload is finished.
                  },
                  {
                    key: '_updateFilesUploadProgress',
                    value: function _updateFilesUploadProgress(files, xhr, e) {
                      if (!files[0].upload.chunked) {
                        // Handle file uploads without chunking
                        var _iterator17 = dropzone_createForOfIteratorHelper(
                            files,
                            true
                          ),
                          _step17

                        try {
                          for (
                            _iterator17.s();
                            !(_step17 = _iterator17.n()).done;

                          ) {
                            var file = _step17.value

                            if (
                              file.upload.total &&
                              file.upload.bytesSent &&
                              file.upload.bytesSent == file.upload.total
                            ) {
                              // If both, the `total` and `bytesSent` have already been set, and
                              // they are equal (meaning progress is at 100%), we can skip this
                              // file, since an upload progress shouldn't go down.
                              continue
                            }

                            if (e) {
                              file.upload.progress = (100 * e.loaded) / e.total
                              file.upload.total = e.total
                              file.upload.bytesSent = e.loaded
                            } else {
                              // No event, so we're at 100%
                              file.upload.progress = 100
                              file.upload.bytesSent = file.upload.total
                            }

                            this.emit(
                              'uploadprogress',
                              file,
                              file.upload.progress,
                              file.upload.bytesSent
                            )
                          }
                        } catch (err) {
                          _iterator17.e(err)
                        } finally {
                          _iterator17.f()
                        }
                      } else {
                        // Handle chunked file uploads
                        // Chunked upload is not compatible with uploading multiple files in one
                        // request, so we know there's only one file.
                        var _file2 = files[0] // Since this is a chunked upload, we need to update the appropriate chunk
                        // progress.

                        var chunk = this._getChunk(_file2, xhr)

                        if (e) {
                          chunk.progress = (100 * e.loaded) / e.total
                          chunk.total = e.total
                          chunk.bytesSent = e.loaded
                        } else {
                          // No event, so we're at 100%
                          chunk.progress = 100
                          chunk.bytesSent = chunk.total
                        } // Now tally the *file* upload progress from its individual chunks

                        _file2.upload.progress = 0
                        _file2.upload.total = 0
                        _file2.upload.bytesSent = 0

                        for (
                          var i = 0;
                          i < _file2.upload.totalChunkCount;
                          i++
                        ) {
                          if (
                            _file2.upload.chunks[i] &&
                            typeof _file2.upload.chunks[i].progress !==
                              'undefined'
                          ) {
                            _file2.upload.progress +=
                              _file2.upload.chunks[i].progress
                            _file2.upload.total += _file2.upload.chunks[i].total
                            _file2.upload.bytesSent +=
                              _file2.upload.chunks[i].bytesSent
                          }
                        } // Since the process is a percentage, we need to divide by the amount of
                        // chunks we've used.

                        _file2.upload.progress =
                          _file2.upload.progress / _file2.upload.totalChunkCount
                        this.emit(
                          'uploadprogress',
                          _file2,
                          _file2.upload.progress,
                          _file2.upload.bytesSent
                        )
                      }
                    }
                  },
                  {
                    key: '_finishedUploading',
                    value: function _finishedUploading(files, xhr, e) {
                      var response

                      if (files[0].status === Dropzone.CANCELED) {
                        return
                      }

                      if (xhr.readyState !== 4) {
                        return
                      }

                      if (
                        xhr.responseType !== 'arraybuffer' &&
                        xhr.responseType !== 'blob'
                      ) {
                        response = xhr.responseText

                        if (
                          xhr.getResponseHeader('content-type') &&
                          ~xhr
                            .getResponseHeader('content-type')
                            .indexOf('application/json')
                        ) {
                          try {
                            response = JSON.parse(response)
                          } catch (error) {
                            e = error
                            response = 'Invalid JSON response from server.'
                          }
                        }
                      }

                      this._updateFilesUploadProgress(files, xhr)

                      if (!(200 <= xhr.status && xhr.status < 300)) {
                        this._handleUploadError(files, xhr, response)
                      } else {
                        if (files[0].upload.chunked) {
                          files[0].upload.finishedChunkUpload(
                            this._getChunk(files[0], xhr),
                            response
                          )
                        } else {
                          this._finished(files, response, e)
                        }
                      }
                    }
                  },
                  {
                    key: '_handleUploadError',
                    value: function _handleUploadError(files, xhr, response) {
                      if (files[0].status === Dropzone.CANCELED) {
                        return
                      }

                      if (files[0].upload.chunked && this.options.retryChunks) {
                        var chunk = this._getChunk(files[0], xhr)

                        if (chunk.retries++ < this.options.retryChunksLimit) {
                          this._uploadData(files, [chunk.dataBlock])

                          return
                        } else {
                          console.warn(
                            'Retried this chunk too often. Giving up.'
                          )
                        }
                      }

                      this._errorProcessing(
                        files,
                        response ||
                          this.options.dictResponseError.replace(
                            '{{statusCode}}',
                            xhr.status
                          ),
                        xhr
                      )
                    }
                  },
                  {
                    key: 'submitRequest',
                    value: function submitRequest(xhr, formData, files) {
                      if (xhr.readyState != 1) {
                        console.warn(
                          'Cannot send this request because the XMLHttpRequest.readyState is not OPENED.'
                        )
                        return
                      }

                      xhr.send(formData)
                    } // Called internally when processing is finished.
                    // Individual callbacks have to be called in the appropriate sections.
                  },
                  {
                    key: '_finished',
                    value: function _finished(files, responseText, e) {
                      var _iterator18 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step18

                      try {
                        for (
                          _iterator18.s();
                          !(_step18 = _iterator18.n()).done;

                        ) {
                          var file = _step18.value
                          file.status = Dropzone.SUCCESS
                          this.emit('success', file, responseText, e)
                          this.emit('complete', file)
                        }
                      } catch (err) {
                        _iterator18.e(err)
                      } finally {
                        _iterator18.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('successmultiple', files, responseText, e)
                        this.emit('completemultiple', files)
                      }

                      if (this.options.autoProcessQueue) {
                        return this.processQueue()
                      }
                    } // Called internally when processing is finished.
                    // Individual callbacks have to be called in the appropriate sections.
                  },
                  {
                    key: '_errorProcessing',
                    value: function _errorProcessing(files, message, xhr) {
                      var _iterator19 = dropzone_createForOfIteratorHelper(
                          files,
                          true
                        ),
                        _step19

                      try {
                        for (
                          _iterator19.s();
                          !(_step19 = _iterator19.n()).done;

                        ) {
                          var file = _step19.value
                          file.status = Dropzone.ERROR
                          this.emit('error', file, message, xhr)
                          this.emit('complete', file)
                        }
                      } catch (err) {
                        _iterator19.e(err)
                      } finally {
                        _iterator19.f()
                      }

                      if (this.options.uploadMultiple) {
                        this.emit('errormultiple', files, message, xhr)
                        this.emit('completemultiple', files)
                      }

                      if (this.options.autoProcessQueue) {
                        return this.processQueue()
                      }
                    }
                  }
                ],
                [
                  {
                    key: 'initClass',
                    value: function initClass() {
                      // Exposing the emitter class, mainly for tests
                      this.prototype.Emitter = Emitter
                      /*
       This is a list of all available events you can register on a dropzone object.
        You can register an event handler like this:
        dropzone.on("dragEnter", function() { });
        */

                      this.prototype.events = [
                        'drop',
                        'dragstart',
                        'dragend',
                        'dragenter',
                        'dragover',
                        'dragleave',
                        'addedfile',
                        'addedfiles',
                        'removedfile',
                        'thumbnail',
                        'error',
                        'errormultiple',
                        'processing',
                        'processingmultiple',
                        'uploadprogress',
                        'totaluploadprogress',
                        'sending',
                        'sendingmultiple',
                        'success',
                        'successmultiple',
                        'canceled',
                        'canceledmultiple',
                        'complete',
                        'completemultiple',
                        'reset',
                        'maxfilesexceeded',
                        'maxfilesreached',
                        'queuecomplete'
                      ]
                      this.prototype._thumbnailQueue = []
                      this.prototype._processingThumbnail = false
                    } // global utility
                  },
                  {
                    key: 'extend',
                    value: function extend(target) {
                      for (
                        var _len2 = arguments.length,
                          objects = new Array(_len2 > 1 ? _len2 - 1 : 0),
                          _key2 = 1;
                        _key2 < _len2;
                        _key2++
                      ) {
                        objects[_key2 - 1] = arguments[_key2]
                      }

                      for (
                        var _i4 = 0, _objects = objects;
                        _i4 < _objects.length;
                        _i4++
                      ) {
                        var object = _objects[_i4]

                        for (var key in object) {
                          var val = object[key]
                          target[key] = val
                        }
                      }

                      return target
                    }
                  },
                  {
                    key: 'uuidv4',
                    value: function uuidv4() {
                      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
                        /[xy]/g,
                        function (c) {
                          var r = (Math.random() * 16) | 0,
                            v = c === 'x' ? r : (r & 0x3) | 0x8
                          return v.toString(16)
                        }
                      )
                    }
                  }
                ]
              )

              return Dropzone
            })(Emitter)

            Dropzone.initClass()
            Dropzone.version = '5.9.3' // This is a map of options for your different dropzones. Add configurations
            // to this object for your different dropzone elemens.
            //
            // Example:
            //
            //     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
            //
            // To disable autoDiscover for a specific element, you can set `false` as an option:
            //
            //     Dropzone.options.myDisabledElementId = false;
            //
            // And in html:
            //
            //     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>

            Dropzone.options = {} // Returns the options for an element or undefined if none available.

            Dropzone.optionsForElement = function (element) {
              // Get the `Dropzone.options.elementId` for this element if it exists
              if (element.getAttribute('id')) {
                return Dropzone.options[camelize(element.getAttribute('id'))]
              } else {
                return undefined
              }
            } // Holds a list of all dropzone instances

            Dropzone.instances = [] // Returns the dropzone for given element if any

            Dropzone.forElement = function (element) {
              if (typeof element === 'string') {
                element = document.querySelector(element)
              }

              if ((element != null ? element.dropzone : undefined) == null) {
                throw new Error(
                  "No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone."
                )
              }

              return element.dropzone
            } // Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.

            Dropzone.autoDiscover = true // Looks for all .dropzone elements and creates a dropzone for them

            Dropzone.discover = function () {
              var dropzones

              if (document.querySelectorAll) {
                dropzones = document.querySelectorAll('.dropzone')
              } else {
                dropzones = [] // IE :(

                var checkElements = function checkElements(elements) {
                  return (function () {
                    var result = []

                    var _iterator20 = dropzone_createForOfIteratorHelper(
                        elements,
                        true
                      ),
                      _step20

                    try {
                      for (
                        _iterator20.s();
                        !(_step20 = _iterator20.n()).done;

                      ) {
                        var el = _step20.value

                        if (/(^| )dropzone($| )/.test(el.className)) {
                          result.push(dropzones.push(el))
                        } else {
                          result.push(undefined)
                        }
                      }
                    } catch (err) {
                      _iterator20.e(err)
                    } finally {
                      _iterator20.f()
                    }

                    return result
                  })()
                }

                checkElements(document.getElementsByTagName('div'))
                checkElements(document.getElementsByTagName('form'))
              }

              return (function () {
                var result = []

                var _iterator21 = dropzone_createForOfIteratorHelper(
                    dropzones,
                    true
                  ),
                  _step21

                try {
                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done; ) {
                    var dropzone = _step21.value

                    // Create a dropzone unless auto discover has been disabled for specific element
                    if (Dropzone.optionsForElement(dropzone) !== false) {
                      result.push(new Dropzone(dropzone))
                    } else {
                      result.push(undefined)
                    }
                  }
                } catch (err) {
                  _iterator21.e(err)
                } finally {
                  _iterator21.f()
                }

                return result
              })()
            } // Some browsers support drag and drog functionality, but not correctly.
            //
            // So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.
            // But what to do when browsers *theoretically* support an API, but crash
            // when using it.
            //
            // This is a list of regular expressions tested against navigator.userAgent
            //
            // ** It should only be used on browser that *do* support the API, but
            // incorrectly **

            Dropzone.blockedBrowsers = [
              // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
              /opera.*(Macintosh|Windows Phone).*version\/12/i
            ] // Checks if the browser is supported

            Dropzone.isBrowserSupported = function () {
              var capableBrowser = true

              if (
                window.File &&
                window.FileReader &&
                window.FileList &&
                window.Blob &&
                window.FormData &&
                document.querySelector
              ) {
                if (!('classList' in document.createElement('a'))) {
                  capableBrowser = false
                } else {
                  if (Dropzone.blacklistedBrowsers !== undefined) {
                    // Since this has been renamed, this makes sure we don't break older
                    // configuration.
                    Dropzone.blockedBrowsers = Dropzone.blacklistedBrowsers
                  } // The browser supports the API, but may be blocked.

                  var _iterator22 = dropzone_createForOfIteratorHelper(
                      Dropzone.blockedBrowsers,
                      true
                    ),
                    _step22

                  try {
                    for (_iterator22.s(); !(_step22 = _iterator22.n()).done; ) {
                      var regex = _step22.value

                      if (regex.test(navigator.userAgent)) {
                        capableBrowser = false
                        continue
                      }
                    }
                  } catch (err) {
                    _iterator22.e(err)
                  } finally {
                    _iterator22.f()
                  }
                }
              } else {
                capableBrowser = false
              }

              return capableBrowser
            }

            Dropzone.dataURItoBlob = function (dataURI) {
              // convert base64 to raw binary data held in a string
              // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
              var byteString = atob(dataURI.split(',')[1]) // separate out the mime component

              var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0] // write the bytes of the string to an ArrayBuffer

              var ab = new ArrayBuffer(byteString.length)
              var ia = new Uint8Array(ab)

              for (
                var i = 0, end = byteString.length, asc = 0 <= end;
                asc ? i <= end : i >= end;
                asc ? i++ : i--
              ) {
                ia[i] = byteString.charCodeAt(i)
              } // write the ArrayBuffer to a blob

              return new Blob([ab], {
                type: mimeString
              })
            } // Returns an array without the rejected item

            var without = function without(list, rejectedItem) {
              return list
                .filter(function (item) {
                  return item !== rejectedItem
                })
                .map(function (item) {
                  return item
                })
            } // abc-def_ghi -> abcDefGhi

            var camelize = function camelize(str) {
              return str.replace(/[\-_](\w)/g, function (match) {
                return match.charAt(1).toUpperCase()
              })
            } // Creates an element from string

            Dropzone.createElement = function (string) {
              var div = document.createElement('div')
              div.innerHTML = string
              return div.childNodes[0]
            } // Tests if given element is inside (or simply is) the container

            Dropzone.elementInside = function (element, container) {
              if (element === container) {
                return true
              } // Coffeescript doesn't support do/while loops

              while ((element = element.parentNode)) {
                if (element === container) {
                  return true
                }
              }

              return false
            }

            Dropzone.getElement = function (el, name) {
              var element

              if (typeof el === 'string') {
                element = document.querySelector(el)
              } else if (el.nodeType != null) {
                element = el
              }

              if (element == null) {
                throw new Error(
                  'Invalid `'.concat(
                    name,
                    '` option provided. Please provide a CSS selector or a plain HTML element.'
                  )
                )
              }

              return element
            }

            Dropzone.getElements = function (els, name) {
              var el, elements

              if (els instanceof Array) {
                elements = []

                try {
                  var _iterator23 = dropzone_createForOfIteratorHelper(
                      els,
                      true
                    ),
                    _step23

                  try {
                    for (_iterator23.s(); !(_step23 = _iterator23.n()).done; ) {
                      el = _step23.value
                      elements.push(this.getElement(el, name))
                    }
                  } catch (err) {
                    _iterator23.e(err)
                  } finally {
                    _iterator23.f()
                  }
                } catch (e) {
                  elements = null
                }
              } else if (typeof els === 'string') {
                elements = []

                var _iterator24 = dropzone_createForOfIteratorHelper(
                    document.querySelectorAll(els),
                    true
                  ),
                  _step24

                try {
                  for (_iterator24.s(); !(_step24 = _iterator24.n()).done; ) {
                    el = _step24.value
                    elements.push(el)
                  }
                } catch (err) {
                  _iterator24.e(err)
                } finally {
                  _iterator24.f()
                }
              } else if (els.nodeType != null) {
                elements = [els]
              }

              if (elements == null || !elements.length) {
                throw new Error(
                  'Invalid `'.concat(
                    name,
                    '` option provided. Please provide a CSS selector, a plain HTML element or a list of those.'
                  )
                )
              }

              return elements
            } // Asks the user the question and calls accepted or rejected accordingly
            //
            // The default implementation just uses `window.confirm` and then calls the
            // appropriate callback.

            Dropzone.confirm = function (question, accepted, rejected) {
              if (window.confirm(question)) {
                return accepted()
              } else if (rejected != null) {
                return rejected()
              }
            } // Validates the mime type like this:
            //
            // https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept

            Dropzone.isValidFile = function (file, acceptedFiles) {
              if (!acceptedFiles) {
                return true
              } // If there are no accepted mime types, it's OK

              acceptedFiles = acceptedFiles.split(',')
              var mimeType = file.type
              var baseMimeType = mimeType.replace(/\/.*$/, '')

              var _iterator25 = dropzone_createForOfIteratorHelper(
                  acceptedFiles,
                  true
                ),
                _step25

              try {
                for (_iterator25.s(); !(_step25 = _iterator25.n()).done; ) {
                  var validType = _step25.value
                  validType = validType.trim()

                  if (validType.charAt(0) === '.') {
                    if (
                      file.name
                        .toLowerCase()
                        .indexOf(
                          validType.toLowerCase(),
                          file.name.length - validType.length
                        ) !== -1
                    ) {
                      return true
                    }
                  } else if (/\/\*$/.test(validType)) {
                    // This is something like a image/* mime type
                    if (baseMimeType === validType.replace(/\/.*$/, '')) {
                      return true
                    }
                  } else {
                    if (mimeType === validType) {
                      return true
                    }
                  }
                }
              } catch (err) {
                _iterator25.e(err)
              } finally {
                _iterator25.f()
              }

              return false
            } // Augment jQuery

            if (typeof jQuery !== 'undefined' && jQuery !== null) {
              jQuery.fn.dropzone = function (options) {
                return this.each(function () {
                  return new Dropzone(this, options)
                })
              }
            } // Dropzone file status codes

            Dropzone.ADDED = 'added'
            Dropzone.QUEUED = 'queued' // For backwards compatibility. Now, if a file is accepted, it's either queued
            // or uploading.

            Dropzone.ACCEPTED = Dropzone.QUEUED
            Dropzone.UPLOADING = 'uploading'
            Dropzone.PROCESSING = Dropzone.UPLOADING // alias

            Dropzone.CANCELED = 'canceled'
            Dropzone.ERROR = 'error'
            Dropzone.SUCCESS = 'success'
            /*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */
            // Detecting vertical squash in loaded image.
            // Fixes a bug which squash image vertically while drawing into canvas for some images.
            // This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel

            var detectVerticalSquash = function detectVerticalSquash(img) {
              var iw = img.naturalWidth
              var ih = img.naturalHeight
              var canvas = document.createElement('canvas')
              canvas.width = 1
              canvas.height = ih
              var ctx = canvas.getContext('2d')
              ctx.drawImage(img, 0, 0)

              var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),
                data = _ctx$getImageData.data // search image edge pixel position in case it is squashed vertically.

              var sy = 0
              var ey = ih
              var py = ih

              while (py > sy) {
                var alpha = data[(py - 1) * 4 + 3]

                if (alpha === 0) {
                  ey = py
                } else {
                  sy = py
                }

                py = (ey + sy) >> 1
              }

              var ratio = py / ih

              if (ratio === 0) {
                return 1
              } else {
                return ratio
              }
            } // A replacement for context.drawImage
            // (args are for source and destination).

            var drawImageIOSFix = function drawImageIOSFix(
              ctx,
              img,
              sx,
              sy,
              sw,
              sh,
              dx,
              dy,
              dw,
              dh
            ) {
              var vertSquashRatio = detectVerticalSquash(img)
              return ctx.drawImage(
                img,
                sx,
                sy,
                sw,
                sh,
                dx,
                dy,
                dw,
                dh / vertSquashRatio
              )
            } // Based on MinifyJpeg
            // Source: http://www.perry.cz/files/ExifRestorer.js
            // http://elicon.blog57.fc2.com/blog-entry-206.html

            var ExifRestore = /*#__PURE__*/ (function () {
              function ExifRestore() {
                dropzone_classCallCheck(this, ExifRestore)
              }

              dropzone_createClass(ExifRestore, null, [
                {
                  key: 'initClass',
                  value: function initClass() {
                    this.KEY_STR =
                      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
                  }
                },
                {
                  key: 'encode64',
                  value: function encode64(input) {
                    var output = ''
                    var chr1 = undefined
                    var chr2 = undefined
                    var chr3 = ''
                    var enc1 = undefined
                    var enc2 = undefined
                    var enc3 = undefined
                    var enc4 = ''
                    var i = 0

                    while (true) {
                      chr1 = input[i++]
                      chr2 = input[i++]
                      chr3 = input[i++]
                      enc1 = chr1 >> 2
                      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4)
                      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6)
                      enc4 = chr3 & 63

                      if (isNaN(chr2)) {
                        enc3 = enc4 = 64
                      } else if (isNaN(chr3)) {
                        enc4 = 64
                      }

                      output =
                        output +
                        this.KEY_STR.charAt(enc1) +
                        this.KEY_STR.charAt(enc2) +
                        this.KEY_STR.charAt(enc3) +
                        this.KEY_STR.charAt(enc4)
                      chr1 = chr2 = chr3 = ''
                      enc1 = enc2 = enc3 = enc4 = ''

                      if (!(i < input.length)) {
                        break
                      }
                    }

                    return output
                  }
                },
                {
                  key: 'restore',
                  value: function restore(origFileBase64, resizedFileBase64) {
                    if (!origFileBase64.match('data:image/jpeg;base64,')) {
                      return resizedFileBase64
                    }

                    var rawImage = this.decode64(
                      origFileBase64.replace('data:image/jpeg;base64,', '')
                    )
                    var segments = this.slice2Segments(rawImage)
                    var image = this.exifManipulation(
                      resizedFileBase64,
                      segments
                    )
                    return 'data:image/jpeg;base64,'.concat(
                      this.encode64(image)
                    )
                  }
                },
                {
                  key: 'exifManipulation',
                  value: function exifManipulation(
                    resizedFileBase64,
                    segments
                  ) {
                    var exifArray = this.getExifArray(segments)
                    var newImageArray = this.insertExif(
                      resizedFileBase64,
                      exifArray
                    )
                    var aBuffer = new Uint8Array(newImageArray)
                    return aBuffer
                  }
                },
                {
                  key: 'getExifArray',
                  value: function getExifArray(segments) {
                    var seg = undefined
                    var x = 0

                    while (x < segments.length) {
                      seg = segments[x]

                      if ((seg[0] === 255) & (seg[1] === 225)) {
                        return seg
                      }

                      x++
                    }

                    return []
                  }
                },
                {
                  key: 'insertExif',
                  value: function insertExif(resizedFileBase64, exifArray) {
                    var imageData = resizedFileBase64.replace(
                      'data:image/jpeg;base64,',
                      ''
                    )
                    var buf = this.decode64(imageData)
                    var separatePoint = buf.indexOf(255, 3)
                    var mae = buf.slice(0, separatePoint)
                    var ato = buf.slice(separatePoint)
                    var array = mae
                    array = array.concat(exifArray)
                    array = array.concat(ato)
                    return array
                  }
                },
                {
                  key: 'slice2Segments',
                  value: function slice2Segments(rawImageArray) {
                    var head = 0
                    var segments = []

                    while (true) {
                      var length

                      if (
                        (rawImageArray[head] === 255) &
                        (rawImageArray[head + 1] === 218)
                      ) {
                        break
                      }

                      if (
                        (rawImageArray[head] === 255) &
                        (rawImageArray[head + 1] === 216)
                      ) {
                        head += 2
                      } else {
                        length =
                          rawImageArray[head + 2] * 256 +
                          rawImageArray[head + 3]
                        var endPoint = head + length + 2
                        var seg = rawImageArray.slice(head, endPoint)
                        segments.push(seg)
                        head = endPoint
                      }

                      if (head > rawImageArray.length) {
                        break
                      }
                    }

                    return segments
                  }
                },
                {
                  key: 'decode64',
                  value: function decode64(input) {
                    var output = ''
                    var chr1 = undefined
                    var chr2 = undefined
                    var chr3 = ''
                    var enc1 = undefined
                    var enc2 = undefined
                    var enc3 = undefined
                    var enc4 = ''
                    var i = 0
                    var buf = [] // remove all characters that are not A-Z, a-z, 0-9, +, /, or =

                    var base64test = /[^A-Za-z0-9\+\/\=]/g

                    if (base64test.exec(input)) {
                      console.warn(
                        "There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding."
                      )
                    }

                    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '')

                    while (true) {
                      enc1 = this.KEY_STR.indexOf(input.charAt(i++))
                      enc2 = this.KEY_STR.indexOf(input.charAt(i++))
                      enc3 = this.KEY_STR.indexOf(input.charAt(i++))
                      enc4 = this.KEY_STR.indexOf(input.charAt(i++))
                      chr1 = (enc1 << 2) | (enc2 >> 4)
                      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)
                      chr3 = ((enc3 & 3) << 6) | enc4
                      buf.push(chr1)

                      if (enc3 !== 64) {
                        buf.push(chr2)
                      }

                      if (enc4 !== 64) {
                        buf.push(chr3)
                      }

                      chr1 = chr2 = chr3 = ''
                      enc1 = enc2 = enc3 = enc4 = ''

                      if (!(i < input.length)) {
                        break
                      }
                    }

                    return buf
                  }
                }
              ])

              return ExifRestore
            })()

            ExifRestore.initClass()
            /*
             * contentloaded.js
             *
             * Author: Diego Perini (diego.perini at gmail.com)
             * Summary: cross-browser wrapper for DOMContentLoaded
             * Updated: 20101020
             * License: MIT
             * Version: 1.2
             *
             * URL:
             * http://javascript.nwbox.com/ContentLoaded/
             * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
             */
            // @win window reference
            // @fn function reference

            var contentLoaded = function contentLoaded(win, fn) {
              var done = false
              var top = true
              var doc = win.document
              var root = doc.documentElement
              var add = doc.addEventListener
                ? 'addEventListener'
                : 'attachEvent'
              var rem = doc.addEventListener
                ? 'removeEventListener'
                : 'detachEvent'
              var pre = doc.addEventListener ? '' : 'on'

              var init = function init(e) {
                if (
                  e.type === 'readystatechange' &&
                  doc.readyState !== 'complete'
                ) {
                  return
                }

                ;(e.type === 'load' ? win : doc)[rem](pre + e.type, init, false)

                if (!done && (done = true)) {
                  return fn.call(win, e.type || e)
                }
              }

              var poll = function poll() {
                try {
                  root.doScroll('left')
                } catch (e) {
                  setTimeout(poll, 50)
                  return
                }

                return init('poll')
              }

              if (doc.readyState !== 'complete') {
                if (doc.createEventObject && root.doScroll) {
                  try {
                    top = !win.frameElement
                  } catch (error) {}

                  if (top) {
                    poll()
                  }
                }

                doc[add](pre + 'DOMContentLoaded', init, false)
                doc[add](pre + 'readystatechange', init, false)
                return win[add](pre + 'load', init, false)
              }
            } // As a single function to be able to write tests.

            Dropzone._autoDiscoverFunction = function () {
              if (Dropzone.autoDiscover) {
                return Dropzone.discover()
              }
            }

            contentLoaded(window, Dropzone._autoDiscoverFunction)

            function __guard__(value, transform) {
              return typeof value !== 'undefined' && value !== null
                ? transform(value)
                : undefined
            }

            function __guardMethod__(obj, methodName, transform) {
              if (
                typeof obj !== 'undefined' &&
                obj !== null &&
                typeof obj[methodName] === 'function'
              ) {
                return transform(obj, methodName)
              } else {
                return undefined
              }
            } // CONCATENATED MODULE: ./tool/dropzone.dist.js

            /// Make Dropzone a global variable.

            window.Dropzone = Dropzone
            /* harmony default export */ var dropzone_dist = Dropzone
          })()
          /******/ return __nested_webpack_exports__
          /******/
        })()
      })

      /***/
    },

    /***/ 7187: /***/ (module) => {
      'use strict'
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      var R = typeof Reflect === 'object' ? Reflect : null
      var ReflectApply =
        R && typeof R.apply === 'function'
          ? R.apply
          : function ReflectApply(target, receiver, args) {
              return Function.prototype.apply.call(target, receiver, args)
            }

      var ReflectOwnKeys
      if (R && typeof R.ownKeys === 'function') {
        ReflectOwnKeys = R.ownKeys
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target).concat(
            Object.getOwnPropertySymbols(target)
          )
        }
      } else {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target)
        }
      }

      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning)
      }

      var NumberIsNaN =
        Number.isNaN ||
        function NumberIsNaN(value) {
          return value !== value
        }

      function EventEmitter() {
        EventEmitter.init.call(this)
      }
      module.exports = EventEmitter
      module.exports.once = once

      // Backwards-compat with node 0.10.x
      EventEmitter.EventEmitter = EventEmitter

      EventEmitter.prototype._events = undefined
      EventEmitter.prototype._eventsCount = 0
      EventEmitter.prototype._maxListeners = undefined

      // By default EventEmitters will print a warning if more than 10 listeners are
      // added to it. This is a useful default which helps finding memory leaks.
      var defaultMaxListeners = 10

      function checkListener(listener) {
        if (typeof listener !== 'function') {
          throw new TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof listener
          )
        }
      }

      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
        enumerable: true,
        get: function () {
          return defaultMaxListeners
        },
        set: function (arg) {
          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                arg +
                '.'
            )
          }
          defaultMaxListeners = arg
        }
      })

      EventEmitter.init = function () {
        if (
          this._events === undefined ||
          this._events === Object.getPrototypeOf(this)._events
        ) {
          this._events = Object.create(null)
          this._eventsCount = 0
        }

        this._maxListeners = this._maxListeners || undefined
      }

      // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
          throw new RangeError(
            'The value of "n" is out of range. It must be a non-negative number. Received ' +
              n +
              '.'
          )
        }
        this._maxListeners = n
        return this
      }

      function _getMaxListeners(that) {
        if (that._maxListeners === undefined)
          return EventEmitter.defaultMaxListeners
        return that._maxListeners
      }

      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this)
      }

      EventEmitter.prototype.emit = function emit(type) {
        var args = []
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i])
        var doError = type === 'error'

        var events = this._events
        if (events !== undefined)
          doError = doError && events.error === undefined
        else if (!doError) return false

        // If there is no 'error' event listener then throw.
        if (doError) {
          var er
          if (args.length > 0) er = args[0]
          if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er // Unhandled 'error' event
          }
          // At least give some kind of context to the user
          var err = new Error(
            'Unhandled error.' + (er ? ' (' + er.message + ')' : '')
          )
          err.context = er
          throw err // Unhandled 'error' event
        }

        var handler = events[type]

        if (handler === undefined) return false

        if (typeof handler === 'function') {
          ReflectApply(handler, this, args)
        } else {
          var len = handler.length
          var listeners = arrayClone(handler, len)
          for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args)
        }

        return true
      }

      function _addListener(target, type, listener, prepend) {
        var m
        var events
        var existing

        checkListener(listener)

        events = target._events
        if (events === undefined) {
          events = target._events = Object.create(null)
          target._eventsCount = 0
        } else {
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (events.newListener !== undefined) {
            target.emit(
              'newListener',
              type,
              listener.listener ? listener.listener : listener
            )

            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events
          }
          existing = events[type]
        }

        if (existing === undefined) {
          // Optimize the case of one listener. Don't need the extra array object.
          existing = events[type] = listener
          ++target._eventsCount
        } else {
          if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend
              ? [listener, existing]
              : [existing, listener]
            // If we've already got an array, just append.
          } else if (prepend) {
            existing.unshift(listener)
          } else {
            existing.push(listener)
          }

          // Check for listener leak
          m = _getMaxListeners(target)
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error(
              'Possible EventEmitter memory leak detected. ' +
                existing.length +
                ' ' +
                String(type) +
                ' listeners ' +
                'added. Use emitter.setMaxListeners() to ' +
                'increase limit'
            )
            w.name = 'MaxListenersExceededWarning'
            w.emitter = target
            w.type = type
            w.count = existing.length
            ProcessEmitWarning(w)
          }
        }

        return target
      }

      EventEmitter.prototype.addListener = function addListener(
        type,
        listener
      ) {
        return _addListener(this, type, listener, false)
      }

      EventEmitter.prototype.on = EventEmitter.prototype.addListener

      EventEmitter.prototype.prependListener = function prependListener(
        type,
        listener
      ) {
        return _addListener(this, type, listener, true)
      }

      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn)
          this.fired = true
          if (arguments.length === 0) return this.listener.call(this.target)
          return this.listener.apply(this.target, arguments)
        }
      }

      function _onceWrap(target, type, listener) {
        var state = {
          fired: false,
          wrapFn: undefined,
          target: target,
          type: type,
          listener: listener
        }
        var wrapped = onceWrapper.bind(state)
        wrapped.listener = listener
        state.wrapFn = wrapped
        return wrapped
      }

      EventEmitter.prototype.once = function once(type, listener) {
        checkListener(listener)
        this.on(type, _onceWrap(this, type, listener))
        return this
      }

      EventEmitter.prototype.prependOnceListener = function prependOnceListener(
        type,
        listener
      ) {
        checkListener(listener)
        this.prependListener(type, _onceWrap(this, type, listener))
        return this
      }

      // Emits a 'removeListener' event if and only if the listener was removed.
      EventEmitter.prototype.removeListener = function removeListener(
        type,
        listener
      ) {
        var list, events, position, i, originalListener

        checkListener(listener)

        events = this._events
        if (events === undefined) return this

        list = events[type]
        if (list === undefined) return this

        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0) this._events = Object.create(null)
          else {
            delete events[type]
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener)
          }
        } else if (typeof list !== 'function') {
          position = -1

          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener
              position = i
              break
            }
          }

          if (position < 0) return this

          if (position === 0) list.shift()
          else {
            spliceOne(list, position)
          }

          if (list.length === 1) events[type] = list[0]

          if (events.removeListener !== undefined)
            this.emit('removeListener', type, originalListener || listener)
        }

        return this
      }

      EventEmitter.prototype.off = EventEmitter.prototype.removeListener

      EventEmitter.prototype.removeAllListeners = function removeAllListeners(
        type
      ) {
        var listeners, events, i

        events = this._events
        if (events === undefined) return this

        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null)
            this._eventsCount = 0
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null)
            else delete events[type]
          }
          return this
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events)
          var key
          for (i = 0; i < keys.length; ++i) {
            key = keys[i]
            if (key === 'removeListener') continue
            this.removeAllListeners(key)
          }
          this.removeAllListeners('removeListener')
          this._events = Object.create(null)
          this._eventsCount = 0
          return this
        }

        listeners = events[type]

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners)
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i])
          }
        }

        return this
      }

      function _listeners(target, type, unwrap) {
        var events = target._events

        if (events === undefined) return []

        var evlistener = events[type]
        if (evlistener === undefined) return []

        if (typeof evlistener === 'function')
          return unwrap ? [evlistener.listener || evlistener] : [evlistener]

        return unwrap
          ? unwrapListeners(evlistener)
          : arrayClone(evlistener, evlistener.length)
      }

      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true)
      }

      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false)
      }

      EventEmitter.listenerCount = function (emitter, type) {
        if (typeof emitter.listenerCount === 'function') {
          return emitter.listenerCount(type)
        } else {
          return listenerCount.call(emitter, type)
        }
      }

      EventEmitter.prototype.listenerCount = listenerCount
      function listenerCount(type) {
        var events = this._events

        if (events !== undefined) {
          var evlistener = events[type]

          if (typeof evlistener === 'function') {
            return 1
          } else if (evlistener !== undefined) {
            return evlistener.length
          }
        }

        return 0
      }

      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
      }

      function arrayClone(arr, n) {
        var copy = new Array(n)
        for (var i = 0; i < n; ++i) copy[i] = arr[i]
        return copy
      }

      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++) list[index] = list[index + 1]
        list.pop()
      }

      function unwrapListeners(arr) {
        var ret = new Array(arr.length)
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i]
        }
        return ret
      }

      function once(emitter, name) {
        return new Promise(function (resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver)
            reject(err)
          }

          function resolver() {
            if (typeof emitter.removeListener === 'function') {
              emitter.removeListener('error', errorListener)
            }
            resolve([].slice.call(arguments))
          }

          eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
          })
          if (name !== 'error') {
            addErrorHandlerIfEventEmitter(emitter, errorListener, {
              once: true
            })
          }
        })
      }

      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === 'function') {
          eventTargetAgnosticAddListener(emitter, 'error', handler, flags)
        }
      }

      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === 'function') {
          if (flags.once) {
            emitter.once(name, listener)
          } else {
            emitter.on(name, listener)
          }
        } else if (typeof emitter.addEventListener === 'function') {
          // EventTarget does not have `error` event semantics like Node
          // EventEmitters, we do not listen for `error` events here.
          emitter.addEventListener(name, function wrapListener(arg) {
            // IE does not have builtin `{ once: true }` support so we
            // have to do it manually.
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener)
            }
            listener(arg)
          })
        } else {
          throw new TypeError(
            'The "emitter" argument must be of type EventEmitter. Received type ' +
              typeof emitter
          )
        }
      }

      /***/
    },

    /***/ 4063: /***/ (module) => {
      'use strict'

      // do not edit .js files directly - edit src/index.jst

      module.exports = function equal(a, b) {
        if (a === b) return true

        if (a && b && typeof a == 'object' && typeof b == 'object') {
          if (a.constructor !== b.constructor) return false

          var length, i, keys
          if (Array.isArray(a)) {
            length = a.length
            if (length != b.length) return false
            for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false
            return true
          }

          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf()
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString()

          keys = Object.keys(a)
          length = keys.length
          if (length !== Object.keys(b).length) return false

          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false

          for (i = length; i-- !== 0; ) {
            var key = keys[i]

            if (!equal(a[key], b[key])) return false
          }

          return true
        }

        // true if both NaN, false otherwise
        return a !== a && b !== b
      }

      /***/
    },

    /***/ 6400: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI :data 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: :data Selector
      //>>group: Core
      //>>description: Selects elements which have data stored under the specified key.
      //>>docs: http://api.jqueryui.com/data-selector/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.extend($.expr.pseudos, {
          data: $.expr.createPseudo
            ? $.expr.createPseudo(function (dataName) {
                return function (elem) {
                  return !!$.data(elem, dataName)
                }
              })
            : // Support: jQuery <1.8
              function (elem, i, match) {
                return !!$.data(elem, match[3])
              }
        })
      })

      /***/
    },

    /***/ 2064: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Disable Selection 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: disableSelection
      //>>group: Core
      //>>description: Disable selection of text content within the set of matched elements.
      //>>docs: http://api.jqueryui.com/disableSelection/

      // This file is deprecated
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.fn.extend({
          disableSelection: (function () {
            var eventType =
              'onselectstart' in document.createElement('div')
                ? 'selectstart'
                : 'mousedown'

            return function () {
              return this.on(
                eventType + '.ui-disableSelection',
                function (event) {
                  event.preventDefault()
                }
              )
            }
          })(),

          enableSelection: function () {
            return this.off('.ui-disableSelection')
          }
        })
      })

      /***/
    },

    /***/ 5436: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Focusable 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: :focusable Selector
      //>>group: Core
      //>>description: Selects elements which can be focused.
      //>>docs: http://api.jqueryui.com/focusable-selector/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // Selectors
        $.ui.focusable = function (element, hasTabindex) {
          var map,
            mapName,
            img,
            focusableIfVisible,
            fieldset,
            nodeName = element.nodeName.toLowerCase()

          if ('area' === nodeName) {
            map = element.parentNode
            mapName = map.name
            if (
              !element.href ||
              !mapName ||
              map.nodeName.toLowerCase() !== 'map'
            ) {
              return false
            }
            img = $("img[usemap='#" + mapName + "']")
            return img.length > 0 && img.is(':visible')
          }

          if (/^(input|select|textarea|button|object)$/.test(nodeName)) {
            focusableIfVisible = !element.disabled

            if (focusableIfVisible) {
              // Form controls within a disabled fieldset are disabled.
              // However, controls within the fieldset's legend do not get disabled.
              // Since controls generally aren't placed inside legends, we skip
              // this portion of the check.
              fieldset = $(element).closest('fieldset')[0]
              if (fieldset) {
                focusableIfVisible = !fieldset.disabled
              }
            }
          } else if ('a' === nodeName) {
            focusableIfVisible = element.href || hasTabindex
          } else {
            focusableIfVisible = hasTabindex
          }

          return (
            focusableIfVisible &&
            $(element).is(':visible') &&
            visible($(element))
          )
        }

        // Support: IE 8 only
        // IE 8 doesn't resolve inherit to visible/hidden for computed values
        function visible(element) {
          var visibility = element.css('visibility')
          while (visibility === 'inherit') {
            element = element.parent()
            visibility = element.css('visibility')
          }
          return visibility === 'visible'
        }

        $.extend($.expr.pseudos, {
          focusable: function (element) {
            return $.ui.focusable(element, $.attr(element, 'tabindex') != null)
          }
        })

        return $.ui.focusable
      })

      /***/
    },

    /***/ 7808: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Form Reset Mixin 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Form Reset Mixin
      //>>group: Core
      //>>description: Refresh input widgets when their form is reset
      //>>docs: http://api.jqueryui.com/form-reset-mixin/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5588),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.formResetMixin = {
          _formResetHandler: function () {
            var form = $(this)

            // Wait for the form reset to actually happen before refreshing
            setTimeout(function () {
              var instances = form.data('ui-form-reset-instances')
              $.each(instances, function () {
                this.refresh()
              })
            })
          },

          _bindFormResetHandler: function () {
            this.form = this.element._form()
            if (!this.form.length) {
              return
            }

            var instances = this.form.data('ui-form-reset-instances') || []
            if (!instances.length) {
              // We don't use _on() here because we use a single event handler per form
              this.form.on('reset.ui-form-reset', this._formResetHandler)
            }
            instances.push(this)
            this.form.data('ui-form-reset-instances', instances)
          },

          _unbindFormResetHandler: function () {
            if (!this.form.length) {
              return
            }

            var instances = this.form.data('ui-form-reset-instances')
            instances.splice($.inArray(this, instances), 1)
            if (instances.length) {
              this.form.data('ui-form-reset-instances', instances)
            } else {
              this.form
                .removeData('ui-form-reset-instances')
                .off('reset.ui-form-reset')
            }
          }
        })
      })

      /***/
    },

    /***/ 5588: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // Support: IE8 Only
        // IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
        // with a string, so we need to find the proper form.
        return ($.fn._form = function () {
          return typeof this[0].form === 'string'
            ? this.closest('form')
            : $(this[0].form)
        })
      })

      /***/
    },

    /***/ 1870: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // This file is deprecated
        return ($.ui.ie = !!/msie [\w.]+/.exec(
          navigator.userAgent.toLowerCase()
        ))
      })

      /***/
    },

    /***/ 7053: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Keycode 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Keycode
      //>>group: Core
      //>>description: Provide keycodes as keynames
      //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.keyCode = {
          BACKSPACE: 8,
          COMMA: 188,
          DELETE: 46,
          DOWN: 40,
          END: 35,
          ENTER: 13,
          ESCAPE: 27,
          HOME: 36,
          LEFT: 37,
          PAGE_DOWN: 34,
          PAGE_UP: 33,
          PERIOD: 190,
          RIGHT: 39,
          SPACE: 32,
          TAB: 9,
          UP: 38
        })
      })

      /***/
    },

    /***/ 6575: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Labels 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: labels
      //>>group: Core
      //>>description: Find all the labels associated with a given input
      //>>docs: http://api.jqueryui.com/labels/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.fn.labels = function () {
          var ancestor, selector, id, labels, ancestors

          if (!this.length) {
            return this.pushStack([])
          }

          // Check control.labels first
          if (this[0].labels && this[0].labels.length) {
            return this.pushStack(this[0].labels)
          }

          // Support: IE <= 11, FF <= 37, Android <= 2.3 only
          // Above browsers do not support control.labels. Everything below is to support them
          // as well as document fragments. control.labels does not work on document fragments
          labels = this.eq(0).parents('label')

          // Look for the label based on the id
          id = this.attr('id')
          if (id) {
            // We don't search against the document in case the element
            // is disconnected from the DOM
            ancestor = this.eq(0).parents().last()

            // Get a full set of top level ancestors
            ancestors = ancestor.add(
              ancestor.length ? ancestor.siblings() : this.siblings()
            )

            // Create a selector for the label based on the id
            selector = "label[for='" + $.escapeSelector(id) + "']"

            labels = labels.add(ancestors.find(selector).addBack(selector))
          }

          // Return whatever we have found for labels
          return this.pushStack(labels)
        })
      })

      /***/
    },

    /***/ 1624: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        // $.ui.plugin is deprecated. Use $.widget() extensions instead.
        return ($.ui.plugin = {
          add: function (module, option, set) {
            var i,
              proto = $.ui[module].prototype
            for (i in set) {
              proto.plugins[i] = proto.plugins[i] || []
              proto.plugins[i].push([option, set[i]])
            }
          },
          call: function (instance, name, args, allowDisconnected) {
            var i,
              set = instance.plugins[name]

            if (!set) {
              return
            }

            if (
              !allowDisconnected &&
              (!instance.element[0].parentNode ||
                instance.element[0].parentNode.nodeType === 11)
            ) {
              return
            }

            for (i = 0; i < set.length; i++) {
              if (instance.options[set[i][0]]) {
                set[i][1].apply(instance.element, args)
              }
            }
          }
        })
      })

      /***/
    },

    /***/ 1822: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Position 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/position/
       */

      //>>label: Position
      //>>group: Core
      //>>description: Positions elements relative to other elements.
      //>>docs: http://api.jqueryui.com/position/
      //>>demos: http://jqueryui.com/position/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        ;(function () {
          var cachedScrollbarWidth,
            max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position

          function getOffsets(offsets, width, height) {
            return [
              parseFloat(offsets[0]) *
                (rpercent.test(offsets[0]) ? width / 100 : 1),
              parseFloat(offsets[1]) *
                (rpercent.test(offsets[1]) ? height / 100 : 1)
            ]
          }

          function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0
          }

          function isWindow(obj) {
            return obj != null && obj === obj.window
          }

          function getDimensions(elem) {
            var raw = elem[0]
            if (raw.nodeType === 9) {
              return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: 0, left: 0 }
              }
            }
            if (isWindow(raw)) {
              return {
                width: elem.width(),
                height: elem.height(),
                offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
              }
            }
            if (raw.preventDefault) {
              return {
                width: 0,
                height: 0,
                offset: { top: raw.pageY, left: raw.pageX }
              }
            }
            return {
              width: elem.outerWidth(),
              height: elem.outerHeight(),
              offset: elem.offset()
            }
          }

          $.position = {
            scrollbarWidth: function () {
              if (cachedScrollbarWidth !== undefined) {
                return cachedScrollbarWidth
              }
              var w1,
                w2,
                div = $(
                  '<div style=' +
                    "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                    "<div style='height:300px;width:auto;'></div></div>"
                ),
                innerDiv = div.children()[0]

              $('body').append(div)
              w1 = innerDiv.offsetWidth
              div.css('overflow', 'scroll')

              w2 = innerDiv.offsetWidth

              if (w1 === w2) {
                w2 = div[0].clientWidth
              }

              div.remove()

              return (cachedScrollbarWidth = w1 - w2)
            },
            getScrollInfo: function (within) {
              var overflowX =
                  within.isWindow || within.isDocument
                    ? ''
                    : within.element.css('overflow-x'),
                overflowY =
                  within.isWindow || within.isDocument
                    ? ''
                    : within.element.css('overflow-y'),
                hasOverflowX =
                  overflowX === 'scroll' ||
                  (overflowX === 'auto' &&
                    within.width < within.element[0].scrollWidth),
                hasOverflowY =
                  overflowY === 'scroll' ||
                  (overflowY === 'auto' &&
                    within.height < within.element[0].scrollHeight)
              return {
                width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                height: hasOverflowX ? $.position.scrollbarWidth() : 0
              }
            },
            getWithinInfo: function (element) {
              var withinElement = $(element || window),
                isElemWindow = isWindow(withinElement[0]),
                isDocument =
                  !!withinElement[0] && withinElement[0].nodeType === 9,
                hasOffset = !isElemWindow && !isDocument
              return {
                element: withinElement,
                isWindow: isElemWindow,
                isDocument: isDocument,
                offset: hasOffset ? $(element).offset() : { left: 0, top: 0 },
                scrollLeft: withinElement.scrollLeft(),
                scrollTop: withinElement.scrollTop(),
                width: withinElement.outerWidth(),
                height: withinElement.outerHeight()
              }
            }
          }

          $.fn.position = function (options) {
            if (!options || !options.of) {
              return _position.apply(this, arguments)
            }

            // Make a copy, we don't want to modify arguments
            options = $.extend({}, options)

            var atOffset,
              targetWidth,
              targetHeight,
              targetOffset,
              basePosition,
              dimensions,
              // Make sure string options are treated as CSS selectors
              target =
                typeof options.of === 'string'
                  ? $(document).find(options.of)
                  : $(options.of),
              within = $.position.getWithinInfo(options.within),
              scrollInfo = $.position.getScrollInfo(within),
              collision = (options.collision || 'flip').split(' '),
              offsets = {}

            dimensions = getDimensions(target)
            if (target[0].preventDefault) {
              // Force left top to allow flipping
              options.at = 'left top'
            }
            targetWidth = dimensions.width
            targetHeight = dimensions.height
            targetOffset = dimensions.offset

            // Clone to reuse original targetOffset later
            basePosition = $.extend({}, targetOffset)

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each(['my', 'at'], function () {
              var pos = (options[this] || '').split(' '),
                horizontalOffset,
                verticalOffset

              if (pos.length === 1) {
                pos = rhorizontal.test(pos[0])
                  ? pos.concat(['center'])
                  : rvertical.test(pos[0])
                    ? ['center'].concat(pos)
                    : ['center', 'center']
              }
              pos[0] = rhorizontal.test(pos[0]) ? pos[0] : 'center'
              pos[1] = rvertical.test(pos[1]) ? pos[1] : 'center'

              // Calculate offsets
              horizontalOffset = roffset.exec(pos[0])
              verticalOffset = roffset.exec(pos[1])
              offsets[this] = [
                horizontalOffset ? horizontalOffset[0] : 0,
                verticalOffset ? verticalOffset[0] : 0
              ]

              // Reduce to just the positions without the offsets
              options[this] = [
                rposition.exec(pos[0])[0],
                rposition.exec(pos[1])[0]
              ]
            })

            // Normalize collision option
            if (collision.length === 1) {
              collision[1] = collision[0]
            }

            if (options.at[0] === 'right') {
              basePosition.left += targetWidth
            } else if (options.at[0] === 'center') {
              basePosition.left += targetWidth / 2
            }

            if (options.at[1] === 'bottom') {
              basePosition.top += targetHeight
            } else if (options.at[1] === 'center') {
              basePosition.top += targetHeight / 2
            }

            atOffset = getOffsets(offsets.at, targetWidth, targetHeight)
            basePosition.left += atOffset[0]
            basePosition.top += atOffset[1]

            return this.each(function () {
              var collisionPosition,
                using,
                elem = $(this),
                elemWidth = elem.outerWidth(),
                elemHeight = elem.outerHeight(),
                marginLeft = parseCss(this, 'marginLeft'),
                marginTop = parseCss(this, 'marginTop'),
                collisionWidth =
                  elemWidth +
                  marginLeft +
                  parseCss(this, 'marginRight') +
                  scrollInfo.width,
                collisionHeight =
                  elemHeight +
                  marginTop +
                  parseCss(this, 'marginBottom') +
                  scrollInfo.height,
                position = $.extend({}, basePosition),
                myOffset = getOffsets(
                  offsets.my,
                  elem.outerWidth(),
                  elem.outerHeight()
                )

              if (options.my[0] === 'right') {
                position.left -= elemWidth
              } else if (options.my[0] === 'center') {
                position.left -= elemWidth / 2
              }

              if (options.my[1] === 'bottom') {
                position.top -= elemHeight
              } else if (options.my[1] === 'center') {
                position.top -= elemHeight / 2
              }

              position.left += myOffset[0]
              position.top += myOffset[1]

              collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
              }

              $.each(['left', 'top'], function (i, dir) {
                if ($.ui.position[collision[i]]) {
                  $.ui.position[collision[i]][dir](position, {
                    targetWidth: targetWidth,
                    targetHeight: targetHeight,
                    elemWidth: elemWidth,
                    elemHeight: elemHeight,
                    collisionPosition: collisionPosition,
                    collisionWidth: collisionWidth,
                    collisionHeight: collisionHeight,
                    offset: [
                      atOffset[0] + myOffset[0],
                      atOffset[1] + myOffset[1]
                    ],
                    my: options.my,
                    at: options.at,
                    within: within,
                    elem: elem
                  })
                }
              })

              if (options.using) {
                // Adds feedback as second argument to using callback, if present
                using = function (props) {
                  var left = targetOffset.left - position.left,
                    right = left + targetWidth - elemWidth,
                    top = targetOffset.top - position.top,
                    bottom = top + targetHeight - elemHeight,
                    feedback = {
                      target: {
                        element: target,
                        left: targetOffset.left,
                        top: targetOffset.top,
                        width: targetWidth,
                        height: targetHeight
                      },
                      element: {
                        element: elem,
                        left: position.left,
                        top: position.top,
                        width: elemWidth,
                        height: elemHeight
                      },
                      horizontal:
                        right < 0 ? 'left' : left > 0 ? 'right' : 'center',
                      vertical:
                        bottom < 0 ? 'top' : top > 0 ? 'bottom' : 'middle'
                    }
                  if (
                    targetWidth < elemWidth &&
                    abs(left + right) < targetWidth
                  ) {
                    feedback.horizontal = 'center'
                  }
                  if (
                    targetHeight < elemHeight &&
                    abs(top + bottom) < targetHeight
                  ) {
                    feedback.vertical = 'middle'
                  }
                  if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                    feedback.important = 'horizontal'
                  } else {
                    feedback.important = 'vertical'
                  }
                  options.using.call(this, props, feedback)
                }
              }

              elem.offset($.extend(position, { using: using }))
            })
          }

          $.ui.position = {
            fit: {
              left: function (position, data) {
                var within = data.within,
                  withinOffset = within.isWindow
                    ? within.scrollLeft
                    : within.offset.left,
                  outerWidth = within.width,
                  collisionPosLeft =
                    position.left - data.collisionPosition.marginLeft,
                  overLeft = withinOffset - collisionPosLeft,
                  overRight =
                    collisionPosLeft +
                    data.collisionWidth -
                    outerWidth -
                    withinOffset,
                  newOverRight

                // Element is wider than within
                if (data.collisionWidth > outerWidth) {
                  // Element is initially over the left side of within
                  if (overLeft > 0 && overRight <= 0) {
                    newOverRight =
                      position.left +
                      overLeft +
                      data.collisionWidth -
                      outerWidth -
                      withinOffset
                    position.left += overLeft - newOverRight

                    // Element is initially over right side of within
                  } else if (overRight > 0 && overLeft <= 0) {
                    position.left = withinOffset

                    // Element is initially over both left and right sides of within
                  } else {
                    if (overLeft > overRight) {
                      position.left =
                        withinOffset + outerWidth - data.collisionWidth
                    } else {
                      position.left = withinOffset
                    }
                  }

                  // Too far left -> align with left edge
                } else if (overLeft > 0) {
                  position.left += overLeft

                  // Too far right -> align with right edge
                } else if (overRight > 0) {
                  position.left -= overRight

                  // Adjust based on position and margin
                } else {
                  position.left = max(
                    position.left - collisionPosLeft,
                    position.left
                  )
                }
              },
              top: function (position, data) {
                var within = data.within,
                  withinOffset = within.isWindow
                    ? within.scrollTop
                    : within.offset.top,
                  outerHeight = data.within.height,
                  collisionPosTop =
                    position.top - data.collisionPosition.marginTop,
                  overTop = withinOffset - collisionPosTop,
                  overBottom =
                    collisionPosTop +
                    data.collisionHeight -
                    outerHeight -
                    withinOffset,
                  newOverBottom

                // Element is taller than within
                if (data.collisionHeight > outerHeight) {
                  // Element is initially over the top of within
                  if (overTop > 0 && overBottom <= 0) {
                    newOverBottom =
                      position.top +
                      overTop +
                      data.collisionHeight -
                      outerHeight -
                      withinOffset
                    position.top += overTop - newOverBottom

                    // Element is initially over bottom of within
                  } else if (overBottom > 0 && overTop <= 0) {
                    position.top = withinOffset

                    // Element is initially over both top and bottom of within
                  } else {
                    if (overTop > overBottom) {
                      position.top =
                        withinOffset + outerHeight - data.collisionHeight
                    } else {
                      position.top = withinOffset
                    }
                  }

                  // Too far up -> align with top
                } else if (overTop > 0) {
                  position.top += overTop

                  // Too far down -> align with bottom edge
                } else if (overBottom > 0) {
                  position.top -= overBottom

                  // Adjust based on position and margin
                } else {
                  position.top = max(
                    position.top - collisionPosTop,
                    position.top
                  )
                }
              }
            },
            flip: {
              left: function (position, data) {
                var within = data.within,
                  withinOffset = within.offset.left + within.scrollLeft,
                  outerWidth = within.width,
                  offsetLeft = within.isWindow
                    ? within.scrollLeft
                    : within.offset.left,
                  collisionPosLeft =
                    position.left - data.collisionPosition.marginLeft,
                  overLeft = collisionPosLeft - offsetLeft,
                  overRight =
                    collisionPosLeft +
                    data.collisionWidth -
                    outerWidth -
                    offsetLeft,
                  myOffset =
                    data.my[0] === 'left'
                      ? -data.elemWidth
                      : data.my[0] === 'right'
                        ? data.elemWidth
                        : 0,
                  atOffset =
                    data.at[0] === 'left'
                      ? data.targetWidth
                      : data.at[0] === 'right'
                        ? -data.targetWidth
                        : 0,
                  offset = -2 * data.offset[0],
                  newOverRight,
                  newOverLeft

                if (overLeft < 0) {
                  newOverRight =
                    position.left +
                    myOffset +
                    atOffset +
                    offset +
                    data.collisionWidth -
                    outerWidth -
                    withinOffset
                  if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                    position.left += myOffset + atOffset + offset
                  }
                } else if (overRight > 0) {
                  newOverLeft =
                    position.left -
                    data.collisionPosition.marginLeft +
                    myOffset +
                    atOffset +
                    offset -
                    offsetLeft
                  if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                    position.left += myOffset + atOffset + offset
                  }
                }
              },
              top: function (position, data) {
                var within = data.within,
                  withinOffset = within.offset.top + within.scrollTop,
                  outerHeight = within.height,
                  offsetTop = within.isWindow
                    ? within.scrollTop
                    : within.offset.top,
                  collisionPosTop =
                    position.top - data.collisionPosition.marginTop,
                  overTop = collisionPosTop - offsetTop,
                  overBottom =
                    collisionPosTop +
                    data.collisionHeight -
                    outerHeight -
                    offsetTop,
                  top = data.my[1] === 'top',
                  myOffset = top
                    ? -data.elemHeight
                    : data.my[1] === 'bottom'
                      ? data.elemHeight
                      : 0,
                  atOffset =
                    data.at[1] === 'top'
                      ? data.targetHeight
                      : data.at[1] === 'bottom'
                        ? -data.targetHeight
                        : 0,
                  offset = -2 * data.offset[1],
                  newOverTop,
                  newOverBottom
                if (overTop < 0) {
                  newOverBottom =
                    position.top +
                    myOffset +
                    atOffset +
                    offset +
                    data.collisionHeight -
                    outerHeight -
                    withinOffset
                  if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                    position.top += myOffset + atOffset + offset
                  }
                } else if (overBottom > 0) {
                  newOverTop =
                    position.top -
                    data.collisionPosition.marginTop +
                    myOffset +
                    atOffset +
                    offset -
                    offsetTop
                  if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                    position.top += myOffset + atOffset + offset
                  }
                }
              }
            },
            flipfit: {
              left: function () {
                $.ui.position.flip.left.apply(this, arguments)
                $.ui.position.fit.left.apply(this, arguments)
              },
              top: function () {
                $.ui.position.flip.top.apply(this, arguments)
                $.ui.position.fit.top.apply(this, arguments)
              }
            }
          }
        })()

        return $.ui.position
      })

      /***/
    },

    /***/ 1440: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.safeActiveElement = function (document) {
          var activeElement

          // Support: IE 9 only
          // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
          try {
            activeElement = document.activeElement
          } catch (error) {
            activeElement = document.body
          }

          // Support: IE 9 - 11 only
          // IE may return null instead of an element
          // Interestingly, this only seems to occur when NOT in an iframe
          if (!activeElement) {
            activeElement = document.body
          }

          // Support: IE 11 only
          // IE11 returns a seemingly empty object in some cases when accessing
          // document.activeElement from an <iframe>
          if (!activeElement.nodeName) {
            activeElement = document.body
          }

          return activeElement
        })
      })

      /***/
    },

    /***/ 192: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.ui.safeBlur = function (element) {
          // Support: IE9 - 10 only
          // If the <body> is blurred, IE will switch windows, see #9420
          if (element && element.nodeName.toLowerCase() !== 'body') {
            $(element).trigger('blur')
          }
        })
      })

      /***/
    },

    /***/ 464: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Scroll Parent 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: scrollParent
      //>>group: Core
      //>>description: Get the closest ancestor element that is scrollable.
      //>>docs: http://api.jqueryui.com/scrollParent/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return ($.fn.scrollParent = function (includeHidden) {
          var position = this.css('position'),
            excludeStaticParent = position === 'absolute',
            overflowRegex = includeHidden
              ? /(auto|scroll|hidden)/
              : /(auto|scroll)/,
            scrollParent = this.parents()
              .filter(function () {
                var parent = $(this)
                if (
                  excludeStaticParent &&
                  parent.css('position') === 'static'
                ) {
                  return false
                }
                return overflowRegex.test(
                  parent.css('overflow') +
                    parent.css('overflow-y') +
                    parent.css('overflow-x')
                )
              })
              .eq(0)

          return position === 'fixed' || !scrollParent.length
            ? $(this[0].ownerDocument || document)
            : scrollParent
        })
      })

      /***/
    },

    /***/ 3614: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Tabbable 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: :tabbable Selector
      //>>group: Core
      //>>description: Selects elements which can be tabbed to.
      //>>docs: http://api.jqueryui.com/tabbable-selector/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592),
            __webpack_require__(5436)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.extend($.expr.pseudos, {
          tabbable: function (element) {
            var tabIndex = $.attr(element, 'tabindex'),
              hasTabindex = tabIndex != null
            return (
              (!hasTabindex || tabIndex >= 0) &&
              $.ui.focusable(element, hasTabindex)
            )
          }
        })
      })

      /***/
    },

    /***/ 9138: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Unique ID 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: uniqueId
      //>>group: Core
      //>>description: Functions to generate and remove uniqueId's
      //>>docs: http://api.jqueryui.com/uniqueId/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.fn.extend({
          uniqueId: (function () {
            var uuid = 0

            return function () {
              return this.each(function () {
                if (!this.id) {
                  this.id = 'ui-id-' + ++uuid
                }
              })
            }
          })(),

          removeUniqueId: function () {
            return this.each(function () {
              if (/^ui-id-\d+$/.test(this.id)) {
                $(this).removeAttr('id')
              }
            })
          }
        })
      })

      /***/
    },

    /***/ 5592: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__
      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9755)]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.ui = $.ui || {}

        return ($.ui.version = '1.13.2')
      })

      /***/
    },

    /***/ 6891: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Widget 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Widget
      //>>group: Core
      //>>description: Provides a factory for creating stateful widgets with a common API.
      //>>docs: http://api.jqueryui.com/jQuery.widget/
      //>>demos: http://jqueryui.com/widget/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(5592)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        var widgetUuid = 0
        var widgetHasOwnProperty = Array.prototype.hasOwnProperty
        var widgetSlice = Array.prototype.slice

        $.cleanData = (function (orig) {
          return function (elems) {
            var events, elem, i
            for (i = 0; (elem = elems[i]) != null; i++) {
              // Only trigger remove when necessary to save time
              events = $._data(elem, 'events')
              if (events && events.remove) {
                $(elem).triggerHandler('remove')
              }
            }
            orig(elems)
          }
        })($.cleanData)

        $.widget = function (name, base, prototype) {
          var existingConstructor, constructor, basePrototype

          // ProxiedPrototype allows the provided prototype to remain unmodified
          // so that it can be used as a mixin for multiple widgets (#8876)
          var proxiedPrototype = {}

          var namespace = name.split('.')[0]
          name = name.split('.')[1]
          var fullName = namespace + '-' + name

          if (!prototype) {
            prototype = base
            base = $.Widget
          }

          if (Array.isArray(prototype)) {
            prototype = $.extend.apply(null, [{}].concat(prototype))
          }

          // Create selector for plugin
          $.expr.pseudos[fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName)
          }

          $[namespace] = $[namespace] || {}
          existingConstructor = $[namespace][name]
          constructor = $[namespace][name] = function (options, element) {
            // Allow instantiation without "new" keyword
            if (!this || !this._createWidget) {
              return new constructor(options, element)
            }

            // Allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
              this._createWidget(options, element)
            }
          }

          // Extend with the existing constructor to carry over any static properties
          $.extend(constructor, existingConstructor, {
            version: prototype.version,

            // Copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),

            // Track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
          })

          basePrototype = new base()

          // We need to make the options hash a property directly on the new instance
          // otherwise we'll modify the options hash on the prototype that we're
          // inheriting from
          basePrototype.options = $.widget.extend({}, basePrototype.options)
          $.each(prototype, function (prop, value) {
            if (typeof value !== 'function') {
              proxiedPrototype[prop] = value
              return
            }
            proxiedPrototype[prop] = (function () {
              function _super() {
                return base.prototype[prop].apply(this, arguments)
              }

              function _superApply(args) {
                return base.prototype[prop].apply(this, args)
              }

              return function () {
                var __super = this._super
                var __superApply = this._superApply
                var returnValue

                this._super = _super
                this._superApply = _superApply

                returnValue = value.apply(this, arguments)

                this._super = __super
                this._superApply = __superApply

                return returnValue
              }
            })()
          })
          constructor.prototype = $.widget.extend(
            basePrototype,
            {
              // TODO: remove support for widgetEventPrefix
              // always use the name + a colon as the prefix, e.g., draggable:start
              // don't prefix for widgets that aren't DOM-based
              widgetEventPrefix: existingConstructor
                ? basePrototype.widgetEventPrefix || name
                : name
            },
            proxiedPrototype,
            {
              constructor: constructor,
              namespace: namespace,
              widgetName: name,
              widgetFullName: fullName
            }
          )

          // If this widget is being redefined then we need to find all widgets that
          // are inheriting from it and redefine all of them so that they inherit from
          // the new version of this widget. We're essentially trying to replace one
          // level in the prototype chain.
          if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
              var childPrototype = child.prototype

              // Redefine the child widget using the same prototype that was
              // originally used, but inherit from the new version of the base
              $.widget(
                childPrototype.namespace + '.' + childPrototype.widgetName,
                constructor,
                child._proto
              )
            })

            // Remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors
          } else {
            base._childConstructors.push(constructor)
          }

          $.widget.bridge(name, constructor)

          return constructor
        }

        $.widget.extend = function (target) {
          var input = widgetSlice.call(arguments, 1)
          var inputIndex = 0
          var inputLength = input.length
          var key
          var value

          for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
              value = input[inputIndex][key]
              if (
                widgetHasOwnProperty.call(input[inputIndex], key) &&
                value !== undefined
              ) {
                // Clone objects
                if ($.isPlainObject(value)) {
                  target[key] = $.isPlainObject(target[key])
                    ? $.widget.extend({}, target[key], value)
                    : // Don't extend strings, arrays, etc. with objects
                      $.widget.extend({}, value)

                  // Copy everything else by reference
                } else {
                  target[key] = value
                }
              }
            }
          }
          return target
        }

        $.widget.bridge = function (name, object) {
          var fullName = object.prototype.widgetFullName || name
          $.fn[name] = function (options) {
            var isMethodCall = typeof options === 'string'
            var args = widgetSlice.call(arguments, 1)
            var returnValue = this

            if (isMethodCall) {
              // If this is an empty collection, we need to have the instance method
              // return undefined instead of the jQuery instance
              if (!this.length && options === 'instance') {
                returnValue = undefined
              } else {
                this.each(function () {
                  var methodValue
                  var instance = $.data(this, fullName)

                  if (options === 'instance') {
                    returnValue = instance
                    return false
                  }

                  if (!instance) {
                    return $.error(
                      'cannot call methods on ' +
                        name +
                        ' prior to initialization; ' +
                        "attempted to call method '" +
                        options +
                        "'"
                    )
                  }

                  if (
                    typeof instance[options] !== 'function' ||
                    options.charAt(0) === '_'
                  ) {
                    return $.error(
                      "no such method '" +
                        options +
                        "' for " +
                        name +
                        ' widget instance'
                    )
                  }

                  methodValue = instance[options].apply(instance, args)

                  if (methodValue !== instance && methodValue !== undefined) {
                    returnValue =
                      methodValue && methodValue.jquery
                        ? returnValue.pushStack(methodValue.get())
                        : methodValue
                    return false
                  }
                })
              }
            } else {
              // Allow multiple hashes to be passed on init
              if (args.length) {
                options = $.widget.extend.apply(null, [options].concat(args))
              }

              this.each(function () {
                var instance = $.data(this, fullName)
                if (instance) {
                  instance.option(options || {})
                  if (instance._init) {
                    instance._init()
                  }
                } else {
                  $.data(this, fullName, new object(options, this))
                }
              })
            }

            return returnValue
          }
        }

        $.Widget = function (/* options, element */) {}
        $.Widget._childConstructors = []

        $.Widget.prototype = {
          widgetName: 'widget',
          widgetEventPrefix: '',
          defaultElement: '<div>',

          options: {
            classes: {},
            disabled: false,

            // Callbacks
            create: null
          },

          _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0]
            this.element = $(element)
            this.uuid = widgetUuid++
            this.eventNamespace = '.' + this.widgetName + this.uuid

            this.bindings = $()
            this.hoverable = $()
            this.focusable = $()
            this.classesElementLookup = {}

            if (element !== this) {
              $.data(element, this.widgetFullName, this)
              this._on(true, this.element, {
                remove: function (event) {
                  if (event.target === element) {
                    this.destroy()
                  }
                }
              })
              this.document = $(
                element.style
                  ? // Element within the document
                    element.ownerDocument
                  : // Element is window or document
                    element.document || element
              )
              this.window = $(
                this.document[0].defaultView || this.document[0].parentWindow
              )
            }

            this.options = $.widget.extend(
              {},
              this.options,
              this._getCreateOptions(),
              options
            )

            this._create()

            if (this.options.disabled) {
              this._setOptionDisabled(this.options.disabled)
            }

            this._trigger('create', null, this._getCreateEventData())
            this._init()
          },

          _getCreateOptions: function () {
            return {}
          },

          _getCreateEventData: $.noop,

          _create: $.noop,

          _init: $.noop,

          destroy: function () {
            var that = this

            this._destroy()
            $.each(this.classesElementLookup, function (key, value) {
              that._removeClass(value, key)
            })

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
              .off(this.eventNamespace)
              .removeData(this.widgetFullName)
            this.widget().off(this.eventNamespace).removeAttr('aria-disabled')

            // Clean up events and states
            this.bindings.off(this.eventNamespace)
          },

          _destroy: $.noop,

          widget: function () {
            return this.element
          },

          option: function (key, value) {
            var options = key
            var parts
            var curOption
            var i

            if (arguments.length === 0) {
              // Don't return a reference to the internal hash
              return $.widget.extend({}, this.options)
            }

            if (typeof key === 'string') {
              // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
              options = {}
              parts = key.split('.')
              key = parts.shift()
              if (parts.length) {
                curOption = options[key] = $.widget.extend(
                  {},
                  this.options[key]
                )
                for (i = 0; i < parts.length - 1; i++) {
                  curOption[parts[i]] = curOption[parts[i]] || {}
                  curOption = curOption[parts[i]]
                }
                key = parts.pop()
                if (arguments.length === 1) {
                  return curOption[key] === undefined ? null : curOption[key]
                }
                curOption[key] = value
              } else {
                if (arguments.length === 1) {
                  return this.options[key] === undefined
                    ? null
                    : this.options[key]
                }
                options[key] = value
              }
            }

            this._setOptions(options)

            return this
          },

          _setOptions: function (options) {
            var key

            for (key in options) {
              this._setOption(key, options[key])
            }

            return this
          },

          _setOption: function (key, value) {
            if (key === 'classes') {
              this._setOptionClasses(value)
            }

            this.options[key] = value

            if (key === 'disabled') {
              this._setOptionDisabled(value)
            }

            return this
          },

          _setOptionClasses: function (value) {
            var classKey, elements, currentElements

            for (classKey in value) {
              currentElements = this.classesElementLookup[classKey]
              if (
                value[classKey] === this.options.classes[classKey] ||
                !currentElements ||
                !currentElements.length
              ) {
                continue
              }

              // We are doing this to create a new jQuery object because the _removeClass() call
              // on the next line is going to destroy the reference to the current elements being
              // tracked. We need to save a copy of this collection so that we can add the new classes
              // below.
              elements = $(currentElements.get())
              this._removeClass(currentElements, classKey)

              // We don't use _addClass() here, because that uses this.options.classes
              // for generating the string of classes. We want to use the value passed in from
              // _setOption(), this is the new value of the classes option which was passed to
              // _setOption(). We pass this value directly to _classes().
              elements.addClass(
                this._classes({
                  element: elements,
                  keys: classKey,
                  classes: value,
                  add: true
                })
              )
            }
          },

          _setOptionDisabled: function (value) {
            this._toggleClass(
              this.widget(),
              this.widgetFullName + '-disabled',
              null,
              !!value
            )

            // If the widget is becoming disabled, then nothing is interactive
            if (value) {
              this._removeClass(this.hoverable, null, 'ui-state-hover')
              this._removeClass(this.focusable, null, 'ui-state-focus')
            }
          },

          enable: function () {
            return this._setOptions({ disabled: false })
          },

          disable: function () {
            return this._setOptions({ disabled: true })
          },

          _classes: function (options) {
            var full = []
            var that = this

            options = $.extend(
              {
                element: this.element,
                classes: this.options.classes || {}
              },
              options
            )

            function bindRemoveEvent() {
              var nodesToBind = []

              options.element.each(function (_, element) {
                var isTracked = $.map(
                  that.classesElementLookup,
                  function (elements) {
                    return elements
                  }
                ).some(function (elements) {
                  return elements.is(element)
                })

                if (!isTracked) {
                  nodesToBind.push(element)
                }
              })

              that._on($(nodesToBind), {
                remove: '_untrackClassesElement'
              })
            }

            function processClassString(classes, checkOption) {
              var current, i
              for (i = 0; i < classes.length; i++) {
                current = that.classesElementLookup[classes[i]] || $()
                if (options.add) {
                  bindRemoveEvent()
                  current = $(
                    $.uniqueSort(current.get().concat(options.element.get()))
                  )
                } else {
                  current = $(current.not(options.element).get())
                }
                that.classesElementLookup[classes[i]] = current
                full.push(classes[i])
                if (checkOption && options.classes[classes[i]]) {
                  full.push(options.classes[classes[i]])
                }
              }
            }

            if (options.keys) {
              processClassString(options.keys.match(/\S+/g) || [], true)
            }
            if (options.extra) {
              processClassString(options.extra.match(/\S+/g) || [])
            }

            return full.join(' ')
          },

          _untrackClassesElement: function (event) {
            var that = this
            $.each(that.classesElementLookup, function (key, value) {
              if ($.inArray(event.target, value) !== -1) {
                that.classesElementLookup[key] = $(
                  value.not(event.target).get()
                )
              }
            })

            this._off($(event.target))
          },

          _removeClass: function (element, keys, extra) {
            return this._toggleClass(element, keys, extra, false)
          },

          _addClass: function (element, keys, extra) {
            return this._toggleClass(element, keys, extra, true)
          },

          _toggleClass: function (element, keys, extra, add) {
            add = typeof add === 'boolean' ? add : extra
            var shift = typeof element === 'string' || element === null,
              options = {
                extra: shift ? keys : extra,
                keys: shift ? element : keys,
                element: shift ? this.element : element,
                add: add
              }
            options.element.toggleClass(this._classes(options), add)
            return this
          },

          _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement
            var instance = this

            // No suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== 'boolean') {
              handlers = element
              element = suppressDisabledCheck
              suppressDisabledCheck = false
            }

            // No element argument, shuffle and use this.element
            if (!handlers) {
              handlers = element
              element = this.element
              delegateElement = this.widget()
            } else {
              element = delegateElement = $(element)
              this.bindings = this.bindings.add(element)
            }

            $.each(handlers, function (event, handler) {
              function handlerProxy() {
                // Allow widgets to customize the disabled handling
                // - disabled as an array instead of boolean
                // - disabled class as method for disabling individual parts
                if (
                  !suppressDisabledCheck &&
                  (instance.options.disabled === true ||
                    $(this).hasClass('ui-state-disabled'))
                ) {
                  return
                }
                return (
                  typeof handler === 'string' ? instance[handler] : handler
                ).apply(instance, arguments)
              }

              // Copy the guid so direct unbinding works
              if (typeof handler !== 'string') {
                handlerProxy.guid = handler.guid =
                  handler.guid || handlerProxy.guid || $.guid++
              }

              var match = event.match(/^([\w:-]*)\s*(.*)$/)
              var eventName = match[1] + instance.eventNamespace
              var selector = match[2]

              if (selector) {
                delegateElement.on(eventName, selector, handlerProxy)
              } else {
                element.on(eventName, handlerProxy)
              }
            })
          },

          _off: function (element, eventName) {
            eventName =
              (eventName || '').split(' ').join(this.eventNamespace + ' ') +
              this.eventNamespace
            element.off(eventName)

            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $(this.bindings.not(element).get())
            this.focusable = $(this.focusable.not(element).get())
            this.hoverable = $(this.hoverable.not(element).get())
          },

          _delay: function (handler, delay) {
            function handlerProxy() {
              return (
                typeof handler === 'string' ? instance[handler] : handler
              ).apply(instance, arguments)
            }
            var instance = this
            return setTimeout(handlerProxy, delay || 0)
          },

          _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element)
            this._on(element, {
              mouseenter: function (event) {
                this._addClass($(event.currentTarget), null, 'ui-state-hover')
              },
              mouseleave: function (event) {
                this._removeClass(
                  $(event.currentTarget),
                  null,
                  'ui-state-hover'
                )
              }
            })
          },

          _focusable: function (element) {
            this.focusable = this.focusable.add(element)
            this._on(element, {
              focusin: function (event) {
                this._addClass($(event.currentTarget), null, 'ui-state-focus')
              },
              focusout: function (event) {
                this._removeClass(
                  $(event.currentTarget),
                  null,
                  'ui-state-focus'
                )
              }
            })
          },

          _trigger: function (type, event, data) {
            var prop, orig
            var callback = this.options[type]

            data = data || {}
            event = $.Event(event)
            event.type = (
              type === this.widgetEventPrefix
                ? type
                : this.widgetEventPrefix + type
            ).toLowerCase()

            // The original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0]

            // Copy original event properties over to the new event
            orig = event.originalEvent
            if (orig) {
              for (prop in orig) {
                if (!(prop in event)) {
                  event[prop] = orig[prop]
                }
              }
            }

            this.element.trigger(event, data)
            return !(
              (typeof callback === 'function' &&
                callback.apply(this.element[0], [event].concat(data)) ===
                  false) ||
              event.isDefaultPrevented()
            )
          }
        }

        $.each(
          { show: 'fadeIn', hide: 'fadeOut' },
          function (method, defaultEffect) {
            $.Widget.prototype['_' + method] = function (
              element,
              options,
              callback
            ) {
              if (typeof options === 'string') {
                options = { effect: options }
              }

              var hasOptions
              var effectName = !options
                ? method
                : options === true || typeof options === 'number'
                  ? defaultEffect
                  : options.effect || defaultEffect

              options = options || {}
              if (typeof options === 'number') {
                options = { duration: options }
              } else if (options === true) {
                options = {}
              }

              hasOptions = !$.isEmptyObject(options)
              options.complete = callback

              if (options.delay) {
                element.delay(options.delay)
              }

              if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options)
              } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback)
              } else {
                element.queue(function (next) {
                  $(this)[method]()
                  if (callback) {
                    callback.call(element[0])
                  }
                  next()
                })
              }
            }
          }
        )

        return $.widget
      })

      /***/
    },

    /***/ 2993: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Autocomplete 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Autocomplete
      //>>group: Widgets
      //>>description: Lists suggested words as the user is typing.
      //>>docs: http://api.jqueryui.com/autocomplete/
      //>>demos: http://jqueryui.com/autocomplete/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/autocomplete.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(8851),
            __webpack_require__(7053),
            __webpack_require__(1822),
            __webpack_require__(1440),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.autocomplete', {
          version: '1.13.2',
          defaultElement: '<input>',
          options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
              my: 'left top',
              at: 'left bottom',
              collision: 'none'
            },
            source: null,

            // Callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
          },

          requestIndex: 0,
          pending: 0,
          liveRegionTimer: null,

          _create: function () {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress,
              suppressKeyPressRepeat,
              suppressInput,
              nodeName = this.element[0].nodeName.toLowerCase(),
              isTextarea = nodeName === 'textarea',
              isInput = nodeName === 'input'

            // Textareas are always multi-line
            // Inputs are always single-line, even if inside a contentEditable element
            // IE also treats inputs as contentEditable
            // All other element types are determined by whether or not they're contentEditable
            this.isMultiLine =
              isTextarea || (!isInput && this._isContentEditable(this.element))

            this.valueMethod =
              this.element[isTextarea || isInput ? 'val' : 'text']
            this.isNewMenu = true

            this._addClass('ui-autocomplete-input')
            this.element.attr('autocomplete', 'off')

            this._on(this.element, {
              keydown: function (event) {
                if (this.element.prop('readOnly')) {
                  suppressKeyPress = true
                  suppressInput = true
                  suppressKeyPressRepeat = true
                  return
                }

                suppressKeyPress = false
                suppressInput = false
                suppressKeyPressRepeat = false
                var keyCode = $.ui.keyCode
                switch (event.keyCode) {
                  case keyCode.PAGE_UP:
                    suppressKeyPress = true
                    this._move('previousPage', event)
                    break
                  case keyCode.PAGE_DOWN:
                    suppressKeyPress = true
                    this._move('nextPage', event)
                    break
                  case keyCode.UP:
                    suppressKeyPress = true
                    this._keyEvent('previous', event)
                    break
                  case keyCode.DOWN:
                    suppressKeyPress = true
                    this._keyEvent('next', event)
                    break
                  case keyCode.ENTER:
                    // when menu is open and has focus
                    if (this.menu.active) {
                      // #6055 - Opera still allows the keypress to occur
                      // which causes forms to submit
                      suppressKeyPress = true
                      event.preventDefault()
                      this.menu.select(event)
                    }
                    break
                  case keyCode.TAB:
                    if (this.menu.active) {
                      this.menu.select(event)
                    }
                    break
                  case keyCode.ESCAPE:
                    if (this.menu.element.is(':visible')) {
                      if (!this.isMultiLine) {
                        this._value(this.term)
                      }
                      this.close(event)

                      // Different browsers have different default behavior for escape
                      // Single press can mean undo or clear
                      // Double press in IE means clear the whole form
                      event.preventDefault()
                    }
                    break
                  default:
                    suppressKeyPressRepeat = true

                    // search timeout should be triggered before the input value is changed
                    this._searchTimeout(event)
                    break
                }
              },
              keypress: function (event) {
                if (suppressKeyPress) {
                  suppressKeyPress = false
                  if (!this.isMultiLine || this.menu.element.is(':visible')) {
                    event.preventDefault()
                  }
                  return
                }
                if (suppressKeyPressRepeat) {
                  return
                }

                // Replicate some key handlers to allow them to repeat in Firefox and Opera
                var keyCode = $.ui.keyCode
                switch (event.keyCode) {
                  case keyCode.PAGE_UP:
                    this._move('previousPage', event)
                    break
                  case keyCode.PAGE_DOWN:
                    this._move('nextPage', event)
                    break
                  case keyCode.UP:
                    this._keyEvent('previous', event)
                    break
                  case keyCode.DOWN:
                    this._keyEvent('next', event)
                    break
                }
              },
              input: function (event) {
                if (suppressInput) {
                  suppressInput = false
                  event.preventDefault()
                  return
                }
                this._searchTimeout(event)
              },
              focus: function () {
                this.selectedItem = null
                this.previous = this._value()
              },
              blur: function (event) {
                clearTimeout(this.searching)
                this.close(event)
                this._change(event)
              }
            })

            this._initSource()
            this.menu = $('<ul>')
              .appendTo(this._appendTo())
              .menu({
                // disable ARIA support, the live region takes care of that
                role: null
              })
              .hide()

              // Support: IE 11 only, Edge <= 14
              // For other browsers, we preventDefault() on the mousedown event
              // to keep the dropdown from taking focus from the input. This doesn't
              // work for IE/Edge, causing problems with selection and scrolling (#9638)
              // Happily, IE and Edge support an "unselectable" attribute that
              // prevents an element from receiving focus, exactly what we want here.
              .attr({
                unselectable: 'on'
              })
              .menu('instance')

            this._addClass(this.menu.element, 'ui-autocomplete', 'ui-front')
            this._on(this.menu.element, {
              mousedown: function (event) {
                // Prevent moving focus out of the text field
                event.preventDefault()
              },
              menufocus: function (event, ui) {
                var label, item

                // support: Firefox
                // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                if (this.isNewMenu) {
                  this.isNewMenu = false
                  if (
                    event.originalEvent &&
                    /^mouse/.test(event.originalEvent.type)
                  ) {
                    this.menu.blur()

                    this.document.one('mousemove', function () {
                      $(event.target).trigger(event.originalEvent)
                    })

                    return
                  }
                }

                item = ui.item.data('ui-autocomplete-item')
                if (false !== this._trigger('focus', event, { item: item })) {
                  // use value to match what will end up in the input, if it was a key event
                  if (
                    event.originalEvent &&
                    /^key/.test(event.originalEvent.type)
                  ) {
                    this._value(item.value)
                  }
                }

                // Announce the value in the liveRegion
                label = ui.item.attr('aria-label') || item.value
                if (label && String.prototype.trim.call(label).length) {
                  clearTimeout(this.liveRegionTimer)
                  this.liveRegionTimer = this._delay(function () {
                    this.liveRegion.html($('<div>').text(label))
                  }, 100)
                }
              },
              menuselect: function (event, ui) {
                var item = ui.item.data('ui-autocomplete-item'),
                  previous = this.previous

                // Only trigger when focus was lost (click on menu)
                if (
                  this.element[0] !== $.ui.safeActiveElement(this.document[0])
                ) {
                  this.element.trigger('focus')
                  this.previous = previous

                  // #6109 - IE triggers two focus events and the second
                  // is asynchronous, so we need to reset the previous
                  // term synchronously and asynchronously :-(
                  this._delay(function () {
                    this.previous = previous
                    this.selectedItem = item
                  })
                }

                if (false !== this._trigger('select', event, { item: item })) {
                  this._value(item.value)
                }

                // reset the term after the select event
                // this allows custom select handling to work properly
                this.term = this._value()

                this.close(event)
                this.selectedItem = item
              }
            })

            this.liveRegion = $('<div>', {
              role: 'status',
              'aria-live': 'assertive',
              'aria-relevant': 'additions'
            }).appendTo(this.document[0].body)

            this._addClass(this.liveRegion, null, 'ui-helper-hidden-accessible')

            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
              beforeunload: function () {
                this.element.removeAttr('autocomplete')
              }
            })
          },

          _destroy: function () {
            clearTimeout(this.searching)
            this.element.removeAttr('autocomplete')
            this.menu.element.remove()
            this.liveRegion.remove()
          },

          _setOption: function (key, value) {
            this._super(key, value)
            if (key === 'source') {
              this._initSource()
            }
            if (key === 'appendTo') {
              this.menu.element.appendTo(this._appendTo())
            }
            if (key === 'disabled' && value && this.xhr) {
              this.xhr.abort()
            }
          },

          _isEventTargetInWidget: function (event) {
            var menuElement = this.menu.element[0]

            return (
              event.target === this.element[0] ||
              event.target === menuElement ||
              $.contains(menuElement, event.target)
            )
          },

          _closeOnClickOutside: function (event) {
            if (!this._isEventTargetInWidget(event)) {
              this.close()
            }
          },

          _appendTo: function () {
            var element = this.options.appendTo

            if (element) {
              element =
                element.jquery || element.nodeType
                  ? $(element)
                  : this.document.find(element).eq(0)
            }

            if (!element || !element[0]) {
              element = this.element.closest('.ui-front, dialog')
            }

            if (!element.length) {
              element = this.document[0].body
            }

            return element
          },

          _initSource: function () {
            var array,
              url,
              that = this
            if (Array.isArray(this.options.source)) {
              array = this.options.source
              this.source = function (request, response) {
                response($.ui.autocomplete.filter(array, request.term))
              }
            } else if (typeof this.options.source === 'string') {
              url = this.options.source
              this.source = function (request, response) {
                if (that.xhr) {
                  that.xhr.abort()
                }
                that.xhr = $.ajax({
                  url: url,
                  data: request,
                  dataType: 'json',
                  success: function (data) {
                    response(data)
                  },
                  error: function () {
                    response([])
                  }
                })
              }
            } else {
              this.source = this.options.source
            }
          },

          _searchTimeout: function (event) {
            clearTimeout(this.searching)
            this.searching = this._delay(function () {
              // Search if the value has changed, or if the user retypes the same value (see #7434)
              var equalValues = this.term === this._value(),
                menuVisible = this.menu.element.is(':visible'),
                modifierKey =
                  event.altKey ||
                  event.ctrlKey ||
                  event.metaKey ||
                  event.shiftKey

              if (
                !equalValues ||
                (equalValues && !menuVisible && !modifierKey)
              ) {
                this.selectedItem = null
                this.search(null, event)
              }
            }, this.options.delay)
          },

          search: function (value, event) {
            value = value != null ? value : this._value()

            // Always save the actual value, not the one passed as an argument
            this.term = this._value()

            if (value.length < this.options.minLength) {
              return this.close(event)
            }

            if (this._trigger('search', event) === false) {
              return
            }

            return this._search(value)
          },

          _search: function (value) {
            this.pending++
            this._addClass('ui-autocomplete-loading')
            this.cancelSearch = false

            this.source({ term: value }, this._response())
          },

          _response: function () {
            var index = ++this.requestIndex

            return function (content) {
              if (index === this.requestIndex) {
                this.__response(content)
              }

              this.pending--
              if (!this.pending) {
                this._removeClass('ui-autocomplete-loading')
              }
            }.bind(this)
          },

          __response: function (content) {
            if (content) {
              content = this._normalize(content)
            }
            this._trigger('response', null, { content: content })
            if (
              !this.options.disabled &&
              content &&
              content.length &&
              !this.cancelSearch
            ) {
              this._suggest(content)
              this._trigger('open')
            } else {
              // use ._close() instead of .close() so we don't cancel future searches
              this._close()
            }
          },

          close: function (event) {
            this.cancelSearch = true
            this._close(event)
          },

          _close: function (event) {
            // Remove the handler that closes the menu on outside clicks
            this._off(this.document, 'mousedown')

            if (this.menu.element.is(':visible')) {
              this.menu.element.hide()
              this.menu.blur()
              this.isNewMenu = true
              this._trigger('close', event)
            }
          },

          _change: function (event) {
            if (this.previous !== this._value()) {
              this._trigger('change', event, { item: this.selectedItem })
            }
          },

          _normalize: function (items) {
            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
              return items
            }
            return $.map(items, function (item) {
              if (typeof item === 'string') {
                return {
                  label: item,
                  value: item
                }
              }
              return $.extend({}, item, {
                label: item.label || item.value,
                value: item.value || item.label
              })
            })
          },

          _suggest: function (items) {
            var ul = this.menu.element.empty()
            this._renderMenu(ul, items)
            this.isNewMenu = true
            this.menu.refresh()

            // Size and position menu
            ul.show()
            this._resizeMenu()
            ul.position(
              $.extend(
                {
                  of: this.element
                },
                this.options.position
              )
            )

            if (this.options.autoFocus) {
              this.menu.next()
            }

            // Listen for interactions outside of the widget (#6642)
            this._on(this.document, {
              mousedown: '_closeOnClickOutside'
            })
          },

          _resizeMenu: function () {
            var ul = this.menu.element
            ul.outerWidth(
              Math.max(
                // Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width('').outerWidth() + 1,
                this.element.outerWidth()
              )
            )
          },

          _renderMenu: function (ul, items) {
            var that = this
            $.each(items, function (index, item) {
              that._renderItemData(ul, item)
            })
          },

          _renderItemData: function (ul, item) {
            return this._renderItem(ul, item).data('ui-autocomplete-item', item)
          },

          _renderItem: function (ul, item) {
            return $('<li>').append($('<div>').text(item.label)).appendTo(ul)
          },

          _move: function (direction, event) {
            if (!this.menu.element.is(':visible')) {
              this.search(null, event)
              return
            }
            if (
              (this.menu.isFirstItem() && /^previous/.test(direction)) ||
              (this.menu.isLastItem() && /^next/.test(direction))
            ) {
              if (!this.isMultiLine) {
                this._value(this.term)
              }

              this.menu.blur()
              return
            }
            this.menu[direction](event)
          },

          widget: function () {
            return this.menu.element
          },

          _value: function () {
            return this.valueMethod.apply(this.element, arguments)
          },

          _keyEvent: function (keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(':visible')) {
              this._move(keyEvent, event)

              // Prevents moving cursor to beginning/end of the text field in some browsers
              event.preventDefault()
            }
          },

          // Support: Chrome <=50
          // We should be able to just use this.element.prop( "isContentEditable" )
          // but hidden elements always report false in Chrome.
          // https://code.google.com/p/chromium/issues/detail?id=313082
          _isContentEditable: function (element) {
            if (!element.length) {
              return false
            }

            var editable = element.prop('contentEditable')

            if (editable === 'inherit') {
              return this._isContentEditable(element.parent())
            }

            return editable === 'true'
          }
        })

        $.extend($.ui.autocomplete, {
          escapeRegex: function (value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
          },
          filter: function (array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), 'i')
            return $.grep(array, function (value) {
              return matcher.test(value.label || value.value || value)
            })
          }
        })

        // Live region extension, adding a `messages` option
        // NOTE: This is an experimental API. We are still investigating
        // a full solution for string manipulation and internationalization.
        $.widget('ui.autocomplete', $.ui.autocomplete, {
          options: {
            messages: {
              noResults: 'No search results.',
              results: function (amount) {
                return (
                  amount +
                  (amount > 1 ? ' results are' : ' result is') +
                  ' available, use up and down arrow keys to navigate.'
                )
              }
            }
          },

          __response: function (content) {
            var message
            this._superApply(arguments)
            if (this.options.disabled || this.cancelSearch) {
              return
            }
            if (content && content.length) {
              message = this.options.messages.results(content.length)
            } else {
              message = this.options.messages.noResults
            }
            clearTimeout(this.liveRegionTimer)
            this.liveRegionTimer = this._delay(function () {
              this.liveRegion.html($('<div>').text(message))
            }, 100)
          }
        })

        return $.ui.autocomplete
      })

      /***/
    },

    /***/ 9366: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Button 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Button
      //>>group: Widgets
      //>>description: Enhances a form with themeable buttons.
      //>>docs: http://api.jqueryui.com/button/
      //>>demos: http://jqueryui.com/button/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/button.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),

            // These are only for backcompat
            // TODO: Remove after 1.12
            __webpack_require__(341),
            __webpack_require__(1193),

            __webpack_require__(7053),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.button', {
          version: '1.13.2',
          defaultElement: '<button>',
          options: {
            classes: {
              'ui-button': 'ui-corner-all'
            },
            disabled: null,
            icon: null,
            iconPosition: 'beginning',
            label: null,
            showLabel: true
          },

          _getCreateOptions: function () {
            var disabled,
              // This is to support cases like in jQuery Mobile where the base widget does have
              // an implementation of _getCreateOptions
              options = this._super() || {}

            this.isInput = this.element.is('input')

            disabled = this.element[0].disabled
            if (disabled != null) {
              options.disabled = disabled
            }

            this.originalLabel = this.isInput
              ? this.element.val()
              : this.element.html()
            if (this.originalLabel) {
              options.label = this.originalLabel
            }

            return options
          },

          _create: function () {
            if (!this.option.showLabel & !this.options.icon) {
              this.options.showLabel = true
            }

            // We have to check the option again here even though we did in _getCreateOptions,
            // because null may have been passed on init which would override what was set in
            // _getCreateOptions
            if (this.options.disabled == null) {
              this.options.disabled = this.element[0].disabled || false
            }

            this.hasTitle = !!this.element.attr('title')

            // Check to see if the label needs to be set or if its already correct
            if (
              this.options.label &&
              this.options.label !== this.originalLabel
            ) {
              if (this.isInput) {
                this.element.val(this.options.label)
              } else {
                this.element.html(this.options.label)
              }
            }
            this._addClass('ui-button', 'ui-widget')
            this._setOption('disabled', this.options.disabled)
            this._enhance()

            if (this.element.is('a')) {
              this._on({
                keyup: function (event) {
                  if (event.keyCode === $.ui.keyCode.SPACE) {
                    event.preventDefault()

                    // Support: PhantomJS <= 1.9, IE 8 Only
                    // If a native click is available use it so we actually cause navigation
                    // otherwise just trigger a click event
                    if (this.element[0].click) {
                      this.element[0].click()
                    } else {
                      this.element.trigger('click')
                    }
                  }
                }
              })
            }
          },

          _enhance: function () {
            if (!this.element.is('button')) {
              this.element.attr('role', 'button')
            }

            if (this.options.icon) {
              this._updateIcon('icon', this.options.icon)
              this._updateTooltip()
            }
          },

          _updateTooltip: function () {
            this.title = this.element.attr('title')

            if (!this.options.showLabel && !this.title) {
              this.element.attr('title', this.options.label)
            }
          },

          _updateIcon: function (option, value) {
            var icon = option !== 'iconPosition',
              position = icon ? this.options.iconPosition : value,
              displayBlock = position === 'top' || position === 'bottom'

            // Create icon
            if (!this.icon) {
              this.icon = $('<span>')

              this._addClass(this.icon, 'ui-button-icon', 'ui-icon')

              if (!this.options.showLabel) {
                this._addClass('ui-button-icon-only')
              }
            } else if (icon) {
              // If we are updating the icon remove the old icon class
              this._removeClass(this.icon, null, this.options.icon)
            }

            // If we are updating the icon add the new icon class
            if (icon) {
              this._addClass(this.icon, null, value)
            }

            this._attachIcon(position)

            // If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
            // the iconSpace if there is one.
            if (displayBlock) {
              this._addClass(this.icon, null, 'ui-widget-icon-block')
              if (this.iconSpace) {
                this.iconSpace.remove()
              }
            } else {
              // Position is beginning or end so remove the ui-widget-icon-block class and add the
              // space if it does not exist
              if (!this.iconSpace) {
                this.iconSpace = $('<span> </span>')
                this._addClass(this.iconSpace, 'ui-button-icon-space')
              }
              this._removeClass(this.icon, null, 'ui-wiget-icon-block')
              this._attachIconSpace(position)
            }
          },

          _destroy: function () {
            this.element.removeAttr('role')

            if (this.icon) {
              this.icon.remove()
            }
            if (this.iconSpace) {
              this.iconSpace.remove()
            }
            if (!this.hasTitle) {
              this.element.removeAttr('title')
            }
          },

          _attachIconSpace: function (iconPosition) {
            this.icon[
              /^(?:end|bottom)/.test(iconPosition) ? 'before' : 'after'
            ](this.iconSpace)
          },

          _attachIcon: function (iconPosition) {
            this.element[
              /^(?:end|bottom)/.test(iconPosition) ? 'append' : 'prepend'
            ](this.icon)
          },

          _setOptions: function (options) {
            var newShowLabel =
                options.showLabel === undefined
                  ? this.options.showLabel
                  : options.showLabel,
              newIcon =
                options.icon === undefined ? this.options.icon : options.icon

            if (!newShowLabel && !newIcon) {
              options.showLabel = true
            }
            this._super(options)
          },

          _setOption: function (key, value) {
            if (key === 'icon') {
              if (value) {
                this._updateIcon(key, value)
              } else if (this.icon) {
                this.icon.remove()
                if (this.iconSpace) {
                  this.iconSpace.remove()
                }
              }
            }

            if (key === 'iconPosition') {
              this._updateIcon(key, value)
            }

            // Make sure we can't end up with a button that has neither text nor icon
            if (key === 'showLabel') {
              this._toggleClass('ui-button-icon-only', null, !value)
              this._updateTooltip()
            }

            if (key === 'label') {
              if (this.isInput) {
                this.element.val(value)
              } else {
                // If there is an icon, append it, else nothing then append the value
                // this avoids removal of the icon when setting label text
                this.element.html(value)
                if (this.icon) {
                  this._attachIcon(this.options.iconPosition)
                  this._attachIconSpace(this.options.iconPosition)
                }
              }
            }

            this._super(key, value)

            if (key === 'disabled') {
              this._toggleClass(null, 'ui-state-disabled', value)
              this.element[0].disabled = value
              if (value) {
                this.element.trigger('blur')
              }
            }
          },

          refresh: function () {
            // Make sure to only check disabled if its an element that supports this otherwise
            // check for the disabled class to determine state
            var isDisabled = this.element.is('input, button')
              ? this.element[0].disabled
              : this.element.hasClass('ui-button-disabled')

            if (isDisabled !== this.options.disabled) {
              this._setOptions({ disabled: isDisabled })
            }

            this._updateTooltip()
          }
        })

        // DEPRECATED
        if ($.uiBackCompat !== false) {
          // Text and Icons options
          $.widget('ui.button', $.ui.button, {
            options: {
              text: true,
              icons: {
                primary: null,
                secondary: null
              }
            },

            _create: function () {
              if (this.options.showLabel && !this.options.text) {
                this.options.showLabel = this.options.text
              }
              if (!this.options.showLabel && this.options.text) {
                this.options.text = this.options.showLabel
              }
              if (
                !this.options.icon &&
                (this.options.icons.primary || this.options.icons.secondary)
              ) {
                if (this.options.icons.primary) {
                  this.options.icon = this.options.icons.primary
                } else {
                  this.options.icon = this.options.icons.secondary
                  this.options.iconPosition = 'end'
                }
              } else if (this.options.icon) {
                this.options.icons.primary = this.options.icon
              }
              this._super()
            },

            _setOption: function (key, value) {
              if (key === 'text') {
                this._super('showLabel', value)
                return
              }
              if (key === 'showLabel') {
                this.options.text = value
              }
              if (key === 'icon') {
                this.options.icons.primary = value
              }
              if (key === 'icons') {
                if (value.primary) {
                  this._super('icon', value.primary)
                  this._super('iconPosition', 'beginning')
                } else if (value.secondary) {
                  this._super('icon', value.secondary)
                  this._super('iconPosition', 'end')
                }
              }
              this._superApply(arguments)
            }
          })

          $.fn.button = (function (orig) {
            return function (options) {
              var isMethodCall = typeof options === 'string'
              var args = Array.prototype.slice.call(arguments, 1)
              var returnValue = this

              if (isMethodCall) {
                // If this is an empty collection, we need to have the instance method
                // return undefined instead of the jQuery instance
                if (!this.length && options === 'instance') {
                  returnValue = undefined
                } else {
                  this.each(function () {
                    var methodValue
                    var type = $(this).attr('type')
                    var name =
                      type !== 'checkbox' && type !== 'radio'
                        ? 'button'
                        : 'checkboxradio'
                    var instance = $.data(this, 'ui-' + name)

                    if (options === 'instance') {
                      returnValue = instance
                      return false
                    }

                    if (!instance) {
                      return $.error(
                        'cannot call methods on button' +
                          ' prior to initialization; ' +
                          "attempted to call method '" +
                          options +
                          "'"
                      )
                    }

                    if (
                      typeof instance[options] !== 'function' ||
                      options.charAt(0) === '_'
                    ) {
                      return $.error(
                        "no such method '" +
                          options +
                          "' for button" +
                          ' widget instance'
                      )
                    }

                    methodValue = instance[options].apply(instance, args)

                    if (methodValue !== instance && methodValue !== undefined) {
                      returnValue =
                        methodValue && methodValue.jquery
                          ? returnValue.pushStack(methodValue.get())
                          : methodValue
                      return false
                    }
                  })
                }
              } else {
                // Allow multiple hashes to be passed on init
                if (args.length) {
                  options = $.widget.extend.apply(null, [options].concat(args))
                }

                this.each(function () {
                  var type = $(this).attr('type')
                  var name =
                    type !== 'checkbox' && type !== 'radio'
                      ? 'button'
                      : 'checkboxradio'
                  var instance = $.data(this, 'ui-' + name)

                  if (instance) {
                    instance.option(options || {})
                    if (instance._init) {
                      instance._init()
                    }
                  } else {
                    if (name === 'button') {
                      orig.call($(this), options)
                      return
                    }

                    $(this).checkboxradio($.extend({ icon: false }, options))
                  }
                })
              }

              return returnValue
            }
          })($.fn.button)

          $.fn.buttonset = function () {
            if (!$.ui.controlgroup) {
              $.error('Controlgroup widget missing')
            }
            if (
              arguments[0] === 'option' &&
              arguments[1] === 'items' &&
              arguments[2]
            ) {
              return this.controlgroup.apply(this, [
                arguments[0],
                'items.button',
                arguments[2]
              ])
            }
            if (arguments[0] === 'option' && arguments[1] === 'items') {
              return this.controlgroup.apply(this, [
                arguments[0],
                'items.button'
              ])
            }
            if (typeof arguments[0] === 'object' && arguments[0].items) {
              arguments[0].items = {
                button: arguments[0].items
              }
            }
            return this.controlgroup.apply(this, arguments)
          }
        }

        return $.ui.button
      })

      /***/
    },

    /***/ 1193: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Checkboxradio 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Checkboxradio
      //>>group: Widgets
      //>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
      //>>docs: http://api.jqueryui.com/checkboxradio/
      //>>demos: http://jqueryui.com/checkboxradio/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/button.css
      //>>css.structure: ../../themes/base/checkboxradio.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(7808),
            __webpack_require__(6575),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.checkboxradio', [
          $.ui.formResetMixin,
          {
            version: '1.13.2',
            options: {
              disabled: null,
              label: null,
              icon: true,
              classes: {
                'ui-checkboxradio-label': 'ui-corner-all',
                'ui-checkboxradio-icon': 'ui-corner-all'
              }
            },

            _getCreateOptions: function () {
              var disabled, labels, labelContents
              var options = this._super() || {}

              // We read the type here, because it makes more sense to throw a element type error first,
              // rather then the error for lack of a label. Often if its the wrong type, it
              // won't have a label (e.g. calling on a div, btn, etc)
              this._readType()

              labels = this.element.labels()

              // If there are multiple labels, use the last one
              this.label = $(labels[labels.length - 1])
              if (!this.label.length) {
                $.error('No label found for checkboxradio widget')
              }

              this.originalLabel = ''

              // We need to get the label text but this may also need to make sure it does not contain the
              // input itself.
              // The label contents could be text, html, or a mix. We wrap all elements
              // and read the wrapper's `innerHTML` to get a string representation of
              // the label, without the input as part of it.
              labelContents = this.label.contents().not(this.element[0])

              if (labelContents.length) {
                this.originalLabel += labelContents
                  .clone()
                  .wrapAll('<div></div>')
                  .parent()
                  .html()
              }

              // Set the label option if we found label text
              if (this.originalLabel) {
                options.label = this.originalLabel
              }

              disabled = this.element[0].disabled
              if (disabled != null) {
                options.disabled = disabled
              }
              return options
            },

            _create: function () {
              var checked = this.element[0].checked

              this._bindFormResetHandler()

              if (this.options.disabled == null) {
                this.options.disabled = this.element[0].disabled
              }

              this._setOption('disabled', this.options.disabled)
              this._addClass('ui-checkboxradio', 'ui-helper-hidden-accessible')
              this._addClass(
                this.label,
                'ui-checkboxradio-label',
                'ui-button ui-widget'
              )

              if (this.type === 'radio') {
                this._addClass(this.label, 'ui-checkboxradio-radio-label')
              }

              if (
                this.options.label &&
                this.options.label !== this.originalLabel
              ) {
                this._updateLabel()
              } else if (this.originalLabel) {
                this.options.label = this.originalLabel
              }

              this._enhance()

              if (checked) {
                this._addClass(
                  this.label,
                  'ui-checkboxradio-checked',
                  'ui-state-active'
                )
              }

              this._on({
                change: '_toggleClasses',
                focus: function () {
                  this._addClass(
                    this.label,
                    null,
                    'ui-state-focus ui-visual-focus'
                  )
                },
                blur: function () {
                  this._removeClass(
                    this.label,
                    null,
                    'ui-state-focus ui-visual-focus'
                  )
                }
              })
            },

            _readType: function () {
              var nodeName = this.element[0].nodeName.toLowerCase()
              this.type = this.element[0].type
              if (nodeName !== 'input' || !/radio|checkbox/.test(this.type)) {
                $.error(
                  "Can't create checkboxradio on element.nodeName=" +
                    nodeName +
                    ' and element.type=' +
                    this.type
                )
              }
            },

            // Support jQuery Mobile enhanced option
            _enhance: function () {
              this._updateIcon(this.element[0].checked)
            },

            widget: function () {
              return this.label
            },

            _getRadioGroup: function () {
              var group
              var name = this.element[0].name
              var nameSelector = "input[name='" + $.escapeSelector(name) + "']"

              if (!name) {
                return $([])
              }

              if (this.form.length) {
                group = $(this.form[0].elements).filter(nameSelector)
              } else {
                // Not inside a form, check all inputs that also are not inside a form
                group = $(nameSelector).filter(function () {
                  return $(this)._form().length === 0
                })
              }

              return group.not(this.element)
            },

            _toggleClasses: function () {
              var checked = this.element[0].checked
              this._toggleClass(
                this.label,
                'ui-checkboxradio-checked',
                'ui-state-active',
                checked
              )

              if (this.options.icon && this.type === 'checkbox') {
                this._toggleClass(
                  this.icon,
                  null,
                  'ui-icon-check ui-state-checked',
                  checked
                )._toggleClass(this.icon, null, 'ui-icon-blank', !checked)
              }

              if (this.type === 'radio') {
                this._getRadioGroup().each(function () {
                  var instance = $(this).checkboxradio('instance')

                  if (instance) {
                    instance._removeClass(
                      instance.label,
                      'ui-checkboxradio-checked',
                      'ui-state-active'
                    )
                  }
                })
              }
            },

            _destroy: function () {
              this._unbindFormResetHandler()

              if (this.icon) {
                this.icon.remove()
                this.iconSpace.remove()
              }
            },

            _setOption: function (key, value) {
              // We don't allow the value to be set to nothing
              if (key === 'label' && !value) {
                return
              }

              this._super(key, value)

              if (key === 'disabled') {
                this._toggleClass(this.label, null, 'ui-state-disabled', value)
                this.element[0].disabled = value

                // Don't refresh when setting disabled
                return
              }
              this.refresh()
            },

            _updateIcon: function (checked) {
              var toAdd = 'ui-icon ui-icon-background '

              if (this.options.icon) {
                if (!this.icon) {
                  this.icon = $('<span>')
                  this.iconSpace = $('<span> </span>')
                  this._addClass(this.iconSpace, 'ui-checkboxradio-icon-space')
                }

                if (this.type === 'checkbox') {
                  toAdd += checked
                    ? 'ui-icon-check ui-state-checked'
                    : 'ui-icon-blank'
                  this._removeClass(
                    this.icon,
                    null,
                    checked ? 'ui-icon-blank' : 'ui-icon-check'
                  )
                } else {
                  toAdd += 'ui-icon-blank'
                }
                this._addClass(this.icon, 'ui-checkboxradio-icon', toAdd)
                if (!checked) {
                  this._removeClass(
                    this.icon,
                    null,
                    'ui-icon-check ui-state-checked'
                  )
                }
                this.icon.prependTo(this.label).after(this.iconSpace)
              } else if (this.icon !== undefined) {
                this.icon.remove()
                this.iconSpace.remove()
                delete this.icon
              }
            },

            _updateLabel: function () {
              // Remove the contents of the label ( minus the icon, icon space, and input )
              var contents = this.label.contents().not(this.element[0])
              if (this.icon) {
                contents = contents.not(this.icon[0])
              }
              if (this.iconSpace) {
                contents = contents.not(this.iconSpace[0])
              }
              contents.remove()

              this.label.append(this.options.label)
            },

            refresh: function () {
              var checked = this.element[0].checked,
                isDisabled = this.element[0].disabled

              this._updateIcon(checked)
              this._toggleClass(
                this.label,
                'ui-checkboxradio-checked',
                'ui-state-active',
                checked
              )
              if (this.options.label !== null) {
                this._updateLabel()
              }

              if (isDisabled !== this.options.disabled) {
                this._setOptions({ disabled: isDisabled })
              }
            }
          }
        ])

        return $.ui.checkboxradio
      })

      /***/
    },

    /***/ 341: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Controlgroup 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Controlgroup
      //>>group: Widgets
      //>>description: Visually groups form control widgets
      //>>docs: http://api.jqueryui.com/controlgroup/
      //>>demos: http://jqueryui.com/controlgroup/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/controlgroup.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g

        return $.widget('ui.controlgroup', {
          version: '1.13.2',
          defaultElement: '<div>',
          options: {
            direction: 'horizontal',
            disabled: null,
            onlyVisible: true,
            items: {
              button:
                'input[type=button], input[type=submit], input[type=reset], button, a',
              controlgroupLabel: '.ui-controlgroup-label',
              checkboxradio: "input[type='checkbox'], input[type='radio']",
              selectmenu: 'select',
              spinner: '.ui-spinner-input'
            }
          },

          _create: function () {
            this._enhance()
          },

          // To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
          _enhance: function () {
            this.element.attr('role', 'toolbar')
            this.refresh()
          },

          _destroy: function () {
            this._callChildMethod('destroy')
            this.childWidgets.removeData('ui-controlgroup-data')
            this.element.removeAttr('role')
            if (this.options.items.controlgroupLabel) {
              this.element
                .find(this.options.items.controlgroupLabel)
                .find('.ui-controlgroup-label-contents')
                .contents()
                .unwrap()
            }
          },

          _initWidgets: function () {
            var that = this,
              childWidgets = []

            // First we iterate over each of the items options
            $.each(this.options.items, function (widget, selector) {
              var labels
              var options = {}

              // Make sure the widget has a selector set
              if (!selector) {
                return
              }

              if (widget === 'controlgroupLabel') {
                labels = that.element.find(selector)
                labels.each(function () {
                  var element = $(this)

                  if (
                    element.children('.ui-controlgroup-label-contents').length
                  ) {
                    return
                  }
                  element
                    .contents()
                    .wrapAll(
                      "<span class='ui-controlgroup-label-contents'></span>"
                    )
                })
                that._addClass(
                  labels,
                  null,
                  'ui-widget ui-widget-content ui-state-default'
                )
                childWidgets = childWidgets.concat(labels.get())
                return
              }

              // Make sure the widget actually exists
              if (!$.fn[widget]) {
                return
              }

              // We assume everything is in the middle to start because we can't determine
              // first / last elements until all enhancments are done.
              if (that['_' + widget + 'Options']) {
                options = that['_' + widget + 'Options']('middle')
              } else {
                options = { classes: {} }
              }

              // Find instances of this widget inside controlgroup and init them
              that.element.find(selector).each(function () {
                var element = $(this)
                var instance = element[widget]('instance')

                // We need to clone the default options for this type of widget to avoid
                // polluting the variable options which has a wider scope than a single widget.
                var instanceOptions = $.widget.extend({}, options)

                // If the button is the child of a spinner ignore it
                // TODO: Find a more generic solution
                if (
                  widget === 'button' &&
                  element.parent('.ui-spinner').length
                ) {
                  return
                }

                // Create the widget if it doesn't exist
                if (!instance) {
                  instance = element[widget]()[widget]('instance')
                }
                if (instance) {
                  instanceOptions.classes = that._resolveClassesValues(
                    instanceOptions.classes,
                    instance
                  )
                }
                element[widget](instanceOptions)

                // Store an instance of the controlgroup to be able to reference
                // from the outermost element for changing options and refresh
                var widgetElement = element[widget]('widget')
                $.data(
                  widgetElement[0],
                  'ui-controlgroup-data',
                  instance ? instance : element[widget]('instance')
                )

                childWidgets.push(widgetElement[0])
              })
            })

            this.childWidgets = $($.uniqueSort(childWidgets))
            this._addClass(this.childWidgets, 'ui-controlgroup-item')
          },

          _callChildMethod: function (method) {
            this.childWidgets.each(function () {
              var element = $(this),
                data = element.data('ui-controlgroup-data')
              if (data && data[method]) {
                data[method]()
              }
            })
          },

          _updateCornerClass: function (element, position) {
            var remove =
              'ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all'
            var add = this._buildSimpleOptions(position, 'label').classes.label

            this._removeClass(element, null, remove)
            this._addClass(element, null, add)
          },

          _buildSimpleOptions: function (position, key) {
            var direction = this.options.direction === 'vertical'
            var result = {
              classes: {}
            }
            result.classes[key] = {
              middle: '',
              first: 'ui-corner-' + (direction ? 'top' : 'left'),
              last: 'ui-corner-' + (direction ? 'bottom' : 'right'),
              only: 'ui-corner-all'
            }[position]

            return result
          },

          _spinnerOptions: function (position) {
            var options = this._buildSimpleOptions(position, 'ui-spinner')

            options.classes['ui-spinner-up'] = ''
            options.classes['ui-spinner-down'] = ''

            return options
          },

          _buttonOptions: function (position) {
            return this._buildSimpleOptions(position, 'ui-button')
          },

          _checkboxradioOptions: function (position) {
            return this._buildSimpleOptions(position, 'ui-checkboxradio-label')
          },

          _selectmenuOptions: function (position) {
            var direction = this.options.direction === 'vertical'
            return {
              width: direction ? 'auto' : false,
              classes: {
                middle: {
                  'ui-selectmenu-button-open': '',
                  'ui-selectmenu-button-closed': ''
                },
                first: {
                  'ui-selectmenu-button-open':
                    'ui-corner-' + (direction ? 'top' : 'tl'),
                  'ui-selectmenu-button-closed':
                    'ui-corner-' + (direction ? 'top' : 'left')
                },
                last: {
                  'ui-selectmenu-button-open': direction ? '' : 'ui-corner-tr',
                  'ui-selectmenu-button-closed':
                    'ui-corner-' + (direction ? 'bottom' : 'right')
                },
                only: {
                  'ui-selectmenu-button-open': 'ui-corner-top',
                  'ui-selectmenu-button-closed': 'ui-corner-all'
                }
              }[position]
            }
          },

          _resolveClassesValues: function (classes, instance) {
            var result = {}
            $.each(classes, function (key) {
              var current = instance.options.classes[key] || ''
              current = String.prototype.trim.call(
                current.replace(controlgroupCornerRegex, '')
              )
              result[key] = (current + ' ' + classes[key]).replace(/\s+/g, ' ')
            })
            return result
          },

          _setOption: function (key, value) {
            if (key === 'direction') {
              this._removeClass('ui-controlgroup-' + this.options.direction)
            }

            this._super(key, value)
            if (key === 'disabled') {
              this._callChildMethod(value ? 'disable' : 'enable')
              return
            }

            this.refresh()
          },

          refresh: function () {
            var children,
              that = this

            this._addClass(
              'ui-controlgroup ui-controlgroup-' + this.options.direction
            )

            if (this.options.direction === 'horizontal') {
              this._addClass(null, 'ui-helper-clearfix')
            }
            this._initWidgets()

            children = this.childWidgets

            // We filter here because we need to track all childWidgets not just the visible ones
            if (this.options.onlyVisible) {
              children = children.filter(':visible')
            }

            if (children.length) {
              // We do this last because we need to make sure all enhancment is done
              // before determining first and last
              $.each(['first', 'last'], function (index, value) {
                var instance = children[value]().data('ui-controlgroup-data')

                if (instance && that['_' + instance.widgetName + 'Options']) {
                  var options = that['_' + instance.widgetName + 'Options'](
                    children.length === 1 ? 'only' : value
                  )
                  options.classes = that._resolveClassesValues(
                    options.classes,
                    instance
                  )
                  instance.element[instance.widgetName](options)
                } else {
                  that._updateCornerClass(children[value](), value)
                }
              })

              // Finally call the refresh method on each of the child widgets.
              this._callChildMethod('refresh')
            }
          }
        })
      })

      /***/
    },

    /***/ 2466: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Dialog 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Dialog
      //>>group: Widgets
      //>>description: Displays customizable dialog windows.
      //>>docs: http://api.jqueryui.com/dialog/
      //>>demos: http://jqueryui.com/dialog/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/dialog.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(9366),
            __webpack_require__(7285),
            __webpack_require__(6177),
            __webpack_require__(1707),
            __webpack_require__(5436),
            __webpack_require__(7053),
            __webpack_require__(1822),
            __webpack_require__(1440),
            __webpack_require__(192),
            __webpack_require__(3614),
            __webpack_require__(9138),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.dialog', {
          version: '1.13.2',
          options: {
            appendTo: 'body',
            autoOpen: true,
            buttons: [],
            classes: {
              'ui-dialog': 'ui-corner-all',
              'ui-dialog-titlebar': 'ui-corner-all'
            },
            closeOnEscape: true,
            closeText: 'Close',
            draggable: true,
            hide: null,
            height: 'auto',
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
              my: 'center',
              at: 'center',
              of: window,
              collision: 'fit',

              // Ensure the titlebar is always visible
              using: function (pos) {
                var topOffset = $(this).css(pos).offset().top
                if (topOffset < 0) {
                  $(this).css('top', pos.top - topOffset)
                }
              }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,

            // Callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
          },

          sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
          },

          resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
          },

          _create: function () {
            this.originalCss = {
              display: this.element[0].style.display,
              width: this.element[0].style.width,
              minHeight: this.element[0].style.minHeight,
              maxHeight: this.element[0].style.maxHeight,
              height: this.element[0].style.height
            }
            this.originalPosition = {
              parent: this.element.parent(),
              index: this.element.parent().children().index(this.element)
            }
            this.originalTitle = this.element.attr('title')
            if (this.options.title == null && this.originalTitle != null) {
              this.options.title = this.originalTitle
            }

            // Dialogs can't be disabled
            if (this.options.disabled) {
              this.options.disabled = false
            }

            this._createWrapper()

            this.element.show().removeAttr('title').appendTo(this.uiDialog)

            this._addClass('ui-dialog-content', 'ui-widget-content')

            this._createTitlebar()
            this._createButtonPane()

            if (this.options.draggable && $.fn.draggable) {
              this._makeDraggable()
            }
            if (this.options.resizable && $.fn.resizable) {
              this._makeResizable()
            }

            this._isOpen = false

            this._trackFocus()
          },

          _init: function () {
            if (this.options.autoOpen) {
              this.open()
            }
          },

          _appendTo: function () {
            var element = this.options.appendTo
            if (element && (element.jquery || element.nodeType)) {
              return $(element)
            }
            return this.document.find(element || 'body').eq(0)
          },

          _destroy: function () {
            var next,
              originalPosition = this.originalPosition

            this._untrackInstance()
            this._destroyOverlay()

            this.element
              .removeUniqueId()
              .css(this.originalCss)

              // Without detaching first, the following becomes really slow
              .detach()

            this.uiDialog.remove()

            if (this.originalTitle) {
              this.element.attr('title', this.originalTitle)
            }

            next = originalPosition.parent.children().eq(originalPosition.index)

            // Don't try to place the dialog next to itself (#8613)
            if (next.length && next[0] !== this.element[0]) {
              next.before(this.element)
            } else {
              originalPosition.parent.append(this.element)
            }
          },

          widget: function () {
            return this.uiDialog
          },

          disable: $.noop,
          enable: $.noop,

          close: function (event) {
            var that = this

            if (
              !this._isOpen ||
              this._trigger('beforeClose', event) === false
            ) {
              return
            }

            this._isOpen = false
            this._focusedElement = null
            this._destroyOverlay()
            this._untrackInstance()

            if (!this.opener.filter(':focusable').trigger('focus').length) {
              // Hiding a focused element doesn't trigger blur in WebKit
              // so in case we have nothing to focus on, explicitly blur the active element
              // https://bugs.webkit.org/show_bug.cgi?id=47182
              $.ui.safeBlur($.ui.safeActiveElement(this.document[0]))
            }

            this._hide(this.uiDialog, this.options.hide, function () {
              that._trigger('close', event)
            })
          },

          isOpen: function () {
            return this._isOpen
          },

          moveToTop: function () {
            this._moveToTop()
          },

          _moveToTop: function (event, silent) {
            var moved = false,
              zIndices = this.uiDialog
                .siblings('.ui-front:visible')
                .map(function () {
                  return +$(this).css('z-index')
                })
                .get(),
              zIndexMax = Math.max.apply(null, zIndices)

            if (zIndexMax >= +this.uiDialog.css('z-index')) {
              this.uiDialog.css('z-index', zIndexMax + 1)
              moved = true
            }

            if (moved && !silent) {
              this._trigger('focus', event)
            }
            return moved
          },

          open: function () {
            var that = this
            if (this._isOpen) {
              if (this._moveToTop()) {
                this._focusTabbable()
              }
              return
            }

            this._isOpen = true
            this.opener = $($.ui.safeActiveElement(this.document[0]))

            this._size()
            this._position()
            this._createOverlay()
            this._moveToTop(null, true)

            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            if (this.overlay) {
              this.overlay.css('z-index', this.uiDialog.css('z-index') - 1)
            }

            this._show(this.uiDialog, this.options.show, function () {
              that._focusTabbable()
              that._trigger('focus')
            })

            // Track the dialog immediately upon opening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            this._makeFocusTarget()

            this._trigger('open')
          },

          _focusTabbable: function () {
            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement
            if (!hasFocus) {
              hasFocus = this.element.find('[autofocus]')
            }
            if (!hasFocus.length) {
              hasFocus = this.element.find(':tabbable')
            }
            if (!hasFocus.length) {
              hasFocus = this.uiDialogButtonPane.find(':tabbable')
            }
            if (!hasFocus.length) {
              hasFocus = this.uiDialogTitlebarClose.filter(':tabbable')
            }
            if (!hasFocus.length) {
              hasFocus = this.uiDialog
            }
            hasFocus.eq(0).trigger('focus')
          },

          _restoreTabbableFocus: function () {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
              isActive =
                this.uiDialog[0] === activeElement ||
                $.contains(this.uiDialog[0], activeElement)
            if (!isActive) {
              this._focusTabbable()
            }
          },

          _keepFocus: function (event) {
            event.preventDefault()
            this._restoreTabbableFocus()

            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(this._restoreTabbableFocus)
          },

          _createWrapper: function () {
            this.uiDialog = $('<div>')
              .hide()
              .attr({
                // Setting tabIndex makes the div focusable
                tabIndex: -1,
                role: 'dialog'
              })
              .appendTo(this._appendTo())

            this._addClass(
              this.uiDialog,
              'ui-dialog',
              'ui-widget ui-widget-content ui-front'
            )
            this._on(this.uiDialog, {
              keydown: function (event) {
                if (
                  this.options.closeOnEscape &&
                  !event.isDefaultPrevented() &&
                  event.keyCode &&
                  event.keyCode === $.ui.keyCode.ESCAPE
                ) {
                  event.preventDefault()
                  this.close(event)
                  return
                }

                // Prevent tabbing out of dialogs
                if (
                  event.keyCode !== $.ui.keyCode.TAB ||
                  event.isDefaultPrevented()
                ) {
                  return
                }
                var tabbables = this.uiDialog.find(':tabbable'),
                  first = tabbables.first(),
                  last = tabbables.last()

                if (
                  (event.target === last[0] ||
                    event.target === this.uiDialog[0]) &&
                  !event.shiftKey
                ) {
                  this._delay(function () {
                    first.trigger('focus')
                  })
                  event.preventDefault()
                } else if (
                  (event.target === first[0] ||
                    event.target === this.uiDialog[0]) &&
                  event.shiftKey
                ) {
                  this._delay(function () {
                    last.trigger('focus')
                  })
                  event.preventDefault()
                }
              },
              mousedown: function (event) {
                if (this._moveToTop(event)) {
                  this._focusTabbable()
                }
              }
            })

            // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            if (!this.element.find('[aria-describedby]').length) {
              this.uiDialog.attr({
                'aria-describedby': this.element.uniqueId().attr('id')
              })
            }
          },

          _createTitlebar: function () {
            var uiDialogTitle

            this.uiDialogTitlebar = $('<div>')
            this._addClass(
              this.uiDialogTitlebar,
              'ui-dialog-titlebar',
              'ui-widget-header ui-helper-clearfix'
            )
            this._on(this.uiDialogTitlebar, {
              mousedown: function (event) {
                // Don't prevent click on close button (#8838)
                // Focusing a dialog that is partially scrolled out of view
                // causes the browser to scroll it into view, preventing the click event
                if (!$(event.target).closest('.ui-dialog-titlebar-close')) {
                  // Dialog isn't getting focus when dragging (#8063)
                  this.uiDialog.trigger('focus')
                }
              }
            })

            // Support: IE
            // Use type="button" to prevent enter keypresses in textboxes from closing the
            // dialog in IE (#9312)
            this.uiDialogTitlebarClose = $("<button type='button'></button>")
              .button({
                label: $('<a>').text(this.options.closeText).html(),
                icon: 'ui-icon-closethick',
                showLabel: false
              })
              .appendTo(this.uiDialogTitlebar)

            this._addClass(
              this.uiDialogTitlebarClose,
              'ui-dialog-titlebar-close'
            )
            this._on(this.uiDialogTitlebarClose, {
              click: function (event) {
                event.preventDefault()
                this.close(event)
              }
            })

            uiDialogTitle = $('<span>')
              .uniqueId()
              .prependTo(this.uiDialogTitlebar)
            this._addClass(uiDialogTitle, 'ui-dialog-title')
            this._title(uiDialogTitle)

            this.uiDialogTitlebar.prependTo(this.uiDialog)

            this.uiDialog.attr({
              'aria-labelledby': uiDialogTitle.attr('id')
            })
          },

          _title: function (title) {
            if (this.options.title) {
              title.text(this.options.title)
            } else {
              title.html('&#160;')
            }
          },

          _createButtonPane: function () {
            this.uiDialogButtonPane = $('<div>')
            this._addClass(
              this.uiDialogButtonPane,
              'ui-dialog-buttonpane',
              'ui-widget-content ui-helper-clearfix'
            )

            this.uiButtonSet = $('<div>').appendTo(this.uiDialogButtonPane)
            this._addClass(this.uiButtonSet, 'ui-dialog-buttonset')

            this._createButtons()
          },

          _createButtons: function () {
            var that = this,
              buttons = this.options.buttons

            // If we already have a button pane, remove it
            this.uiDialogButtonPane.remove()
            this.uiButtonSet.empty()

            if (
              $.isEmptyObject(buttons) ||
              (Array.isArray(buttons) && !buttons.length)
            ) {
              this._removeClass(this.uiDialog, 'ui-dialog-buttons')
              return
            }

            $.each(buttons, function (name, props) {
              var click, buttonOptions
              props =
                typeof props === 'function'
                  ? { click: props, text: name }
                  : props

              // Default to a non-submitting button
              props = $.extend({ type: 'button' }, props)

              // Change the context for the click callback to be the main element
              click = props.click
              buttonOptions = {
                icon: props.icon,
                iconPosition: props.iconPosition,
                showLabel: props.showLabel,

                // Deprecated options
                icons: props.icons,
                text: props.text
              }

              delete props.click
              delete props.icon
              delete props.iconPosition
              delete props.showLabel

              // Deprecated options
              delete props.icons
              if (typeof props.text === 'boolean') {
                delete props.text
              }

              $('<button></button>', props)
                .button(buttonOptions)
                .appendTo(that.uiButtonSet)
                .on('click', function () {
                  click.apply(that.element[0], arguments)
                })
            })
            this._addClass(this.uiDialog, 'ui-dialog-buttons')
            this.uiDialogButtonPane.appendTo(this.uiDialog)
          },

          _makeDraggable: function () {
            var that = this,
              options = this.options

            function filteredUi(ui) {
              return {
                position: ui.position,
                offset: ui.offset
              }
            }

            this.uiDialog.draggable({
              cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
              handle: '.ui-dialog-titlebar',
              containment: 'document',
              start: function (event, ui) {
                that._addClass($(this), 'ui-dialog-dragging')
                that._blockFrames()
                that._trigger('dragStart', event, filteredUi(ui))
              },
              drag: function (event, ui) {
                that._trigger('drag', event, filteredUi(ui))
              },
              stop: function (event, ui) {
                var left = ui.offset.left - that.document.scrollLeft(),
                  top = ui.offset.top - that.document.scrollTop()

                options.position = {
                  my: 'left top',
                  at:
                    'left' +
                    (left >= 0 ? '+' : '') +
                    left +
                    ' ' +
                    'top' +
                    (top >= 0 ? '+' : '') +
                    top,
                  of: that.window
                }
                that._removeClass($(this), 'ui-dialog-dragging')
                that._unblockFrames()
                that._trigger('dragStop', event, filteredUi(ui))
              }
            })
          },

          _makeResizable: function () {
            var that = this,
              options = this.options,
              handles = options.resizable,
              // .ui-resizable has position: relative defined in the stylesheet
              // but dialogs have to use absolute or fixed positioning
              position = this.uiDialog.css('position'),
              resizeHandles =
                typeof handles === 'string' ? handles : 'n,e,s,w,se,sw,ne,nw'

            function filteredUi(ui) {
              return {
                originalPosition: ui.originalPosition,
                originalSize: ui.originalSize,
                position: ui.position,
                size: ui.size
              }
            }

            this.uiDialog
              .resizable({
                cancel: '.ui-dialog-content',
                containment: 'document',
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function (event, ui) {
                  that._addClass($(this), 'ui-dialog-resizing')
                  that._blockFrames()
                  that._trigger('resizeStart', event, filteredUi(ui))
                },
                resize: function (event, ui) {
                  that._trigger('resize', event, filteredUi(ui))
                },
                stop: function (event, ui) {
                  var offset = that.uiDialog.offset(),
                    left = offset.left - that.document.scrollLeft(),
                    top = offset.top - that.document.scrollTop()

                  options.height = that.uiDialog.height()
                  options.width = that.uiDialog.width()
                  options.position = {
                    my: 'left top',
                    at:
                      'left' +
                      (left >= 0 ? '+' : '') +
                      left +
                      ' ' +
                      'top' +
                      (top >= 0 ? '+' : '') +
                      top,
                    of: that.window
                  }
                  that._removeClass($(this), 'ui-dialog-resizing')
                  that._unblockFrames()
                  that._trigger('resizeStop', event, filteredUi(ui))
                }
              })
              .css('position', position)
          },

          _trackFocus: function () {
            this._on(this.widget(), {
              focusin: function (event) {
                this._makeFocusTarget()
                this._focusedElement = $(event.target)
              }
            })
          },

          _makeFocusTarget: function () {
            this._untrackInstance()
            this._trackingInstances().unshift(this)
          },

          _untrackInstance: function () {
            var instances = this._trackingInstances(),
              exists = $.inArray(this, instances)
            if (exists !== -1) {
              instances.splice(exists, 1)
            }
          },

          _trackingInstances: function () {
            var instances = this.document.data('ui-dialog-instances')
            if (!instances) {
              instances = []
              this.document.data('ui-dialog-instances', instances)
            }
            return instances
          },

          _minHeight: function () {
            var options = this.options

            return options.height === 'auto'
              ? options.minHeight
              : Math.min(options.minHeight, options.height)
          },

          _position: function () {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(':visible')
            if (!isVisible) {
              this.uiDialog.show()
            }
            this.uiDialog.position(this.options.position)
            if (!isVisible) {
              this.uiDialog.hide()
            }
          },

          _setOptions: function (options) {
            var that = this,
              resize = false,
              resizableOptions = {}

            $.each(options, function (key, value) {
              that._setOption(key, value)

              if (key in that.sizeRelatedOptions) {
                resize = true
              }
              if (key in that.resizableRelatedOptions) {
                resizableOptions[key] = value
              }
            })

            if (resize) {
              this._size()
              this._position()
            }
            if (this.uiDialog.is(':data(ui-resizable)')) {
              this.uiDialog.resizable('option', resizableOptions)
            }
          },

          _setOption: function (key, value) {
            var isDraggable,
              isResizable,
              uiDialog = this.uiDialog

            if (key === 'disabled') {
              return
            }

            this._super(key, value)

            if (key === 'appendTo') {
              this.uiDialog.appendTo(this._appendTo())
            }

            if (key === 'buttons') {
              this._createButtons()
            }

            if (key === 'closeText') {
              this.uiDialogTitlebarClose.button({
                // Ensure that we always pass a string
                label: $('<a>')
                  .text('' + this.options.closeText)
                  .html()
              })
            }

            if (key === 'draggable') {
              isDraggable = uiDialog.is(':data(ui-draggable)')
              if (isDraggable && !value) {
                uiDialog.draggable('destroy')
              }

              if (!isDraggable && value) {
                this._makeDraggable()
              }
            }

            if (key === 'position') {
              this._position()
            }

            if (key === 'resizable') {
              // currently resizable, becoming non-resizable
              isResizable = uiDialog.is(':data(ui-resizable)')
              if (isResizable && !value) {
                uiDialog.resizable('destroy')
              }

              // Currently resizable, changing handles
              if (isResizable && typeof value === 'string') {
                uiDialog.resizable('option', 'handles', value)
              }

              // Currently non-resizable, becoming resizable
              if (!isResizable && value !== false) {
                this._makeResizable()
              }
            }

            if (key === 'title') {
              this._title(this.uiDialogTitlebar.find('.ui-dialog-title'))
            }
          },

          _size: function () {
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight,
              minContentHeight,
              maxContentHeight,
              options = this.options

            // Reset content sizing
            this.element.show().css({
              width: 'auto',
              minHeight: 0,
              maxHeight: 'none',
              height: 0
            })

            if (options.minWidth > options.width) {
              options.width = options.minWidth
            }

            // Reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog
              .css({
                height: 'auto',
                width: options.width
              })
              .outerHeight()
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight)
            maxContentHeight =
              typeof options.maxHeight === 'number'
                ? Math.max(0, options.maxHeight - nonContentHeight)
                : 'none'

            if (options.height === 'auto') {
              this.element.css({
                minHeight: minContentHeight,
                maxHeight: maxContentHeight,
                height: 'auto'
              })
            } else {
              this.element.height(
                Math.max(0, options.height - nonContentHeight)
              )
            }

            if (this.uiDialog.is(':data(ui-resizable)')) {
              this.uiDialog.resizable('option', 'minHeight', this._minHeight())
            }
          },

          _blockFrames: function () {
            this.iframeBlocks = this.document.find('iframe').map(function () {
              var iframe = $(this)

              return $('<div>')
                .css({
                  position: 'absolute',
                  width: iframe.outerWidth(),
                  height: iframe.outerHeight()
                })
                .appendTo(iframe.parent())
                .offset(iframe.offset())[0]
            })
          },

          _unblockFrames: function () {
            if (this.iframeBlocks) {
              this.iframeBlocks.remove()
              delete this.iframeBlocks
            }
          },

          _allowInteraction: function (event) {
            if ($(event.target).closest('.ui-dialog').length) {
              return true
            }

            // TODO: Remove hack when datepicker implements
            // the .ui-front logic (#8989)
            return !!$(event.target).closest('.ui-datepicker').length
          },

          _createOverlay: function () {
            if (!this.options.modal) {
              return
            }

            var jqMinor = $.fn.jquery.substring(0, 4)

            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling (#2804)
            var isOpening = true
            this._delay(function () {
              isOpening = false
            })

            if (!this.document.data('ui-dialog-overlays')) {
              // Prevent use of anchors and inputs
              // This doesn't use `_on()` because it is a shared event handler
              // across all open modal dialogs.
              this.document.on(
                'focusin.ui-dialog',
                function (event) {
                  if (isOpening) {
                    return
                  }

                  var instance = this._trackingInstances()[0]
                  if (!instance._allowInteraction(event)) {
                    event.preventDefault()
                    instance._focusTabbable()

                    // Support: jQuery >=3.4 <3.6 only
                    // Focus re-triggering in jQuery 3.4/3.5 makes the original element
                    // have its focus event propagated last, breaking the re-targeting.
                    // Trigger focus in a delay in addition if needed to avoid the issue
                    // See https://github.com/jquery/jquery/issues/4382
                    if (jqMinor === '3.4.' || jqMinor === '3.5.') {
                      instance._delay(instance._restoreTabbableFocus)
                    }
                  }
                }.bind(this)
              )
            }

            this.overlay = $('<div>').appendTo(this._appendTo())

            this._addClass(this.overlay, null, 'ui-widget-overlay ui-front')
            this._on(this.overlay, {
              mousedown: '_keepFocus'
            })
            this.document.data(
              'ui-dialog-overlays',
              (this.document.data('ui-dialog-overlays') || 0) + 1
            )
          },

          _destroyOverlay: function () {
            if (!this.options.modal) {
              return
            }

            if (this.overlay) {
              var overlays = this.document.data('ui-dialog-overlays') - 1

              if (!overlays) {
                this.document.off('focusin.ui-dialog')
                this.document.removeData('ui-dialog-overlays')
              } else {
                this.document.data('ui-dialog-overlays', overlays)
              }

              this.overlay.remove()
              this.overlay = null
            }
          }
        })

        // DEPRECATED
        // TODO: switch return back to widget declaration at top of file when this is removed
        if ($.uiBackCompat !== false) {
          // Backcompat for dialogClass option
          $.widget('ui.dialog', $.ui.dialog, {
            options: {
              dialogClass: ''
            },
            _createWrapper: function () {
              this._super()
              this.uiDialog.addClass(this.options.dialogClass)
            },
            _setOption: function (key, value) {
              if (key === 'dialogClass') {
                this.uiDialog
                  .removeClass(this.options.dialogClass)
                  .addClass(value)
              }
              this._superApply(arguments)
            }
          })
        }

        return $.ui.dialog
      })

      /***/
    },

    /***/ 7285: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Draggable 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Draggable
      //>>group: Interactions
      //>>description: Enables dragging functionality for any element.
      //>>docs: http://api.jqueryui.com/draggable/
      //>>demos: http://jqueryui.com/draggable/
      //>>css.structure: ../../themes/base/draggable.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(6177),
            __webpack_require__(6400),
            __webpack_require__(1624),
            __webpack_require__(1440),
            __webpack_require__(192),
            __webpack_require__(464),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.draggable', $.ui.mouse, {
          version: '1.13.2',
          widgetEventPrefix: 'drag',
          options: {
            addClasses: true,
            appendTo: 'parent',
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: 'auto',
            cursorAt: false,
            grid: false,
            handle: false,
            helper: 'original',
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: 'default',
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: 'both',
            snapTolerance: 20,
            stack: false,
            zIndex: false,

            // Callbacks
            drag: null,
            start: null,
            stop: null
          },
          _create: function () {
            if (this.options.helper === 'original') {
              this._setPositionRelative()
            }
            if (this.options.addClasses) {
              this._addClass('ui-draggable')
            }
            this._setHandleClassName()

            this._mouseInit()
          },

          _setOption: function (key, value) {
            this._super(key, value)
            if (key === 'handle') {
              this._removeHandleClassName()
              this._setHandleClassName()
            }
          },

          _destroy: function () {
            if ((this.helper || this.element).is('.ui-draggable-dragging')) {
              this.destroyOnClear = true
              return
            }
            this._removeHandleClassName()
            this._mouseDestroy()
          },

          _mouseCapture: function (event) {
            var o = this.options

            // Among others, prevent a drag on a resizable-handle
            if (
              this.helper ||
              o.disabled ||
              $(event.target).closest('.ui-resizable-handle').length > 0
            ) {
              return false
            }

            //Quit if we're not on a valid handle
            this.handle = this._getHandle(event)
            if (!this.handle) {
              return false
            }

            this._blurActiveElement(event)

            this._blockFrames(o.iframeFix === true ? 'iframe' : o.iframeFix)

            return true
          },

          _blockFrames: function (selector) {
            this.iframeBlocks = this.document.find(selector).map(function () {
              var iframe = $(this)

              return $('<div>')
                .css('position', 'absolute')
                .appendTo(iframe.parent())
                .outerWidth(iframe.outerWidth())
                .outerHeight(iframe.outerHeight())
                .offset(iframe.offset())[0]
            })
          },

          _unblockFrames: function () {
            if (this.iframeBlocks) {
              this.iframeBlocks.remove()
              delete this.iframeBlocks
            }
          },

          _blurActiveElement: function (event) {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
              target = $(event.target)

            // Don't blur if the event occurred on an element that is within
            // the currently focused element
            // See #10527, #12472
            if (target.closest(activeElement).length) {
              return
            }

            // Blur any element that currently has focus, see #4261
            $.ui.safeBlur(activeElement)
          },

          _mouseStart: function (event) {
            var o = this.options

            //Create and append the visible helper
            this.helper = this._createHelper(event)

            this._addClass(this.helper, 'ui-draggable-dragging')

            //Cache the helper size
            this._cacheHelperProportions()

            //If ddmanager is used for droppables, set the global draggable
            if ($.ui.ddmanager) {
              $.ui.ddmanager.current = this
            }

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins()

            //Store the helper's css position
            this.cssPosition = this.helper.css('position')
            this.scrollParent = this.helper.scrollParent(true)
            this.offsetParent = this.helper.offsetParent()
            this.hasFixedAncestor =
              this.helper.parents().filter(function () {
                return $(this).css('position') === 'fixed'
              }).length > 0

            //The element's absolute position on the page minus margins
            this.positionAbs = this.element.offset()
            this._refreshOffsets(event)

            //Generate the original position
            this.originalPosition = this.position = this._generatePosition(
              event,
              false
            )
            this.originalPageX = event.pageX
            this.originalPageY = event.pageY

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            if (o.cursorAt) {
              this._adjustOffsetFromHelper(o.cursorAt)
            }

            //Set a containment if given in the options
            this._setContainment()

            //Trigger event + callbacks
            if (this._trigger('start', event) === false) {
              this._clear()
              return false
            }

            //Recache the helper size
            this._cacheHelperProportions()

            //Prepare the droppable offsets
            if ($.ui.ddmanager && !o.dropBehaviour) {
              $.ui.ddmanager.prepareOffsets(this, event)
            }

            // Execute the drag once - this causes the helper not to be visible before getting its
            // correct position
            this._mouseDrag(event, true)

            // If the ddmanager is used for droppables, inform the manager that dragging has started
            // (see #5003)
            if ($.ui.ddmanager) {
              $.ui.ddmanager.dragStart(this, event)
            }

            return true
          },

          _refreshOffsets: function (event) {
            this.offset = {
              top: this.positionAbs.top - this.margins.top,
              left: this.positionAbs.left - this.margins.left,
              scroll: false,
              parent: this._getParentOffset(),
              relative: this._getRelativeOffset()
            }

            this.offset.click = {
              left: event.pageX - this.offset.left,
              top: event.pageY - this.offset.top
            }
          },

          _mouseDrag: function (event, noPropagation) {
            // reset any necessary cached properties (see #5009)
            if (this.hasFixedAncestor) {
              this.offset.parent = this._getParentOffset()
            }

            //Compute the helpers position
            this.position = this._generatePosition(event, true)
            this.positionAbs = this._convertPositionTo('absolute')

            //Call plugins and callbacks and use the resulting position if something is returned
            if (!noPropagation) {
              var ui = this._uiHash()
              if (this._trigger('drag', event, ui) === false) {
                this._mouseUp(new $.Event('mouseup', event))
                return false
              }
              this.position = ui.position
            }

            this.helper[0].style.left = this.position.left + 'px'
            this.helper[0].style.top = this.position.top + 'px'

            if ($.ui.ddmanager) {
              $.ui.ddmanager.drag(this, event)
            }

            return false
          },

          _mouseStop: function (event) {
            //If we are using droppables, inform the manager about the drop
            var that = this,
              dropped = false
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
              dropped = $.ui.ddmanager.drop(this, event)
            }

            //if a drop comes from outside (a sortable)
            if (this.dropped) {
              dropped = this.dropped
              this.dropped = false
            }

            if (
              (this.options.revert === 'invalid' && !dropped) ||
              (this.options.revert === 'valid' && dropped) ||
              this.options.revert === true ||
              (typeof this.options.revert === 'function' &&
                this.options.revert.call(this.element, dropped))
            ) {
              $(this.helper).animate(
                this.originalPosition,
                parseInt(this.options.revertDuration, 10),
                function () {
                  if (that._trigger('stop', event) !== false) {
                    that._clear()
                  }
                }
              )
            } else {
              if (this._trigger('stop', event) !== false) {
                this._clear()
              }
            }

            return false
          },

          _mouseUp: function (event) {
            this._unblockFrames()

            // If the ddmanager is used for droppables, inform the manager that dragging has stopped
            // (see #5003)
            if ($.ui.ddmanager) {
              $.ui.ddmanager.dragStop(this, event)
            }

            // Only need to focus if the event occurred on the draggable itself, see #10527
            if (this.handleElement.is(event.target)) {
              // The interaction is over; whether or not the click resulted in a drag,
              // focus the element
              this.element.trigger('focus')
            }

            return $.ui.mouse.prototype._mouseUp.call(this, event)
          },

          cancel: function () {
            if (this.helper.is('.ui-draggable-dragging')) {
              this._mouseUp(new $.Event('mouseup', { target: this.element[0] }))
            } else {
              this._clear()
            }

            return this
          },

          _getHandle: function (event) {
            return this.options.handle
              ? !!$(event.target).closest(
                  this.element.find(this.options.handle)
                ).length
              : true
          },

          _setHandleClassName: function () {
            this.handleElement = this.options.handle
              ? this.element.find(this.options.handle)
              : this.element
            this._addClass(this.handleElement, 'ui-draggable-handle')
          },

          _removeHandleClassName: function () {
            this._removeClass(this.handleElement, 'ui-draggable-handle')
          },

          _createHelper: function (event) {
            var o = this.options,
              helperIsFunction = typeof o.helper === 'function',
              helper = helperIsFunction
                ? $(o.helper.apply(this.element[0], [event]))
                : o.helper === 'clone'
                  ? this.element.clone().removeAttr('id')
                  : this.element

            if (!helper.parents('body').length) {
              helper.appendTo(
                o.appendTo === 'parent'
                  ? this.element[0].parentNode
                  : o.appendTo
              )
            }

            // Http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            if (helperIsFunction && helper[0] === this.element[0]) {
              this._setPositionRelative()
            }

            if (
              helper[0] !== this.element[0] &&
              !/(fixed|absolute)/.test(helper.css('position'))
            ) {
              helper.css('position', 'absolute')
            }

            return helper
          },

          _setPositionRelative: function () {
            if (!/^(?:r|a|f)/.test(this.element.css('position'))) {
              this.element[0].style.position = 'relative'
            }
          },

          _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === 'string') {
              obj = obj.split(' ')
            }
            if (Array.isArray(obj)) {
              obj = { left: +obj[0], top: +obj[1] || 0 }
            }
            if ('left' in obj) {
              this.offset.click.left = obj.left + this.margins.left
            }
            if ('right' in obj) {
              this.offset.click.left =
                this.helperProportions.width - obj.right + this.margins.left
            }
            if ('top' in obj) {
              this.offset.click.top = obj.top + this.margins.top
            }
            if ('bottom' in obj) {
              this.offset.click.top =
                this.helperProportions.height - obj.bottom + this.margins.top
            }
          },

          _isRootNode: function (element) {
            return (
              /(html|body)/i.test(element.tagName) ||
              element === this.document[0]
            )
          },

          _getParentOffset: function () {
            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(),
              document = this.document[0]

            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if (
              this.cssPosition === 'absolute' &&
              this.scrollParent[0] !== document &&
              $.contains(this.scrollParent[0], this.offsetParent[0])
            ) {
              po.left += this.scrollParent.scrollLeft()
              po.top += this.scrollParent.scrollTop()
            }

            if (this._isRootNode(this.offsetParent[0])) {
              po = { top: 0, left: 0 }
            }

            return {
              top:
                po.top +
                (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
              left:
                po.left +
                (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
            }
          },

          _getRelativeOffset: function () {
            if (this.cssPosition !== 'relative') {
              return { top: 0, left: 0 }
            }

            var p = this.element.position(),
              scrollIsRootNode = this._isRootNode(this.scrollParent[0])

            return {
              top:
                p.top -
                (parseInt(this.helper.css('top'), 10) || 0) +
                (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
              left:
                p.left -
                (parseInt(this.helper.css('left'), 10) || 0) +
                (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
            }
          },

          _cacheMargins: function () {
            this.margins = {
              left: parseInt(this.element.css('marginLeft'), 10) || 0,
              top: parseInt(this.element.css('marginTop'), 10) || 0,
              right: parseInt(this.element.css('marginRight'), 10) || 0,
              bottom: parseInt(this.element.css('marginBottom'), 10) || 0
            }
          },

          _cacheHelperProportions: function () {
            this.helperProportions = {
              width: this.helper.outerWidth(),
              height: this.helper.outerHeight()
            }
          },

          _setContainment: function () {
            var isUserScrollable,
              c,
              ce,
              o = this.options,
              document = this.document[0]

            this.relativeContainer = null

            if (!o.containment) {
              this.containment = null
              return
            }

            if (o.containment === 'window') {
              this.containment = [
                $(window).scrollLeft() -
                  this.offset.relative.left -
                  this.offset.parent.left,
                $(window).scrollTop() -
                  this.offset.relative.top -
                  this.offset.parent.top,
                $(window).scrollLeft() +
                  $(window).width() -
                  this.helperProportions.width -
                  this.margins.left,
                $(window).scrollTop() +
                  ($(window).height() ||
                    document.body.parentNode.scrollHeight) -
                  this.helperProportions.height -
                  this.margins.top
              ]
              return
            }

            if (o.containment === 'document') {
              this.containment = [
                0,
                0,
                $(document).width() -
                  this.helperProportions.width -
                  this.margins.left,
                ($(document).height() ||
                  document.body.parentNode.scrollHeight) -
                  this.helperProportions.height -
                  this.margins.top
              ]
              return
            }

            if (o.containment.constructor === Array) {
              this.containment = o.containment
              return
            }

            if (o.containment === 'parent') {
              o.containment = this.helper[0].parentNode
            }

            c = $(o.containment)
            ce = c[0]

            if (!ce) {
              return
            }

            isUserScrollable = /(scroll|auto)/.test(c.css('overflow'))

            this.containment = [
              (parseInt(c.css('borderLeftWidth'), 10) || 0) +
                (parseInt(c.css('paddingLeft'), 10) || 0),
              (parseInt(c.css('borderTopWidth'), 10) || 0) +
                (parseInt(c.css('paddingTop'), 10) || 0),
              (isUserScrollable
                ? Math.max(ce.scrollWidth, ce.offsetWidth)
                : ce.offsetWidth) -
                (parseInt(c.css('borderRightWidth'), 10) || 0) -
                (parseInt(c.css('paddingRight'), 10) || 0) -
                this.helperProportions.width -
                this.margins.left -
                this.margins.right,
              (isUserScrollable
                ? Math.max(ce.scrollHeight, ce.offsetHeight)
                : ce.offsetHeight) -
                (parseInt(c.css('borderBottomWidth'), 10) || 0) -
                (parseInt(c.css('paddingBottom'), 10) || 0) -
                this.helperProportions.height -
                this.margins.top -
                this.margins.bottom
            ]
            this.relativeContainer = c
          },

          _convertPositionTo: function (d, pos) {
            if (!pos) {
              pos = this.position
            }

            var mod = d === 'absolute' ? 1 : -1,
              scrollIsRootNode = this._isRootNode(this.scrollParent[0])

            return {
              top:
                // The absolute mouse position
                pos.top +
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.top * mod +
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.top * mod -
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.top
                  : scrollIsRootNode
                    ? 0
                    : this.offset.scroll.top) *
                  mod,
              left:
                // The absolute mouse position
                pos.left +
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.left * mod +
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.left * mod -
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.left
                  : scrollIsRootNode
                    ? 0
                    : this.offset.scroll.left) *
                  mod
            }
          },

          _generatePosition: function (event, constrainPosition) {
            var containment,
              co,
              top,
              left,
              o = this.options,
              scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
              pageX = event.pageX,
              pageY = event.pageY

            // Cache the scroll
            if (!scrollIsRootNode || !this.offset.scroll) {
              this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
              }
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            // If we are not dragging yet, we won't check for options
            if (constrainPosition) {
              if (this.containment) {
                if (this.relativeContainer) {
                  co = this.relativeContainer.offset()
                  containment = [
                    this.containment[0] + co.left,
                    this.containment[1] + co.top,
                    this.containment[2] + co.left,
                    this.containment[3] + co.top
                  ]
                } else {
                  containment = this.containment
                }

                if (event.pageX - this.offset.click.left < containment[0]) {
                  pageX = containment[0] + this.offset.click.left
                }
                if (event.pageY - this.offset.click.top < containment[1]) {
                  pageY = containment[1] + this.offset.click.top
                }
                if (event.pageX - this.offset.click.left > containment[2]) {
                  pageX = containment[2] + this.offset.click.left
                }
                if (event.pageY - this.offset.click.top > containment[3]) {
                  pageY = containment[3] + this.offset.click.top
                }
              }

              if (o.grid) {
                //Check for grid elements set to 0 to prevent divide by 0 error causing invalid
                // argument errors in IE (see ticket #6950)
                top = o.grid[1]
                  ? this.originalPageY +
                    Math.round((pageY - this.originalPageY) / o.grid[1]) *
                      o.grid[1]
                  : this.originalPageY
                pageY = containment
                  ? top - this.offset.click.top >= containment[1] ||
                    top - this.offset.click.top > containment[3]
                    ? top
                    : top - this.offset.click.top >= containment[1]
                      ? top - o.grid[1]
                      : top + o.grid[1]
                  : top

                left = o.grid[0]
                  ? this.originalPageX +
                    Math.round((pageX - this.originalPageX) / o.grid[0]) *
                      o.grid[0]
                  : this.originalPageX
                pageX = containment
                  ? left - this.offset.click.left >= containment[0] ||
                    left - this.offset.click.left > containment[2]
                    ? left
                    : left - this.offset.click.left >= containment[0]
                      ? left - o.grid[0]
                      : left + o.grid[0]
                  : left
              }

              if (o.axis === 'y') {
                pageX = this.originalPageX
              }

              if (o.axis === 'x') {
                pageY = this.originalPageY
              }
            }

            return {
              top:
                // The absolute mouse position
                pageY -
                // Click offset (relative to the element)
                this.offset.click.top -
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.top -
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.top +
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.top
                  : scrollIsRootNode
                    ? 0
                    : this.offset.scroll.top),
              left:
                // The absolute mouse position
                pageX -
                // Click offset (relative to the element)
                this.offset.click.left -
                // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.relative.left -
                // The offsetParent's offset without borders (offset + border)
                this.offset.parent.left +
                (this.cssPosition === 'fixed'
                  ? -this.offset.scroll.left
                  : scrollIsRootNode
                    ? 0
                    : this.offset.scroll.left)
            }
          },

          _clear: function () {
            this._removeClass(this.helper, 'ui-draggable-dragging')
            if (
              this.helper[0] !== this.element[0] &&
              !this.cancelHelperRemoval
            ) {
              this.helper.remove()
            }
            this.helper = null
            this.cancelHelperRemoval = false
            if (this.destroyOnClear) {
              this.destroy()
            }
          },

          // From now on bulk stuff - mainly helpers

          _trigger: function (type, event, ui) {
            ui = ui || this._uiHash()
            $.ui.plugin.call(this, type, [event, ui, this], true)

            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            if (/^(drag|start|stop)/.test(type)) {
              this.positionAbs = this._convertPositionTo('absolute')
              ui.offset = this.positionAbs
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui)
          },

          plugins: {},

          _uiHash: function () {
            return {
              helper: this.helper,
              position: this.position,
              originalPosition: this.originalPosition,
              offset: this.positionAbs
            }
          }
        })

        $.ui.plugin.add('draggable', 'connectToSortable', {
          start: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
              item: draggable.element
            })

            draggable.sortables = []
            $(draggable.options.connectToSortable).each(function () {
              var sortable = $(this).sortable('instance')

              if (sortable && !sortable.options.disabled) {
                draggable.sortables.push(sortable)

                // RefreshPositions is called at drag start to refresh the containerCache
                // which is used in drag. This ensures it's initialized and synchronized
                // with any changes that might have happened on the page since initialization.
                sortable.refreshPositions()
                sortable._trigger('activate', event, uiSortable)
              }
            })
          },
          stop: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
              item: draggable.element
            })

            draggable.cancelHelperRemoval = false

            $.each(draggable.sortables, function () {
              var sortable = this

              if (sortable.isOver) {
                sortable.isOver = 0

                // Allow this sortable to handle removing the helper
                draggable.cancelHelperRemoval = true
                sortable.cancelHelperRemoval = false

                // Use _storedCSS To restore properties in the sortable,
                // as this also handles revert (#9675) since the draggable
                // may have modified them in unexpected ways (#8809)
                sortable._storedCSS = {
                  position: sortable.placeholder.css('position'),
                  top: sortable.placeholder.css('top'),
                  left: sortable.placeholder.css('left')
                }

                sortable._mouseStop(event)

                // Once drag has ended, the sortable should return to using
                // its original helper, not the shared helper from draggable
                sortable.options.helper = sortable.options._helper
              } else {
                // Prevent this Sortable from removing the helper.
                // However, don't set the draggable to remove the helper
                // either as another connected Sortable may yet handle the removal.
                sortable.cancelHelperRemoval = true

                sortable._trigger('deactivate', event, uiSortable)
              }
            })
          },
          drag: function (event, ui, draggable) {
            $.each(draggable.sortables, function () {
              var innermostIntersecting = false,
                sortable = this

              // Copy over variables that sortable's _intersectsWith uses
              sortable.positionAbs = draggable.positionAbs
              sortable.helperProportions = draggable.helperProportions
              sortable.offset.click = draggable.offset.click

              if (sortable._intersectsWith(sortable.containerCache)) {
                innermostIntersecting = true

                $.each(draggable.sortables, function () {
                  // Copy over variables that sortable's _intersectsWith uses
                  this.positionAbs = draggable.positionAbs
                  this.helperProportions = draggable.helperProportions
                  this.offset.click = draggable.offset.click

                  if (
                    this !== sortable &&
                    this._intersectsWith(this.containerCache) &&
                    $.contains(sortable.element[0], this.element[0])
                  ) {
                    innermostIntersecting = false
                  }

                  return innermostIntersecting
                })
              }

              if (innermostIntersecting) {
                // If it intersects, we use a little isOver variable and set it once,
                // so that the move-in stuff gets fired only once.
                if (!sortable.isOver) {
                  sortable.isOver = 1

                  // Store draggable's parent in case we need to reappend to it later.
                  draggable._parent = ui.helper.parent()

                  sortable.currentItem = ui.helper
                    .appendTo(sortable.element)
                    .data('ui-sortable-item', true)

                  // Store helper option to later restore it
                  sortable.options._helper = sortable.options.helper

                  sortable.options.helper = function () {
                    return ui.helper[0]
                  }

                  // Fire the start events of the sortable with our passed browser event,
                  // and our own helper (so it doesn't create a new one)
                  event.target = sortable.currentItem[0]
                  sortable._mouseCapture(event, true)
                  sortable._mouseStart(event, true, true)

                  // Because the browser event is way off the new appended portlet,
                  // modify necessary variables to reflect the changes
                  sortable.offset.click.top = draggable.offset.click.top
                  sortable.offset.click.left = draggable.offset.click.left
                  sortable.offset.parent.left -=
                    draggable.offset.parent.left - sortable.offset.parent.left
                  sortable.offset.parent.top -=
                    draggable.offset.parent.top - sortable.offset.parent.top

                  draggable._trigger('toSortable', event)

                  // Inform draggable that the helper is in a valid drop zone,
                  // used solely in the revert option to handle "valid/invalid".
                  draggable.dropped = sortable.element

                  // Need to refreshPositions of all sortables in the case that
                  // adding to one sortable changes the location of the other sortables (#9675)
                  $.each(draggable.sortables, function () {
                    this.refreshPositions()
                  })

                  // Hack so receive/update callbacks work (mostly)
                  draggable.currentItem = draggable.element
                  sortable.fromOutside = draggable
                }

                if (sortable.currentItem) {
                  sortable._mouseDrag(event)

                  // Copy the sortable's position because the draggable's can potentially reflect
                  // a relative position, while sortable is always absolute, which the dragged
                  // element has now become. (#8809)
                  ui.position = sortable.position
                }
              } else {
                // If it doesn't intersect with the sortable, and it intersected before,
                // we fake the drag stop of the sortable, but make sure it doesn't remove
                // the helper by using cancelHelperRemoval.
                if (sortable.isOver) {
                  sortable.isOver = 0
                  sortable.cancelHelperRemoval = true

                  // Calling sortable's mouseStop would trigger a revert,
                  // so revert must be temporarily false until after mouseStop is called.
                  sortable.options._revert = sortable.options.revert
                  sortable.options.revert = false

                  sortable._trigger('out', event, sortable._uiHash(sortable))
                  sortable._mouseStop(event, true)

                  // Restore sortable behaviors that were modfied
                  // when the draggable entered the sortable area (#9481)
                  sortable.options.revert = sortable.options._revert
                  sortable.options.helper = sortable.options._helper

                  if (sortable.placeholder) {
                    sortable.placeholder.remove()
                  }

                  // Restore and recalculate the draggable's offset considering the sortable
                  // may have modified them in unexpected ways. (#8809, #10669)
                  ui.helper.appendTo(draggable._parent)
                  draggable._refreshOffsets(event)
                  ui.position = draggable._generatePosition(event, true)

                  draggable._trigger('fromSortable', event)

                  // Inform draggable that the helper is no longer in a valid drop zone
                  draggable.dropped = false

                  // Need to refreshPositions of all sortables just in case removing
                  // from one sortable changes the location of other sortables (#9675)
                  $.each(draggable.sortables, function () {
                    this.refreshPositions()
                  })
                }
              }
            })
          }
        })

        $.ui.plugin.add('draggable', 'cursor', {
          start: function (event, ui, instance) {
            var t = $('body'),
              o = instance.options

            if (t.css('cursor')) {
              o._cursor = t.css('cursor')
            }
            t.css('cursor', o.cursor)
          },
          stop: function (event, ui, instance) {
            var o = instance.options
            if (o._cursor) {
              $('body').css('cursor', o._cursor)
            }
          }
        })

        $.ui.plugin.add('draggable', 'opacity', {
          start: function (event, ui, instance) {
            var t = $(ui.helper),
              o = instance.options
            if (t.css('opacity')) {
              o._opacity = t.css('opacity')
            }
            t.css('opacity', o.opacity)
          },
          stop: function (event, ui, instance) {
            var o = instance.options
            if (o._opacity) {
              $(ui.helper).css('opacity', o._opacity)
            }
          }
        })

        $.ui.plugin.add('draggable', 'scroll', {
          start: function (event, ui, i) {
            if (!i.scrollParentNotHidden) {
              i.scrollParentNotHidden = i.helper.scrollParent(false)
            }

            if (
              i.scrollParentNotHidden[0] !== i.document[0] &&
              i.scrollParentNotHidden[0].tagName !== 'HTML'
            ) {
              i.overflowOffset = i.scrollParentNotHidden.offset()
            }
          },
          drag: function (event, ui, i) {
            var o = i.options,
              scrolled = false,
              scrollParent = i.scrollParentNotHidden[0],
              document = i.document[0]

            if (scrollParent !== document && scrollParent.tagName !== 'HTML') {
              if (!o.axis || o.axis !== 'x') {
                if (
                  i.overflowOffset.top +
                    scrollParent.offsetHeight -
                    event.pageY <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollTop = scrolled =
                    scrollParent.scrollTop + o.scrollSpeed
                } else if (
                  event.pageY - i.overflowOffset.top <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollTop = scrolled =
                    scrollParent.scrollTop - o.scrollSpeed
                }
              }

              if (!o.axis || o.axis !== 'y') {
                if (
                  i.overflowOffset.left +
                    scrollParent.offsetWidth -
                    event.pageX <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollLeft = scrolled =
                    scrollParent.scrollLeft + o.scrollSpeed
                } else if (
                  event.pageX - i.overflowOffset.left <
                  o.scrollSensitivity
                ) {
                  scrollParent.scrollLeft = scrolled =
                    scrollParent.scrollLeft - o.scrollSpeed
                }
              }
            } else {
              if (!o.axis || o.axis !== 'x') {
                if (
                  event.pageY - $(document).scrollTop() <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollTop(
                    $(document).scrollTop() - o.scrollSpeed
                  )
                } else if (
                  $(window).height() - (event.pageY - $(document).scrollTop()) <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollTop(
                    $(document).scrollTop() + o.scrollSpeed
                  )
                }
              }

              if (!o.axis || o.axis !== 'y') {
                if (
                  event.pageX - $(document).scrollLeft() <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollLeft(
                    $(document).scrollLeft() - o.scrollSpeed
                  )
                } else if (
                  $(window).width() - (event.pageX - $(document).scrollLeft()) <
                  o.scrollSensitivity
                ) {
                  scrolled = $(document).scrollLeft(
                    $(document).scrollLeft() + o.scrollSpeed
                  )
                }
              }
            }

            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
              $.ui.ddmanager.prepareOffsets(i, event)
            }
          }
        })

        $.ui.plugin.add('draggable', 'snap', {
          start: function (event, ui, i) {
            var o = i.options

            i.snapElements = []

            $(
              o.snap.constructor !== String
                ? o.snap.items || ':data(ui-draggable)'
                : o.snap
            ).each(function () {
              var $t = $(this),
                $o = $t.offset()
              if (this !== i.element[0]) {
                i.snapElements.push({
                  item: this,
                  width: $t.outerWidth(),
                  height: $t.outerHeight(),
                  top: $o.top,
                  left: $o.left
                })
              }
            })
          },
          drag: function (event, ui, inst) {
            var ts,
              bs,
              ls,
              rs,
              l,
              r,
              t,
              b,
              i,
              first,
              o = inst.options,
              d = o.snapTolerance,
              x1 = ui.offset.left,
              x2 = x1 + inst.helperProportions.width,
              y1 = ui.offset.top,
              y2 = y1 + inst.helperProportions.height

            for (i = inst.snapElements.length - 1; i >= 0; i--) {
              l = inst.snapElements[i].left - inst.margins.left
              r = l + inst.snapElements[i].width
              t = inst.snapElements[i].top - inst.margins.top
              b = t + inst.snapElements[i].height

              if (
                x2 < l - d ||
                x1 > r + d ||
                y2 < t - d ||
                y1 > b + d ||
                !$.contains(
                  inst.snapElements[i].item.ownerDocument,
                  inst.snapElements[i].item
                )
              ) {
                if (inst.snapElements[i].snapping) {
                  if (inst.options.snap.release) {
                    inst.options.snap.release.call(
                      inst.element,
                      event,
                      $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                      })
                    )
                  }
                }
                inst.snapElements[i].snapping = false
                continue
              }

              if (o.snapMode !== 'inner') {
                ts = Math.abs(t - y2) <= d
                bs = Math.abs(b - y1) <= d
                ls = Math.abs(l - x2) <= d
                rs = Math.abs(r - x1) <= d
                if (ts) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: t - inst.helperProportions.height,
                    left: 0
                  }).top
                }
                if (bs) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: b,
                    left: 0
                  }).top
                }
                if (ls) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: l - inst.helperProportions.width
                  }).left
                }
                if (rs) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: r
                  }).left
                }
              }

              first = ts || bs || ls || rs

              if (o.snapMode !== 'outer') {
                ts = Math.abs(t - y1) <= d
                bs = Math.abs(b - y2) <= d
                ls = Math.abs(l - x1) <= d
                rs = Math.abs(r - x2) <= d
                if (ts) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: t,
                    left: 0
                  }).top
                }
                if (bs) {
                  ui.position.top = inst._convertPositionTo('relative', {
                    top: b - inst.helperProportions.height,
                    left: 0
                  }).top
                }
                if (ls) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: l
                  }).left
                }
                if (rs) {
                  ui.position.left = inst._convertPositionTo('relative', {
                    top: 0,
                    left: r - inst.helperProportions.width
                  }).left
                }
              }

              if (
                !inst.snapElements[i].snapping &&
                (ts || bs || ls || rs || first)
              ) {
                if (inst.options.snap.snap) {
                  inst.options.snap.snap.call(
                    inst.element,
                    event,
                    $.extend(inst._uiHash(), {
                      snapItem: inst.snapElements[i].item
                    })
                  )
                }
              }
              inst.snapElements[i].snapping = ts || bs || ls || rs || first
            }
          }
        })

        $.ui.plugin.add('draggable', 'stack', {
          start: function (event, ui, instance) {
            var min,
              o = instance.options,
              group = $.makeArray($(o.stack)).sort(function (a, b) {
                return (
                  (parseInt($(a).css('zIndex'), 10) || 0) -
                  (parseInt($(b).css('zIndex'), 10) || 0)
                )
              })

            if (!group.length) {
              return
            }

            min = parseInt($(group[0]).css('zIndex'), 10) || 0
            $(group).each(function (i) {
              $(this).css('zIndex', min + i)
            })
            this.css('zIndex', min + group.length)
          }
        })

        $.ui.plugin.add('draggable', 'zIndex', {
          start: function (event, ui, instance) {
            var t = $(ui.helper),
              o = instance.options

            if (t.css('zIndex')) {
              o._zIndex = t.css('zIndex')
            }
            t.css('zIndex', o.zIndex)
          },
          stop: function (event, ui, instance) {
            var o = instance.options

            if (o._zIndex) {
              $(ui.helper).css('zIndex', o._zIndex)
            }
          }
        })

        return $.ui.draggable
      })

      /***/
    },

    /***/ 8851: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Menu 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Menu
      //>>group: Widgets
      //>>description: Creates nestable menus.
      //>>docs: http://api.jqueryui.com/menu/
      //>>demos: http://jqueryui.com/menu/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/menu.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(7053),
            __webpack_require__(1822),
            __webpack_require__(1440),
            __webpack_require__(9138),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        return $.widget('ui.menu', {
          version: '1.13.2',
          defaultElement: '<ul>',
          delay: 300,
          options: {
            icons: {
              submenu: 'ui-icon-caret-1-e'
            },
            items: '> *',
            menus: 'ul',
            position: {
              my: 'left top',
              at: 'right top'
            },
            role: 'menu',

            // Callbacks
            blur: null,
            focus: null,
            select: null
          },

          _create: function () {
            this.activeMenu = this.element

            // Flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = false
            this.lastMousePosition = { x: null, y: null }
            this.element.uniqueId().attr({
              role: this.options.role,
              tabIndex: 0
            })

            this._addClass('ui-menu', 'ui-widget ui-widget-content')
            this._on({
              // Prevent focus from sticking to links inside menu after clicking
              // them (focus should always stay on UL during navigation).
              'mousedown .ui-menu-item': function (event) {
                event.preventDefault()

                this._activateItem(event)
              },
              'click .ui-menu-item': function (event) {
                var target = $(event.target)
                var active = $($.ui.safeActiveElement(this.document[0]))
                if (
                  !this.mouseHandled &&
                  target.not('.ui-state-disabled').length
                ) {
                  this.select(event)

                  // Only set the mouseHandled flag if the event will bubble, see #9469.
                  if (!event.isPropagationStopped()) {
                    this.mouseHandled = true
                  }

                  // Open submenu on click
                  if (target.has('.ui-menu').length) {
                    this.expand(event)
                  } else if (
                    !this.element.is(':focus') &&
                    active.closest('.ui-menu').length
                  ) {
                    // Redirect focus to the menu
                    this.element.trigger('focus', [true])

                    // If the active item is on the top level, let it stay active.
                    // Otherwise, blur the active item since it is no longer visible.
                    if (
                      this.active &&
                      this.active.parents('.ui-menu').length === 1
                    ) {
                      clearTimeout(this.timer)
                    }
                  }
                }
              },
              'mouseenter .ui-menu-item': '_activateItem',
              'mousemove .ui-menu-item': '_activateItem',
              mouseleave: 'collapseAll',
              'mouseleave .ui-menu': 'collapseAll',
              focus: function (event, keepActiveItem) {
                // If there's already an active item, keep it active
                // If not, activate the first item
                var item = this.active || this._menuItems().first()

                if (!keepActiveItem) {
                  this.focus(event, item)
                }
              },
              blur: function (event) {
                this._delay(function () {
                  var notContained = !$.contains(
                    this.element[0],
                    $.ui.safeActiveElement(this.document[0])
                  )
                  if (notContained) {
                    this.collapseAll(event)
                  }
                })
              },
              keydown: '_keydown'
            })

            this.refresh()

            // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
              click: function (event) {
                if (this._closeOnDocumentClick(event)) {
                  this.collapseAll(event, true)
                }

                // Reset the mouseHandled flag
                this.mouseHandled = false
              }
            })
          },

          _activateItem: function (event) {
            // Ignore mouse events while typeahead is active, see #10458.
            // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
            // is over an item in the menu
            if (this.previousFilter) {
              return
            }

            // If the mouse didn't actually move, but the page was scrolled, ignore the event (#9356)
            if (
              event.clientX === this.lastMousePosition.x &&
              event.clientY === this.lastMousePosition.y
            ) {
              return
            }

            this.lastMousePosition = {
              x: event.clientX,
              y: event.clientY
            }

            var actualTarget = $(event.target).closest('.ui-menu-item'),
              target = $(event.currentTarget)

            // Ignore bubbled events on parent items, see #11641
            if (actualTarget[0] !== target[0]) {
              return
            }

            // If the item is already active, there's nothing to do
            if (target.is('.ui-state-active')) {
              return
            }

            // Remove ui-state-active class from siblings of the newly focused menu item
            // to avoid a jump caused by adjacent elements both having a class with a border
            this._removeClass(
              target.siblings().children('.ui-state-active'),
              null,
              'ui-state-active'
            )
            this.focus(event, target)
          },

          _destroy: function () {
            var items = this.element
                .find('.ui-menu-item')
                .removeAttr('role aria-disabled'),
              submenus = items
                .children('.ui-menu-item-wrapper')
                .removeUniqueId()
                .removeAttr('tabIndex role aria-haspopup')

            // Destroy (sub)menus
            this.element
              .removeAttr('aria-activedescendant')
              .find('.ui-menu')
              .addBack()
              .removeAttr(
                'role aria-labelledby aria-expanded aria-hidden aria-disabled ' +
                  'tabIndex'
              )
              .removeUniqueId()
              .show()

            submenus.children().each(function () {
              var elem = $(this)
              if (elem.data('ui-menu-submenu-caret')) {
                elem.remove()
              }
            })
          },

          _keydown: function (event) {
            var match,
              prev,
              character,
              skip,
              preventDefault = true

            switch (event.keyCode) {
              case $.ui.keyCode.PAGE_UP:
                this.previousPage(event)
                break
              case $.ui.keyCode.PAGE_DOWN:
                this.nextPage(event)
                break
              case $.ui.keyCode.HOME:
                this._move('first', 'first', event)
                break
              case $.ui.keyCode.END:
                this._move('last', 'last', event)
                break
              case $.ui.keyCode.UP:
                this.previous(event)
                break
              case $.ui.keyCode.DOWN:
                this.next(event)
                break
              case $.ui.keyCode.LEFT:
                this.collapse(event)
                break
              case $.ui.keyCode.RIGHT:
                if (this.active && !this.active.is('.ui-state-disabled')) {
                  this.expand(event)
                }
                break
              case $.ui.keyCode.ENTER:
              case $.ui.keyCode.SPACE:
                this._activate(event)
                break
              case $.ui.keyCode.ESCAPE:
                this.collapse(event)
                break
              default:
                preventDefault = false
                prev = this.previousFilter || ''
                skip = false

                // Support number pad values
                character =
                  event.keyCode >= 96 && event.keyCode <= 105
                    ? (event.keyCode - 96).toString()
                    : String.fromCharCode(event.keyCode)

                clearTimeout(this.filterTimer)

                if (character === prev) {
                  skip = true
                } else {
                  character = prev + character
                }

                match = this._filterMenuItems(character)
                match =
                  skip && match.index(this.active.next()) !== -1
                    ? this.active.nextAll('.ui-menu-item')
                    : match

                // If no matches on the current filter, reset to the last character pressed
                // to move down the menu to the first item that starts with that character
                if (!match.length) {
                  character = String.fromCharCode(event.keyCode)
                  match = this._filterMenuItems(character)
                }

                if (match.length) {
                  this.focus(event, match)
                  this.previousFilter = character
                  this.filterTimer = this._delay(function () {
                    delete this.previousFilter
                  }, 1000)
                } else {
                  delete this.previousFilter
                }
            }

            if (preventDefault) {
              event.preventDefault()
            }
          },

          _activate: function (event) {
            if (this.active && !this.active.is('.ui-state-disabled')) {
              if (this.active.children("[aria-haspopup='true']").length) {
                this.expand(event)
              } else {
                this.select(event)
              }
            }
          },

          refresh: function () {
            var menus,
              items,
              newSubmenus,
              newItems,
              newWrappers,
              that = this,
              icon = this.options.icons.submenu,
              submenus = this.element.find(this.options.menus)

            this._toggleClass(
              'ui-menu-icons',
              null,
              !!this.element.find('.ui-icon').length
            )

            // Initialize nested menus
            newSubmenus = submenus
              .filter(':not(.ui-menu)')
              .hide()
              .attr({
                role: this.options.role,
                'aria-hidden': 'true',
                'aria-expanded': 'false'
              })
              .each(function () {
                var menu = $(this),
                  item = menu.prev(),
                  submenuCaret = $('<span>').data('ui-menu-submenu-caret', true)

                that._addClass(submenuCaret, 'ui-menu-icon', 'ui-icon ' + icon)
                item.attr('aria-haspopup', 'true').prepend(submenuCaret)
                menu.attr('aria-labelledby', item.attr('id'))
              })

            this._addClass(
              newSubmenus,
              'ui-menu',
              'ui-widget ui-widget-content ui-front'
            )

            menus = submenus.add(this.element)
            items = menus.find(this.options.items)

            // Initialize menu-items containing spaces and/or dashes only as dividers
            items.not('.ui-menu-item').each(function () {
              var item = $(this)
              if (that._isDivider(item)) {
                that._addClass(item, 'ui-menu-divider', 'ui-widget-content')
              }
            })

            // Don't refresh list items that are already adapted
            newItems = items.not('.ui-menu-item, .ui-menu-divider')
            newWrappers = newItems.children().not('.ui-menu').uniqueId().attr({
              tabIndex: -1,
              role: this._itemRole()
            })
            this._addClass(newItems, 'ui-menu-item')._addClass(
              newWrappers,
              'ui-menu-item-wrapper'
            )

            // Add aria-disabled attribute to any disabled menu item
            items.filter('.ui-state-disabled').attr('aria-disabled', 'true')

            // If the active item has been removed, blur the menu
            if (this.active && !$.contains(this.element[0], this.active[0])) {
              this.blur()
            }
          },

          _itemRole: function () {
            return {
              menu: 'menuitem',
              listbox: 'option'
            }[this.options.role]
          },

          _setOption: function (key, value) {
            if (key === 'icons') {
              var icons = this.element.find('.ui-menu-icon')
              this._removeClass(
                icons,
                null,
                this.options.icons.submenu
              )._addClass(icons, null, value.submenu)
            }
            this._super(key, value)
          },

          _setOptionDisabled: function (value) {
            this._super(value)

            this.element.attr('aria-disabled', String(value))
            this._toggleClass(null, 'ui-state-disabled', !!value)
          },

          focus: function (event, item) {
            var nested, focused, activeParent
            this.blur(event, event && event.type === 'focus')

            this._scrollIntoView(item)

            this.active = item.first()

            focused = this.active.children('.ui-menu-item-wrapper')
            this._addClass(focused, null, 'ui-state-active')

            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if (this.options.role) {
              this.element.attr('aria-activedescendant', focused.attr('id'))
            }

            // Highlight active parent menu item, if any
            activeParent = this.active
              .parent()
              .closest('.ui-menu-item')
              .children('.ui-menu-item-wrapper')
            this._addClass(activeParent, null, 'ui-state-active')

            if (event && event.type === 'keydown') {
              this._close()
            } else {
              this.timer = this._delay(function () {
                this._close()
              }, this.delay)
            }

            nested = item.children('.ui-menu')
            if (nested.length && event && /^mouse/.test(event.type)) {
              this._startOpening(nested)
            }
            this.activeMenu = item.parent()

            this._trigger('focus', event, { item: item })
          },

          _scrollIntoView: function (item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight
            if (this._hasScroll()) {
              borderTop =
                parseFloat($.css(this.activeMenu[0], 'borderTopWidth')) || 0
              paddingTop =
                parseFloat($.css(this.activeMenu[0], 'paddingTop')) || 0
              offset =
                item.offset().top -
                this.activeMenu.offset().top -
                borderTop -
                paddingTop
              scroll = this.activeMenu.scrollTop()
              elementHeight = this.activeMenu.height()
              itemHeight = item.outerHeight()

              if (offset < 0) {
                this.activeMenu.scrollTop(scroll + offset)
              } else if (offset + itemHeight > elementHeight) {
                this.activeMenu.scrollTop(
                  scroll + offset - elementHeight + itemHeight
                )
              }
            }
          },

          blur: function (event, fromFocus) {
            if (!fromFocus) {
              clearTimeout(this.timer)
            }

            if (!this.active) {
              return
            }

            this._removeClass(
              this.active.children('.ui-menu-item-wrapper'),
              null,
              'ui-state-active'
            )

            this._trigger('blur', event, { item: this.active })
            this.active = null
          },

          _startOpening: function (submenu) {
            clearTimeout(this.timer)

            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the caret icon
            if (submenu.attr('aria-hidden') !== 'true') {
              return
            }

            this.timer = this._delay(function () {
              this._close()
              this._open(submenu)
            }, this.delay)
          },

          _open: function (submenu) {
            var position = $.extend(
              {
                of: this.active
              },
              this.options.position
            )

            clearTimeout(this.timer)
            this.element
              .find('.ui-menu')
              .not(submenu.parents('.ui-menu'))
              .hide()
              .attr('aria-hidden', 'true')

            submenu
              .show()
              .removeAttr('aria-hidden')
              .attr('aria-expanded', 'true')
              .position(position)
          },

          collapseAll: function (event, all) {
            clearTimeout(this.timer)
            this.timer = this._delay(
              function () {
                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all
                  ? this.element
                  : $(event && event.target).closest(
                      this.element.find('.ui-menu')
                    )

                // If we found no valid submenu ancestor, use the main menu to close all
                // sub menus anyway
                if (!currentMenu.length) {
                  currentMenu = this.element
                }

                this._close(currentMenu)

                this.blur(event)

                // Work around active item staying active after menu is blurred
                this._removeClass(
                  currentMenu.find('.ui-state-active'),
                  null,
                  'ui-state-active'
                )

                this.activeMenu = currentMenu
              },
              all ? 0 : this.delay
            )
          },

          // With no arguments, closes the currently active menu - if nothing is active
          // it closes all menus.  If passed an argument, it will search for menus BELOW
          _close: function (startMenu) {
            if (!startMenu) {
              startMenu = this.active ? this.active.parent() : this.element
            }

            startMenu
              .find('.ui-menu')
              .hide()
              .attr('aria-hidden', 'true')
              .attr('aria-expanded', 'false')
          },

          _closeOnDocumentClick: function (event) {
            return !$(event.target).closest('.ui-menu').length
          },

          _isDivider: function (item) {
            // Match hyphen, em dash, en dash
            return !/[^\-\u2014\u2013\s]/.test(item.text())
          },

          collapse: function (event) {
            var newItem =
              this.active &&
              this.active.parent().closest('.ui-menu-item', this.element)
            if (newItem && newItem.length) {
              this._close()
              this.focus(event, newItem)
            }
          },

          expand: function (event) {
            var newItem =
              this.active &&
              this._menuItems(this.active.children('.ui-menu')).first()

            if (newItem && newItem.length) {
              this._open(newItem.parent())

              // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
              this._delay(function () {
                this.focus(event, newItem)
              })
            }
          },

          next: function (event) {
            this._move('next', 'first', event)
          },

          previous: function (event) {
            this._move('prev', 'last', event)
          },

          isFirstItem: function () {
            return this.active && !this.active.prevAll('.ui-menu-item').length
          },

          isLastItem: function () {
            return this.active && !this.active.nextAll('.ui-menu-item').length
          },

          _menuItems: function (menu) {
            return (menu || this.element)
              .find(this.options.items)
              .filter('.ui-menu-item')
          },

          _move: function (direction, filter, event) {
            var next
            if (this.active) {
              if (direction === 'first' || direction === 'last') {
                next =
                  this.active[direction === 'first' ? 'prevAll' : 'nextAll'](
                    '.ui-menu-item'
                  ).last()
              } else {
                next = this.active[direction + 'All']('.ui-menu-item').first()
              }
            }
            if (!next || !next.length || !this.active) {
              next = this._menuItems(this.activeMenu)[filter]()
            }

            this.focus(event, next)
          },

          nextPage: function (event) {
            var item, base, height

            if (!this.active) {
              this.next(event)
              return
            }
            if (this.isLastItem()) {
              return
            }
            if (this._hasScroll()) {
              base = this.active.offset().top
              height = this.element.innerHeight()

              // jQuery 3.2 doesn't include scrollbars in innerHeight, add it back.
              if ($.fn.jquery.indexOf('3.2.') === 0) {
                height +=
                  this.element[0].offsetHeight - this.element.outerHeight()
              }

              this.active.nextAll('.ui-menu-item').each(function () {
                item = $(this)
                return item.offset().top - base - height < 0
              })

              this.focus(event, item)
            } else {
              this.focus(
                event,
                this._menuItems(this.activeMenu)[
                  !this.active ? 'first' : 'last'
                ]()
              )
            }
          },

          previousPage: function (event) {
            var item, base, height
            if (!this.active) {
              this.next(event)
              return
            }
            if (this.isFirstItem()) {
              return
            }
            if (this._hasScroll()) {
              base = this.active.offset().top
              height = this.element.innerHeight()

              // jQuery 3.2 doesn't include scrollbars in innerHeight, add it back.
              if ($.fn.jquery.indexOf('3.2.') === 0) {
                height +=
                  this.element[0].offsetHeight - this.element.outerHeight()
              }

              this.active.prevAll('.ui-menu-item').each(function () {
                item = $(this)
                return item.offset().top - base + height > 0
              })

              this.focus(event, item)
            } else {
              this.focus(event, this._menuItems(this.activeMenu).first())
            }
          },

          _hasScroll: function () {
            return (
              this.element.outerHeight() < this.element.prop('scrollHeight')
            )
          },

          select: function (event) {
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active =
              this.active || $(event.target).closest('.ui-menu-item')
            var ui = { item: this.active }
            if (!this.active.has('.ui-menu').length) {
              this.collapseAll(event, true)
            }
            this._trigger('select', event, ui)
          },

          _filterMenuItems: function (character) {
            var escapedCharacter = character.replace(
                /[\-\[\]{}()*+?.,\\\^$|#\s]/g,
                '\\$&'
              ),
              regex = new RegExp('^' + escapedCharacter, 'i')

            return (
              this.activeMenu
                .find(this.options.items)

                // Only match on items, not dividers or other content (#10571)
                .filter('.ui-menu-item')
                .filter(function () {
                  return regex.test(
                    String.prototype.trim.call(
                      $(this).children('.ui-menu-item-wrapper').text()
                    )
                  )
                })
            )
          }
        })
      })

      /***/
    },

    /***/ 6177: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Mouse 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Mouse
      //>>group: Widgets
      //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
      //>>docs: http://api.jqueryui.com/mouse/

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(1870),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        var mouseHandled = false
        $(document).on('mouseup', function () {
          mouseHandled = false
        })

        return $.widget('ui.mouse', {
          version: '1.13.2',
          options: {
            cancel: 'input, textarea, button, select, option',
            distance: 1,
            delay: 0
          },
          _mouseInit: function () {
            var that = this

            this.element
              .on('mousedown.' + this.widgetName, function (event) {
                return that._mouseDown(event)
              })
              .on('click.' + this.widgetName, function (event) {
                if (
                  true ===
                  $.data(event.target, that.widgetName + '.preventClickEvent')
                ) {
                  $.removeData(
                    event.target,
                    that.widgetName + '.preventClickEvent'
                  )
                  event.stopImmediatePropagation()
                  return false
                }
              })

            this.started = false
          },

          // TODO: make sure destroying one instance of mouse doesn't mess with
          // other instances of mouse
          _mouseDestroy: function () {
            this.element.off('.' + this.widgetName)
            if (this._mouseMoveDelegate) {
              this.document
                .off('mousemove.' + this.widgetName, this._mouseMoveDelegate)
                .off('mouseup.' + this.widgetName, this._mouseUpDelegate)
            }
          },

          _mouseDown: function (event) {
            // don't let more than one widget handle mouseStart
            if (mouseHandled) {
              return
            }

            this._mouseMoved = false

            // We may have missed mouseup (out of window)
            if (this._mouseStarted) {
              this._mouseUp(event)
            }

            this._mouseDownEvent = event

            var that = this,
              btnIsLeft = event.which === 1,
              // event.target.nodeName works around a bug in IE 8 with
              // disabled inputs (#7620)
              elIsCancel =
                typeof this.options.cancel === 'string' && event.target.nodeName
                  ? $(event.target).closest(this.options.cancel).length
                  : false
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
              return true
            }

            this.mouseDelayMet = !this.options.delay
            if (!this.mouseDelayMet) {
              this._mouseDelayTimer = setTimeout(function () {
                that.mouseDelayMet = true
              }, this.options.delay)
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
              this._mouseStarted = this._mouseStart(event) !== false
              if (!this._mouseStarted) {
                event.preventDefault()
                return true
              }
            }

            // Click event may never have fired (Gecko & Opera)
            if (
              true ===
              $.data(event.target, this.widgetName + '.preventClickEvent')
            ) {
              $.removeData(event.target, this.widgetName + '.preventClickEvent')
            }

            // These delegates are required to keep context
            this._mouseMoveDelegate = function (event) {
              return that._mouseMove(event)
            }
            this._mouseUpDelegate = function (event) {
              return that._mouseUp(event)
            }

            this.document
              .on('mousemove.' + this.widgetName, this._mouseMoveDelegate)
              .on('mouseup.' + this.widgetName, this._mouseUpDelegate)

            event.preventDefault()

            mouseHandled = true
            return true
          },

          _mouseMove: function (event) {
            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if (this._mouseMoved) {
              // IE mouseup check - mouseup happened when mouse was out of window
              if (
                $.ui.ie &&
                (!document.documentMode || document.documentMode < 9) &&
                !event.button
              ) {
                return this._mouseUp(event)

                // Iframe mouseup check - mouseup occurred in another document
              } else if (!event.which) {
                // Support: Safari <=8 - 9
                // Safari sets which to 0 if you press any of the following keys
                // during a drag (#14461)
                if (
                  event.originalEvent.altKey ||
                  event.originalEvent.ctrlKey ||
                  event.originalEvent.metaKey ||
                  event.originalEvent.shiftKey
                ) {
                  this.ignoreMissingWhich = true
                } else if (!this.ignoreMissingWhich) {
                  return this._mouseUp(event)
                }
              }
            }

            if (event.which || event.button) {
              this._mouseMoved = true
            }

            if (this._mouseStarted) {
              this._mouseDrag(event)
              return event.preventDefault()
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
              this._mouseStarted =
                this._mouseStart(this._mouseDownEvent, event) !== false
              if (this._mouseStarted) {
                this._mouseDrag(event)
              } else {
                this._mouseUp(event)
              }
            }

            return !this._mouseStarted
          },

          _mouseUp: function (event) {
            this.document
              .off('mousemove.' + this.widgetName, this._mouseMoveDelegate)
              .off('mouseup.' + this.widgetName, this._mouseUpDelegate)

            if (this._mouseStarted) {
              this._mouseStarted = false

              if (event.target === this._mouseDownEvent.target) {
                $.data(
                  event.target,
                  this.widgetName + '.preventClickEvent',
                  true
                )
              }

              this._mouseStop(event)
            }

            if (this._mouseDelayTimer) {
              clearTimeout(this._mouseDelayTimer)
              delete this._mouseDelayTimer
            }

            this.ignoreMissingWhich = false
            mouseHandled = false
            event.preventDefault()
          },

          _mouseDistanceMet: function (event) {
            return (
              Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
              ) >= this.options.distance
            )
          },

          _mouseDelayMet: function (/* event */) {
            return this.mouseDelayMet
          },

          // These are placeholder methods, to be overriden by extending plugin
          _mouseStart: function (/* event */) {},
          _mouseDrag: function (/* event */) {},
          _mouseStop: function (/* event */) {},
          _mouseCapture: function (/* event */) {
            return true
          }
        })
      })

      /***/
    },

    /***/ 1707: /***/ (module, exports, __webpack_require__) => {
      var __WEBPACK_AMD_DEFINE_FACTORY__,
        __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery UI Resizable 1.13.2
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       */

      //>>label: Resizable
      //>>group: Interactions
      //>>description: Enables resize functionality for any element.
      //>>docs: http://api.jqueryui.com/resizable/
      //>>demos: http://jqueryui.com/resizable/
      //>>css.structure: ../../themes/base/core.css
      //>>css.structure: ../../themes/base/resizable.css
      //>>css.theme: ../../themes/base/theme.css

      ;(function (factory) {
        'use strict'

        if (true) {
          // AMD. Register as an anonymous module.
          !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(9755),
            __webpack_require__(6177),
            __webpack_require__(2064),
            __webpack_require__(1624),
            __webpack_require__(5592),
            __webpack_require__(6891)
          ]),
          (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
          (__WEBPACK_AMD_DEFINE_RESULT__ =
            typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
              ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                  exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__
                )
              : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
            (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else {
        }
      })(function ($) {
        'use strict'

        $.widget('ui.resizable', $.ui.mouse, {
          version: '1.13.2',
          widgetEventPrefix: 'resize',
          options: {
            alsoResize: false,
            animate: false,
            animateDuration: 'slow',
            animateEasing: 'swing',
            aspectRatio: false,
            autoHide: false,
            classes: {
              'ui-resizable-se': 'ui-icon ui-icon-gripsmall-diagonal-se'
            },
            containment: false,
            ghost: false,
            grid: false,
            handles: 'e,s,se',
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,

            // See #7960
            zIndex: 90,

            // Callbacks
            resize: null,
            start: null,
            stop: null
          },

          _num: function (value) {
            return parseFloat(value) || 0
          },

          _isNumber: function (value) {
            return !isNaN(parseFloat(value))
          },

          _hasScroll: function (el, a) {
            if ($(el).css('overflow') === 'hidden') {
              return false
            }

            var scroll = a && a === 'left' ? 'scrollLeft' : 'scrollTop',
              has = false

            if (el[scroll] > 0) {
              return true
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            try {
              el[scroll] = 1
              has = el[scroll] > 0
              el[scroll] = 0
            } catch (e) {
              // `el` might be a string, then setting `scroll` will throw
              // an error in strict mode; ignore it.
            }
            return has
          },

          _create: function () {
            var margins,
              o = this.options,
              that = this
            this._addClass('ui-resizable')

            $.extend(this, {
              _aspectRatio: !!o.aspectRatio,
              aspectRatio: o.aspectRatio,
              originalElement: this.element,
              _proportionallyResizeElements: [],
              _helper:
                o.helper || o.ghost || o.animate
                  ? o.helper || 'ui-resizable-helper'
                  : null
            })

            // Wrap the element if it cannot hold child nodes
            if (
              this.element[0].nodeName.match(
                /^(canvas|textarea|input|select|button|img)$/i
              )
            ) {
              this.element.wrap(
                $("<div class='ui-wrapper'></div>").css({
                  overflow: 'hidden',
                  position: this.element.css('position'),
                  width: this.element.outerWidth(),
                  height: this.element.outerHeight(),
                  top: this.element.css('top'),
                  left: this.element.css('left')
                })
              )

              this.element = this.element
                .parent()
                .data('ui-resizable', this.element.resizable('instance'))

              this.elementIsWrapper = true

              margins = {
                marginTop: this.originalElement.css('marginTop'),
                marginRight: this.originalElement.css('marginRight'),
                marginBottom: this.originalElement.css('marginBottom'),
                marginLeft: this.originalElement.css('marginLeft')
              }

              this.element.css(margins)
              this.originalElement.css('margin', 0)

              // support: Safari
              // Prevent Safari textarea resize
              this.originalResizeStyle = this.originalElement.css('resize')
              this.originalElement.css('resize', 'none')

              this._proportionallyResizeElements.push(
                this.originalElement.css({
                  position: 'static',
                  zoom: 1,
                  display: 'block'
                })
              )

              // Support: IE9
              // avoid IE jump (hard set the margin)
              this.originalElement.css(margins)

              this._proportionallyResize()
            }

            this._setupHandles()

            if (o.autoHide) {
              $(this.element)
                .on('mouseenter', function () {
                  if (o.disabled) {
                    return
                  }
                  that._removeClass('ui-resizable-autohide')
                  that._handles.show()
                })
                .on('mouseleave', function () {
                  if (o.disabled) {
                    return
                  }
                  if (!that.resizing) {
                    that._addClass('ui-resizable-autohide')
                    that._handles.hide()
                  }
                })
            }

            this._mouseInit()
          },

          _destroy: function () {
            this._mouseDestroy()
            this._addedHandles.remove()

            var wrapper,
              _destroy = function (exp) {
                $(exp)
                  .removeData('resizable')
                  .removeData('ui-resizable')
                  .off('.resizable')
              }

            // TODO: Unwrap at same DOM position
            if (this.elementIsWrapper) {
              _destroy(this.element)
              wrapper = this.element
              this.originalElement
                .css({
                  position: wrapper.css('position'),
                  width: wrapper.outerWidth(),
                  height: wrapper.outerHeight(),
                  top: wrapper.css('top'),
                  left: wrapper.css('left')
                })
                .insertAfter(wrapper)
              wrapper.remove()
            }

            this.originalElement.css('resize', this.originalResizeStyle)
            _destroy(this.originalElement)

            return this
          },

          _setOption: function (key, value) {
            this._super(key, value)

            switch (key) {
              case 'handles':
                this._removeHandles()
                this._setupHandles()
                break
              case 'aspectRatio':
                this._aspectRatio = !!value
                break
              default:
                break
            }
          },

          _setupHandles: function () {
            var o = this.options,
              handle,
              i,
              n,
              hname,
              axis,
              that = this
            this.handles =
              o.handles ||
              (!$('.ui-resizable-handle', this.element).length
                ? 'e,s,se'
                : {
                    n: '.ui-resizable-n',
                    e: '.ui-resizable-e',
                    s: '.ui-resizable-s',
                    w: '.ui-resizable-w',
                    se: '.ui-resizable-se',
                    sw: '.ui-resizable-sw',
                    ne: '.ui-resizable-ne',
                    nw: '.ui-resizable-nw'
                  })

            this._handles = $()
            this._addedHandles = $()
            if (this.handles.constructor === String) {
              if (this.handles === 'all') {
                this.handles = 'n,e,s,w,se,sw,ne,nw'
              }

              n = this.handles.split(',')
              this.handles = {}

              for (i = 0; i < n.length; i++) {
                handle = String.prototype.trim.call(n[i])
                hname = 'ui-resizable-' + handle
                axis = $('<div>')
                this._addClass(axis, 'ui-resizable-handle ' + hname)

                axis.css({ zIndex: o.zIndex })

                this.handles[handle] = '.ui-resizable-' + handle
                if (!this.element.children(this.handles[handle]).length) {
                  this.element.append(axis)
                  this._addedHandles = this._addedHandles.add(axis)
                }
              }
            }

            this._renderAxis = function (target) {
              var i, axis, padPos, padWrapper

              target = target || this.element

              for (i in this.handles) {
                if (this.handles[i].constructor === String) {
                  this.handles[i] = this.element
                    .children(this.handles[i])
                    .first()
                    .show()
                } else if (this.handles[i].jquery || this.handles[i].nodeType) {
                  this.handles[i] = $(this.handles[i])
                  this._on(this.handles[i], { mousedown: that._mouseDown })
                }

                if (
                  this.elementIsWrapper &&
                  this.originalElement[0].nodeName.match(
                    /^(textarea|input|select|button)$/i
                  )
                ) {
                  axis = $(this.handles[i], this.element)

                  padWrapper = /sw|ne|nw|se|n|s/.test(i)
                    ? axis.outerHeight()
                    : axis.outerWidth()

                  padPos = [
                    'padding',
                    /ne|nw|n/.test(i)
                      ? 'Top'
                      : /se|sw|s/.test(i)
                        ? 'Bottom'
                        : /^e$/.test(i)
                          ? 'Right'
                          : 'Left'
                  ].join('')

                  target.css(padPos, padWrapper)

                  this._proportionallyResize()
                }

                this._handles = this._handles.add(this.handles[i])
              }
            }

            // TODO: make renderAxis a prototype function
            this._renderAxis(this.element)

            this._handles = this._handles.add(
              this.element.find('.ui-resizable-handle')
            )
            this._handles.disableSelection()

            this._handles.on('mouseover', function () {
              if (!that.resizing) {
                if (this.className) {
                  axis = this.className.match(
                    /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i
                  )
                }
                that.axis = axis && axis[1] ? axis[1] : 'se'
              }
            })

            if (o.autoHide) {
              this._handles.hide()
              this._addClass('ui-resizable-autohide')
            }
          },

          _removeHandles: function () {
            this._addedHandles.remove()
          },

          _mouseCapture: function (event) {
            var i,
              handle,
              capture = false

            for (i in this.handles) {
              handle = $(this.handles[i])[0]
              if (handle === event.target || $.contains(handle, event.target)) {
                capture = true
              }
            }

            return !this.options.disabled && capture
          },

          _mouseStart: function (event) {
            var curleft,
              curtop,
              cursor,
              o = this.options,
              el = this.element

            this.resizing = true

            this._renderProxy()

            curleft = this._num(this.helper.css('left'))
            curtop = this._num(this.helper.css('top'))

            if (o.containment) {
              curleft += $(o.containment).scrollLeft() || 0
              curtop += $(o.containment).scrollTop() || 0
            }

            this.offset = this.helper.offset()
            this.position = { left: curleft, top: curtop }

            this.size = this._helper
              ? {
                  width: this.helper.width(),
                  height: this.helper.height()
                }
              : {
                  width: el.width(),
                  height: el.height()
                }

            this.originalSize = this._helper
              ? {
                  width: el.outerWidth(),
                  height: el.outerHeight()
                }
              : {
                  width: el.width(),
                  height: el.height()
                }

            this.sizeDiff = {
              width: el.outerWidth() - el.width(),
              height: el.outerHeight() - el.height()
            }

            this.originalPosition = { left: curleft, top: curtop }
            this.originalMousePosition = { left: event.pageX, top: event.pageY }

            this.aspectRatio =
              typeof o.aspectRatio === 'number'
                ? o.aspectRatio
                : this.originalSize.width / this.originalSize.height || 1

            cursor = $('.ui-resizable-' + this.axis).css('cursor')
            $('body').css(
              'cursor',
              cursor === 'auto' ? this.axis + '-resize' : cursor
            )

            this._addClass('ui-resizable-resizing')
            this._propagate('start', event)
            return true
          },

          _mouseDrag: function (event) {
            var data,
              props,
              smp = this.originalMousePosition,
              a = this.axis,
              dx = event.pageX - smp.left || 0,
              dy = event.pageY - smp.top || 0,
              trigger = this._change[a]

            this._updatePrevProperties()

            if (!trigger) {
              return false
            }

            data = trigger.apply(this, [event, dx, dy])

            this._updateVirtualBoundaries(event.shiftKey)
            if (this._aspectRatio || event.shiftKey) {
              data = this._updateRatio(data, event)
            }

            data = this._respectSize(data, event)

            this._updateCache(data)

            this._propagate('resize', event)

            props = this._applyChanges()

            if (!this._helper && this._proportionallyResizeElements.length) {
              this._proportionallyResize()
            }

            if (!$.isEmptyObject(props)) {
              this._updatePrevProperties()
              this._trigger('resize', event, this.ui())
              this._applyChanges()
            }

            return false
          },

          _mouseStop: function (event) {
            this.resizing = false
            var pr,
              ista,
              soffseth,
              soffsetw,
              s,
              left,
              top,
              o = this.options,
              that = this

            if (this._helper) {
              pr = this._proportionallyResizeElements
              ista = pr.length && /textarea/i.test(pr[0].nodeName)
              soffseth =
                ista && this._hasScroll(pr[0], 'left')
                  ? 0
                  : that.sizeDiff.height
              soffsetw = ista ? 0 : that.sizeDiff.width

              s = {
                width: that.helper.width() - soffsetw,
                height: that.helper.height() - soffseth
              }
              left =
                parseFloat(that.element.css('left')) +
                  (that.position.left - that.originalPosition.left) || null
              top =
                parseFloat(that.element.css('top')) +
                  (that.position.top - that.originalPosition.top) || null

              if (!o.animate) {
                this.element.css($.extend(s, { top: top, left: left }))
              }

              that.helper.height(that.size.height)
              that.helper.width(that.size.width)

              if (this._helper && !o.animate) {
                this._proportionallyResize()
              }
            }

            $('body').css('cursor', 'auto')

            this._removeClass('ui-resizable-resizing')

            this._propagate('stop', event)

            if (this._helper) {
              this.helper.remove()
            }

            return false
          },

          _updatePrevProperties: function () {
            this.prevPosition = {
              top: this.position.top,
              left: this.position.left
            }
            this.prevSize = {
              width: this.size.width,
              height: this.size.height
            }
          },

          _applyChanges: function () {
            var props = {}

            if (this.position.top !== this.prevPosition.top) {
              props.top = this.position.top + 'px'
            }
            if (this.position.left !== this.prevPosition.left) {
              props.left = this.position.left + 'px'
            }
            if (this.size.width !== this.prevSize.width) {
              props.width = this.size.width + 'px'
            }
            if (this.size.height !== this.prevSize.height) {
              props.height = this.size.height + 'px'
            }

            this.helper.css(props)

            return props
          },

          _updateVirtualBoundaries: function (forceAspectRatio) {
            var pMinWidth,
              pMaxWidth,
              pMinHeight,
              pMaxHeight,
              b,
              o = this.options

            b = {
              minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
              maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
              minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
              maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            }

            if (this._aspectRatio || forceAspectRatio) {
              pMinWidth = b.minHeight * this.aspectRatio
              pMinHeight = b.minWidth / this.aspectRatio
              pMaxWidth = b.maxHeight * this.aspectRatio
              pMaxHeight = b.maxWidth / this.aspectRatio

              if (pMinWidth > b.minWidth) {
                b.minWidth = pMinWidth
              }
              if (pMinHeight > b.minHeight) {
                b.minHeight = pMinHeight
              }
              if (pMaxWidth < b.maxWidth) {
                b.maxWidth = pMaxWidth
              }
              if (pMaxHeight < b.maxHeight) {
                b.maxHeight = pMaxHeight
              }
            }
            this._vBoundaries = b
          },

          _updateCache: function (data) {
            this.offset = this.helper.offset()
            if (this._isNumber(data.left)) {
              this.position.left = data.left
            }
            if (this._isNumber(data.top)) {
              this.position.top = data.top
            }
            if (this._isNumber(data.height)) {
              this.size.height = data.height
            }
            if (this._isNumber(data.width)) {
              this.size.width = data.width
            }
          },

          _updateRatio: function (data) {
            var cpos = this.position,
              csize = this.size,
              a = this.axis

            if (this._isNumber(data.height)) {
              data.width = data.height * this.aspectRatio
            } else if (this._isNumber(data.width)) {
              data.height = data.width / this.aspectRatio
            }

            if (a === 'sw') {
              data.left = cpos.left + (csize.width - data.width)
              data.top = null
            }
            if (a === 'nw') {
              data.top = cpos.top + (csize.height - data.height)
              data.left = cpos.left + (csize.width - data.width)
            }

            return data
          },

          _respectSize: function (data) {
            var o = this._vBoundaries,
              a = this.axis,
              ismaxw =
                this._isNumber(data.width) &&
                o.maxWidth &&
                o.maxWidth < data.width,
              ismaxh =
                this._isNumber(data.height) &&
                o.maxHeight &&
                o.maxHeight < data.height,
              isminw =
                this._isNumber(data.width) &&
                o.minWidth &&
                o.minWidth > data.width,
              isminh =
                this._isNumber(data.height) &&
                o.minHeight &&
                o.minHeight > data.height,
              dw = this.originalPosition.left + this.originalSize.width,
              dh = this.originalPosition.top + this.originalSize.height,
              cw = /sw|nw|w/.test(a),
              ch = /nw|ne|n/.test(a)
            if (isminw) {
              data.width = o.minWidth
            }
            if (isminh) {
              data.height = o.minHeight
            }
            if (ismaxw) {
              data.width = o.maxWidth
            }
            if (ismaxh) {
              data.height = o.maxHeight
            }

            if (isminw && cw) {
              data.left = dw - o.minWidth
            }
            if (ismaxw && cw) {
              data.left = dw - o.maxWidth
            }
            if (isminh && ch) {
              data.top = dh - o.minHeight
            }
            if (ismaxh && ch) {
              data.top = dh - o.maxHeight
            }

            // Fixing jump error on top/left - bug #2330
            if (!data.width && !data.height && !data.left && data.top) {
              data.top = null
            } else if (!data.width && !data.height && !data.top && data.left) {
              data.left = null
            }

            return data
          },

          _getPaddingPlusBorderDimensions: function (element) {
            var i = 0,
              widths = [],
              borders = [
                element.css('borderTopWidth'),
                element.css('borderRightWidth'),
                element.css('borderBottomWidth'),
                element.css('borderLeftWidth')
              ],
              paddings = [
                element.css('paddingTop'),
                element.css('paddingRight'),
                element.css('paddingBottom'),
                element.css('paddingLeft')
              ]

            for (; i < 4; i++) {
              widths[i] = parseFloat(borders[i]) || 0
              widths[i] += parseFloat(paddings[i]) || 0
            }

            return {
              height: widths[0] + widths[2],
              width: widths[1] + widths[3]
            }
          },

          _proportionallyResize: function () {
            if (!this._proportionallyResizeElements.length) {
              return
            }

            var prel,
              i = 0,
              element = this.helper || this.element

            for (; i < this._proportionallyResizeElements.length; i++) {
              prel = this._proportionallyResizeElements[i]

              // TODO: Seems like a bug to cache this.outerDimensions
              // considering that we are in a loop.
              if (!this.outerDimensions) {
                this.outerDimensions =
                  this._getPaddingPlusBorderDimensions(prel)
              }

              prel.css({
                height: element.height() - this.outerDimensions.height || 0,
                width: element.width() - this.outerDimensions.width || 0
              })
            }
          },

          _renderProxy: function () {
            var el = this.element,
              o = this.options
            this.elementOffset = el.offset()

            if (this._helper) {
              this.helper =
                this.helper || $('<div></div>').css({ overflow: 'hidden' })

              this._addClass(this.helper, this._helper)
              this.helper.css({
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
                position: 'absolute',
                left: this.elementOffset.left + 'px',
                top: this.elementOffset.top + 'px',
                zIndex: ++o.zIndex //TODO: Don't modify option
              })

              this.helper.appendTo('body').disableSelection()
            } else {
              this.helper = this.element
            }
          },

          _change: {
            e: function (event, dx) {
              return { width: this.originalSize.width + dx }
            },
            w: function (event, dx) {
              var cs = this.originalSize,
                sp = this.originalPosition
              return { left: sp.left + dx, width: cs.width - dx }
            },
            n: function (event, dx, dy) {
              var cs = this.originalSize,
                sp = this.originalPosition
              return { top: sp.top + dy, height: cs.height - dy }
            },
            s: function (event, dx, dy) {
              return { height: this.originalSize.height + dy }
            },
            se: function (event, dx, dy) {
              return $.extend(
                this._change.s.apply(this, arguments),
                this._change.e.apply(this, [event, dx, dy])
              )
            },
            sw: function (event, dx, dy) {
              return $.extend(
                this._change.s.apply(this, arguments),
                this._change.w.apply(this, [event, dx, dy])
              )
            },
            ne: function (event, dx, dy) {
              return $.extend(
                this._change.n.apply(this, arguments),
                this._change.e.apply(this, [event, dx, dy])
              )
            },
            nw: function (event, dx, dy) {
              return $.extend(
                this._change.n.apply(this, arguments),
                this._change.w.apply(this, [event, dx, dy])
              )
            }
          },

          _propagate: function (n, event) {
            $.ui.plugin.call(this, n, [event, this.ui()])
            if (n !== 'resize') {
              this._trigger(n, event, this.ui())
            }
          },

          plugins: {},

          ui: function () {
            return {
              originalElement: this.originalElement,
              element: this.element,
              helper: this.helper,
              position: this.position,
              size: this.size,
              originalSize: this.originalSize,
              originalPosition: this.originalPosition
            }
          }
        })

        /*
         * Resizable Extensions
         */

        $.ui.plugin.add('resizable', 'animate', {
          stop: function (event) {
            var that = $(this).resizable('instance'),
              o = that.options,
              pr = that._proportionallyResizeElements,
              ista = pr.length && /textarea/i.test(pr[0].nodeName),
              soffseth =
                ista && that._hasScroll(pr[0], 'left')
                  ? 0
                  : that.sizeDiff.height,
              soffsetw = ista ? 0 : that.sizeDiff.width,
              style = {
                width: that.size.width - soffsetw,
                height: that.size.height - soffseth
              },
              left =
                parseFloat(that.element.css('left')) +
                  (that.position.left - that.originalPosition.left) || null,
              top =
                parseFloat(that.element.css('top')) +
                  (that.position.top - that.originalPosition.top) || null

            that.element.animate(
              $.extend(style, top && left ? { top: top, left: left } : {}),
              {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function () {
                  var data = {
                    width: parseFloat(that.element.css('width')),
                    height: parseFloat(that.element.css('height')),
                    top: parseFloat(that.element.css('top')),
                    left: parseFloat(that.element.css('left'))
                  }

                  if (pr && pr.length) {
                    $(pr[0]).css({ width: data.width, height: data.height })
                  }

                  // Propagating resize, and updating values for each animation step
                  that._updateCache(data)
                  that._propagate('resize', event)
                }
              }
            )
          }
        })

        $.ui.plugin.add('resizable', 'containment', {
          start: function () {
            var element,
              p,
              co,
              ch,
              cw,
              width,
              height,
              that = $(this).resizable('instance'),
              o = that.options,
              el = that.element,
              oc = o.containment,
              ce =
                oc instanceof $
                  ? oc.get(0)
                  : /parent/.test(oc)
                    ? el.parent().get(0)
                    : oc

            if (!ce) {
              return
            }

            that.containerElement = $(ce)

            if (/document/.test(oc) || oc === document) {
              that.containerOffset = {
                left: 0,
                top: 0
              }
              that.containerPosition = {
                left: 0,
                top: 0
              }

              that.parentData = {
                element: $(document),
                left: 0,
                top: 0,
                width: $(document).width(),
                height:
                  $(document).height() || document.body.parentNode.scrollHeight
              }
            } else {
              element = $(ce)
              p = []
              $(['Top', 'Right', 'Left', 'Bottom']).each(function (i, name) {
                p[i] = that._num(element.css('padding' + name))
              })

              that.containerOffset = element.offset()
              that.containerPosition = element.position()
              that.containerSize = {
                height: element.innerHeight() - p[3],
                width: element.innerWidth() - p[1]
              }

              co = that.containerOffset
              ch = that.containerSize.height
              cw = that.containerSize.width
              width = that._hasScroll(ce, 'left') ? ce.scrollWidth : cw
              height = that._hasScroll(ce) ? ce.scrollHeight : ch

              that.parentData = {
                element: ce,
                left: co.left,
                top: co.top,
                width: width,
                height: height
              }
            }
          },

          resize: function (event) {
            var woset,
              hoset,
              isParent,
              isOffsetRelative,
              that = $(this).resizable('instance'),
              o = that.options,
              co = that.containerOffset,
              cp = that.position,
              pRatio = that._aspectRatio || event.shiftKey,
              cop = {
                top: 0,
                left: 0
              },
              ce = that.containerElement,
              continueResize = true

            if (ce[0] !== document && /static/.test(ce.css('position'))) {
              cop = co
            }

            if (cp.left < (that._helper ? co.left : 0)) {
              that.size.width =
                that.size.width +
                (that._helper
                  ? that.position.left - co.left
                  : that.position.left - cop.left)

              if (pRatio) {
                that.size.height = that.size.width / that.aspectRatio
                continueResize = false
              }
              that.position.left = o.helper ? co.left : 0
            }

            if (cp.top < (that._helper ? co.top : 0)) {
              that.size.height =
                that.size.height +
                (that._helper ? that.position.top - co.top : that.position.top)

              if (pRatio) {
                that.size.width = that.size.height * that.aspectRatio
                continueResize = false
              }
              that.position.top = that._helper ? co.top : 0
            }

            isParent =
              that.containerElement.get(0) === that.element.parent().get(0)
            isOffsetRelative = /relative|absolute/.test(
              that.containerElement.css('position')
            )

            if (isParent && isOffsetRelative) {
              that.offset.left = that.parentData.left + that.position.left
              that.offset.top = that.parentData.top + that.position.top
            } else {
              that.offset.left = that.element.offset().left
              that.offset.top = that.element.offset().top
            }

            woset = Math.abs(
              that.sizeDiff.width +
                (that._helper
                  ? that.offset.left - cop.left
                  : that.offset.left - co.left)
            )

            hoset = Math.abs(
              that.sizeDiff.height +
                (that._helper
                  ? that.offset.top - cop.top
                  : that.offset.top - co.top)
            )

            if (woset + that.size.width >= that.parentData.width) {
              that.size.width = that.parentData.width - woset
              if (pRatio) {
                that.size.height = that.size.width / that.aspectRatio
                continueResize = false
              }
            }

            if (hoset + that.size.height >= that.parentData.height) {
              that.size.height = that.parentData.height - hoset
              if (pRatio) {
                that.size.width = that.size.height * that.aspectRatio
                continueResize = false
              }
            }

            if (!continueResize) {
              that.position.left = that.prevPosition.left
              that.position.top = that.prevPosition.top
              that.size.width = that.prevSize.width
              that.size.height = that.prevSize.height
            }
          },

          stop: function () {
            var that = $(this).resizable('instance'),
              o = that.options,
              co = that.containerOffset,
              cop = that.containerPosition,
              ce = that.containerElement,
              helper = $(that.helper),
              ho = helper.offset(),
              w = helper.outerWidth() - that.sizeDiff.width,
              h = helper.outerHeight() - that.sizeDiff.height

            if (
              that._helper &&
              !o.animate &&
              /relative/.test(ce.css('position'))
            ) {
              $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
              })
            }

            if (
              that._helper &&
              !o.animate &&
              /static/.test(ce.css('position'))
            ) {
              $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
              })
            }
          }
        })

        $.ui.plugin.add('resizable', 'alsoResize', {
          start: function () {
            var that = $(this).resizable('instance'),
              o = that.options

            $(o.alsoResize).each(function () {
              var el = $(this)
              el.data('ui-resizable-alsoresize', {
                width: parseFloat(el.width()),
                height: parseFloat(el.height()),
                left: parseFloat(el.css('left')),
                top: parseFloat(el.css('top'))
              })
            })
          },

          resize: function (event, ui) {
            var that = $(this).resizable('instance'),
              o = that.options,
              os = that.originalSize,
              op = that.originalPosition,
              delta = {
                height: that.size.height - os.height || 0,
                width: that.size.width - os.width || 0,
                top: that.position.top - op.top || 0,
                left: that.position.left - op.left || 0
              }

            $(o.alsoResize).each(function () {
              var el = $(this),
                start = $(this).data('ui-resizable-alsoresize'),
                style = {},
                css = el.parents(ui.originalElement[0]).length
                  ? ['width', 'height']
                  : ['width', 'height', 'top', 'left']

              $.each(css, function (i, prop) {
                var sum = (start[prop] || 0) + (delta[prop] || 0)
                if (sum && sum >= 0) {
                  style[prop] = sum || null
                }
              })

              el.css(style)
            })
          },

          stop: function () {
            $(this).removeData('ui-resizable-alsoresize')
          }
        })

        $.ui.plugin.add('resizable', 'ghost', {
          start: function () {
            var that = $(this).resizable('instance'),
              cs = that.size

            that.ghost = that.originalElement.clone()
            that.ghost.css({
              opacity: 0.25,
              display: 'block',
              position: 'relative',
              height: cs.height,
              width: cs.width,
              margin: 0,
              left: 0,
              top: 0
            })

            that._addClass(that.ghost, 'ui-resizable-ghost')

            // DEPRECATED
            // TODO: remove after 1.12
            if (
              $.uiBackCompat !== false &&
              typeof that.options.ghost === 'string'
            ) {
              // Ghost option
              that.ghost.addClass(this.options.ghost)
            }

            that.ghost.appendTo(that.helper)
          },

          resize: function () {
            var that = $(this).resizable('instance')
            if (that.ghost) {
              that.ghost.css({
                position: 'relative',
                height: that.size.height,
                width: that.size.width
              })
            }
          },

          stop: function () {
            var that = $(this).resizable('instance')
            if (that.ghost && that.helper) {
              that.helper.get(0).removeChild(that.ghost.get(0))
            }
          }
        })

        $.ui.plugin.add('resizable', 'grid', {
          resize: function () {
            var outerDimensions,
              that = $(this).resizable('instance'),
              o = that.options,
              cs = that.size,
              os = that.originalSize,
              op = that.originalPosition,
              a = that.axis,
              grid = typeof o.grid === 'number' ? [o.grid, o.grid] : o.grid,
              gridX = grid[0] || 1,
              gridY = grid[1] || 1,
              ox = Math.round((cs.width - os.width) / gridX) * gridX,
              oy = Math.round((cs.height - os.height) / gridY) * gridY,
              newWidth = os.width + ox,
              newHeight = os.height + oy,
              isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
              isMaxHeight = o.maxHeight && o.maxHeight < newHeight,
              isMinWidth = o.minWidth && o.minWidth > newWidth,
              isMinHeight = o.minHeight && o.minHeight > newHeight

            o.grid = grid

            if (isMinWidth) {
              newWidth += gridX
            }
            if (isMinHeight) {
              newHeight += gridY
            }
            if (isMaxWidth) {
              newWidth -= gridX
            }
            if (isMaxHeight) {
              newHeight -= gridY
            }

            if (/^(se|s|e)$/.test(a)) {
              that.size.width = newWidth
              that.size.height = newHeight
            } else if (/^(ne)$/.test(a)) {
              that.size.width = newWidth
              that.size.height = newHeight
              that.position.top = op.top - oy
            } else if (/^(sw)$/.test(a)) {
              that.size.width = newWidth
              that.size.height = newHeight
              that.position.left = op.left - ox
            } else {
              if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                outerDimensions = that._getPaddingPlusBorderDimensions(this)
              }

              if (newHeight - gridY > 0) {
                that.size.height = newHeight
                that.position.top = op.top - oy
              } else {
                newHeight = gridY - outerDimensions.height
                that.size.height = newHeight
                that.position.top = op.top + os.height - newHeight
              }
              if (newWidth - gridX > 0) {
                that.size.width = newWidth
                that.position.left = op.left - ox
              } else {
                newWidth = gridX - outerDimensions.width
                that.size.width = newWidth
                that.position.left = op.left + os.width - newWidth
              }
            }
          }
        })

        return $.ui.resizable
      })

      /***/
    },

    /***/ 9755: /***/ function (module, exports) {
      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__ /*!
       * jQuery JavaScript Library v3.7.1
       * https://jquery.com/
       *
       * Copyright OpenJS Foundation and other contributors
       * Released under the MIT license
       * https://jquery.org/license
       *
       * Date: 2023-08-28T13:37Z
       */
      ;(function (global, factory) {
        'use strict'

        if (true && typeof module.exports === 'object') {
          // For CommonJS and CommonJS-like environments where a proper `window`
          // is present, execute the factory and get jQuery.
          // For environments that do not have a `window` with a `document`
          // (such as Node.js), expose a factory as module.exports.
          // This accentuates the need for the creation of a real `window`.
          // e.g. var jQuery = require("jquery")(window);
          // See ticket trac-14549 for more info.
          module.exports = global.document
            ? factory(global, true)
            : function (w) {
                if (!w.document) {
                  throw new Error('jQuery requires a window with a document')
                }
                return factory(w)
              }
        } else {
          factory(global)
        }

        // Pass this if window is not defined yet
      })(
        typeof window !== 'undefined' ? window : this,
        function (window, noGlobal) {
          // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
          // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
          // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
          // enough that all such attempts are guarded in a try block.
          'use strict'

          var arr = []

          var getProto = Object.getPrototypeOf

          var slice = arr.slice

          var flat = arr.flat
            ? function (array) {
                return arr.flat.call(array)
              }
            : function (array) {
                return arr.concat.apply([], array)
              }

          var push = arr.push

          var indexOf = arr.indexOf

          var class2type = {}

          var toString = class2type.toString

          var hasOwn = class2type.hasOwnProperty

          var fnToString = hasOwn.toString

          var ObjectFunctionString = fnToString.call(Object)

          var support = {}

          var isFunction = function isFunction(obj) {
            // Support: Chrome <=57, Firefox <=52
            // In some browsers, typeof returns "function" for HTML <object> elements
            // (i.e., `typeof document.createElement( "object" ) === "function"`).
            // We don't want to classify *any* DOM node as a function.
            // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
            // Plus for old WebKit, typeof returns "function" for HTML collections
            // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
            return (
              typeof obj === 'function' &&
              typeof obj.nodeType !== 'number' &&
              typeof obj.item !== 'function'
            )
          }

          var isWindow = function isWindow(obj) {
            return obj != null && obj === obj.window
          }

          var document = window.document

          var preservedScriptAttributes = {
            type: true,
            src: true,
            nonce: true,
            noModule: true
          }

          function DOMEval(code, node, doc) {
            doc = doc || document

            var i,
              val,
              script = doc.createElement('script')

            script.text = code
            if (node) {
              for (i in preservedScriptAttributes) {
                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[i] || (node.getAttribute && node.getAttribute(i))
                if (val) {
                  script.setAttribute(i, val)
                }
              }
            }
            doc.head.appendChild(script).parentNode.removeChild(script)
          }

          function toType(obj) {
            if (obj == null) {
              return obj + ''
            }

            // Support: Android <=2.3 only (functionish RegExp)
            return typeof obj === 'object' || typeof obj === 'function'
              ? class2type[toString.call(obj)] || 'object'
              : typeof obj
          }
          /* global Symbol */
          // Defining this global in .eslintrc.json would create a danger of using the global
          // unguarded in another place, it seems safer to define global only for this module

          var version = '3.7.1',
            rhtmlSuffix = /HTML$/i,
            // Define a local copy of jQuery
            jQuery = function (selector, context) {
              // The jQuery object is actually just the init constructor 'enhanced'
              // Need init if jQuery is called (just allow error to be thrown if not included)
              return new jQuery.fn.init(selector, context)
            }

          jQuery.fn = jQuery.prototype = {
            // The current version of jQuery being used
            jquery: version,

            constructor: jQuery,

            // The default length of a jQuery object is 0
            length: 0,

            toArray: function () {
              return slice.call(this)
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
              // Return all the elements in a clean array
              if (num == null) {
                return slice.call(this)
              }

              // Return just the one element from the set
              return num < 0 ? this[num + this.length] : this[num]
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems) {
              // Build a new jQuery matched element set
              var ret = jQuery.merge(this.constructor(), elems)

              // Add the old object onto the stack (as a reference)
              ret.prevObject = this

              // Return the newly-formed element set
              return ret
            },

            // Execute a callback for every element in the matched set.
            each: function (callback) {
              return jQuery.each(this, callback)
            },

            map: function (callback) {
              return this.pushStack(
                jQuery.map(this, function (elem, i) {
                  return callback.call(elem, i, elem)
                })
              )
            },

            slice: function () {
              return this.pushStack(slice.apply(this, arguments))
            },

            first: function () {
              return this.eq(0)
            },

            last: function () {
              return this.eq(-1)
            },

            even: function () {
              return this.pushStack(
                jQuery.grep(this, function (_elem, i) {
                  return (i + 1) % 2
                })
              )
            },

            odd: function () {
              return this.pushStack(
                jQuery.grep(this, function (_elem, i) {
                  return i % 2
                })
              )
            },

            eq: function (i) {
              var len = this.length,
                j = +i + (i < 0 ? len : 0)
              return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
            },

            end: function () {
              return this.prevObject || this.constructor()
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: arr.sort,
            splice: arr.splice
          }

          jQuery.extend = jQuery.fn.extend = function () {
            var options,
              name,
              src,
              copy,
              copyIsArray,
              clone,
              target = arguments[0] || {},
              i = 1,
              length = arguments.length,
              deep = false

            // Handle a deep copy situation
            if (typeof target === 'boolean') {
              deep = target

              // Skip the boolean and the target
              target = arguments[i] || {}
              i++
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== 'object' && !isFunction(target)) {
              target = {}
            }

            // Extend jQuery itself if only one argument is passed
            if (i === length) {
              target = this
              i--
            }

            for (; i < length; i++) {
              // Only deal with non-null/undefined values
              if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                  copy = options[name]

                  // Prevent Object.prototype pollution
                  // Prevent never-ending loop
                  if (name === '__proto__' || target === copy) {
                    continue
                  }

                  // Recurse if we're merging plain objects or arrays
                  if (
                    deep &&
                    copy &&
                    (jQuery.isPlainObject(copy) ||
                      (copyIsArray = Array.isArray(copy)))
                  ) {
                    src = target[name]

                    // Ensure proper type for the source value
                    if (copyIsArray && !Array.isArray(src)) {
                      clone = []
                    } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                      clone = {}
                    } else {
                      clone = src
                    }
                    copyIsArray = false

                    // Never move original objects, clone them
                    target[name] = jQuery.extend(deep, clone, copy)

                    // Don't bring in undefined values
                  } else if (copy !== undefined) {
                    target[name] = copy
                  }
                }
              }
            }

            // Return the modified object
            return target
          }

          jQuery.extend({
            // Unique for each copy of jQuery on the page
            expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),

            // Assume jQuery is ready without the ready module
            isReady: true,

            error: function (msg) {
              throw new Error(msg)
            },

            noop: function () {},

            isPlainObject: function (obj) {
              var proto, Ctor

              // Detect obvious negatives
              // Use toString instead of jQuery.type to catch host objects
              if (!obj || toString.call(obj) !== '[object Object]') {
                return false
              }

              proto = getProto(obj)

              // Objects with no prototype (e.g., `Object.create( null )`) are plain
              if (!proto) {
                return true
              }

              // Objects with prototype are plain iff they were constructed by a global Object function
              Ctor = hasOwn.call(proto, 'constructor') && proto.constructor
              return (
                typeof Ctor === 'function' &&
                fnToString.call(Ctor) === ObjectFunctionString
              )
            },

            isEmptyObject: function (obj) {
              var name

              for (name in obj) {
                return false
              }
              return true
            },

            // Evaluates a script in a provided context; falls back to the global one
            // if not specified.
            globalEval: function (code, options, doc) {
              DOMEval(code, { nonce: options && options.nonce }, doc)
            },

            each: function (obj, callback) {
              var length,
                i = 0

              if (isArrayLike(obj)) {
                length = obj.length
                for (; i < length; i++) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break
                  }
                }
              } else {
                for (i in obj) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break
                  }
                }
              }

              return obj
            },

            // Retrieve the text value of an array of DOM nodes
            text: function (elem) {
              var node,
                ret = '',
                i = 0,
                nodeType = elem.nodeType

              if (!nodeType) {
                // If no nodeType, this is expected to be an array
                while ((node = elem[i++])) {
                  // Do not traverse comment nodes
                  ret += jQuery.text(node)
                }
              }
              if (nodeType === 1 || nodeType === 11) {
                return elem.textContent
              }
              if (nodeType === 9) {
                return elem.documentElement.textContent
              }
              if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue
              }

              // Do not include comment or processing instruction nodes

              return ret
            },

            // results is for internal usage only
            makeArray: function (arr, results) {
              var ret = results || []

              if (arr != null) {
                if (isArrayLike(Object(arr))) {
                  jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr)
                } else {
                  push.call(ret, arr)
                }
              }

              return ret
            },

            inArray: function (elem, arr, i) {
              return arr == null ? -1 : indexOf.call(arr, elem, i)
            },

            isXMLDoc: function (elem) {
              var namespace = elem && elem.namespaceURI,
                docElem = elem && (elem.ownerDocument || elem).documentElement

              // Assume HTML when documentElement doesn't yet exist, such as inside
              // document fragments.
              return !rhtmlSuffix.test(
                namespace || (docElem && docElem.nodeName) || 'HTML'
              )
            },

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            merge: function (first, second) {
              var len = +second.length,
                j = 0,
                i = first.length

              for (; j < len; j++) {
                first[i++] = second[j]
              }

              first.length = i

              return first
            },

            grep: function (elems, callback, invert) {
              var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert

              // Go through the array, only saving the items
              // that pass the validator function
              for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i)
                if (callbackInverse !== callbackExpect) {
                  matches.push(elems[i])
                }
              }

              return matches
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
              var length,
                value,
                i = 0,
                ret = []

              // Go through the array, translating each of the items to their new values
              if (isArrayLike(elems)) {
                length = elems.length
                for (; i < length; i++) {
                  value = callback(elems[i], i, arg)

                  if (value != null) {
                    ret.push(value)
                  }
                }

                // Go through every key on the object,
              } else {
                for (i in elems) {
                  value = callback(elems[i], i, arg)

                  if (value != null) {
                    ret.push(value)
                  }
                }
              }

              // Flatten any nested arrays
              return flat(ret)
            },

            // A global GUID counter for objects
            guid: 1,

            // jQuery.support is not used in Core but other projects attach their
            // properties to it so it needs to exist.
            support: support
          })

          if (typeof Symbol === 'function') {
            jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]
          }

          // Populate the class2type map
          jQuery.each(
            'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(
              ' '
            ),
            function (_i, name) {
              class2type['[object ' + name + ']'] = name.toLowerCase()
            }
          )

          function isArrayLike(obj) {
            // Support: real iOS 8.2 only (not reproducible in simulator)
            // `in` check used to prevent JIT error (gh-2145)
            // hasOwn isn't used here due to false negatives
            // regarding Nodelist length in IE
            var length = !!obj && 'length' in obj && obj.length,
              type = toType(obj)

            if (isFunction(obj) || isWindow(obj)) {
              return false
            }

            return (
              type === 'array' ||
              length === 0 ||
              (typeof length === 'number' && length > 0 && length - 1 in obj)
            )
          }

          function nodeName(elem, name) {
            return (
              elem.nodeName &&
              elem.nodeName.toLowerCase() === name.toLowerCase()
            )
          }
          var pop = arr.pop

          var sort = arr.sort

          var splice = arr.splice

          var whitespace = '[\\x20\\t\\r\\n\\f]'

          var rtrimCSS = new RegExp(
            '^' +
              whitespace +
              '+|((?:^|[^\\\\])(?:\\\\.)*)' +
              whitespace +
              '+$',
            'g'
          )

          // Note: an element does not contain itself
          jQuery.contains = function (a, b) {
            var bup = b && b.parentNode

            return (
              a === bup ||
              !!(
                bup &&
                bup.nodeType === 1 &&
                // Support: IE 9 - 11+
                // IE doesn't have `contains` on SVG.
                (a.contains
                  ? a.contains(bup)
                  : a.compareDocumentPosition &&
                    a.compareDocumentPosition(bup) & 16)
              )
            )
          }

          // CSS string/identifier serialization
          // https://drafts.csswg.org/cssom/#common-serializing-idioms
          var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g

          function fcssescape(ch, asCodePoint) {
            if (asCodePoint) {
              // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
              if (ch === '\0') {
                return '\uFFFD'
              }

              // Control characters and (dependent upon position) numbers get escaped as code points
              return (
                ch.slice(0, -1) +
                '\\' +
                ch.charCodeAt(ch.length - 1).toString(16) +
                ' '
              )
            }

            // Other potentially-special ASCII characters get backslash-escaped
            return '\\' + ch
          }

          jQuery.escapeSelector = function (sel) {
            return (sel + '').replace(rcssescape, fcssescape)
          }

          var preferredDoc = document,
            pushNative = push

          ;(function () {
            var i,
              Expr,
              outermostContext,
              sortInput,
              hasDuplicate,
              push = pushNative,
              // Local document vars
              document,
              documentElement,
              documentIsHTML,
              rbuggyQSA,
              matches,
              // Instance-specific data
              expando = jQuery.expando,
              dirruns = 0,
              done = 0,
              classCache = createCache(),
              tokenCache = createCache(),
              compilerCache = createCache(),
              nonnativeSelectorCache = createCache(),
              sortOrder = function (a, b) {
                if (a === b) {
                  hasDuplicate = true
                }
                return 0
              },
              booleans =
                'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|' +
                'loop|multiple|open|readonly|required|scoped',
              // Regular expressions

              // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
              identifier =
                '(?:\\\\[\\da-fA-F]{1,6}' +
                whitespace +
                '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+',
              // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
              attributes =
                '\\[' +
                whitespace +
                '*(' +
                identifier +
                ')(?:' +
                whitespace +
                // Operator (capture 2)
                '*([*^$|!~]?=)' +
                whitespace +
                // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' +
                identifier +
                '))|)' +
                whitespace +
                '*\\]',
              pseudos =
                ':(' +
                identifier +
                ')(?:\\((' +
                // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                // 1. quoted (capture 3; capture 4 or capture 5)
                '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' +
                // 2. simple (capture 6)
                '((?:\\\\.|[^\\\\()[\\]]|' +
                attributes +
                ')*)|' +
                // 3. anything else (capture 2)
                '.*' +
                ')\\)|)',
              // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
              rwhitespace = new RegExp(whitespace + '+', 'g'),
              rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),
              rleadingCombinator = new RegExp(
                '^' +
                  whitespace +
                  '*([>+~]|' +
                  whitespace +
                  ')' +
                  whitespace +
                  '*'
              ),
              rdescend = new RegExp(whitespace + '|>'),
              rpseudo = new RegExp(pseudos),
              ridentifier = new RegExp('^' + identifier + '$'),
              matchExpr = {
                ID: new RegExp('^#(' + identifier + ')'),
                CLASS: new RegExp('^\\.(' + identifier + ')'),
                TAG: new RegExp('^(' + identifier + '|[*])'),
                ATTR: new RegExp('^' + attributes),
                PSEUDO: new RegExp('^' + pseudos),
                CHILD: new RegExp(
                  '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' +
                    whitespace +
                    '*(even|odd|(([+-]|)(\\d*)n|)' +
                    whitespace +
                    '*(?:([+-]|)' +
                    whitespace +
                    '*(\\d+)|))' +
                    whitespace +
                    '*\\)|)',
                  'i'
                ),
                bool: new RegExp('^(?:' + booleans + ')$', 'i'),

                // For use in libraries implementing .is()
                // We use this for POS matching in `select`
                needsContext: new RegExp(
                  '^' +
                    whitespace +
                    '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' +
                    whitespace +
                    '*((?:-\\d)?\\d*)' +
                    whitespace +
                    '*\\)|)(?=[^-]|$)',
                  'i'
                )
              },
              rinputs = /^(?:input|select|textarea|button)$/i,
              rheader = /^h\d$/i,
              // Easily-parseable/retrievable ID or TAG or CLASS selectors
              rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
              rsibling = /[+~]/,
              // CSS escapes
              // https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
              runescape = new RegExp(
                '\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\([^\\r\\n\\f])',
                'g'
              ),
              funescape = function (escape, nonHex) {
                var high = '0x' + escape.slice(1) - 0x10000

                if (nonHex) {
                  // Strip the backslash prefix from a non-hex escape sequence
                  return nonHex
                }

                // Replace a hexadecimal escape sequence with the encoded Unicode code point
                // Support: IE <=11+
                // For values outside the Basic Multilingual Plane (BMP), manually construct a
                // surrogate pair
                return high < 0
                  ? String.fromCharCode(high + 0x10000)
                  : String.fromCharCode(
                      (high >> 10) | 0xd800,
                      (high & 0x3ff) | 0xdc00
                    )
              },
              // Used for iframes; see `setDocument`.
              // Support: IE 9 - 11+, Edge 12 - 18+
              // Removing the function wrapper causes a "Permission Denied"
              // error in IE/Edge.
              unloadHandler = function () {
                setDocument()
              },
              inDisabledFieldset = addCombinator(
                function (elem) {
                  return elem.disabled === true && nodeName(elem, 'fieldset')
                },
                { dir: 'parentNode', next: 'legend' }
              )

            // Support: IE <=9 only
            // Accessing document.activeElement can throw unexpectedly
            // https://bugs.jquery.com/ticket/13393
            function safeActiveElement() {
              try {
                return document.activeElement
              } catch (err) {}
            }

            // Optimize for push.apply( _, NodeList )
            try {
              push.apply(
                (arr = slice.call(preferredDoc.childNodes)),
                preferredDoc.childNodes
              )

              // Support: Android <=4.0
              // Detect silently failing push.apply
              // eslint-disable-next-line no-unused-expressions
              arr[preferredDoc.childNodes.length].nodeType
            } catch (e) {
              push = {
                apply: function (target, els) {
                  pushNative.apply(target, slice.call(els))
                },
                call: function (target) {
                  pushNative.apply(target, slice.call(arguments, 1))
                }
              }
            }

            function find(selector, context, results, seed) {
              var m,
                i,
                elem,
                nid,
                match,
                groups,
                newSelector,
                newContext = context && context.ownerDocument,
                // nodeType defaults to 9, since context defaults to document
                nodeType = context ? context.nodeType : 9

              results = results || []

              // Return early from calls with invalid selector or context
              if (
                typeof selector !== 'string' ||
                !selector ||
                (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
              ) {
                return results
              }

              // Try to shortcut find operations (as opposed to filters) in HTML documents
              if (!seed) {
                setDocument(context)
                context = context || document

                if (documentIsHTML) {
                  // If the selector is sufficiently simple, try using a "get*By*" DOM method
                  // (excepting DocumentFragment context, where the methods don't exist)
                  if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                    // ID selector
                    if ((m = match[1])) {
                      // Document context
                      if (nodeType === 9) {
                        if ((elem = context.getElementById(m))) {
                          // Support: IE 9 only
                          // getElementById can match elements by name instead of ID
                          if (elem.id === m) {
                            push.call(results, elem)
                            return results
                          }
                        } else {
                          return results
                        }

                        // Element context
                      } else {
                        // Support: IE 9 only
                        // getElementById can match elements by name instead of ID
                        if (
                          newContext &&
                          (elem = newContext.getElementById(m)) &&
                          find.contains(context, elem) &&
                          elem.id === m
                        ) {
                          push.call(results, elem)
                          return results
                        }
                      }

                      // Type selector
                    } else if (match[2]) {
                      push.apply(
                        results,
                        context.getElementsByTagName(selector)
                      )
                      return results

                      // Class selector
                    } else if (
                      (m = match[3]) &&
                      context.getElementsByClassName
                    ) {
                      push.apply(results, context.getElementsByClassName(m))
                      return results
                    }
                  }

                  // Take advantage of querySelectorAll
                  if (
                    !nonnativeSelectorCache[selector + ' '] &&
                    (!rbuggyQSA || !rbuggyQSA.test(selector))
                  ) {
                    newSelector = selector
                    newContext = context

                    // qSA considers elements outside a scoping root when evaluating child or
                    // descendant combinators, which is not what we want.
                    // In such cases, we work around the behavior by prefixing every selector in the
                    // list with an ID selector referencing the scope context.
                    // The technique has to be used as well when a leading combinator is used
                    // as such selectors are not recognized by querySelectorAll.
                    // Thanks to Andrew Dupont for this technique.
                    if (
                      nodeType === 1 &&
                      (rdescend.test(selector) ||
                        rleadingCombinator.test(selector))
                    ) {
                      // Expand context for sibling selectors
                      newContext =
                        (rsibling.test(selector) &&
                          testContext(context.parentNode)) ||
                        context

                      // We can use :scope instead of the ID hack if the browser
                      // supports it & if we're not changing the context.
                      // Support: IE 11+, Edge 17 - 18+
                      // IE/Edge sometimes throw a "Permission denied" error when
                      // strict-comparing two documents; shallow comparisons work.
                      // eslint-disable-next-line eqeqeq
                      if (newContext != context || !support.scope) {
                        // Capture the context ID, setting it first if necessary
                        if ((nid = context.getAttribute('id'))) {
                          nid = jQuery.escapeSelector(nid)
                        } else {
                          context.setAttribute('id', (nid = expando))
                        }
                      }

                      // Prefix every selector in the list
                      groups = tokenize(selector)
                      i = groups.length
                      while (i--) {
                        groups[i] =
                          (nid ? '#' + nid : ':scope') +
                          ' ' +
                          toSelector(groups[i])
                      }
                      newSelector = groups.join(',')
                    }

                    try {
                      push.apply(
                        results,
                        newContext.querySelectorAll(newSelector)
                      )
                      return results
                    } catch (qsaError) {
                      nonnativeSelectorCache(selector, true)
                    } finally {
                      if (nid === expando) {
                        context.removeAttribute('id')
                      }
                    }
                  }
                }
              }

              // All others
              return select(
                selector.replace(rtrimCSS, '$1'),
                context,
                results,
                seed
              )
            }

            /**
             * Create key-value caches of limited size
             * @returns {function(string, object)} Returns the Object data after storing it on itself with
             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *	deleting the oldest entry
             */
            function createCache() {
              var keys = []

              function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties
                // (see https://github.com/jquery/sizzle/issues/157)
                if (keys.push(key + ' ') > Expr.cacheLength) {
                  // Only keep the most recent entries
                  delete cache[keys.shift()]
                }
                return (cache[key + ' '] = value)
              }
              return cache
            }

            /**
             * Mark a function for special use by jQuery selector module
             * @param {Function} fn The function to mark
             */
            function markFunction(fn) {
              fn[expando] = true
              return fn
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created element and returns a boolean result
             */
            function assert(fn) {
              var el = document.createElement('fieldset')

              try {
                return !!fn(el)
              } catch (e) {
                return false
              } finally {
                // Remove from its parent by default
                if (el.parentNode) {
                  el.parentNode.removeChild(el)
                }

                // release memory in IE
                el = null
              }
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo(type) {
              return function (elem) {
                return nodeName(elem, 'input') && elem.type === type
              }
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo(type) {
              return function (elem) {
                return (
                  (nodeName(elem, 'input') || nodeName(elem, 'button')) &&
                  elem.type === type
                )
              }
            }

            /**
             * Returns a function to use in pseudos for :enabled/:disabled
             * @param {Boolean} disabled true for :disabled; false for :enabled
             */
            function createDisabledPseudo(disabled) {
              // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
              return function (elem) {
                // Only certain elements can match :enabled or :disabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                if ('form' in elem) {
                  // Check for inherited disabledness on relevant non-disabled elements:
                  // * listed form-associated elements in a disabled fieldset
                  //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                  //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                  // * option elements in a disabled optgroup
                  //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                  // All such elements have a "form" property.
                  if (elem.parentNode && elem.disabled === false) {
                    // Option elements defer to a parent optgroup if present
                    if ('label' in elem) {
                      if ('label' in elem.parentNode) {
                        return elem.parentNode.disabled === disabled
                      } else {
                        return elem.disabled === disabled
                      }
                    }

                    // Support: IE 6 - 11+
                    // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                    return (
                      elem.isDisabled === disabled ||
                      // Where there is no isDisabled, check manually
                      (elem.isDisabled !== !disabled &&
                        inDisabledFieldset(elem) === disabled)
                    )
                  }

                  return elem.disabled === disabled

                  // Try to winnow out elements that can't be disabled before trusting the disabled property.
                  // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                  // even exist on them, let alone have a boolean value.
                } else if ('label' in elem) {
                  return elem.disabled === disabled
                }

                // Remaining elements are neither :enabled nor :disabled
                return false
              }
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo(fn) {
              return markFunction(function (argument) {
                argument = +argument
                return markFunction(function (seed, matches) {
                  var j,
                    matchIndexes = fn([], seed.length, argument),
                    i = matchIndexes.length

                  // Match elements found at the specified indexes
                  while (i--) {
                    if (seed[(j = matchIndexes[i])]) {
                      seed[j] = !(matches[j] = seed[j])
                    }
                  }
                })
              })
            }

            /**
             * Checks a node for validity as a jQuery selector context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext(context) {
              return (
                context &&
                typeof context.getElementsByTagName !== 'undefined' &&
                context
              )
            }

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [node] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            function setDocument(node) {
              var subWindow,
                doc = node ? node.ownerDocument || node : preferredDoc

              // Return early if doc is invalid or already selected
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              if (
                doc == document ||
                doc.nodeType !== 9 ||
                !doc.documentElement
              ) {
                return document
              }

              // Update global variables
              document = doc
              documentElement = document.documentElement
              documentIsHTML = !jQuery.isXMLDoc(document)

              // Support: iOS 7 only, IE 9 - 11+
              // Older browsers didn't support unprefixed `matches`.
              matches =
                documentElement.matches ||
                documentElement.webkitMatchesSelector ||
                documentElement.msMatchesSelector

              // Support: IE 9 - 11+, Edge 12 - 18+
              // Accessing iframe documents after unload throws "permission denied" errors
              // (see trac-13936).
              // Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
              // all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
              if (
                documentElement.msMatchesSelector &&
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                preferredDoc != document &&
                (subWindow = document.defaultView) &&
                subWindow.top !== subWindow
              ) {
                // Support: IE 9 - 11+, Edge 12 - 18+
                subWindow.addEventListener('unload', unloadHandler)
              }

              // Support: IE <10
              // Check if getElementById returns elements by name
              // The broken getElementById methods don't pick up programmatically-set names,
              // so use a roundabout getElementsByName test
              support.getById = assert(function (el) {
                documentElement.appendChild(el).id = jQuery.expando
                return (
                  !document.getElementsByName ||
                  !document.getElementsByName(jQuery.expando).length
                )
              })

              // Support: IE 9 only
              // Check to see if it's possible to do matchesSelector
              // on a disconnected node.
              support.disconnectedMatch = assert(function (el) {
                return matches.call(el, '*')
              })

              // Support: IE 9 - 11+, Edge 12 - 18+
              // IE/Edge don't support the :scope pseudo-class.
              support.scope = assert(function () {
                return document.querySelectorAll(':scope')
              })

              // Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
              // Make sure the `:has()` argument is parsed unforgivingly.
              // We include `*` in the test to detect buggy implementations that are
              // _selectively_ forgiving (specifically when the list includes at least
              // one valid selector).
              // Note that we treat complete lack of support for `:has()` as if it were
              // spec-compliant support, which is fine because use of `:has()` in such
              // environments will fail in the qSA path and fall back to jQuery traversal
              // anyway.
              support.cssHas = assert(function () {
                try {
                  document.querySelector(':has(*,:jqfake)')
                  return false
                } catch (e) {
                  return true
                }
              })

              // ID filter and find
              if (support.getById) {
                Expr.filter.ID = function (id) {
                  var attrId = id.replace(runescape, funescape)
                  return function (elem) {
                    return elem.getAttribute('id') === attrId
                  }
                }
                Expr.find.ID = function (id, context) {
                  if (
                    typeof context.getElementById !== 'undefined' &&
                    documentIsHTML
                  ) {
                    var elem = context.getElementById(id)
                    return elem ? [elem] : []
                  }
                }
              } else {
                Expr.filter.ID = function (id) {
                  var attrId = id.replace(runescape, funescape)
                  return function (elem) {
                    var node =
                      typeof elem.getAttributeNode !== 'undefined' &&
                      elem.getAttributeNode('id')
                    return node && node.value === attrId
                  }
                }

                // Support: IE 6 - 7 only
                // getElementById is not reliable as a find shortcut
                Expr.find.ID = function (id, context) {
                  if (
                    typeof context.getElementById !== 'undefined' &&
                    documentIsHTML
                  ) {
                    var node,
                      i,
                      elems,
                      elem = context.getElementById(id)

                    if (elem) {
                      // Verify the id attribute
                      node = elem.getAttributeNode('id')
                      if (node && node.value === id) {
                        return [elem]
                      }

                      // Fall back on getElementsByName
                      elems = context.getElementsByName(id)
                      i = 0
                      while ((elem = elems[i++])) {
                        node = elem.getAttributeNode('id')
                        if (node && node.value === id) {
                          return [elem]
                        }
                      }
                    }

                    return []
                  }
                }
              }

              // Tag
              Expr.find.TAG = function (tag, context) {
                if (typeof context.getElementsByTagName !== 'undefined') {
                  return context.getElementsByTagName(tag)

                  // DocumentFragment nodes don't have gEBTN
                } else {
                  return context.querySelectorAll(tag)
                }
              }

              // Class
              Expr.find.CLASS = function (className, context) {
                if (
                  typeof context.getElementsByClassName !== 'undefined' &&
                  documentIsHTML
                ) {
                  return context.getElementsByClassName(className)
                }
              }

              /* QSA/matchesSelector
	---------------------------------------------------------------------- */

              // QSA and matchesSelector support

              rbuggyQSA = []

              // Build QSA regex
              // Regex strategy adopted from Diego Perini
              assert(function (el) {
                var input

                documentElement.appendChild(el).innerHTML =
                  "<a id='" +
                  expando +
                  "' href='' disabled='disabled'></a>" +
                  "<select id='" +
                  expando +
                  "-\r\\' disabled='disabled'>" +
                  "<option selected=''></option></select>"

                // Support: iOS <=7 - 8 only
                // Boolean attributes and "value" are not treated correctly in some XML documents
                if (!el.querySelectorAll('[selected]').length) {
                  rbuggyQSA.push(
                    '\\[' + whitespace + '*(?:value|' + booleans + ')'
                  )
                }

                // Support: iOS <=7 - 8 only
                if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
                  rbuggyQSA.push('~=')
                }

                // Support: iOS 8 only
                // https://bugs.webkit.org/show_bug.cgi?id=136851
                // In-page `selector#id sibling-combinator selector` fails
                if (!el.querySelectorAll('a#' + expando + '+*').length) {
                  rbuggyQSA.push('.#.+[+~]')
                }

                // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
                // In some of the document kinds, these selectors wouldn't work natively.
                // This is probably OK but for backwards compatibility we want to maintain
                // handling them through jQuery traversal in jQuery 3.x.
                if (!el.querySelectorAll(':checked').length) {
                  rbuggyQSA.push(':checked')
                }

                // Support: Windows 8 Native Apps
                // The type and name attributes are restricted during .innerHTML assignment
                input = document.createElement('input')
                input.setAttribute('type', 'hidden')
                el.appendChild(input).setAttribute('name', 'D')

                // Support: IE 9 - 11+
                // IE's :disabled selector does not pick up the children of disabled fieldsets
                // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
                // In some of the document kinds, these selectors wouldn't work natively.
                // This is probably OK but for backwards compatibility we want to maintain
                // handling them through jQuery traversal in jQuery 3.x.
                documentElement.appendChild(el).disabled = true
                if (el.querySelectorAll(':disabled').length !== 2) {
                  rbuggyQSA.push(':enabled', ':disabled')
                }

                // Support: IE 11+, Edge 15 - 18+
                // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                // Adding a temporary attribute to the document before the selection works
                // around the issue.
                // Interestingly, IE 10 & older don't seem to have the issue.
                input = document.createElement('input')
                input.setAttribute('name', '')
                el.appendChild(input)
                if (!el.querySelectorAll("[name='']").length) {
                  rbuggyQSA.push(
                    '\\[' +
                      whitespace +
                      '*name' +
                      whitespace +
                      '*=' +
                      whitespace +
                      '*(?:\'\'|"")'
                  )
                }
              })

              if (!support.cssHas) {
                // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
                // Our regular `try-catch` mechanism fails to detect natively-unsupported
                // pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
                // in browsers that parse the `:has()` argument as a forgiving selector list.
                // https://drafts.csswg.org/selectors/#relational now requires the argument
                // to be parsed unforgivingly, but browsers have not yet fully adjusted.
                rbuggyQSA.push(':has')
              }

              rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'))

              /* Sorting
	---------------------------------------------------------------------- */

              // Document order sorting
              sortOrder = function (a, b) {
                // Flag for duplicate removal
                if (a === b) {
                  hasDuplicate = true
                  return 0
                }

                // Sort on method existence if only one input has compareDocumentPosition
                var compare =
                  !a.compareDocumentPosition - !b.compareDocumentPosition
                if (compare) {
                  return compare
                }

                // Calculate position if both inputs belong to the same document
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                compare =
                  (a.ownerDocument || a) == (b.ownerDocument || b)
                    ? a.compareDocumentPosition(b)
                    : // Otherwise we know they are disconnected
                      1

                // Disconnected nodes
                if (
                  compare & 1 ||
                  (!support.sortDetached &&
                    b.compareDocumentPosition(a) === compare)
                ) {
                  // Choose the first element that is related to our preferred document
                  // Support: IE 11+, Edge 17 - 18+
                  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                  // two documents; shallow comparisons work.
                  // eslint-disable-next-line eqeqeq
                  if (
                    a === document ||
                    (a.ownerDocument == preferredDoc &&
                      find.contains(preferredDoc, a))
                  ) {
                    return -1
                  }

                  // Support: IE 11+, Edge 17 - 18+
                  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                  // two documents; shallow comparisons work.
                  // eslint-disable-next-line eqeqeq
                  if (
                    b === document ||
                    (b.ownerDocument == preferredDoc &&
                      find.contains(preferredDoc, b))
                  ) {
                    return 1
                  }

                  // Maintain original order
                  return sortInput
                    ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b)
                    : 0
                }

                return compare & 4 ? -1 : 1
              }

              return document
            }

            find.matches = function (expr, elements) {
              return find(expr, null, null, elements)
            }

            find.matchesSelector = function (elem, expr) {
              setDocument(elem)

              if (
                documentIsHTML &&
                !nonnativeSelectorCache[expr + ' '] &&
                (!rbuggyQSA || !rbuggyQSA.test(expr))
              ) {
                try {
                  var ret = matches.call(elem, expr)

                  // IE 9's matchesSelector returns false on disconnected nodes
                  if (
                    ret ||
                    support.disconnectedMatch ||
                    // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    (elem.document && elem.document.nodeType !== 11)
                  ) {
                    return ret
                  }
                } catch (e) {
                  nonnativeSelectorCache(expr, true)
                }
              }

              return find(expr, document, null, [elem]).length > 0
            }

            find.contains = function (context, elem) {
              // Set document vars if needed
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              if ((context.ownerDocument || context) != document) {
                setDocument(context)
              }
              return jQuery.contains(context, elem)
            }

            find.attr = function (elem, name) {
              // Set document vars if needed
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              if ((elem.ownerDocument || elem) != document) {
                setDocument(elem)
              }

              var fn = Expr.attrHandle[name.toLowerCase()],
                // Don't get fooled by Object.prototype properties (see trac-13807)
                val =
                  fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
                    ? fn(elem, name, !documentIsHTML)
                    : undefined

              if (val !== undefined) {
                return val
              }

              return elem.getAttribute(name)
            }

            find.error = function (msg) {
              throw new Error('Syntax error, unrecognized expression: ' + msg)
            }

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            jQuery.uniqueSort = function (results) {
              var elem,
                duplicates = [],
                j = 0,
                i = 0

              // Unless we *know* we can detect duplicates, assume their presence
              //
              // Support: Android <=4.0+
              // Testing for detecting duplicates is unpredictable so instead assume we can't
              // depend on duplicate detection in all browsers without a stable sort.
              hasDuplicate = !support.sortStable
              sortInput = !support.sortStable && slice.call(results, 0)
              sort.call(results, sortOrder)

              if (hasDuplicate) {
                while ((elem = results[i++])) {
                  if (elem === results[i]) {
                    j = duplicates.push(i)
                  }
                }
                while (j--) {
                  splice.call(results, duplicates[j], 1)
                }
              }

              // Clear input after sorting to release objects
              // See https://github.com/jquery/sizzle/pull/225
              sortInput = null

              return results
            }

            jQuery.fn.uniqueSort = function () {
              return this.pushStack(jQuery.uniqueSort(slice.apply(this)))
            }

            Expr = jQuery.expr = {
              // Can be adjusted by the user
              cacheLength: 50,

              createPseudo: markFunction,

              match: matchExpr,

              attrHandle: {},

              find: {},

              relative: {
                '>': { dir: 'parentNode', first: true },
                ' ': { dir: 'parentNode' },
                '+': { dir: 'previousSibling', first: true },
                '~': { dir: 'previousSibling' }
              },

              preFilter: {
                ATTR: function (match) {
                  match[1] = match[1].replace(runescape, funescape)

                  // Move the given value to match[3] whether quoted or unquoted
                  match[3] = (match[3] || match[4] || match[5] || '').replace(
                    runescape,
                    funescape
                  )

                  if (match[2] === '~=') {
                    match[3] = ' ' + match[3] + ' '
                  }

                  return match.slice(0, 4)
                },

                CHILD: function (match) {
                  /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                  match[1] = match[1].toLowerCase()

                  if (match[1].slice(0, 3) === 'nth') {
                    // nth-* requires argument
                    if (!match[3]) {
                      find.error(match[0])
                    }

                    // numeric x and y parameters for Expr.filter.CHILD
                    // remember that false/true cast respectively to 0/1
                    match[4] = +(match[4]
                      ? match[5] + (match[6] || 1)
                      : 2 * (match[3] === 'even' || match[3] === 'odd'))
                    match[5] = +(match[7] + match[8] || match[3] === 'odd')

                    // other types prohibit arguments
                  } else if (match[3]) {
                    find.error(match[0])
                  }

                  return match
                },

                PSEUDO: function (match) {
                  var excess,
                    unquoted = !match[6] && match[2]

                  if (matchExpr.CHILD.test(match[0])) {
                    return null
                  }

                  // Accept quoted arguments as-is
                  if (match[3]) {
                    match[2] = match[4] || match[5] || ''

                    // Strip excess characters from unquoted arguments
                  } else if (
                    unquoted &&
                    rpseudo.test(unquoted) &&
                    // Get excess from tokenize (recursively)
                    (excess = tokenize(unquoted, true)) &&
                    // advance to the next closing parenthesis
                    (excess =
                      unquoted.indexOf(')', unquoted.length - excess) -
                      unquoted.length)
                  ) {
                    // excess is a negative index
                    match[0] = match[0].slice(0, excess)
                    match[2] = unquoted.slice(0, excess)
                  }

                  // Return only captures needed by the pseudo filter method (type and argument)
                  return match.slice(0, 3)
                }
              },

              filter: {
                TAG: function (nodeNameSelector) {
                  var expectedNodeName = nodeNameSelector
                    .replace(runescape, funescape)
                    .toLowerCase()
                  return nodeNameSelector === '*'
                    ? function () {
                        return true
                      }
                    : function (elem) {
                        return nodeName(elem, expectedNodeName)
                      }
                },

                CLASS: function (className) {
                  var pattern = classCache[className + ' ']

                  return (
                    pattern ||
                    ((pattern = new RegExp(
                      '(^|' +
                        whitespace +
                        ')' +
                        className +
                        '(' +
                        whitespace +
                        '|$)'
                    )) &&
                      classCache(className, function (elem) {
                        return pattern.test(
                          (typeof elem.className === 'string' &&
                            elem.className) ||
                            (typeof elem.getAttribute !== 'undefined' &&
                              elem.getAttribute('class')) ||
                            ''
                        )
                      }))
                  )
                },

                ATTR: function (name, operator, check) {
                  return function (elem) {
                    var result = find.attr(elem, name)

                    if (result == null) {
                      return operator === '!='
                    }
                    if (!operator) {
                      return true
                    }

                    result += ''

                    if (operator === '=') {
                      return result === check
                    }
                    if (operator === '!=') {
                      return result !== check
                    }
                    if (operator === '^=') {
                      return check && result.indexOf(check) === 0
                    }
                    if (operator === '*=') {
                      return check && result.indexOf(check) > -1
                    }
                    if (operator === '$=') {
                      return check && result.slice(-check.length) === check
                    }
                    if (operator === '~=') {
                      return (
                        (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(
                          check
                        ) > -1
                      )
                    }
                    if (operator === '|=') {
                      return (
                        result === check ||
                        result.slice(0, check.length + 1) === check + '-'
                      )
                    }

                    return false
                  }
                },

                CHILD: function (type, what, _argument, first, last) {
                  var simple = type.slice(0, 3) !== 'nth',
                    forward = type.slice(-4) !== 'last',
                    ofType = what === 'of-type'

                  return first === 1 && last === 0
                    ? // Shortcut for :nth-*(n)
                      function (elem) {
                        return !!elem.parentNode
                      }
                    : function (elem, _context, xml) {
                        var cache,
                          outerCache,
                          node,
                          nodeIndex,
                          start,
                          dir =
                            simple !== forward
                              ? 'nextSibling'
                              : 'previousSibling',
                          parent = elem.parentNode,
                          name = ofType && elem.nodeName.toLowerCase(),
                          useCache = !xml && !ofType,
                          diff = false

                        if (parent) {
                          // :(first|last|only)-(child|of-type)
                          if (simple) {
                            while (dir) {
                              node = elem
                              while ((node = node[dir])) {
                                if (
                                  ofType
                                    ? nodeName(node, name)
                                    : node.nodeType === 1
                                ) {
                                  return false
                                }
                              }

                              // Reverse direction for :only-* (if we haven't yet done so)
                              start = dir =
                                type === 'only' && !start && 'nextSibling'
                            }
                            return true
                          }

                          start = [
                            forward ? parent.firstChild : parent.lastChild
                          ]

                          // non-xml :nth-child(...) stores cache data on `parent`
                          if (forward && useCache) {
                            // Seek `elem` from a previously-cached index
                            outerCache =
                              parent[expando] || (parent[expando] = {})
                            cache = outerCache[type] || []
                            nodeIndex = cache[0] === dirruns && cache[1]
                            diff = nodeIndex && cache[2]
                            node = nodeIndex && parent.childNodes[nodeIndex]

                            while (
                              (node =
                                (++nodeIndex && node && node[dir]) ||
                                // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) ||
                                start.pop())
                            ) {
                              // When found, cache indexes on `parent` and break
                              if (
                                node.nodeType === 1 &&
                                ++diff &&
                                node === elem
                              ) {
                                outerCache[type] = [dirruns, nodeIndex, diff]
                                break
                              }
                            }
                          } else {
                            // Use previously-cached element index if available
                            if (useCache) {
                              outerCache = elem[expando] || (elem[expando] = {})
                              cache = outerCache[type] || []
                              nodeIndex = cache[0] === dirruns && cache[1]
                              diff = nodeIndex
                            }

                            // xml :nth-child(...)
                            // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                            if (diff === false) {
                              // Use the same loop as above to seek `elem` from the start
                              while (
                                (node =
                                  (++nodeIndex && node && node[dir]) ||
                                  (diff = nodeIndex = 0) ||
                                  start.pop())
                              ) {
                                if (
                                  (ofType
                                    ? nodeName(node, name)
                                    : node.nodeType === 1) &&
                                  ++diff
                                ) {
                                  // Cache the index of each encountered element
                                  if (useCache) {
                                    outerCache =
                                      node[expando] || (node[expando] = {})
                                    outerCache[type] = [dirruns, diff]
                                  }

                                  if (node === elem) {
                                    break
                                  }
                                }
                              }
                            }
                          }

                          // Incorporate the offset, then check against cycle size
                          diff -= last
                          return (
                            diff === first ||
                            (diff % first === 0 && diff / first >= 0)
                          )
                        }
                      }
                },

                PSEUDO: function (pseudo, argument) {
                  // pseudo-class names are case-insensitive
                  // https://www.w3.org/TR/selectors/#pseudo-classes
                  // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                  // Remember that setFilters inherits from pseudos
                  var args,
                    fn =
                      Expr.pseudos[pseudo] ||
                      Expr.setFilters[pseudo.toLowerCase()] ||
                      find.error('unsupported pseudo: ' + pseudo)

                  // The user may use createPseudo to indicate that
                  // arguments are needed to create the filter function
                  // just as jQuery does
                  if (fn[expando]) {
                    return fn(argument)
                  }

                  // But maintain support for old signatures
                  if (fn.length > 1) {
                    args = [pseudo, pseudo, '', argument]
                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())
                      ? markFunction(function (seed, matches) {
                          var idx,
                            matched = fn(seed, argument),
                            i = matched.length
                          while (i--) {
                            idx = indexOf.call(seed, matched[i])
                            seed[idx] = !(matches[idx] = matched[i])
                          }
                        })
                      : function (elem) {
                          return fn(elem, 0, args)
                        }
                  }

                  return fn
                }
              },

              pseudos: {
                // Potentially complex pseudos
                not: markFunction(function (selector) {
                  // Trim the selector passed to compile
                  // to avoid treating leading and trailing
                  // spaces as combinators
                  var input = [],
                    results = [],
                    matcher = compile(selector.replace(rtrimCSS, '$1'))

                  return matcher[expando]
                    ? markFunction(function (seed, matches, _context, xml) {
                        var elem,
                          unmatched = matcher(seed, null, xml, []),
                          i = seed.length

                        // Match elements unmatched by `matcher`
                        while (i--) {
                          if ((elem = unmatched[i])) {
                            seed[i] = !(matches[i] = elem)
                          }
                        }
                      })
                    : function (elem, _context, xml) {
                        input[0] = elem
                        matcher(input, null, xml, results)

                        // Don't keep the element
                        // (see https://github.com/jquery/sizzle/issues/299)
                        input[0] = null
                        return !results.pop()
                      }
                }),

                has: markFunction(function (selector) {
                  return function (elem) {
                    return find(selector, elem).length > 0
                  }
                }),

                contains: markFunction(function (text) {
                  text = text.replace(runescape, funescape)
                  return function (elem) {
                    return (
                      (elem.textContent || jQuery.text(elem)).indexOf(text) > -1
                    )
                  }
                }),

                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // https://www.w3.org/TR/selectors/#lang-pseudo
                lang: markFunction(function (lang) {
                  // lang value must be a valid identifier
                  if (!ridentifier.test(lang || '')) {
                    find.error('unsupported lang: ' + lang)
                  }
                  lang = lang.replace(runescape, funescape).toLowerCase()
                  return function (elem) {
                    var elemLang
                    do {
                      if (
                        (elemLang = documentIsHTML
                          ? elem.lang
                          : elem.getAttribute('xml:lang') ||
                            elem.getAttribute('lang'))
                      ) {
                        elemLang = elemLang.toLowerCase()
                        return (
                          elemLang === lang ||
                          elemLang.indexOf(lang + '-') === 0
                        )
                      }
                    } while ((elem = elem.parentNode) && elem.nodeType === 1)
                    return false
                  }
                }),

                // Miscellaneous
                target: function (elem) {
                  var hash = window.location && window.location.hash
                  return hash && hash.slice(1) === elem.id
                },

                root: function (elem) {
                  return elem === documentElement
                },

                focus: function (elem) {
                  return (
                    elem === safeActiveElement() &&
                    document.hasFocus() &&
                    !!(elem.type || elem.href || ~elem.tabIndex)
                  )
                },

                // Boolean properties
                enabled: createDisabledPseudo(false),
                disabled: createDisabledPseudo(true),

                checked: function (elem) {
                  // In CSS3, :checked should return both checked and selected elements
                  // https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                  return (
                    (nodeName(elem, 'input') && !!elem.checked) ||
                    (nodeName(elem, 'option') && !!elem.selected)
                  )
                },

                selected: function (elem) {
                  // Support: IE <=11+
                  // Accessing the selectedIndex property
                  // forces the browser to treat the default option as
                  // selected when in an optgroup.
                  if (elem.parentNode) {
                    // eslint-disable-next-line no-unused-expressions
                    elem.parentNode.selectedIndex
                  }

                  return elem.selected === true
                },

                // Contents
                empty: function (elem) {
                  // https://www.w3.org/TR/selectors/#empty-pseudo
                  // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                  //   but not by others (comment: 8; processing instruction: 7; etc.)
                  // nodeType < 6 works because attributes (2) do not appear as children
                  for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    if (elem.nodeType < 6) {
                      return false
                    }
                  }
                  return true
                },

                parent: function (elem) {
                  return !Expr.pseudos.empty(elem)
                },

                // Element/input types
                header: function (elem) {
                  return rheader.test(elem.nodeName)
                },

                input: function (elem) {
                  return rinputs.test(elem.nodeName)
                },

                button: function (elem) {
                  return (
                    (nodeName(elem, 'input') && elem.type === 'button') ||
                    nodeName(elem, 'button')
                  )
                },

                text: function (elem) {
                  var attr
                  return (
                    nodeName(elem, 'input') &&
                    elem.type === 'text' &&
                    // Support: IE <10 only
                    // New HTML5 attribute values (e.g., "search") appear
                    // with elem.type === "text"
                    ((attr = elem.getAttribute('type')) == null ||
                      attr.toLowerCase() === 'text')
                  )
                },

                // Position-in-collection
                first: createPositionalPseudo(function () {
                  return [0]
                }),

                last: createPositionalPseudo(function (_matchIndexes, length) {
                  return [length - 1]
                }),

                eq: createPositionalPseudo(
                  function (_matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument]
                  }
                ),

                even: createPositionalPseudo(function (matchIndexes, length) {
                  var i = 0
                  for (; i < length; i += 2) {
                    matchIndexes.push(i)
                  }
                  return matchIndexes
                }),

                odd: createPositionalPseudo(function (matchIndexes, length) {
                  var i = 1
                  for (; i < length; i += 2) {
                    matchIndexes.push(i)
                  }
                  return matchIndexes
                }),

                lt: createPositionalPseudo(
                  function (matchIndexes, length, argument) {
                    var i

                    if (argument < 0) {
                      i = argument + length
                    } else if (argument > length) {
                      i = length
                    } else {
                      i = argument
                    }

                    for (; --i >= 0; ) {
                      matchIndexes.push(i)
                    }
                    return matchIndexes
                  }
                ),

                gt: createPositionalPseudo(
                  function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument
                    for (; ++i < length; ) {
                      matchIndexes.push(i)
                    }
                    return matchIndexes
                  }
                )
              }
            }

            Expr.pseudos.nth = Expr.pseudos.eq

            // Add button/input type pseudos
            for (i in {
              radio: true,
              checkbox: true,
              file: true,
              password: true,
              image: true
            }) {
              Expr.pseudos[i] = createInputPseudo(i)
            }
            for (i in { submit: true, reset: true }) {
              Expr.pseudos[i] = createButtonPseudo(i)
            }

            // Easy API for creating new setFilters
            function setFilters() {}
            setFilters.prototype = Expr.filters = Expr.pseudos
            Expr.setFilters = new setFilters()

            function tokenize(selector, parseOnly) {
              var matched,
                match,
                tokens,
                type,
                soFar,
                groups,
                preFilters,
                cached = tokenCache[selector + ' ']

              if (cached) {
                return parseOnly ? 0 : cached.slice(0)
              }

              soFar = selector
              groups = []
              preFilters = Expr.preFilter

              while (soFar) {
                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                  if (match) {
                    // Don't consume trailing commas as valid
                    soFar = soFar.slice(match[0].length) || soFar
                  }
                  groups.push((tokens = []))
                }

                matched = false

                // Combinators
                if ((match = rleadingCombinator.exec(soFar))) {
                  matched = match.shift()
                  tokens.push({
                    value: matched,

                    // Cast descendant combinators to space
                    type: match[0].replace(rtrimCSS, ' ')
                  })
                  soFar = soFar.slice(matched.length)
                }

                // Filters
                for (type in Expr.filter) {
                  if (
                    (match = matchExpr[type].exec(soFar)) &&
                    (!preFilters[type] || (match = preFilters[type](match)))
                  ) {
                    matched = match.shift()
                    tokens.push({
                      value: matched,
                      type: type,
                      matches: match
                    })
                    soFar = soFar.slice(matched.length)
                  }
                }

                if (!matched) {
                  break
                }
              }

              // Return the length of the invalid excess
              // if we're just parsing
              // Otherwise, throw an error or return tokens
              if (parseOnly) {
                return soFar.length
              }

              return soFar
                ? find.error(selector)
                : // Cache the tokens
                  tokenCache(selector, groups).slice(0)
            }

            function toSelector(tokens) {
              var i = 0,
                len = tokens.length,
                selector = ''
              for (; i < len; i++) {
                selector += tokens[i].value
              }
              return selector
            }

            function addCombinator(matcher, combinator, base) {
              var dir = combinator.dir,
                skip = combinator.next,
                key = skip || dir,
                checkNonElements = base && key === 'parentNode',
                doneName = done++

              return combinator.first
                ? // Check against closest ancestor/preceding element
                  function (elem, context, xml) {
                    while ((elem = elem[dir])) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml)
                      }
                    }
                    return false
                  }
                : // Check against all ancestor/preceding elements
                  function (elem, context, xml) {
                    var oldCache,
                      outerCache,
                      newCache = [dirruns, doneName]

                    // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                    if (xml) {
                      while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                          if (matcher(elem, context, xml)) {
                            return true
                          }
                        }
                      }
                    } else {
                      while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                          outerCache = elem[expando] || (elem[expando] = {})

                          if (skip && nodeName(elem, skip)) {
                            elem = elem[dir] || elem
                          } else if (
                            (oldCache = outerCache[key]) &&
                            oldCache[0] === dirruns &&
                            oldCache[1] === doneName
                          ) {
                            // Assign to newCache so results back-propagate to previous elements
                            return (newCache[2] = oldCache[2])
                          } else {
                            // Reuse newcache so results back-propagate to previous elements
                            outerCache[key] = newCache

                            // A match means we're done; a fail means we have to keep checking
                            if ((newCache[2] = matcher(elem, context, xml))) {
                              return true
                            }
                          }
                        }
                      }
                    }
                    return false
                  }
            }

            function elementMatcher(matchers) {
              return matchers.length > 1
                ? function (elem, context, xml) {
                    var i = matchers.length
                    while (i--) {
                      if (!matchers[i](elem, context, xml)) {
                        return false
                      }
                    }
                    return true
                  }
                : matchers[0]
            }

            function multipleContexts(selector, contexts, results) {
              var i = 0,
                len = contexts.length
              for (; i < len; i++) {
                find(selector, contexts[i], results)
              }
              return results
            }

            function condense(unmatched, map, filter, context, xml) {
              var elem,
                newUnmatched = [],
                i = 0,
                len = unmatched.length,
                mapped = map != null

              for (; i < len; i++) {
                if ((elem = unmatched[i])) {
                  if (!filter || filter(elem, context, xml)) {
                    newUnmatched.push(elem)
                    if (mapped) {
                      map.push(i)
                    }
                  }
                }
              }

              return newUnmatched
            }

            function setMatcher(
              preFilter,
              selector,
              matcher,
              postFilter,
              postFinder,
              postSelector
            ) {
              if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter)
              }
              if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector)
              }
              return markFunction(function (seed, results, context, xml) {
                var temp,
                  i,
                  elem,
                  matcherOut,
                  preMap = [],
                  postMap = [],
                  preexisting = results.length,
                  // Get initial elements from seed or context
                  elems =
                    seed ||
                    multipleContexts(
                      selector || '*',
                      context.nodeType ? [context] : context,
                      []
                    ),
                  // Prefilter to get matcher input, preserving a map for seed-results synchronization
                  matcherIn =
                    preFilter && (seed || !selector)
                      ? condense(elems, preMap, preFilter, context, xml)
                      : elems

                if (matcher) {
                  // If we have a postFinder, or filtered seed, or non-seed postFilter
                  // or preexisting results,
                  matcherOut =
                    postFinder || (seed ? preFilter : preexisting || postFilter)
                      ? // ...intermediate processing is necessary
                        []
                      : // ...otherwise use results directly
                        results

                  // Find primary matches
                  matcher(matcherIn, matcherOut, context, xml)
                } else {
                  matcherOut = matcherIn
                }

                // Apply postFilter
                if (postFilter) {
                  temp = condense(matcherOut, postMap)
                  postFilter(temp, [], context, xml)

                  // Un-match failing elements by moving them back to matcherIn
                  i = temp.length
                  while (i--) {
                    if ((elem = temp[i])) {
                      matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
                    }
                  }
                }

                if (seed) {
                  if (postFinder || preFilter) {
                    if (postFinder) {
                      // Get the final matcherOut by condensing this intermediate into postFinder contexts
                      temp = []
                      i = matcherOut.length
                      while (i--) {
                        if ((elem = matcherOut[i])) {
                          // Restore matcherIn since elem is not yet a final match
                          temp.push((matcherIn[i] = elem))
                        }
                      }
                      postFinder(null, (matcherOut = []), temp, xml)
                    }

                    // Move matched elements from seed to results to keep them synchronized
                    i = matcherOut.length
                    while (i--) {
                      if (
                        (elem = matcherOut[i]) &&
                        (temp = postFinder
                          ? indexOf.call(seed, elem)
                          : preMap[i]) > -1
                      ) {
                        seed[temp] = !(results[temp] = elem)
                      }
                    }
                  }

                  // Add elements to results, through postFinder if defined
                } else {
                  matcherOut = condense(
                    matcherOut === results
                      ? matcherOut.splice(preexisting, matcherOut.length)
                      : matcherOut
                  )
                  if (postFinder) {
                    postFinder(null, results, matcherOut, xml)
                  } else {
                    push.apply(results, matcherOut)
                  }
                }
              })
            }

            function matcherFromTokens(tokens) {
              var checkContext,
                matcher,
                j,
                len = tokens.length,
                leadingRelative = Expr.relative[tokens[0].type],
                implicitRelative = leadingRelative || Expr.relative[' '],
                i = leadingRelative ? 1 : 0,
                // The foundational matcher ensures that elements are reachable from top-level context(s)
                matchContext = addCombinator(
                  function (elem) {
                    return elem === checkContext
                  },
                  implicitRelative,
                  true
                ),
                matchAnyContext = addCombinator(
                  function (elem) {
                    return indexOf.call(checkContext, elem) > -1
                  },
                  implicitRelative,
                  true
                ),
                matchers = [
                  function (elem, context, xml) {
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    var ret =
                      (!leadingRelative &&
                        (xml || context != outermostContext)) ||
                      ((checkContext = context).nodeType
                        ? matchContext(elem, context, xml)
                        : matchAnyContext(elem, context, xml))

                    // Avoid hanging onto element
                    // (see https://github.com/jquery/sizzle/issues/299)
                    checkContext = null
                    return ret
                  }
                ]

              for (; i < len; i++) {
                if ((matcher = Expr.relative[tokens[i].type])) {
                  matchers = [addCombinator(elementMatcher(matchers), matcher)]
                } else {
                  matcher = Expr.filter[tokens[i].type].apply(
                    null,
                    tokens[i].matches
                  )

                  // Return special upon seeing a positional matcher
                  if (matcher[expando]) {
                    // Find the next relative operator (if any) for proper handling
                    j = ++i
                    for (; j < len; j++) {
                      if (Expr.relative[tokens[j].type]) {
                        break
                      }
                    }
                    return setMatcher(
                      i > 1 && elementMatcher(matchers),
                      i > 1 &&
                        toSelector(
                          // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                          tokens
                            .slice(0, i - 1)
                            .concat({
                              value: tokens[i - 2].type === ' ' ? '*' : ''
                            })
                        ).replace(rtrimCSS, '$1'),
                      matcher,
                      i < j && matcherFromTokens(tokens.slice(i, j)),
                      j < len && matcherFromTokens((tokens = tokens.slice(j))),
                      j < len && toSelector(tokens)
                    )
                  }
                  matchers.push(matcher)
                }
              }

              return elementMatcher(matchers)
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
              var bySet = setMatchers.length > 0,
                byElement = elementMatchers.length > 0,
                superMatcher = function (
                  seed,
                  context,
                  xml,
                  results,
                  outermost
                ) {
                  var elem,
                    j,
                    matcher,
                    matchedCount = 0,
                    i = '0',
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,
                    // We must always have either seed elements or outermost context
                    elems =
                      seed || (byElement && Expr.find.TAG('*', outermost)),
                    // Use integer dirruns iff this is the outermost matcher
                    dirrunsUnique = (dirruns +=
                      contextBackup == null ? 1 : Math.random() || 0.1),
                    len = elems.length

                  if (outermost) {
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    outermostContext =
                      context == document || context || outermost
                  }

                  // Add elements passing elementMatchers directly to results
                  // Support: iOS <=7 - 9 only
                  // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
                  // elements by id. (see trac-14142)
                  for (; i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                      j = 0

                      // Support: IE 11+, Edge 17 - 18+
                      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                      // two documents; shallow comparisons work.
                      // eslint-disable-next-line eqeqeq
                      if (!context && elem.ownerDocument != document) {
                        setDocument(elem)
                        xml = !documentIsHTML
                      }
                      while ((matcher = elementMatchers[j++])) {
                        if (matcher(elem, context || document, xml)) {
                          push.call(results, elem)
                          break
                        }
                      }
                      if (outermost) {
                        dirruns = dirrunsUnique
                      }
                    }

                    // Track unmatched elements for set filters
                    if (bySet) {
                      // They will have gone through all possible matchers
                      if ((elem = !matcher && elem)) {
                        matchedCount--
                      }

                      // Lengthen the array for every element, matched or not
                      if (seed) {
                        unmatched.push(elem)
                      }
                    }
                  }

                  // `i` is now the count of elements visited above, and adding it to `matchedCount`
                  // makes the latter nonnegative.
                  matchedCount += i

                  // Apply set filters to unmatched elements
                  // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                  // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                  // no element matchers and no seed.
                  // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                  // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                  // numerically zero.
                  if (bySet && i !== matchedCount) {
                    j = 0
                    while ((matcher = setMatchers[j++])) {
                      matcher(unmatched, setMatched, context, xml)
                    }

                    if (seed) {
                      // Reintegrate element matches to eliminate the need for sorting
                      if (matchedCount > 0) {
                        while (i--) {
                          if (!(unmatched[i] || setMatched[i])) {
                            setMatched[i] = pop.call(results)
                          }
                        }
                      }

                      // Discard index placeholder values to get only actual matches
                      setMatched = condense(setMatched)
                    }

                    // Add matches to results
                    push.apply(results, setMatched)

                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (
                      outermost &&
                      !seed &&
                      setMatched.length > 0 &&
                      matchedCount + setMatchers.length > 1
                    ) {
                      jQuery.uniqueSort(results)
                    }
                  }

                  // Override manipulation of globals by nested matchers
                  if (outermost) {
                    dirruns = dirrunsUnique
                    outermostContext = contextBackup
                  }

                  return unmatched
                }

              return bySet ? markFunction(superMatcher) : superMatcher
            }

            function compile(selector, match /* Internal Use Only */) {
              var i,
                setMatchers = [],
                elementMatchers = [],
                cached = compilerCache[selector + ' ']

              if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) {
                  match = tokenize(selector)
                }
                i = match.length
                while (i--) {
                  cached = matcherFromTokens(match[i])
                  if (cached[expando]) {
                    setMatchers.push(cached)
                  } else {
                    elementMatchers.push(cached)
                  }
                }

                // Cache the compiled function
                cached = compilerCache(
                  selector,
                  matcherFromGroupMatchers(elementMatchers, setMatchers)
                )

                // Save selector and tokenization
                cached.selector = selector
              }
              return cached
            }

            /**
             * A low-level selection function that works with jQuery's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with jQuery selector compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            function select(selector, context, results, seed) {
              var i,
                tokens,
                token,
                type,
                find,
                compiled = typeof selector === 'function' && selector,
                match =
                  !seed && tokenize((selector = compiled.selector || selector))

              results = results || []

              // Try to minimize operations if there is only one selector in the list and no seed
              // (the latter of which guarantees us context)
              if (match.length === 1) {
                // Reduce context if the leading compound selector is an ID
                tokens = match[0] = match[0].slice(0)
                if (
                  tokens.length > 2 &&
                  (token = tokens[0]).type === 'ID' &&
                  context.nodeType === 9 &&
                  documentIsHTML &&
                  Expr.relative[tokens[1].type]
                ) {
                  context = (Expr.find.ID(
                    token.matches[0].replace(runescape, funescape),
                    context
                  ) || [])[0]
                  if (!context) {
                    return results

                    // Precompiled matchers will still verify ancestry, so step up a level
                  } else if (compiled) {
                    context = context.parentNode
                  }

                  selector = selector.slice(tokens.shift().value.length)
                }

                // Fetch a seed set for right-to-left matching
                i = matchExpr.needsContext.test(selector) ? 0 : tokens.length
                while (i--) {
                  token = tokens[i]

                  // Abort if we hit a combinator
                  if (Expr.relative[(type = token.type)]) {
                    break
                  }
                  if ((find = Expr.find[type])) {
                    // Search, expanding context for leading sibling combinators
                    if (
                      (seed = find(
                        token.matches[0].replace(runescape, funescape),
                        (rsibling.test(tokens[0].type) &&
                          testContext(context.parentNode)) ||
                          context
                      ))
                    ) {
                      // If seed is empty or no tokens remain, we can return early
                      tokens.splice(i, 1)
                      selector = seed.length && toSelector(tokens)
                      if (!selector) {
                        push.apply(results, seed)
                        return results
                      }

                      break
                    }
                  }
                }
              }

              // Compile and execute a filtering function if one is not provided
              // Provide `match` to avoid retokenization if we modified the selector above
              ;(compiled || compile(selector, match))(
                seed,
                context,
                !documentIsHTML,
                results,
                !context ||
                  (rsibling.test(selector) &&
                    testContext(context.parentNode)) ||
                  context
              )
              return results
            }

            // One-time assignments

            // Support: Android <=4.0 - 4.1+
            // Sort stability
            support.sortStable =
              expando.split('').sort(sortOrder).join('') === expando

            // Initialize against the default document
            setDocument()

            // Support: Android <=4.0 - 4.1+
            // Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function (el) {
              // Should return 1, but returns 4 (following)
              return (
                el.compareDocumentPosition(document.createElement('fieldset')) &
                1
              )
            })

            jQuery.find = find

            // Deprecated
            jQuery.expr[':'] = jQuery.expr.pseudos
            jQuery.unique = jQuery.uniqueSort

            // These have always been private, but they used to be documented as part of
            // Sizzle so let's maintain them for now for backwards compatibility purposes.
            find.compile = compile
            find.select = select
            find.setDocument = setDocument
            find.tokenize = tokenize

            find.escape = jQuery.escapeSelector
            find.getText = jQuery.text
            find.isXML = jQuery.isXMLDoc
            find.selectors = jQuery.expr
            find.support = jQuery.support
            find.uniqueSort = jQuery.uniqueSort

            /* eslint-enable */
          })()

          var dir = function (elem, dir, until) {
            var matched = [],
              truncate = until !== undefined

            while ((elem = elem[dir]) && elem.nodeType !== 9) {
              if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                  break
                }
                matched.push(elem)
              }
            }
            return matched
          }

          var siblings = function (n, elem) {
            var matched = []

            for (; n; n = n.nextSibling) {
              if (n.nodeType === 1 && n !== elem) {
                matched.push(n)
              }
            }

            return matched
          }

          var rneedsContext = jQuery.expr.match.needsContext

          var rsingleTag =
            /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i

          // Implement the identical functionality for filter and not
          function winnow(elements, qualifier, not) {
            if (isFunction(qualifier)) {
              return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
              })
            }

            // Single element
            if (qualifier.nodeType) {
              return jQuery.grep(elements, function (elem) {
                return (elem === qualifier) !== not
              })
            }

            // Arraylike of elements (jQuery, arguments, Array)
            if (typeof qualifier !== 'string') {
              return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not
              })
            }

            // Filtered directly for both simple and complex selectors
            return jQuery.filter(qualifier, elements, not)
          }

          jQuery.filter = function (expr, elems, not) {
            var elem = elems[0]

            if (not) {
              expr = ':not(' + expr + ')'
            }

            if (elems.length === 1 && elem.nodeType === 1) {
              return jQuery.find.matchesSelector(elem, expr) ? [elem] : []
            }

            return jQuery.find.matches(
              expr,
              jQuery.grep(elems, function (elem) {
                return elem.nodeType === 1
              })
            )
          }

          jQuery.fn.extend({
            find: function (selector) {
              var i,
                ret,
                len = this.length,
                self = this

              if (typeof selector !== 'string') {
                return this.pushStack(
                  jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                      if (jQuery.contains(self[i], this)) {
                        return true
                      }
                    }
                  })
                )
              }

              ret = this.pushStack([])

              for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret)
              }

              return len > 1 ? jQuery.uniqueSort(ret) : ret
            },
            filter: function (selector) {
              return this.pushStack(winnow(this, selector || [], false))
            },
            not: function (selector) {
              return this.pushStack(winnow(this, selector || [], true))
            },
            is: function (selector) {
              return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === 'string' && rneedsContext.test(selector)
                  ? jQuery(selector)
                  : selector || [],
                false
              ).length
            }
          })

          // Initialize a jQuery object

          // A central reference to the root jQuery(document)
          var rootjQuery,
            // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
            // Strict HTML recognition (trac-11290: must start with <)
            // Shortcut simple #id case for speed
            rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
            init = (jQuery.fn.init = function (selector, context, root) {
              var match, elem

              // HANDLE: $(""), $(null), $(undefined), $(false)
              if (!selector) {
                return this
              }

              // Method init() accepts an alternate rootjQuery
              // so migrate can support jQuery.sub (gh-2101)
              root = root || rootjQuery

              // Handle HTML strings
              if (typeof selector === 'string') {
                if (
                  selector[0] === '<' &&
                  selector[selector.length - 1] === '>' &&
                  selector.length >= 3
                ) {
                  // Assume that strings that start and end with <> are HTML and skip the regex check
                  match = [null, selector, null]
                } else {
                  match = rquickExpr.exec(selector)
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {
                  // HANDLE: $(html) -> $(array)
                  if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context

                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(
                      this,
                      jQuery.parseHTML(
                        match[1],
                        context && context.nodeType
                          ? context.ownerDocument || context
                          : document,
                        true
                      )
                    )

                    // HANDLE: $(html, props)
                    if (
                      rsingleTag.test(match[1]) &&
                      jQuery.isPlainObject(context)
                    ) {
                      for (match in context) {
                        // Properties of context are called as methods if possible
                        if (isFunction(this[match])) {
                          this[match](context[match])

                          // ...and otherwise set as attributes
                        } else {
                          this.attr(match, context[match])
                        }
                      }
                    }

                    return this

                    // HANDLE: $(#id)
                  } else {
                    elem = document.getElementById(match[2])

                    if (elem) {
                      // Inject the element directly into the jQuery object
                      this[0] = elem
                      this.length = 1
                    }
                    return this
                  }

                  // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                  return (context || root).find(selector)

                  // HANDLE: $(expr, context)
                  // (which is just equivalent to: $(context).find(expr)
                } else {
                  return this.constructor(context).find(selector)
                }

                // HANDLE: $(DOMElement)
              } else if (selector.nodeType) {
                this[0] = selector
                this.length = 1
                return this

                // HANDLE: $(function)
                // Shortcut for document ready
              } else if (isFunction(selector)) {
                return root.ready !== undefined
                  ? root.ready(selector)
                  : // Execute immediately if ready is not present
                    selector(jQuery)
              }

              return jQuery.makeArray(selector, this)
            })

          // Give the init function the jQuery prototype for later instantiation
          init.prototype = jQuery.fn

          // Initialize central reference
          rootjQuery = jQuery(document)

          var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            // Methods guaranteed to produce a unique set when starting from a unique set
            guaranteedUnique = {
              children: true,
              contents: true,
              next: true,
              prev: true
            }

          jQuery.fn.extend({
            has: function (target) {
              var targets = jQuery(target, this),
                l = targets.length

              return this.filter(function () {
                var i = 0
                for (; i < l; i++) {
                  if (jQuery.contains(this, targets[i])) {
                    return true
                  }
                }
              })
            },

            closest: function (selectors, context) {
              var cur,
                i = 0,
                l = this.length,
                matched = [],
                targets = typeof selectors !== 'string' && jQuery(selectors)

              // Positional selectors never match, since there's no _selection_ context
              if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                  for (
                    cur = this[i];
                    cur && cur !== context;
                    cur = cur.parentNode
                  ) {
                    // Always skip document fragments
                    if (
                      cur.nodeType < 11 &&
                      (targets
                        ? targets.index(cur) > -1
                        : // Don't pass non-elements to jQuery#find
                          cur.nodeType === 1 &&
                          jQuery.find.matchesSelector(cur, selectors))
                    ) {
                      matched.push(cur)
                      break
                    }
                  }
                }
              }

              return this.pushStack(
                matched.length > 1 ? jQuery.uniqueSort(matched) : matched
              )
            },

            // Determine the position of an element within the set
            index: function (elem) {
              // No argument, return index in parent
              if (!elem) {
                return this[0] && this[0].parentNode
                  ? this.first().prevAll().length
                  : -1
              }

              // Index in selector
              if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0])
              }

              // Locate the position of the desired element
              return indexOf.call(
                this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
              )
            },

            add: function (selector, context) {
              return this.pushStack(
                jQuery.uniqueSort(
                  jQuery.merge(this.get(), jQuery(selector, context))
                )
              )
            },

            addBack: function (selector) {
              return this.add(
                selector == null
                  ? this.prevObject
                  : this.prevObject.filter(selector)
              )
            }
          })

          function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {}
            return cur
          }

          jQuery.each(
            {
              parent: function (elem) {
                var parent = elem.parentNode
                return parent && parent.nodeType !== 11 ? parent : null
              },
              parents: function (elem) {
                return dir(elem, 'parentNode')
              },
              parentsUntil: function (elem, _i, until) {
                return dir(elem, 'parentNode', until)
              },
              next: function (elem) {
                return sibling(elem, 'nextSibling')
              },
              prev: function (elem) {
                return sibling(elem, 'previousSibling')
              },
              nextAll: function (elem) {
                return dir(elem, 'nextSibling')
              },
              prevAll: function (elem) {
                return dir(elem, 'previousSibling')
              },
              nextUntil: function (elem, _i, until) {
                return dir(elem, 'nextSibling', until)
              },
              prevUntil: function (elem, _i, until) {
                return dir(elem, 'previousSibling', until)
              },
              siblings: function (elem) {
                return siblings((elem.parentNode || {}).firstChild, elem)
              },
              children: function (elem) {
                return siblings(elem.firstChild)
              },
              contents: function (elem) {
                if (
                  elem.contentDocument != null &&
                  // Support: IE 11+
                  // <object> elements with no `data` attribute has an object
                  // `contentDocument` with a `null` prototype.
                  getProto(elem.contentDocument)
                ) {
                  return elem.contentDocument
                }

                // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
                // Treat the template element as a regular one in browsers that
                // don't support it.
                if (nodeName(elem, 'template')) {
                  elem = elem.content || elem
                }

                return jQuery.merge([], elem.childNodes)
              }
            },
            function (name, fn) {
              jQuery.fn[name] = function (until, selector) {
                var matched = jQuery.map(this, fn, until)

                if (name.slice(-5) !== 'Until') {
                  selector = until
                }

                if (selector && typeof selector === 'string') {
                  matched = jQuery.filter(selector, matched)
                }

                if (this.length > 1) {
                  // Remove duplicates
                  if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched)
                  }

                  // Reverse order for parents* and prev-derivatives
                  if (rparentsprev.test(name)) {
                    matched.reverse()
                  }
                }

                return this.pushStack(matched)
              }
            }
          )
          var rnothtmlwhite = /[^\x20\t\r\n\f]+/g

          // Convert String-formatted options into Object-formatted ones
          function createOptions(options) {
            var object = {}
            jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
              object[flag] = true
            })
            return object
          }

          /*
           * Create a callback list using the following parameters:
           *
           *	options: an optional list of space-separated options that will change how
           *			the callback list behaves or a more traditional option object
           *
           * By default a callback list will act like an event callback list and can be
           * "fired" multiple times.
           *
           * Possible options:
           *
           *	once:			will ensure the callback list can only be fired once (like a Deferred)
           *
           *	memory:			will keep track of previous values and will call any callback added
           *					after the list has been fired right away with the latest "memorized"
           *					values (like a Deferred)
           *
           *	unique:			will ensure a callback can only be added once (no duplicate in the list)
           *
           *	stopOnFalse:	interrupt callings when a callback returns false
           *
           */
          jQuery.Callbacks = function (options) {
            // Convert options from String-formatted to Object-formatted if needed
            // (we check in cache first)
            options =
              typeof options === 'string'
                ? createOptions(options)
                : jQuery.extend({}, options)

            var // Flag to know if list is currently firing
              firing,
              // Last fire value for non-forgettable lists
              memory,
              // Flag to know if list was already fired
              fired,
              // Flag to prevent firing
              locked,
              // Actual callback list
              list = [],
              // Queue of execution data for repeatable lists
              queue = [],
              // Index of currently firing callback (modified by add/remove as needed)
              firingIndex = -1,
              // Fire callbacks
              fire = function () {
                // Enforce single-firing
                locked = locked || options.once

                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true
                for (; queue.length; firingIndex = -1) {
                  memory = queue.shift()
                  while (++firingIndex < list.length) {
                    // Run callback and check for early termination
                    if (
                      list[firingIndex].apply(memory[0], memory[1]) === false &&
                      options.stopOnFalse
                    ) {
                      // Jump to end and forget the data so .add doesn't re-fire
                      firingIndex = list.length
                      memory = false
                    }
                  }
                }

                // Forget the data if we're done with it
                if (!options.memory) {
                  memory = false
                }

                firing = false

                // Clean up if we're done firing for good
                if (locked) {
                  // Keep an empty list if we have data for future add calls
                  if (memory) {
                    list = []

                    // Otherwise, this object is spent
                  } else {
                    list = ''
                  }
                }
              },
              // Actual Callbacks object
              self = {
                // Add a callback or a collection of callbacks to the list
                add: function () {
                  if (list) {
                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                      firingIndex = list.length - 1
                      queue.push(memory)
                    }

                    ;(function add(args) {
                      jQuery.each(args, function (_, arg) {
                        if (isFunction(arg)) {
                          if (!options.unique || !self.has(arg)) {
                            list.push(arg)
                          }
                        } else if (
                          arg &&
                          arg.length &&
                          toType(arg) !== 'string'
                        ) {
                          // Inspect recursively
                          add(arg)
                        }
                      })
                    })(arguments)

                    if (memory && !firing) {
                      fire()
                    }
                  }
                  return this
                },

                // Remove a callback from the list
                remove: function () {
                  jQuery.each(arguments, function (_, arg) {
                    var index
                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                      list.splice(index, 1)

                      // Handle firing indexes
                      if (index <= firingIndex) {
                        firingIndex--
                      }
                    }
                  })
                  return this
                },

                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function (fn) {
                  return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
                },

                // Remove all callbacks from the list
                empty: function () {
                  if (list) {
                    list = []
                  }
                  return this
                },

                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function () {
                  locked = queue = []
                  list = memory = ''
                  return this
                },
                disabled: function () {
                  return !list
                },

                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function () {
                  locked = queue = []
                  if (!memory && !firing) {
                    list = memory = ''
                  }
                  return this
                },
                locked: function () {
                  return !!locked
                },

                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                  if (!locked) {
                    args = args || []
                    args = [context, args.slice ? args.slice() : args]
                    queue.push(args)
                    if (!firing) {
                      fire()
                    }
                  }
                  return this
                },

                // Call all the callbacks with the given arguments
                fire: function () {
                  self.fireWith(this, arguments)
                  return this
                },

                // To know if the callbacks have already been called at least once
                fired: function () {
                  return !!fired
                }
              }

            return self
          }

          function Identity(v) {
            return v
          }
          function Thrower(ex) {
            throw ex
          }

          function adoptValue(value, resolve, reject, noValue) {
            var method

            try {
              // Check for promise aspect first to privilege synchronous behavior
              if (value && isFunction((method = value.promise))) {
                method.call(value).done(resolve).fail(reject)

                // Other thenables
              } else if (value && isFunction((method = value.then))) {
                method.call(value, resolve, reject)

                // Other non-thenables
              } else {
                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                // * false: [ value ].slice( 0 ) => resolve( value )
                // * true: [ value ].slice( 1 ) => resolve()
                resolve.apply(undefined, [value].slice(noValue))
              }

              // For Promises/A+, convert exceptions into rejections
              // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
              // Deferred#then to conditionally suppress rejection.
            } catch (value) {
              // Support: Android 4.0 only
              // Strict mode functions invoked without .call/.apply get global-object context
              reject.apply(undefined, [value])
            }
          }

          jQuery.extend({
            Deferred: function (func) {
              var tuples = [
                  // action, add listener, callbacks,
                  // ... .then handlers, argument index, [final state]
                  [
                    'notify',
                    'progress',
                    jQuery.Callbacks('memory'),
                    jQuery.Callbacks('memory'),
                    2
                  ],
                  [
                    'resolve',
                    'done',
                    jQuery.Callbacks('once memory'),
                    jQuery.Callbacks('once memory'),
                    0,
                    'resolved'
                  ],
                  [
                    'reject',
                    'fail',
                    jQuery.Callbacks('once memory'),
                    jQuery.Callbacks('once memory'),
                    1,
                    'rejected'
                  ]
                ],
                state = 'pending',
                promise = {
                  state: function () {
                    return state
                  },
                  always: function () {
                    deferred.done(arguments).fail(arguments)
                    return this
                  },
                  catch: function (fn) {
                    return promise.then(null, fn)
                  },

                  // Keep pipe for back-compat
                  pipe: function (/* fnDone, fnFail, fnProgress */) {
                    var fns = arguments

                    return jQuery
                      .Deferred(function (newDefer) {
                        jQuery.each(tuples, function (_i, tuple) {
                          // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                          var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]

                          // deferred.progress(function() { bind to newDefer or newDefer.notify })
                          // deferred.done(function() { bind to newDefer or newDefer.resolve })
                          // deferred.fail(function() { bind to newDefer or newDefer.reject })
                          deferred[tuple[1]](function () {
                            var returned = fn && fn.apply(this, arguments)
                            if (returned && isFunction(returned.promise)) {
                              returned
                                .promise()
                                .progress(newDefer.notify)
                                .done(newDefer.resolve)
                                .fail(newDefer.reject)
                            } else {
                              newDefer[tuple[0] + 'With'](
                                this,
                                fn ? [returned] : arguments
                              )
                            }
                          })
                        })
                        fns = null
                      })
                      .promise()
                  },
                  then: function (onFulfilled, onRejected, onProgress) {
                    var maxDepth = 0
                    function resolve(depth, deferred, handler, special) {
                      return function () {
                        var that = this,
                          args = arguments,
                          mightThrow = function () {
                            var returned, then

                            // Support: Promises/A+ section 2.3.3.3.3
                            // https://promisesaplus.com/#point-59
                            // Ignore double-resolution attempts
                            if (depth < maxDepth) {
                              return
                            }

                            returned = handler.apply(that, args)

                            // Support: Promises/A+ section 2.3.1
                            // https://promisesaplus.com/#point-48
                            if (returned === deferred.promise()) {
                              throw new TypeError('Thenable self-resolution')
                            }

                            // Support: Promises/A+ sections 2.3.3.1, 3.5
                            // https://promisesaplus.com/#point-54
                            // https://promisesaplus.com/#point-75
                            // Retrieve `then` only once
                            then =
                              returned &&
                              // Support: Promises/A+ section 2.3.4
                              // https://promisesaplus.com/#point-64
                              // Only check objects and functions for thenability
                              (typeof returned === 'object' ||
                                typeof returned === 'function') &&
                              returned.then

                            // Handle a returned thenable
                            if (isFunction(then)) {
                              // Special processors (notify) just wait for resolution
                              if (special) {
                                then.call(
                                  returned,
                                  resolve(
                                    maxDepth,
                                    deferred,
                                    Identity,
                                    special
                                  ),
                                  resolve(maxDepth, deferred, Thrower, special)
                                )

                                // Normal processors (resolve) also hook into progress
                              } else {
                                // ...and disregard older resolution values
                                maxDepth++

                                then.call(
                                  returned,
                                  resolve(
                                    maxDepth,
                                    deferred,
                                    Identity,
                                    special
                                  ),
                                  resolve(maxDepth, deferred, Thrower, special),
                                  resolve(
                                    maxDepth,
                                    deferred,
                                    Identity,
                                    deferred.notifyWith
                                  )
                                )
                              }

                              // Handle all other returned values
                            } else {
                              // Only substitute handlers pass on context
                              // and multiple values (non-spec behavior)
                              if (handler !== Identity) {
                                that = undefined
                                args = [returned]
                              }

                              // Process the value(s)
                              // Default process is resolve
                              ;(special || deferred.resolveWith)(that, args)
                            }
                          },
                          // Only normal processors (resolve) catch and reject exceptions
                          process = special
                            ? mightThrow
                            : function () {
                                try {
                                  mightThrow()
                                } catch (e) {
                                  if (jQuery.Deferred.exceptionHook) {
                                    jQuery.Deferred.exceptionHook(
                                      e,
                                      process.error
                                    )
                                  }

                                  // Support: Promises/A+ section 2.3.3.3.4.1
                                  // https://promisesaplus.com/#point-61
                                  // Ignore post-resolution exceptions
                                  if (depth + 1 >= maxDepth) {
                                    // Only substitute handlers pass on context
                                    // and multiple values (non-spec behavior)
                                    if (handler !== Thrower) {
                                      that = undefined
                                      args = [e]
                                    }

                                    deferred.rejectWith(that, args)
                                  }
                                }
                              }

                        // Support: Promises/A+ section 2.3.3.3.1
                        // https://promisesaplus.com/#point-57
                        // Re-resolve promises immediately to dodge false rejection from
                        // subsequent errors
                        if (depth) {
                          process()
                        } else {
                          // Call an optional hook to record the error, in case of exception
                          // since it's otherwise lost when execution goes async
                          if (jQuery.Deferred.getErrorHook) {
                            process.error = jQuery.Deferred.getErrorHook()

                            // The deprecated alias of the above. While the name suggests
                            // returning the stack, not an error instance, jQuery just passes
                            // it directly to `console.warn` so both will work; an instance
                            // just better cooperates with source maps.
                          } else if (jQuery.Deferred.getStackHook) {
                            process.error = jQuery.Deferred.getStackHook()
                          }
                          window.setTimeout(process)
                        }
                      }
                    }

                    return jQuery
                      .Deferred(function (newDefer) {
                        // progress_handlers.add( ... )
                        tuples[0][3].add(
                          resolve(
                            0,
                            newDefer,
                            isFunction(onProgress) ? onProgress : Identity,
                            newDefer.notifyWith
                          )
                        )

                        // fulfilled_handlers.add( ... )
                        tuples[1][3].add(
                          resolve(
                            0,
                            newDefer,
                            isFunction(onFulfilled) ? onFulfilled : Identity
                          )
                        )

                        // rejected_handlers.add( ... )
                        tuples[2][3].add(
                          resolve(
                            0,
                            newDefer,
                            isFunction(onRejected) ? onRejected : Thrower
                          )
                        )
                      })
                      .promise()
                  },

                  // Get a promise for this deferred
                  // If obj is provided, the promise aspect is added to the object
                  promise: function (obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise
                  }
                },
                deferred = {}

              // Add list-specific methods
              jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                  stateString = tuple[5]

                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add

                // Handle state
                if (stateString) {
                  list.add(
                    function () {
                      // state = "resolved" (i.e., fulfilled)
                      // state = "rejected"
                      state = stateString
                    },

                    // rejected_callbacks.disable
                    // fulfilled_callbacks.disable
                    tuples[3 - i][2].disable,

                    // rejected_handlers.disable
                    // fulfilled_handlers.disable
                    tuples[3 - i][3].disable,

                    // progress_callbacks.lock
                    tuples[0][2].lock,

                    // progress_handlers.lock
                    tuples[0][3].lock
                  )
                }

                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire)

                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function () {
                  deferred[tuple[0] + 'With'](
                    this === deferred ? undefined : this,
                    arguments
                  )
                  return this
                }

                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + 'With'] = list.fireWith
              })

              // Make the deferred a promise
              promise.promise(deferred)

              // Call given func if any
              if (func) {
                func.call(deferred, deferred)
              }

              // All done!
              return deferred
            },

            // Deferred helper
            when: function (singleValue) {
              var // count of uncompleted subordinates
                remaining = arguments.length,
                // count of unprocessed arguments
                i = remaining,
                // subordinate fulfillment data
                resolveContexts = Array(i),
                resolveValues = slice.call(arguments),
                // the primary Deferred
                primary = jQuery.Deferred(),
                // subordinate callback factory
                updateFunc = function (i) {
                  return function (value) {
                    resolveContexts[i] = this
                    resolveValues[i] =
                      arguments.length > 1 ? slice.call(arguments) : value
                    if (!--remaining) {
                      primary.resolveWith(resolveContexts, resolveValues)
                    }
                  }
                }

              // Single- and empty arguments are adopted like Promise.resolve
              if (remaining <= 1) {
                adoptValue(
                  singleValue,
                  primary.done(updateFunc(i)).resolve,
                  primary.reject,
                  !remaining
                )

                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (
                  primary.state() === 'pending' ||
                  isFunction(resolveValues[i] && resolveValues[i].then)
                ) {
                  return primary.then()
                }
              }

              // Multiple arguments are aggregated like Promise.all array elements
              while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), primary.reject)
              }

              return primary.promise()
            }
          })

          // These usually indicate a programmer mistake during development,
          // warn about them ASAP rather than swallowing them by default.
          var rerrorNames =
            /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/

          // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
          // captured before the async barrier to get the original error cause
          // which may otherwise be hidden.
          jQuery.Deferred.exceptionHook = function (error, asyncError) {
            // Support: IE 8 - 9 only
            // Console exists when dev tools are open, which can happen at any time
            if (
              window.console &&
              window.console.warn &&
              error &&
              rerrorNames.test(error.name)
            ) {
              window.console.warn(
                'jQuery.Deferred exception: ' + error.message,
                error.stack,
                asyncError
              )
            }
          }

          jQuery.readyException = function (error) {
            window.setTimeout(function () {
              throw error
            })
          }

          // The deferred used on DOM ready
          var readyList = jQuery.Deferred()

          jQuery.fn.ready = function (fn) {
            readyList
              .then(fn)

              // Wrap jQuery.readyException in a function so that the lookup
              // happens at the time of error handling instead of callback
              // registration.
              .catch(function (error) {
                jQuery.readyException(error)
              })

            return this
          }

          jQuery.extend({
            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See trac-6781
            readyWait: 1,

            // Handle when the DOM is ready
            ready: function (wait) {
              // Abort if there are pending holds or we're already ready
              if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return
              }

              // Remember that the DOM is ready
              jQuery.isReady = true

              // If a normal DOM Ready event fired, decrement, and wait if need be
              if (wait !== true && --jQuery.readyWait > 0) {
                return
              }

              // If there are functions bound, to execute
              readyList.resolveWith(document, [jQuery])
            }
          })

          jQuery.ready.then = readyList.then

          // The ready event handler and self cleanup method
          function completed() {
            document.removeEventListener('DOMContentLoaded', completed)
            window.removeEventListener('load', completed)
            jQuery.ready()
          }

          // Catch cases where $(document).ready() is called
          // after the browser event has already occurred.
          // Support: IE <=9 - 10 only
          // Older IE sometimes signals "interactive" too soon
          if (
            document.readyState === 'complete' ||
            (document.readyState !== 'loading' &&
              !document.documentElement.doScroll)
          ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            window.setTimeout(jQuery.ready)
          } else {
            // Use the handy event callback
            document.addEventListener('DOMContentLoaded', completed)

            // A fallback to window.onload, that will always work
            window.addEventListener('load', completed)
          }

          // Multifunctional method to get and set values of a collection
          // The value/s can optionally be executed if it's a function
          var access = function (
            elems,
            fn,
            key,
            value,
            chainable,
            emptyGet,
            raw
          ) {
            var i = 0,
              len = elems.length,
              bulk = key == null

            // Sets many values
            if (toType(key) === 'object') {
              chainable = true
              for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw)
              }

              // Sets one value
            } else if (value !== undefined) {
              chainable = true

              if (!isFunction(value)) {
                raw = true
              }

              if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                  fn.call(elems, value)
                  fn = null

                  // ...except when executing function values
                } else {
                  bulk = fn
                  fn = function (elem, _key, value) {
                    return bulk.call(jQuery(elem), value)
                  }
                }
              }

              if (fn) {
                for (; i < len; i++) {
                  fn(
                    elems[i],
                    key,
                    raw ? value : value.call(elems[i], i, fn(elems[i], key))
                  )
                }
              }
            }

            if (chainable) {
              return elems
            }

            // Gets
            if (bulk) {
              return fn.call(elems)
            }

            return len ? fn(elems[0], key) : emptyGet
          }

          // Matches dashed string for camelizing
          var rmsPrefix = /^-ms-/,
            rdashAlpha = /-([a-z])/g

          // Used by camelCase as callback to replace()
          function fcamelCase(_all, letter) {
            return letter.toUpperCase()
          }

          // Convert dashed to camelCase; used by the css and data modules
          // Support: IE <=9 - 11, Edge 12 - 15
          // Microsoft forgot to hump their vendor prefix (trac-9572)
          function camelCase(string) {
            return string
              .replace(rmsPrefix, 'ms-')
              .replace(rdashAlpha, fcamelCase)
          }
          var acceptData = function (owner) {
            // Accepts only:
            //  - Node
            //    - Node.ELEMENT_NODE
            //    - Node.DOCUMENT_NODE
            //  - Object
            //    - Any
            return (
              owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType
            )
          }

          function Data() {
            this.expando = jQuery.expando + Data.uid++
          }

          Data.uid = 1

          Data.prototype = {
            cache: function (owner) {
              // Check if the owner object already has a cache
              var value = owner[this.expando]

              // If not, create one
              if (!value) {
                value = {}

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see trac-8335.
                // Always return an empty object.
                if (acceptData(owner)) {
                  // If it is a node unlikely to be stringify-ed or looped over
                  // use plain assignment
                  if (owner.nodeType) {
                    owner[this.expando] = value

                    // Otherwise secure it in a non-enumerable property
                    // configurable must be true to allow the property to be
                    // deleted when data is removed
                  } else {
                    Object.defineProperty(owner, this.expando, {
                      value: value,
                      configurable: true
                    })
                  }
                }
              }

              return value
            },
            set: function (owner, data, value) {
              var prop,
                cache = this.cache(owner)

              // Handle: [ owner, key, value ] args
              // Always use camelCase key (gh-2257)
              if (typeof data === 'string') {
                cache[camelCase(data)] = value

                // Handle: [ owner, { properties } ] args
              } else {
                // Copy the properties one-by-one to the cache object
                for (prop in data) {
                  cache[camelCase(prop)] = data[prop]
                }
              }
              return cache
            },
            get: function (owner, key) {
              return key === undefined
                ? this.cache(owner)
                : // Always use camelCase key (gh-2257)
                  owner[this.expando] && owner[this.expando][camelCase(key)]
            },
            access: function (owner, key, value) {
              // In cases where either:
              //
              //   1. No key was specified
              //   2. A string key was specified, but no value provided
              //
              // Take the "read" path and allow the get method to determine
              // which value to return, respectively either:
              //
              //   1. The entire cache object
              //   2. The data stored at the key
              //
              if (
                key === undefined ||
                (key && typeof key === 'string' && value === undefined)
              ) {
                return this.get(owner, key)
              }

              // When the key is not a string, or both a key and value
              // are specified, set or extend (existing objects) with either:
              //
              //   1. An object of properties
              //   2. A key and value
              //
              this.set(owner, key, value)

              // Since the "set" path can have two possible entry points
              // return the expected data based on which path was taken[*]
              return value !== undefined ? value : key
            },
            remove: function (owner, key) {
              var i,
                cache = owner[this.expando]

              if (cache === undefined) {
                return
              }

              if (key !== undefined) {
                // Support array or space separated string of keys
                if (Array.isArray(key)) {
                  // If key is an array of keys...
                  // We always set camelCase keys, so remove that.
                  key = key.map(camelCase)
                } else {
                  key = camelCase(key)

                  // If a key with the spaces exists, use it.
                  // Otherwise, create an array by matching non-whitespace
                  key = key in cache ? [key] : key.match(rnothtmlwhite) || []
                }

                i = key.length

                while (i--) {
                  delete cache[key[i]]
                }
              }

              // Remove the expando if there's no more data
              if (key === undefined || jQuery.isEmptyObject(cache)) {
                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) {
                  owner[this.expando] = undefined
                } else {
                  delete owner[this.expando]
                }
              }
            },
            hasData: function (owner) {
              var cache = owner[this.expando]
              return cache !== undefined && !jQuery.isEmptyObject(cache)
            }
          }
          var dataPriv = new Data()

          var dataUser = new Data()

          //	Implementation Summary
          //
          //	1. Enforce API surface and semantic compatibility with 1.9.x branch
          //	2. Improve the module's maintainability by reducing the storage
          //		paths to a single mechanism.
          //	3. Use the same single mechanism to support "private" and "user" data.
          //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
          //	5. Avoid exposing implementation details on user objects (eg. expando properties)
          //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

          var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /[A-Z]/g

          function getData(data) {
            if (data === 'true') {
              return true
            }

            if (data === 'false') {
              return false
            }

            if (data === 'null') {
              return null
            }

            // Only convert to a number if it doesn't change the string
            if (data === +data + '') {
              return +data
            }

            if (rbrace.test(data)) {
              return JSON.parse(data)
            }

            return data
          }

          function dataAttr(elem, key, data) {
            var name

            // If nothing was found internally, try to fetch any
            // data from the HTML5 data-* attribute
            if (data === undefined && elem.nodeType === 1) {
              name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase()
              data = elem.getAttribute(name)

              if (typeof data === 'string') {
                try {
                  data = getData(data)
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data)
              } else {
                data = undefined
              }
            }
            return data
          }

          jQuery.extend({
            hasData: function (elem) {
              return dataUser.hasData(elem) || dataPriv.hasData(elem)
            },

            data: function (elem, name, data) {
              return dataUser.access(elem, name, data)
            },

            removeData: function (elem, name) {
              dataUser.remove(elem, name)
            },

            // TODO: Now that all calls to _data and _removeData have been replaced
            // with direct calls to dataPriv methods, these can be deprecated.
            _data: function (elem, name, data) {
              return dataPriv.access(elem, name, data)
            },

            _removeData: function (elem, name) {
              dataPriv.remove(elem, name)
            }
          })

          jQuery.fn.extend({
            data: function (key, value) {
              var i,
                name,
                data,
                elem = this[0],
                attrs = elem && elem.attributes

              // Gets all values
              if (key === undefined) {
                if (this.length) {
                  data = dataUser.get(elem)

                  if (
                    elem.nodeType === 1 &&
                    !dataPriv.get(elem, 'hasDataAttrs')
                  ) {
                    i = attrs.length
                    while (i--) {
                      // Support: IE 11 only
                      // The attrs elements can be null (trac-14894)
                      if (attrs[i]) {
                        name = attrs[i].name
                        if (name.indexOf('data-') === 0) {
                          name = camelCase(name.slice(5))
                          dataAttr(elem, name, data[name])
                        }
                      }
                    }
                    dataPriv.set(elem, 'hasDataAttrs', true)
                  }
                }

                return data
              }

              // Sets multiple values
              if (typeof key === 'object') {
                return this.each(function () {
                  dataUser.set(this, key)
                })
              }

              return access(
                this,
                function (value) {
                  var data

                  // The calling jQuery object (element matches) is not empty
                  // (and therefore has an element appears at this[ 0 ]) and the
                  // `value` parameter was not undefined. An empty jQuery object
                  // will result in `undefined` for elem = this[ 0 ] which will
                  // throw an exception if an attempt to read a data cache is made.
                  if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key)
                    if (data !== undefined) {
                      return data
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key)
                    if (data !== undefined) {
                      return data
                    }

                    // We tried really hard, but the data doesn't exist.
                    return
                  }

                  // Set the data...
                  this.each(function () {
                    // We always store the camelCased key
                    dataUser.set(this, key, value)
                  })
                },
                null,
                value,
                arguments.length > 1,
                null,
                true
              )
            },

            removeData: function (key) {
              return this.each(function () {
                dataUser.remove(this, key)
              })
            }
          })

          jQuery.extend({
            queue: function (elem, type, data) {
              var queue

              if (elem) {
                type = (type || 'fx') + 'queue'
                queue = dataPriv.get(elem, type)

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                  if (!queue || Array.isArray(data)) {
                    queue = dataPriv.access(elem, type, jQuery.makeArray(data))
                  } else {
                    queue.push(data)
                  }
                }
                return queue || []
              }
            },

            dequeue: function (elem, type) {
              type = type || 'fx'

              var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function () {
                  jQuery.dequeue(elem, type)
                }

              // If the fx queue is dequeued, always remove the progress sentinel
              if (fn === 'inprogress') {
                fn = queue.shift()
                startLength--
              }

              if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === 'fx') {
                  queue.unshift('inprogress')
                }

                // Clear up the last queue stop function
                delete hooks.stop
                fn.call(elem, next, hooks)
              }

              if (!startLength && hooks) {
                hooks.empty.fire()
              }
            },

            // Not public - generate a queueHooks object, or return the current one
            _queueHooks: function (elem, type) {
              var key = type + 'queueHooks'
              return (
                dataPriv.get(elem, key) ||
                dataPriv.access(elem, key, {
                  empty: jQuery.Callbacks('once memory').add(function () {
                    dataPriv.remove(elem, [type + 'queue', key])
                  })
                })
              )
            }
          })

          jQuery.fn.extend({
            queue: function (type, data) {
              var setter = 2

              if (typeof type !== 'string') {
                data = type
                type = 'fx'
                setter--
              }

              if (arguments.length < setter) {
                return jQuery.queue(this[0], type)
              }

              return data === undefined
                ? this
                : this.each(function () {
                    var queue = jQuery.queue(this, type, data)

                    // Ensure a hooks for this queue
                    jQuery._queueHooks(this, type)

                    if (type === 'fx' && queue[0] !== 'inprogress') {
                      jQuery.dequeue(this, type)
                    }
                  })
            },
            dequeue: function (type) {
              return this.each(function () {
                jQuery.dequeue(this, type)
              })
            },
            clearQueue: function (type) {
              return this.queue(type || 'fx', [])
            },

            // Get a promise resolved when queues of a certain type
            // are emptied (fx is the type by default)
            promise: function (type, obj) {
              var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function () {
                  if (!--count) {
                    defer.resolveWith(elements, [elements])
                  }
                }

              if (typeof type !== 'string') {
                obj = type
                type = undefined
              }
              type = type || 'fx'

              while (i--) {
                tmp = dataPriv.get(elements[i], type + 'queueHooks')
                if (tmp && tmp.empty) {
                  count++
                  tmp.empty.add(resolve)
                }
              }
              resolve()
              return defer.promise(obj)
            }
          })
          var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source

          var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i')

          var cssExpand = ['Top', 'Right', 'Bottom', 'Left']

          var documentElement = document.documentElement

          var isAttached = function (elem) {
              return jQuery.contains(elem.ownerDocument, elem)
            },
            composed = { composed: true }

          // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
          // Check attachment across shadow DOM boundaries when possible (gh-3504)
          // Support: iOS 10.0-10.2 only
          // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
          // leading to errors. We need to check for `getRootNode`.
          if (documentElement.getRootNode) {
            isAttached = function (elem) {
              return (
                jQuery.contains(elem.ownerDocument, elem) ||
                elem.getRootNode(composed) === elem.ownerDocument
              )
            }
          }
          var isHiddenWithinTree = function (elem, el) {
            // isHiddenWithinTree might be called from jQuery#filter function;
            // in that case, element will be second argument
            elem = el || elem

            // Inline style trumps all
            return (
              elem.style.display === 'none' ||
              (elem.style.display === '' &&
                // Otherwise, check computed style
                // Support: Firefox <=43 - 45
                // Disconnected elements can have computed display: none, so first confirm that elem is
                // in the document.
                isAttached(elem) &&
                jQuery.css(elem, 'display') === 'none')
            )
          }

          function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted,
              scale,
              maxIterations = 20,
              currentValue = tween
                ? function () {
                    return tween.cur()
                  }
                : function () {
                    return jQuery.css(elem, prop, '')
                  },
              initial = currentValue(),
              unit =
                (valueParts && valueParts[3]) ||
                (jQuery.cssNumber[prop] ? '' : 'px'),
              // Starting value computation is required for potential unit mismatches
              initialInUnit =
                elem.nodeType &&
                (jQuery.cssNumber[prop] || (unit !== 'px' && +initial)) &&
                rcssNum.exec(jQuery.css(elem, prop))

            if (initialInUnit && initialInUnit[3] !== unit) {
              // Support: Firefox <=54
              // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
              initial = initial / 2

              // Trust units reported by jQuery.css
              unit = unit || initialInUnit[3]

              // Iteratively approximate from a nonzero starting point
              initialInUnit = +initial || 1

              while (maxIterations--) {
                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit)
                if (
                  (1 - scale) *
                    (1 - (scale = currentValue() / initial || 0.5)) <=
                  0
                ) {
                  maxIterations = 0
                }
                initialInUnit = initialInUnit / scale
              }

              initialInUnit = initialInUnit * 2
              jQuery.style(elem, prop, initialInUnit + unit)

              // Make sure we update the tween properties later on
              valueParts = valueParts || []
            }

            if (valueParts) {
              initialInUnit = +initialInUnit || +initial || 0

              // Apply relative offset (+=/-=) if specified
              adjusted = valueParts[1]
                ? initialInUnit + (valueParts[1] + 1) * valueParts[2]
                : +valueParts[2]
              if (tween) {
                tween.unit = unit
                tween.start = initialInUnit
                tween.end = adjusted
              }
            }
            return adjusted
          }

          var defaultDisplayMap = {}

          function getDefaultDisplay(elem) {
            var temp,
              doc = elem.ownerDocument,
              nodeName = elem.nodeName,
              display = defaultDisplayMap[nodeName]

            if (display) {
              return display
            }

            temp = doc.body.appendChild(doc.createElement(nodeName))
            display = jQuery.css(temp, 'display')

            temp.parentNode.removeChild(temp)

            if (display === 'none') {
              display = 'block'
            }
            defaultDisplayMap[nodeName] = display

            return display
          }

          function showHide(elements, show) {
            var display,
              elem,
              values = [],
              index = 0,
              length = elements.length

            // Determine new display value for elements that need to change
            for (; index < length; index++) {
              elem = elements[index]
              if (!elem.style) {
                continue
              }

              display = elem.style.display
              if (show) {
                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === 'none') {
                  values[index] = dataPriv.get(elem, 'display') || null
                  if (!values[index]) {
                    elem.style.display = ''
                  }
                }
                if (elem.style.display === '' && isHiddenWithinTree(elem)) {
                  values[index] = getDefaultDisplay(elem)
                }
              } else {
                if (display !== 'none') {
                  values[index] = 'none'

                  // Remember what we're overwriting
                  dataPriv.set(elem, 'display', display)
                }
              }
            }

            // Set the display of the elements in a second loop to avoid constant reflow
            for (index = 0; index < length; index++) {
              if (values[index] != null) {
                elements[index].style.display = values[index]
              }
            }

            return elements
          }

          jQuery.fn.extend({
            show: function () {
              return showHide(this, true)
            },
            hide: function () {
              return showHide(this)
            },
            toggle: function (state) {
              if (typeof state === 'boolean') {
                return state ? this.show() : this.hide()
              }

              return this.each(function () {
                if (isHiddenWithinTree(this)) {
                  jQuery(this).show()
                } else {
                  jQuery(this).hide()
                }
              })
            }
          })
          var rcheckableType = /^(?:checkbox|radio)$/i

          var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i

          var rscriptType = /^$|^module$|\/(?:java|ecma)script/i

          ;(function () {
            var fragment = document.createDocumentFragment(),
              div = fragment.appendChild(document.createElement('div')),
              input = document.createElement('input')

            // Support: Android 4.0 - 4.3 only
            // Check state lost if the name is set (trac-11217)
            // Support: Windows Web Apps (WWA)
            // `name` and `type` must use .setAttribute for WWA (trac-14901)
            input.setAttribute('type', 'radio')
            input.setAttribute('checked', 'checked')
            input.setAttribute('name', 't')

            div.appendChild(input)

            // Support: Android <=4.1 only
            // Older WebKit doesn't clone checked state correctly in fragments
            support.checkClone = div
              .cloneNode(true)
              .cloneNode(true).lastChild.checked

            // Support: IE <=11 only
            // Make sure textarea (and checkbox) defaultValue is properly cloned
            div.innerHTML = '<textarea>x</textarea>'
            support.noCloneChecked =
              !!div.cloneNode(true).lastChild.defaultValue

            // Support: IE <=9 only
            // IE <=9 replaces <option> tags with their contents when inserted outside of
            // the select element.
            div.innerHTML = '<option></option>'
            support.option = !!div.lastChild
          })()

          // We have to close these tags to support XHTML (trac-13200)
          var wrapMap = {
            // XHTML parsers do not magically insert elements in the
            // same way that tag soup parsers do. So we cannot shorten
            // this by omitting <tbody> or other required elements.
            thead: [1, '<table>', '</table>'],
            col: [2, '<table><colgroup>', '</colgroup></table>'],
            tr: [2, '<table><tbody>', '</tbody></table>'],
            td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],

            _default: [0, '', '']
          }

          wrapMap.tbody =
            wrapMap.tfoot =
            wrapMap.colgroup =
            wrapMap.caption =
              wrapMap.thead
          wrapMap.th = wrapMap.td

          // Support: IE <=9 only
          if (!support.option) {
            wrapMap.optgroup = wrapMap.option = [
              1,
              "<select multiple='multiple'>",
              '</select>'
            ]
          }

          function getAll(context, tag) {
            // Support: IE <=9 - 11 only
            // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
            var ret

            if (typeof context.getElementsByTagName !== 'undefined') {
              ret = context.getElementsByTagName(tag || '*')
            } else if (typeof context.querySelectorAll !== 'undefined') {
              ret = context.querySelectorAll(tag || '*')
            } else {
              ret = []
            }

            if (tag === undefined || (tag && nodeName(context, tag))) {
              return jQuery.merge([context], ret)
            }

            return ret
          }

          // Mark scripts as having already been evaluated
          function setGlobalEval(elems, refElements) {
            var i = 0,
              l = elems.length

            for (; i < l; i++) {
              dataPriv.set(
                elems[i],
                'globalEval',
                !refElements || dataPriv.get(refElements[i], 'globalEval')
              )
            }
          }

          var rhtml = /<|&#?\w+;/

          function buildFragment(elems, context, scripts, selection, ignored) {
            var elem,
              tmp,
              tag,
              wrap,
              attached,
              j,
              fragment = context.createDocumentFragment(),
              nodes = [],
              i = 0,
              l = elems.length

            for (; i < l; i++) {
              elem = elems[i]

              if (elem || elem === 0) {
                // Add nodes directly
                if (toType(elem) === 'object') {
                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // push.apply(_, arraylike) throws on ancient WebKit
                  jQuery.merge(nodes, elem.nodeType ? [elem] : elem)

                  // Convert non-html into a text node
                } else if (!rhtml.test(elem)) {
                  nodes.push(context.createTextNode(elem))

                  // Convert html into DOM nodes
                } else {
                  tmp =
                    tmp || fragment.appendChild(context.createElement('div'))

                  // Deserialize a standard representation
                  tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase()
                  wrap = wrapMap[tag] || wrapMap._default
                  tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]

                  // Descend through wrappers to the right content
                  j = wrap[0]
                  while (j--) {
                    tmp = tmp.lastChild
                  }

                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // push.apply(_, arraylike) throws on ancient WebKit
                  jQuery.merge(nodes, tmp.childNodes)

                  // Remember the top-level container
                  tmp = fragment.firstChild

                  // Ensure the created nodes are orphaned (trac-12392)
                  tmp.textContent = ''
                }
              }
            }

            // Remove wrapper from fragment
            fragment.textContent = ''

            i = 0
            while ((elem = nodes[i++])) {
              // Skip elements already in the context collection (trac-4087)
              if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                  ignored.push(elem)
                }
                continue
              }

              attached = isAttached(elem)

              // Append to fragment
              tmp = getAll(fragment.appendChild(elem), 'script')

              // Preserve script evaluation history
              if (attached) {
                setGlobalEval(tmp)
              }

              // Capture executables
              if (scripts) {
                j = 0
                while ((elem = tmp[j++])) {
                  if (rscriptType.test(elem.type || '')) {
                    scripts.push(elem)
                  }
                }
              }
            }

            return fragment
          }

          var rtypenamespace = /^([^.]*)(?:\.(.+)|)/

          function returnTrue() {
            return true
          }

          function returnFalse() {
            return false
          }

          function on(elem, types, selector, data, fn, one) {
            var origFn, type

            // Types can be a map of types/handlers
            if (typeof types === 'object') {
              // ( types-Object, selector, data )
              if (typeof selector !== 'string') {
                // ( types-Object, data )
                data = data || selector
                selector = undefined
              }
              for (type in types) {
                on(elem, type, selector, data, types[type], one)
              }
              return elem
            }

            if (data == null && fn == null) {
              // ( types, fn )
              fn = selector
              data = selector = undefined
            } else if (fn == null) {
              if (typeof selector === 'string') {
                // ( types, selector, fn )
                fn = data
                data = undefined
              } else {
                // ( types, data, fn )
                fn = data
                data = selector
                selector = undefined
              }
            }
            if (fn === false) {
              fn = returnFalse
            } else if (!fn) {
              return elem
            }

            if (one === 1) {
              origFn = fn
              fn = function (event) {
                // Can use an empty set, since event contains the info
                jQuery().off(event)
                return origFn.apply(this, arguments)
              }

              // Use same guid so caller can remove using origFn
              fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
            }
            return elem.each(function () {
              jQuery.event.add(this, types, fn, data, selector)
            })
          }

          /*
           * Helper functions for managing events -- not part of the public interface.
           * Props to Dean Edwards' addEvent library for many of the ideas.
           */
          jQuery.event = {
            global: {},

            add: function (elem, types, handler, data, selector) {
              var handleObjIn,
                eventHandle,
                tmp,
                events,
                t,
                handleObj,
                special,
                handlers,
                type,
                namespaces,
                origType,
                elemData = dataPriv.get(elem)

              // Only attach events to objects that accept data
              if (!acceptData(elem)) {
                return
              }

              // Caller can pass in an object of custom data in lieu of the handler
              if (handler.handler) {
                handleObjIn = handler
                handler = handleObjIn.handler
                selector = handleObjIn.selector
              }

              // Ensure that invalid selectors throw exceptions at attach time
              // Evaluate against documentElement in case elem is a non-element node (e.g., document)
              if (selector) {
                jQuery.find.matchesSelector(documentElement, selector)
              }

              // Make sure that the handler has a unique ID, used to find/remove it later
              if (!handler.guid) {
                handler.guid = jQuery.guid++
              }

              // Init the element's event structure and main handler, if this is the first
              if (!(events = elemData.events)) {
                events = elemData.events = Object.create(null)
              }
              if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                  // Discard the second event of a jQuery.event.trigger() and
                  // when an event is called after a page has unloaded
                  return typeof jQuery !== 'undefined' &&
                    jQuery.event.triggered !== e.type
                    ? jQuery.event.dispatch.apply(elem, arguments)
                    : undefined
                }
              }

              // Handle multiple events separated by a space
              types = (types || '').match(rnothtmlwhite) || ['']
              t = types.length
              while (t--) {
                tmp = rtypenamespace.exec(types[t]) || []
                type = origType = tmp[1]
                namespaces = (tmp[2] || '').split('.').sort()

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                  continue
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {}

                // If selector defined, determine special event api type, otherwise given type
                type =
                  (selector ? special.delegateType : special.bindType) || type

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {}

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend(
                  {
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext:
                      selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                  },
                  handleObjIn
                )

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                  handlers = events[type] = []
                  handlers.delegateCount = 0

                  // Only use addEventListener if the special events handler returns false
                  if (
                    !special.setup ||
                    special.setup.call(elem, data, namespaces, eventHandle) ===
                      false
                  ) {
                    if (elem.addEventListener) {
                      elem.addEventListener(type, eventHandle)
                    }
                  }
                }

                if (special.add) {
                  special.add.call(elem, handleObj)

                  if (!handleObj.handler.guid) {
                    handleObj.handler.guid = handler.guid
                  }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                  handlers.splice(handlers.delegateCount++, 0, handleObj)
                } else {
                  handlers.push(handleObj)
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true
              }
            },

            // Detach an event or set of events from an element
            remove: function (elem, types, handler, selector, mappedTypes) {
              var j,
                origCount,
                tmp,
                events,
                t,
                handleObj,
                special,
                handlers,
                type,
                namespaces,
                origType,
                elemData = dataPriv.hasData(elem) && dataPriv.get(elem)

              if (!elemData || !(events = elemData.events)) {
                return
              }

              // Once for each type.namespace in types; type may be omitted
              types = (types || '').match(rnothtmlwhite) || ['']
              t = types.length
              while (t--) {
                tmp = rtypenamespace.exec(types[t]) || []
                type = origType = tmp[1]
                namespaces = (tmp[2] || '').split('.').sort()

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                  for (type in events) {
                    jQuery.event.remove(
                      elem,
                      type + types[t],
                      handler,
                      selector,
                      true
                    )
                  }
                  continue
                }

                special = jQuery.event.special[type] || {}
                type =
                  (selector ? special.delegateType : special.bindType) || type
                handlers = events[type] || []
                tmp =
                  tmp[2] &&
                  new RegExp(
                    '(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)'
                  )

                // Remove matching events
                origCount = j = handlers.length
                while (j--) {
                  handleObj = handlers[j]

                  if (
                    (mappedTypes || origType === handleObj.origType) &&
                    (!handler || handler.guid === handleObj.guid) &&
                    (!tmp || tmp.test(handleObj.namespace)) &&
                    (!selector ||
                      selector === handleObj.selector ||
                      (selector === '**' && handleObj.selector))
                  ) {
                    handlers.splice(j, 1)

                    if (handleObj.selector) {
                      handlers.delegateCount--
                    }
                    if (special.remove) {
                      special.remove.call(elem, handleObj)
                    }
                  }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                  if (
                    !special.teardown ||
                    special.teardown.call(elem, namespaces, elemData.handle) ===
                      false
                  ) {
                    jQuery.removeEvent(elem, type, elemData.handle)
                  }

                  delete events[type]
                }
              }

              // Remove data and the expando if it's no longer used
              if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, 'handle events')
              }
            },

            dispatch: function (nativeEvent) {
              var i,
                j,
                ret,
                matched,
                handleObj,
                handlerQueue,
                args = new Array(arguments.length),
                // Make a writable jQuery.Event from the native event object
                event = jQuery.event.fix(nativeEvent),
                handlers =
                  (dataPriv.get(this, 'events') || Object.create(null))[
                    event.type
                  ] || [],
                special = jQuery.event.special[event.type] || {}

              // Use the fix-ed jQuery.Event rather than the (read-only) native event
              args[0] = event

              for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i]
              }

              event.delegateTarget = this

              // Call the preDispatch hook for the mapped type, and let it bail if desired
              if (
                special.preDispatch &&
                special.preDispatch.call(this, event) === false
              ) {
                return
              }

              // Determine handlers
              handlerQueue = jQuery.event.handlers.call(this, event, handlers)

              // Run delegates first; they may want to stop propagation beneath us
              i = 0
              while (
                (matched = handlerQueue[i++]) &&
                !event.isPropagationStopped()
              ) {
                event.currentTarget = matched.elem

                j = 0
                while (
                  (handleObj = matched.handlers[j++]) &&
                  !event.isImmediatePropagationStopped()
                ) {
                  // If the event is namespaced, then each handler is only invoked if it is
                  // specially universal or its namespaces are a superset of the event's.
                  if (
                    !event.rnamespace ||
                    handleObj.namespace === false ||
                    event.rnamespace.test(handleObj.namespace)
                  ) {
                    event.handleObj = handleObj
                    event.data = handleObj.data

                    ret = (
                      (jQuery.event.special[handleObj.origType] || {}).handle ||
                      handleObj.handler
                    ).apply(matched.elem, args)

                    if (ret !== undefined) {
                      if ((event.result = ret) === false) {
                        event.preventDefault()
                        event.stopPropagation()
                      }
                    }
                  }
                }
              }

              // Call the postDispatch hook for the mapped type
              if (special.postDispatch) {
                special.postDispatch.call(this, event)
              }

              return event.result
            },

            handlers: function (event, handlers) {
              var i,
                handleObj,
                sel,
                matchedHandlers,
                matchedSelectors,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target

              // Find delegate handlers
              if (
                delegateCount &&
                // Support: IE <=9
                // Black-hole SVG <use> instance trees (trac-13180)
                cur.nodeType &&
                // Support: Firefox <=42
                // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                // Support: IE 11 only
                // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                !(event.type === 'click' && event.button >= 1)
              ) {
                for (; cur !== this; cur = cur.parentNode || this) {
                  // Don't check non-elements (trac-13208)
                  // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
                  if (
                    cur.nodeType === 1 &&
                    !(event.type === 'click' && cur.disabled === true)
                  ) {
                    matchedHandlers = []
                    matchedSelectors = {}
                    for (i = 0; i < delegateCount; i++) {
                      handleObj = handlers[i]

                      // Don't conflict with Object.prototype properties (trac-13203)
                      sel = handleObj.selector + ' '

                      if (matchedSelectors[sel] === undefined) {
                        matchedSelectors[sel] = handleObj.needsContext
                          ? jQuery(sel, this).index(cur) > -1
                          : jQuery.find(sel, this, null, [cur]).length
                      }
                      if (matchedSelectors[sel]) {
                        matchedHandlers.push(handleObj)
                      }
                    }
                    if (matchedHandlers.length) {
                      handlerQueue.push({
                        elem: cur,
                        handlers: matchedHandlers
                      })
                    }
                  }
                }
              }

              // Add the remaining (directly-bound) handlers
              cur = this
              if (delegateCount < handlers.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: handlers.slice(delegateCount)
                })
              }

              return handlerQueue
            },

            addProp: function (name, hook) {
              Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,

                get: isFunction(hook)
                  ? function () {
                      if (this.originalEvent) {
                        return hook(this.originalEvent)
                      }
                    }
                  : function () {
                      if (this.originalEvent) {
                        return this.originalEvent[name]
                      }
                    },

                set: function (value) {
                  Object.defineProperty(this, name, {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: value
                  })
                }
              })
            },

            fix: function (originalEvent) {
              return originalEvent[jQuery.expando]
                ? originalEvent
                : new jQuery.Event(originalEvent)
            },

            special: {
              load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
              },
              click: {
                // Utilize native event to ensure correct state for checkable inputs
                setup: function (data) {
                  // For mutual compressibility with _default, replace `this` access with a local var.
                  // `|| data` is dead code meant only to preserve the variable through minification.
                  var el = this || data

                  // Claim the first handler
                  if (
                    rcheckableType.test(el.type) &&
                    el.click &&
                    nodeName(el, 'input')
                  ) {
                    // dataPriv.set( el, "click", ... )
                    leverageNative(el, 'click', true)
                  }

                  // Return false to allow normal processing in the caller
                  return false
                },
                trigger: function (data) {
                  // For mutual compressibility with _default, replace `this` access with a local var.
                  // `|| data` is dead code meant only to preserve the variable through minification.
                  var el = this || data

                  // Force setup before triggering a click
                  if (
                    rcheckableType.test(el.type) &&
                    el.click &&
                    nodeName(el, 'input')
                  ) {
                    leverageNative(el, 'click')
                  }

                  // Return non-false to allow normal event-path propagation
                  return true
                },

                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function (event) {
                  var target = event.target
                  return (
                    (rcheckableType.test(target.type) &&
                      target.click &&
                      nodeName(target, 'input') &&
                      dataPriv.get(target, 'click')) ||
                    nodeName(target, 'a')
                  )
                }
              },

              beforeunload: {
                postDispatch: function (event) {
                  // Support: Firefox 20+
                  // Firefox doesn't alert if the returnValue field is not set.
                  if (event.result !== undefined && event.originalEvent) {
                    event.originalEvent.returnValue = event.result
                  }
                }
              }
            }
          }

          // Ensure the presence of an event listener that handles manually-triggered
          // synthetic events by interrupting progress until reinvoked in response to
          // *native* events that it fires directly, ensuring that state changes have
          // already occurred before other listeners are invoked.
          function leverageNative(el, type, isSetup) {
            // Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
            if (!isSetup) {
              if (dataPriv.get(el, type) === undefined) {
                jQuery.event.add(el, type, returnTrue)
              }
              return
            }

            // Register the controller as a special universal handler for all event namespaces
            dataPriv.set(el, type, false)
            jQuery.event.add(el, type, {
              namespace: false,
              handler: function (event) {
                var result,
                  saved = dataPriv.get(this, type)

                if (event.isTrigger & 1 && this[type]) {
                  // Interrupt processing of the outer synthetic .trigger()ed event
                  if (!saved) {
                    // Store arguments for use when handling the inner native event
                    // There will always be at least one argument (an event object), so this array
                    // will not be confused with a leftover capture object.
                    saved = slice.call(arguments)
                    dataPriv.set(this, type, saved)

                    // Trigger the native event and capture its result
                    this[type]()
                    result = dataPriv.get(this, type)
                    dataPriv.set(this, type, false)

                    if (saved !== result) {
                      // Cancel the outer synthetic event
                      event.stopImmediatePropagation()
                      event.preventDefault()

                      return result
                    }

                    // If this is an inner synthetic event for an event with a bubbling surrogate
                    // (focus or blur), assume that the surrogate already propagated from triggering
                    // the native event and prevent that from happening again here.
                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                    // less bad than duplication.
                  } else if ((jQuery.event.special[type] || {}).delegateType) {
                    event.stopPropagation()
                  }

                  // If this is a native event triggered above, everything is now in order
                  // Fire an inner synthetic event with the original arguments
                } else if (saved) {
                  // ...and capture the result
                  dataPriv.set(
                    this,
                    type,
                    jQuery.event.trigger(saved[0], saved.slice(1), this)
                  )

                  // Abort handling of the native event by all jQuery handlers while allowing
                  // native handlers on the same element to run. On target, this is achieved
                  // by stopping immediate propagation just on the jQuery event. However,
                  // the native event is re-wrapped by a jQuery one on each level of the
                  // propagation so the only way to stop it for jQuery is to stop it for
                  // everyone via native `stopPropagation()`. This is not a problem for
                  // focus/blur which don't bubble, but it does also stop click on checkboxes
                  // and radios. We accept this limitation.
                  event.stopPropagation()
                  event.isImmediatePropagationStopped = returnTrue
                }
              }
            })
          }

          jQuery.removeEvent = function (elem, type, handle) {
            // This "if" is needed for plain objects
            if (elem.removeEventListener) {
              elem.removeEventListener(type, handle)
            }
          }

          jQuery.Event = function (src, props) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof jQuery.Event)) {
              return new jQuery.Event(src, props)
            }

            // Event object
            if (src && src.type) {
              this.originalEvent = src
              this.type = src.type

              // Events bubbling up the document may have been marked as prevented
              // by a handler lower down the tree; reflect the correct value.
              this.isDefaultPrevented =
                src.defaultPrevented ||
                (src.defaultPrevented === undefined &&
                  // Support: Android <=2.3 only
                  src.returnValue === false)
                  ? returnTrue
                  : returnFalse

              // Create target properties
              // Support: Safari <=6 - 7 only
              // Target should not be a text node (trac-504, trac-13143)
              this.target =
                src.target && src.target.nodeType === 3
                  ? src.target.parentNode
                  : src.target

              this.currentTarget = src.currentTarget
              this.relatedTarget = src.relatedTarget

              // Event type
            } else {
              this.type = src
            }

            // Put explicitly provided properties onto the event object
            if (props) {
              jQuery.extend(this, props)
            }

            // Create a timestamp if incoming event doesn't have one
            this.timeStamp = (src && src.timeStamp) || Date.now()

            // Mark it as fixed
            this[jQuery.expando] = true
          }

          // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
          // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
          jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: false,

            preventDefault: function () {
              var e = this.originalEvent

              this.isDefaultPrevented = returnTrue

              if (e && !this.isSimulated) {
                e.preventDefault()
              }
            },
            stopPropagation: function () {
              var e = this.originalEvent

              this.isPropagationStopped = returnTrue

              if (e && !this.isSimulated) {
                e.stopPropagation()
              }
            },
            stopImmediatePropagation: function () {
              var e = this.originalEvent

              this.isImmediatePropagationStopped = returnTrue

              if (e && !this.isSimulated) {
                e.stopImmediatePropagation()
              }

              this.stopPropagation()
            }
          }

          // Includes all common event props including KeyEvent and MouseEvent specific props
          jQuery.each(
            {
              altKey: true,
              bubbles: true,
              cancelable: true,
              changedTouches: true,
              ctrlKey: true,
              detail: true,
              eventPhase: true,
              metaKey: true,
              pageX: true,
              pageY: true,
              shiftKey: true,
              view: true,
              char: true,
              code: true,
              charCode: true,
              key: true,
              keyCode: true,
              button: true,
              buttons: true,
              clientX: true,
              clientY: true,
              offsetX: true,
              offsetY: true,
              pointerId: true,
              pointerType: true,
              screenX: true,
              screenY: true,
              targetTouches: true,
              toElement: true,
              touches: true,
              which: true
            },
            jQuery.event.addProp
          )

          jQuery.each(
            { focus: 'focusin', blur: 'focusout' },
            function (type, delegateType) {
              function focusMappedHandler(nativeEvent) {
                if (document.documentMode) {
                  // Support: IE 11+
                  // Attach a single focusin/focusout handler on the document while someone wants
                  // focus/blur. This is because the former are synchronous in IE while the latter
                  // are async. In other browsers, all those handlers are invoked synchronously.

                  // `handle` from private data would already wrap the event, but we need
                  // to change the `type` here.
                  var handle = dataPriv.get(this, 'handle'),
                    event = jQuery.event.fix(nativeEvent)
                  event.type = nativeEvent.type === 'focusin' ? 'focus' : 'blur'
                  event.isSimulated = true

                  // First, handle focusin/focusout
                  handle(nativeEvent)

                  // ...then, handle focus/blur
                  //
                  // focus/blur don't bubble while focusin/focusout do; simulate the former by only
                  // invoking the handler at the lower level.
                  if (event.target === event.currentTarget) {
                    // The setup part calls `leverageNative`, which, in turn, calls
                    // `jQuery.event.add`, so event handle will already have been set
                    // by this point.
                    handle(event)
                  }
                } else {
                  // For non-IE browsers, attach a single capturing handler on the document
                  // while someone wants focusin/focusout.
                  jQuery.event.simulate(
                    delegateType,
                    nativeEvent.target,
                    jQuery.event.fix(nativeEvent)
                  )
                }
              }

              jQuery.event.special[type] = {
                // Utilize native event if possible so blur/focus sequence is correct
                setup: function () {
                  var attaches

                  // Claim the first handler
                  // dataPriv.set( this, "focus", ... )
                  // dataPriv.set( this, "blur", ... )
                  leverageNative(this, type, true)

                  if (document.documentMode) {
                    // Support: IE 9 - 11+
                    // We use the same native handler for focusin & focus (and focusout & blur)
                    // so we need to coordinate setup & teardown parts between those events.
                    // Use `delegateType` as the key as `type` is already used by `leverageNative`.
                    attaches = dataPriv.get(this, delegateType)
                    if (!attaches) {
                      this.addEventListener(delegateType, focusMappedHandler)
                    }
                    dataPriv.set(this, delegateType, (attaches || 0) + 1)
                  } else {
                    // Return false to allow normal processing in the caller
                    return false
                  }
                },
                trigger: function () {
                  // Force setup before trigger
                  leverageNative(this, type)

                  // Return non-false to allow normal event-path propagation
                  return true
                },

                teardown: function () {
                  var attaches

                  if (document.documentMode) {
                    attaches = dataPriv.get(this, delegateType) - 1
                    if (!attaches) {
                      this.removeEventListener(delegateType, focusMappedHandler)
                      dataPriv.remove(this, delegateType)
                    } else {
                      dataPriv.set(this, delegateType, attaches)
                    }
                  } else {
                    // Return false to indicate standard teardown should be applied
                    return false
                  }
                },

                // Suppress native focus or blur if we're currently inside
                // a leveraged native-event stack
                _default: function (event) {
                  return dataPriv.get(event.target, type)
                },

                delegateType: delegateType
              }

              // Support: Firefox <=44
              // Firefox doesn't have focus(in | out) events
              // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
              //
              // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
              // focus(in | out) events fire after focus & blur events,
              // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
              // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
              //
              // Support: IE 9 - 11+
              // To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
              // attach a single handler for both events in IE.
              jQuery.event.special[delegateType] = {
                setup: function () {
                  // Handle: regular nodes (via `this.ownerDocument`), window
                  // (via `this.document`) & document (via `this`).
                  var doc = this.ownerDocument || this.document || this,
                    dataHolder = document.documentMode ? this : doc,
                    attaches = dataPriv.get(dataHolder, delegateType)

                  // Support: IE 9 - 11+
                  // We use the same native handler for focusin & focus (and focusout & blur)
                  // so we need to coordinate setup & teardown parts between those events.
                  // Use `delegateType` as the key as `type` is already used by `leverageNative`.
                  if (!attaches) {
                    if (document.documentMode) {
                      this.addEventListener(delegateType, focusMappedHandler)
                    } else {
                      doc.addEventListener(type, focusMappedHandler, true)
                    }
                  }
                  dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1)
                },
                teardown: function () {
                  var doc = this.ownerDocument || this.document || this,
                    dataHolder = document.documentMode ? this : doc,
                    attaches = dataPriv.get(dataHolder, delegateType) - 1

                  if (!attaches) {
                    if (document.documentMode) {
                      this.removeEventListener(delegateType, focusMappedHandler)
                    } else {
                      doc.removeEventListener(type, focusMappedHandler, true)
                    }
                    dataPriv.remove(dataHolder, delegateType)
                  } else {
                    dataPriv.set(dataHolder, delegateType, attaches)
                  }
                }
              }
            }
          )

          // Create mouseenter/leave events using mouseover/out and event-time checks
          // so that event delegation works in jQuery.
          // Do the same for pointerenter/pointerleave and pointerover/pointerout
          //
          // Support: Safari 7 only
          // Safari sends mouseenter too often; see:
          // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
          // for the description of the bug (it existed in older Chrome versions as well).
          jQuery.each(
            {
              mouseenter: 'mouseover',
              mouseleave: 'mouseout',
              pointerenter: 'pointerover',
              pointerleave: 'pointerout'
            },
            function (orig, fix) {
              jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,

                handle: function (event) {
                  var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj

                  // For mouseenter/leave call the handler if related is outside the target.
                  // NB: No relatedTarget if the mouse left/entered the browser window
                  if (
                    !related ||
                    (related !== target && !jQuery.contains(target, related))
                  ) {
                    event.type = handleObj.origType
                    ret = handleObj.handler.apply(this, arguments)
                    event.type = fix
                  }
                  return ret
                }
              }
            }
          )

          jQuery.fn.extend({
            on: function (types, selector, data, fn) {
              return on(this, types, selector, data, fn)
            },
            one: function (types, selector, data, fn) {
              return on(this, types, selector, data, fn, 1)
            },
            off: function (types, selector, fn) {
              var handleObj, type
              if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj
                jQuery(types.delegateTarget).off(
                  handleObj.namespace
                    ? handleObj.origType + '.' + handleObj.namespace
                    : handleObj.origType,
                  handleObj.selector,
                  handleObj.handler
                )
                return this
              }
              if (typeof types === 'object') {
                // ( types-object [, selector] )
                for (type in types) {
                  this.off(type, selector, types[type])
                }
                return this
              }
              if (selector === false || typeof selector === 'function') {
                // ( types [, fn] )
                fn = selector
                selector = undefined
              }
              if (fn === false) {
                fn = returnFalse
              }
              return this.each(function () {
                jQuery.event.remove(this, types, fn, selector)
              })
            }
          })

          var // Support: IE <=10 - 11, Edge 12 - 13 only
            // In IE/Edge using regex groups here causes severe slowdowns.
            // See https://connect.microsoft.com/IE/feedback/details/1736512/
            rnoInnerhtml = /<script|<style|<link/i,
            // checked="checked" or checked
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g

          // Prefer a tbody over its parent table for containing new rows
          function manipulationTarget(elem, content) {
            if (
              nodeName(elem, 'table') &&
              nodeName(
                content.nodeType !== 11 ? content : content.firstChild,
                'tr'
              )
            ) {
              return jQuery(elem).children('tbody')[0] || elem
            }

            return elem
          }

          // Replace/restore the type attribute of script elements for safe DOM manipulation
          function disableScript(elem) {
            elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type
            return elem
          }
          function restoreScript(elem) {
            if ((elem.type || '').slice(0, 5) === 'true/') {
              elem.type = elem.type.slice(5)
            } else {
              elem.removeAttribute('type')
            }

            return elem
          }

          function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, udataOld, udataCur, events

            if (dest.nodeType !== 1) {
              return
            }

            // 1. Copy private data: events, handlers, etc.
            if (dataPriv.hasData(src)) {
              pdataOld = dataPriv.get(src)
              events = pdataOld.events

              if (events) {
                dataPriv.remove(dest, 'handle events')

                for (type in events) {
                  for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i])
                  }
                }
              }
            }

            // 2. Copy user data
            if (dataUser.hasData(src)) {
              udataOld = dataUser.access(src)
              udataCur = jQuery.extend({}, udataOld)

              dataUser.set(dest, udataCur)
            }
          }

          // Fix IE bugs, see support tests
          function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase()

            // Fails to persist the checked state of a cloned checkbox or radio button.
            if (nodeName === 'input' && rcheckableType.test(src.type)) {
              dest.checked = src.checked

              // Fails to return the selected option to the default selected state when cloning options
            } else if (nodeName === 'input' || nodeName === 'textarea') {
              dest.defaultValue = src.defaultValue
            }
          }

          function domManip(collection, args, callback, ignored) {
            // Flatten any nested arrays
            args = flat(args)

            var fragment,
              first,
              scripts,
              hasScripts,
              node,
              doc,
              i = 0,
              l = collection.length,
              iNoClone = l - 1,
              value = args[0],
              valueIsFunction = isFunction(value)

            // We can't cloneNode fragments that contain checked, in WebKit
            if (
              valueIsFunction ||
              (l > 1 &&
                typeof value === 'string' &&
                !support.checkClone &&
                rchecked.test(value))
            ) {
              return collection.each(function (index) {
                var self = collection.eq(index)
                if (valueIsFunction) {
                  args[0] = value.call(this, index, self.html())
                }
                domManip(self, args, callback, ignored)
              })
            }

            if (l) {
              fragment = buildFragment(
                args,
                collection[0].ownerDocument,
                false,
                collection,
                ignored
              )
              first = fragment.firstChild

              if (fragment.childNodes.length === 1) {
                fragment = first
              }

              // Require either new content or an interest in ignored elements to invoke the callback
              if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, 'script'), disableScript)
                hasScripts = scripts.length

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (trac-8070).
                for (; i < l; i++) {
                  node = fragment

                  if (i !== iNoClone) {
                    node = jQuery.clone(node, true, true)

                    // Keep references to cloned scripts for later restoration
                    if (hasScripts) {
                      // Support: Android <=4.0 only, PhantomJS 1 only
                      // push.apply(_, arraylike) throws on ancient WebKit
                      jQuery.merge(scripts, getAll(node, 'script'))
                    }
                  }

                  callback.call(collection[i], node, i)
                }

                if (hasScripts) {
                  doc = scripts[scripts.length - 1].ownerDocument

                  // Re-enable scripts
                  jQuery.map(scripts, restoreScript)

                  // Evaluate executable scripts on first document insertion
                  for (i = 0; i < hasScripts; i++) {
                    node = scripts[i]
                    if (
                      rscriptType.test(node.type || '') &&
                      !dataPriv.access(node, 'globalEval') &&
                      jQuery.contains(doc, node)
                    ) {
                      if (
                        node.src &&
                        (node.type || '').toLowerCase() !== 'module'
                      ) {
                        // Optional AJAX dependency, but won't run scripts if not present
                        if (jQuery._evalUrl && !node.noModule) {
                          jQuery._evalUrl(
                            node.src,
                            {
                              nonce: node.nonce || node.getAttribute('nonce')
                            },
                            doc
                          )
                        }
                      } else {
                        // Unwrap a CDATA section containing script contents. This shouldn't be
                        // needed as in XML documents they're already not visible when
                        // inspecting element contents and in HTML documents they have no
                        // meaning but we're preserving that logic for backwards compatibility.
                        // This will be removed completely in 4.0. See gh-4904.
                        DOMEval(
                          node.textContent.replace(rcleanScript, ''),
                          node,
                          doc
                        )
                      }
                    }
                  }
                }
              }
            }

            return collection
          }

          function remove(elem, selector, keepData) {
            var node,
              nodes = selector ? jQuery.filter(selector, elem) : elem,
              i = 0

            for (; (node = nodes[i]) != null; i++) {
              if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node))
              }

              if (node.parentNode) {
                if (keepData && isAttached(node)) {
                  setGlobalEval(getAll(node, 'script'))
                }
                node.parentNode.removeChild(node)
              }
            }

            return elem
          }

          jQuery.extend({
            htmlPrefilter: function (html) {
              return html
            },

            clone: function (elem, dataAndEvents, deepDataAndEvents) {
              var i,
                l,
                srcElements,
                destElements,
                clone = elem.cloneNode(true),
                inPage = isAttached(elem)

              // Fix IE cloning issues
              if (
                !support.noCloneChecked &&
                (elem.nodeType === 1 || elem.nodeType === 11) &&
                !jQuery.isXMLDoc(elem)
              ) {
                // We eschew jQuery#find here for performance reasons:
                // https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone)
                srcElements = getAll(elem)

                for (i = 0, l = srcElements.length; i < l; i++) {
                  fixInput(srcElements[i], destElements[i])
                }
              }

              // Copy the events from the original to the clone
              if (dataAndEvents) {
                if (deepDataAndEvents) {
                  srcElements = srcElements || getAll(elem)
                  destElements = destElements || getAll(clone)

                  for (i = 0, l = srcElements.length; i < l; i++) {
                    cloneCopyEvent(srcElements[i], destElements[i])
                  }
                } else {
                  cloneCopyEvent(elem, clone)
                }
              }

              // Preserve script evaluation history
              destElements = getAll(clone, 'script')
              if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'))
              }

              // Return the cloned set
              return clone
            },

            cleanData: function (elems) {
              var data,
                elem,
                type,
                special = jQuery.event.special,
                i = 0

              for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                  if ((data = elem[dataPriv.expando])) {
                    if (data.events) {
                      for (type in data.events) {
                        if (special[type]) {
                          jQuery.event.remove(elem, type)

                          // This is a shortcut to avoid jQuery.event.remove's overhead
                        } else {
                          jQuery.removeEvent(elem, type, data.handle)
                        }
                      }
                    }

                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataPriv.expando] = undefined
                  }
                  if (elem[dataUser.expando]) {
                    // Support: Chrome <=35 - 45+
                    // Assign undefined instead of using delete, see Data#remove
                    elem[dataUser.expando] = undefined
                  }
                }
              }
            }
          })

          jQuery.fn.extend({
            detach: function (selector) {
              return remove(this, selector, true)
            },

            remove: function (selector) {
              return remove(this, selector)
            },

            text: function (value) {
              return access(
                this,
                function (value) {
                  return value === undefined
                    ? jQuery.text(this)
                    : this.empty().each(function () {
                        if (
                          this.nodeType === 1 ||
                          this.nodeType === 11 ||
                          this.nodeType === 9
                        ) {
                          this.textContent = value
                        }
                      })
                },
                null,
                value,
                arguments.length
              )
            },

            append: function () {
              return domManip(this, arguments, function (elem) {
                if (
                  this.nodeType === 1 ||
                  this.nodeType === 11 ||
                  this.nodeType === 9
                ) {
                  var target = manipulationTarget(this, elem)
                  target.appendChild(elem)
                }
              })
            },

            prepend: function () {
              return domManip(this, arguments, function (elem) {
                if (
                  this.nodeType === 1 ||
                  this.nodeType === 11 ||
                  this.nodeType === 9
                ) {
                  var target = manipulationTarget(this, elem)
                  target.insertBefore(elem, target.firstChild)
                }
              })
            },

            before: function () {
              return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this)
                }
              })
            },

            after: function () {
              return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this.nextSibling)
                }
              })
            },

            empty: function () {
              var elem,
                i = 0

              for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                  // Prevent memory leaks
                  jQuery.cleanData(getAll(elem, false))

                  // Remove any remaining nodes
                  elem.textContent = ''
                }
              }

              return this
            },

            clone: function (dataAndEvents, deepDataAndEvents) {
              dataAndEvents = dataAndEvents == null ? false : dataAndEvents
              deepDataAndEvents =
                deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents

              return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
              })
            },

            html: function (value) {
              return access(
                this,
                function (value) {
                  var elem = this[0] || {},
                    i = 0,
                    l = this.length

                  if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML
                  }

                  // See if we can take a shortcut and just use innerHTML
                  if (
                    typeof value === 'string' &&
                    !rnoInnerhtml.test(value) &&
                    !wrapMap[
                      (rtagName.exec(value) || ['', ''])[1].toLowerCase()
                    ]
                  ) {
                    value = jQuery.htmlPrefilter(value)

                    try {
                      for (; i < l; i++) {
                        elem = this[i] || {}

                        // Remove element nodes and prevent memory leaks
                        if (elem.nodeType === 1) {
                          jQuery.cleanData(getAll(elem, false))
                          elem.innerHTML = value
                        }
                      }

                      elem = 0

                      // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                  }

                  if (elem) {
                    this.empty().append(value)
                  }
                },
                null,
                value,
                arguments.length
              )
            },

            replaceWith: function () {
              var ignored = []

              // Make the changes, replacing each non-ignored context element with the new content
              return domManip(
                this,
                arguments,
                function (elem) {
                  var parent = this.parentNode

                  if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this))
                    if (parent) {
                      parent.replaceChild(elem, this)
                    }
                  }

                  // Force callback invocation
                },
                ignored
              )
            }
          })

          jQuery.each(
            {
              appendTo: 'append',
              prependTo: 'prepend',
              insertBefore: 'before',
              insertAfter: 'after',
              replaceAll: 'replaceWith'
            },
            function (name, original) {
              jQuery.fn[name] = function (selector) {
                var elems,
                  ret = [],
                  insert = jQuery(selector),
                  last = insert.length - 1,
                  i = 0

                for (; i <= last; i++) {
                  elems = i === last ? this : this.clone(true)
                  jQuery(insert[i])[original](elems)

                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // .get() because push.apply(_, arraylike) throws on ancient WebKit
                  push.apply(ret, elems.get())
                }

                return this.pushStack(ret)
              }
            }
          )
          var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i')

          var rcustomProp = /^--/

          var getStyles = function (elem) {
            // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
            // IE throws on elements created in popups
            // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
            var view = elem.ownerDocument.defaultView

            if (!view || !view.opener) {
              view = window
            }

            return view.getComputedStyle(elem)
          }

          var swap = function (elem, options, callback) {
            var ret,
              name,
              old = {}

            // Remember the old values, and insert the new ones
            for (name in options) {
              old[name] = elem.style[name]
              elem.style[name] = options[name]
            }

            ret = callback.call(elem)

            // Revert the old values
            for (name in options) {
              elem.style[name] = old[name]
            }

            return ret
          }

          var rboxStyle = new RegExp(cssExpand.join('|'), 'i')

          ;(function () {
            // Executing both pixelPosition & boxSizingReliable tests require only one layout
            // so they're executed at the same time to save the second computation.
            function computeStyleTests() {
              // This is a singleton, we need to execute it only once
              if (!div) {
                return
              }

              container.style.cssText =
                'position:absolute;left:-11111px;width:60px;' +
                'margin-top:1px;padding:0;border:0'
              div.style.cssText =
                'position:relative;display:block;box-sizing:border-box;overflow:scroll;' +
                'margin:auto;border:1px;padding:1px;' +
                'width:60%;top:1%'
              documentElement.appendChild(container).appendChild(div)

              var divStyle = window.getComputedStyle(div)
              pixelPositionVal = divStyle.top !== '1%'

              // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
              reliableMarginLeftVal =
                roundPixelMeasures(divStyle.marginLeft) === 12

              // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
              // Some styles come back with percentage values, even though they shouldn't
              div.style.right = '60%'
              pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36

              // Support: IE 9 - 11 only
              // Detect misreporting of content dimensions for box-sizing:border-box elements
              boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36

              // Support: IE 9 only
              // Detect overflow:scroll screwiness (gh-3699)
              // Support: Chrome <=64
              // Don't get tricked when zoom affects offsetWidth (gh-4029)
              div.style.position = 'absolute'
              scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12

              documentElement.removeChild(container)

              // Nullify the div so it wouldn't be stored in the memory and
              // it will also be a sign that checks already performed
              div = null
            }

            function roundPixelMeasures(measure) {
              return Math.round(parseFloat(measure))
            }

            var pixelPositionVal,
              boxSizingReliableVal,
              scrollboxSizeVal,
              pixelBoxStylesVal,
              reliableTrDimensionsVal,
              reliableMarginLeftVal,
              container = document.createElement('div'),
              div = document.createElement('div')

            // Finish early in limited (non-browser) environments
            if (!div.style) {
              return
            }

            // Support: IE <=9 - 11 only
            // Style of cloned element affects source element cloned (trac-8908)
            div.style.backgroundClip = 'content-box'
            div.cloneNode(true).style.backgroundClip = ''
            support.clearCloneStyle = div.style.backgroundClip === 'content-box'

            jQuery.extend(support, {
              boxSizingReliable: function () {
                computeStyleTests()
                return boxSizingReliableVal
              },
              pixelBoxStyles: function () {
                computeStyleTests()
                return pixelBoxStylesVal
              },
              pixelPosition: function () {
                computeStyleTests()
                return pixelPositionVal
              },
              reliableMarginLeft: function () {
                computeStyleTests()
                return reliableMarginLeftVal
              },
              scrollboxSize: function () {
                computeStyleTests()
                return scrollboxSizeVal
              },

              // Support: IE 9 - 11+, Edge 15 - 18+
              // IE/Edge misreport `getComputedStyle` of table rows with width/height
              // set in CSS while `offset*` properties report correct values.
              // Behavior in IE 9 is more subtle than in newer versions & it passes
              // some versions of this test; make sure not to make it pass there!
              //
              // Support: Firefox 70+
              // Only Firefox includes border widths
              // in computed dimensions. (gh-4529)
              reliableTrDimensions: function () {
                var table, tr, trChild, trStyle
                if (reliableTrDimensionsVal == null) {
                  table = document.createElement('table')
                  tr = document.createElement('tr')
                  trChild = document.createElement('div')

                  table.style.cssText =
                    'position:absolute;left:-11111px;border-collapse:separate'
                  tr.style.cssText = 'box-sizing:content-box;border:1px solid'

                  // Support: Chrome 86+
                  // Height set through cssText does not get applied.
                  // Computed height then comes back as 0.
                  tr.style.height = '1px'
                  trChild.style.height = '9px'

                  // Support: Android 8 Chrome 86+
                  // In our bodyBackground.html iframe,
                  // display for all div elements is set to "inline",
                  // which causes a problem only in Android 8 Chrome 86.
                  // Ensuring the div is `display: block`
                  // gets around this issue.
                  trChild.style.display = 'block'

                  documentElement
                    .appendChild(table)
                    .appendChild(tr)
                    .appendChild(trChild)

                  trStyle = window.getComputedStyle(tr)
                  reliableTrDimensionsVal =
                    parseInt(trStyle.height, 10) +
                      parseInt(trStyle.borderTopWidth, 10) +
                      parseInt(trStyle.borderBottomWidth, 10) ===
                    tr.offsetHeight

                  documentElement.removeChild(table)
                }
                return reliableTrDimensionsVal
              }
            })
          })()

          function curCSS(elem, name, computed) {
            var width,
              minWidth,
              maxWidth,
              ret,
              isCustomProp = rcustomProp.test(name),
              // Support: Firefox 51+
              // Retrieving style before computed somehow
              // fixes an issue with getting wrong values
              // on detached elements
              style = elem.style

            computed = computed || getStyles(elem)

            // getPropertyValue is needed for:
            //   .css('filter') (IE 9 only, trac-12537)
            //   .css('--customProperty) (gh-3144)
            if (computed) {
              // Support: IE <=9 - 11+
              // IE only supports `"float"` in `getPropertyValue`; in computed styles
              // it's only available as `"cssFloat"`. We no longer modify properties
              // sent to `.css()` apart from camelCasing, so we need to check both.
              // Normally, this would create difference in behavior: if
              // `getPropertyValue` returns an empty string, the value returned
              // by `.css()` would be `undefined`. This is usually the case for
              // disconnected elements. However, in IE even disconnected elements
              // with no styles return `"none"` for `getPropertyValue( "float" )`
              ret = computed.getPropertyValue(name) || computed[name]

              if (isCustomProp && ret) {
                // Support: Firefox 105+, Chrome <=105+
                // Spec requires trimming whitespace for custom properties (gh-4926).
                // Firefox only trims leading whitespace. Chrome just collapses
                // both leading & trailing whitespace to a single space.
                //
                // Fall back to `undefined` if empty string returned.
                // This collapses a missing definition with property defined
                // and set to an empty string but there's no standard API
                // allowing us to differentiate them without a performance penalty
                // and returning `undefined` aligns with older jQuery.
                //
                // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
                // as whitespace while CSS does not, but this is not a problem
                // because CSS preprocessing replaces them with U+000A LINE FEED
                // (which *is* CSS whitespace)
                // https://www.w3.org/TR/css-syntax-3/#input-preprocessing
                ret = ret.replace(rtrimCSS, '$1') || undefined
              }

              if (ret === '' && !isAttached(elem)) {
                ret = jQuery.style(elem, name)
              }

              // A tribute to the "awesome hack by Dean Edwards"
              // Android Browser returns percentage for some values,
              // but width seems to be reliably pixels.
              // This is against the CSSOM draft spec:
              // https://drafts.csswg.org/cssom/#resolved-values
              if (
                !support.pixelBoxStyles() &&
                rnumnonpx.test(ret) &&
                rboxStyle.test(name)
              ) {
                // Remember the original values
                width = style.width
                minWidth = style.minWidth
                maxWidth = style.maxWidth

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret
                ret = computed.width

                // Revert the changed values
                style.width = width
                style.minWidth = minWidth
                style.maxWidth = maxWidth
              }
            }

            return ret !== undefined
              ? // Support: IE <=9 - 11 only
                // IE returns zIndex value as an integer.
                ret + ''
              : ret
          }

          function addGetHookIf(conditionFn, hookFn) {
            // Define the hook, we'll check on the first run if it's really needed.
            return {
              get: function () {
                if (conditionFn()) {
                  // Hook not needed (or it's not possible to use it due
                  // to missing dependency), remove it.
                  delete this.get
                  return
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments)
              }
            }
          }

          var cssPrefixes = ['Webkit', 'Moz', 'ms'],
            emptyStyle = document.createElement('div').style,
            vendorProps = {}

          // Return a vendor-prefixed property or undefined
          function vendorPropName(name) {
            // Check for vendor prefixed names
            var capName = name[0].toUpperCase() + name.slice(1),
              i = cssPrefixes.length

            while (i--) {
              name = cssPrefixes[i] + capName
              if (name in emptyStyle) {
                return name
              }
            }
          }

          // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
          function finalPropName(name) {
            var final = jQuery.cssProps[name] || vendorProps[name]

            if (final) {
              return final
            }
            if (name in emptyStyle) {
              return name
            }
            return (vendorProps[name] = vendorPropName(name) || name)
          }

          var // Swappable if display is none or starts with table
            // except "table", "table-cell", or "table-caption"
            // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
            rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            cssShow = {
              position: 'absolute',
              visibility: 'hidden',
              display: 'block'
            },
            cssNormalTransform = {
              letterSpacing: '0',
              fontWeight: '400'
            }

          function setPositiveNumber(_elem, value, subtract) {
            // Any relative (+/-) values have already been
            // normalized at this point
            var matches = rcssNum.exec(value)
            return matches
              ? // Guard against undefined "subtract", e.g., when used as in cssHooks
                Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px')
              : value
          }

          function boxModelAdjustment(
            elem,
            dimension,
            box,
            isBorderBox,
            styles,
            computedVal
          ) {
            var i = dimension === 'width' ? 1 : 0,
              extra = 0,
              delta = 0,
              marginDelta = 0

            // Adjustment may not be necessary
            if (box === (isBorderBox ? 'border' : 'content')) {
              return 0
            }

            for (; i < 4; i += 2) {
              // Both box models exclude margin
              // Count margin delta separately to only add it after scroll gutter adjustment.
              // This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
              if (box === 'margin') {
                marginDelta += jQuery.css(
                  elem,
                  box + cssExpand[i],
                  true,
                  styles
                )
              }

              // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
              if (!isBorderBox) {
                // Add padding
                delta += jQuery.css(
                  elem,
                  'padding' + cssExpand[i],
                  true,
                  styles
                )

                // For "border" or "margin", add border
                if (box !== 'padding') {
                  delta += jQuery.css(
                    elem,
                    'border' + cssExpand[i] + 'Width',
                    true,
                    styles
                  )

                  // But still keep track of it otherwise
                } else {
                  extra += jQuery.css(
                    elem,
                    'border' + cssExpand[i] + 'Width',
                    true,
                    styles
                  )
                }

                // If we get here with a border-box (content + padding + border), we're seeking "content" or
                // "padding" or "margin"
              } else {
                // For "content", subtract padding
                if (box === 'content') {
                  delta -= jQuery.css(
                    elem,
                    'padding' + cssExpand[i],
                    true,
                    styles
                  )
                }

                // For "content" or "padding", subtract border
                if (box !== 'margin') {
                  delta -= jQuery.css(
                    elem,
                    'border' + cssExpand[i] + 'Width',
                    true,
                    styles
                  )
                }
              }
            }

            // Account for positive content-box scroll gutter when requested by providing computedVal
            if (!isBorderBox && computedVal >= 0) {
              // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
              // Assuming integer scroll gutter, subtract the rest and round down
              delta +=
                Math.max(
                  0,
                  Math.ceil(
                    elem[
                      'offset' + dimension[0].toUpperCase() + dimension.slice(1)
                    ] -
                      computedVal -
                      delta -
                      extra -
                      0.5

                    // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                    // Use an explicit zero to avoid NaN (gh-3964)
                  )
                ) || 0
            }

            return delta + marginDelta
          }

          function getWidthOrHeight(elem, dimension, extra) {
            // Start with computed style
            var styles = getStyles(elem),
              // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
              // Fake content-box until we know it's needed to know the true value.
              boxSizingNeeded = !support.boxSizingReliable() || extra,
              isBorderBox =
                boxSizingNeeded &&
                jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',
              valueIsBorderBox = isBorderBox,
              val = curCSS(elem, dimension, styles),
              offsetProp =
                'offset' + dimension[0].toUpperCase() + dimension.slice(1)

            // Support: Firefox <=54
            // Return a confounding non-pixel value or feign ignorance, as appropriate.
            if (rnumnonpx.test(val)) {
              if (!extra) {
                return val
              }
              val = 'auto'
            }

            // Support: IE 9 - 11 only
            // Use offsetWidth/offsetHeight for when box sizing is unreliable.
            // In those cases, the computed value can be trusted to be border-box.
            if (
              ((!support.boxSizingReliable() && isBorderBox) ||
                // Support: IE 10 - 11+, Edge 15 - 18+
                // IE/Edge misreport `getComputedStyle` of table rows with width/height
                // set in CSS while `offset*` properties report correct values.
                // Interestingly, in some cases IE 9 doesn't suffer from this issue.
                (!support.reliableTrDimensions() && nodeName(elem, 'tr')) ||
                // Fall back to offsetWidth/offsetHeight when value is "auto"
                // This happens for inline elements with no explicit setting (gh-3571)
                val === 'auto' ||
                // Support: Android <=4.1 - 4.3 only
                // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
                (!parseFloat(val) &&
                  jQuery.css(elem, 'display', false, styles) === 'inline')) &&
              // Make sure the element is visible & connected
              elem.getClientRects().length
            ) {
              isBorderBox =
                jQuery.css(elem, 'boxSizing', false, styles) === 'border-box'

              // Where available, offsetWidth/offsetHeight approximate border box dimensions.
              // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
              // retrieved value as a content box dimension.
              valueIsBorderBox = offsetProp in elem
              if (valueIsBorderBox) {
                val = elem[offsetProp]
              }
            }

            // Normalize "" and auto
            val = parseFloat(val) || 0

            // Adjust for the element's box model
            return (
              val +
              boxModelAdjustment(
                elem,
                dimension,
                extra || (isBorderBox ? 'border' : 'content'),
                valueIsBorderBox,
                styles,

                // Provide the current computed size to request scroll gutter calculation (gh-3589)
                val
              ) +
              'px'
            )
          }

          jQuery.extend({
            // Add in style property hooks for overriding the default
            // behavior of getting and setting a style property
            cssHooks: {
              opacity: {
                get: function (elem, computed) {
                  if (computed) {
                    // We should always get a number back from opacity
                    var ret = curCSS(elem, 'opacity')
                    return ret === '' ? '1' : ret
                  }
                }
              }
            },

            // Don't automatically add "px" to these possibly-unitless properties
            cssNumber: {
              animationIterationCount: true,
              aspectRatio: true,
              borderImageSlice: true,
              columnCount: true,
              flexGrow: true,
              flexShrink: true,
              fontWeight: true,
              gridArea: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnStart: true,
              gridRow: true,
              gridRowEnd: true,
              gridRowStart: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              scale: true,
              widows: true,
              zIndex: true,
              zoom: true,

              // SVG-related
              fillOpacity: true,
              floodOpacity: true,
              stopOpacity: true,
              strokeMiterlimit: true,
              strokeOpacity: true
            },

            // Add in properties whose names you wish to fix before
            // setting or getting the value
            cssProps: {},

            // Get and set the style property on a DOM Node
            style: function (elem, name, value, extra) {
              // Don't set styles on text and comment nodes
              if (
                !elem ||
                elem.nodeType === 3 ||
                elem.nodeType === 8 ||
                !elem.style
              ) {
                return
              }

              // Make sure that we're working with the right name
              var ret,
                type,
                hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name),
                style = elem.style

              // Make sure that we're working with the right name. We don't
              // want to query the value if it is a CSS custom property
              // since they are user-defined.
              if (!isCustomProp) {
                name = finalPropName(origName)
              }

              // Gets hook for the prefixed version, then unprefixed version
              hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

              // Check if we're setting a value
              if (value !== undefined) {
                type = typeof value

                // Convert "+=" or "-=" to relative numbers (trac-7345)
                if (
                  type === 'string' &&
                  (ret = rcssNum.exec(value)) &&
                  ret[1]
                ) {
                  value = adjustCSS(elem, name, ret)

                  // Fixes bug trac-9237
                  type = 'number'
                }

                // Make sure that null and NaN values aren't set (trac-7116)
                if (value == null || value !== value) {
                  return
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if (type === 'number' && !isCustomProp) {
                  value +=
                    (ret && ret[3]) || (jQuery.cssNumber[origName] ? '' : 'px')
                }

                // background-* props affect original clone's values
                if (
                  !support.clearCloneStyle &&
                  value === '' &&
                  name.indexOf('background') === 0
                ) {
                  style[name] = 'inherit'
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (
                  !hooks ||
                  !('set' in hooks) ||
                  (value = hooks.set(elem, value, extra)) !== undefined
                ) {
                  if (isCustomProp) {
                    style.setProperty(name, value)
                  } else {
                    style[name] = value
                  }
                }
              } else {
                // If a hook was provided get the non-computed value from there
                if (
                  hooks &&
                  'get' in hooks &&
                  (ret = hooks.get(elem, false, extra)) !== undefined
                ) {
                  return ret
                }

                // Otherwise just get the value from the style object
                return style[name]
              }
            },

            css: function (elem, name, extra, styles) {
              var val,
                num,
                hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name)

              // Make sure that we're working with the right name. We don't
              // want to modify the value if it is a CSS custom property
              // since they are user-defined.
              if (!isCustomProp) {
                name = finalPropName(origName)
              }

              // Try prefixed name followed by the unprefixed name
              hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

              // If a hook was provided get the computed value from there
              if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra)
              }

              // Otherwise, if a way to get the computed value exists, use that
              if (val === undefined) {
                val = curCSS(elem, name, styles)
              }

              // Convert "normal" to computed value
              if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name]
              }

              // Make numeric if forced or a qualifier was provided and val looks numeric
              if (extra === '' || extra) {
                num = parseFloat(val)
                return extra === true || isFinite(num) ? num || 0 : val
              }

              return val
            }
          })

          jQuery.each(['height', 'width'], function (_i, dimension) {
            jQuery.cssHooks[dimension] = {
              get: function (elem, computed, extra) {
                if (computed) {
                  // Certain elements can have dimension info if we invisibly show them
                  // but it must have a current display style that would benefit
                  return rdisplayswap.test(jQuery.css(elem, 'display')) &&
                    // Support: Safari 8+
                    // Table columns in Safari have non-zero offsetWidth & zero
                    // getBoundingClientRect().width unless display is changed.
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a disconnected node
                    // in IE throws an error.
                    (!elem.getClientRects().length ||
                      !elem.getBoundingClientRect().width)
                    ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, dimension, extra)
                      })
                    : getWidthOrHeight(elem, dimension, extra)
                }
              },

              set: function (elem, value, extra) {
                var matches,
                  styles = getStyles(elem),
                  // Only read styles.position if the test has a chance to fail
                  // to avoid forcing a reflow.
                  scrollboxSizeBuggy =
                    !support.scrollboxSize() && styles.position === 'absolute',
                  // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                  boxSizingNeeded = scrollboxSizeBuggy || extra,
                  isBorderBox =
                    boxSizingNeeded &&
                    jQuery.css(elem, 'boxSizing', false, styles) ===
                      'border-box',
                  subtract = extra
                    ? boxModelAdjustment(
                        elem,
                        dimension,
                        extra,
                        isBorderBox,
                        styles
                      )
                    : 0

                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && scrollboxSizeBuggy) {
                  subtract -= Math.ceil(
                    elem[
                      'offset' + dimension[0].toUpperCase() + dimension.slice(1)
                    ] -
                      parseFloat(styles[dimension]) -
                      boxModelAdjustment(
                        elem,
                        dimension,
                        'border',
                        false,
                        styles
                      ) -
                      0.5
                  )
                }

                // Convert to pixels if value adjustment is needed
                if (
                  subtract &&
                  (matches = rcssNum.exec(value)) &&
                  (matches[3] || 'px') !== 'px'
                ) {
                  elem.style[dimension] = value
                  value = jQuery.css(elem, dimension)
                }

                return setPositiveNumber(elem, value, subtract)
              }
            }
          })

          jQuery.cssHooks.marginLeft = addGetHookIf(
            support.reliableMarginLeft,
            function (elem, computed) {
              if (computed) {
                return (
                  (parseFloat(curCSS(elem, 'marginLeft')) ||
                    elem.getBoundingClientRect().left -
                      swap(elem, { marginLeft: 0 }, function () {
                        return elem.getBoundingClientRect().left
                      })) + 'px'
                )
              }
            }
          )

          // These hooks are used by animate to expand properties
          jQuery.each(
            {
              margin: '',
              padding: '',
              border: 'Width'
            },
            function (prefix, suffix) {
              jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                  var i = 0,
                    expanded = {},
                    // Assumes a single number if not a string
                    parts =
                      typeof value === 'string' ? value.split(' ') : [value]

                  for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
                      parts[i] || parts[i - 2] || parts[0]
                  }

                  return expanded
                }
              }

              if (prefix !== 'margin') {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber
              }
            }
          )

          jQuery.fn.extend({
            css: function (name, value) {
              return access(
                this,
                function (elem, name, value) {
                  var styles,
                    len,
                    map = {},
                    i = 0

                  if (Array.isArray(name)) {
                    styles = getStyles(elem)
                    len = name.length

                    for (; i < len; i++) {
                      map[name[i]] = jQuery.css(elem, name[i], false, styles)
                    }

                    return map
                  }

                  return value !== undefined
                    ? jQuery.style(elem, name, value)
                    : jQuery.css(elem, name)
                },
                name,
                value,
                arguments.length > 1
              )
            }
          })

          function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing)
          }
          jQuery.Tween = Tween

          Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
              this.elem = elem
              this.prop = prop
              this.easing = easing || jQuery.easing._default
              this.options = options
              this.start = this.now = this.cur()
              this.end = end
              this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px')
            },
            cur: function () {
              var hooks = Tween.propHooks[this.prop]

              return hooks && hooks.get
                ? hooks.get(this)
                : Tween.propHooks._default.get(this)
            },
            run: function (percent) {
              var eased,
                hooks = Tween.propHooks[this.prop]

              if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                  percent,
                  this.options.duration * percent,
                  0,
                  1,
                  this.options.duration
                )
              } else {
                this.pos = eased = percent
              }
              this.now = (this.end - this.start) * eased + this.start

              if (this.options.step) {
                this.options.step.call(this.elem, this.now, this)
              }

              if (hooks && hooks.set) {
                hooks.set(this)
              } else {
                Tween.propHooks._default.set(this)
              }
              return this
            }
          }

          Tween.prototype.init.prototype = Tween.prototype

          Tween.propHooks = {
            _default: {
              get: function (tween) {
                var result

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (
                  tween.elem.nodeType !== 1 ||
                  (tween.elem[tween.prop] != null &&
                    tween.elem.style[tween.prop] == null)
                ) {
                  return tween.elem[tween.prop]
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, '')

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === 'auto' ? 0 : result
              },
              set: function (tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                  jQuery.fx.step[tween.prop](tween)
                } else if (
                  tween.elem.nodeType === 1 &&
                  (jQuery.cssHooks[tween.prop] ||
                    tween.elem.style[finalPropName(tween.prop)] != null)
                ) {
                  jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
                } else {
                  tween.elem[tween.prop] = tween.now
                }
              }
            }
          }

          // Support: IE <=9 only
          // Panic based approach to setting things on disconnected nodes
          Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
              if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now
              }
            }
          }

          jQuery.easing = {
            linear: function (p) {
              return p
            },
            swing: function (p) {
              return 0.5 - Math.cos(p * Math.PI) / 2
            },
            _default: 'swing'
          }

          jQuery.fx = Tween.prototype.init

          // Back compat <1.8 extension point
          jQuery.fx.step = {}

          var fxNow,
            inProgress,
            rfxtypes = /^(?:toggle|show|hide)$/,
            rrun = /queueHooks$/

          function schedule() {
            if (inProgress) {
              if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule)
              } else {
                window.setTimeout(schedule, jQuery.fx.interval)
              }

              jQuery.fx.tick()
            }
          }

          // Animations created synchronously will run synchronously
          function createFxNow() {
            window.setTimeout(function () {
              fxNow = undefined
            })
            return (fxNow = Date.now())
          }

          // Generate parameters to create a standard animation
          function genFx(type, includeWidth) {
            var which,
              i = 0,
              attrs = { height: type }

            // If we include width, step value is 1 to do all cssExpand values,
            // otherwise step value is 2 to skip over Left and Right
            includeWidth = includeWidth ? 1 : 0
            for (; i < 4; i += 2 - includeWidth) {
              which = cssExpand[i]
              attrs['margin' + which] = attrs['padding' + which] = type
            }

            if (includeWidth) {
              attrs.opacity = attrs.width = type
            }

            return attrs
          }

          function createTween(value, prop, animation) {
            var tween,
              collection = (Animation.tweeners[prop] || []).concat(
                Animation.tweeners['*']
              ),
              index = 0,
              length = collection.length
            for (; index < length; index++) {
              if ((tween = collection[index].call(animation, prop, value))) {
                // We're done with this property
                return tween
              }
            }
          }

          function defaultPrefilter(elem, props, opts) {
            var prop,
              value,
              toggle,
              hooks,
              oldfire,
              propTween,
              restoreDisplay,
              display,
              isBox = 'width' in props || 'height' in props,
              anim = this,
              orig = {},
              style = elem.style,
              hidden = elem.nodeType && isHiddenWithinTree(elem),
              dataShow = dataPriv.get(elem, 'fxshow')

            // Queue-skipping animations hijack the fx hooks
            if (!opts.queue) {
              hooks = jQuery._queueHooks(elem, 'fx')
              if (hooks.unqueued == null) {
                hooks.unqueued = 0
                oldfire = hooks.empty.fire
                hooks.empty.fire = function () {
                  if (!hooks.unqueued) {
                    oldfire()
                  }
                }
              }
              hooks.unqueued++

              anim.always(function () {
                // Ensure the complete handler is called before this completes
                anim.always(function () {
                  hooks.unqueued--
                  if (!jQuery.queue(elem, 'fx').length) {
                    hooks.empty.fire()
                  }
                })
              })
            }

            // Detect show/hide animations
            for (prop in props) {
              value = props[prop]
              if (rfxtypes.test(value)) {
                delete props[prop]
                toggle = toggle || value === 'toggle'
                if (value === (hidden ? 'hide' : 'show')) {
                  // Pretend to be hidden if this is a "show" and
                  // there is still data from a stopped show/hide
                  if (
                    value === 'show' &&
                    dataShow &&
                    dataShow[prop] !== undefined
                  ) {
                    hidden = true

                    // Ignore all other no-op show/hide data
                  } else {
                    continue
                  }
                }
                orig[prop] =
                  (dataShow && dataShow[prop]) || jQuery.style(elem, prop)
              }
            }

            // Bail out if this is a no-op like .hide().hide()
            propTween = !jQuery.isEmptyObject(props)
            if (!propTween && jQuery.isEmptyObject(orig)) {
              return
            }

            // Restrict "overflow" and "display" styles during box animations
            if (isBox && elem.nodeType === 1) {
              // Support: IE <=9 - 11, Edge 12 - 15
              // Record all 3 overflow attributes because IE does not infer the shorthand
              // from identically-valued overflowX and overflowY and Edge just mirrors
              // the overflowX value there.
              opts.overflow = [style.overflow, style.overflowX, style.overflowY]

              // Identify a display type, preferring old show/hide data over the CSS cascade
              restoreDisplay = dataShow && dataShow.display
              if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, 'display')
              }
              display = jQuery.css(elem, 'display')
              if (display === 'none') {
                if (restoreDisplay) {
                  display = restoreDisplay
                } else {
                  // Get nonempty value(s) by temporarily forcing visibility
                  showHide([elem], true)
                  restoreDisplay = elem.style.display || restoreDisplay
                  display = jQuery.css(elem, 'display')
                  showHide([elem])
                }
              }

              // Animate inline elements as inline-block
              if (
                display === 'inline' ||
                (display === 'inline-block' && restoreDisplay != null)
              ) {
                if (jQuery.css(elem, 'float') === 'none') {
                  // Restore the original display value at the end of pure show/hide animations
                  if (!propTween) {
                    anim.done(function () {
                      style.display = restoreDisplay
                    })
                    if (restoreDisplay == null) {
                      display = style.display
                      restoreDisplay = display === 'none' ? '' : display
                    }
                  }
                  style.display = 'inline-block'
                }
              }
            }

            if (opts.overflow) {
              style.overflow = 'hidden'
              anim.always(function () {
                style.overflow = opts.overflow[0]
                style.overflowX = opts.overflow[1]
                style.overflowY = opts.overflow[2]
              })
            }

            // Implement show/hide animations
            propTween = false
            for (prop in orig) {
              // General show/hide setup for this element animation
              if (!propTween) {
                if (dataShow) {
                  if ('hidden' in dataShow) {
                    hidden = dataShow.hidden
                  }
                } else {
                  dataShow = dataPriv.access(elem, 'fxshow', {
                    display: restoreDisplay
                  })
                }

                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) {
                  dataShow.hidden = !hidden
                }

                // Show elements before animating them
                if (hidden) {
                  showHide([elem], true)
                }

                /* eslint-disable no-loop-func */

                anim.done(function () {
                  /* eslint-enable no-loop-func */

                  // The final step of a "hide" animation is actually hiding the element
                  if (!hidden) {
                    showHide([elem])
                  }
                  dataPriv.remove(elem, 'fxshow')
                  for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop])
                  }
                })
              }

              // Per-property setup
              propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim)
              if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start
                if (hidden) {
                  propTween.end = propTween.start
                  propTween.start = 0
                }
              }
            }
          }

          function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks

            // camelCase, specialEasing and expand cssHook pass
            for (index in props) {
              name = camelCase(index)
              easing = specialEasing[name]
              value = props[index]
              if (Array.isArray(value)) {
                easing = value[1]
                value = props[index] = value[0]
              }

              if (index !== name) {
                props[name] = value
                delete props[index]
              }

              hooks = jQuery.cssHooks[name]
              if (hooks && 'expand' in hooks) {
                value = hooks.expand(value)
                delete props[name]

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                  if (!(index in props)) {
                    props[index] = value[index]
                    specialEasing[index] = easing
                  }
                }
              } else {
                specialEasing[name] = easing
              }
            }
          }

          function Animation(elem, properties, options) {
            var result,
              stopped,
              index = 0,
              length = Animation.prefilters.length,
              deferred = jQuery.Deferred().always(function () {
                // Don't match elem in the :animated selector
                delete tick.elem
              }),
              tick = function () {
                if (stopped) {
                  return false
                }
                var currentTime = fxNow || createFxNow(),
                  remaining = Math.max(
                    0,
                    animation.startTime + animation.duration - currentTime
                  ),
                  // Support: Android 2.3 only
                  // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
                  temp = remaining / animation.duration || 0,
                  percent = 1 - temp,
                  index = 0,
                  length = animation.tweens.length

                for (; index < length; index++) {
                  animation.tweens[index].run(percent)
                }

                deferred.notifyWith(elem, [animation, percent, remaining])

                // If there's more to do, yield
                if (percent < 1 && length) {
                  return remaining
                }

                // If this was an empty animation, synthesize a final progress notification
                if (!length) {
                  deferred.notifyWith(elem, [animation, 1, 0])
                }

                // Resolve the animation and report its conclusion
                deferred.resolveWith(elem, [animation])
                return false
              },
              animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(
                  true,
                  {
                    specialEasing: {},
                    easing: jQuery.easing._default
                  },
                  options
                ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                  var tween = jQuery.Tween(
                    elem,
                    animation.opts,
                    prop,
                    end,
                    animation.opts.specialEasing[prop] || animation.opts.easing
                  )
                  animation.tweens.push(tween)
                  return tween
                },
                stop: function (gotoEnd) {
                  var index = 0,
                    // If we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation.tweens.length : 0
                  if (stopped) {
                    return this
                  }
                  stopped = true
                  for (; index < length; index++) {
                    animation.tweens[index].run(1)
                  }

                  // Resolve when we played the last frame; otherwise, reject
                  if (gotoEnd) {
                    deferred.notifyWith(elem, [animation, 1, 0])
                    deferred.resolveWith(elem, [animation, gotoEnd])
                  } else {
                    deferred.rejectWith(elem, [animation, gotoEnd])
                  }
                  return this
                }
              }),
              props = animation.props

            propFilter(props, animation.opts.specialEasing)

            for (; index < length; index++) {
              result = Animation.prefilters[index].call(
                animation,
                elem,
                props,
                animation.opts
              )
              if (result) {
                if (isFunction(result.stop)) {
                  jQuery._queueHooks(
                    animation.elem,
                    animation.opts.queue
                  ).stop = result.stop.bind(result)
                }
                return result
              }
            }

            jQuery.map(props, createTween, animation)

            if (isFunction(animation.opts.start)) {
              animation.opts.start.call(elem, animation)
            }

            // Attach callbacks from options
            animation
              .progress(animation.opts.progress)
              .done(animation.opts.done, animation.opts.complete)
              .fail(animation.opts.fail)
              .always(animation.opts.always)

            jQuery.fx.timer(
              jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
              })
            )

            return animation
          }

          jQuery.Animation = jQuery.extend(Animation, {
            tweeners: {
              '*': [
                function (prop, value) {
                  var tween = this.createTween(prop, value)
                  adjustCSS(tween.elem, prop, rcssNum.exec(value), tween)
                  return tween
                }
              ]
            },

            tweener: function (props, callback) {
              if (isFunction(props)) {
                callback = props
                props = ['*']
              } else {
                props = props.match(rnothtmlwhite)
              }

              var prop,
                index = 0,
                length = props.length

              for (; index < length; index++) {
                prop = props[index]
                Animation.tweeners[prop] = Animation.tweeners[prop] || []
                Animation.tweeners[prop].unshift(callback)
              }
            },

            prefilters: [defaultPrefilter],

            prefilter: function (callback, prepend) {
              if (prepend) {
                Animation.prefilters.unshift(callback)
              } else {
                Animation.prefilters.push(callback)
              }
            }
          })

          jQuery.speed = function (speed, easing, fn) {
            var opt =
              speed && typeof speed === 'object'
                ? jQuery.extend({}, speed)
                : {
                    complete:
                      fn || (!fn && easing) || (isFunction(speed) && speed),
                    duration: speed,
                    easing:
                      (fn && easing) ||
                      (easing && !isFunction(easing) && easing)
                  }

            // Go to the end state if fx are off
            if (jQuery.fx.off) {
              opt.duration = 0
            } else {
              if (typeof opt.duration !== 'number') {
                if (opt.duration in jQuery.fx.speeds) {
                  opt.duration = jQuery.fx.speeds[opt.duration]
                } else {
                  opt.duration = jQuery.fx.speeds._default
                }
              }
            }

            // Normalize opt.queue - true/undefined/null -> "fx"
            if (opt.queue == null || opt.queue === true) {
              opt.queue = 'fx'
            }

            // Queueing
            opt.old = opt.complete

            opt.complete = function () {
              if (isFunction(opt.old)) {
                opt.old.call(this)
              }

              if (opt.queue) {
                jQuery.dequeue(this, opt.queue)
              }
            }

            return opt
          }

          jQuery.fn.extend({
            fadeTo: function (speed, to, easing, callback) {
              // Show any hidden elements after setting opacity to 0
              return (
                this.filter(isHiddenWithinTree)
                  .css('opacity', 0)
                  .show()

                  // Animate to the value specified
                  .end()
                  .animate({ opacity: to }, speed, easing, callback)
              )
            },
            animate: function (prop, speed, easing, callback) {
              var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {
                  // Operate on a copy of prop so per-property easing won't be lost
                  var anim = Animation(this, jQuery.extend({}, prop), optall)

                  // Empty animations, or finishing resolves immediately
                  if (empty || dataPriv.get(this, 'finish')) {
                    anim.stop(true)
                  }
                }

              doAnimation.finish = doAnimation

              return empty || optall.queue === false
                ? this.each(doAnimation)
                : this.queue(optall.queue, doAnimation)
            },
            stop: function (type, clearQueue, gotoEnd) {
              var stopQueue = function (hooks) {
                var stop = hooks.stop
                delete hooks.stop
                stop(gotoEnd)
              }

              if (typeof type !== 'string') {
                gotoEnd = clearQueue
                clearQueue = type
                type = undefined
              }
              if (clearQueue) {
                this.queue(type || 'fx', [])
              }

              return this.each(function () {
                var dequeue = true,
                  index = type != null && type + 'queueHooks',
                  timers = jQuery.timers,
                  data = dataPriv.get(this)

                if (index) {
                  if (data[index] && data[index].stop) {
                    stopQueue(data[index])
                  }
                } else {
                  for (index in data) {
                    if (data[index] && data[index].stop && rrun.test(index)) {
                      stopQueue(data[index])
                    }
                  }
                }

                for (index = timers.length; index--; ) {
                  if (
                    timers[index].elem === this &&
                    (type == null || timers[index].queue === type)
                  ) {
                    timers[index].anim.stop(gotoEnd)
                    dequeue = false
                    timers.splice(index, 1)
                  }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                  jQuery.dequeue(this, type)
                }
              })
            },
            finish: function (type) {
              if (type !== false) {
                type = type || 'fx'
              }
              return this.each(function () {
                var index,
                  data = dataPriv.get(this),
                  queue = data[type + 'queue'],
                  hooks = data[type + 'queueHooks'],
                  timers = jQuery.timers,
                  length = queue ? queue.length : 0

                // Enable finishing flag on private data
                data.finish = true

                // Empty the queue first
                jQuery.queue(this, type, [])

                if (hooks && hooks.stop) {
                  hooks.stop.call(this, true)
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--; ) {
                  if (
                    timers[index].elem === this &&
                    timers[index].queue === type
                  ) {
                    timers[index].anim.stop(true)
                    timers.splice(index, 1)
                  }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                  if (queue[index] && queue[index].finish) {
                    queue[index].finish.call(this)
                  }
                }

                // Turn off finishing flag
                delete data.finish
              })
            }
          })

          jQuery.each(['toggle', 'show', 'hide'], function (_i, name) {
            var cssFn = jQuery.fn[name]
            jQuery.fn[name] = function (speed, easing, callback) {
              return speed == null || typeof speed === 'boolean'
                ? cssFn.apply(this, arguments)
                : this.animate(genFx(name, true), speed, easing, callback)
            }
          })

          // Generate shortcuts for custom animations
          jQuery.each(
            {
              slideDown: genFx('show'),
              slideUp: genFx('hide'),
              slideToggle: genFx('toggle'),
              fadeIn: { opacity: 'show' },
              fadeOut: { opacity: 'hide' },
              fadeToggle: { opacity: 'toggle' }
            },
            function (name, props) {
              jQuery.fn[name] = function (speed, easing, callback) {
                return this.animate(props, speed, easing, callback)
              }
            }
          )

          jQuery.timers = []
          jQuery.fx.tick = function () {
            var timer,
              i = 0,
              timers = jQuery.timers

            fxNow = Date.now()

            for (; i < timers.length; i++) {
              timer = timers[i]

              // Run the timer and safely remove it when done (allowing for external removal)
              if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1)
              }
            }

            if (!timers.length) {
              jQuery.fx.stop()
            }
            fxNow = undefined
          }

          jQuery.fx.timer = function (timer) {
            jQuery.timers.push(timer)
            jQuery.fx.start()
          }

          jQuery.fx.interval = 13
          jQuery.fx.start = function () {
            if (inProgress) {
              return
            }

            inProgress = true
            schedule()
          }

          jQuery.fx.stop = function () {
            inProgress = null
          }

          jQuery.fx.speeds = {
            slow: 600,
            fast: 200,

            // Default speed
            _default: 400
          }

          // Based off of the plugin by Clint Helfers, with permission.
          jQuery.fn.delay = function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time
            type = type || 'fx'

            return this.queue(type, function (next, hooks) {
              var timeout = window.setTimeout(next, time)
              hooks.stop = function () {
                window.clearTimeout(timeout)
              }
            })
          }

          ;(function () {
            var input = document.createElement('input'),
              select = document.createElement('select'),
              opt = select.appendChild(document.createElement('option'))

            input.type = 'checkbox'

            // Support: Android <=4.3 only
            // Default value for a checkbox should be "on"
            support.checkOn = input.value !== ''

            // Support: IE <=11 only
            // Must access selectedIndex to make default options select
            support.optSelected = opt.selected

            // Support: IE <=11 only
            // An input loses its value after becoming a radio
            input = document.createElement('input')
            input.value = 't'
            input.type = 'radio'
            support.radioValue = input.value === 't'
          })()

          var boolHook,
            attrHandle = jQuery.expr.attrHandle

          jQuery.fn.extend({
            attr: function (name, value) {
              return access(
                this,
                jQuery.attr,
                name,
                value,
                arguments.length > 1
              )
            },

            removeAttr: function (name) {
              return this.each(function () {
                jQuery.removeAttr(this, name)
              })
            }
          })

          jQuery.extend({
            attr: function (elem, name, value) {
              var ret,
                hooks,
                nType = elem.nodeType

              // Don't get/set attributes on text, comment and attribute nodes
              if (nType === 3 || nType === 8 || nType === 2) {
                return
              }

              // Fallback to prop when attributes are not supported
              if (typeof elem.getAttribute === 'undefined') {
                return jQuery.prop(elem, name, value)
              }

              // Attribute hooks are determined by the lowercase version
              // Grab necessary hook if one is defined
              if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks =
                  jQuery.attrHooks[name.toLowerCase()] ||
                  (jQuery.expr.match.bool.test(name) ? boolHook : undefined)
              }

              if (value !== undefined) {
                if (value === null) {
                  jQuery.removeAttr(elem, name)
                  return
                }

                if (
                  hooks &&
                  'set' in hooks &&
                  (ret = hooks.set(elem, value, name)) !== undefined
                ) {
                  return ret
                }

                elem.setAttribute(name, value + '')
                return value
              }

              if (
                hooks &&
                'get' in hooks &&
                (ret = hooks.get(elem, name)) !== null
              ) {
                return ret
              }

              ret = jQuery.find.attr(elem, name)

              // Non-existent attributes return null, we normalize to undefined
              return ret == null ? undefined : ret
            },

            attrHooks: {
              type: {
                set: function (elem, value) {
                  if (
                    !support.radioValue &&
                    value === 'radio' &&
                    nodeName(elem, 'input')
                  ) {
                    var val = elem.value
                    elem.setAttribute('type', value)
                    if (val) {
                      elem.value = val
                    }
                    return value
                  }
                }
              }
            },

            removeAttr: function (elem, value) {
              var name,
                i = 0,
                // Attribute names can contain non-HTML whitespace characters
                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                attrNames = value && value.match(rnothtmlwhite)

              if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                  elem.removeAttribute(name)
                }
              }
            }
          })

          // Hooks for boolean attributes
          boolHook = {
            set: function (elem, value, name) {
              if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name)
              } else {
                elem.setAttribute(name, name)
              }
              return name
            }
          }

          jQuery.each(
            jQuery.expr.match.bool.source.match(/\w+/g),
            function (_i, name) {
              var getter = attrHandle[name] || jQuery.find.attr

              attrHandle[name] = function (elem, name, isXML) {
                var ret,
                  handle,
                  lowercaseName = name.toLowerCase()

                if (!isXML) {
                  // Avoid an infinite loop by temporarily removing this function from the getter
                  handle = attrHandle[lowercaseName]
                  attrHandle[lowercaseName] = ret
                  ret = getter(elem, name, isXML) != null ? lowercaseName : null
                  attrHandle[lowercaseName] = handle
                }
                return ret
              }
            }
          )

          var rfocusable = /^(?:input|select|textarea|button)$/i,
            rclickable = /^(?:a|area)$/i

          jQuery.fn.extend({
            prop: function (name, value) {
              return access(
                this,
                jQuery.prop,
                name,
                value,
                arguments.length > 1
              )
            },

            removeProp: function (name) {
              return this.each(function () {
                delete this[jQuery.propFix[name] || name]
              })
            }
          })

          jQuery.extend({
            prop: function (elem, name, value) {
              var ret,
                hooks,
                nType = elem.nodeType

              // Don't get/set properties on text, comment and attribute nodes
              if (nType === 3 || nType === 8 || nType === 2) {
                return
              }

              if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name
                hooks = jQuery.propHooks[name]
              }

              if (value !== undefined) {
                if (
                  hooks &&
                  'set' in hooks &&
                  (ret = hooks.set(elem, value, name)) !== undefined
                ) {
                  return ret
                }

                return (elem[name] = value)
              }

              if (
                hooks &&
                'get' in hooks &&
                (ret = hooks.get(elem, name)) !== null
              ) {
                return ret
              }

              return elem[name]
            },

            propHooks: {
              tabIndex: {
                get: function (elem) {
                  // Support: IE <=9 - 11 only
                  // elem.tabIndex doesn't always return the
                  // correct value when it hasn't been explicitly set
                  // Use proper attribute retrieval (trac-12072)
                  var tabindex = jQuery.find.attr(elem, 'tabindex')

                  if (tabindex) {
                    return parseInt(tabindex, 10)
                  }

                  if (
                    rfocusable.test(elem.nodeName) ||
                    (rclickable.test(elem.nodeName) && elem.href)
                  ) {
                    return 0
                  }

                  return -1
                }
              }
            },

            propFix: {
              for: 'htmlFor',
              class: 'className'
            }
          })

          // Support: IE <=11 only
          // Accessing the selectedIndex property
          // forces the browser to respect setting selected
          // on the option
          // The getter ensures a default option is selected
          // when in an optgroup
          // eslint rule "no-unused-expressions" is disabled for this code
          // since it considers such accessions noop
          if (!support.optSelected) {
            jQuery.propHooks.selected = {
              get: function (elem) {
                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode
                if (parent && parent.parentNode) {
                  parent.parentNode.selectedIndex
                }
                return null
              },
              set: function (elem) {
                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode
                if (parent) {
                  parent.selectedIndex

                  if (parent.parentNode) {
                    parent.parentNode.selectedIndex
                  }
                }
              }
            }
          }

          jQuery.each(
            [
              'tabIndex',
              'readOnly',
              'maxLength',
              'cellSpacing',
              'cellPadding',
              'rowSpan',
              'colSpan',
              'useMap',
              'frameBorder',
              'contentEditable'
            ],
            function () {
              jQuery.propFix[this.toLowerCase()] = this
            }
          )

          // Strip and collapse whitespace according to HTML spec
          // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
          function stripAndCollapse(value) {
            var tokens = value.match(rnothtmlwhite) || []
            return tokens.join(' ')
          }

          function getClass(elem) {
            return (elem.getAttribute && elem.getAttribute('class')) || ''
          }

          function classesToArray(value) {
            if (Array.isArray(value)) {
              return value
            }
            if (typeof value === 'string') {
              return value.match(rnothtmlwhite) || []
            }
            return []
          }

          jQuery.fn.extend({
            addClass: function (value) {
              var classNames, cur, curValue, className, i, finalValue

              if (isFunction(value)) {
                return this.each(function (j) {
                  jQuery(this).addClass(value.call(this, j, getClass(this)))
                })
              }

              classNames = classesToArray(value)

              if (classNames.length) {
                return this.each(function () {
                  curValue = getClass(this)
                  cur =
                    this.nodeType === 1 &&
                    ' ' + stripAndCollapse(curValue) + ' '

                  if (cur) {
                    for (i = 0; i < classNames.length; i++) {
                      className = classNames[i]
                      if (cur.indexOf(' ' + className + ' ') < 0) {
                        cur += className + ' '
                      }
                    }

                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur)
                    if (curValue !== finalValue) {
                      this.setAttribute('class', finalValue)
                    }
                  }
                })
              }

              return this
            },

            removeClass: function (value) {
              var classNames, cur, curValue, className, i, finalValue

              if (isFunction(value)) {
                return this.each(function (j) {
                  jQuery(this).removeClass(value.call(this, j, getClass(this)))
                })
              }

              if (!arguments.length) {
                return this.attr('class', '')
              }

              classNames = classesToArray(value)

              if (classNames.length) {
                return this.each(function () {
                  curValue = getClass(this)

                  // This expression is here for better compressibility (see addClass)
                  cur =
                    this.nodeType === 1 &&
                    ' ' + stripAndCollapse(curValue) + ' '

                  if (cur) {
                    for (i = 0; i < classNames.length; i++) {
                      className = classNames[i]

                      // Remove *all* instances
                      while (cur.indexOf(' ' + className + ' ') > -1) {
                        cur = cur.replace(' ' + className + ' ', ' ')
                      }
                    }

                    // Only assign if different to avoid unneeded rendering.
                    finalValue = stripAndCollapse(cur)
                    if (curValue !== finalValue) {
                      this.setAttribute('class', finalValue)
                    }
                  }
                })
              }

              return this
            },

            toggleClass: function (value, stateVal) {
              var classNames,
                className,
                i,
                self,
                type = typeof value,
                isValidValue = type === 'string' || Array.isArray(value)

              if (isFunction(value)) {
                return this.each(function (i) {
                  jQuery(this).toggleClass(
                    value.call(this, i, getClass(this), stateVal),
                    stateVal
                  )
                })
              }

              if (typeof stateVal === 'boolean' && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value)
              }

              classNames = classesToArray(value)

              return this.each(function () {
                if (isValidValue) {
                  // Toggle individual class names
                  self = jQuery(this)

                  for (i = 0; i < classNames.length; i++) {
                    className = classNames[i]

                    // Check each className given, space separated list
                    if (self.hasClass(className)) {
                      self.removeClass(className)
                    } else {
                      self.addClass(className)
                    }
                  }

                  // Toggle whole class name
                } else if (value === undefined || type === 'boolean') {
                  className = getClass(this)
                  if (className) {
                    // Store className if set
                    dataPriv.set(this, '__className__', className)
                  }

                  // If the element has a class name or if we're passed `false`,
                  // then remove the whole classname (if there was one, the above saved it).
                  // Otherwise bring back whatever was previously saved (if anything),
                  // falling back to the empty string if nothing was stored.
                  if (this.setAttribute) {
                    this.setAttribute(
                      'class',
                      className || value === false
                        ? ''
                        : dataPriv.get(this, '__className__') || ''
                    )
                  }
                }
              })
            },

            hasClass: function (selector) {
              var className,
                elem,
                i = 0

              className = ' ' + selector + ' '
              while ((elem = this[i++])) {
                if (
                  elem.nodeType === 1 &&
                  (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(
                    className
                  ) > -1
                ) {
                  return true
                }
              }

              return false
            }
          })

          var rreturn = /\r/g

          jQuery.fn.extend({
            val: function (value) {
              var hooks,
                ret,
                valueIsFunction,
                elem = this[0]

              if (!arguments.length) {
                if (elem) {
                  hooks =
                    jQuery.valHooks[elem.type] ||
                    jQuery.valHooks[elem.nodeName.toLowerCase()]

                  if (
                    hooks &&
                    'get' in hooks &&
                    (ret = hooks.get(elem, 'value')) !== undefined
                  ) {
                    return ret
                  }

                  ret = elem.value

                  // Handle most common string cases
                  if (typeof ret === 'string') {
                    return ret.replace(rreturn, '')
                  }

                  // Handle cases where value is null/undef or number
                  return ret == null ? '' : ret
                }

                return
              }

              valueIsFunction = isFunction(value)

              return this.each(function (i) {
                var val

                if (this.nodeType !== 1) {
                  return
                }

                if (valueIsFunction) {
                  val = value.call(this, i, jQuery(this).val())
                } else {
                  val = value
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                  val = ''
                } else if (typeof val === 'number') {
                  val += ''
                } else if (Array.isArray(val)) {
                  val = jQuery.map(val, function (value) {
                    return value == null ? '' : value + ''
                  })
                }

                hooks =
                  jQuery.valHooks[this.type] ||
                  jQuery.valHooks[this.nodeName.toLowerCase()]

                // If set returns undefined, fall back to normal setting
                if (
                  !hooks ||
                  !('set' in hooks) ||
                  hooks.set(this, val, 'value') === undefined
                ) {
                  this.value = val
                }
              })
            }
          })

          jQuery.extend({
            valHooks: {
              option: {
                get: function (elem) {
                  var val = jQuery.find.attr(elem, 'value')
                  return val != null
                    ? val
                    : // Support: IE <=10 - 11 only
                      // option.text throws exceptions (trac-14686, trac-14858)
                      // Strip and collapse whitespace
                      // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                      stripAndCollapse(jQuery.text(elem))
                }
              },
              select: {
                get: function (elem) {
                  var value,
                    option,
                    i,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === 'select-one',
                    values = one ? null : [],
                    max = one ? index + 1 : options.length

                  if (index < 0) {
                    i = max
                  } else {
                    i = one ? index : 0
                  }

                  // Loop through all the selected options
                  for (; i < max; i++) {
                    option = options[i]

                    // Support: IE <=9 only
                    // IE8-9 doesn't update selected after form reset (trac-2551)
                    if (
                      (option.selected || i === index) &&
                      // Don't return options that are disabled or in a disabled optgroup
                      !option.disabled &&
                      (!option.parentNode.disabled ||
                        !nodeName(option.parentNode, 'optgroup'))
                    ) {
                      // Get the specific value for the option
                      value = jQuery(option).val()

                      // We don't need an array for one selects
                      if (one) {
                        return value
                      }

                      // Multi-Selects return an array
                      values.push(value)
                    }
                  }

                  return values
                },

                set: function (elem, value) {
                  var optionSet,
                    option,
                    options = elem.options,
                    values = jQuery.makeArray(value),
                    i = options.length

                  while (i--) {
                    option = options[i]

                    /* eslint-disable no-cond-assign */

                    if (
                      (option.selected =
                        jQuery.inArray(
                          jQuery.valHooks.option.get(option),
                          values
                        ) > -1)
                    ) {
                      optionSet = true
                    }

                    /* eslint-enable no-cond-assign */
                  }

                  // Force browsers to behave consistently when non-matching value is set
                  if (!optionSet) {
                    elem.selectedIndex = -1
                  }
                  return values
                }
              }
            }
          })

          // Radios and checkboxes getter/setter
          jQuery.each(['radio', 'checkbox'], function () {
            jQuery.valHooks[this] = {
              set: function (elem, value) {
                if (Array.isArray(value)) {
                  return (elem.checked =
                    jQuery.inArray(jQuery(elem).val(), value) > -1)
                }
              }
            }
            if (!support.checkOn) {
              jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value
              }
            }
          })

          // Return jQuery for attributes-only inclusion
          var location = window.location

          var nonce = { guid: Date.now() }

          var rquery = /\?/

          // Cross-browser xml parsing
          jQuery.parseXML = function (data) {
            var xml, parserErrorElem
            if (!data || typeof data !== 'string') {
              return null
            }

            // Support: IE 9 - 11 only
            // IE throws on parseFromString with invalid input.
            try {
              xml = new window.DOMParser().parseFromString(data, 'text/xml')
            } catch (e) {}

            parserErrorElem = xml && xml.getElementsByTagName('parsererror')[0]
            if (!xml || parserErrorElem) {
              jQuery.error(
                'Invalid XML: ' +
                  (parserErrorElem
                    ? jQuery
                        .map(parserErrorElem.childNodes, function (el) {
                          return el.textContent
                        })
                        .join('\n')
                    : data)
              )
            }
            return xml
          }

          var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            stopPropagationCallback = function (e) {
              e.stopPropagation()
            }

          jQuery.extend(jQuery.event, {
            trigger: function (event, data, elem, onlyHandlers) {
              var i,
                cur,
                tmp,
                bubbleType,
                ontype,
                handle,
                special,
                lastElement,
                eventPath = [elem || document],
                type = hasOwn.call(event, 'type') ? event.type : event,
                namespaces = hasOwn.call(event, 'namespace')
                  ? event.namespace.split('.')
                  : []

              cur = lastElement = tmp = elem = elem || document

              // Don't do events on text and comment nodes
              if (elem.nodeType === 3 || elem.nodeType === 8) {
                return
              }

              // focus/blur morphs to focusin/out; ensure we're not firing them right now
              if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return
              }

              if (type.indexOf('.') > -1) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split('.')
                type = namespaces.shift()
                namespaces.sort()
              }
              ontype = type.indexOf(':') < 0 && 'on' + type

              // Caller can pass in a jQuery.Event object, Object, or just an event type string
              event = event[jQuery.expando]
                ? event
                : new jQuery.Event(type, typeof event === 'object' && event)

              // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
              event.isTrigger = onlyHandlers ? 2 : 3
              event.namespace = namespaces.join('.')
              event.rnamespace = event.namespace
                ? new RegExp(
                    '(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)'
                  )
                : null

              // Clean up the event in case it is being reused
              event.result = undefined
              if (!event.target) {
                event.target = elem
              }

              // Clone any incoming data and prepend the event, creating the handler arg list
              data = data == null ? [event] : jQuery.makeArray(data, [event])

              // Allow special events to draw outside the lines
              special = jQuery.event.special[type] || {}
              if (
                !onlyHandlers &&
                special.trigger &&
                special.trigger.apply(elem, data) === false
              ) {
                return
              }

              // Determine event propagation path in advance, per W3C events spec (trac-9951)
              // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
              if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type
                if (!rfocusMorph.test(bubbleType + type)) {
                  cur = cur.parentNode
                }
                for (; cur; cur = cur.parentNode) {
                  eventPath.push(cur)
                  tmp = cur
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                  eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                }
              }

              // Fire handlers on the event path
              i = 0
              while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur
                event.type = i > 1 ? bubbleType : special.bindType || type

                // jQuery handler
                handle =
                  (dataPriv.get(cur, 'events') || Object.create(null))[
                    event.type
                  ] && dataPriv.get(cur, 'handle')
                if (handle) {
                  handle.apply(cur, data)
                }

                // Native handler
                handle = ontype && cur[ontype]
                if (handle && handle.apply && acceptData(cur)) {
                  event.result = handle.apply(cur, data)
                  if (event.result === false) {
                    event.preventDefault()
                  }
                }
              }
              event.type = type

              // If nobody prevented the default action, do it now
              if (!onlyHandlers && !event.isDefaultPrevented()) {
                if (
                  (!special._default ||
                    special._default.apply(eventPath.pop(), data) === false) &&
                  acceptData(elem)
                ) {
                  // Call a native DOM method on the target with the same name as the event.
                  // Don't do default actions on window, that's where global variables be (trac-6170)
                  if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                    // Don't re-trigger an onFOO event when we call its FOO() method
                    tmp = elem[ontype]

                    if (tmp) {
                      elem[ontype] = null
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type

                    if (event.isPropagationStopped()) {
                      lastElement.addEventListener(
                        type,
                        stopPropagationCallback
                      )
                    }

                    elem[type]()

                    if (event.isPropagationStopped()) {
                      lastElement.removeEventListener(
                        type,
                        stopPropagationCallback
                      )
                    }

                    jQuery.event.triggered = undefined

                    if (tmp) {
                      elem[ontype] = tmp
                    }
                  }
                }
              }

              return event.result
            },

            // Piggyback on a donor event to simulate a different one
            // Used only for `focus(in | out)` events
            simulate: function (type, elem, event) {
              var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
              })

              jQuery.event.trigger(e, null, elem)
            }
          })

          jQuery.fn.extend({
            trigger: function (type, data) {
              return this.each(function () {
                jQuery.event.trigger(type, data, this)
              })
            },
            triggerHandler: function (type, data) {
              var elem = this[0]
              if (elem) {
                return jQuery.event.trigger(type, data, elem, true)
              }
            }
          })

          var rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i

          function buildParams(prefix, obj, traditional, add) {
            var name

            if (Array.isArray(obj)) {
              // Serialize array item.
              jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                  // Treat each array item as a scalar.
                  add(prefix, v)
                } else {
                  // Item is non-scalar (array or object), encode its numeric index.
                  buildParams(
                    prefix +
                      '[' +
                      (typeof v === 'object' && v != null ? i : '') +
                      ']',
                    v,
                    traditional,
                    add
                  )
                }
              })
            } else if (!traditional && toType(obj) === 'object') {
              // Serialize object item.
              for (name in obj) {
                buildParams(
                  prefix + '[' + name + ']',
                  obj[name],
                  traditional,
                  add
                )
              }
            } else {
              // Serialize scalar item.
              add(prefix, obj)
            }
          }

          // Serialize an array of form elements or a set of
          // key/values into a query string
          jQuery.param = function (a, traditional) {
            var prefix,
              s = [],
              add = function (key, valueOrFunction) {
                // If value is a function, invoke it and use its return value
                var value = isFunction(valueOrFunction)
                  ? valueOrFunction()
                  : valueOrFunction

                s[s.length] =
                  encodeURIComponent(key) +
                  '=' +
                  encodeURIComponent(value == null ? '' : value)
              }

            if (a == null) {
              return ''
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
              // Serialize the form elements
              jQuery.each(a, function () {
                add(this.name, this.value)
              })
            } else {
              // If traditional, encode the "old" way (the way 1.3.2 or older
              // did it), otherwise encode params recursively.
              for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add)
              }
            }

            // Return the resulting serialization
            return s.join('&')
          }

          jQuery.fn.extend({
            serialize: function () {
              return jQuery.param(this.serializeArray())
            },
            serializeArray: function () {
              return this.map(function () {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, 'elements')
                return elements ? jQuery.makeArray(elements) : this
              })
                .filter(function () {
                  var type = this.type

                  // Use .is( ":disabled" ) so that fieldset[disabled] works
                  return (
                    this.name &&
                    !jQuery(this).is(':disabled') &&
                    rsubmittable.test(this.nodeName) &&
                    !rsubmitterTypes.test(type) &&
                    (this.checked || !rcheckableType.test(type))
                  )
                })
                .map(function (_i, elem) {
                  var val = jQuery(this).val()

                  if (val == null) {
                    return null
                  }

                  if (Array.isArray(val)) {
                    return jQuery.map(val, function (val) {
                      return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                      }
                    })
                  }

                  return { name: elem.name, value: val.replace(rCRLF, '\r\n') }
                })
                .get()
            }
          })

          var r20 = /%20/g,
            rhash = /#.*$/,
            rantiCache = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            // trac-7653, trac-8125, trac-8152: local protocol detection
            rlocalProtocol =
              /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            /* Prefilters
             * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
             * 2) These are called:
             *    - BEFORE asking for a transport
             *    - AFTER param serialization (s.data is a string if s.processData is true)
             * 3) key is the dataType
             * 4) the catchall symbol "*" can be used
             * 5) execution will start with transport dataType and THEN continue down to "*" if needed
             */
            prefilters = {},
            /* Transports bindings
             * 1) key is the dataType
             * 2) the catchall symbol "*" can be used
             * 3) selection will start with transport dataType and THEN go to "*" if needed
             */
            transports = {},
            // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
            allTypes = '*/'.concat('*'),
            // Anchor tag for parsing the document origin
            originAnchor = document.createElement('a')

          originAnchor.href = location.href

          // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
          function addToPrefiltersOrTransports(structure) {
            // dataTypeExpression is optional and defaults to "*"
            return function (dataTypeExpression, func) {
              if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression
                dataTypeExpression = '*'
              }

              var dataType,
                i = 0,
                dataTypes =
                  dataTypeExpression.toLowerCase().match(rnothtmlwhite) || []

              if (isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {
                  // Prepend if requested
                  if (dataType[0] === '+') {
                    dataType = dataType.slice(1) || '*'
                    ;(structure[dataType] = structure[dataType] || []).unshift(
                      func
                    )

                    // Otherwise append
                  } else {
                    ;(structure[dataType] = structure[dataType] || []).push(
                      func
                    )
                  }
                }
              }
            }
          }

          // Base inspection function for prefilters and transports
          function inspectPrefiltersOrTransports(
            structure,
            options,
            originalOptions,
            jqXHR
          ) {
            var inspected = {},
              seekingTransport = structure === transports

            function inspect(dataType) {
              var selected
              inspected[dataType] = true
              jQuery.each(
                structure[dataType] || [],
                function (_, prefilterOrFactory) {
                  var dataTypeOrTransport = prefilterOrFactory(
                    options,
                    originalOptions,
                    jqXHR
                  )
                  if (
                    typeof dataTypeOrTransport === 'string' &&
                    !seekingTransport &&
                    !inspected[dataTypeOrTransport]
                  ) {
                    options.dataTypes.unshift(dataTypeOrTransport)
                    inspect(dataTypeOrTransport)
                    return false
                  } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport)
                  }
                }
              )
              return selected
            }

            return (
              inspect(options.dataTypes[0]) || (!inspected['*'] && inspect('*'))
            )
          }

          // A special extend for ajax options
          // that takes "flat" options (not to be deep extended)
          // Fixes trac-9887
          function ajaxExtend(target, src) {
            var key,
              deep,
              flatOptions = jQuery.ajaxSettings.flatOptions || {}

            for (key in src) {
              if (src[key] !== undefined) {
                ;(flatOptions[key] ? target : deep || (deep = {}))[key] =
                  src[key]
              }
            }
            if (deep) {
              jQuery.extend(true, target, deep)
            }

            return target
          }

          /* Handles responses to an ajax request:
           * - finds the right dataType (mediates between content-type and expected dataType)
           * - returns the corresponding response
           */
          function ajaxHandleResponses(s, jqXHR, responses) {
            var ct,
              type,
              finalDataType,
              firstDataType,
              contents = s.contents,
              dataTypes = s.dataTypes

            // Remove auto dataType and get content-type in the process
            while (dataTypes[0] === '*') {
              dataTypes.shift()
              if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type')
              }
            }

            // Check if we're dealing with a known content-type
            if (ct) {
              for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                  dataTypes.unshift(type)
                  break
                }
              }
            }

            // Check to see if we have a response for the expected dataType
            if (dataTypes[0] in responses) {
              finalDataType = dataTypes[0]
            } else {
              // Try convertible dataTypes
              for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                  finalDataType = type
                  break
                }
                if (!firstDataType) {
                  firstDataType = type
                }
              }

              // Or just use first one
              finalDataType = finalDataType || firstDataType
            }

            // If we found a dataType
            // We add the dataType to the list if needed
            // and return the corresponding response
            if (finalDataType) {
              if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType)
              }
              return responses[finalDataType]
            }
          }

          /* Chain conversions given the request and the original response
           * Also sets the responseXXX fields on the jqXHR instance
           */
          function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2,
              current,
              conv,
              tmp,
              prev,
              converters = {},
              // Work with a copy of dataTypes in case we need to modify it for conversion
              dataTypes = s.dataTypes.slice()

            // Create converters map with lowercased keys
            if (dataTypes[1]) {
              for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv]
              }
            }

            current = dataTypes.shift()

            // Convert to each sequential dataType
            while (current) {
              if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response
              }

              // Apply the dataFilter if provided
              if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType)
              }

              prev = current
              current = dataTypes.shift()

              if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === '*') {
                  current = prev

                  // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== '*' && prev !== current) {
                  // Seek a direct converter
                  conv =
                    converters[prev + ' ' + current] ||
                    converters['* ' + current]

                  // If none found, seek a pair
                  if (!conv) {
                    for (conv2 in converters) {
                      // If conv2 outputs current
                      tmp = conv2.split(' ')
                      if (tmp[1] === current) {
                        // If prev can be converted to accepted input
                        conv =
                          converters[prev + ' ' + tmp[0]] ||
                          converters['* ' + tmp[0]]
                        if (conv) {
                          // Condense equivalence converters
                          if (conv === true) {
                            conv = converters[conv2]

                            // Otherwise, insert the intermediate dataType
                          } else if (converters[conv2] !== true) {
                            current = tmp[0]
                            dataTypes.unshift(tmp[1])
                          }
                          break
                        }
                      }
                    }
                  }

                  // Apply converter (if not an equivalence)
                  if (conv !== true) {
                    // Unless errors are allowed to bubble, catch and return them
                    if (conv && s.throws) {
                      response = conv(response)
                    } else {
                      try {
                        response = conv(response)
                      } catch (e) {
                        return {
                          state: 'parsererror',
                          error: conv
                            ? e
                            : 'No conversion from ' + prev + ' to ' + current
                        }
                      }
                    }
                  }
                }
              }
            }

            return { state: 'success', data: response }
          }

          jQuery.extend({
            // Counter for holding the number of active queries
            active: 0,

            // Last-Modified header cache for next request
            lastModified: {},
            etag: {},

            ajaxSettings: {
              url: location.href,
              type: 'GET',
              isLocal: rlocalProtocol.test(location.protocol),
              global: true,
              processData: true,
              async: true,
              contentType: 'application/x-www-form-urlencoded; charset=UTF-8',

              /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

              accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
              },

              contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
              },

              responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
              },

              // Data converters
              // Keys separate source (or catchall "*") and destination types with a single space
              converters: {
                // Convert anything to text
                '* text': String,

                // Text to html (true = no transformation)
                'text html': true,

                // Evaluate text as a json expression
                'text json': JSON.parse,

                // Parse text as xml
                'text xml': jQuery.parseXML
              },

              // For options that shouldn't be deep extended:
              // you can add your own custom options here if
              // and when you create one that shouldn't be
              // deep extended (see ajaxExtend)
              flatOptions: {
                url: true,
                context: true
              }
            },

            // Creates a full fledged settings object into target
            // with both ajaxSettings and settings fields.
            // If target is omitted, writes into ajaxSettings.
            ajaxSetup: function (target, settings) {
              return settings
                ? // Building a settings object
                  ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
                : // Extending ajaxSettings
                  ajaxExtend(jQuery.ajaxSettings, target)
            },

            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),

            // Main method
            ajax: function (url, options) {
              // If url is an object, simulate pre-1.5 signature
              if (typeof url === 'object') {
                options = url
                url = undefined
              }

              // Force options to be an object
              options = options || {}

              var transport,
                // URL without anti-cache param
                cacheURL,
                // Response headers
                responseHeadersString,
                responseHeaders,
                // timeout handle
                timeoutTimer,
                // Url cleanup var
                urlAnchor,
                // Request state (becomes false upon send and true upon completion)
                completed,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // uncached part of the url
                uncached,
                // Create the final options object
                s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext =
                  s.context &&
                  (callbackContext.nodeType || callbackContext.jquery)
                    ? jQuery(callbackContext)
                    : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks('once memory'),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // Default abort message
                strAbort = 'canceled',
                // Fake xhr
                jqXHR = {
                  readyState: 0,

                  // Builds headers hashtable if needed
                  getResponseHeader: function (key) {
                    var match
                    if (completed) {
                      if (!responseHeaders) {
                        responseHeaders = {}
                        while ((match = rheaders.exec(responseHeadersString))) {
                          responseHeaders[match[1].toLowerCase() + ' '] = (
                            responseHeaders[match[1].toLowerCase() + ' '] || []
                          ).concat(match[2])
                        }
                      }
                      match = responseHeaders[key.toLowerCase() + ' ']
                    }
                    return match == null ? null : match.join(', ')
                  },

                  // Raw string
                  getAllResponseHeaders: function () {
                    return completed ? responseHeadersString : null
                  },

                  // Caches the header
                  setRequestHeader: function (name, value) {
                    if (completed == null) {
                      name = requestHeadersNames[name.toLowerCase()] =
                        requestHeadersNames[name.toLowerCase()] || name
                      requestHeaders[name] = value
                    }
                    return this
                  },

                  // Overrides response content-type header
                  overrideMimeType: function (type) {
                    if (completed == null) {
                      s.mimeType = type
                    }
                    return this
                  },

                  // Status-dependent callbacks
                  statusCode: function (map) {
                    var code
                    if (map) {
                      if (completed) {
                        // Execute the appropriate callbacks
                        jqXHR.always(map[jqXHR.status])
                      } else {
                        // Lazy-add the new callbacks in a way that preserves old ones
                        for (code in map) {
                          statusCode[code] = [statusCode[code], map[code]]
                        }
                      }
                    }
                    return this
                  },

                  // Cancel the request
                  abort: function (statusText) {
                    var finalText = statusText || strAbort
                    if (transport) {
                      transport.abort(finalText)
                    }
                    done(0, finalText)
                    return this
                  }
                }

              // Attach deferreds
              deferred.promise(jqXHR)

              // Add protocol if not provided (prefilters might expect it)
              // Handle falsy url in the settings object (trac-10093: consistency with old signature)
              // We also use the url parameter if available
              s.url = ((url || s.url || location.href) + '').replace(
                rprotocol,
                location.protocol + '//'
              )

              // Alias method option to type as per ticket trac-12004
              s.type = options.method || options.type || s.method || s.type

              // Extract dataTypes list
              s.dataTypes = (s.dataType || '*')
                .toLowerCase()
                .match(rnothtmlwhite) || ['']

              // A cross-domain request is in order when the origin doesn't match the current origin.
              if (s.crossDomain == null) {
                urlAnchor = document.createElement('a')

                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                  urlAnchor.href = s.url

                  // Support: IE <=8 - 11 only
                  // Anchor's host property isn't correctly set when s.url is relative
                  urlAnchor.href = urlAnchor.href
                  s.crossDomain =
                    originAnchor.protocol + '//' + originAnchor.host !==
                    urlAnchor.protocol + '//' + urlAnchor.host
                } catch (e) {
                  // If there is an error parsing the URL, assume it is crossDomain,
                  // it can be rejected by the transport if it is invalid
                  s.crossDomain = true
                }
              }

              // Convert data if not already a string
              if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional)
              }

              // Apply prefilters
              inspectPrefiltersOrTransports(prefilters, s, options, jqXHR)

              // If request was aborted inside a prefilter, stop there
              if (completed) {
                return jqXHR
              }

              // We can fire global events as of now if asked to
              // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
              fireGlobals = jQuery.event && s.global

              // Watch for a new set of requests
              if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart')
              }

              // Uppercase the type
              s.type = s.type.toUpperCase()

              // Determine if request has content
              s.hasContent = !rnoContent.test(s.type)

              // Save the URL in case we're toying with the If-Modified-Since
              // and/or If-None-Match header later on
              // Remove hash to simplify url manipulation
              cacheURL = s.url.replace(rhash, '')

              // More options handling for requests with no content
              if (!s.hasContent) {
                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length)

                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === 'string')) {
                  cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data

                  // trac-9682: remove data so that it's not used in an eventual retry
                  delete s.data
                }

                // Add or update anti-cache param if needed
                if (s.cache === false) {
                  cacheURL = cacheURL.replace(rantiCache, '$1')
                  uncached =
                    (rquery.test(cacheURL) ? '&' : '?') +
                    '_=' +
                    nonce.guid++ +
                    uncached
                }

                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached

                // Change '%20' to '+' if this is encoded form body content (gh-2658)
              } else if (
                s.data &&
                s.processData &&
                (s.contentType || '').indexOf(
                  'application/x-www-form-urlencoded'
                ) === 0
              ) {
                s.data = s.data.replace(r20, '+')
              }

              // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
              if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                  jqXHR.setRequestHeader(
                    'If-Modified-Since',
                    jQuery.lastModified[cacheURL]
                  )
                }
                if (jQuery.etag[cacheURL]) {
                  jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL])
                }
              }

              // Set the correct header, if data is being sent
              if (
                (s.data && s.hasContent && s.contentType !== false) ||
                options.contentType
              ) {
                jqXHR.setRequestHeader('Content-Type', s.contentType)
              }

              // Set the Accepts header for the server, depending on the dataType
              jqXHR.setRequestHeader(
                'Accept',
                s.dataTypes[0] && s.accepts[s.dataTypes[0]]
                  ? s.accepts[s.dataTypes[0]] +
                      (s.dataTypes[0] !== '*'
                        ? ', ' + allTypes + '; q=0.01'
                        : '')
                  : s.accepts['*']
              )

              // Check for headers option
              for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i])
              }

              // Allow custom headers/mimetypes and early abort
              if (
                s.beforeSend &&
                (s.beforeSend.call(callbackContext, jqXHR, s) === false ||
                  completed)
              ) {
                // Abort if not done already and return
                return jqXHR.abort()
              }

              // Aborting is no longer a cancellation
              strAbort = 'abort'

              // Install callbacks on deferreds
              completeDeferred.add(s.complete)
              jqXHR.done(s.success)
              jqXHR.fail(s.error)

              // Get transport
              transport = inspectPrefiltersOrTransports(
                transports,
                s,
                options,
                jqXHR
              )

              // If no transport, we auto-abort
              if (!transport) {
                done(-1, 'No Transport')
              } else {
                jqXHR.readyState = 1

                // Send global event
                if (fireGlobals) {
                  globalEventContext.trigger('ajaxSend', [jqXHR, s])
                }

                // If request was aborted inside ajaxSend, stop there
                if (completed) {
                  return jqXHR
                }

                // Timeout
                if (s.async && s.timeout > 0) {
                  timeoutTimer = window.setTimeout(function () {
                    jqXHR.abort('timeout')
                  }, s.timeout)
                }

                try {
                  completed = false
                  transport.send(requestHeaders, done)
                } catch (e) {
                  // Rethrow post-completion exceptions
                  if (completed) {
                    throw e
                  }

                  // Propagate others as results
                  done(-1, e)
                }
              }

              // Callback for when everything is done
              function done(status, nativeStatusText, responses, headers) {
                var isSuccess,
                  success,
                  error,
                  response,
                  modified,
                  statusText = nativeStatusText

                // Ignore repeat invocations
                if (completed) {
                  return
                }

                completed = true

                // Clear timeout if it exists
                if (timeoutTimer) {
                  window.clearTimeout(timeoutTimer)
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined

                // Cache response headers
                responseHeadersString = headers || ''

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0

                // Determine if successful
                isSuccess = (status >= 200 && status < 300) || status === 304

                // Get response data
                if (responses) {
                  response = ajaxHandleResponses(s, jqXHR, responses)
                }

                // Use a noop converter for missing script but not if jsonp
                if (
                  !isSuccess &&
                  jQuery.inArray('script', s.dataTypes) > -1 &&
                  jQuery.inArray('json', s.dataTypes) < 0
                ) {
                  s.converters['text script'] = function () {}
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess)

                // If successful, handle type chaining
                if (isSuccess) {
                  // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                  if (s.ifModified) {
                    modified = jqXHR.getResponseHeader('Last-Modified')
                    if (modified) {
                      jQuery.lastModified[cacheURL] = modified
                    }
                    modified = jqXHR.getResponseHeader('etag')
                    if (modified) {
                      jQuery.etag[cacheURL] = modified
                    }
                  }

                  // if no content
                  if (status === 204 || s.type === 'HEAD') {
                    statusText = 'nocontent'

                    // if not modified
                  } else if (status === 304) {
                    statusText = 'notmodified'

                    // If we have data, let's convert it
                  } else {
                    statusText = response.state
                    success = response.data
                    error = response.error
                    isSuccess = !error
                  }
                } else {
                  // Extract error from statusText and normalize for non-aborts
                  error = statusText
                  if (status || !statusText) {
                    statusText = 'error'
                    if (status < 0) {
                      status = 0
                    }
                  }
                }

                // Set data for the fake xhr object
                jqXHR.status = status
                jqXHR.statusText = (nativeStatusText || statusText) + ''

                // Success/Error
                if (isSuccess) {
                  deferred.resolveWith(callbackContext, [
                    success,
                    statusText,
                    jqXHR
                  ])
                } else {
                  deferred.rejectWith(callbackContext, [
                    jqXHR,
                    statusText,
                    error
                  ])
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode)
                statusCode = undefined

                if (fireGlobals) {
                  globalEventContext.trigger(
                    isSuccess ? 'ajaxSuccess' : 'ajaxError',
                    [jqXHR, s, isSuccess ? success : error]
                  )
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText])

                if (fireGlobals) {
                  globalEventContext.trigger('ajaxComplete', [jqXHR, s])

                  // Handle the global AJAX counter
                  if (!--jQuery.active) {
                    jQuery.event.trigger('ajaxStop')
                  }
                }
              }

              return jqXHR
            },

            getJSON: function (url, data, callback) {
              return jQuery.get(url, data, callback, 'json')
            },

            getScript: function (url, callback) {
              return jQuery.get(url, undefined, callback, 'script')
            }
          })

          jQuery.each(['get', 'post'], function (_i, method) {
            jQuery[method] = function (url, data, callback, type) {
              // Shift arguments if data argument was omitted
              if (isFunction(data)) {
                type = type || callback
                callback = data
                data = undefined
              }

              // The url can be an options object (which then must have .url)
              return jQuery.ajax(
                jQuery.extend(
                  {
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                  },
                  jQuery.isPlainObject(url) && url
                )
              )
            }
          })

          jQuery.ajaxPrefilter(function (s) {
            var i
            for (i in s.headers) {
              if (i.toLowerCase() === 'content-type') {
                s.contentType = s.headers[i] || ''
              }
            }
          })

          jQuery._evalUrl = function (url, options, doc) {
            return jQuery.ajax({
              url: url,

              // Make this explicit, since user can override this through ajaxSetup (trac-11264)
              type: 'GET',
              dataType: 'script',
              cache: true,
              async: false,
              global: false,

              // Only evaluate the response if it is successful (gh-4126)
              // dataFilter is not invoked for failure responses, so using it instead
              // of the default converter is kludgy but it works.
              converters: {
                'text script': function () {}
              },
              dataFilter: function (response) {
                jQuery.globalEval(response, options, doc)
              }
            })
          }

          jQuery.fn.extend({
            wrapAll: function (html) {
              var wrap

              if (this[0]) {
                if (isFunction(html)) {
                  html = html.call(this[0])
                }

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true)

                if (this[0].parentNode) {
                  wrap.insertBefore(this[0])
                }

                wrap
                  .map(function () {
                    var elem = this

                    while (elem.firstElementChild) {
                      elem = elem.firstElementChild
                    }

                    return elem
                  })
                  .append(this)
              }

              return this
            },

            wrapInner: function (html) {
              if (isFunction(html)) {
                return this.each(function (i) {
                  jQuery(this).wrapInner(html.call(this, i))
                })
              }

              return this.each(function () {
                var self = jQuery(this),
                  contents = self.contents()

                if (contents.length) {
                  contents.wrapAll(html)
                } else {
                  self.append(html)
                }
              })
            },

            wrap: function (html) {
              var htmlIsFunction = isFunction(html)

              return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
              })
            },

            unwrap: function (selector) {
              this.parent(selector)
                .not('body')
                .each(function () {
                  jQuery(this).replaceWith(this.childNodes)
                })
              return this
            }
          })

          jQuery.expr.pseudos.hidden = function (elem) {
            return !jQuery.expr.pseudos.visible(elem)
          }
          jQuery.expr.pseudos.visible = function (elem) {
            return !!(
              elem.offsetWidth ||
              elem.offsetHeight ||
              elem.getClientRects().length
            )
          }

          jQuery.ajaxSettings.xhr = function () {
            try {
              return new window.XMLHttpRequest()
            } catch (e) {}
          }

          var xhrSuccessStatus = {
              // File protocol always yields status code 0, assume 200
              0: 200,

              // Support: IE <=9 only
              // trac-1450: sometimes IE returns 1223 when it should be 204
              1223: 204
            },
            xhrSupported = jQuery.ajaxSettings.xhr()

          support.cors = !!xhrSupported && 'withCredentials' in xhrSupported
          support.ajax = xhrSupported = !!xhrSupported

          jQuery.ajaxTransport(function (options) {
            var callback, errorCallback

            // Cross domain only allowed if supported through XMLHttpRequest
            if (support.cors || (xhrSupported && !options.crossDomain)) {
              return {
                send: function (headers, complete) {
                  var i,
                    xhr = options.xhr()

                  xhr.open(
                    options.type,
                    options.url,
                    options.async,
                    options.username,
                    options.password
                  )

                  // Apply custom fields if provided
                  if (options.xhrFields) {
                    for (i in options.xhrFields) {
                      xhr[i] = options.xhrFields[i]
                    }
                  }

                  // Override mime type if needed
                  if (options.mimeType && xhr.overrideMimeType) {
                    xhr.overrideMimeType(options.mimeType)
                  }

                  // X-Requested-With header
                  // For cross-domain requests, seeing as conditions for a preflight are
                  // akin to a jigsaw puzzle, we simply never set it to be sure.
                  // (it can always be set on a per-request basis or even using ajaxSetup)
                  // For same-domain requests, won't change header if already provided.
                  if (!options.crossDomain && !headers['X-Requested-With']) {
                    headers['X-Requested-With'] = 'XMLHttpRequest'
                  }

                  // Set headers
                  for (i in headers) {
                    xhr.setRequestHeader(i, headers[i])
                  }

                  // Callback
                  callback = function (type) {
                    return function () {
                      if (callback) {
                        callback =
                          errorCallback =
                          xhr.onload =
                          xhr.onerror =
                          xhr.onabort =
                          xhr.ontimeout =
                          xhr.onreadystatechange =
                            null

                        if (type === 'abort') {
                          xhr.abort()
                        } else if (type === 'error') {
                          // Support: IE <=9 only
                          // On a manual native abort, IE9 throws
                          // errors on any property access that is not readyState
                          if (typeof xhr.status !== 'number') {
                            complete(0, 'error')
                          } else {
                            complete(
                              // File: protocol always yields status 0; see trac-8605, trac-14207
                              xhr.status,
                              xhr.statusText
                            )
                          }
                        } else {
                          complete(
                            xhrSuccessStatus[xhr.status] || xhr.status,
                            xhr.statusText,

                            // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || 'text') !== 'text' ||
                              typeof xhr.responseText !== 'string'
                              ? { binary: xhr.response }
                              : { text: xhr.responseText },
                            xhr.getAllResponseHeaders()
                          )
                        }
                      }
                    }
                  }

                  // Listen to events
                  xhr.onload = callback()
                  errorCallback =
                    xhr.onerror =
                    xhr.ontimeout =
                      callback('error')

                  // Support: IE 9 only
                  // Use onreadystatechange to replace onabort
                  // to handle uncaught aborts
                  if (xhr.onabort !== undefined) {
                    xhr.onabort = errorCallback
                  } else {
                    xhr.onreadystatechange = function () {
                      // Check readyState before timeout as it changes
                      if (xhr.readyState === 4) {
                        // Allow onerror to be called first,
                        // but that will not handle a native abort
                        // Also, save errorCallback to a variable
                        // as xhr.onerror cannot be accessed
                        window.setTimeout(function () {
                          if (callback) {
                            errorCallback()
                          }
                        })
                      }
                    }
                  }

                  // Create the abort callback
                  callback = callback('abort')

                  try {
                    // Do send the request (this may raise an exception)
                    xhr.send((options.hasContent && options.data) || null)
                  } catch (e) {
                    // trac-14683: Only rethrow if this hasn't been notified as an error yet
                    if (callback) {
                      throw e
                    }
                  }
                },

                abort: function () {
                  if (callback) {
                    callback()
                  }
                }
              }
            }
          })

          // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
          jQuery.ajaxPrefilter(function (s) {
            if (s.crossDomain) {
              s.contents.script = false
            }
          })

          // Install script dataType
          jQuery.ajaxSetup({
            accepts: {
              script:
                'text/javascript, application/javascript, ' +
                'application/ecmascript, application/x-ecmascript'
            },
            contents: {
              script: /\b(?:java|ecma)script\b/
            },
            converters: {
              'text script': function (text) {
                jQuery.globalEval(text)
                return text
              }
            }
          })

          // Handle cache's special case and crossDomain
          jQuery.ajaxPrefilter('script', function (s) {
            if (s.cache === undefined) {
              s.cache = false
            }
            if (s.crossDomain) {
              s.type = 'GET'
            }
          })

          // Bind script tag hack transport
          jQuery.ajaxTransport('script', function (s) {
            // This transport only deals with cross domain or forced-by-attrs requests
            if (s.crossDomain || s.scriptAttrs) {
              var script, callback
              return {
                send: function (_, complete) {
                  script = jQuery('<script>')
                    .attr(s.scriptAttrs || {})
                    .prop({ charset: s.scriptCharset, src: s.url })
                    .on(
                      'load error',
                      (callback = function (evt) {
                        script.remove()
                        callback = null
                        if (evt) {
                          complete(evt.type === 'error' ? 404 : 200, evt.type)
                        }
                      })
                    )

                  // Use native DOM manipulation to avoid our domManip AJAX trickery
                  document.head.appendChild(script[0])
                },
                abort: function () {
                  if (callback) {
                    callback()
                  }
                }
              }
            }
          })

          var oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/

          // Default jsonp settings
          jQuery.ajaxSetup({
            jsonp: 'callback',
            jsonpCallback: function () {
              var callback =
                oldCallbacks.pop() || jQuery.expando + '_' + nonce.guid++
              this[callback] = true
              return callback
            }
          })

          // Detect, normalize options and install callbacks for jsonp requests
          jQuery.ajaxPrefilter(
            'json jsonp',
            function (s, originalSettings, jqXHR) {
              var callbackName,
                overwritten,
                responseContainer,
                jsonProp =
                  s.jsonp !== false &&
                  (rjsonp.test(s.url)
                    ? 'url'
                    : typeof s.data === 'string' &&
                      (s.contentType || '').indexOf(
                        'application/x-www-form-urlencoded'
                      ) === 0 &&
                      rjsonp.test(s.data) &&
                      'data')

              // Handle iff the expected data type is "jsonp" or we have a parameter to set
              if (jsonProp || s.dataTypes[0] === 'jsonp') {
                // Get callback name, remembering preexisting value associated with it
                callbackName = s.jsonpCallback = isFunction(s.jsonpCallback)
                  ? s.jsonpCallback()
                  : s.jsonpCallback

                // Insert callback into url or form data
                if (jsonProp) {
                  s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName)
                } else if (s.jsonp !== false) {
                  s.url +=
                    (rquery.test(s.url) ? '&' : '?') +
                    s.jsonp +
                    '=' +
                    callbackName
                }

                // Use data converter to retrieve json after script execution
                s.converters['script json'] = function () {
                  if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called')
                  }
                  return responseContainer[0]
                }

                // Force json dataType
                s.dataTypes[0] = 'json'

                // Install callback
                overwritten = window[callbackName]
                window[callbackName] = function () {
                  responseContainer = arguments
                }

                // Clean-up function (fires after converters)
                jqXHR.always(function () {
                  // If previous value didn't exist - remove it
                  if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName)

                    // Otherwise restore preexisting value
                  } else {
                    window[callbackName] = overwritten
                  }

                  // Save back as free
                  if (s[callbackName]) {
                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback

                    // Save the callback name for future use
                    oldCallbacks.push(callbackName)
                  }

                  // Call if it was a function and we have a response
                  if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0])
                  }

                  responseContainer = overwritten = undefined
                })

                // Delegate to script
                return 'script'
              }
            }
          )

          // Support: Safari 8 only
          // In Safari 8 documents created via document.implementation.createHTMLDocument
          // collapse sibling forms: the second one becomes a child of the first one.
          // Because of that, this security measure has to be disabled in Safari 8.
          // https://bugs.webkit.org/show_bug.cgi?id=137337
          support.createHTMLDocument = (function () {
            var body = document.implementation.createHTMLDocument('').body
            body.innerHTML = '<form></form><form></form>'
            return body.childNodes.length === 2
          })()

          // Argument "data" should be string of html
          // context (optional): If specified, the fragment will be created in this context,
          // defaults to document
          // keepScripts (optional): If true, will include scripts passed in the html string
          jQuery.parseHTML = function (data, context, keepScripts) {
            if (typeof data !== 'string') {
              return []
            }
            if (typeof context === 'boolean') {
              keepScripts = context
              context = false
            }

            var base, parsed, scripts

            if (!context) {
              // Stop scripts or inline event handlers from being executed immediately
              // by using document.implementation
              if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument('')

                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement('base')
                base.href = document.location.href
                context.head.appendChild(base)
              } else {
                context = document
              }
            }

            parsed = rsingleTag.exec(data)
            scripts = !keepScripts && []

            // Single tag
            if (parsed) {
              return [context.createElement(parsed[1])]
            }

            parsed = buildFragment([data], context, scripts)

            if (scripts && scripts.length) {
              jQuery(scripts).remove()
            }

            return jQuery.merge([], parsed.childNodes)
          }

          /**
           * Load a url into a page
           */
          jQuery.fn.load = function (url, params, callback) {
            var selector,
              type,
              response,
              self = this,
              off = url.indexOf(' ')

            if (off > -1) {
              selector = stripAndCollapse(url.slice(off))
              url = url.slice(0, off)
            }

            // If it's a function
            if (isFunction(params)) {
              // We assume that it's the callback
              callback = params
              params = undefined

              // Otherwise, build a param string
            } else if (params && typeof params === 'object') {
              type = 'POST'
            }

            // If we have elements to modify, make the request
            if (self.length > 0) {
              jQuery
                .ajax({
                  url: url,

                  // If "type" variable is undefined, then "GET" method will be used.
                  // Make value of this field explicit since
                  // user can override it through ajaxSetup method
                  type: type || 'GET',
                  dataType: 'html',
                  data: params
                })
                .done(function (responseText) {
                  // Save response for use in complete callback
                  response = arguments

                  self.html(
                    selector
                      ? // If a selector was specified, locate the right elements in a dummy div
                        // Exclude scripts to avoid IE 'Permission Denied' errors
                        jQuery('<div>')
                          .append(jQuery.parseHTML(responseText))
                          .find(selector)
                      : // Otherwise use the full result
                        responseText
                  )

                  // If the request succeeds, this function gets "data", "status", "jqXHR"
                  // but they are ignored because response was set above.
                  // If it fails, this function gets "jqXHR", "status", "error"
                })
                .always(
                  callback &&
                    function (jqXHR, status) {
                      self.each(function () {
                        callback.apply(
                          this,
                          response || [jqXHR.responseText, status, jqXHR]
                        )
                      })
                    }
                )
            }

            return this
          }

          jQuery.expr.pseudos.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
              return elem === fn.elem
            }).length
          }

          jQuery.offset = {
            setOffset: function (elem, options, i) {
              var curPosition,
                curLeft,
                curCSSTop,
                curTop,
                curOffset,
                curCSSLeft,
                calculatePosition,
                position = jQuery.css(elem, 'position'),
                curElem = jQuery(elem),
                props = {}

              // Set position first, in-case top/left are set even on static elem
              if (position === 'static') {
                elem.style.position = 'relative'
              }

              curOffset = curElem.offset()
              curCSSTop = jQuery.css(elem, 'top')
              curCSSLeft = jQuery.css(elem, 'left')
              calculatePosition =
                (position === 'absolute' || position === 'fixed') &&
                (curCSSTop + curCSSLeft).indexOf('auto') > -1

              // Need to be able to calculate position if either
              // top or left is auto and position is either absolute or fixed
              if (calculatePosition) {
                curPosition = curElem.position()
                curTop = curPosition.top
                curLeft = curPosition.left
              } else {
                curTop = parseFloat(curCSSTop) || 0
                curLeft = parseFloat(curCSSLeft) || 0
              }

              if (isFunction(options)) {
                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call(elem, i, jQuery.extend({}, curOffset))
              }

              if (options.top != null) {
                props.top = options.top - curOffset.top + curTop
              }
              if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft
              }

              if ('using' in options) {
                options.using.call(elem, props)
              } else {
                curElem.css(props)
              }
            }
          }

          jQuery.fn.extend({
            // offset() relates an element's border box to the document origin
            offset: function (options) {
              // Preserve chaining for setter
              if (arguments.length) {
                return options === undefined
                  ? this
                  : this.each(function (i) {
                      jQuery.offset.setOffset(this, options, i)
                    })
              }

              var rect,
                win,
                elem = this[0]

              if (!elem) {
                return
              }

              // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
              // Support: IE <=11 only
              // Running getBoundingClientRect on a
              // disconnected node in IE throws an error
              if (!elem.getClientRects().length) {
                return { top: 0, left: 0 }
              }

              // Get document-relative position by adding viewport scroll to viewport-relative gBCR
              rect = elem.getBoundingClientRect()
              win = elem.ownerDocument.defaultView
              return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
              }
            },

            // position() relates an element's margin box to its offset parent's padding box
            // This corresponds to the behavior of CSS absolute positioning
            position: function () {
              if (!this[0]) {
                return
              }

              var offsetParent,
                offset,
                doc,
                elem = this[0],
                parentOffset = { top: 0, left: 0 }

              // position:fixed elements are offset from the viewport, which itself always has zero offset
              if (jQuery.css(elem, 'position') === 'fixed') {
                // Assume position:fixed implies availability of getBoundingClientRect
                offset = elem.getBoundingClientRect()
              } else {
                offset = this.offset()

                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument
                offsetParent = elem.offsetParent || doc.documentElement
                while (
                  offsetParent &&
                  (offsetParent === doc.body ||
                    offsetParent === doc.documentElement) &&
                  jQuery.css(offsetParent, 'position') === 'static'
                ) {
                  offsetParent = offsetParent.parentNode
                }
                if (
                  offsetParent &&
                  offsetParent !== elem &&
                  offsetParent.nodeType === 1
                ) {
                  // Incorporate borders into its offset, since they are outside its content origin
                  parentOffset = jQuery(offsetParent).offset()
                  parentOffset.top += jQuery.css(
                    offsetParent,
                    'borderTopWidth',
                    true
                  )
                  parentOffset.left += jQuery.css(
                    offsetParent,
                    'borderLeftWidth',
                    true
                  )
                }
              }

              // Subtract parent offsets and element margins
              return {
                top:
                  offset.top -
                  parentOffset.top -
                  jQuery.css(elem, 'marginTop', true),
                left:
                  offset.left -
                  parentOffset.left -
                  jQuery.css(elem, 'marginLeft', true)
              }
            },

            // This method will return documentElement in the following cases:
            // 1) For the element inside the iframe without offsetParent, this method will return
            //    documentElement of the parent window
            // 2) For the hidden or detached element
            // 3) For body or html element, i.e. in case of the html node - it will return itself
            //
            // but those exceptions were never presented as a real life use-cases
            // and might be considered as more preferable results.
            //
            // This logic, however, is not guaranteed and can change at any point in the future
            offsetParent: function () {
              return this.map(function () {
                var offsetParent = this.offsetParent

                while (
                  offsetParent &&
                  jQuery.css(offsetParent, 'position') === 'static'
                ) {
                  offsetParent = offsetParent.offsetParent
                }

                return offsetParent || documentElement
              })
            }
          })

          // Create scrollLeft and scrollTop methods
          jQuery.each(
            { scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' },
            function (method, prop) {
              var top = 'pageYOffset' === prop

              jQuery.fn[method] = function (val) {
                return access(
                  this,
                  function (elem, method, val) {
                    // Coalesce documents and windows
                    var win
                    if (isWindow(elem)) {
                      win = elem
                    } else if (elem.nodeType === 9) {
                      win = elem.defaultView
                    }

                    if (val === undefined) {
                      return win ? win[prop] : elem[method]
                    }

                    if (win) {
                      win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                      )
                    } else {
                      elem[method] = val
                    }
                  },
                  method,
                  val,
                  arguments.length
                )
              }
            }
          )

          // Support: Safari <=7 - 9.1, Chrome <=37 - 49
          // Add the top/left cssHooks using jQuery.fn.position
          // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
          // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
          // getComputedStyle returns percent when specified for top/left/bottom/right;
          // rather than make the css module depend on the offset module, just check for it here
          jQuery.each(['top', 'left'], function (_i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(
              support.pixelPosition,
              function (elem, computed) {
                if (computed) {
                  computed = curCSS(elem, prop)

                  // If curCSS returns percentage, fallback to offset
                  return rnumnonpx.test(computed)
                    ? jQuery(elem).position()[prop] + 'px'
                    : computed
                }
              }
            )
          })

          // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
          jQuery.each(
            { Height: 'height', Width: 'width' },
            function (name, type) {
              jQuery.each(
                {
                  padding: 'inner' + name,
                  content: type,
                  '': 'outer' + name
                },
                function (defaultExtra, funcName) {
                  // Margin is only for outerHeight, outerWidth
                  jQuery.fn[funcName] = function (margin, value) {
                    var chainable =
                        arguments.length &&
                        (defaultExtra || typeof margin !== 'boolean'),
                      extra =
                        defaultExtra ||
                        (margin === true || value === true
                          ? 'margin'
                          : 'border')

                    return access(
                      this,
                      function (elem, type, value) {
                        var doc

                        if (isWindow(elem)) {
                          // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                          return funcName.indexOf('outer') === 0
                            ? elem['inner' + name]
                            : elem.document.documentElement['client' + name]
                        }

                        // Get document width or height
                        if (elem.nodeType === 9) {
                          doc = elem.documentElement

                          // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                          // whichever is greatest
                          return Math.max(
                            elem.body['scroll' + name],
                            doc['scroll' + name],
                            elem.body['offset' + name],
                            doc['offset' + name],
                            doc['client' + name]
                          )
                        }

                        return value === undefined
                          ? // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css(elem, type, extra)
                          : // Set width or height on the element
                            jQuery.style(elem, type, value, extra)
                      },
                      type,
                      chainable ? margin : undefined,
                      chainable
                    )
                  }
                }
              )
            }
          )

          jQuery.each(
            [
              'ajaxStart',
              'ajaxStop',
              'ajaxComplete',
              'ajaxError',
              'ajaxSuccess',
              'ajaxSend'
            ],
            function (_i, type) {
              jQuery.fn[type] = function (fn) {
                return this.on(type, fn)
              }
            }
          )

          jQuery.fn.extend({
            bind: function (types, data, fn) {
              return this.on(types, null, data, fn)
            },
            unbind: function (types, fn) {
              return this.off(types, null, fn)
            },

            delegate: function (selector, types, data, fn) {
              return this.on(types, selector, data, fn)
            },
            undelegate: function (selector, types, fn) {
              // ( namespace ) or ( selector, types [, fn] )
              return arguments.length === 1
                ? this.off(selector, '**')
                : this.off(types, selector || '**', fn)
            },

            hover: function (fnOver, fnOut) {
              return this.on('mouseenter', fnOver).on(
                'mouseleave',
                fnOut || fnOver
              )
            }
          })

          jQuery.each(
            (
              'blur focus focusin focusout resize scroll click dblclick ' +
              'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
              'change select submit keydown keypress keyup contextmenu'
            ).split(' '),
            function (_i, name) {
              // Handle event binding
              jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0
                  ? this.on(name, null, data, fn)
                  : this.trigger(name)
              }
            }
          )

          // Support: Android <=4.0 only
          // Make sure we trim BOM and NBSP
          // Require that the "whitespace run" starts from a non-whitespace
          // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
          var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g

          // Bind a function to a context, optionally partially applying any
          // arguments.
          // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
          // However, it is not slated for removal any time soon
          jQuery.proxy = function (fn, context) {
            var tmp, args, proxy

            if (typeof context === 'string') {
              tmp = fn[context]
              context = fn
              fn = tmp
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!isFunction(fn)) {
              return undefined
            }

            // Simulated bind
            args = slice.call(arguments, 2)
            proxy = function () {
              return fn.apply(
                context || this,
                args.concat(slice.call(arguments))
              )
            }

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++

            return proxy
          }

          jQuery.holdReady = function (hold) {
            if (hold) {
              jQuery.readyWait++
            } else {
              jQuery.ready(true)
            }
          }
          jQuery.isArray = Array.isArray
          jQuery.parseJSON = JSON.parse
          jQuery.nodeName = nodeName
          jQuery.isFunction = isFunction
          jQuery.isWindow = isWindow
          jQuery.camelCase = camelCase
          jQuery.type = toType

          jQuery.now = Date.now

          jQuery.isNumeric = function (obj) {
            // As of jQuery 3.0, isNumeric is limited to
            // strings and numbers (primitives or objects)
            // that can be coerced to finite numbers (gh-2662)
            var type = jQuery.type(obj)
            return (
              (type === 'number' || type === 'string') &&
              // parseFloat NaNs numeric-cast false positives ("")
              // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
              // subtraction forces infinities to NaN
              !isNaN(obj - parseFloat(obj))
            )
          }

          jQuery.trim = function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '$1')
          }

          // Register as a named AMD module, since jQuery can be concatenated with other
          // files that may use define, but not via a proper concatenation script that
          // understands anonymous AMD modules. A named AMD is safest and most robust
          // way to register. Lowercase jquery is used because AMD module names are
          // derived from file names, and jQuery is normally delivered in a lowercase
          // file name. Do this after creating the global so that if an AMD module wants
          // to call noConflict to hide this version of jQuery, it will work.

          // Note that for maximum portability, libraries that are not jQuery should
          // declare themselves as anonymous modules, and avoid setting a global if an
          // AMD loader is present. jQuery is a special case. For more information, see
          // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

          if (true) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
              return jQuery
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
          }

          var // Map over jQuery in case of overwrite
            _jQuery = window.jQuery,
            // Map over the $ in case of overwrite
            _$ = window.$

          jQuery.noConflict = function (deep) {
            if (window.$ === jQuery) {
              window.$ = _$
            }

            if (deep && window.jQuery === jQuery) {
              window.jQuery = _jQuery
            }

            return jQuery
          }

          // Expose jQuery and $ identifiers, even in AMD
          // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
          // and CommonJS for browser emulators (trac-13566)
          if (typeof noGlobal === 'undefined') {
            window.jQuery = window.$ = jQuery
          }

          return jQuery
        }
      )

      /***/
    },

    /***/ 9461: /***/ (module) => {
      'use strict'

      var traverse = (module.exports = function (schema, opts, cb) {
        // Legacy support for v0.3.1 and earlier.
        if (typeof opts == 'function') {
          cb = opts
          opts = {}
        }

        cb = opts.cb || cb
        var pre = typeof cb == 'function' ? cb : cb.pre || function () {}
        var post = cb.post || function () {}

        _traverse(opts, pre, post, schema, '', schema)
      })

      traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
        if: true,
        then: true,
        else: true
      }

      traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      }

      traverse.propsKeywords = {
        $defs: true,
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      }

      traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      }

      function _traverse(
        opts,
        pre,
        post,
        schema,
        jsonPtr,
        rootSchema,
        parentJsonPtr,
        parentKeyword,
        parentSchema,
        keyIndex
      ) {
        if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
          pre(
            schema,
            jsonPtr,
            rootSchema,
            parentJsonPtr,
            parentKeyword,
            parentSchema,
            keyIndex
          )
          for (var key in schema) {
            var sch = schema[key]
            if (Array.isArray(sch)) {
              if (key in traverse.arrayKeywords) {
                for (var i = 0; i < sch.length; i++)
                  _traverse(
                    opts,
                    pre,
                    post,
                    sch[i],
                    jsonPtr + '/' + key + '/' + i,
                    rootSchema,
                    jsonPtr,
                    key,
                    schema,
                    i
                  )
              }
            } else if (key in traverse.propsKeywords) {
              if (sch && typeof sch == 'object') {
                for (var prop in sch)
                  _traverse(
                    opts,
                    pre,
                    post,
                    sch[prop],
                    jsonPtr + '/' + key + '/' + escapeJsonPtr(prop),
                    rootSchema,
                    jsonPtr,
                    key,
                    schema,
                    prop
                  )
              }
            } else if (
              key in traverse.keywords ||
              (opts.allKeys && !(key in traverse.skipKeywords))
            ) {
              _traverse(
                opts,
                pre,
                post,
                sch,
                jsonPtr + '/' + key,
                rootSchema,
                jsonPtr,
                key,
                schema
              )
            }
          }
          post(
            schema,
            jsonPtr,
            rootSchema,
            parentJsonPtr,
            parentKeyword,
            parentSchema,
            keyIndex
          )
        }
      }

      function escapeJsonPtr(str) {
        return str.replace(/~/g, '~0').replace(/\//g, '~1')
      }

      /***/
    },

    /***/ 2837: /***/ () => {
      /***/
    },

    /***/ 5311: /***/ function (
      __unused_webpack_module,
      exports,
      __webpack_require__
    ) {
      ;(function (global, factory) {
        true ? factory(exports, __webpack_require__(2837)) : 0
      })(this, function (exports, chalk) {
        'use strict'

        class Processor {
          constructor(options) {
            this.selfOptions = options || {}
            this.pipes = {}
          }
          options(options) {
            if (options) {
              this.selfOptions = options
            }
            return this.selfOptions
          }
          pipe(name, pipeArg) {
            let pipe = pipeArg
            if (typeof name === 'string') {
              if (typeof pipe === 'undefined') {
                return this.pipes[name]
              } else {
                this.pipes[name] = pipe
              }
            }
            if (name && name.name) {
              pipe = name
              if (pipe.processor === this) {
                return pipe
              }
              this.pipes[pipe.name] = pipe
            }
            pipe.processor = this
            return pipe
          }
          process(input, pipe) {
            let context = input
            context.options = this.options()
            let nextPipe = pipe || input.pipe || 'default'
            let lastPipe
            let lastContext
            while (nextPipe) {
              if (typeof context.nextAfterChildren !== 'undefined') {
                // children processed and coming back to parent
                context.next = context.nextAfterChildren
                context.nextAfterChildren = null
              }
              if (typeof nextPipe === 'string') {
                nextPipe = this.pipe(nextPipe)
              }
              nextPipe.process(context)
              lastContext = context
              lastPipe = nextPipe
              nextPipe = null
              if (context) {
                if (context.next) {
                  context = context.next
                  nextPipe = lastContext.nextPipe || context.pipe || lastPipe
                }
              }
            }
            return context.hasResult ? context.result : undefined
          }
        }

        class Pipe {
          constructor(name) {
            this.name = name
            this.filters = []
          }
          process(input) {
            if (!this.processor) {
              throw new Error('add this pipe to a processor before using it')
            }
            const debug = this.debug
            const length = this.filters.length
            const context = input
            for (let index = 0; index < length; index++) {
              const filter = this.filters[index]
              if (debug) {
                this.log(`filter: ${filter.filterName}`)
              }
              filter(context)
              if (typeof context === 'object' && context.exiting) {
                context.exiting = false
                break
              }
            }
            if (!context.next && this.resultCheck) {
              this.resultCheck(context)
            }
          }
          log(msg) {
            console.log(`[jsondiffpatch] ${this.name} pipe, ${msg}`)
          }
          append() {
            this.filters.push(...arguments)
            return this
          }
          prepend() {
            this.filters.unshift(...arguments)
            return this
          }
          indexOf(filterName) {
            if (!filterName) {
              throw new Error('a filter name is required')
            }
            for (let index = 0; index < this.filters.length; index++) {
              const filter = this.filters[index]
              if (filter.filterName === filterName) {
                return index
              }
            }
            throw new Error(`filter not found: ${filterName}`)
          }
          list() {
            return this.filters.map((f) => f.filterName)
          }
          after(filterName) {
            const index = this.indexOf(filterName)
            const params = Array.prototype.slice.call(arguments, 1)
            if (!params.length) {
              throw new Error('a filter is required')
            }
            params.unshift(index + 1, 0)
            Array.prototype.splice.apply(this.filters, params)
            return this
          }
          before(filterName) {
            const index = this.indexOf(filterName)
            const params = Array.prototype.slice.call(arguments, 1)
            if (!params.length) {
              throw new Error('a filter is required')
            }
            params.unshift(index, 0)
            Array.prototype.splice.apply(this.filters, params)
            return this
          }
          replace(filterName) {
            const index = this.indexOf(filterName)
            const params = Array.prototype.slice.call(arguments, 1)
            if (!params.length) {
              throw new Error('a filter is required')
            }
            params.unshift(index, 1)
            Array.prototype.splice.apply(this.filters, params)
            return this
          }
          remove(filterName) {
            const index = this.indexOf(filterName)
            this.filters.splice(index, 1)
            return this
          }
          clear() {
            this.filters.length = 0
            return this
          }
          shouldHaveResult(should) {
            if (should === false) {
              this.resultCheck = null
              return
            }
            if (this.resultCheck) {
              return
            }
            const pipe = this
            this.resultCheck = (context) => {
              if (!context.hasResult) {
                console.log(context)
                const error = new Error(`${pipe.name} failed`)
                error.noResult = true
                throw error
              }
            }
            return this
          }
        }

        class Context {
          setResult(result) {
            this.result = result
            this.hasResult = true
            return this
          }
          exit() {
            this.exiting = true
            return this
          }
          switchTo(next, pipe) {
            if (typeof next === 'string' || next instanceof Pipe) {
              this.nextPipe = next
            } else {
              this.next = next
              if (pipe) {
                this.nextPipe = pipe
              }
            }
            return this
          }
          push(child, name) {
            child.parent = this
            if (typeof name !== 'undefined') {
              child.childName = name
            }
            child.root = this.root || this
            child.options = child.options || this.options
            if (!this.children) {
              this.children = [child]
              this.nextAfterChildren = this.next || null
              this.next = child
            } else {
              this.children[this.children.length - 1].next = child
              this.children.push(child)
            }
            child.next = this
            return this
          }
        }

        const isArray$3 =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : (a) => a instanceof Array
        function cloneRegExp(re) {
          const regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString())
          return new RegExp(regexMatch[1], regexMatch[2])
        }
        function clone$1(arg) {
          if (typeof arg !== 'object') {
            return arg
          }
          if (arg === null) {
            return null
          }
          if (isArray$3(arg)) {
            return arg.map(clone$1)
          }
          if (arg instanceof Date) {
            return new Date(arg.getTime())
          }
          if (arg instanceof RegExp) {
            return cloneRegExp(arg)
          }
          const cloned = {}
          for (const name in arg) {
            if (Object.prototype.hasOwnProperty.call(arg, name)) {
              cloned[name] = clone$1(arg[name])
            }
          }
          return cloned
        }

        class DiffContext extends Context {
          constructor(left, right) {
            super()
            this.left = left
            this.right = right
            this.pipe = 'diff'
          }
          setResult(result) {
            if (this.options.cloneDiffValues && typeof result === 'object') {
              const clone =
                typeof this.options.cloneDiffValues === 'function'
                  ? this.options.cloneDiffValues
                  : clone$1
              if (typeof result[0] === 'object') {
                result[0] = clone(result[0])
              }
              if (typeof result[1] === 'object') {
                result[1] = clone(result[1])
              }
            }
            return Context.prototype.setResult.apply(this, arguments)
          }
        }

        class PatchContext extends Context {
          constructor(left, delta) {
            super()
            this.left = left
            this.delta = delta
            this.pipe = 'patch'
          }
        }

        class ReverseContext extends Context {
          constructor(delta) {
            super()
            this.delta = delta
            this.pipe = 'reverse'
          }
        }

        const isArray$2 =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : function (a) {
                return a instanceof Array
              }
        const diffFilter$3 = function trivialMatchesDiffFilter(context) {
          if (context.left === context.right) {
            context.setResult(undefined).exit()
            return
          }
          if (typeof context.left === 'undefined') {
            if (typeof context.right === 'function') {
              throw new Error('functions are not supported')
            }
            context.setResult([context.right]).exit()
            return
          }
          if (typeof context.right === 'undefined') {
            context.setResult([context.left, 0, 0]).exit()
            return
          }
          if (
            typeof context.left === 'function' ||
            typeof context.right === 'function'
          ) {
            throw new Error('functions are not supported')
          }
          context.leftType =
            context.left === null ? 'null' : typeof context.left
          context.rightType =
            context.right === null ? 'null' : typeof context.right
          if (context.leftType !== context.rightType) {
            context.setResult([context.left, context.right]).exit()
            return
          }
          if (context.leftType === 'boolean' || context.leftType === 'number') {
            context.setResult([context.left, context.right]).exit()
            return
          }
          if (context.leftType === 'object') {
            context.leftIsArray = isArray$2(context.left)
          }
          if (context.rightType === 'object') {
            context.rightIsArray = isArray$2(context.right)
          }
          if (context.leftIsArray !== context.rightIsArray) {
            context.setResult([context.left, context.right]).exit()
            return
          }
          if (context.left instanceof RegExp) {
            if (context.right instanceof RegExp) {
              context
                .setResult([context.left.toString(), context.right.toString()])
                .exit()
            } else {
              context.setResult([context.left, context.right]).exit()
            }
          }
        }
        diffFilter$3.filterName = 'trivial'
        const patchFilter$3 = function trivialMatchesPatchFilter(context) {
          if (typeof context.delta === 'undefined') {
            context.setResult(context.left).exit()
            return
          }
          context.nested = !isArray$2(context.delta)
          if (context.nested) {
            return
          }
          if (context.delta.length === 1) {
            context.setResult(context.delta[0]).exit()
            return
          }
          if (context.delta.length === 2) {
            if (context.left instanceof RegExp) {
              const regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1])
              if (regexArgs) {
                context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit()
                return
              }
            }
            context.setResult(context.delta[1]).exit()
            return
          }
          if (context.delta.length === 3 && context.delta[2] === 0) {
            context.setResult(undefined).exit()
          }
        }
        patchFilter$3.filterName = 'trivial'
        const reverseFilter$3 = function trivialReferseFilter(context) {
          if (typeof context.delta === 'undefined') {
            context.setResult(context.delta).exit()
            return
          }
          context.nested = !isArray$2(context.delta)
          if (context.nested) {
            return
          }
          if (context.delta.length === 1) {
            context.setResult([context.delta[0], 0, 0]).exit()
            return
          }
          if (context.delta.length === 2) {
            context.setResult([context.delta[1], context.delta[0]]).exit()
            return
          }
          if (context.delta.length === 3 && context.delta[2] === 0) {
            context.setResult([context.delta[0]]).exit()
          }
        }
        reverseFilter$3.filterName = 'trivial'

        function collectChildrenDiffFilter(context) {
          if (!context || !context.children) {
            return
          }
          const length = context.children.length
          let child
          let result = context.result
          for (let index = 0; index < length; index++) {
            child = context.children[index]
            if (typeof child.result === 'undefined') {
              continue
            }
            result = result || {}
            result[child.childName] = child.result
          }
          if (result && context.leftIsArray) {
            result._t = 'a'
          }
          context.setResult(result).exit()
        }
        collectChildrenDiffFilter.filterName = 'collectChildren'
        function objectsDiffFilter(context) {
          if (context.leftIsArray || context.leftType !== 'object') {
            return
          }
          let name
          let child
          const propertyFilter = context.options.propertyFilter
          for (name in context.left) {
            if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
              continue
            }
            if (propertyFilter && !propertyFilter(name, context)) {
              continue
            }
            child = new DiffContext(context.left[name], context.right[name])
            context.push(child, name)
          }
          for (name in context.right) {
            if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
              continue
            }
            if (propertyFilter && !propertyFilter(name, context)) {
              continue
            }
            if (typeof context.left[name] === 'undefined') {
              child = new DiffContext(undefined, context.right[name])
              context.push(child, name)
            }
          }
          if (!context.children || context.children.length === 0) {
            context.setResult(undefined).exit()
            return
          }
          context.exit()
        }
        objectsDiffFilter.filterName = 'objects'
        const patchFilter$2 = function nestedPatchFilter(context) {
          if (!context.nested) {
            return
          }
          if (context.delta._t) {
            return
          }
          let name
          let child
          for (name in context.delta) {
            child = new PatchContext(context.left[name], context.delta[name])
            context.push(child, name)
          }
          context.exit()
        }
        patchFilter$2.filterName = 'objects'
        const collectChildrenPatchFilter$1 =
          function collectChildrenPatchFilter(context) {
            if (!context || !context.children) {
              return
            }
            if (context.delta._t) {
              return
            }
            const length = context.children.length
            let child
            for (let index = 0; index < length; index++) {
              child = context.children[index]
              if (
                Object.prototype.hasOwnProperty.call(
                  context.left,
                  child.childName
                ) &&
                child.result === undefined
              ) {
                delete context.left[child.childName]
              } else if (context.left[child.childName] !== child.result) {
                context.left[child.childName] = child.result
              }
            }
            context.setResult(context.left).exit()
          }
        collectChildrenPatchFilter$1.filterName = 'collectChildren'
        const reverseFilter$2 = function nestedReverseFilter(context) {
          if (!context.nested) {
            return
          }
          if (context.delta._t) {
            return
          }
          let name
          let child
          for (name in context.delta) {
            child = new ReverseContext(context.delta[name])
            context.push(child, name)
          }
          context.exit()
        }
        reverseFilter$2.filterName = 'objects'
        function collectChildrenReverseFilter$1(context) {
          if (!context || !context.children) {
            return
          }
          if (context.delta._t) {
            return
          }
          const length = context.children.length
          let child
          const delta = {}
          for (let index = 0; index < length; index++) {
            child = context.children[index]
            if (delta[child.childName] !== child.result) {
              delta[child.childName] = child.result
            }
          }
          context.setResult(delta).exit()
        }
        collectChildrenReverseFilter$1.filterName = 'collectChildren'

        /*

  LCS implementation that supports arrays or strings

  reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

  */

        const defaultMatch = function (array1, array2, index1, index2) {
          return array1[index1] === array2[index2]
        }
        const lengthMatrix = function (array1, array2, match, context) {
          const len1 = array1.length
          const len2 = array2.length
          let x, y

          // initialize empty matrix of len1+1 x len2+1
          const matrix = [len1 + 1]
          for (x = 0; x < len1 + 1; x++) {
            matrix[x] = [len2 + 1]
            for (y = 0; y < len2 + 1; y++) {
              matrix[x][y] = 0
            }
          }
          matrix.match = match
          // save sequence lengths for each coordinate
          for (x = 1; x < len1 + 1; x++) {
            for (y = 1; y < len2 + 1; y++) {
              if (match(array1, array2, x - 1, y - 1, context)) {
                matrix[x][y] = matrix[x - 1][y - 1] + 1
              } else {
                matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1])
              }
            }
          }
          return matrix
        }
        const backtrack = function (matrix, array1, array2, context) {
          let index1 = array1.length
          let index2 = array2.length
          const subsequence = {
            sequence: [],
            indices1: [],
            indices2: []
          }
          while (index1 !== 0 && index2 !== 0) {
            const sameLetter = matrix.match(
              array1,
              array2,
              index1 - 1,
              index2 - 1,
              context
            )
            if (sameLetter) {
              subsequence.sequence.unshift(array1[index1 - 1])
              subsequence.indices1.unshift(index1 - 1)
              subsequence.indices2.unshift(index2 - 1)
              --index1
              --index2
            } else {
              const valueAtMatrixAbove = matrix[index1][index2 - 1]
              const valueAtMatrixLeft = matrix[index1 - 1][index2]
              if (valueAtMatrixAbove > valueAtMatrixLeft) {
                --index2
              } else {
                --index1
              }
            }
          }
          return subsequence
        }
        const get = function (array1, array2, match, context) {
          const innerContext = context || {}
          const matrix = lengthMatrix(
            array1,
            array2,
            match || defaultMatch,
            innerContext
          )
          const result = backtrack(matrix, array1, array2, innerContext)
          if (typeof array1 === 'string' && typeof array2 === 'string') {
            result.sequence = result.sequence.join('')
          }
          return result
        }
        var lcs = {
          get
        }

        const ARRAY_MOVE = 3
        const isArray$1 =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : (a) => a instanceof Array
        const arrayIndexOf =
          typeof Array.prototype.indexOf === 'function'
            ? (array, item) => array.indexOf(item)
            : (array, item) => {
                const length = array.length
                for (let i = 0; i < length; i++) {
                  if (array[i] === item) {
                    return i
                  }
                }
                return -1
              }
        function arraysHaveMatchByRef(array1, array2, len1, len2) {
          for (let index1 = 0; index1 < len1; index1++) {
            const val1 = array1[index1]
            for (let index2 = 0; index2 < len2; index2++) {
              const val2 = array2[index2]
              if (index1 !== index2 && val1 === val2) {
                return true
              }
            }
          }
        }
        function matchItems(array1, array2, index1, index2, context) {
          const value1 = array1[index1]
          const value2 = array2[index2]
          if (value1 === value2) {
            return true
          }
          if (typeof value1 !== 'object' || typeof value2 !== 'object') {
            return false
          }
          const objectHash = context.objectHash
          if (!objectHash) {
            // no way to match objects was provided, try match by position
            return context.matchByPosition && index1 === index2
          }
          let hash1
          let hash2
          if (typeof index1 === 'number') {
            context.hashCache1 = context.hashCache1 || []
            hash1 = context.hashCache1[index1]
            if (typeof hash1 === 'undefined') {
              context.hashCache1[index1] = hash1 = objectHash(value1, index1)
            }
          } else {
            hash1 = objectHash(value1)
          }
          if (typeof hash1 === 'undefined') {
            return false
          }
          if (typeof index2 === 'number') {
            context.hashCache2 = context.hashCache2 || []
            hash2 = context.hashCache2[index2]
            if (typeof hash2 === 'undefined') {
              context.hashCache2[index2] = hash2 = objectHash(value2, index2)
            }
          } else {
            hash2 = objectHash(value2)
          }
          if (typeof hash2 === 'undefined') {
            return false
          }
          return hash1 === hash2
        }
        const diffFilter$2 = function arraysDiffFilter(context) {
          if (!context.leftIsArray) {
            return
          }
          const matchContext = {
            objectHash: context.options && context.options.objectHash,
            matchByPosition: context.options && context.options.matchByPosition
          }
          let commonHead = 0
          let commonTail = 0
          let index
          let index1
          let index2
          const array1 = context.left
          const array2 = context.right
          const len1 = array1.length
          const len2 = array2.length
          let child
          if (
            len1 > 0 &&
            len2 > 0 &&
            !matchContext.objectHash &&
            typeof matchContext.matchByPosition !== 'boolean'
          ) {
            matchContext.matchByPosition = !arraysHaveMatchByRef(
              array1,
              array2,
              len1,
              len2
            )
          }

          // separate common head
          while (
            commonHead < len1 &&
            commonHead < len2 &&
            matchItems(array1, array2, commonHead, commonHead, matchContext)
          ) {
            index = commonHead
            child = new DiffContext(context.left[index], context.right[index])
            context.push(child, index)
            commonHead++
          }
          // separate common tail
          while (
            commonTail + commonHead < len1 &&
            commonTail + commonHead < len2 &&
            matchItems(
              array1,
              array2,
              len1 - 1 - commonTail,
              len2 - 1 - commonTail,
              matchContext
            )
          ) {
            index1 = len1 - 1 - commonTail
            index2 = len2 - 1 - commonTail
            child = new DiffContext(context.left[index1], context.right[index2])
            context.push(child, index2)
            commonTail++
          }
          let result
          if (commonHead + commonTail === len1) {
            if (len1 === len2) {
              // arrays are identical
              context.setResult(undefined).exit()
              return
            }
            // trivial case, a block (1 or more consecutive items) was added
            result = result || {
              _t: 'a'
            }
            for (index = commonHead; index < len2 - commonTail; index++) {
              result[index] = [array2[index]]
            }
            context.setResult(result).exit()
            return
          }
          if (commonHead + commonTail === len2) {
            // trivial case, a block (1 or more consecutive items) was removed
            result = result || {
              _t: 'a'
            }
            for (index = commonHead; index < len1 - commonTail; index++) {
              result[`_${index}`] = [array1[index], 0, 0]
            }
            context.setResult(result).exit()
            return
          }
          // reset hash cache
          delete matchContext.hashCache1
          delete matchContext.hashCache2

          // diff is not trivial, find the LCS (Longest Common Subsequence)
          const trimmed1 = array1.slice(commonHead, len1 - commonTail)
          const trimmed2 = array2.slice(commonHead, len2 - commonTail)
          const seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext)
          const removedItems = []
          result = result || {
            _t: 'a'
          }
          for (index = commonHead; index < len1 - commonTail; index++) {
            if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
              // removed
              result[`_${index}`] = [array1[index], 0, 0]
              removedItems.push(index)
            }
          }
          let detectMove = true
          if (
            context.options &&
            context.options.arrays &&
            context.options.arrays.detectMove === false
          ) {
            detectMove = false
          }
          let includeValueOnMove = false
          if (
            context.options &&
            context.options.arrays &&
            context.options.arrays.includeValueOnMove
          ) {
            includeValueOnMove = true
          }
          const removedItemsLength = removedItems.length
          for (index = commonHead; index < len2 - commonTail; index++) {
            const indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead)
            if (indexOnArray2 < 0) {
              // added, try to match with a removed item and register as position move
              let isMove = false
              if (detectMove && removedItemsLength > 0) {
                for (
                  let removeItemIndex1 = 0;
                  removeItemIndex1 < removedItemsLength;
                  removeItemIndex1++
                ) {
                  index1 = removedItems[removeItemIndex1]
                  if (
                    matchItems(
                      trimmed1,
                      trimmed2,
                      index1 - commonHead,
                      index - commonHead,
                      matchContext
                    )
                  ) {
                    // store position move as: [originalValue, newPosition, ARRAY_MOVE]
                    result[`_${index1}`].splice(1, 2, index, ARRAY_MOVE)
                    if (!includeValueOnMove) {
                      // don't include moved value on diff, to save bytes
                      result[`_${index1}`][0] = ''
                    }
                    index2 = index
                    child = new DiffContext(
                      context.left[index1],
                      context.right[index2]
                    )
                    context.push(child, index2)
                    removedItems.splice(removeItemIndex1, 1)
                    isMove = true
                    break
                  }
                }
              }
              if (!isMove) {
                // added
                result[index] = [array2[index]]
              }
            } else {
              // match, do inner diff
              index1 = seq.indices1[indexOnArray2] + commonHead
              index2 = seq.indices2[indexOnArray2] + commonHead
              child = new DiffContext(
                context.left[index1],
                context.right[index2]
              )
              context.push(child, index2)
            }
          }
          context.setResult(result).exit()
        }
        diffFilter$2.filterName = 'arrays'
        const compare = {
          numerically(a, b) {
            return a - b
          },
          numericallyBy(name) {
            return (a, b) => a[name] - b[name]
          }
        }
        const patchFilter$1 = function nestedPatchFilter(context) {
          if (!context.nested) {
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          let index
          let index1
          const delta = context.delta
          const array = context.left

          // first, separate removals, insertions and modifications
          let toRemove = []
          let toInsert = []
          const toModify = []
          for (index in delta) {
            if (index !== '_t') {
              if (index[0] === '_') {
                // removed item from original array
                if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
                  toRemove.push(parseInt(index.slice(1), 10))
                } else {
                  throw new Error(
                    'only removal or move can be applied at original array indices,' +
                      ` invalid diff type: ${delta[index][2]}`
                  )
                }
              } else {
                if (delta[index].length === 1) {
                  // added item at new array
                  toInsert.push({
                    index: parseInt(index, 10),
                    value: delta[index][0]
                  })
                } else {
                  // modified item at new array
                  toModify.push({
                    index: parseInt(index, 10),
                    delta: delta[index]
                  })
                }
              }
            }
          }

          // remove items, in reverse order to avoid sawing our own floor
          toRemove = toRemove.sort(compare.numerically)
          for (index = toRemove.length - 1; index >= 0; index--) {
            index1 = toRemove[index]
            const indexDiff = delta[`_${index1}`]
            const removedValue = array.splice(index1, 1)[0]
            if (indexDiff[2] === ARRAY_MOVE) {
              // reinsert later
              toInsert.push({
                index: indexDiff[1],
                value: removedValue
              })
            }
          }

          // insert items, in reverse order to avoid moving our own floor
          toInsert = toInsert.sort(compare.numericallyBy('index'))
          const toInsertLength = toInsert.length
          for (index = 0; index < toInsertLength; index++) {
            const insertion = toInsert[index]
            array.splice(insertion.index, 0, insertion.value)
          }

          // apply modifications
          const toModifyLength = toModify.length
          let child
          if (toModifyLength > 0) {
            for (index = 0; index < toModifyLength; index++) {
              const modification = toModify[index]
              child = new PatchContext(
                context.left[modification.index],
                modification.delta
              )
              context.push(child, modification.index)
            }
          }
          if (!context.children) {
            context.setResult(context.left).exit()
            return
          }
          context.exit()
        }
        patchFilter$1.filterName = 'arrays'
        const collectChildrenPatchFilter = function collectChildrenPatchFilter(
          context
        ) {
          if (!context || !context.children) {
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          const length = context.children.length
          let child
          for (let index = 0; index < length; index++) {
            child = context.children[index]
            context.left[child.childName] = child.result
          }
          context.setResult(context.left).exit()
        }
        collectChildrenPatchFilter.filterName = 'arraysCollectChildren'
        const reverseFilter$1 = function arraysReverseFilter(context) {
          if (!context.nested) {
            if (context.delta[2] === ARRAY_MOVE) {
              context.newName = `_${context.delta[1]}`
              context
                .setResult([
                  context.delta[0],
                  parseInt(context.childName.substr(1), 10),
                  ARRAY_MOVE
                ])
                .exit()
            }
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          let name
          let child
          for (name in context.delta) {
            if (name === '_t') {
              continue
            }
            child = new ReverseContext(context.delta[name])
            context.push(child, name)
          }
          context.exit()
        }
        reverseFilter$1.filterName = 'arrays'
        const reverseArrayDeltaIndex = (delta, index, itemDelta) => {
          if (typeof index === 'string' && index[0] === '_') {
            return parseInt(index.substr(1), 10)
          } else if (isArray$1(itemDelta) && itemDelta[2] === 0) {
            return `_${index}`
          }
          let reverseIndex = +index
          for (const deltaIndex in delta) {
            const deltaItem = delta[deltaIndex]
            if (isArray$1(deltaItem)) {
              if (deltaItem[2] === ARRAY_MOVE) {
                const moveFromIndex = parseInt(deltaIndex.substr(1), 10)
                const moveToIndex = deltaItem[1]
                if (moveToIndex === +index) {
                  return moveFromIndex
                }
                if (
                  moveFromIndex <= reverseIndex &&
                  moveToIndex > reverseIndex
                ) {
                  reverseIndex++
                } else if (
                  moveFromIndex >= reverseIndex &&
                  moveToIndex < reverseIndex
                ) {
                  reverseIndex--
                }
              } else if (deltaItem[2] === 0) {
                const deleteIndex = parseInt(deltaIndex.substr(1), 10)
                if (deleteIndex <= reverseIndex) {
                  reverseIndex++
                }
              } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
                reverseIndex--
              }
            }
          }
          return reverseIndex
        }
        function collectChildrenReverseFilter(context) {
          if (!context || !context.children) {
            return
          }
          if (context.delta._t !== 'a') {
            return
          }
          const length = context.children.length
          let child
          const delta = {
            _t: 'a'
          }
          for (let index = 0; index < length; index++) {
            child = context.children[index]
            let name = child.newName
            if (typeof name === 'undefined') {
              name = reverseArrayDeltaIndex(
                context.delta,
                child.childName,
                child.result
              )
            }
            if (delta[name] !== child.result) {
              delta[name] = child.result
            }
          }
          context.setResult(delta).exit()
        }
        collectChildrenReverseFilter.filterName = 'arraysCollectChildren'

        const diffFilter$1 = function datesDiffFilter(context) {
          if (context.left instanceof Date) {
            if (context.right instanceof Date) {
              if (context.left.getTime() !== context.right.getTime()) {
                context.setResult([context.left, context.right])
              } else {
                context.setResult(undefined)
              }
            } else {
              context.setResult([context.left, context.right])
            }
            context.exit()
          } else if (context.right instanceof Date) {
            context.setResult([context.left, context.right]).exit()
          }
        }
        diffFilter$1.filterName = 'dates'

        function getDefaultExportFromCjs(x) {
          return x &&
            x.__esModule &&
            Object.prototype.hasOwnProperty.call(x, 'default')
            ? x['default']
            : x
        }

        var diffMatchPatch = { exports: {} }

        /**
         * Diff Match and Patch
         * Copyright 2018 The diff-match-patch Authors.
         * https://github.com/google/diff-match-patch
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        ;(function (module) {
          /**
           * @fileoverview Computes the difference between two texts to create a patch.
           * Applies the patch onto another text, allowing for errors.
           * @author fraser@google.com (Neil Fraser)
           */

          /**
           * Class containing the diff, match and patch methods.
           * @constructor
           */
          var diff_match_patch = function () {
            // Defaults.
            // Redefine these in your program to override the defaults.

            // Number of seconds to map a diff before giving up (0 for infinity).
            this.Diff_Timeout = 1.0
            // Cost of an empty edit operation in terms of edit characters.
            this.Diff_EditCost = 4
            // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
            this.Match_Threshold = 0.5
            // How far to search for a match (0 = exact location, 1000+ = broad match).
            // A match this many characters away from the expected location will add
            // 1.0 to the score (0.0 is a perfect match).
            this.Match_Distance = 1000
            // When deleting a large block of text (over ~64 characters), how close do
            // the contents have to be to match the expected contents. (0.0 = perfection,
            // 1.0 = very loose).  Note that Match_Threshold controls how closely the
            // end points of a delete need to match.
            this.Patch_DeleteThreshold = 0.5
            // Chunk size for context length.
            this.Patch_Margin = 4

            // The number of bits in an int.
            this.Match_MaxBits = 32
          }

          //  DIFF FUNCTIONS

          /**
           * The data structure representing a diff is an array of tuples:
           * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
           * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
           */
          var DIFF_DELETE = -1
          var DIFF_INSERT = 1
          var DIFF_EQUAL = 0

          /**
           * Class representing one diff tuple.
           * ~Attempts to look like a two-element array (which is what this used to be).~
           * Constructor returns an actual two-element array, to allow destructing @JackuB
           * See https://github.com/JackuB/diff-match-patch/issues/14 for details
           * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
           * @param {string} text Text to be deleted, inserted, or retained.
           * @constructor
           */
          diff_match_patch.Diff = function (op, text) {
            return [op, text]
          }

          /**
           * Find the differences between two texts.  Simplifies the problem by stripping
           * any common prefix or suffix off the texts before diffing.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
           *     then don't run a line-level diff first to identify the changed areas.
           *     Defaults to true, which does a faster, slightly less optimal diff.
           * @param {number=} opt_deadline Optional time when the diff should be complete
           *     by.  Used internally for recursive calls.  Users should set DiffTimeout
           *     instead.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           */
          diff_match_patch.prototype.diff_main = function (
            text1,
            text2,
            opt_checklines,
            opt_deadline
          ) {
            // Set a deadline by which time the diff must be complete.
            if (typeof opt_deadline == 'undefined') {
              if (this.Diff_Timeout <= 0) {
                opt_deadline = Number.MAX_VALUE
              } else {
                opt_deadline = new Date().getTime() + this.Diff_Timeout * 1000
              }
            }
            var deadline = opt_deadline

            // Check for null inputs.
            if (text1 == null || text2 == null) {
              throw new Error('Null input. (diff_main)')
            }

            // Check for equality (speedup).
            if (text1 == text2) {
              if (text1) {
                return [new diff_match_patch.Diff(DIFF_EQUAL, text1)]
              }
              return []
            }

            if (typeof opt_checklines == 'undefined') {
              opt_checklines = true
            }
            var checklines = opt_checklines

            // Trim off common prefix (speedup).
            var commonlength = this.diff_commonPrefix(text1, text2)
            var commonprefix = text1.substring(0, commonlength)
            text1 = text1.substring(commonlength)
            text2 = text2.substring(commonlength)

            // Trim off common suffix (speedup).
            commonlength = this.diff_commonSuffix(text1, text2)
            var commonsuffix = text1.substring(text1.length - commonlength)
            text1 = text1.substring(0, text1.length - commonlength)
            text2 = text2.substring(0, text2.length - commonlength)

            // Compute the diff on the middle block.
            var diffs = this.diff_compute_(text1, text2, checklines, deadline)

            // Restore the prefix and suffix.
            if (commonprefix) {
              diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix))
            }
            if (commonsuffix) {
              diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix))
            }
            this.diff_cleanupMerge(diffs)
            return diffs
          }

          /**
           * Find the differences between two texts.  Assumes that the texts do not
           * have any common prefix or suffix.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {boolean} checklines Speedup flag.  If false, then don't run a
           *     line-level diff first to identify the changed areas.
           *     If true, then run a faster, slightly less optimal diff.
           * @param {number} deadline Time when the diff should be complete by.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_compute_ = function (
            text1,
            text2,
            checklines,
            deadline
          ) {
            var diffs

            if (!text1) {
              // Just add some text (speedup).
              return [new diff_match_patch.Diff(DIFF_INSERT, text2)]
            }

            if (!text2) {
              // Just delete some text (speedup).
              return [new diff_match_patch.Diff(DIFF_DELETE, text1)]
            }

            var longtext = text1.length > text2.length ? text1 : text2
            var shorttext = text1.length > text2.length ? text2 : text1
            var i = longtext.indexOf(shorttext)
            if (i != -1) {
              // Shorter text is inside the longer text (speedup).
              diffs = [
                new diff_match_patch.Diff(
                  DIFF_INSERT,
                  longtext.substring(0, i)
                ),
                new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
                new diff_match_patch.Diff(
                  DIFF_INSERT,
                  longtext.substring(i + shorttext.length)
                )
              ]
              // Swap insertions for deletions if diff is reversed.
              if (text1.length > text2.length) {
                diffs[0][0] = diffs[2][0] = DIFF_DELETE
              }
              return diffs
            }

            if (shorttext.length == 1) {
              // Single character string.
              // After the previous speedup, the character can't be an equality.
              return [
                new diff_match_patch.Diff(DIFF_DELETE, text1),
                new diff_match_patch.Diff(DIFF_INSERT, text2)
              ]
            }

            // Check to see if the problem can be split in two.
            var hm = this.diff_halfMatch_(text1, text2)
            if (hm) {
              // A half-match was found, sort out the return data.
              var text1_a = hm[0]
              var text1_b = hm[1]
              var text2_a = hm[2]
              var text2_b = hm[3]
              var mid_common = hm[4]
              // Send both pairs off for separate processing.
              var diffs_a = this.diff_main(
                text1_a,
                text2_a,
                checklines,
                deadline
              )
              var diffs_b = this.diff_main(
                text1_b,
                text2_b,
                checklines,
                deadline
              )
              // Merge the results.
              return diffs_a.concat(
                [new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
                diffs_b
              )
            }

            if (checklines && text1.length > 100 && text2.length > 100) {
              return this.diff_lineMode_(text1, text2, deadline)
            }

            return this.diff_bisect_(text1, text2, deadline)
          }

          /**
           * Do a quick line-level diff on both strings, then rediff the parts for
           * greater accuracy.
           * This speedup can produce non-minimal diffs.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {number} deadline Time when the diff should be complete by.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_lineMode_ = function (
            text1,
            text2,
            deadline
          ) {
            // Scan the text on a line-by-line basis first.
            var a = this.diff_linesToChars_(text1, text2)
            text1 = a.chars1
            text2 = a.chars2
            var linearray = a.lineArray

            var diffs = this.diff_main(text1, text2, false, deadline)

            // Convert the diff back to original text.
            this.diff_charsToLines_(diffs, linearray)
            // Eliminate freak matches (e.g. blank lines)
            this.diff_cleanupSemantic(diffs)

            // Rediff any replacement blocks, this time character-by-character.
            // Add a dummy entry at the end.
            diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''))
            var pointer = 0
            var count_delete = 0
            var count_insert = 0
            var text_delete = ''
            var text_insert = ''
            while (pointer < diffs.length) {
              switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                  count_insert++
                  text_insert += diffs[pointer][1]
                  break
                case DIFF_DELETE:
                  count_delete++
                  text_delete += diffs[pointer][1]
                  break
                case DIFF_EQUAL:
                  // Upon reaching an equality, check for prior redundancies.
                  if (count_delete >= 1 && count_insert >= 1) {
                    // Delete the offending records and add the merged ones.
                    diffs.splice(
                      pointer - count_delete - count_insert,
                      count_delete + count_insert
                    )
                    pointer = pointer - count_delete - count_insert
                    var subDiff = this.diff_main(
                      text_delete,
                      text_insert,
                      false,
                      deadline
                    )
                    for (var j = subDiff.length - 1; j >= 0; j--) {
                      diffs.splice(pointer, 0, subDiff[j])
                    }
                    pointer = pointer + subDiff.length
                  }
                  count_insert = 0
                  count_delete = 0
                  text_delete = ''
                  text_insert = ''
                  break
              }
              pointer++
            }
            diffs.pop() // Remove the dummy entry at the end.

            return diffs
          }

          /**
           * Find the 'middle snake' of a diff, split the problem in two
           * and return the recursively constructed diff.
           * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {number} deadline Time at which to bail if not yet complete.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_bisect_ = function (
            text1,
            text2,
            deadline
          ) {
            // Cache the text lengths to prevent multiple calls.
            var text1_length = text1.length
            var text2_length = text2.length
            var max_d = Math.ceil((text1_length + text2_length) / 2)
            var v_offset = max_d
            var v_length = 2 * max_d
            var v1 = new Array(v_length)
            var v2 = new Array(v_length)
            // Setting all elements to -1 is faster in Chrome & Firefox than mixing
            // integers and undefined.
            for (var x = 0; x < v_length; x++) {
              v1[x] = -1
              v2[x] = -1
            }
            v1[v_offset + 1] = 0
            v2[v_offset + 1] = 0
            var delta = text1_length - text2_length
            // If the total number of characters is odd, then the front path will collide
            // with the reverse path.
            var front = delta % 2 != 0
            // Offsets for start and end of k loop.
            // Prevents mapping of space beyond the grid.
            var k1start = 0
            var k1end = 0
            var k2start = 0
            var k2end = 0
            for (var d = 0; d < max_d; d++) {
              // Bail out if deadline is reached.
              if (new Date().getTime() > deadline) {
                break
              }

              // Walk the front path one step.
              for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                var k1_offset = v_offset + k1
                var x1
                if (
                  k1 == -d ||
                  (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])
                ) {
                  x1 = v1[k1_offset + 1]
                } else {
                  x1 = v1[k1_offset - 1] + 1
                }
                var y1 = x1 - k1
                while (
                  x1 < text1_length &&
                  y1 < text2_length &&
                  text1.charAt(x1) == text2.charAt(y1)
                ) {
                  x1++
                  y1++
                }
                v1[k1_offset] = x1
                if (x1 > text1_length) {
                  // Ran off the right of the graph.
                  k1end += 2
                } else if (y1 > text2_length) {
                  // Ran off the bottom of the graph.
                  k1start += 2
                } else if (front) {
                  var k2_offset = v_offset + delta - k1
                  if (
                    k2_offset >= 0 &&
                    k2_offset < v_length &&
                    v2[k2_offset] != -1
                  ) {
                    // Mirror x2 onto top-left coordinate system.
                    var x2 = text1_length - v2[k2_offset]
                    if (x1 >= x2) {
                      // Overlap detected.
                      return this.diff_bisectSplit_(
                        text1,
                        text2,
                        x1,
                        y1,
                        deadline
                      )
                    }
                  }
                }
              }

              // Walk the reverse path one step.
              for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                var k2_offset = v_offset + k2
                var x2
                if (
                  k2 == -d ||
                  (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])
                ) {
                  x2 = v2[k2_offset + 1]
                } else {
                  x2 = v2[k2_offset - 1] + 1
                }
                var y2 = x2 - k2
                while (
                  x2 < text1_length &&
                  y2 < text2_length &&
                  text1.charAt(text1_length - x2 - 1) ==
                    text2.charAt(text2_length - y2 - 1)
                ) {
                  x2++
                  y2++
                }
                v2[k2_offset] = x2
                if (x2 > text1_length) {
                  // Ran off the left of the graph.
                  k2end += 2
                } else if (y2 > text2_length) {
                  // Ran off the top of the graph.
                  k2start += 2
                } else if (!front) {
                  var k1_offset = v_offset + delta - k2
                  if (
                    k1_offset >= 0 &&
                    k1_offset < v_length &&
                    v1[k1_offset] != -1
                  ) {
                    var x1 = v1[k1_offset]
                    var y1 = v_offset + x1 - k1_offset
                    // Mirror x2 onto top-left coordinate system.
                    x2 = text1_length - x2
                    if (x1 >= x2) {
                      // Overlap detected.
                      return this.diff_bisectSplit_(
                        text1,
                        text2,
                        x1,
                        y1,
                        deadline
                      )
                    }
                  }
                }
              }
            }
            // Diff took too long and hit the deadline or
            // number of diffs equals number of characters, no commonality at all.
            return [
              new diff_match_patch.Diff(DIFF_DELETE, text1),
              new diff_match_patch.Diff(DIFF_INSERT, text2)
            ]
          }

          /**
           * Given the location of the 'middle snake', split the diff in two parts
           * and recurse.
           * @param {string} text1 Old string to be diffed.
           * @param {string} text2 New string to be diffed.
           * @param {number} x Index of split point in text1.
           * @param {number} y Index of split point in text2.
           * @param {number} deadline Time at which to bail if not yet complete.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @private
           */
          diff_match_patch.prototype.diff_bisectSplit_ = function (
            text1,
            text2,
            x,
            y,
            deadline
          ) {
            var text1a = text1.substring(0, x)
            var text2a = text2.substring(0, y)
            var text1b = text1.substring(x)
            var text2b = text2.substring(y)

            // Compute both diffs serially.
            var diffs = this.diff_main(text1a, text2a, false, deadline)
            var diffsb = this.diff_main(text1b, text2b, false, deadline)

            return diffs.concat(diffsb)
          }

          /**
           * Split two texts into an array of strings.  Reduce the texts to a string of
           * hashes where each Unicode character represents one line.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
           *     An object containing the encoded text1, the encoded text2 and
           *     the array of unique strings.
           *     The zeroth element of the array of unique strings is intentionally blank.
           * @private
           */
          diff_match_patch.prototype.diff_linesToChars_ = function (
            text1,
            text2
          ) {
            var lineArray = [] // e.g. lineArray[4] == 'Hello\n'
            var lineHash = {} // e.g. lineHash['Hello\n'] == 4

            // '\x00' is a valid character, but various debuggers don't like it.
            // So we'll insert a junk entry to avoid generating a null character.
            lineArray[0] = ''

            /**
             * Split a text into an array of strings.  Reduce the texts to a string of
             * hashes where each Unicode character represents one line.
             * Modifies linearray and linehash through being a closure.
             * @param {string} text String to encode.
             * @return {string} Encoded string.
             * @private
             */
            function diff_linesToCharsMunge_(text) {
              var chars = ''
              // Walk the text, pulling out a substring for each line.
              // text.split('\n') would would temporarily double our memory footprint.
              // Modifying text would create many large strings to garbage collect.
              var lineStart = 0
              var lineEnd = -1
              // Keeping our own length variable is faster than looking it up.
              var lineArrayLength = lineArray.length
              while (lineEnd < text.length - 1) {
                lineEnd = text.indexOf('\n', lineStart)
                if (lineEnd == -1) {
                  lineEnd = text.length - 1
                }
                var line = text.substring(lineStart, lineEnd + 1)

                if (
                  lineHash.hasOwnProperty
                    ? lineHash.hasOwnProperty(line)
                    : lineHash[line] !== undefined
                ) {
                  chars += String.fromCharCode(lineHash[line])
                } else {
                  if (lineArrayLength == maxLines) {
                    // Bail out at 65535 because
                    // String.fromCharCode(65536) == String.fromCharCode(0)
                    line = text.substring(lineStart)
                    lineEnd = text.length
                  }
                  chars += String.fromCharCode(lineArrayLength)
                  lineHash[line] = lineArrayLength
                  lineArray[lineArrayLength++] = line
                }
                lineStart = lineEnd + 1
              }
              return chars
            }
            // Allocate 2/3rds of the space for text1, the rest for text2.
            var maxLines = 40000
            var chars1 = diff_linesToCharsMunge_(text1)
            maxLines = 65535
            var chars2 = diff_linesToCharsMunge_(text2)
            return { chars1: chars1, chars2: chars2, lineArray: lineArray }
          }

          /**
           * Rehydrate the text in a diff from a string of line hashes to real lines of
           * text.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @param {!Array.<string>} lineArray Array of unique strings.
           * @private
           */
          diff_match_patch.prototype.diff_charsToLines_ = function (
            diffs,
            lineArray
          ) {
            for (var i = 0; i < diffs.length; i++) {
              var chars = diffs[i][1]
              var text = []
              for (var j = 0; j < chars.length; j++) {
                text[j] = lineArray[chars.charCodeAt(j)]
              }
              diffs[i][1] = text.join('')
            }
          }

          /**
           * Determine the common prefix of two strings.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {number} The number of characters common to the start of each
           *     string.
           */
          diff_match_patch.prototype.diff_commonPrefix = function (
            text1,
            text2
          ) {
            // Quick check for common null cases.
            if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
              return 0
            }
            // Binary search.
            // Performance analysis: https://neil.fraser.name/news/2007/10/09/
            var pointermin = 0
            var pointermax = Math.min(text1.length, text2.length)
            var pointermid = pointermax
            var pointerstart = 0
            while (pointermin < pointermid) {
              if (
                text1.substring(pointerstart, pointermid) ==
                text2.substring(pointerstart, pointermid)
              ) {
                pointermin = pointermid
                pointerstart = pointermin
              } else {
                pointermax = pointermid
              }
              pointermid = Math.floor(
                (pointermax - pointermin) / 2 + pointermin
              )
            }
            return pointermid
          }

          /**
           * Determine the common suffix of two strings.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {number} The number of characters common to the end of each string.
           */
          diff_match_patch.prototype.diff_commonSuffix = function (
            text1,
            text2
          ) {
            // Quick check for common null cases.
            if (
              !text1 ||
              !text2 ||
              text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)
            ) {
              return 0
            }
            // Binary search.
            // Performance analysis: https://neil.fraser.name/news/2007/10/09/
            var pointermin = 0
            var pointermax = Math.min(text1.length, text2.length)
            var pointermid = pointermax
            var pointerend = 0
            while (pointermin < pointermid) {
              if (
                text1.substring(
                  text1.length - pointermid,
                  text1.length - pointerend
                ) ==
                text2.substring(
                  text2.length - pointermid,
                  text2.length - pointerend
                )
              ) {
                pointermin = pointermid
                pointerend = pointermin
              } else {
                pointermax = pointermid
              }
              pointermid = Math.floor(
                (pointermax - pointermin) / 2 + pointermin
              )
            }
            return pointermid
          }

          /**
           * Determine if the suffix of one string is the prefix of another.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {number} The number of characters common to the end of the first
           *     string and the start of the second string.
           * @private
           */
          diff_match_patch.prototype.diff_commonOverlap_ = function (
            text1,
            text2
          ) {
            // Cache the text lengths to prevent multiple calls.
            var text1_length = text1.length
            var text2_length = text2.length
            // Eliminate the null case.
            if (text1_length == 0 || text2_length == 0) {
              return 0
            }
            // Truncate the longer string.
            if (text1_length > text2_length) {
              text1 = text1.substring(text1_length - text2_length)
            } else if (text1_length < text2_length) {
              text2 = text2.substring(0, text1_length)
            }
            var text_length = Math.min(text1_length, text2_length)
            // Quick check for the worst case.
            if (text1 == text2) {
              return text_length
            }

            // Start by looking for a single character match
            // and increase length until no match is found.
            // Performance analysis: https://neil.fraser.name/news/2010/11/04/
            var best = 0
            var length = 1
            while (true) {
              var pattern = text1.substring(text_length - length)
              var found = text2.indexOf(pattern)
              if (found == -1) {
                return best
              }
              length += found
              if (
                found == 0 ||
                text1.substring(text_length - length) ==
                  text2.substring(0, length)
              ) {
                best = length
                length++
              }
            }
          }

          /**
           * Do the two texts share a substring which is at least half the length of the
           * longer text?
           * This speedup can produce non-minimal diffs.
           * @param {string} text1 First string.
           * @param {string} text2 Second string.
           * @return {Array.<string>} Five element Array, containing the prefix of
           *     text1, the suffix of text1, the prefix of text2, the suffix of
           *     text2 and the common middle.  Or null if there was no match.
           * @private
           */
          diff_match_patch.prototype.diff_halfMatch_ = function (text1, text2) {
            if (this.Diff_Timeout <= 0) {
              // Don't risk returning a non-optimal diff if we have unlimited time.
              return null
            }
            var longtext = text1.length > text2.length ? text1 : text2
            var shorttext = text1.length > text2.length ? text2 : text1
            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
              return null // Pointless.
            }
            var dmp = this // 'this' becomes 'window' in a closure.

            /**
             * Does a substring of shorttext exist within longtext such that the substring
             * is at least half the length of longtext?
             * Closure, but does not reference any external variables.
             * @param {string} longtext Longer string.
             * @param {string} shorttext Shorter string.
             * @param {number} i Start index of quarter length substring within longtext.
             * @return {Array.<string>} Five element Array, containing the prefix of
             *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
             *     of shorttext and the common middle.  Or null if there was no match.
             * @private
             */
            function diff_halfMatchI_(longtext, shorttext, i) {
              // Start with a 1/4 length substring at position i as a seed.
              var seed = longtext.substring(
                i,
                i + Math.floor(longtext.length / 4)
              )
              var j = -1
              var best_common = ''
              var best_longtext_a,
                best_longtext_b,
                best_shorttext_a,
                best_shorttext_b
              while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                var prefixLength = dmp.diff_commonPrefix(
                  longtext.substring(i),
                  shorttext.substring(j)
                )
                var suffixLength = dmp.diff_commonSuffix(
                  longtext.substring(0, i),
                  shorttext.substring(0, j)
                )
                if (best_common.length < suffixLength + prefixLength) {
                  best_common =
                    shorttext.substring(j - suffixLength, j) +
                    shorttext.substring(j, j + prefixLength)
                  best_longtext_a = longtext.substring(0, i - suffixLength)
                  best_longtext_b = longtext.substring(i + prefixLength)
                  best_shorttext_a = shorttext.substring(0, j - suffixLength)
                  best_shorttext_b = shorttext.substring(j + prefixLength)
                }
              }
              if (best_common.length * 2 >= longtext.length) {
                return [
                  best_longtext_a,
                  best_longtext_b,
                  best_shorttext_a,
                  best_shorttext_b,
                  best_common
                ]
              } else {
                return null
              }
            }

            // First check if the second quarter is the seed for a half-match.
            var hm1 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 4)
            )
            // Check again based on the third quarter.
            var hm2 = diff_halfMatchI_(
              longtext,
              shorttext,
              Math.ceil(longtext.length / 2)
            )
            var hm
            if (!hm1 && !hm2) {
              return null
            } else if (!hm2) {
              hm = hm1
            } else if (!hm1) {
              hm = hm2
            } else {
              // Both matched.  Select the longest.
              hm = hm1[4].length > hm2[4].length ? hm1 : hm2
            }

            // A half-match was found, sort out the return data.
            var text1_a, text1_b, text2_a, text2_b
            if (text1.length > text2.length) {
              text1_a = hm[0]
              text1_b = hm[1]
              text2_a = hm[2]
              text2_b = hm[3]
            } else {
              text2_a = hm[0]
              text2_b = hm[1]
              text1_a = hm[2]
              text1_b = hm[3]
            }
            var mid_common = hm[4]
            return [text1_a, text1_b, text2_a, text2_b, mid_common]
          }

          /**
           * Reduce the number of edits by eliminating semantically trivial equalities.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupSemantic = function (diffs) {
            var changes = false
            var equalities = [] // Stack of indices where equalities are found.
            var equalitiesLength = 0 // Keeping our own length var is faster in JS.
            /** @type {?string} */
            var lastEquality = null
            // Always equal to diffs[equalities[equalitiesLength - 1]][1]
            var pointer = 0 // Index of current position.
            // Number of characters that changed prior to the equality.
            var length_insertions1 = 0
            var length_deletions1 = 0
            // Number of characters that changed after the equality.
            var length_insertions2 = 0
            var length_deletions2 = 0
            while (pointer < diffs.length) {
              if (diffs[pointer][0] == DIFF_EQUAL) {
                // Equality found.
                equalities[equalitiesLength++] = pointer
                length_insertions1 = length_insertions2
                length_deletions1 = length_deletions2
                length_insertions2 = 0
                length_deletions2 = 0
                lastEquality = diffs[pointer][1]
              } else {
                // An insertion or deletion.
                if (diffs[pointer][0] == DIFF_INSERT) {
                  length_insertions2 += diffs[pointer][1].length
                } else {
                  length_deletions2 += diffs[pointer][1].length
                }
                // Eliminate an equality that is smaller or equal to the edits on both
                // sides of it.
                if (
                  lastEquality &&
                  lastEquality.length <=
                    Math.max(length_insertions1, length_deletions1) &&
                  lastEquality.length <=
                    Math.max(length_insertions2, length_deletions2)
                ) {
                  // Duplicate record.
                  diffs.splice(
                    equalities[equalitiesLength - 1],
                    0,
                    new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
                  )
                  // Change second copy to insert.
                  diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT
                  // Throw away the equality we just deleted.
                  equalitiesLength--
                  // Throw away the previous equality (it needs to be reevaluated).
                  equalitiesLength--
                  pointer =
                    equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1
                  length_insertions1 = 0 // Reset the counters.
                  length_deletions1 = 0
                  length_insertions2 = 0
                  length_deletions2 = 0
                  lastEquality = null
                  changes = true
                }
              }
              pointer++
            }

            // Normalize the diff.
            if (changes) {
              this.diff_cleanupMerge(diffs)
            }
            this.diff_cleanupSemanticLossless(diffs)

            // Find any overlaps between deletions and insertions.
            // e.g: <del>abcxxx</del><ins>xxxdef</ins>
            //   -> <del>abc</del>xxx<ins>def</ins>
            // e.g: <del>xxxabc</del><ins>defxxx</ins>
            //   -> <ins>def</ins>xxx<del>abc</del>
            // Only extract an overlap if it is as big as the edit ahead or behind it.
            pointer = 1
            while (pointer < diffs.length) {
              if (
                diffs[pointer - 1][0] == DIFF_DELETE &&
                diffs[pointer][0] == DIFF_INSERT
              ) {
                var deletion = diffs[pointer - 1][1]
                var insertion = diffs[pointer][1]
                var overlap_length1 = this.diff_commonOverlap_(
                  deletion,
                  insertion
                )
                var overlap_length2 = this.diff_commonOverlap_(
                  insertion,
                  deletion
                )
                if (overlap_length1 >= overlap_length2) {
                  if (
                    overlap_length1 >= deletion.length / 2 ||
                    overlap_length1 >= insertion.length / 2
                  ) {
                    // Overlap found.  Insert an equality and trim the surrounding edits.
                    diffs.splice(
                      pointer,
                      0,
                      new diff_match_patch.Diff(
                        DIFF_EQUAL,
                        insertion.substring(0, overlap_length1)
                      )
                    )
                    diffs[pointer - 1][1] = deletion.substring(
                      0,
                      deletion.length - overlap_length1
                    )
                    diffs[pointer + 1][1] = insertion.substring(overlap_length1)
                    pointer++
                  }
                } else {
                  if (
                    overlap_length2 >= deletion.length / 2 ||
                    overlap_length2 >= insertion.length / 2
                  ) {
                    // Reverse overlap found.
                    // Insert an equality and swap and trim the surrounding edits.
                    diffs.splice(
                      pointer,
                      0,
                      new diff_match_patch.Diff(
                        DIFF_EQUAL,
                        deletion.substring(0, overlap_length2)
                      )
                    )
                    diffs[pointer - 1][0] = DIFF_INSERT
                    diffs[pointer - 1][1] = insertion.substring(
                      0,
                      insertion.length - overlap_length2
                    )
                    diffs[pointer + 1][0] = DIFF_DELETE
                    diffs[pointer + 1][1] = deletion.substring(overlap_length2)
                    pointer++
                  }
                }
                pointer++
              }
              pointer++
            }
          }

          /**
           * Look for single edits surrounded on both sides by equalities
           * which can be shifted sideways to align the edit to a word boundary.
           * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupSemanticLossless = function (
            diffs
          ) {
            /**
             * Given two strings, compute a score representing whether the internal
             * boundary falls on logical boundaries.
             * Scores range from 6 (best) to 0 (worst).
             * Closure, but does not reference any external variables.
             * @param {string} one First string.
             * @param {string} two Second string.
             * @return {number} The score.
             * @private
             */
            function diff_cleanupSemanticScore_(one, two) {
              if (!one || !two) {
                // Edges are the best.
                return 6
              }

              // Each port of this function behaves slightly differently due to
              // subtle differences in each language's definition of things like
              // 'whitespace'.  Since this function's purpose is largely cosmetic,
              // the choice has been made to use each language's native features
              // rather than force total conformity.
              var char1 = one.charAt(one.length - 1)
              var char2 = two.charAt(0)
              var nonAlphaNumeric1 = char1.match(
                diff_match_patch.nonAlphaNumericRegex_
              )
              var nonAlphaNumeric2 = char2.match(
                diff_match_patch.nonAlphaNumericRegex_
              )
              var whitespace1 =
                nonAlphaNumeric1 &&
                char1.match(diff_match_patch.whitespaceRegex_)
              var whitespace2 =
                nonAlphaNumeric2 &&
                char2.match(diff_match_patch.whitespaceRegex_)
              var lineBreak1 =
                whitespace1 && char1.match(diff_match_patch.linebreakRegex_)
              var lineBreak2 =
                whitespace2 && char2.match(diff_match_patch.linebreakRegex_)
              var blankLine1 =
                lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_)
              var blankLine2 =
                lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_)

              if (blankLine1 || blankLine2) {
                // Five points for blank lines.
                return 5
              } else if (lineBreak1 || lineBreak2) {
                // Four points for line breaks.
                return 4
              } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
                // Three points for end of sentences.
                return 3
              } else if (whitespace1 || whitespace2) {
                // Two points for whitespace.
                return 2
              } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
                // One point for non-alphanumeric.
                return 1
              }
              return 0
            }

            var pointer = 1
            // Intentionally ignore the first and last element (don't need checking).
            while (pointer < diffs.length - 1) {
              if (
                diffs[pointer - 1][0] == DIFF_EQUAL &&
                diffs[pointer + 1][0] == DIFF_EQUAL
              ) {
                // This is a single edit surrounded by equalities.
                var equality1 = diffs[pointer - 1][1]
                var edit = diffs[pointer][1]
                var equality2 = diffs[pointer + 1][1]

                // First, shift the edit as far left as possible.
                var commonOffset = this.diff_commonSuffix(equality1, edit)
                if (commonOffset) {
                  var commonString = edit.substring(edit.length - commonOffset)
                  equality1 = equality1.substring(
                    0,
                    equality1.length - commonOffset
                  )
                  edit =
                    commonString + edit.substring(0, edit.length - commonOffset)
                  equality2 = commonString + equality2
                }

                // Second, step character by character right, looking for the best fit.
                var bestEquality1 = equality1
                var bestEdit = edit
                var bestEquality2 = equality2
                var bestScore =
                  diff_cleanupSemanticScore_(equality1, edit) +
                  diff_cleanupSemanticScore_(edit, equality2)
                while (edit.charAt(0) === equality2.charAt(0)) {
                  equality1 += edit.charAt(0)
                  edit = edit.substring(1) + equality2.charAt(0)
                  equality2 = equality2.substring(1)
                  var score =
                    diff_cleanupSemanticScore_(equality1, edit) +
                    diff_cleanupSemanticScore_(edit, equality2)
                  // The >= encourages trailing rather than leading whitespace on edits.
                  if (score >= bestScore) {
                    bestScore = score
                    bestEquality1 = equality1
                    bestEdit = edit
                    bestEquality2 = equality2
                  }
                }

                if (diffs[pointer - 1][1] != bestEquality1) {
                  // We have an improvement, save it back to the diff.
                  if (bestEquality1) {
                    diffs[pointer - 1][1] = bestEquality1
                  } else {
                    diffs.splice(pointer - 1, 1)
                    pointer--
                  }
                  diffs[pointer][1] = bestEdit
                  if (bestEquality2) {
                    diffs[pointer + 1][1] = bestEquality2
                  } else {
                    diffs.splice(pointer + 1, 1)
                    pointer--
                  }
                }
              }
              pointer++
            }
          }

          // Define some regex patterns for matching boundaries.
          diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/
          diff_match_patch.whitespaceRegex_ = /\s/
          diff_match_patch.linebreakRegex_ = /[\r\n]/
          diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/
          diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/

          /**
           * Reduce the number of edits by eliminating operationally trivial equalities.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupEfficiency = function (diffs) {
            var changes = false
            var equalities = [] // Stack of indices where equalities are found.
            var equalitiesLength = 0 // Keeping our own length var is faster in JS.
            /** @type {?string} */
            var lastEquality = null
            // Always equal to diffs[equalities[equalitiesLength - 1]][1]
            var pointer = 0 // Index of current position.
            // Is there an insertion operation before the last equality.
            var pre_ins = false
            // Is there a deletion operation before the last equality.
            var pre_del = false
            // Is there an insertion operation after the last equality.
            var post_ins = false
            // Is there a deletion operation after the last equality.
            var post_del = false
            while (pointer < diffs.length) {
              if (diffs[pointer][0] == DIFF_EQUAL) {
                // Equality found.
                if (
                  diffs[pointer][1].length < this.Diff_EditCost &&
                  (post_ins || post_del)
                ) {
                  // Candidate found.
                  equalities[equalitiesLength++] = pointer
                  pre_ins = post_ins
                  pre_del = post_del
                  lastEquality = diffs[pointer][1]
                } else {
                  // Not a candidate, and can never become one.
                  equalitiesLength = 0
                  lastEquality = null
                }
                post_ins = post_del = false
              } else {
                // An insertion or deletion.
                if (diffs[pointer][0] == DIFF_DELETE) {
                  post_del = true
                } else {
                  post_ins = true
                }
                /*
                 * Five types to be split:
                 * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
                 * <ins>A</ins>X<ins>C</ins><del>D</del>
                 * <ins>A</ins><del>B</del>X<ins>C</ins>
                 * <ins>A</del>X<ins>C</ins><del>D</del>
                 * <ins>A</ins><del>B</del>X<del>C</del>
                 */
                if (
                  lastEquality &&
                  ((pre_ins && pre_del && post_ins && post_del) ||
                    (lastEquality.length < this.Diff_EditCost / 2 &&
                      pre_ins + pre_del + post_ins + post_del == 3))
                ) {
                  // Duplicate record.
                  diffs.splice(
                    equalities[equalitiesLength - 1],
                    0,
                    new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
                  )
                  // Change second copy to insert.
                  diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT
                  equalitiesLength-- // Throw away the equality we just deleted;
                  lastEquality = null
                  if (pre_ins && pre_del) {
                    // No changes made which could affect previous entry, keep going.
                    post_ins = post_del = true
                    equalitiesLength = 0
                  } else {
                    equalitiesLength-- // Throw away the previous equality.
                    pointer =
                      equalitiesLength > 0
                        ? equalities[equalitiesLength - 1]
                        : -1
                    post_ins = post_del = false
                  }
                  changes = true
                }
              }
              pointer++
            }

            if (changes) {
              this.diff_cleanupMerge(diffs)
            }
          }

          /**
           * Reorder and merge like edit sections.  Merge equalities.
           * Any edit section can move as long as it doesn't cross an equality.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           */
          diff_match_patch.prototype.diff_cleanupMerge = function (diffs) {
            // Add a dummy entry at the end.
            diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''))
            var pointer = 0
            var count_delete = 0
            var count_insert = 0
            var text_delete = ''
            var text_insert = ''
            var commonlength
            while (pointer < diffs.length) {
              switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                  count_insert++
                  text_insert += diffs[pointer][1]
                  pointer++
                  break
                case DIFF_DELETE:
                  count_delete++
                  text_delete += diffs[pointer][1]
                  pointer++
                  break
                case DIFF_EQUAL:
                  // Upon reaching an equality, check for prior redundancies.
                  if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                      // Factor out any common prefixies.
                      commonlength = this.diff_commonPrefix(
                        text_insert,
                        text_delete
                      )
                      if (commonlength !== 0) {
                        if (
                          pointer - count_delete - count_insert > 0 &&
                          diffs[pointer - count_delete - count_insert - 1][0] ==
                            DIFF_EQUAL
                        ) {
                          diffs[pointer - count_delete - count_insert - 1][1] +=
                            text_insert.substring(0, commonlength)
                        } else {
                          diffs.splice(
                            0,
                            0,
                            new diff_match_patch.Diff(
                              DIFF_EQUAL,
                              text_insert.substring(0, commonlength)
                            )
                          )
                          pointer++
                        }
                        text_insert = text_insert.substring(commonlength)
                        text_delete = text_delete.substring(commonlength)
                      }
                      // Factor out any common suffixies.
                      commonlength = this.diff_commonSuffix(
                        text_insert,
                        text_delete
                      )
                      if (commonlength !== 0) {
                        diffs[pointer][1] =
                          text_insert.substring(
                            text_insert.length - commonlength
                          ) + diffs[pointer][1]
                        text_insert = text_insert.substring(
                          0,
                          text_insert.length - commonlength
                        )
                        text_delete = text_delete.substring(
                          0,
                          text_delete.length - commonlength
                        )
                      }
                    }
                    // Delete the offending records and add the merged ones.
                    pointer -= count_delete + count_insert
                    diffs.splice(pointer, count_delete + count_insert)
                    if (text_delete.length) {
                      diffs.splice(
                        pointer,
                        0,
                        new diff_match_patch.Diff(DIFF_DELETE, text_delete)
                      )
                      pointer++
                    }
                    if (text_insert.length) {
                      diffs.splice(
                        pointer,
                        0,
                        new diff_match_patch.Diff(DIFF_INSERT, text_insert)
                      )
                      pointer++
                    }
                    pointer++
                  } else if (
                    pointer !== 0 &&
                    diffs[pointer - 1][0] == DIFF_EQUAL
                  ) {
                    // Merge this equality with the previous one.
                    diffs[pointer - 1][1] += diffs[pointer][1]
                    diffs.splice(pointer, 1)
                  } else {
                    pointer++
                  }
                  count_insert = 0
                  count_delete = 0
                  text_delete = ''
                  text_insert = ''
                  break
              }
            }
            if (diffs[diffs.length - 1][1] === '') {
              diffs.pop() // Remove the dummy entry at the end.
            }

            // Second pass: look for single edits surrounded on both sides by equalities
            // which can be shifted sideways to eliminate an equality.
            // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
            var changes = false
            pointer = 1
            // Intentionally ignore the first and last element (don't need checking).
            while (pointer < diffs.length - 1) {
              if (
                diffs[pointer - 1][0] == DIFF_EQUAL &&
                diffs[pointer + 1][0] == DIFF_EQUAL
              ) {
                // This is a single edit surrounded by equalities.
                if (
                  diffs[pointer][1].substring(
                    diffs[pointer][1].length - diffs[pointer - 1][1].length
                  ) == diffs[pointer - 1][1]
                ) {
                  // Shift the edit over the previous equality.
                  diffs[pointer][1] =
                    diffs[pointer - 1][1] +
                    diffs[pointer][1].substring(
                      0,
                      diffs[pointer][1].length - diffs[pointer - 1][1].length
                    )
                  diffs[pointer + 1][1] =
                    diffs[pointer - 1][1] + diffs[pointer + 1][1]
                  diffs.splice(pointer - 1, 1)
                  changes = true
                } else if (
                  diffs[pointer][1].substring(
                    0,
                    diffs[pointer + 1][1].length
                  ) == diffs[pointer + 1][1]
                ) {
                  // Shift the edit over the next equality.
                  diffs[pointer - 1][1] += diffs[pointer + 1][1]
                  diffs[pointer][1] =
                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
                    diffs[pointer + 1][1]
                  diffs.splice(pointer + 1, 1)
                  changes = true
                }
              }
              pointer++
            }
            // If shifts were made, the diff needs reordering and another shift sweep.
            if (changes) {
              this.diff_cleanupMerge(diffs)
            }
          }

          /**
           * loc is a location in text1, compute and return the equivalent location in
           * text2.
           * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @param {number} loc Location within text1.
           * @return {number} Location within text2.
           */
          diff_match_patch.prototype.diff_xIndex = function (diffs, loc) {
            var chars1 = 0
            var chars2 = 0
            var last_chars1 = 0
            var last_chars2 = 0
            var x
            for (x = 0; x < diffs.length; x++) {
              if (diffs[x][0] !== DIFF_INSERT) {
                // Equality or deletion.
                chars1 += diffs[x][1].length
              }
              if (diffs[x][0] !== DIFF_DELETE) {
                // Equality or insertion.
                chars2 += diffs[x][1].length
              }
              if (chars1 > loc) {
                // Overshot the location.
                break
              }
              last_chars1 = chars1
              last_chars2 = chars2
            }
            // Was the location was deleted?
            if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
              return last_chars2
            }
            // Add the remaining character length.
            return last_chars2 + (loc - last_chars1)
          }

          /**
           * Convert a diff array into a pretty HTML report.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} HTML representation.
           */
          diff_match_patch.prototype.diff_prettyHtml = function (diffs) {
            var html = []
            var pattern_amp = /&/g
            var pattern_lt = /</g
            var pattern_gt = />/g
            var pattern_para = /\n/g
            for (var x = 0; x < diffs.length; x++) {
              var op = diffs[x][0] // Operation (insert, delete, equal)
              var data = diffs[x][1] // Text of change.
              var text = data
                .replace(pattern_amp, '&amp;')
                .replace(pattern_lt, '&lt;')
                .replace(pattern_gt, '&gt;')
                .replace(pattern_para, '&para;<br>')
              switch (op) {
                case DIFF_INSERT:
                  html[x] =
                    '<ins style="background:#e6ffe6;">' + text + '</ins>'
                  break
                case DIFF_DELETE:
                  html[x] =
                    '<del style="background:#ffe6e6;">' + text + '</del>'
                  break
                case DIFF_EQUAL:
                  html[x] = '<span>' + text + '</span>'
                  break
              }
            }
            return html.join('')
          }

          /**
           * Compute and return the source text (all equalities and deletions).
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} Source text.
           */
          diff_match_patch.prototype.diff_text1 = function (diffs) {
            var text = []
            for (var x = 0; x < diffs.length; x++) {
              if (diffs[x][0] !== DIFF_INSERT) {
                text[x] = diffs[x][1]
              }
            }
            return text.join('')
          }

          /**
           * Compute and return the destination text (all equalities and insertions).
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} Destination text.
           */
          diff_match_patch.prototype.diff_text2 = function (diffs) {
            var text = []
            for (var x = 0; x < diffs.length; x++) {
              if (diffs[x][0] !== DIFF_DELETE) {
                text[x] = diffs[x][1]
              }
            }
            return text.join('')
          }

          /**
           * Compute the Levenshtein distance; the number of inserted, deleted or
           * substituted characters.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {number} Number of changes.
           */
          diff_match_patch.prototype.diff_levenshtein = function (diffs) {
            var levenshtein = 0
            var insertions = 0
            var deletions = 0
            for (var x = 0; x < diffs.length; x++) {
              var op = diffs[x][0]
              var data = diffs[x][1]
              switch (op) {
                case DIFF_INSERT:
                  insertions += data.length
                  break
                case DIFF_DELETE:
                  deletions += data.length
                  break
                case DIFF_EQUAL:
                  // A deletion and an insertion is one substitution.
                  levenshtein += Math.max(insertions, deletions)
                  insertions = 0
                  deletions = 0
                  break
              }
            }
            levenshtein += Math.max(insertions, deletions)
            return levenshtein
          }

          /**
           * Crush the diff into an encoded string which describes the operations
           * required to transform text1 into text2.
           * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
           * Operations are tab-separated.  Inserted text is escaped using %xx notation.
           * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
           * @return {string} Delta text.
           */
          diff_match_patch.prototype.diff_toDelta = function (diffs) {
            var text = []
            for (var x = 0; x < diffs.length; x++) {
              switch (diffs[x][0]) {
                case DIFF_INSERT:
                  text[x] = '+' + encodeURI(diffs[x][1])
                  break
                case DIFF_DELETE:
                  text[x] = '-' + diffs[x][1].length
                  break
                case DIFF_EQUAL:
                  text[x] = '=' + diffs[x][1].length
                  break
              }
            }
            return text.join('\t').replace(/%20/g, ' ')
          }

          /**
           * Given the original text1, and an encoded string which describes the
           * operations required to transform text1 into text2, compute the full diff.
           * @param {string} text1 Source string for the diff.
           * @param {string} delta Delta text.
           * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
           * @throws {!Error} If invalid input.
           */
          diff_match_patch.prototype.diff_fromDelta = function (text1, delta) {
            var diffs = []
            var diffsLength = 0 // Keeping our own length var is faster in JS.
            var pointer = 0 // Cursor in text1
            var tokens = delta.split(/\t/g)
            for (var x = 0; x < tokens.length; x++) {
              // Each token begins with a one character parameter which specifies the
              // operation of this token (delete, insert, equality).
              var param = tokens[x].substring(1)
              switch (tokens[x].charAt(0)) {
                case '+':
                  try {
                    diffs[diffsLength++] = new diff_match_patch.Diff(
                      DIFF_INSERT,
                      decodeURI(param)
                    )
                  } catch (ex) {
                    // Malformed URI sequence.
                    throw new Error(
                      'Illegal escape in diff_fromDelta: ' + param
                    )
                  }
                  break
                case '-':
                // Fall through.
                case '=':
                  var n = parseInt(param, 10)
                  if (isNaN(n) || n < 0) {
                    throw new Error(
                      'Invalid number in diff_fromDelta: ' + param
                    )
                  }
                  var text = text1.substring(pointer, (pointer += n))
                  if (tokens[x].charAt(0) == '=') {
                    diffs[diffsLength++] = new diff_match_patch.Diff(
                      DIFF_EQUAL,
                      text
                    )
                  } else {
                    diffs[diffsLength++] = new diff_match_patch.Diff(
                      DIFF_DELETE,
                      text
                    )
                  }
                  break
                default:
                  // Blank tokens are ok (from a trailing \t).
                  // Anything else is an error.
                  if (tokens[x]) {
                    throw new Error(
                      'Invalid diff operation in diff_fromDelta: ' + tokens[x]
                    )
                  }
              }
            }
            if (pointer != text1.length) {
              throw new Error(
                'Delta length (' +
                  pointer +
                  ') does not equal source text length (' +
                  text1.length +
                  ').'
              )
            }
            return diffs
          }

          //  MATCH FUNCTIONS

          /**
           * Locate the best instance of 'pattern' in 'text' near 'loc'.
           * @param {string} text The text to search.
           * @param {string} pattern The pattern to search for.
           * @param {number} loc The location to search around.
           * @return {number} Best match index or -1.
           */
          diff_match_patch.prototype.match_main = function (
            text,
            pattern,
            loc
          ) {
            // Check for null inputs.
            if (text == null || pattern == null || loc == null) {
              throw new Error('Null input. (match_main)')
            }

            loc = Math.max(0, Math.min(loc, text.length))
            if (text == pattern) {
              // Shortcut (potentially not guaranteed by the algorithm)
              return 0
            } else if (!text.length) {
              // Nothing to match.
              return -1
            } else if (text.substring(loc, loc + pattern.length) == pattern) {
              // Perfect match at the perfect spot!  (Includes case of null pattern)
              return loc
            } else {
              // Do a fuzzy compare.
              return this.match_bitap_(text, pattern, loc)
            }
          }

          /**
           * Locate the best instance of 'pattern' in 'text' near 'loc' using the
           * Bitap algorithm.
           * @param {string} text The text to search.
           * @param {string} pattern The pattern to search for.
           * @param {number} loc The location to search around.
           * @return {number} Best match index or -1.
           * @private
           */
          diff_match_patch.prototype.match_bitap_ = function (
            text,
            pattern,
            loc
          ) {
            if (pattern.length > this.Match_MaxBits) {
              throw new Error('Pattern too long for this browser.')
            }

            // Initialise the alphabet.
            var s = this.match_alphabet_(pattern)

            var dmp = this // 'this' becomes 'window' in a closure.

            /**
             * Compute and return the score for a match with e errors and x location.
             * Accesses loc and pattern through being a closure.
             * @param {number} e Number of errors in match.
             * @param {number} x Location of match.
             * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
             * @private
             */
            function match_bitapScore_(e, x) {
              var accuracy = e / pattern.length
              var proximity = Math.abs(loc - x)
              if (!dmp.Match_Distance) {
                // Dodge divide by zero error.
                return proximity ? 1.0 : accuracy
              }
              return accuracy + proximity / dmp.Match_Distance
            }

            // Highest score beyond which we give up.
            var score_threshold = this.Match_Threshold
            // Is there a nearby exact match? (speedup)
            var best_loc = text.indexOf(pattern, loc)
            if (best_loc != -1) {
              score_threshold = Math.min(
                match_bitapScore_(0, best_loc),
                score_threshold
              )
              // What about in the other direction? (speedup)
              best_loc = text.lastIndexOf(pattern, loc + pattern.length)
              if (best_loc != -1) {
                score_threshold = Math.min(
                  match_bitapScore_(0, best_loc),
                  score_threshold
                )
              }
            }

            // Initialise the bit arrays.
            var matchmask = 1 << (pattern.length - 1)
            best_loc = -1

            var bin_min, bin_mid
            var bin_max = pattern.length + text.length
            var last_rd
            for (var d = 0; d < pattern.length; d++) {
              // Scan for the best match; each iteration allows for one more error.
              // Run a binary search to determine how far from 'loc' we can stray at this
              // error level.
              bin_min = 0
              bin_mid = bin_max
              while (bin_min < bin_mid) {
                if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
                  bin_min = bin_mid
                } else {
                  bin_max = bin_mid
                }
                bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min)
              }
              // Use the result from this iteration as the maximum for the next.
              bin_max = bin_mid
              var start = Math.max(1, loc - bin_mid + 1)
              var finish = Math.min(loc + bin_mid, text.length) + pattern.length

              var rd = Array(finish + 2)
              rd[finish + 1] = (1 << d) - 1
              for (var j = finish; j >= start; j--) {
                // The alphabet (s) is a sparse hash, so the following line generates
                // warnings.
                var charMatch = s[text.charAt(j - 1)]
                if (d === 0) {
                  // First pass: exact match.
                  rd[j] = ((rd[j + 1] << 1) | 1) & charMatch
                } else {
                  // Subsequent passes: fuzzy match.
                  rd[j] =
                    (((rd[j + 1] << 1) | 1) & charMatch) |
                    (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                    last_rd[j + 1]
                }
                if (rd[j] & matchmask) {
                  var score = match_bitapScore_(d, j - 1)
                  // This match will almost certainly be better than any existing match.
                  // But check anyway.
                  if (score <= score_threshold) {
                    // Told you so.
                    score_threshold = score
                    best_loc = j - 1
                    if (best_loc > loc) {
                      // When passing loc, don't exceed our current distance from loc.
                      start = Math.max(1, 2 * loc - best_loc)
                    } else {
                      // Already passed loc, downhill from here on in.
                      break
                    }
                  }
                }
              }
              // No hope for a (better) match at greater error levels.
              if (match_bitapScore_(d + 1, loc) > score_threshold) {
                break
              }
              last_rd = rd
            }
            return best_loc
          }

          /**
           * Initialise the alphabet for the Bitap algorithm.
           * @param {string} pattern The text to encode.
           * @return {!Object} Hash of character locations.
           * @private
           */
          diff_match_patch.prototype.match_alphabet_ = function (pattern) {
            var s = {}
            for (var i = 0; i < pattern.length; i++) {
              s[pattern.charAt(i)] = 0
            }
            for (var i = 0; i < pattern.length; i++) {
              s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1)
            }
            return s
          }

          //  PATCH FUNCTIONS

          /**
           * Increase the context until it is unique,
           * but don't let the pattern expand beyond Match_MaxBits.
           * @param {!diff_match_patch.patch_obj} patch The patch to grow.
           * @param {string} text Source text.
           * @private
           */
          diff_match_patch.prototype.patch_addContext_ = function (
            patch,
            text
          ) {
            if (text.length == 0) {
              return
            }
            if (patch.start2 === null) {
              throw Error('patch not initialized')
            }
            var pattern = text.substring(
              patch.start2,
              patch.start2 + patch.length1
            )
            var padding = 0

            // Look for the first and last matches of pattern in text.  If two different
            // matches are found, increase the pattern length.
            while (
              text.indexOf(pattern) != text.lastIndexOf(pattern) &&
              pattern.length <
                this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin
            ) {
              padding += this.Patch_Margin
              pattern = text.substring(
                patch.start2 - padding,
                patch.start2 + patch.length1 + padding
              )
            }
            // Add one chunk for good luck.
            padding += this.Patch_Margin

            // Add the prefix.
            var prefix = text.substring(patch.start2 - padding, patch.start2)
            if (prefix) {
              patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix))
            }
            // Add the suffix.
            var suffix = text.substring(
              patch.start2 + patch.length1,
              patch.start2 + patch.length1 + padding
            )
            if (suffix) {
              patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix))
            }

            // Roll back the start points.
            patch.start1 -= prefix.length
            patch.start2 -= prefix.length
            // Extend the lengths.
            patch.length1 += prefix.length + suffix.length
            patch.length2 += prefix.length + suffix.length
          }

          /**
           * Compute a list of patches to turn text1 into text2.
           * Use diffs if provided, otherwise compute it ourselves.
           * There are four ways to call this function, depending on what data is
           * available to the caller:
           * Method 1:
           * a = text1, b = text2
           * Method 2:
           * a = diffs
           * Method 3 (optimal):
           * a = text1, b = diffs
           * Method 4 (deprecated, use method 3):
           * a = text1, b = text2, c = diffs
           *
           * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
           * Array of diff tuples for text1 to text2 (method 2).
           * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
           * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
           * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
           * for text1 to text2 (method 4) or undefined (methods 1,2,3).
           * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
           */
          diff_match_patch.prototype.patch_make = function (a, opt_b, opt_c) {
            var text1, diffs
            if (
              typeof a == 'string' &&
              typeof opt_b == 'string' &&
              typeof opt_c == 'undefined'
            ) {
              // Method 1: text1, text2
              // Compute diffs from text1 and text2.
              text1 = /** @type {string} */ (a)
              diffs = this.diff_main(text1, /** @type {string} */ (opt_b), true)
              if (diffs.length > 2) {
                this.diff_cleanupSemantic(diffs)
                this.diff_cleanupEfficiency(diffs)
              }
            } else if (
              a &&
              typeof a == 'object' &&
              typeof opt_b == 'undefined' &&
              typeof opt_c == 'undefined'
            ) {
              // Method 2: diffs
              // Compute text1 from diffs.
              diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ (a)
              text1 = this.diff_text1(diffs)
            } else if (
              typeof a == 'string' &&
              opt_b &&
              typeof opt_b == 'object' &&
              typeof opt_c == 'undefined'
            ) {
              // Method 3: text1, diffs
              text1 = /** @type {string} */ (a)
              diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ (opt_b)
            } else if (
              typeof a == 'string' &&
              typeof opt_b == 'string' &&
              opt_c &&
              typeof opt_c == 'object'
            ) {
              // Method 4: text1, text2, diffs
              // text2 is not used.
              text1 = /** @type {string} */ (a)
              diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ (opt_c)
            } else {
              throw new Error('Unknown call format to patch_make.')
            }

            if (diffs.length === 0) {
              return [] // Get rid of the null case.
            }
            var patches = []
            var patch = new diff_match_patch.patch_obj()
            var patchDiffLength = 0 // Keeping our own length var is faster in JS.
            var char_count1 = 0 // Number of characters into the text1 string.
            var char_count2 = 0 // Number of characters into the text2 string.
            // Start with text1 (prepatch_text) and apply the diffs until we arrive at
            // text2 (postpatch_text).  We recreate the patches one by one to determine
            // context info.
            var prepatch_text = text1
            var postpatch_text = text1
            for (var x = 0; x < diffs.length; x++) {
              var diff_type = diffs[x][0]
              var diff_text = diffs[x][1]

              if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
                // A new patch starts here.
                patch.start1 = char_count1
                patch.start2 = char_count2
              }

              switch (diff_type) {
                case DIFF_INSERT:
                  patch.diffs[patchDiffLength++] = diffs[x]
                  patch.length2 += diff_text.length
                  postpatch_text =
                    postpatch_text.substring(0, char_count2) +
                    diff_text +
                    postpatch_text.substring(char_count2)
                  break
                case DIFF_DELETE:
                  patch.length1 += diff_text.length
                  patch.diffs[patchDiffLength++] = diffs[x]
                  postpatch_text =
                    postpatch_text.substring(0, char_count2) +
                    postpatch_text.substring(char_count2 + diff_text.length)
                  break
                case DIFF_EQUAL:
                  if (
                    diff_text.length <= 2 * this.Patch_Margin &&
                    patchDiffLength &&
                    diffs.length != x + 1
                  ) {
                    // Small equality inside a patch.
                    patch.diffs[patchDiffLength++] = diffs[x]
                    patch.length1 += diff_text.length
                    patch.length2 += diff_text.length
                  } else if (diff_text.length >= 2 * this.Patch_Margin) {
                    // Time for a new patch.
                    if (patchDiffLength) {
                      this.patch_addContext_(patch, prepatch_text)
                      patches.push(patch)
                      patch = new diff_match_patch.patch_obj()
                      patchDiffLength = 0
                      // Unlike Unidiff, our patch lists have a rolling context.
                      // https://github.com/google/diff-match-patch/wiki/Unidiff
                      // Update prepatch text & pos to reflect the application of the
                      // just completed patch.
                      prepatch_text = postpatch_text
                      char_count1 = char_count2
                    }
                  }
                  break
              }

              // Update the current character count.
              if (diff_type !== DIFF_INSERT) {
                char_count1 += diff_text.length
              }
              if (diff_type !== DIFF_DELETE) {
                char_count2 += diff_text.length
              }
            }
            // Pick up the leftover patch if not empty.
            if (patchDiffLength) {
              this.patch_addContext_(patch, prepatch_text)
              patches.push(patch)
            }

            return patches
          }

          /**
           * Given an array of patches, return another array that is identical.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
           */
          diff_match_patch.prototype.patch_deepCopy = function (patches) {
            // Making deep copies is hard in JavaScript.
            var patchesCopy = []
            for (var x = 0; x < patches.length; x++) {
              var patch = patches[x]
              var patchCopy = new diff_match_patch.patch_obj()
              patchCopy.diffs = []
              for (var y = 0; y < patch.diffs.length; y++) {
                patchCopy.diffs[y] = new diff_match_patch.Diff(
                  patch.diffs[y][0],
                  patch.diffs[y][1]
                )
              }
              patchCopy.start1 = patch.start1
              patchCopy.start2 = patch.start2
              patchCopy.length1 = patch.length1
              patchCopy.length2 = patch.length2
              patchesCopy[x] = patchCopy
            }
            return patchesCopy
          }

          /**
           * Merge a set of patches onto the text.  Return a patched text, as well
           * as a list of true/false values indicating which patches were applied.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @param {string} text Old text.
           * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
           *      new text and an array of boolean values.
           */
          diff_match_patch.prototype.patch_apply = function (patches, text) {
            if (patches.length == 0) {
              return [text, []]
            }

            // Deep copy the patches so that no changes are made to originals.
            patches = this.patch_deepCopy(patches)

            var nullPadding = this.patch_addPadding(patches)
            text = nullPadding + text + nullPadding

            this.patch_splitMax(patches)
            // delta keeps track of the offset between the expected and actual location
            // of the previous patch.  If there are patches expected at positions 10 and
            // 20, but the first patch was found at 12, delta is 2 and the second patch
            // has an effective expected position of 22.
            var delta = 0
            var results = []
            for (var x = 0; x < patches.length; x++) {
              var expected_loc = patches[x].start2 + delta
              var text1 = this.diff_text1(patches[x].diffs)
              var start_loc
              var end_loc = -1
              if (text1.length > this.Match_MaxBits) {
                // patch_splitMax will only provide an oversized pattern in the case of
                // a monster delete.
                start_loc = this.match_main(
                  text,
                  text1.substring(0, this.Match_MaxBits),
                  expected_loc
                )
                if (start_loc != -1) {
                  end_loc = this.match_main(
                    text,
                    text1.substring(text1.length - this.Match_MaxBits),
                    expected_loc + text1.length - this.Match_MaxBits
                  )
                  if (end_loc == -1 || start_loc >= end_loc) {
                    // Can't find valid trailing context.  Drop this patch.
                    start_loc = -1
                  }
                }
              } else {
                start_loc = this.match_main(text, text1, expected_loc)
              }
              if (start_loc == -1) {
                // No match found.  :(
                results[x] = false
                // Subtract the delta for this failed patch from subsequent patches.
                delta -= patches[x].length2 - patches[x].length1
              } else {
                // Found a match.  :)
                results[x] = true
                delta = start_loc - expected_loc
                var text2
                if (end_loc == -1) {
                  text2 = text.substring(start_loc, start_loc + text1.length)
                } else {
                  text2 = text.substring(
                    start_loc,
                    end_loc + this.Match_MaxBits
                  )
                }
                if (text1 == text2) {
                  // Perfect match, just shove the replacement text in.
                  text =
                    text.substring(0, start_loc) +
                    this.diff_text2(patches[x].diffs) +
                    text.substring(start_loc + text1.length)
                } else {
                  // Imperfect match.  Run a diff to get a framework of equivalent
                  // indices.
                  var diffs = this.diff_main(text1, text2, false)
                  if (
                    text1.length > this.Match_MaxBits &&
                    this.diff_levenshtein(diffs) / text1.length >
                      this.Patch_DeleteThreshold
                  ) {
                    // The end points match, but the content is unacceptably bad.
                    results[x] = false
                  } else {
                    this.diff_cleanupSemanticLossless(diffs)
                    var index1 = 0
                    var index2
                    for (var y = 0; y < patches[x].diffs.length; y++) {
                      var mod = patches[x].diffs[y]
                      if (mod[0] !== DIFF_EQUAL) {
                        index2 = this.diff_xIndex(diffs, index1)
                      }
                      if (mod[0] === DIFF_INSERT) {
                        // Insertion
                        text =
                          text.substring(0, start_loc + index2) +
                          mod[1] +
                          text.substring(start_loc + index2)
                      } else if (mod[0] === DIFF_DELETE) {
                        // Deletion
                        text =
                          text.substring(0, start_loc + index2) +
                          text.substring(
                            start_loc +
                              this.diff_xIndex(diffs, index1 + mod[1].length)
                          )
                      }
                      if (mod[0] !== DIFF_DELETE) {
                        index1 += mod[1].length
                      }
                    }
                  }
                }
              }
            }
            // Strip the padding off.
            text = text.substring(
              nullPadding.length,
              text.length - nullPadding.length
            )
            return [text, results]
          }

          /**
           * Add some padding on text start and end so that edges can match something.
           * Intended to be called only from within patch_apply.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @return {string} The padding string added to each side.
           */
          diff_match_patch.prototype.patch_addPadding = function (patches) {
            var paddingLength = this.Patch_Margin
            var nullPadding = ''
            for (var x = 1; x <= paddingLength; x++) {
              nullPadding += String.fromCharCode(x)
            }

            // Bump all the patches forward.
            for (var x = 0; x < patches.length; x++) {
              patches[x].start1 += paddingLength
              patches[x].start2 += paddingLength
            }

            // Add some padding on start of first diff.
            var patch = patches[0]
            var diffs = patch.diffs
            if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
              // Add nullPadding equality.
              diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding))
              patch.start1 -= paddingLength // Should be 0.
              patch.start2 -= paddingLength // Should be 0.
              patch.length1 += paddingLength
              patch.length2 += paddingLength
            } else if (paddingLength > diffs[0][1].length) {
              // Grow first equality.
              var extraLength = paddingLength - diffs[0][1].length
              diffs[0][1] =
                nullPadding.substring(diffs[0][1].length) + diffs[0][1]
              patch.start1 -= extraLength
              patch.start2 -= extraLength
              patch.length1 += extraLength
              patch.length2 += extraLength
            }

            // Add some padding on end of last diff.
            patch = patches[patches.length - 1]
            diffs = patch.diffs
            if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
              // Add nullPadding equality.
              diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding))
              patch.length1 += paddingLength
              patch.length2 += paddingLength
            } else if (paddingLength > diffs[diffs.length - 1][1].length) {
              // Grow last equality.
              var extraLength =
                paddingLength - diffs[diffs.length - 1][1].length
              diffs[diffs.length - 1][1] += nullPadding.substring(
                0,
                extraLength
              )
              patch.length1 += extraLength
              patch.length2 += extraLength
            }

            return nullPadding
          }

          /**
           * Look through the patches and break up any which are longer than the maximum
           * limit of the match algorithm.
           * Intended to be called only from within patch_apply.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           */
          diff_match_patch.prototype.patch_splitMax = function (patches) {
            var patch_size = this.Match_MaxBits
            for (var x = 0; x < patches.length; x++) {
              if (patches[x].length1 <= patch_size) {
                continue
              }
              var bigpatch = patches[x]
              // Remove the big old patch.
              patches.splice(x--, 1)
              var start1 = bigpatch.start1
              var start2 = bigpatch.start2
              var precontext = ''
              while (bigpatch.diffs.length !== 0) {
                // Create one of several smaller patches.
                var patch = new diff_match_patch.patch_obj()
                var empty = true
                patch.start1 = start1 - precontext.length
                patch.start2 = start2 - precontext.length
                if (precontext !== '') {
                  patch.length1 = patch.length2 = precontext.length
                  patch.diffs.push(
                    new diff_match_patch.Diff(DIFF_EQUAL, precontext)
                  )
                }
                while (
                  bigpatch.diffs.length !== 0 &&
                  patch.length1 < patch_size - this.Patch_Margin
                ) {
                  var diff_type = bigpatch.diffs[0][0]
                  var diff_text = bigpatch.diffs[0][1]
                  if (diff_type === DIFF_INSERT) {
                    // Insertions are harmless.
                    patch.length2 += diff_text.length
                    start2 += diff_text.length
                    patch.diffs.push(bigpatch.diffs.shift())
                    empty = false
                  } else if (
                    diff_type === DIFF_DELETE &&
                    patch.diffs.length == 1 &&
                    patch.diffs[0][0] == DIFF_EQUAL &&
                    diff_text.length > 2 * patch_size
                  ) {
                    // This is a large deletion.  Let it pass in one chunk.
                    patch.length1 += diff_text.length
                    start1 += diff_text.length
                    empty = false
                    patch.diffs.push(
                      new diff_match_patch.Diff(diff_type, diff_text)
                    )
                    bigpatch.diffs.shift()
                  } else {
                    // Deletion or equality.  Only take as much as we can stomach.
                    diff_text = diff_text.substring(
                      0,
                      patch_size - patch.length1 - this.Patch_Margin
                    )
                    patch.length1 += diff_text.length
                    start1 += diff_text.length
                    if (diff_type === DIFF_EQUAL) {
                      patch.length2 += diff_text.length
                      start2 += diff_text.length
                    } else {
                      empty = false
                    }
                    patch.diffs.push(
                      new diff_match_patch.Diff(diff_type, diff_text)
                    )
                    if (diff_text == bigpatch.diffs[0][1]) {
                      bigpatch.diffs.shift()
                    } else {
                      bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(
                        diff_text.length
                      )
                    }
                  }
                }
                // Compute the head context for the next patch.
                precontext = this.diff_text2(patch.diffs)
                precontext = precontext.substring(
                  precontext.length - this.Patch_Margin
                )
                // Append the end context for this patch.
                var postcontext = this.diff_text1(bigpatch.diffs).substring(
                  0,
                  this.Patch_Margin
                )
                if (postcontext !== '') {
                  patch.length1 += postcontext.length
                  patch.length2 += postcontext.length
                  if (
                    patch.diffs.length !== 0 &&
                    patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL
                  ) {
                    patch.diffs[patch.diffs.length - 1][1] += postcontext
                  } else {
                    patch.diffs.push(
                      new diff_match_patch.Diff(DIFF_EQUAL, postcontext)
                    )
                  }
                }
                if (!empty) {
                  patches.splice(++x, 0, patch)
                }
              }
            }
          }

          /**
           * Take a list of patches and return a textual representation.
           * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
           * @return {string} Text representation of patches.
           */
          diff_match_patch.prototype.patch_toText = function (patches) {
            var text = []
            for (var x = 0; x < patches.length; x++) {
              text[x] = patches[x]
            }
            return text.join('')
          }

          /**
           * Parse a textual representation of patches and return a list of Patch objects.
           * @param {string} textline Text representation of patches.
           * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
           * @throws {!Error} If invalid input.
           */
          diff_match_patch.prototype.patch_fromText = function (textline) {
            var patches = []
            if (!textline) {
              return patches
            }
            var text = textline.split('\n')
            var textPointer = 0
            var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/
            while (textPointer < text.length) {
              var m = text[textPointer].match(patchHeader)
              if (!m) {
                throw new Error('Invalid patch string: ' + text[textPointer])
              }
              var patch = new diff_match_patch.patch_obj()
              patches.push(patch)
              patch.start1 = parseInt(m[1], 10)
              if (m[2] === '') {
                patch.start1--
                patch.length1 = 1
              } else if (m[2] == '0') {
                patch.length1 = 0
              } else {
                patch.start1--
                patch.length1 = parseInt(m[2], 10)
              }

              patch.start2 = parseInt(m[3], 10)
              if (m[4] === '') {
                patch.start2--
                patch.length2 = 1
              } else if (m[4] == '0') {
                patch.length2 = 0
              } else {
                patch.start2--
                patch.length2 = parseInt(m[4], 10)
              }
              textPointer++

              while (textPointer < text.length) {
                var sign = text[textPointer].charAt(0)
                try {
                  var line = decodeURI(text[textPointer].substring(1))
                } catch (ex) {
                  // Malformed URI sequence.
                  throw new Error('Illegal escape in patch_fromText: ' + line)
                }
                if (sign == '-') {
                  // Deletion.
                  patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line))
                } else if (sign == '+') {
                  // Insertion.
                  patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line))
                } else if (sign == ' ') {
                  // Minor equality.
                  patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line))
                } else if (sign == '@') {
                  // Start of next patch.
                  break
                } else if (sign === '');
                else {
                  // WTF?
                  throw new Error(
                    'Invalid patch mode "' + sign + '" in: ' + line
                  )
                }
                textPointer++
              }
            }
            return patches
          }

          /**
           * Class representing one patch operation.
           * @constructor
           */
          diff_match_patch.patch_obj = function () {
            /** @type {!Array.<!diff_match_patch.Diff>} */
            this.diffs = []
            /** @type {?number} */
            this.start1 = null
            /** @type {?number} */
            this.start2 = null
            /** @type {number} */
            this.length1 = 0
            /** @type {number} */
            this.length2 = 0
          }

          /**
           * Emulate GNU diff's format.
           * Header: @@ -382,8 +481,9 @@
           * Indices are printed as 1-based, not 0-based.
           * @return {string} The GNU diff string.
           */
          diff_match_patch.patch_obj.prototype.toString = function () {
            var coords1, coords2
            if (this.length1 === 0) {
              coords1 = this.start1 + ',0'
            } else if (this.length1 == 1) {
              coords1 = this.start1 + 1
            } else {
              coords1 = this.start1 + 1 + ',' + this.length1
            }
            if (this.length2 === 0) {
              coords2 = this.start2 + ',0'
            } else if (this.length2 == 1) {
              coords2 = this.start2 + 1
            } else {
              coords2 = this.start2 + 1 + ',' + this.length2
            }
            var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n']
            var op
            // Escape the body of the patch with %xx notation.
            for (var x = 0; x < this.diffs.length; x++) {
              switch (this.diffs[x][0]) {
                case DIFF_INSERT:
                  op = '+'
                  break
                case DIFF_DELETE:
                  op = '-'
                  break
                case DIFF_EQUAL:
                  op = ' '
                  break
              }
              text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n'
            }
            return text.join('').replace(/%20/g, ' ')
          }

          // The following export code was added by @ForbesLindesay
          module.exports = diff_match_patch
          module.exports['diff_match_patch'] = diff_match_patch
          module.exports['DIFF_DELETE'] = DIFF_DELETE
          module.exports['DIFF_INSERT'] = DIFF_INSERT
          module.exports['DIFF_EQUAL'] = DIFF_EQUAL
        })(diffMatchPatch)

        var diffMatchPatchExports = diffMatchPatch.exports
        var dmp = /*@__PURE__*/ getDefaultExportFromCjs(diffMatchPatchExports)

        /* global diff_match_patch */
        const TEXT_DIFF = 2
        const DEFAULT_MIN_LENGTH = 60
        let cachedDiffPatch = null
        const getDiffMatchPatch = function (required) {
          /* jshint camelcase: false */

          if (!cachedDiffPatch) {
            let instance
            /* eslint-disable camelcase, new-cap */
            if (typeof diff_match_patch !== 'undefined') {
              // already loaded, probably a browser
              instance =
                typeof diff_match_patch === 'function'
                  ? new diff_match_patch()
                  : new diff_match_patch.diff_match_patch()
            } else if (dmp) {
              try {
                instance = dmp && new dmp()
              } catch (err) {
                instance = null
              }
            }
            /* eslint-enable camelcase, new-cap */
            if (!instance) {
              if (!required) {
                return null
              }
              const error = new Error('text diff_match_patch library not found')
              // eslint-disable-next-line camelcase
              error.diff_match_patch_not_found = true
              throw error
            }
            cachedDiffPatch = {
              diff: function (txt1, txt2) {
                return instance.patch_toText(instance.patch_make(txt1, txt2))
              },
              patch: function (txt1, patch) {
                const results = instance.patch_apply(
                  instance.patch_fromText(patch),
                  txt1
                )
                for (let i = 0; i < results[1].length; i++) {
                  if (!results[1][i]) {
                    const error = new Error('text patch failed')
                    error.textPatchFailed = true
                  }
                }
                return results[0]
              }
            }
          }
          return cachedDiffPatch
        }
        const diffFilter = function textsDiffFilter(context) {
          if (context.leftType !== 'string') {
            return
          }
          const minLength =
            (context.options &&
              context.options.textDiff &&
              context.options.textDiff.minLength) ||
            DEFAULT_MIN_LENGTH
          if (
            context.left.length < minLength ||
            context.right.length < minLength
          ) {
            context.setResult([context.left, context.right]).exit()
            return
          }
          // large text, try to use a text-diff algorithm
          const diffMatchPatch = getDiffMatchPatch()
          if (!diffMatchPatch) {
            // diff-match-patch library not available,
            // fallback to regular string replace
            context.setResult([context.left, context.right]).exit()
            return
          }
          const diff = diffMatchPatch.diff
          context
            .setResult([diff(context.left, context.right), 0, TEXT_DIFF])
            .exit()
        }
        diffFilter.filterName = 'texts'
        const patchFilter = function textsPatchFilter(context) {
          if (context.nested) {
            return
          }
          if (context.delta[2] !== TEXT_DIFF) {
            return
          }

          // text-diff, use a text-patch algorithm
          const patch = getDiffMatchPatch(true).patch
          context.setResult(patch(context.left, context.delta[0])).exit()
        }
        patchFilter.filterName = 'texts'
        const textDeltaReverse = function (delta) {
          let i
          let l
          let line
          let lineTmp
          let header = null
          const headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/
          let lineHeader
          const lines = delta.split('\n')
          for (i = 0, l = lines.length; i < l; i++) {
            line = lines[i]
            const lineStart = line.slice(0, 1)
            if (lineStart === '@') {
              header = headerRegex.exec(line)
              lineHeader = i

              // fix header
              lines[lineHeader] =
                '@@ -' +
                header[3] +
                ',' +
                header[4] +
                ' +' +
                header[1] +
                ',' +
                header[2] +
                ' @@'
            } else if (lineStart === '+') {
              lines[i] = '-' + lines[i].slice(1)
              if (lines[i - 1].slice(0, 1) === '+') {
                // swap lines to keep default order (-+)
                lineTmp = lines[i]
                lines[i] = lines[i - 1]
                lines[i - 1] = lineTmp
              }
            } else if (lineStart === '-') {
              lines[i] = '+' + lines[i].slice(1)
            }
          }
          return lines.join('\n')
        }
        const reverseFilter = function textsReverseFilter(context) {
          if (context.nested) {
            return
          }
          if (context.delta[2] !== TEXT_DIFF) {
            return
          }

          // text-diff, use a text-diff algorithm
          context
            .setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF])
            .exit()
        }
        reverseFilter.filterName = 'texts'

        class DiffPatcher {
          constructor(options) {
            this.processor = new Processor(options)
            this.processor.pipe(
              new Pipe('diff')
                .append(
                  collectChildrenDiffFilter,
                  diffFilter$3,
                  diffFilter$1,
                  diffFilter,
                  objectsDiffFilter,
                  diffFilter$2
                )
                .shouldHaveResult()
            )
            this.processor.pipe(
              new Pipe('patch')
                .append(
                  collectChildrenPatchFilter$1,
                  collectChildrenPatchFilter,
                  patchFilter$3,
                  patchFilter,
                  patchFilter$2,
                  patchFilter$1
                )
                .shouldHaveResult()
            )
            this.processor.pipe(
              new Pipe('reverse')
                .append(
                  collectChildrenReverseFilter$1,
                  collectChildrenReverseFilter,
                  reverseFilter$3,
                  reverseFilter,
                  reverseFilter$2,
                  reverseFilter$1
                )
                .shouldHaveResult()
            )
          }
          options() {
            return this.processor.options(...arguments)
          }
          diff(left, right) {
            return this.processor.process(new DiffContext(left, right))
          }
          patch(left, delta) {
            return this.processor.process(new PatchContext(left, delta))
          }
          reverse(delta) {
            return this.processor.process(new ReverseContext(delta))
          }
          unpatch(right, delta) {
            return this.patch(right, this.reverse(delta))
          }
          clone(value) {
            return clone$1(value)
          }
        }

        const isArray =
          typeof Array.isArray === 'function'
            ? Array.isArray
            : (a) => a instanceof Array
        const getObjectKeys =
          typeof Object.keys === 'function'
            ? (obj) => Object.keys(obj)
            : (obj) => {
                const names = []
                for (const property in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, property)) {
                    names.push(property)
                  }
                }
                return names
              }
        const trimUnderscore = (str) => {
          if (str.substr(0, 1) === '_') {
            return str.slice(1)
          }
          return str
        }
        const arrayKeyToSortNumber = (key) => {
          if (key === '_t') {
            return -1
          } else {
            if (key.substr(0, 1) === '_') {
              return parseInt(key.slice(1), 10)
            } else {
              return parseInt(key, 10) + 0.1
            }
          }
        }
        const arrayKeyComparer = (key1, key2) =>
          arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2)
        class BaseFormatter {
          format(delta, left) {
            const context = {}
            this.prepareContext(context)
            this.recurse(context, delta, left)
            return this.finalize(context)
          }
          prepareContext(context) {
            context.buffer = []
            context.out = function () {
              this.buffer.push(...arguments)
            }
          }
          typeFormattterNotFound(context, deltaType) {
            throw new Error(`cannot format delta type: ${deltaType}`)
          }
          typeFormattterErrorFormatter(context, err) {
            return err.toString()
          }
          finalize(_ref) {
            let { buffer } = _ref
            if (isArray(buffer)) {
              return buffer.join('')
            }
          }
          recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
            const useMoveOriginHere = delta && movedFrom
            const leftValue = useMoveOriginHere ? movedFrom.value : left
            if (typeof delta === 'undefined' && typeof key === 'undefined') {
              return undefined
            }
            const type = this.getDeltaType(delta, movedFrom)
            const nodeType =
              type === 'node' ? (delta._t === 'a' ? 'array' : 'object') : ''
            if (typeof key !== 'undefined') {
              this.nodeBegin(context, key, leftKey, type, nodeType, isLast)
            } else {
              this.rootBegin(context, type, nodeType)
            }
            let typeFormattter
            try {
              typeFormattter =
                this[`format_${type}`] ||
                this.typeFormattterNotFound(context, type)
              typeFormattter.call(
                this,
                context,
                delta,
                leftValue,
                key,
                leftKey,
                movedFrom
              )
            } catch (err) {
              this.typeFormattterErrorFormatter(
                context,
                err,
                delta,
                leftValue,
                key,
                leftKey,
                movedFrom
              )
              if (typeof console !== 'undefined' && console.error) {
                console.error(err.stack)
              }
            }
            if (typeof key !== 'undefined') {
              this.nodeEnd(context, key, leftKey, type, nodeType, isLast)
            } else {
              this.rootEnd(context, type, nodeType)
            }
          }
          formatDeltaChildren(context, delta, left) {
            const self = this
            this.forEachDeltaKey(
              delta,
              left,
              (key, leftKey, movedFrom, isLast) => {
                self.recurse(
                  context,
                  delta[key],
                  left ? left[leftKey] : undefined,
                  key,
                  leftKey,
                  movedFrom,
                  isLast
                )
              }
            )
          }
          forEachDeltaKey(delta, left, fn) {
            const keys = getObjectKeys(delta)
            const arrayKeys = delta._t === 'a'
            const moveDestinations = {}
            let name
            if (typeof left !== 'undefined') {
              for (name in left) {
                if (Object.prototype.hasOwnProperty.call(left, name)) {
                  if (
                    typeof delta[name] === 'undefined' &&
                    (!arrayKeys || typeof delta[`_${name}`] === 'undefined')
                  ) {
                    keys.push(name)
                  }
                }
              }
            }
            // look for move destinations
            for (name in delta) {
              if (Object.prototype.hasOwnProperty.call(delta, name)) {
                const value = delta[name]
                if (isArray(value) && value[2] === 3) {
                  moveDestinations[value[1].toString()] = {
                    key: name,
                    value: left && left[parseInt(name.substr(1))]
                  }
                  if (this.includeMoveDestinations !== false) {
                    if (
                      typeof left === 'undefined' &&
                      typeof delta[value[1]] === 'undefined'
                    ) {
                      keys.push(value[1].toString())
                    }
                  }
                }
              }
            }
            if (arrayKeys) {
              keys.sort(arrayKeyComparer)
            } else {
              keys.sort()
            }
            for (let index = 0, length = keys.length; index < length; index++) {
              const key = keys[index]
              if (arrayKeys && key === '_t') {
                continue
              }
              const leftKey = arrayKeys
                ? typeof key === 'number'
                  ? key
                  : parseInt(trimUnderscore(key), 10)
                : key
              const isLast = index === length - 1
              fn(key, leftKey, moveDestinations[leftKey], isLast)
            }
          }
          getDeltaType(delta, movedFrom) {
            if (typeof delta === 'undefined') {
              if (typeof movedFrom !== 'undefined') {
                return 'movedestination'
              }
              return 'unchanged'
            }
            if (isArray(delta)) {
              if (delta.length === 1) {
                return 'added'
              }
              if (delta.length === 2) {
                return 'modified'
              }
              if (delta.length === 3 && delta[2] === 0) {
                return 'deleted'
              }
              if (delta.length === 3 && delta[2] === 2) {
                return 'textdiff'
              }
              if (delta.length === 3 && delta[2] === 3) {
                return 'moved'
              }
            } else if (typeof delta === 'object') {
              return 'node'
            }
            return 'unknown'
          }
          parseTextDiff(value) {
            const output = []
            const lines = value.split('\n@@ ')
            for (let i = 0, l = lines.length; i < l; i++) {
              const line = lines[i]
              const lineOutput = {
                pieces: []
              }
              const location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1)
              lineOutput.location = {
                line: location[0],
                chr: location[1]
              }
              const pieces = line.split('\n').slice(1)
              for (
                let pieceIndex = 0, piecesLength = pieces.length;
                pieceIndex < piecesLength;
                pieceIndex++
              ) {
                const piece = pieces[pieceIndex]
                if (!piece.length) {
                  continue
                }
                const pieceOutput = {
                  type: 'context'
                }
                if (piece.substr(0, 1) === '+') {
                  pieceOutput.type = 'added'
                } else if (piece.substr(0, 1) === '-') {
                  pieceOutput.type = 'deleted'
                }
                pieceOutput.text = piece.slice(1)
                lineOutput.pieces.push(pieceOutput)
              }
              output.push(lineOutput)
            }
            return output
          }
        }

        var base = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          default: BaseFormatter
        })

        class HtmlFormatter extends BaseFormatter {
          typeFormattterErrorFormatter(context, err) {
            context.out(`<pre class="jsondiffpatch-error">${err}</pre>`)
          }
          formatValue(context, value) {
            context.out(
              `<pre>${htmlEscape(JSON.stringify(value, null, 2))}</pre>`
            )
          }
          formatTextDiffString(context, value) {
            const lines = this.parseTextDiff(value)
            context.out('<ul class="jsondiffpatch-textdiff">')
            for (let i = 0, l = lines.length; i < l; i++) {
              const line = lines[i]
              context.out(
                '<li><div class="jsondiffpatch-textdiff-location">' +
                  `<span class="jsondiffpatch-textdiff-line-number">${line.location.line}</span><span class="jsondiffpatch-textdiff-char">${line.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`
              )
              const pieces = line.pieces
              for (
                let pieceIndex = 0, piecesLength = pieces.length;
                pieceIndex < piecesLength;
                pieceIndex++
              ) {
                /* global decodeURI */
                const piece = pieces[pieceIndex]
                context.out(
                  `<span class="jsondiffpatch-textdiff-${
                    piece.type
                  }">${htmlEscape(decodeURI(piece.text))}</span>`
                )
              }
              context.out('</div></li>')
            }
            context.out('</ul>')
          }
          rootBegin(context, type, nodeType) {
            const nodeClass = `jsondiffpatch-${type}${
              nodeType ? ` jsondiffpatch-child-node-type-${nodeType}` : ''
            }`
            context.out(`<div class="jsondiffpatch-delta ${nodeClass}">`)
          }
          rootEnd(context) {
            context.out(
              `</div>${
                context.hasArrows
                  ? '<script type="text/javascript">setTimeout(' +
                    `${adjustArrows.toString()},10);</script>`
                  : ''
              }`
            )
          }
          nodeBegin(context, key, leftKey, type, nodeType) {
            const nodeClass = `jsondiffpatch-${type}${
              nodeType ? ` jsondiffpatch-child-node-type-${nodeType}` : ''
            }`
            context.out(
              `<li class="${nodeClass}" data-key="${leftKey}">` +
                `<div class="jsondiffpatch-property-name">${leftKey}</div>`
            )
          }
          nodeEnd(context) {
            context.out('</li>')
          }

          /* jshint camelcase: false */
          /* eslint-disable camelcase */

          format_unchanged(context, delta, left) {
            if (typeof left === 'undefined') {
              return
            }
            context.out('<div class="jsondiffpatch-value">')
            this.formatValue(context, left)
            context.out('</div>')
          }
          format_movedestination(context, delta, left) {
            if (typeof left === 'undefined') {
              return
            }
            context.out('<div class="jsondiffpatch-value">')
            this.formatValue(context, left)
            context.out('</div>')
          }
          format_node(context, delta, left) {
            // recurse
            const nodeType = delta._t === 'a' ? 'array' : 'object'
            context.out(
              `<ul class="jsondiffpatch-node jsondiffpatch-node-type-${nodeType}">`
            )
            this.formatDeltaChildren(context, delta, left)
            context.out('</ul>')
          }
          format_added(context, delta) {
            context.out('<div class="jsondiffpatch-value">')
            this.formatValue(context, delta[0])
            context.out('</div>')
          }
          format_modified(context, delta) {
            context.out(
              '<div class="jsondiffpatch-value jsondiffpatch-left-value">'
            )
            this.formatValue(context, delta[0])
            context.out(
              '</div>' +
                '<div class="jsondiffpatch-value jsondiffpatch-right-value">'
            )
            this.formatValue(context, delta[1])
            context.out('</div>')
          }
          format_deleted(context, delta) {
            context.out('<div class="jsondiffpatch-value">')
            this.formatValue(context, delta[0])
            context.out('</div>')
          }
          format_moved(context, delta) {
            context.out('<div class="jsondiffpatch-value">')
            this.formatValue(context, delta[0])
            context.out(
              `</div><div class="jsondiffpatch-moved-destination">${delta[1]}</div>`
            )

            // draw an SVG arrow from here to move destination
            context.out(
              /* jshint multistr: true */
              '<div class="jsondiffpatch-arrow" ' +
                `style="position: relative; left: -34px;">
          <svg width="30" height="60" ` +
                `style="position: absolute; display: none;">
          <defs>
              <marker id="markerArrow" markerWidth="8" markerHeight="8"
                 refx="2" refy="4"
                     orient="auto" markerUnits="userSpaceOnUse">
                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />
              </marker>
          </defs>
          <path d="M30,0 Q-10,25 26,50"
            style="stroke: #88f; stroke-width: 2px; fill: none; ` +
                `stroke-opacity: 0.5; marker-end: url(#markerArrow);"
          ></path>
          </svg>
      </div>`
            )
            context.hasArrows = true
          }
          format_textdiff(context, delta) {
            context.out('<div class="jsondiffpatch-value">')
            this.formatTextDiffString(context, delta[0])
            context.out('</div>')
          }
        }
        function htmlEscape(text) {
          let html = text
          const replacements = [
            [/&/g, '&amp;'],
            [/</g, '&lt;'],
            [/>/g, '&gt;'],
            [/'/g, '&apos;'],
            [/"/g, '&quot;']
          ]
          for (let i = 0; i < replacements.length; i++) {
            html = html.replace(replacements[i][0], replacements[i][1])
          }
          return html
        }
        const adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(
          nodeArg
        ) {
          const node = nodeArg || document
          const getElementText = (_ref) => {
            let { textContent, innerText } = _ref
            return textContent || innerText
          }
          const eachByQuery = (el, query, fn) => {
            const elems = el.querySelectorAll(query)
            for (let i = 0, l = elems.length; i < l; i++) {
              fn(elems[i])
            }
          }
          const eachChildren = (_ref2, fn) => {
            let { children } = _ref2
            for (let i = 0, l = children.length; i < l; i++) {
              fn(children[i], i)
            }
          }
          eachByQuery(node, '.jsondiffpatch-arrow', (_ref3) => {
            let { parentNode, children, style } = _ref3
            const arrowParent = parentNode
            const svg = children[0]
            const path = svg.children[1]
            svg.style.display = 'none'
            const destination = getElementText(
              arrowParent.querySelector('.jsondiffpatch-moved-destination')
            )
            const container = arrowParent.parentNode
            let destinationElem
            eachChildren(container, (child) => {
              if (child.getAttribute('data-key') === destination) {
                destinationElem = child
              }
            })
            if (!destinationElem) {
              return
            }
            try {
              const distance = destinationElem.offsetTop - arrowParent.offsetTop
              svg.setAttribute('height', Math.abs(distance) + 6)
              style.top = `${-8 + (distance > 0 ? 0 : distance)}px`
              const curve =
                distance > 0
                  ? `M30,0 Q-10,${Math.round(distance / 2)} 26,${distance - 4}`
                  : `M30,${-distance} Q-10,${Math.round(-distance / 2)} 26,4`
              path.setAttribute('d', curve)
              svg.style.display = ''
            } catch (err) {}
          })
        }

        /* jshint camelcase: true */
        /* eslint-enable camelcase */

        const showUnchanged = (show, node, delay) => {
          const el = node || document.body
          const prefix = 'jsondiffpatch-unchanged-'
          const classes = {
            showing: `${prefix}showing`,
            hiding: `${prefix}hiding`,
            visible: `${prefix}visible`,
            hidden: `${prefix}hidden`
          }
          const list = el.classList
          if (!list) {
            return
          }
          if (!delay) {
            list.remove(classes.showing)
            list.remove(classes.hiding)
            list.remove(classes.visible)
            list.remove(classes.hidden)
            if (show === false) {
              list.add(classes.hidden)
            }
            return
          }
          if (show === false) {
            list.remove(classes.showing)
            list.add(classes.visible)
            setTimeout(() => {
              list.add(classes.hiding)
            }, 10)
          } else {
            list.remove(classes.hiding)
            list.add(classes.showing)
            list.remove(classes.hidden)
          }
          const intervalId = setInterval(() => {
            adjustArrows(el)
          }, 100)
          setTimeout(() => {
            list.remove(classes.showing)
            list.remove(classes.hiding)
            if (show === false) {
              list.add(classes.hidden)
              list.remove(classes.visible)
            } else {
              list.add(classes.visible)
              list.remove(classes.hidden)
            }
            setTimeout(() => {
              list.remove(classes.visible)
              clearInterval(intervalId)
            }, delay + 400)
          }, delay)
        }
        const hideUnchanged = (node, delay) => showUnchanged(false, node, delay)
        let defaultInstance$4
        function format$3(delta, left) {
          if (!defaultInstance$4) {
            defaultInstance$4 = new HtmlFormatter()
          }
          return defaultInstance$4.format(delta, left)
        }

        var html = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          default: HtmlFormatter,
          format: format$3,
          hideUnchanged: hideUnchanged,
          showUnchanged: showUnchanged
        })

        class AnnotatedFormatter extends BaseFormatter {
          constructor() {
            super()
            this.includeMoveDestinations = false
          }
          prepareContext(context) {
            super.prepareContext(context)
            context.indent = function (levels) {
              this.indentLevel =
                (this.indentLevel || 0) +
                (typeof levels === 'undefined' ? 1 : levels)
              this.indentPad = new Array(this.indentLevel + 1).join(
                '&nbsp;&nbsp;'
              )
            }
            context.row = (json, htmlNote) => {
              context.out(
                '<tr><td style="white-space: nowrap;">' +
                  '<pre class="jsondiffpatch-annotated-indent"' +
                  ' style="display: inline-block">'
              )
              context.out(context.indentPad)
              context.out('</pre><pre style="display: inline-block">')
              context.out(json)
              context.out(
                '</pre></td><td class="jsondiffpatch-delta-note"><div>'
              )
              context.out(htmlNote)
              context.out('</div></td></tr>')
            }
          }
          typeFormattterErrorFormatter(context, err) {
            context.row('', `<pre class="jsondiffpatch-error">${err}</pre>`)
          }
          formatTextDiffString(context, value) {
            const lines = this.parseTextDiff(value)
            context.out('<ul class="jsondiffpatch-textdiff">')
            for (let i = 0, l = lines.length; i < l; i++) {
              const line = lines[i]
              context.out(
                '<li><div class="jsondiffpatch-textdiff-location">' +
                  `<span class="jsondiffpatch-textdiff-line-number">${line.location.line}</span><span class="jsondiffpatch-textdiff-char">${line.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`
              )
              const pieces = line.pieces
              for (
                let pieceIndex = 0, piecesLength = pieces.length;
                pieceIndex < piecesLength;
                pieceIndex++
              ) {
                const piece = pieces[pieceIndex]
                context.out(
                  `<span class="jsondiffpatch-textdiff-${piece.type}">${piece.text}</span>`
                )
              }
              context.out('</div></li>')
            }
            context.out('</ul>')
          }
          rootBegin(context, type, nodeType) {
            context.out('<table class="jsondiffpatch-annotated-delta">')
            if (type === 'node') {
              context.row('{')
              context.indent()
            }
            if (nodeType === 'array') {
              context.row(
                '"_t": "a",',
                'Array delta (member names indicate array indices)'
              )
            }
          }
          rootEnd(context, type) {
            if (type === 'node') {
              context.indent(-1)
              context.row('}')
            }
            context.out('</table>')
          }
          nodeBegin(context, key, leftKey, type, nodeType) {
            context.row(`&quot;${key}&quot;: {`)
            if (type === 'node') {
              context.indent()
            }
            if (nodeType === 'array') {
              context.row(
                '"_t": "a",',
                'Array delta (member names indicate array indices)'
              )
            }
          }
          nodeEnd(context, key, leftKey, type, nodeType, isLast) {
            if (type === 'node') {
              context.indent(-1)
            }
            context.row(`}${isLast ? '' : ','}`)
          }

          /* jshint camelcase: false */

          /* eslint-disable camelcase */
          format_unchanged() {}
          format_movedestination() {}
          format_node(context, delta, left) {
            // recurse
            this.formatDeltaChildren(context, delta, left)
          }
        }

        /* eslint-enable camelcase */

        const wrapPropertyName = (name) =>
          `<pre style="display:inline-block">&quot;${name}&quot;</pre>`
        const deltaAnnotations = {
          added(delta, left, key, leftKey) {
            const formatLegend = ' <pre>([newValue])</pre>'
            if (typeof leftKey === 'undefined') {
              return `new value${formatLegend}`
            }
            if (typeof leftKey === 'number') {
              return `insert at index ${leftKey}${formatLegend}`
            }
            return `add property ${wrapPropertyName(leftKey)}${formatLegend}`
          },
          modified(delta, left, key, leftKey) {
            const formatLegend = ' <pre>([previousValue, newValue])</pre>'
            if (typeof leftKey === 'undefined') {
              return `modify value${formatLegend}`
            }
            if (typeof leftKey === 'number') {
              return `modify at index ${leftKey}${formatLegend}`
            }
            return `modify property ${wrapPropertyName(leftKey)}${formatLegend}`
          },
          deleted(delta, left, key, leftKey) {
            const formatLegend = ' <pre>([previousValue, 0, 0])</pre>'
            if (typeof leftKey === 'undefined') {
              return `delete value${formatLegend}`
            }
            if (typeof leftKey === 'number') {
              return `remove index ${leftKey}${formatLegend}`
            }
            return `delete property ${wrapPropertyName(leftKey)}${formatLegend}`
          },
          moved(delta, left, key, leftKey) {
            return (
              'move from <span title="(position to remove at original state)">' +
              `index ${leftKey}</span> to <span title="(position to insert at final` +
              ` state)">index ${delta[1]}</span>`
            )
          },
          textdiff(delta, left, key, leftKey) {
            const location =
              typeof leftKey === 'undefined'
                ? ''
                : typeof leftKey === 'number'
                  ? ` at index ${leftKey}`
                  : ` at property ${wrapPropertyName(leftKey)}`
            return (
              `text diff${location}, format is <a href="https://code.google.com/` +
              'p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>'
            )
          }
        }
        const formatAnyChange = function (context, delta) {
          const deltaType = this.getDeltaType(delta)
          const annotator = deltaAnnotations[deltaType]
          const htmlNote =
            annotator &&
            annotator.apply(annotator, Array.prototype.slice.call(arguments, 1))
          let json = JSON.stringify(delta, null, 2)
          if (deltaType === 'textdiff') {
            // split text diffs lines
            json = json.split('\\n').join('\\n"+\n   "')
          }
          context.indent()
          context.row(json, htmlNote)
          context.indent(-1)
        }

        /* eslint-disable camelcase */
        AnnotatedFormatter.prototype.format_added = formatAnyChange
        AnnotatedFormatter.prototype.format_modified = formatAnyChange
        AnnotatedFormatter.prototype.format_deleted = formatAnyChange
        AnnotatedFormatter.prototype.format_moved = formatAnyChange
        AnnotatedFormatter.prototype.format_textdiff = formatAnyChange
        let defaultInstance$3
        function format$2(delta, left) {
          if (!defaultInstance$3) {
            defaultInstance$3 = new AnnotatedFormatter()
          }
          return defaultInstance$3.format(delta, left)
        }

        var annotated = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          default: AnnotatedFormatter,
          format: format$2
        })

        const OPERATIONS = {
          add: 'add',
          remove: 'remove',
          replace: 'replace',
          move: 'move'
        }
        class JSONFormatter extends BaseFormatter {
          constructor() {
            super()
            this.includeMoveDestinations = true
          }
          prepareContext(context) {
            super.prepareContext(context)
            context.result = []
            context.path = []
            context.pushCurrentOp = function (obj) {
              const { op, value } = obj
              const val = {
                op,
                path: this.currentPath()
              }
              if (typeof value !== 'undefined') {
                val.value = value
              }
              this.result.push(val)
            }
            context.pushMoveOp = function (to) {
              const from = this.currentPath()
              this.result.push({
                op: OPERATIONS.move,
                from,
                path: this.toPath(to)
              })
            }
            context.currentPath = function () {
              return `/${this.path.join('/')}`
            }
            context.toPath = function (toPath) {
              const to = this.path.slice()
              to[to.length - 1] = toPath
              return `/${to.join('/')}`
            }
          }
          typeFormattterErrorFormatter(context, err) {
            context.out(`[ERROR] ${err}`)
          }
          rootBegin() {}
          rootEnd() {}
          nodeBegin(_ref, key, leftKey) {
            let { path } = _ref
            path.push(leftKey)
          }
          nodeEnd(_ref2) {
            let { path } = _ref2
            path.pop()
          }

          /* jshint camelcase: false */
          /* eslint-disable camelcase */

          format_unchanged() {}
          format_movedestination() {}
          format_node(context, delta, left) {
            this.formatDeltaChildren(context, delta, left)
          }
          format_added(context, delta) {
            context.pushCurrentOp({
              op: OPERATIONS.add,
              value: delta[0]
            })
          }
          format_modified(context, delta) {
            context.pushCurrentOp({
              op: OPERATIONS.replace,
              value: delta[1]
            })
          }
          format_deleted(context) {
            context.pushCurrentOp({
              op: OPERATIONS.remove
            })
          }
          format_moved(context, delta) {
            const to = delta[1]
            context.pushMoveOp(to)
          }
          format_textdiff() {
            throw new Error('Not implemented')
          }
          format(delta, left) {
            const context = {}
            this.prepareContext(context)
            this.recurse(context, delta, left)
            return context.result
          }
        }
        const last = (arr) => arr[arr.length - 1]
        const sortBy = (arr, pred) => {
          arr.sort(pred)
          return arr
        }
        const compareByIndexDesc = (indexA, indexB) => {
          const lastA = parseInt(indexA, 10)
          const lastB = parseInt(indexB, 10)
          if (!(isNaN(lastA) || isNaN(lastB))) {
            return lastB - lastA
          } else {
            return 0
          }
        }
        const opsByDescendingOrder = (removeOps) =>
          sortBy(removeOps, (a, b) => {
            const splitA = a.path.split('/')
            const splitB = b.path.split('/')
            if (splitA.length !== splitB.length) {
              return splitA.length - splitB.length
            } else {
              return compareByIndexDesc(last(splitA), last(splitB))
            }
          })
        const partitionOps = (arr, fns) => {
          const initArr = Array(fns.length + 1)
            .fill()
            .map(() => [])
          return arr
            .map((item) => {
              let position = fns.map((fn) => fn(item)).indexOf(true)
              if (position < 0) {
                position = fns.length
              }
              return {
                item,
                position
              }
            })
            .reduce((acc, item) => {
              acc[item.position].push(item.item)
              return acc
            }, initArr)
        }
        const isMoveOp = (_ref3) => {
          let { op } = _ref3
          return op === 'move'
        }
        const isRemoveOp = (_ref4) => {
          let { op } = _ref4
          return op === 'remove'
        }
        const reorderOps = (diff) => {
          const [moveOps, removedOps, restOps] = partitionOps(diff, [
            isMoveOp,
            isRemoveOp
          ])
          const removeOpsReverse = opsByDescendingOrder(removedOps)
          return [...removeOpsReverse, ...moveOps, ...restOps]
        }
        let defaultInstance$2
        const format$1 = (delta, left) => {
          if (!defaultInstance$2) {
            defaultInstance$2 = new JSONFormatter()
          }
          return reorderOps(defaultInstance$2.format(delta, left))
        }
        const log$1 = (delta, left) => {
          console.log(format$1(delta, left))
        }

        var jsonpatch = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          default: JSONFormatter,
          format: format$1,
          log: log$1,
          partitionOps: partitionOps
        })

        function chalkColor(name) {
          return (
            (chalk && chalk[name]) ||
            function () {
              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key]
              }
              return args
            }
          )
        }
        const colors = {
          added: chalkColor('green'),
          deleted: chalkColor('red'),
          movedestination: chalkColor('gray'),
          moved: chalkColor('yellow'),
          unchanged: chalkColor('gray'),
          error: chalkColor('white.bgRed'),
          textDiffLine: chalkColor('gray')
        }
        class ConsoleFormatter extends BaseFormatter {
          constructor() {
            super()
            this.includeMoveDestinations = false
          }
          prepareContext(context) {
            super.prepareContext(context)
            context.indent = function (levels) {
              this.indentLevel =
                (this.indentLevel || 0) +
                (typeof levels === 'undefined' ? 1 : levels)
              this.indentPad = new Array(this.indentLevel + 1).join('  ')
              this.outLine()
            }
            context.outLine = function () {
              this.buffer.push(`\n${this.indentPad || ''}`)
            }
            context.out = function () {
              for (
                var _len2 = arguments.length,
                  args = new Array(_len2),
                  _key2 = 0;
                _key2 < _len2;
                _key2++
              ) {
                args[_key2] = arguments[_key2]
              }
              for (let i = 0, l = args.length; i < l; i++) {
                const lines = args[i].split('\n')
                let text = lines.join(`\n${this.indentPad || ''}`)
                if (this.color && this.color[0]) {
                  text = this.color[0](text)
                }
                this.buffer.push(text)
              }
            }
            context.pushColor = function (color) {
              this.color = this.color || []
              this.color.unshift(color)
            }
            context.popColor = function () {
              this.color = this.color || []
              this.color.shift()
            }
          }
          typeFormattterErrorFormatter(context, err) {
            context.pushColor(colors.error)
            context.out(`[ERROR]${err}`)
            context.popColor()
          }
          formatValue(context, value) {
            context.out(JSON.stringify(value, null, 2))
          }
          formatTextDiffString(context, value) {
            const lines = this.parseTextDiff(value)
            context.indent()
            for (let i = 0, l = lines.length; i < l; i++) {
              const line = lines[i]
              context.pushColor(colors.textDiffLine)
              context.out(`${line.location.line},${line.location.chr} `)
              context.popColor()
              const pieces = line.pieces
              for (
                let pieceIndex = 0, piecesLength = pieces.length;
                pieceIndex < piecesLength;
                pieceIndex++
              ) {
                const piece = pieces[pieceIndex]
                context.pushColor(colors[piece.type])
                context.out(piece.text)
                context.popColor()
              }
              if (i < l - 1) {
                context.outLine()
              }
            }
            context.indent(-1)
          }
          rootBegin(context, type, nodeType) {
            context.pushColor(colors[type])
            if (type === 'node') {
              context.out(nodeType === 'array' ? '[' : '{')
              context.indent()
            }
          }
          rootEnd(context, type, nodeType) {
            if (type === 'node') {
              context.indent(-1)
              context.out(nodeType === 'array' ? ']' : '}')
            }
            context.popColor()
          }
          nodeBegin(context, key, leftKey, type, nodeType) {
            context.pushColor(colors[type])
            context.out(`${leftKey}: `)
            if (type === 'node') {
              context.out(nodeType === 'array' ? '[' : '{')
              context.indent()
            }
          }
          nodeEnd(context, key, leftKey, type, nodeType, isLast) {
            if (type === 'node') {
              context.indent(-1)
              context.out(nodeType === 'array' ? ']' : `}${isLast ? '' : ','}`)
            }
            if (!isLast) {
              context.outLine()
            }
            context.popColor()
          }

          /* jshint camelcase: false */
          /* eslint-disable camelcase */

          format_unchanged(context, delta, left) {
            if (typeof left === 'undefined') {
              return
            }
            this.formatValue(context, left)
          }
          format_movedestination(context, delta, left) {
            if (typeof left === 'undefined') {
              return
            }
            this.formatValue(context, left)
          }
          format_node(context, delta, left) {
            // recurse
            this.formatDeltaChildren(context, delta, left)
          }
          format_added(context, delta) {
            this.formatValue(context, delta[0])
          }
          format_modified(context, delta) {
            context.pushColor(colors.deleted)
            this.formatValue(context, delta[0])
            context.popColor()
            context.out(' => ')
            context.pushColor(colors.added)
            this.formatValue(context, delta[1])
            context.popColor()
          }
          format_deleted(context, delta) {
            this.formatValue(context, delta[0])
          }
          format_moved(context, delta) {
            context.out(`==> ${delta[1]}`)
          }
          format_textdiff(context, delta) {
            this.formatTextDiffString(context, delta[0])
          }
        }
        let defaultInstance$1
        const format = (delta, left) => {
          if (!defaultInstance$1) {
            defaultInstance$1 = new ConsoleFormatter()
          }
          return defaultInstance$1.format(delta, left)
        }
        function log(delta, left) {
          console.log(format(delta, left))
        }

        var console$1 = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          default: ConsoleFormatter,
          format: format,
          log: log
        })

        var index = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          annotated: annotated,
          base: base,
          console: console$1,
          html: html,
          jsonpatch: jsonpatch
        })

        // use as 2nd parameter for JSON.parse to revive Date instances
        function dateReviver(key, value) {
          let parts
          if (typeof value === 'string') {
            // eslint-disable-next-line max-len
            parts =
              /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(
                value
              )
            if (parts) {
              return new Date(
                Date.UTC(
                  +parts[1],
                  +parts[2] - 1,
                  +parts[3],
                  +parts[4],
                  +parts[5],
                  +parts[6],
                  +(parts[7] || 0)
                )
              )
            }
          }
          return value
        }

        function create(options) {
          return new DiffPatcher(options)
        }
        let defaultInstance
        function diff() {
          if (!defaultInstance) {
            defaultInstance = new DiffPatcher()
          }
          return defaultInstance.diff.apply(defaultInstance, arguments)
        }
        function patch() {
          if (!defaultInstance) {
            defaultInstance = new DiffPatcher()
          }
          return defaultInstance.patch.apply(defaultInstance, arguments)
        }
        function unpatch() {
          if (!defaultInstance) {
            defaultInstance = new DiffPatcher()
          }
          return defaultInstance.unpatch.apply(defaultInstance, arguments)
        }
        function reverse() {
          if (!defaultInstance) {
            defaultInstance = new DiffPatcher()
          }
          return defaultInstance.reverse.apply(defaultInstance, arguments)
        }
        function clone() {
          if (!defaultInstance) {
            defaultInstance = new DiffPatcher()
          }
          return defaultInstance.clone.apply(defaultInstance, arguments)
        }

        exports.DiffPatcher = DiffPatcher
        exports.clone = clone
        exports.console = console$1
        exports.create = create
        exports.dateReviver = dateReviver
        exports.diff = diff
        exports.formatters = index
        exports.patch = patch
        exports.reverse = reverse
        exports.unpatch = unpatch
      })

      /***/
    },

    /***/ 8686: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      /**
       * lodash (Custom Build) <https://lodash.com/>
       * Build: `lodash modularize exports="npm" -o ./`
       * Copyright jQuery Foundation and other contributors <https://jquery.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0

      /** `Object#toString` result references. */
      var symbolTag = '[object Symbol]'

      /** Used to match HTML entities and HTML characters. */
      var reUnescapedHtml = /[&<>"'`]/g,
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source)

      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      }

      /** Detect free variable `global` from Node.js. */
      var freeGlobal =
        typeof __webpack_require__.g == 'object' &&
        __webpack_require__.g &&
        __webpack_require__.g.Object === Object &&
        __webpack_require__.g

      /** Detect free variable `self`. */
      var freeSelf =
        typeof self == 'object' && self && self.Object === Object && self

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')()

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined : object[key]
        }
      }

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      var escapeHtmlChar = basePropertyOf(htmlEscapes)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
       * of values.
       */
      var objectToString = objectProto.toString

      /** Built-in value references. */
      var Symbol = root.Symbol

      /** Used to convert symbols to primitives and strings. */
      var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined

      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
          return value
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : ''
        }
        var result = value + ''
        return result == '0' && 1 / value == -INFINITY ? '-0' : result
      }

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return !!value && typeof value == 'object'
      }

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return (
          typeof value == 'symbol' ||
          (isObjectLike(value) && objectToString.call(value) == symbolTag)
        )
      }

      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */
      function toString(value) {
        return value == null ? '' : baseToString(value)
      }

      /**
       * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
       * their corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * Backticks are escaped because in IE < 9, they can break out of
       * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
       * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
       * [#133](https://html5sec.org/#133) of the
       * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */
      function escape(string) {
        string = toString(string)
        return string && reHasUnescapedHtml.test(string)
          ? string.replace(reUnescapedHtml, escapeHtmlChar)
          : string
      }

      module.exports = escape

      /***/
    },

    /***/ 9462: /***/ (module) => {
      module.exports = Observable

      function Observable(value) {
        var listeners = []
        value = value === undefined ? null : value

        observable.set = function (v) {
          value = v
          listeners.forEach(function (f) {
            f(v)
          })
        }

        return observable

        function observable(listener) {
          if (!listener) {
            return value
          }

          listeners.push(listener)

          return function remove() {
            listeners.splice(listeners.indexOf(listener), 1)
          }
        }
      }

      /***/
    },

    /***/ 6470: /***/ (module) => {
      'use strict'
      // 'path' module extracted from Node.js v8.11.1 (only the posix part)
      // transplited with Babel

      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      function assertPath(path) {
        if (typeof path !== 'string') {
          throw new TypeError(
            'Path must be a string. Received ' + JSON.stringify(path)
          )
        }
      }

      // Resolves . and .. elements in a path with directory names
      function normalizeStringPosix(path, allowAboveRoot) {
        var res = ''
        var lastSegmentLength = 0
        var lastSlash = -1
        var dots = 0
        var code
        for (var i = 0; i <= path.length; ++i) {
          if (i < path.length) code = path.charCodeAt(i)
          else if (code === 47 /*/*/) break
          else code = 47 /*/*/
          if (code === 47 /*/*/) {
            if (lastSlash === i - 1 || dots === 1) {
              // NOOP
            } else if (lastSlash !== i - 1 && dots === 2) {
              if (
                res.length < 2 ||
                lastSegmentLength !== 2 ||
                res.charCodeAt(res.length - 1) !== 46 /*.*/ ||
                res.charCodeAt(res.length - 2) !== 46 /*.*/
              ) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf('/')
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = ''
                      lastSegmentLength = 0
                    } else {
                      res = res.slice(0, lastSlashIndex)
                      lastSegmentLength = res.length - 1 - res.lastIndexOf('/')
                    }
                    lastSlash = i
                    dots = 0
                    continue
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = ''
                  lastSegmentLength = 0
                  lastSlash = i
                  dots = 0
                  continue
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0) res += '/..'
                else res = '..'
                lastSegmentLength = 2
              }
            } else {
              if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i)
              else res = path.slice(lastSlash + 1, i)
              lastSegmentLength = i - lastSlash - 1
            }
            lastSlash = i
            dots = 0
          } else if (code === 46 /*.*/ && dots !== -1) {
            ++dots
          } else {
            dots = -1
          }
        }
        return res
      }

      function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root
        var base =
          pathObject.base || (pathObject.name || '') + (pathObject.ext || '')
        if (!dir) {
          return base
        }
        if (dir === pathObject.root) {
          return dir + base
        }
        return dir + sep + base
      }

      var posix = {
        // path.resolve([from ...], to)
        resolve: function resolve() {
          var resolvedPath = ''
          var resolvedAbsolute = false
          var cwd

          for (
            var i = arguments.length - 1;
            i >= -1 && !resolvedAbsolute;
            i--
          ) {
            var path
            if (i >= 0) path = arguments[i]
            else {
              if (cwd === undefined) cwd = process.cwd()
              path = cwd
            }

            assertPath(path)

            // Skip empty entries
            if (path.length === 0) {
              continue
            }

            resolvedPath = path + '/' + resolvedPath
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/
          }

          // At this point the path should be resolved to a full absolute path, but
          // handle relative paths to be safe (might happen when process.cwd() fails)

          // Normalize the path
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute)

          if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return '/' + resolvedPath
            else return '/'
          } else if (resolvedPath.length > 0) {
            return resolvedPath
          } else {
            return '.'
          }
        },

        normalize: function normalize(path) {
          assertPath(path)

          if (path.length === 0) return '.'

          var isAbsolute = path.charCodeAt(0) === 47 /*/*/
          var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/

          // Normalize the path
          path = normalizeStringPosix(path, !isAbsolute)

          if (path.length === 0 && !isAbsolute) path = '.'
          if (path.length > 0 && trailingSeparator) path += '/'

          if (isAbsolute) return '/' + path
          return path
        },

        isAbsolute: function isAbsolute(path) {
          assertPath(path)
          return path.length > 0 && path.charCodeAt(0) === 47 /*/*/
        },

        join: function join() {
          if (arguments.length === 0) return '.'
          var joined
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i]
            assertPath(arg)
            if (arg.length > 0) {
              if (joined === undefined) joined = arg
              else joined += '/' + arg
            }
          }
          if (joined === undefined) return '.'
          return posix.normalize(joined)
        },

        relative: function relative(from, to) {
          assertPath(from)
          assertPath(to)

          if (from === to) return ''

          from = posix.resolve(from)
          to = posix.resolve(to)

          if (from === to) return ''

          // Trim any leading backslashes
          var fromStart = 1
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47 /*/*/) break
          }
          var fromEnd = from.length
          var fromLen = fromEnd - fromStart

          // Trim any leading backslashes
          var toStart = 1
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47 /*/*/) break
          }
          var toEnd = to.length
          var toLen = toEnd - toStart

          // Compare paths to find the longest common path from root
          var length = fromLen < toLen ? fromLen : toLen
          var lastCommonSep = -1
          var i = 0
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                  // We get here if `from` is the exact base path for `to`.
                  // For example: from='/foo/bar'; to='/foo/bar/baz'
                  return to.slice(toStart + i + 1)
                } else if (i === 0) {
                  // We get here if `from` is the root
                  // For example: from='/'; to='/foo'
                  return to.slice(toStart + i)
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                  // We get here if `to` is the exact base path for `from`.
                  // For example: from='/foo/bar/baz'; to='/foo/bar'
                  lastCommonSep = i
                } else if (i === 0) {
                  // We get here if `to` is the root.
                  // For example: from='/foo'; to='/'
                  lastCommonSep = 0
                }
              }
              break
            }
            var fromCode = from.charCodeAt(fromStart + i)
            var toCode = to.charCodeAt(toStart + i)
            if (fromCode !== toCode) break
            else if (fromCode === 47 /*/*/) lastCommonSep = i
          }

          var out = ''
          // Generate the relative path based on the path difference between `to`
          // and `from`
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
              if (out.length === 0) out += '..'
              else out += '/..'
            }
          }

          // Lastly, append the rest of the destination (`to`) path that comes after
          // the common path parts
          if (out.length > 0) return out + to.slice(toStart + lastCommonSep)
          else {
            toStart += lastCommonSep
            if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart
            return to.slice(toStart)
          }
        },

        _makeLong: function _makeLong(path) {
          return path
        },

        dirname: function dirname(path) {
          assertPath(path)
          if (path.length === 0) return '.'
          var code = path.charCodeAt(0)
          var hasRoot = code === 47 /*/*/
          var end = -1
          var matchedSlash = true
          for (var i = path.length - 1; i >= 1; --i) {
            code = path.charCodeAt(i)
            if (code === 47 /*/*/) {
              if (!matchedSlash) {
                end = i
                break
              }
            } else {
              // We saw the first non-path separator
              matchedSlash = false
            }
          }

          if (end === -1) return hasRoot ? '/' : '.'
          if (hasRoot && end === 1) return '//'
          return path.slice(0, end)
        },

        basename: function basename(path, ext) {
          if (ext !== undefined && typeof ext !== 'string')
            throw new TypeError('"ext" argument must be a string')
          assertPath(path)

          var start = 0
          var end = -1
          var matchedSlash = true
          var i

          if (
            ext !== undefined &&
            ext.length > 0 &&
            ext.length <= path.length
          ) {
            if (ext.length === path.length && ext === path) return ''
            var extIdx = ext.length - 1
            var firstNonSlashEnd = -1
            for (i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i)
              if (code === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  start = i + 1
                  break
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  // We saw the first non-path separator, remember this index in case
                  // we need it if the extension ends up not matching
                  matchedSlash = false
                  firstNonSlashEnd = i + 1
                }
                if (extIdx >= 0) {
                  // Try to match the explicit extension
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      // We matched the extension, so mark this as the end of our path
                      // component
                      end = i
                    }
                  } else {
                    // Extension does not match, so our result is the entire path
                    // component
                    extIdx = -1
                    end = firstNonSlashEnd
                  }
                }
              }
            }

            if (start === end) end = firstNonSlashEnd
            else if (end === -1) end = path.length
            return path.slice(start, end)
          } else {
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                  start = i + 1
                  break
                }
              } else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false
                end = i + 1
              }
            }

            if (end === -1) return ''
            return path.slice(start, end)
          }
        },

        extname: function extname(path) {
          assertPath(path)
          var startDot = -1
          var startPart = 0
          var end = -1
          var matchedSlash = true
          // Track the state of characters (if any) we see before our first dot and
          // after any path separator we find
          var preDotState = 0
          for (var i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i)
            if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1
                break
              }
              continue
            }
            if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // extension
              matchedSlash = false
              end = i + 1
            }
            if (code === 46 /*.*/) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1) startDot = i
              else if (preDotState !== 1) preDotState = 1
            } else if (startDot !== -1) {
              // We saw a non-dot and non-path separator before our dot, so we should
              // have a good chance at having a non-empty extension
              preDotState = -1
            }
          }

          if (
            startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
              startDot === end - 1 &&
              startDot === startPart + 1)
          ) {
            return ''
          }
          return path.slice(startDot, end)
        },

        format: function format(pathObject) {
          if (pathObject === null || typeof pathObject !== 'object') {
            throw new TypeError(
              'The "pathObject" argument must be of type Object. Received type ' +
                typeof pathObject
            )
          }
          return _format('/', pathObject)
        },

        parse: function parse(path) {
          assertPath(path)

          var ret = { root: '', dir: '', base: '', ext: '', name: '' }
          if (path.length === 0) return ret
          var code = path.charCodeAt(0)
          var isAbsolute = code === 47 /*/*/
          var start
          if (isAbsolute) {
            ret.root = '/'
            start = 1
          } else {
            start = 0
          }
          var startDot = -1
          var startPart = 0
          var end = -1
          var matchedSlash = true
          var i = path.length - 1

          // Track the state of characters (if any) we see before our first dot and
          // after any path separator we find
          var preDotState = 0

          // Get non-dir info
          for (; i >= start; --i) {
            code = path.charCodeAt(i)
            if (code === 47 /*/*/) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now
              if (!matchedSlash) {
                startPart = i + 1
                break
              }
              continue
            }
            if (end === -1) {
              // We saw the first non-path separator, mark this as the end of our
              // extension
              matchedSlash = false
              end = i + 1
            }
            if (code === 46 /*.*/) {
              // If this is our first dot, mark it as the start of our extension
              if (startDot === -1) startDot = i
              else if (preDotState !== 1) preDotState = 1
            } else if (startDot !== -1) {
              // We saw a non-dot and non-path separator before our dot, so we should
              // have a good chance at having a non-empty extension
              preDotState = -1
            }
          }

          if (
            startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
              startDot === end - 1 &&
              startDot === startPart + 1)
          ) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path.slice(1, end)
              else ret.base = ret.name = path.slice(startPart, end)
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path.slice(1, startDot)
              ret.base = path.slice(1, end)
            } else {
              ret.name = path.slice(startPart, startDot)
              ret.base = path.slice(startPart, end)
            }
            ret.ext = path.slice(startDot, end)
          }

          if (startPart > 0) ret.dir = path.slice(0, startPart - 1)
          else if (isAbsolute) ret.dir = '/'

          return ret
        },

        sep: '/',
        delimiter: ':',
        win32: null,
        posix: null
      }

      posix.posix = posix

      module.exports = posix

      /***/
    },

    /***/ 5346: /***/ function (module) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i]
          descriptor.enumerable = descriptor.enumerable || false
          descriptor.configurable = true
          if ('value' in descriptor) descriptor.writable = true
          Object.defineProperty(target, descriptor.key, descriptor)
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps)
        if (staticProps) _defineProperties(Constructor, staticProps)
        return Constructor
      }

      /**
       * Sticky.js
       * Library for sticky elements written in vanilla javascript. With this library you can easily set sticky elements on your website. It's also responsive.
       *
       * @version 1.3.0
       * @author Rafal Galus <biuro@rafalgalus.pl>
       * @website https://rgalus.github.io/sticky-js/
       * @repo https://github.com/rgalus/sticky-js
       * @license https://github.com/rgalus/sticky-js/blob/master/LICENSE
       */
      var Sticky = /*#__PURE__*/ (function () {
        /**
         * Sticky instance constructor
         * @constructor
         * @param {string} selector - Selector which we can find elements
         * @param {string} options - Global options for sticky elements (could be overwritten by data-{option}="" attributes)
         */
        function Sticky() {
          var selector =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : ''
          var options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          _classCallCheck(this, Sticky)

          this.selector = selector
          this.elements = []
          this.version = '1.3.0'
          this.vp = this.getViewportSize()
          this.body = document.querySelector('body')
          this.options = {
            wrap: options.wrap || false,
            wrapWith: options.wrapWith || '<span></span>',
            marginTop: options.marginTop || 0,
            marginBottom: options.marginBottom || 0,
            stickyFor: options.stickyFor || 0,
            stickyClass: options.stickyClass || null,
            stickyContainer: options.stickyContainer || 'body'
          }
          this.updateScrollTopPosition = this.updateScrollTopPosition.bind(this)
          this.updateScrollTopPosition()
          window.addEventListener('load', this.updateScrollTopPosition)
          window.addEventListener('scroll', this.updateScrollTopPosition)
          this.run()
        }
        /**
         * Function that waits for page to be fully loaded and then renders & activates every sticky element found with specified selector
         * @function
         */

        _createClass(Sticky, [
          {
            key: 'run',
            value: function run() {
              var _this = this

              // wait for page to be fully loaded
              var pageLoaded = setInterval(function () {
                if (document.readyState === 'complete') {
                  clearInterval(pageLoaded)
                  var elements = document.querySelectorAll(_this.selector)

                  _this.forEach(elements, function (element) {
                    return _this.renderElement(element)
                  })
                }
              }, 10)
            }
            /**
             * Function that assign needed variables for sticky element, that are used in future for calculations and other
             * @function
             * @param {node} element - Element to be rendered
             */
          },
          {
            key: 'renderElement',
            value: function renderElement(element) {
              var _this2 = this

              // create container for variables needed in future
              element.sticky = {} // set default variables

              element.sticky.active = false
              element.sticky.marginTop =
                parseInt(element.getAttribute('data-margin-top')) ||
                this.options.marginTop
              element.sticky.marginBottom =
                parseInt(element.getAttribute('data-margin-bottom')) ||
                this.options.marginBottom
              element.sticky.stickyFor =
                parseInt(element.getAttribute('data-sticky-for')) ||
                this.options.stickyFor
              element.sticky.stickyClass =
                element.getAttribute('data-sticky-class') ||
                this.options.stickyClass
              element.sticky.wrap = element.hasAttribute('data-sticky-wrap')
                ? true
                : this.options.wrap // @todo attribute for stickyContainer
              // element.sticky.stickyContainer = element.getAttribute('data-sticky-container') || this.options.stickyContainer;

              element.sticky.stickyContainer = this.options.stickyContainer
              element.sticky.container = this.getStickyContainer(element)
              element.sticky.container.rect = this.getRectangle(
                element.sticky.container
              )
              element.sticky.rect = this.getRectangle(element) // fix when element is image that has not yet loaded and width, height = 0

              if (element.tagName.toLowerCase() === 'img') {
                element.onload = function () {
                  return (element.sticky.rect = _this2.getRectangle(element))
                }
              }

              if (element.sticky.wrap) {
                this.wrapElement(element)
              } // activate rendered element

              this.activate(element)
            }
            /**
             * Wraps element into placeholder element
             * @function
             * @param {node} element - Element to be wrapped
             */
          },
          {
            key: 'wrapElement',
            value: function wrapElement(element) {
              element.insertAdjacentHTML(
                'beforebegin',
                element.getAttribute('data-sticky-wrapWith') ||
                  this.options.wrapWith
              )
              element.previousSibling.appendChild(element)
            }
            /**
             * Function that activates element when specified conditions are met and then initalise events
             * @function
             * @param {node} element - Element to be activated
             */
          },
          {
            key: 'activate',
            value: function activate(element) {
              if (
                element.sticky.rect.top + element.sticky.rect.height <
                  element.sticky.container.rect.top +
                    element.sticky.container.rect.height &&
                element.sticky.stickyFor < this.vp.width &&
                !element.sticky.active
              ) {
                element.sticky.active = true
              }

              if (this.elements.indexOf(element) < 0) {
                this.elements.push(element)
              }

              if (!element.sticky.resizeEvent) {
                this.initResizeEvents(element)
                element.sticky.resizeEvent = true
              }

              if (!element.sticky.scrollEvent) {
                this.initScrollEvents(element)
                element.sticky.scrollEvent = true
              }

              this.setPosition(element)
            }
            /**
             * Function which is adding onResizeEvents to window listener and assigns function to element as resizeListener
             * @function
             * @param {node} element - Element for which resize events are initialised
             */
          },
          {
            key: 'initResizeEvents',
            value: function initResizeEvents(element) {
              var _this3 = this

              element.sticky.resizeListener = function () {
                return _this3.onResizeEvents(element)
              }

              window.addEventListener('resize', element.sticky.resizeListener)
            }
            /**
             * Removes element listener from resize event
             * @function
             * @param {node} element - Element from which listener is deleted
             */
          },
          {
            key: 'destroyResizeEvents',
            value: function destroyResizeEvents(element) {
              window.removeEventListener(
                'resize',
                element.sticky.resizeListener
              )
            }
            /**
             * Function which is fired when user resize window. It checks if element should be activated or deactivated and then run setPosition function
             * @function
             * @param {node} element - Element for which event function is fired
             */
          },
          {
            key: 'onResizeEvents',
            value: function onResizeEvents(element) {
              this.vp = this.getViewportSize()
              element.sticky.rect = this.getRectangle(element)
              element.sticky.container.rect = this.getRectangle(
                element.sticky.container
              )

              if (
                element.sticky.rect.top + element.sticky.rect.height <
                  element.sticky.container.rect.top +
                    element.sticky.container.rect.height &&
                element.sticky.stickyFor < this.vp.width &&
                !element.sticky.active
              ) {
                element.sticky.active = true
              } else if (
                element.sticky.rect.top + element.sticky.rect.height >=
                  element.sticky.container.rect.top +
                    element.sticky.container.rect.height ||
                (element.sticky.stickyFor >= this.vp.width &&
                  element.sticky.active)
              ) {
                element.sticky.active = false
              }

              this.setPosition(element)
            }
            /**
             * Function which is adding onScrollEvents to window listener and assigns function to element as scrollListener
             * @function
             * @param {node} element - Element for which scroll events are initialised
             */
          },
          {
            key: 'initScrollEvents',
            value: function initScrollEvents(element) {
              var _this4 = this

              element.sticky.scrollListener = function () {
                return _this4.onScrollEvents(element)
              }

              window.addEventListener('scroll', element.sticky.scrollListener)
            }
            /**
             * Removes element listener from scroll event
             * @function
             * @param {node} element - Element from which listener is deleted
             */
          },
          {
            key: 'destroyScrollEvents',
            value: function destroyScrollEvents(element) {
              window.removeEventListener(
                'scroll',
                element.sticky.scrollListener
              )
            }
            /**
             * Function which is fired when user scroll window. If element is active, function is invoking setPosition function
             * @function
             * @param {node} element - Element for which event function is fired
             */
          },
          {
            key: 'onScrollEvents',
            value: function onScrollEvents(element) {
              if (element.sticky && element.sticky.active) {
                this.setPosition(element)
              }
            }
            /**
             * Main function for the library. Here are some condition calculations and css appending for sticky element when user scroll window
             * @function
             * @param {node} element - Element that will be positioned if it's active
             */
          },
          {
            key: 'setPosition',
            value: function setPosition(element) {
              this.css(element, {
                position: '',
                width: '',
                top: '',
                left: ''
              })

              if (
                this.vp.height < element.sticky.rect.height ||
                !element.sticky.active
              ) {
                return
              }

              if (!element.sticky.rect.width) {
                element.sticky.rect = this.getRectangle(element)
              }

              if (element.sticky.wrap) {
                this.css(element.parentNode, {
                  display: 'block',
                  width: element.sticky.rect.width + 'px',
                  height: element.sticky.rect.height + 'px'
                })
              }

              if (
                element.sticky.rect.top === 0 &&
                element.sticky.container === this.body
              ) {
                this.css(element, {
                  position: 'fixed',
                  top: element.sticky.rect.top + 'px',
                  left: element.sticky.rect.left + 'px',
                  width: element.sticky.rect.width + 'px'
                })

                if (element.sticky.stickyClass) {
                  element.classList.add(element.sticky.stickyClass)
                }
              } else if (
                this.scrollTop >
                element.sticky.rect.top - element.sticky.marginTop
              ) {
                this.css(element, {
                  position: 'fixed',
                  width: element.sticky.rect.width + 'px',
                  left: element.sticky.rect.left + 'px'
                })

                if (
                  this.scrollTop +
                    element.sticky.rect.height +
                    element.sticky.marginTop >
                  element.sticky.container.rect.top +
                    element.sticky.container.offsetHeight -
                    element.sticky.marginBottom
                ) {
                  if (element.sticky.stickyClass) {
                    element.classList.remove(element.sticky.stickyClass)
                  }

                  this.css(element, {
                    top:
                      element.sticky.container.rect.top +
                      element.sticky.container.offsetHeight -
                      (this.scrollTop +
                        element.sticky.rect.height +
                        element.sticky.marginBottom) +
                      'px'
                  })
                } else {
                  if (element.sticky.stickyClass) {
                    element.classList.add(element.sticky.stickyClass)
                  }

                  this.css(element, {
                    top: element.sticky.marginTop + 'px'
                  })
                }
              } else {
                if (element.sticky.stickyClass) {
                  element.classList.remove(element.sticky.stickyClass)
                }

                this.css(element, {
                  position: '',
                  width: '',
                  top: '',
                  left: ''
                })

                if (element.sticky.wrap) {
                  this.css(element.parentNode, {
                    display: '',
                    width: '',
                    height: ''
                  })
                }
              }
            }
            /**
             * Function that updates element sticky rectangle (with sticky container), then activate or deactivate element, then update position if it's active
             * @function
             */
          },
          {
            key: 'update',
            value: function update() {
              var _this5 = this

              this.forEach(this.elements, function (element) {
                element.sticky.rect = _this5.getRectangle(element)
                element.sticky.container.rect = _this5.getRectangle(
                  element.sticky.container
                )

                _this5.activate(element)

                _this5.setPosition(element)
              })
            }
            /**
             * Destroys sticky element, remove listeners
             * @function
             */
          },
          {
            key: 'destroy',
            value: function destroy() {
              var _this6 = this

              window.removeEventListener('load', this.updateScrollTopPosition)
              window.removeEventListener('scroll', this.updateScrollTopPosition)
              this.forEach(this.elements, function (element) {
                _this6.destroyResizeEvents(element)

                _this6.destroyScrollEvents(element)

                delete element.sticky
              })
            }
            /**
             * Function that returns container element in which sticky element is stuck (if is not specified, then it's stuck to body)
             * @function
             * @param {node} element - Element which sticky container are looked for
             * @return {node} element - Sticky container
             */
          },
          {
            key: 'getStickyContainer',
            value: function getStickyContainer(element) {
              var container = element.parentNode

              while (
                !container.hasAttribute('data-sticky-container') &&
                !container.parentNode.querySelector(
                  element.sticky.stickyContainer
                ) &&
                container !== this.body
              ) {
                container = container.parentNode
              }

              return container
            }
            /**
             * Function that returns element rectangle & position (width, height, top, left)
             * @function
             * @param {node} element - Element which position & rectangle are returned
             * @return {object}
             */
          },
          {
            key: 'getRectangle',
            value: function getRectangle(element) {
              this.css(element, {
                position: '',
                width: '',
                top: '',
                left: ''
              })
              var width = Math.max(
                element.offsetWidth,
                element.clientWidth,
                element.scrollWidth
              )
              var height = Math.max(
                element.offsetHeight,
                element.clientHeight,
                element.scrollHeight
              )
              var top = 0
              var left = 0

              do {
                top += element.offsetTop || 0
                left += element.offsetLeft || 0
                element = element.offsetParent
              } while (element)

              return {
                top: top,
                left: left,
                width: width,
                height: height
              }
            }
            /**
             * Function that returns viewport dimensions
             * @function
             * @return {object}
             */
          },
          {
            key: 'getViewportSize',
            value: function getViewportSize() {
              return {
                width: Math.max(
                  document.documentElement.clientWidth,
                  window.innerWidth || 0
                ),
                height: Math.max(
                  document.documentElement.clientHeight,
                  window.innerHeight || 0
                )
              }
            }
            /**
             * Function that updates window scroll position
             * @function
             * @return {number}
             */
          },
          {
            key: 'updateScrollTopPosition',
            value: function updateScrollTopPosition() {
              this.scrollTop =
                (window.pageYOffset || document.scrollTop) -
                  (document.clientTop || 0) || 0
            }
            /**
             * Helper function for loops
             * @helper
             * @param {array}
             * @param {function} callback - Callback function (no need for explanation)
             */
          },
          {
            key: 'forEach',
            value: function forEach(array, callback) {
              for (var i = 0, len = array.length; i < len; i++) {
                callback(array[i])
              }
            }
            /**
             * Helper function to add/remove css properties for specified element.
             * @helper
             * @param {node} element - DOM element
             * @param {object} properties - CSS properties that will be added/removed from specified element
             */
          },
          {
            key: 'css',
            value: function css(element, properties) {
              for (var property in properties) {
                if (properties.hasOwnProperty(property)) {
                  element.style[property] = properties[property]
                }
              }
            }
          }
        ])

        return Sticky
      })()
      /**
       * Export function that supports AMD, CommonJS and Plain Browser.
       */

      ;(function (root, factory) {
        if (true) {
          module.exports = factory
        } else {
        }
      })(this, Sticky)

      /***/
    },

    /***/ 5820: /***/ (
      module,
      __unused_webpack_exports,
      __webpack_require__
    ) => {
      var Sticky = __webpack_require__(5346)

      module.exports = Sticky

      /***/
    },

    /***/ 9623: /***/ (module) => {
      function throttle(function_, wait) {
        let timeoutId
        let lastCallTime = 0

        return function throttled(...arguments_) {
          // eslint-disable-line func-names
          clearTimeout(timeoutId)

          const now = Date.now()
          const timeSinceLastCall = now - lastCallTime
          const delayForNextCall = wait - timeSinceLastCall

          if (delayForNextCall <= 0) {
            lastCallTime = now
            function_.apply(this, arguments_)
          } else {
            timeoutId = setTimeout(() => {
              lastCallTime = Date.now()
              function_.apply(this, arguments_)
            }, delayForNextCall)
          }
        }
      }

      module.exports = throttle

      /***/
    },

    /***/ 540: /***/ function (__unused_webpack_module, exports) {
      /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
      ;(function (global, factory) {
        true ? factory(exports) : 0
      })(this, function (exports) {
        'use strict'

        function merge() {
          for (
            var _len = arguments.length, sets = Array(_len), _key = 0;
            _key < _len;
            _key++
          ) {
            sets[_key] = arguments[_key]
          }

          if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1)
            var xl = sets.length - 1
            for (var x = 1; x < xl; ++x) {
              sets[x] = sets[x].slice(1, -1)
            }
            sets[xl] = sets[xl].slice(1)
            return sets.join('')
          } else {
            return sets[0]
          }
        }
        function subexp(str) {
          return '(?:' + str + ')'
        }
        function typeOf(o) {
          return o === undefined
            ? 'undefined'
            : o === null
              ? 'null'
              : Object.prototype.toString
                  .call(o)
                  .split(' ')
                  .pop()
                  .split(']')
                  .shift()
                  .toLowerCase()
        }
        function toUpperCase(str) {
          return str.toUpperCase()
        }
        function toArray(obj) {
          return obj !== undefined && obj !== null
            ? obj instanceof Array
              ? obj
              : typeof obj.length !== 'number' ||
                  obj.split ||
                  obj.setInterval ||
                  obj.call
                ? [obj]
                : Array.prototype.slice.call(obj)
            : []
        }
        function assign(target, source) {
          var obj = target
          if (source) {
            for (var key in source) {
              obj[key] = source[key]
            }
          }
          return obj
        }

        function buildExps(isIRI) {
          var ALPHA$$ = '[A-Za-z]',
            CR$ = '[\\x0D]',
            DIGIT$$ = '[0-9]',
            DQUOTE$$ = '[\\x22]',
            HEXDIG$$ = merge(DIGIT$$, '[A-Fa-f]'),
            //case-insensitive
            LF$$ = '[\\x0A]',
            SP$$ = '[\\x20]',
            PCT_ENCODED$ = subexp(
              subexp(
                '%[EFef]' +
                  HEXDIG$$ +
                  '%' +
                  HEXDIG$$ +
                  HEXDIG$$ +
                  '%' +
                  HEXDIG$$ +
                  HEXDIG$$
              ) +
                '|' +
                subexp('%[89A-Fa-f]' + HEXDIG$$ + '%' + HEXDIG$$ + HEXDIG$$) +
                '|' +
                subexp('%' + HEXDIG$$ + HEXDIG$$)
            ),
            //expanded
            GEN_DELIMS$$ = '[\\:\\/\\?\\#\\[\\]\\@]',
            SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
            RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
            UCSCHAR$$ = isIRI
              ? '[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]'
              : '[]',
            //subset, excludes bidi control characters
            IPRIVATE$$ = isIRI ? '[\\uE000-\\uF8FF]' : '[]',
            //subset
            UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, '[\\-\\.\\_\\~]', UCSCHAR$$),
            SCHEME$ = subexp(
              ALPHA$$ + merge(ALPHA$$, DIGIT$$, '[\\+\\-\\.]') + '*'
            ),
            USERINFO$ = subexp(
              subexp(
                PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$, '[\\:]')
              ) + '*'
            ),
            DEC_OCTET$ = subexp(
              subexp('25[0-5]') +
                '|' +
                subexp('2[0-4]' + DIGIT$$) +
                '|' +
                subexp('1' + DIGIT$$ + DIGIT$$) +
                '|' +
                subexp('[1-9]' + DIGIT$$) +
                '|' +
                DIGIT$$
            ),
            DEC_OCTET_RELAXED$ = subexp(
              subexp('25[0-5]') +
                '|' +
                subexp('2[0-4]' + DIGIT$$) +
                '|' +
                subexp('1' + DIGIT$$ + DIGIT$$) +
                '|' +
                subexp('0?[1-9]' + DIGIT$$) +
                '|0?0?' +
                DIGIT$$
            ),
            //relaxed parsing rules
            IPV4ADDRESS$ = subexp(
              DEC_OCTET_RELAXED$ +
                '\\.' +
                DEC_OCTET_RELAXED$ +
                '\\.' +
                DEC_OCTET_RELAXED$ +
                '\\.' +
                DEC_OCTET_RELAXED$
            ),
            H16$ = subexp(HEXDIG$$ + '{1,4}'),
            LS32$ = subexp(subexp(H16$ + '\\:' + H16$) + '|' + IPV4ADDRESS$),
            IPV6ADDRESS1$ = subexp(subexp(H16$ + '\\:') + '{6}' + LS32$),
            //                           6( h16 ":" ) ls32
            IPV6ADDRESS2$ = subexp(
              '\\:\\:' + subexp(H16$ + '\\:') + '{5}' + LS32$
            ),
            //                      "::" 5( h16 ":" ) ls32
            IPV6ADDRESS3$ = subexp(
              subexp(H16$) + '?\\:\\:' + subexp(H16$ + '\\:') + '{4}' + LS32$
            ),
            //[               h16 ] "::" 4( h16 ":" ) ls32
            IPV6ADDRESS4$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,1}' + H16$) +
                '?\\:\\:' +
                subexp(H16$ + '\\:') +
                '{3}' +
                LS32$
            ),
            //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
            IPV6ADDRESS5$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,2}' + H16$) +
                '?\\:\\:' +
                subexp(H16$ + '\\:') +
                '{2}' +
                LS32$
            ),
            //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
            IPV6ADDRESS6$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,3}' + H16$) +
                '?\\:\\:' +
                H16$ +
                '\\:' +
                LS32$
            ),
            //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
            IPV6ADDRESS7$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,4}' + H16$) + '?\\:\\:' + LS32$
            ),
            //[ *4( h16 ":" ) h16 ] "::"              ls32
            IPV6ADDRESS8$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,5}' + H16$) + '?\\:\\:' + H16$
            ),
            //[ *5( h16 ":" ) h16 ] "::"              h16
            IPV6ADDRESS9$ = subexp(
              subexp(subexp(H16$ + '\\:') + '{0,6}' + H16$) + '?\\:\\:'
            ),
            //[ *6( h16 ":" ) h16 ] "::"
            IPV6ADDRESS$ = subexp(
              [
                IPV6ADDRESS1$,
                IPV6ADDRESS2$,
                IPV6ADDRESS3$,
                IPV6ADDRESS4$,
                IPV6ADDRESS5$,
                IPV6ADDRESS6$,
                IPV6ADDRESS7$,
                IPV6ADDRESS8$,
                IPV6ADDRESS9$
              ].join('|')
            ),
            ZONEID$ = subexp(subexp(UNRESERVED$$ + '|' + PCT_ENCODED$) + '+'),
            //RFC 6874
            IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + '\\%25' + ZONEID$),
            //RFC 6874
            IPV6ADDRZ_RELAXED$ = subexp(
              IPV6ADDRESS$ +
                subexp('\\%25|\\%(?!' + HEXDIG$$ + '{2})') +
                ZONEID$
            ),
            //RFC 6874, with relaxed parsing rules
            IPVFUTURE$ = subexp(
              '[vV]' +
                HEXDIG$$ +
                '+\\.' +
                merge(UNRESERVED$$, SUB_DELIMS$$, '[\\:]') +
                '+'
            ),
            IP_LITERAL$ = subexp(
              '\\[' +
                subexp(
                  IPV6ADDRZ_RELAXED$ + '|' + IPV6ADDRESS$ + '|' + IPVFUTURE$
                ) +
                '\\]'
            ),
            //RFC 6874
            REG_NAME$ = subexp(
              subexp(PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$)) +
                '*'
            ),
            HOST$ = subexp(
              IP_LITERAL$ +
                '|' +
                IPV4ADDRESS$ +
                '(?!' +
                REG_NAME$ +
                ')' +
                '|' +
                REG_NAME$
            ),
            PORT$ = subexp(DIGIT$$ + '*'),
            AUTHORITY$ = subexp(
              subexp(USERINFO$ + '@') +
                '?' +
                HOST$ +
                subexp('\\:' + PORT$) +
                '?'
            ),
            PCHAR$ = subexp(
              PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$, '[\\:\\@]')
            ),
            SEGMENT$ = subexp(PCHAR$ + '*'),
            SEGMENT_NZ$ = subexp(PCHAR$ + '+'),
            SEGMENT_NZ_NC$ = subexp(
              subexp(
                PCT_ENCODED$ + '|' + merge(UNRESERVED$$, SUB_DELIMS$$, '[\\@]')
              ) + '+'
            ),
            PATH_ABEMPTY$ = subexp(subexp('\\/' + SEGMENT$) + '*'),
            PATH_ABSOLUTE$ = subexp(
              '\\/' + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + '?'
            ),
            //simplified
            PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
            //simplified
            PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
            //simplified
            PATH_EMPTY$ = '(?!' + PCHAR$ + ')',
            PATH$ = subexp(
              PATH_ABEMPTY$ +
                '|' +
                PATH_ABSOLUTE$ +
                '|' +
                PATH_NOSCHEME$ +
                '|' +
                PATH_ROOTLESS$ +
                '|' +
                PATH_EMPTY$
            ),
            QUERY$ = subexp(
              subexp(PCHAR$ + '|' + merge('[\\/\\?]', IPRIVATE$$)) + '*'
            ),
            FRAGMENT$ = subexp(subexp(PCHAR$ + '|[\\/\\?]') + '*'),
            HIER_PART$ = subexp(
              subexp('\\/\\/' + AUTHORITY$ + PATH_ABEMPTY$) +
                '|' +
                PATH_ABSOLUTE$ +
                '|' +
                PATH_ROOTLESS$ +
                '|' +
                PATH_EMPTY$
            ),
            URI$ = subexp(
              SCHEME$ +
                '\\:' +
                HIER_PART$ +
                subexp('\\?' + QUERY$) +
                '?' +
                subexp('\\#' + FRAGMENT$) +
                '?'
            ),
            RELATIVE_PART$ = subexp(
              subexp('\\/\\/' + AUTHORITY$ + PATH_ABEMPTY$) +
                '|' +
                PATH_ABSOLUTE$ +
                '|' +
                PATH_NOSCHEME$ +
                '|' +
                PATH_EMPTY$
            ),
            RELATIVE$ = subexp(
              RELATIVE_PART$ +
                subexp('\\?' + QUERY$) +
                '?' +
                subexp('\\#' + FRAGMENT$) +
                '?'
            ),
            URI_REFERENCE$ = subexp(URI$ + '|' + RELATIVE$),
            ABSOLUTE_URI$ = subexp(
              SCHEME$ + '\\:' + HIER_PART$ + subexp('\\?' + QUERY$) + '?'
            ),
            GENERIC_REF$ =
              '^(' +
              SCHEME$ +
              ')\\:' +
              subexp(
                subexp(
                  '\\/\\/(' +
                    subexp('(' + USERINFO$ + ')@') +
                    '?(' +
                    HOST$ +
                    ')' +
                    subexp('\\:(' + PORT$ + ')') +
                    '?)'
                ) +
                  '?(' +
                  PATH_ABEMPTY$ +
                  '|' +
                  PATH_ABSOLUTE$ +
                  '|' +
                  PATH_ROOTLESS$ +
                  '|' +
                  PATH_EMPTY$ +
                  ')'
              ) +
              subexp('\\?(' + QUERY$ + ')') +
              '?' +
              subexp('\\#(' + FRAGMENT$ + ')') +
              '?$',
            RELATIVE_REF$ =
              '^(){0}' +
              subexp(
                subexp(
                  '\\/\\/(' +
                    subexp('(' + USERINFO$ + ')@') +
                    '?(' +
                    HOST$ +
                    ')' +
                    subexp('\\:(' + PORT$ + ')') +
                    '?)'
                ) +
                  '?(' +
                  PATH_ABEMPTY$ +
                  '|' +
                  PATH_ABSOLUTE$ +
                  '|' +
                  PATH_NOSCHEME$ +
                  '|' +
                  PATH_EMPTY$ +
                  ')'
              ) +
              subexp('\\?(' + QUERY$ + ')') +
              '?' +
              subexp('\\#(' + FRAGMENT$ + ')') +
              '?$',
            ABSOLUTE_REF$ =
              '^(' +
              SCHEME$ +
              ')\\:' +
              subexp(
                subexp(
                  '\\/\\/(' +
                    subexp('(' + USERINFO$ + ')@') +
                    '?(' +
                    HOST$ +
                    ')' +
                    subexp('\\:(' + PORT$ + ')') +
                    '?)'
                ) +
                  '?(' +
                  PATH_ABEMPTY$ +
                  '|' +
                  PATH_ABSOLUTE$ +
                  '|' +
                  PATH_ROOTLESS$ +
                  '|' +
                  PATH_EMPTY$ +
                  ')'
              ) +
              subexp('\\?(' + QUERY$ + ')') +
              '?$',
            SAMEDOC_REF$ = '^' + subexp('\\#(' + FRAGMENT$ + ')') + '?$',
            AUTHORITY_REF$ =
              '^' +
              subexp('(' + USERINFO$ + ')@') +
              '?(' +
              HOST$ +
              ')' +
              subexp('\\:(' + PORT$ + ')') +
              '?$'
          return {
            NOT_SCHEME: new RegExp(
              merge('[^]', ALPHA$$, DIGIT$$, '[\\+\\-\\.]'),
              'g'
            ),
            NOT_USERINFO: new RegExp(
              merge('[^\\%\\:]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_HOST: new RegExp(
              merge('[^\\%\\[\\]\\:]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_PATH: new RegExp(
              merge('[^\\%\\/\\:\\@]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_PATH_NOSCHEME: new RegExp(
              merge('[^\\%\\/\\@]', UNRESERVED$$, SUB_DELIMS$$),
              'g'
            ),
            NOT_QUERY: new RegExp(
              merge(
                '[^\\%]',
                UNRESERVED$$,
                SUB_DELIMS$$,
                '[\\:\\@\\/\\?]',
                IPRIVATE$$
              ),
              'g'
            ),
            NOT_FRAGMENT: new RegExp(
              merge('[^\\%]', UNRESERVED$$, SUB_DELIMS$$, '[\\:\\@\\/\\?]'),
              'g'
            ),
            ESCAPE: new RegExp(merge('[^]', UNRESERVED$$, SUB_DELIMS$$), 'g'),
            UNRESERVED: new RegExp(UNRESERVED$$, 'g'),
            OTHER_CHARS: new RegExp(
              merge('[^\\%]', UNRESERVED$$, RESERVED$$),
              'g'
            ),
            PCT_ENCODED: new RegExp(PCT_ENCODED$, 'g'),
            IPV4ADDRESS: new RegExp('^(' + IPV4ADDRESS$ + ')$'),
            IPV6ADDRESS: new RegExp(
              '^\\[?(' +
                IPV6ADDRESS$ +
                ')' +
                subexp(
                  subexp('\\%25|\\%(?!' + HEXDIG$$ + '{2})') +
                    '(' +
                    ZONEID$ +
                    ')'
                ) +
                '?\\]?$'
            ) //RFC 6874, with relaxed parsing rules
          }
        }
        var URI_PROTOCOL = buildExps(false)

        var IRI_PROTOCOL = buildExps(true)

        var slicedToArray = (function () {
          function sliceIterator(arr, i) {
            var _arr = []
            var _n = true
            var _d = false
            var _e = undefined

            try {
              for (
                var _i = arr[Symbol.iterator](), _s;
                !(_n = (_s = _i.next()).done);
                _n = true
              ) {
                _arr.push(_s.value)

                if (i && _arr.length === i) break
              }
            } catch (err) {
              _d = true
              _e = err
            } finally {
              try {
                if (!_n && _i['return']) _i['return']()
              } finally {
                if (_d) throw _e
              }
            }

            return _arr
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i)
            } else {
              throw new TypeError(
                'Invalid attempt to destructure non-iterable instance'
              )
            }
          }
        })()

        var toConsumableArray = function (arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
              arr2[i] = arr[i]

            return arr2
          } else {
            return Array.from(arr)
          }
        }

        /** Highest positive signed 32-bit float value */

        var maxInt = 2147483647 // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        var base = 36
        var tMin = 1
        var tMax = 26
        var skew = 38
        var damp = 700
        var initialBias = 72
        var initialN = 128 // 0x80
        var delimiter = '-' // '\x2D'

        /** Regular expressions */
        var regexPunycode = /^xn--/
        var regexNonASCII = /[^\0-\x7E]/ // non-ASCII chars
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g // RFC 3490 separators

        /** Error messages */
        var errors = {
          overflow: 'Overflow: input needs wider integers to process',
          'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
          'invalid-input': 'Invalid input'
        }

        /** Convenience shortcuts */
        var baseMinusTMin = base - tMin
        var floor = Math.floor
        var stringFromCharCode = String.fromCharCode

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error$1(type) {
          throw new RangeError(errors[type])
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
          var result = []
          var length = array.length
          while (length--) {
            result[length] = fn(array[length])
          }
          return result
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
          var parts = string.split('@')
          var result = ''
          if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@'
            string = parts[1]
          }
          // Avoid `split(regex)` for IE8 compatibility. See #17.
          string = string.replace(regexSeparators, '\x2E')
          var labels = string.split('.')
          var encoded = map(labels, fn).join('.')
          return result + encoded
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
          var output = []
          var counter = 0
          var length = string.length
          while (counter < length) {
            var value = string.charCodeAt(counter++)
            if (value >= 0xd800 && value <= 0xdbff && counter < length) {
              // It's a high surrogate, and there is a next character.
              var extra = string.charCodeAt(counter++)
              if ((extra & 0xfc00) == 0xdc00) {
                // Low surrogate.
                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000)
              } else {
                // It's an unmatched surrogate; only append this code unit, in case the
                // next code unit is the high surrogate of a surrogate pair.
                output.push(value)
                counter--
              }
            } else {
              output.push(value)
            }
          }
          return output
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        var ucs2encode = function ucs2encode(array) {
          return String.fromCodePoint.apply(String, toConsumableArray(array))
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        var basicToDigit = function basicToDigit(codePoint) {
          if (codePoint - 0x30 < 0x0a) {
            return codePoint - 0x16
          }
          if (codePoint - 0x41 < 0x1a) {
            return codePoint - 0x41
          }
          if (codePoint - 0x61 < 0x1a) {
            return codePoint - 0x61
          }
          return base
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        var digitToBasic = function digitToBasic(digit, flag) {
          //  0..25 map to ASCII a..z or A..Z
          // 26..35 map to ASCII 0..9
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * https://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        var adapt = function adapt(delta, numPoints, firstTime) {
          var k = 0
          delta = firstTime ? floor(delta / damp) : delta >> 1
          delta += floor(delta / numPoints)
          for (
            ;
            /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
            k += base
          ) {
            delta = floor(delta / baseMinusTMin)
          }
          return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew))
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        var decode = function decode(input) {
          // Don't use UCS-2.
          var output = []
          var inputLength = input.length
          var i = 0
          var n = initialN
          var bias = initialBias

          // Handle the basic code points: let `basic` be the number of input code
          // points before the last delimiter, or `0` if there is none, then copy
          // the first basic code points to the output.

          var basic = input.lastIndexOf(delimiter)
          if (basic < 0) {
            basic = 0
          }

          for (var j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
              error$1('not-basic')
            }
            output.push(input.charCodeAt(j))
          }

          // Main decoding loop: start just after the last delimiter if any basic code
          // points were copied; start at the beginning otherwise.

          for (
            var index = basic > 0 ? basic + 1 : 0;
            index < inputLength;

          ) /* no final expression */ {
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            var oldi = i
            for (var w = 1, k = base; ; /* no condition */ k += base) {
              if (index >= inputLength) {
                error$1('invalid-input')
              }

              var digit = basicToDigit(input.charCodeAt(index++))

              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error$1('overflow')
              }

              i += digit * w
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias

              if (digit < t) {
                break
              }

              var baseMinusT = base - t
              if (w > floor(maxInt / baseMinusT)) {
                error$1('overflow')
              }

              w *= baseMinusT
            }

            var out = output.length + 1
            bias = adapt(i - oldi, out, oldi == 0)

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
              error$1('overflow')
            }

            n += floor(i / out)
            i %= out

            // Insert `n` at position `i` of the output.
            output.splice(i++, 0, n)
          }

          return String.fromCodePoint.apply(String, output)
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        var encode = function encode(input) {
          var output = []

          // Convert the input in UCS-2 to an array of Unicode code points.
          input = ucs2decode(input)

          // Cache the length.
          var inputLength = input.length

          // Initialize the state.
          var n = initialN
          var delta = 0
          var bias = initialBias

          // Handle the basic code points.
          var _iteratorNormalCompletion = true
          var _didIteratorError = false
          var _iteratorError = undefined

          try {
            for (
              var _iterator = input[Symbol.iterator](), _step;
              !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
              _iteratorNormalCompletion = true
            ) {
              var _currentValue2 = _step.value

              if (_currentValue2 < 0x80) {
                output.push(stringFromCharCode(_currentValue2))
              }
            }
          } catch (err) {
            _didIteratorError = true
            _iteratorError = err
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return()
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError
              }
            }
          }

          var basicLength = output.length
          var handledCPCount = basicLength

          // `handledCPCount` is the number of code points that have been handled;
          // `basicLength` is the number of basic code points.

          // Finish the basic string with a delimiter unless it's empty.
          if (basicLength) {
            output.push(delimiter)
          }

          // Main encoding loop:
          while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            var m = maxInt
            var _iteratorNormalCompletion2 = true
            var _didIteratorError2 = false
            var _iteratorError2 = undefined

            try {
              for (
                var _iterator2 = input[Symbol.iterator](), _step2;
                !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next())
                  .done);
                _iteratorNormalCompletion2 = true
              ) {
                var currentValue = _step2.value

                if (currentValue >= n && currentValue < m) {
                  m = currentValue
                }
              }

              // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
              // but guard against overflow.
            } catch (err) {
              _didIteratorError2 = true
              _iteratorError2 = err
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return()
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2
                }
              }
            }

            var handledCPCountPlusOne = handledCPCount + 1
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error$1('overflow')
            }

            delta += (m - n) * handledCPCountPlusOne
            n = m

            var _iteratorNormalCompletion3 = true
            var _didIteratorError3 = false
            var _iteratorError3 = undefined

            try {
              for (
                var _iterator3 = input[Symbol.iterator](), _step3;
                !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next())
                  .done);
                _iteratorNormalCompletion3 = true
              ) {
                var _currentValue = _step3.value

                if (_currentValue < n && ++delta > maxInt) {
                  error$1('overflow')
                }
                if (_currentValue == n) {
                  // Represent delta as a generalized variable-length integer.
                  var q = delta
                  for (var k = base; ; /* no condition */ k += base) {
                    var t =
                      k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
                    if (q < t) {
                      break
                    }
                    var qMinusT = q - t
                    var baseMinusT = base - t
                    output.push(
                      stringFromCharCode(
                        digitToBasic(t + (qMinusT % baseMinusT), 0)
                      )
                    )
                    q = floor(qMinusT / baseMinusT)
                  }

                  output.push(stringFromCharCode(digitToBasic(q, 0)))
                  bias = adapt(
                    delta,
                    handledCPCountPlusOne,
                    handledCPCount == basicLength
                  )
                  delta = 0
                  ++handledCPCount
                }
              }
            } catch (err) {
              _didIteratorError3 = true
              _iteratorError3 = err
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return()
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3
                }
              }
            }

            ++delta
            ++n
          }
          return output.join('')
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        var toUnicode = function toUnicode(input) {
          return mapDomain(input, function (string) {
            return regexPunycode.test(string)
              ? decode(string.slice(4).toLowerCase())
              : string
          })
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        var toASCII = function toASCII(input) {
          return mapDomain(input, function (string) {
            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string
          })
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        var punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          version: '2.1.0',
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          ucs2: {
            decode: ucs2decode,
            encode: ucs2encode
          },
          decode: decode,
          encode: encode,
          toASCII: toASCII,
          toUnicode: toUnicode
        }

        /**
         * URI.js
         *
         * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
         * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
         * @see http://github.com/garycourt/uri-js
         */
        /**
         * Copyright 2011 Gary Court. All rights reserved.
         *
         * Redistribution and use in source and binary forms, with or without modification, are
         * permitted provided that the following conditions are met:
         *
         *    1. Redistributions of source code must retain the above copyright notice, this list of
         *       conditions and the following disclaimer.
         *
         *    2. Redistributions in binary form must reproduce the above copyright notice, this list
         *       of conditions and the following disclaimer in the documentation and/or other materials
         *       provided with the distribution.
         *
         * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
         * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
         * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
         * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
         * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
         * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
         * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
         * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
         * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         *
         * The views and conclusions contained in the software and documentation are those of the
         * authors and should not be interpreted as representing official policies, either expressed
         * or implied, of Gary Court.
         */
        var SCHEMES = {}
        function pctEncChar(chr) {
          var c = chr.charCodeAt(0)
          var e = void 0
          if (c < 16) e = '%0' + c.toString(16).toUpperCase()
          else if (c < 128) e = '%' + c.toString(16).toUpperCase()
          else if (c < 2048)
            e =
              '%' +
              ((c >> 6) | 192).toString(16).toUpperCase() +
              '%' +
              ((c & 63) | 128).toString(16).toUpperCase()
          else
            e =
              '%' +
              ((c >> 12) | 224).toString(16).toUpperCase() +
              '%' +
              (((c >> 6) & 63) | 128).toString(16).toUpperCase() +
              '%' +
              ((c & 63) | 128).toString(16).toUpperCase()
          return e
        }
        function pctDecChars(str) {
          var newStr = ''
          var i = 0
          var il = str.length
          while (i < il) {
            var c = parseInt(str.substr(i + 1, 2), 16)
            if (c < 128) {
              newStr += String.fromCharCode(c)
              i += 3
            } else if (c >= 194 && c < 224) {
              if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16)
                newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63))
              } else {
                newStr += str.substr(i, 6)
              }
              i += 6
            } else if (c >= 224) {
              if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16)
                var c3 = parseInt(str.substr(i + 7, 2), 16)
                newStr += String.fromCharCode(
                  ((c & 15) << 12) | ((_c & 63) << 6) | (c3 & 63)
                )
              } else {
                newStr += str.substr(i, 9)
              }
              i += 9
            } else {
              newStr += str.substr(i, 3)
              i += 3
            }
          }
          return newStr
        }
        function _normalizeComponentEncoding(components, protocol) {
          function decodeUnreserved(str) {
            var decStr = pctDecChars(str)
            return !decStr.match(protocol.UNRESERVED) ? str : decStr
          }
          if (components.scheme)
            components.scheme = String(components.scheme)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .toLowerCase()
              .replace(protocol.NOT_SCHEME, '')
          if (components.userinfo !== undefined)
            components.userinfo = String(components.userinfo)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(protocol.NOT_USERINFO, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.host !== undefined)
            components.host = String(components.host)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .toLowerCase()
              .replace(protocol.NOT_HOST, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.path !== undefined)
            components.path = String(components.path)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(
                components.scheme
                  ? protocol.NOT_PATH
                  : protocol.NOT_PATH_NOSCHEME,
                pctEncChar
              )
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.query !== undefined)
            components.query = String(components.query)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(protocol.NOT_QUERY, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          if (components.fragment !== undefined)
            components.fragment = String(components.fragment)
              .replace(protocol.PCT_ENCODED, decodeUnreserved)
              .replace(protocol.NOT_FRAGMENT, pctEncChar)
              .replace(protocol.PCT_ENCODED, toUpperCase)
          return components
        }

        function _stripLeadingZeros(str) {
          return str.replace(/^0*(.*)/, '$1') || '0'
        }
        function _normalizeIPv4(host, protocol) {
          var matches = host.match(protocol.IPV4ADDRESS) || []

          var _matches = slicedToArray(matches, 2),
            address = _matches[1]

          if (address) {
            return address.split('.').map(_stripLeadingZeros).join('.')
          } else {
            return host
          }
        }
        function _normalizeIPv6(host, protocol) {
          var matches = host.match(protocol.IPV6ADDRESS) || []

          var _matches2 = slicedToArray(matches, 3),
            address = _matches2[1],
            zone = _matches2[2]

          if (address) {
            var _address$toLowerCase$ = address
                .toLowerCase()
                .split('::')
                .reverse(),
              _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
              last = _address$toLowerCase$2[0],
              first = _address$toLowerCase$2[1]

            var firstFields = first
              ? first.split(':').map(_stripLeadingZeros)
              : []
            var lastFields = last.split(':').map(_stripLeadingZeros)
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(
              lastFields[lastFields.length - 1]
            )
            var fieldCount = isLastFieldIPv4Address ? 7 : 8
            var lastFieldsStart = lastFields.length - fieldCount
            var fields = Array(fieldCount)
            for (var x = 0; x < fieldCount; ++x) {
              fields[x] =
                firstFields[x] || lastFields[lastFieldsStart + x] || ''
            }
            if (isLastFieldIPv4Address) {
              fields[fieldCount - 1] = _normalizeIPv4(
                fields[fieldCount - 1],
                protocol
              )
            }
            var allZeroFields = fields.reduce(function (acc, field, index) {
              if (!field || field === '0') {
                var lastLongest = acc[acc.length - 1]
                if (
                  lastLongest &&
                  lastLongest.index + lastLongest.length === index
                ) {
                  lastLongest.length++
                } else {
                  acc.push({ index: index, length: 1 })
                }
              }
              return acc
            }, [])
            var longestZeroFields = allZeroFields.sort(function (a, b) {
              return b.length - a.length
            })[0]
            var newHost = void 0
            if (longestZeroFields && longestZeroFields.length > 1) {
              var newFirst = fields.slice(0, longestZeroFields.index)
              var newLast = fields.slice(
                longestZeroFields.index + longestZeroFields.length
              )
              newHost = newFirst.join(':') + '::' + newLast.join(':')
            } else {
              newHost = fields.join(':')
            }
            if (zone) {
              newHost += '%' + zone
            }
            return newHost
          } else {
            return host
          }
        }
        var URI_PARSE =
          /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i
        var NO_MATCH_IS_UNDEFINED = ''.match(/(){0}/)[1] === undefined
        function parse(uriString) {
          var options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          var components = {}
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL
          if (options.reference === 'suffix')
            uriString =
              (options.scheme ? options.scheme + ':' : '') + '//' + uriString
          var matches = uriString.match(URI_PARSE)
          if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
              //store each component
              components.scheme = matches[1]
              components.userinfo = matches[3]
              components.host = matches[4]
              components.port = parseInt(matches[5], 10)
              components.path = matches[6] || ''
              components.query = matches[7]
              components.fragment = matches[8]
              //fix port number
              if (isNaN(components.port)) {
                components.port = matches[5]
              }
            } else {
              //IE FIX for improper RegExp matching
              //store each component
              components.scheme = matches[1] || undefined
              components.userinfo =
                uriString.indexOf('@') !== -1 ? matches[3] : undefined
              components.host =
                uriString.indexOf('//') !== -1 ? matches[4] : undefined
              components.port = parseInt(matches[5], 10)
              components.path = matches[6] || ''
              components.query =
                uriString.indexOf('?') !== -1 ? matches[7] : undefined
              components.fragment =
                uriString.indexOf('#') !== -1 ? matches[8] : undefined
              //fix port number
              if (isNaN(components.port)) {
                components.port = uriString.match(
                  /\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/
                )
                  ? matches[4]
                  : undefined
              }
            }
            if (components.host) {
              //normalize IP hosts
              components.host = _normalizeIPv6(
                _normalizeIPv4(components.host, protocol),
                protocol
              )
            }
            //determine reference type
            if (
              components.scheme === undefined &&
              components.userinfo === undefined &&
              components.host === undefined &&
              components.port === undefined &&
              !components.path &&
              components.query === undefined
            ) {
              components.reference = 'same-document'
            } else if (components.scheme === undefined) {
              components.reference = 'relative'
            } else if (components.fragment === undefined) {
              components.reference = 'absolute'
            } else {
              components.reference = 'uri'
            }
            //check for reference errors
            if (
              options.reference &&
              options.reference !== 'suffix' &&
              options.reference !== components.reference
            ) {
              components.error =
                components.error ||
                'URI is not a ' + options.reference + ' reference.'
            }
            //find scheme handler
            var schemeHandler =
              SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]
            //check if scheme can't handle IRIs
            if (
              !options.unicodeSupport &&
              (!schemeHandler || !schemeHandler.unicodeSupport)
            ) {
              //if host component is a domain name
              if (
                components.host &&
                (options.domainHost ||
                  (schemeHandler && schemeHandler.domainHost))
              ) {
                //convert Unicode IDN -> ASCII IDN
                try {
                  components.host = punycode.toASCII(
                    components.host
                      .replace(protocol.PCT_ENCODED, pctDecChars)
                      .toLowerCase()
                  )
                } catch (e) {
                  components.error =
                    components.error ||
                    "Host's domain name can not be converted to ASCII via punycode: " +
                      e
                }
              }
              //convert IRI -> URI
              _normalizeComponentEncoding(components, URI_PROTOCOL)
            } else {
              //normalize encodings
              _normalizeComponentEncoding(components, protocol)
            }
            //perform scheme specific parsing
            if (schemeHandler && schemeHandler.parse) {
              schemeHandler.parse(components, options)
            }
          } else {
            components.error = components.error || 'URI can not be parsed.'
          }
          return components
        }

        function _recomposeAuthority(components, options) {
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL
          var uriTokens = []
          if (components.userinfo !== undefined) {
            uriTokens.push(components.userinfo)
            uriTokens.push('@')
          }
          if (components.host !== undefined) {
            //normalize IP hosts, add brackets and escape zone separator for IPv6
            uriTokens.push(
              _normalizeIPv6(
                _normalizeIPv4(String(components.host), protocol),
                protocol
              ).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
                return '[' + $1 + ($2 ? '%25' + $2 : '') + ']'
              })
            )
          }
          if (
            typeof components.port === 'number' ||
            typeof components.port === 'string'
          ) {
            uriTokens.push(':')
            uriTokens.push(String(components.port))
          }
          return uriTokens.length ? uriTokens.join('') : undefined
        }

        var RDS1 = /^\.\.?\//
        var RDS2 = /^\/\.(\/|$)/
        var RDS3 = /^\/\.\.(\/|$)/
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/
        function removeDotSegments(input) {
          var output = []
          while (input.length) {
            if (input.match(RDS1)) {
              input = input.replace(RDS1, '')
            } else if (input.match(RDS2)) {
              input = input.replace(RDS2, '/')
            } else if (input.match(RDS3)) {
              input = input.replace(RDS3, '/')
              output.pop()
            } else if (input === '.' || input === '..') {
              input = ''
            } else {
              var im = input.match(RDS5)
              if (im) {
                var s = im[0]
                input = input.slice(s.length)
                output.push(s)
              } else {
                throw new Error('Unexpected dot segment condition')
              }
            }
          }
          return output.join('')
        }

        function serialize(components) {
          var options =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

          var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL
          var uriTokens = []
          //find scheme handler
          var schemeHandler =
            SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]
          //perform scheme specific serialization
          if (schemeHandler && schemeHandler.serialize)
            schemeHandler.serialize(components, options)
          if (components.host) {
            //if host component is an IPv6 address
            if (protocol.IPV6ADDRESS.test(components.host)) {
            }
            //TODO: normalize IPv6 address as per RFC 5952

            //if host component is a domain name
            else if (
              options.domainHost ||
              (schemeHandler && schemeHandler.domainHost)
            ) {
              //convert IDN via punycode
              try {
                components.host = !options.iri
                  ? punycode.toASCII(
                      components.host
                        .replace(protocol.PCT_ENCODED, pctDecChars)
                        .toLowerCase()
                    )
                  : punycode.toUnicode(components.host)
              } catch (e) {
                components.error =
                  components.error ||
                  "Host's domain name can not be converted to " +
                    (!options.iri ? 'ASCII' : 'Unicode') +
                    ' via punycode: ' +
                    e
              }
            }
          }
          //normalize encoding
          _normalizeComponentEncoding(components, protocol)
          if (options.reference !== 'suffix' && components.scheme) {
            uriTokens.push(components.scheme)
            uriTokens.push(':')
          }
          var authority = _recomposeAuthority(components, options)
          if (authority !== undefined) {
            if (options.reference !== 'suffix') {
              uriTokens.push('//')
            }
            uriTokens.push(authority)
            if (components.path && components.path.charAt(0) !== '/') {
              uriTokens.push('/')
            }
          }
          if (components.path !== undefined) {
            var s = components.path
            if (
              !options.absolutePath &&
              (!schemeHandler || !schemeHandler.absolutePath)
            ) {
              s = removeDotSegments(s)
            }
            if (authority === undefined) {
              s = s.replace(/^\/\//, '/%2F') //don't allow the path to start with "//"
            }
            uriTokens.push(s)
          }
          if (components.query !== undefined) {
            uriTokens.push('?')
            uriTokens.push(components.query)
          }
          if (components.fragment !== undefined) {
            uriTokens.push('#')
            uriTokens.push(components.fragment)
          }
          return uriTokens.join('') //merge tokens into a string
        }

        function resolveComponents(base, relative) {
          var options =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : {}
          var skipNormalization = arguments[3]

          var target = {}
          if (!skipNormalization) {
            base = parse(serialize(base, options), options) //normalize base components
            relative = parse(serialize(relative, options), options) //normalize relative components
          }
          options = options || {}
          if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo
            target.host = relative.host
            target.port = relative.port
            target.path = removeDotSegments(relative.path || '')
            target.query = relative.query
          } else {
            if (
              relative.userinfo !== undefined ||
              relative.host !== undefined ||
              relative.port !== undefined
            ) {
              //target.authority = relative.authority;
              target.userinfo = relative.userinfo
              target.host = relative.host
              target.port = relative.port
              target.path = removeDotSegments(relative.path || '')
              target.query = relative.query
            } else {
              if (!relative.path) {
                target.path = base.path
                if (relative.query !== undefined) {
                  target.query = relative.query
                } else {
                  target.query = base.query
                }
              } else {
                if (relative.path.charAt(0) === '/') {
                  target.path = removeDotSegments(relative.path)
                } else {
                  if (
                    (base.userinfo !== undefined ||
                      base.host !== undefined ||
                      base.port !== undefined) &&
                    !base.path
                  ) {
                    target.path = '/' + relative.path
                  } else if (!base.path) {
                    target.path = relative.path
                  } else {
                    target.path =
                      base.path.slice(0, base.path.lastIndexOf('/') + 1) +
                      relative.path
                  }
                  target.path = removeDotSegments(target.path)
                }
                target.query = relative.query
              }
              //target.authority = base.authority;
              target.userinfo = base.userinfo
              target.host = base.host
              target.port = base.port
            }
            target.scheme = base.scheme
          }
          target.fragment = relative.fragment
          return target
        }

        function resolve(baseURI, relativeURI, options) {
          var schemelessOptions = assign({ scheme: 'null' }, options)
          return serialize(
            resolveComponents(
              parse(baseURI, schemelessOptions),
              parse(relativeURI, schemelessOptions),
              schemelessOptions,
              true
            ),
            schemelessOptions
          )
        }

        function normalize(uri, options) {
          if (typeof uri === 'string') {
            uri = serialize(parse(uri, options), options)
          } else if (typeOf(uri) === 'object') {
            uri = parse(serialize(uri, options), options)
          }
          return uri
        }

        function equal(uriA, uriB, options) {
          if (typeof uriA === 'string') {
            uriA = serialize(parse(uriA, options), options)
          } else if (typeOf(uriA) === 'object') {
            uriA = serialize(uriA, options)
          }
          if (typeof uriB === 'string') {
            uriB = serialize(parse(uriB, options), options)
          } else if (typeOf(uriB) === 'object') {
            uriB = serialize(uriB, options)
          }
          return uriA === uriB
        }

        function escapeComponent(str, options) {
          return (
            str &&
            str
              .toString()
              .replace(
                !options || !options.iri
                  ? URI_PROTOCOL.ESCAPE
                  : IRI_PROTOCOL.ESCAPE,
                pctEncChar
              )
          )
        }

        function unescapeComponent(str, options) {
          return (
            str &&
            str
              .toString()
              .replace(
                !options || !options.iri
                  ? URI_PROTOCOL.PCT_ENCODED
                  : IRI_PROTOCOL.PCT_ENCODED,
                pctDecChars
              )
          )
        }

        var handler = {
          scheme: 'http',
          domainHost: true,
          parse: function parse(components, options) {
            //report missing host
            if (!components.host) {
              components.error =
                components.error || 'HTTP URIs must have a host.'
            }
            return components
          },
          serialize: function serialize(components, options) {
            var secure = String(components.scheme).toLowerCase() === 'https'
            //normalize the default port
            if (
              components.port === (secure ? 443 : 80) ||
              components.port === ''
            ) {
              components.port = undefined
            }
            //normalize the empty path
            if (!components.path) {
              components.path = '/'
            }
            //NOTE: We do not parse query strings for HTTP URIs
            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
            //and not the HTTP spec.
            return components
          }
        }

        var handler$1 = {
          scheme: 'https',
          domainHost: handler.domainHost,
          parse: handler.parse,
          serialize: handler.serialize
        }

        function isSecure(wsComponents) {
          return typeof wsComponents.secure === 'boolean'
            ? wsComponents.secure
            : String(wsComponents.scheme).toLowerCase() === 'wss'
        }
        //RFC 6455
        var handler$2 = {
          scheme: 'ws',
          domainHost: true,
          parse: function parse(components, options) {
            var wsComponents = components
            //indicate if the secure flag is set
            wsComponents.secure = isSecure(wsComponents)
            //construct resouce name
            wsComponents.resourceName =
              (wsComponents.path || '/') +
              (wsComponents.query ? '?' + wsComponents.query : '')
            wsComponents.path = undefined
            wsComponents.query = undefined
            return wsComponents
          },
          serialize: function serialize(wsComponents, options) {
            //normalize the default port
            if (
              wsComponents.port === (isSecure(wsComponents) ? 443 : 80) ||
              wsComponents.port === ''
            ) {
              wsComponents.port = undefined
            }
            //ensure scheme matches secure flag
            if (typeof wsComponents.secure === 'boolean') {
              wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws'
              wsComponents.secure = undefined
            }
            //reconstruct path from resource name
            if (wsComponents.resourceName) {
              var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                _wsComponents$resourc2 = slicedToArray(
                  _wsComponents$resourc,
                  2
                ),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1]

              wsComponents.path = path && path !== '/' ? path : undefined
              wsComponents.query = query
              wsComponents.resourceName = undefined
            }
            //forbid fragment component
            wsComponents.fragment = undefined
            return wsComponents
          }
        }

        var handler$3 = {
          scheme: 'wss',
          domainHost: handler$2.domainHost,
          parse: handler$2.parse,
          serialize: handler$2.serialize
        }

        var O = {}
        var isIRI = true
        //RFC 3986
        var UNRESERVED$$ =
          '[A-Za-z0-9\\-\\.\\_\\~' +
          (isIRI
            ? '\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF'
            : '') +
          ']'
        var HEXDIG$$ = '[0-9A-Fa-f]' //case-insensitive
        var PCT_ENCODED$ = subexp(
          subexp(
            '%[EFef]' +
              HEXDIG$$ +
              '%' +
              HEXDIG$$ +
              HEXDIG$$ +
              '%' +
              HEXDIG$$ +
              HEXDIG$$
          ) +
            '|' +
            subexp('%[89A-Fa-f]' + HEXDIG$$ + '%' + HEXDIG$$ + HEXDIG$$) +
            '|' +
            subexp('%' + HEXDIG$$ + HEXDIG$$)
        ) //expanded
        //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
        //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
        //const WSP$$ = "[\\x20\\x09]";
        //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
        //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
        //const VCHAR$$ = "[\\x21-\\x7E]";
        //const WSP$$ = "[\\x20\\x09]";
        //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
        //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
        //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
        //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]"
        var QTEXT$$ =
          "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]"
        var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]')
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"
        var UNRESERVED = new RegExp(UNRESERVED$$, 'g')
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, 'g')
        var NOT_LOCAL_PART = new RegExp(
          merge('[^]', ATEXT$$, '[\\.]', '[\\"]', VCHAR$$),
          'g'
        )
        var NOT_HFNAME = new RegExp(
          merge('[^]', UNRESERVED$$, SOME_DELIMS$$),
          'g'
        )
        var NOT_HFVALUE = NOT_HFNAME
        function decodeUnreserved(str) {
          var decStr = pctDecChars(str)
          return !decStr.match(UNRESERVED) ? str : decStr
        }
        var handler$4 = {
          scheme: 'mailto',
          parse: function parse$$1(components, options) {
            var mailtoComponents = components
            var to = (mailtoComponents.to = mailtoComponents.path
              ? mailtoComponents.path.split(',')
              : [])
            mailtoComponents.path = undefined
            if (mailtoComponents.query) {
              var unknownHeaders = false
              var headers = {}
              var hfields = mailtoComponents.query.split('&')
              for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split('=')
                switch (hfield[0]) {
                  case 'to':
                    var toAddrs = hfield[1].split(',')
                    for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                      to.push(toAddrs[_x])
                    }
                    break
                  case 'subject':
                    mailtoComponents.subject = unescapeComponent(
                      hfield[1],
                      options
                    )
                    break
                  case 'body':
                    mailtoComponents.body = unescapeComponent(
                      hfield[1],
                      options
                    )
                    break
                  default:
                    unknownHeaders = true
                    headers[unescapeComponent(hfield[0], options)] =
                      unescapeComponent(hfield[1], options)
                    break
                }
              }
              if (unknownHeaders) mailtoComponents.headers = headers
            }
            mailtoComponents.query = undefined
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
              var addr = to[_x2].split('@')
              addr[0] = unescapeComponent(addr[0])
              if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                  addr[1] = punycode.toASCII(
                    unescapeComponent(addr[1], options).toLowerCase()
                  )
                } catch (e) {
                  mailtoComponents.error =
                    mailtoComponents.error ||
                    "Email address's domain name can not be converted to ASCII via punycode: " +
                      e
                }
              } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase()
              }
              to[_x2] = addr.join('@')
            }
            return mailtoComponents
          },
          serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents
            var to = toArray(mailtoComponents.to)
            if (to) {
              for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x])
                var atIdx = toAddr.lastIndexOf('@')
                var localPart = toAddr
                  .slice(0, atIdx)
                  .replace(PCT_ENCODED, decodeUnreserved)
                  .replace(PCT_ENCODED, toUpperCase)
                  .replace(NOT_LOCAL_PART, pctEncChar)
                var domain = toAddr.slice(atIdx + 1)
                //convert IDN via punycode
                try {
                  domain = !options.iri
                    ? punycode.toASCII(
                        unescapeComponent(domain, options).toLowerCase()
                      )
                    : punycode.toUnicode(domain)
                } catch (e) {
                  components.error =
                    components.error ||
                    "Email address's domain name can not be converted to " +
                      (!options.iri ? 'ASCII' : 'Unicode') +
                      ' via punycode: ' +
                      e
                }
                to[x] = localPart + '@' + domain
              }
              components.path = to.join(',')
            }
            var headers = (mailtoComponents.headers =
              mailtoComponents.headers || {})
            if (mailtoComponents.subject)
              headers['subject'] = mailtoComponents.subject
            if (mailtoComponents.body) headers['body'] = mailtoComponents.body
            var fields = []
            for (var name in headers) {
              if (headers[name] !== O[name]) {
                fields.push(
                  name
                    .replace(PCT_ENCODED, decodeUnreserved)
                    .replace(PCT_ENCODED, toUpperCase)
                    .replace(NOT_HFNAME, pctEncChar) +
                    '=' +
                    headers[name]
                      .replace(PCT_ENCODED, decodeUnreserved)
                      .replace(PCT_ENCODED, toUpperCase)
                      .replace(NOT_HFVALUE, pctEncChar)
                )
              }
            }
            if (fields.length) {
              components.query = fields.join('&')
            }
            return components
          }
        }

        var URN_PARSE = /^([^\:]+)\:(.*)/
        //RFC 2141
        var handler$5 = {
          scheme: 'urn',
          parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE)
            var urnComponents = components
            if (matches) {
              var scheme = options.scheme || urnComponents.scheme || 'urn'
              var nid = matches[1].toLowerCase()
              var nss = matches[2]
              var urnScheme = scheme + ':' + (options.nid || nid)
              var schemeHandler = SCHEMES[urnScheme]
              urnComponents.nid = nid
              urnComponents.nss = nss
              urnComponents.path = undefined
              if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options)
              }
            } else {
              urnComponents.error =
                urnComponents.error || 'URN can not be parsed.'
            }
            return urnComponents
          },
          serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || 'urn'
            var nid = urnComponents.nid
            var urnScheme = scheme + ':' + (options.nid || nid)
            var schemeHandler = SCHEMES[urnScheme]
            if (schemeHandler) {
              urnComponents = schemeHandler.serialize(urnComponents, options)
            }
            var uriComponents = urnComponents
            var nss = urnComponents.nss
            uriComponents.path = (nid || options.nid) + ':' + nss
            return uriComponents
          }
        }

        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/
        //RFC 4122
        var handler$6 = {
          scheme: 'urn:uuid',
          parse: function parse(urnComponents, options) {
            var uuidComponents = urnComponents
            uuidComponents.uuid = uuidComponents.nss
            uuidComponents.nss = undefined
            if (
              !options.tolerant &&
              (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))
            ) {
              uuidComponents.error =
                uuidComponents.error || 'UUID is not valid.'
            }
            return uuidComponents
          },
          serialize: function serialize(uuidComponents, options) {
            var urnComponents = uuidComponents
            //normalize UUID
            urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()
            return urnComponents
          }
        }

        SCHEMES[handler.scheme] = handler
        SCHEMES[handler$1.scheme] = handler$1
        SCHEMES[handler$2.scheme] = handler$2
        SCHEMES[handler$3.scheme] = handler$3
        SCHEMES[handler$4.scheme] = handler$4
        SCHEMES[handler$5.scheme] = handler$5
        SCHEMES[handler$6.scheme] = handler$6

        exports.SCHEMES = SCHEMES
        exports.pctEncChar = pctEncChar
        exports.pctDecChars = pctDecChars
        exports.parse = parse
        exports.removeDotSegments = removeDotSegments
        exports.serialize = serialize
        exports.resolveComponents = resolveComponents
        exports.resolve = resolve
        exports.normalize = normalize
        exports.equal = equal
        exports.escapeComponent = escapeComponent
        exports.unescapeComponent = unescapeComponent

        Object.defineProperty(exports, '__esModule', { value: true })
      })
      //# sourceMappingURL=uri.all.js.map

      /***/
    },

    /***/ 4775: /***/ (module) => {
      'use strict'
      module.exports = JSON.parse(
        '{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}'
      )

      /***/
    },

    /***/ 98: /***/ (module) => {
      'use strict'
      module.exports = JSON.parse(
        '{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}'
      )

      /***/
    }

    /******/
  }
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {}
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId]
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {}
      /******/
    })
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    )
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ ;(() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module['default']
          : /******/ () => module
      /******/ __webpack_require__.d(getter, { a: getter })
      /******/ return getter
      /******/
    }
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ ;(() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          })
          /******/
        }
        /******/
      }
      /******/
    }
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/global */
  /******/ ;(() => {
    /******/ __webpack_require__.g = (function () {
      /******/ if (typeof globalThis === 'object') return globalThis
      /******/ try {
        /******/ return this || new Function('return this')()
        /******/
      } catch (e) {
        /******/ if (typeof window === 'object') return window
        /******/
      }
      /******/
    })()
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ ;(() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop)
    /******/
  })()
  /******/
  /************************************************************************/
  var __webpack_exports__ = {}
  // This entry need to be wrapped in an IIFE because it need to be in strict mode.
  ;(() => {
    'use strict'

    // EXTERNAL MODULE: ./node_modules/alertifyjs/build/alertify.js
    var alertify = __webpack_require__(8307)
    var alertify_default = /*#__PURE__*/ __webpack_require__.n(alertify)
    // EXTERNAL MODULE: ./node_modules/debounce/index.js
    var debounce = __webpack_require__(296)
    var debounce_default = /*#__PURE__*/ __webpack_require__.n(debounce)
    // EXTERNAL MODULE: ./node_modules/delegate/src/delegate.js
    var delegate = __webpack_require__(9438)
    var delegate_default = /*#__PURE__*/ __webpack_require__.n(delegate)
    // EXTERNAL MODULE: ./node_modules/dohtml/index.js
    var dohtml = __webpack_require__(1182)
    var dohtml_default = /*#__PURE__*/ __webpack_require__.n(dohtml)
    // EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
    var jquery = __webpack_require__(9755)
    var jquery_default = /*#__PURE__*/ __webpack_require__.n(jquery)
    // EXTERNAL MODULE: ./node_modules/jquery-ui/ui/widgets/dialog.js
    var dialog = __webpack_require__(2466) // CONCATENATED MODULE: ./src/lib/component/Dialog.js
    class Dialog {
      constructor(title, contentHtml, option = {}) {
        this._el = dohtml_default().create(`
    <div title="${title}">
      ${contentHtml}
    </div>
    `)
        this._$dialog = jquery_default()(this._el)
        this._$dialog.on('dialogclose', () => {
          // Delay destroy to check a click target is child of the dialog.
          requestAnimationFrame(() => this._$dialog.dialog('destroy'))
        })

        this._option = option
      }

      get el() {
        return this._el
      }

      get button() {
        return this._$dialog
          .dialog('widget')[0]
          .querySelector('.ui-dialog-buttonpane button')
      }

      open() {
        this._$dialog.dialog({
          ...{
            dialogClass: 'textae-editor__dialog',
            height: 'auto',
            modal: true,
            resizable: false,
            width: 'calc(100% - 10px)',
            create: (event) => {
              // The maxWidth option of the jQuery UI dialog is not working.
              // See: https://stackoverflow.com/a/20218692/1276969
              jquery_default()(event.target.parentElement).css(
                'maxWidth',
                `${this._option.maxWidth || 550}px`
              )
            }
          },
          ...this._option
        })
      }

      close() {
        this._$dialog.dialog('close')
      }
    } // CONCATENATED MODULE: ./src/lib/component/HelpDialog.js

    class HelpDialog extends Dialog {
      constructor() {
        super(
          'Help (Keyboard short-cuts)',
          `<div class="textae-tool__key-help"></div>
       <ul>
         <li>
          cut
          : Ctrl+x
        </li>
         <li>
          copy
          : Ctrl+c
        </li>
         <li>
          paste
          : Ctrl+v
        </li>
       </ul>
      `,

          {
            maxWidth: 523
          }
        )
      }
    } // CONCATENATED MODULE: ./src/lib/component/TipsDialog.js

    class TipsDialog extends Dialog {
      constructor() {
        super(
          'For security reason, the shortcut keys for cut/copy/paste are changed as follows:',
          `<table class="textae-editor__tips-dialog__table">
        <thead>
          <tr><th></th><th>before</th><th>after</th></tr>
        </thead>
        <tbody>
          <tr><td>cut</td><td>x</td><td>Ctrl-x</td></tr>
          <tr><td>copy</td><td>c</td><td>Ctrl-c</td></tr>
          <tr><td>paste</td><td>v</td><td>Ctrl-v</td></tr>
        </tbody>
      </table>
      `,

          {
            maxWidth: 785
          }
        )
      }
    } // CONCATENATED MODULE: ./src/lib/textae/Tool/EditorContainer/isTextFields.js

    /* harmony default export */ function isTextFields(htmlElement) {
      return (
        htmlElement instanceof HTMLInputElement ||
        htmlElement instanceof HTMLTextAreaElement
      )
    }

    // EXTERNAL MODULE: ./node_modules/throttleit/index.js
    var throttleit = __webpack_require__(9623)
    var throttleit_default = /*#__PURE__*/ __webpack_require__.n(throttleit) // CONCATENATED MODULE: ./src/lib/textae/Tool/EditorContainer/index.js
    const helpDialog = new HelpDialog()
    const tipsDialog = new TipsDialog()

    class EditorContainer {
      constructor() {
        this._editors = new Map()
        this._selected = null
        this._counter = 0

        delegate_default()(window, '.textae-editor', 'keyup', (event) => {
          // Keyup events occurs without selected editor, When editor is focused before initializing.
          if (this.selected) {
            switch (event.key) {
              case 'h':
                helpDialog.open()
                break
              case 'c':
              case 'x':
              case 'v':
                if (!event.ctrlKey && !event.metaKey) {
                  tipsDialog.open()
                }
            }
          }
        })

        this._observeDocumentEvents()
      }

      set(element, editor) {
        this._editors.set(element, editor)
        this._counter++
      }

      remove(element) {
        this._editors.get(element).dispose()
        this._editors.delete(element)

        if (this.selected === element) {
          this._selected = null
        }
      }

      get selected() {
        return this._selected
      }

      set selected(element) {
        if (element === null) {
          this._selectedEditor.deactivate()
          this._selected = null
        } else {
          this._selected = element
          this._selectedEditor.activate()
        }
      }

      drawGridsInSight() {
        for (const editor of this._editors.values()) {
          editor.drawGridsInSight()
        }
      }

      updateDenotationEntitiesWidth() {
        for (const editor of this._editors.values()) {
          editor.updateDenotationEntitiesWidth()
        }
      }

      reLayout() {
        for (const editor of this._editors.values()) {
          editor.reLayout()
        }
      }

      has(element) {
        return this._editors.has(element)
      }

      get nextID() {
        return `editor${this._counter}`
      }

      _observeDocumentEvents() {
        document.addEventListener(
          'scroll',
          throttleit_default()(() => {
            this.drawGridsInSight()
          }, 300)
        )

        // Since the Body element does not yet exist at the time of initializing the EditorContainer,
        // we will set up an event handler in the document.
        document.addEventListener('copy', (e) => {
          if (isTextFields(e.target)) {
            return
          }

          if (this.selected) {
            this._editors.get(this.selected).copyEntitiesToSystemClipboard(e)
          }
        })
        document.addEventListener('cut', (e) => {
          if (isTextFields(e.target)) {
            return
          }

          if (this.selected) {
            this._editors.get(this.selected).cutEntitiesToSystemClipboard(e)
          }
        })
        document.addEventListener('paste', (e) => {
          if (isTextFields(e.target)) {
            return
          }

          if (this.selected) {
            this._editors.get(this.selected).pasteEntitiesFromSystemClipboard(e)
          }
        })

        // Enable/disable the context menu icon by looking at the text selection.
        document.addEventListener(
          'selectionchange',
          debounce_default()(() => {
            if (this.selected) {
              this._editors.get(this.selected).applyTextSelection()
            }
          }, 100)
        )
        document.addEventListener('contextmenu', () => {
          if (this.selected) {
            this._editors.get(this.selected).applyTextSelection()
          }
        })

        // Close ContextMenu when another editor is clicked
        document.addEventListener('click', (e) => {
          // In Firefox, the right button of mouse fires a 'click' event.
          // https://stackoverflow.com/questions/43144995/mouse-right-click-on-firefox-triggers-click-event
          // In Firefox, MouseEvent has a 'which' property, which is 3 when the right button is clicked.
          // https://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
          if (e.which === 3) {
            return
          }

          for (const api of this._editors.values()) {
            api.hideContextMenu()
          }
        })

        document.addEventListener('contextmenu', (contextmenuEvent) => {
          // Close ContextMenu when another editor is clicked.
          for (const api of this._editors.values()) {
            api.hideContextMenu()
          }

          // If the editor you click on is selected and editable,
          // it will display its own context menu, rather than the browser's context menu.
          const clickedEditor =
            contextmenuEvent.target.closest('.textae-editor')
          if (clickedEditor === this._selected) {
            if (
              clickedEditor.classList.contains(
                'textae-editor__mode--view-with-relation'
              ) ||
              clickedEditor.classList.contains(
                'textae-editor__mode--view-without-relation'
              )
            ) {
              return
            }

            // Prevent show browser default context menu
            contextmenuEvent.preventDefault()
            this._selectedEditor.showContextMenu(contextmenuEvent)
          }
        })
      }

      get _selectedEditor() {
        return this._editors.get(this._selected)
      }
    } // CONCATENATED MODULE: ./src/lib/textae/Tool/Veil.js

    const config = {
      attributes: true,
      attributeFilter: ['class']
    }

    class Veil {
      constructor() {
        // Since not all editors will be notified at once, keep the state in a instance variable.
        this._waitingEditors = new Set()
      }

      setObserver(editorHTMLElement) {
        // Do not create HTML elements in the constructor
        // so that this class can be initialized before document.body is created.
        // Instead, we create it here.
        if (!this._el) {
          this._el = dohtml_default().create(
            `<div class="textae-editor-veil" style="display: none;"></div>`
          )
          document.body.appendChild(this._el)
        }

        new MutationObserver((mutationRecords) =>
          this._mutationCallback(mutationRecords)
        ).observe(editorHTMLElement, config)
      }

      _mutationCallback(mutationRecords) {
        this._collectWaitingEditors(mutationRecords)

        if (this._waitingEditors.size > 0) {
          this._show()
        } else {
          this._hide()
        }
      }

      _collectWaitingEditors(mutationRecords) {
        mutationRecords.forEach(({ target }) => {
          if (target.classList.contains('textae-editor--wait')) {
            this._waitingEditors.add(target)
          } else {
            this._waitingEditors.delete(target)
          }
        })
      }

      _show() {
        this._el.style.display = 'block'
      }

      _hide() {
        this._el.style.display = 'none'
      }
    } // CONCATENATED MODULE: ./src/lib/textae/Tool/observeBodyEvents.js

    /**
     *
     * @param {import('./EditorContainer').default} editorContainer
     */
    /* harmony default export */ function observeBodyEvents(editorContainer) {
      // The blur events always occurs each focus changing.
      // For example, blur events always occurs when the labels in the pallet is clicked.
      // If other editors are selected, the pallet should be closed.
      // But the blur events is not distinguished from clicking on the pallet and selection other editors.

      // Select the editor when the editor, a span or an entity-type is focused in.
      // Unselect the editor when a child element of other than the editor is focused in.
      // The click events are not fired on changing the selection by the tab key.
      document.body.addEventListener(
        'focus',
        (e) => {
          const element = e.target.closest('.textae-editor')

          if (element) {
            if (
              editorContainer.selected &&
              editorContainer.selected !== element
            ) {
              editorContainer.selected = null
            }
            editorContainer.selected = element
          }
        },
        true
      )

      // Unselect the editor when a child element of other than the editor is clicked.
      // The focus events are not fired on the un-focusable elements like div.
      document.body.addEventListener('click', (e) => {
        // Ignore clicks on the jQuery UI dialogs.
        if (e.target.closest('.textae-editor__dialog') !== null) {
          return
        }

        // Ignore clicks on the auto-completion items.
        if (e.target.closest('.ui-autocomplete') !== null) {
          return
        }

        // Ignore clicks on the overlay of the jQuery UI.
        if (e.target.closest('.ui-widget-overlay') !== null) {
          return
        }

        // Ignore clicks on the pallet.
        if (e.target.closest('.textae-editor__pallet__content') !== null) {
          return
        }

        // Ignore clicks on children of the this Editor
        if (editorContainer.has(e.target.closest('.textae-editor'))) {
          return
        }

        if (editorContainer.selected) {
          editorContainer.selected = null
        }
      })

      // Observes the removal of the editor element.
      // Remove deleted editor from the editor container.
      new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
          if (mutation.type === 'childList') {
            for (const removedNode of mutation.removedNodes) {
              if (removedNode instanceof HTMLElement) {
                if (removedNode.classList.contains('textae-editor')) {
                  editorContainer.remove(removedNode)
                }

                for (const editor of removedNode.querySelectorAll(
                  '.textae-editor'
                )) {
                  editorContainer.remove(editor)
                }
              }
            }
          }
        }
      }).observe(document.body, { childList: true, subtree: true })
    } // CONCATENATED MODULE: ./src/lib/textae/Tool/getMousePoint.js

    // Observe and record mouse position to return it.
    const lastMousePoint = {}

    document.querySelector('html').addEventListener('mousemove', (e) => {
      lastMousePoint.clientY = e.clientY
      lastMousePoint.pageY = e.pageY
      lastMousePoint.clientX = e.clientX
    })

    /* harmony default export */ function getMousePoint() {
      return lastMousePoint
    } // CONCATENATED MODULE: ./src/lib/textae/Tool/index.js

    // The tool manages interactions between components.
    class Tool {
      constructor() {
        this._editorContainer = new EditorContainer()
        this._veil = new Veil()
        this._mousePoint = getMousePoint()

        // When the DOMContentLoaded event occurs, document.body may not have been initialized yet.
        // When the load event occurs, bind the event handler of document.body.
        window.addEventListener('load', () =>
          observeBodyEvents(this._editorContainer)
        )

        // Observe window-resize event and redraw all editors.
        window.addEventListener(
          'resize',
          throttleit_default()(() => {
            this._editorContainer.reLayout()
            this._editorContainer.drawGridsInSight()
            this._editorContainer.updateDenotationEntitiesWidth()
          }, 500)
        )
      }

      get nextID() {
        return this._editorContainer.nextID
      }

      get mousePoint() {
        return this._mousePoint
      }

      registerEditor(element, editor) {
        this._veil.setObserver(element)
        this._editorContainer.set(element, editor)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/InstanceContainer/index.js

    class InstanceContainer {
      constructor(emitter, name) {
        this._emitter = emitter
        this._name = name
        this._container = new Map()
      }

      _toInstance(rowDatum) {
        return rowDatum
      }

      addSource(source, type) {
        for (const instance of source.map((r) => this._toInstance(r, type))) {
          this._addToContainer(instance)
        }
      }

      add(instance) {
        const newInstance = this._addToContainer(instance)
        this._emit(
          `textae-event.annotation-data.${this._name}.add`,
          newInstance
        )
        return newInstance
      }

      get(id) {
        return this._container.get(id)
      }

      get all() {
        return Array.from(this._container.values())
      }

      get selectedItems() {
        return this.all.filter(({ isSelected }) => isSelected)
      }

      findByType(typeName) {
        return this.all.filter((instance) => instance.typeName === typeName)
      }

      /**
       * @returns {boolean} true if the container has any instance.
       * @readonly
       */
      get some() {
        return !!this._container.size
      }

      changeType(id, newType) {
        const instance = this._container.get(id)
        instance.typeName = newType
        this._emit(
          `textae-event.annotation-data.${this._name}.change`,
          instance
        )
        return instance
      }

      remove(id) {
        const instance = this._container.get(id)
        if (instance) {
          this._container.delete(id)
          this._emit(
            `textae-event.annotation-data.${this._name}.remove`,
            instance
          )
        }
        return instance
      }

      clear() {
        this._container.clear()
      }

      _addToContainer(instance) {
        this._container.set(instance.id, instance)
        return instance
      }

      _emit(event, data) {
        this._emitter.emit(event, data)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/updateSpanTree/getParent/isChildOf.js

    /* harmony default export */ function isChildOf(span, maybeParent) {
      if (!maybeParent) {
        return false
      }

      return maybeParent.begin <= span.begin && span.end <= maybeParent.end
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/updateSpanTree/getParent/index.js

    function getParet(span, parent) {
      if (isChildOf(span, parent)) {
        return parent
      } else if (parent.parent) {
        return getParet(span, parent.parent)
      } else {
        return null
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/spanComparator.js

    /* harmony default export */ function spanComparator(a, b) {
      return a.begin - b.begin || b.end - a.end
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/updateSpanTree/index.js

    // the spanTree has parent-child structure.
    /* harmony default export */ function updateSpanTree(root, spans) {
      // Sort spans by the position.
      const sortedSpans = spans.sort(spanComparator)

      sortedSpans.forEach((span, index, array) => {
        span.severTies()

        const left = index !== 0 ? array[index - 1] : null
        if (left) {
          const parent = getParet(span, left)
          if (parent) {
            span.beChildOf(parent)
          } else {
            span.beChildOf(root)
          }
        } else {
          span.beChildOf(root)
        }
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/idFactory.js

    // The ID of spans has editorID and begin and end, like 'editor1__S0_15'.
    function makeDenotationSpanHTMLElementID(editorID, begin, end) {
      return `${editorID}__D${begin}_${end}`
    }

    function makeStyleSpanHTMLElementID(editorID, begin, end) {
      return `${editorID}__S${begin}_${end}`
    }

    function makeBlockSpanHTMLElementID(editorID, begin, end) {
      return `${editorID}__B${begin}_${end}`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/SELECTED.js

    const SELECTED = 'ui-selected'
    /* harmony default export */ const SpanInstanceContainer_SELECTED = SELECTED // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/DenotationSpanInstance/getGridHeightIncludeDescendantGrids.js

    /**
     *
     * @param {import('./index').DenotationSpanInstance} span
     * @param {number} typeGap
     * @returns {number}
     */
    function getGridHeightIncludeDescendantGrids(span) {
      const descendantsMaxHeight =
        span.children.length === 0 ? 0 : getMaxHeight(span)
      const height = span.gridHeight

      return height + descendantsMaxHeight
    }

    function getMaxHeight(span) {
      return Math.max.apply(
        null,
        span.children.map((childSpan) =>
          getGridHeightIncludeDescendantGrids(childSpan)
        )
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/round.js

    // The value of getBoundingClientRect may contain 13 decimal places.
    // It's too fine to use as a style attribute,
    // so I'll round it to 2 decimal places,
    // which is below the rounding accuracy of Google Chrome and Firefox.
    /* harmony default export */ function round(val) {
      return Math.round(val * 100) / 100
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/SpanInstance/createGridHtml.js

    /* harmony default export */ function createGridHtml(
      spanId,
      top,
      left,
      width
    ) {
      return `
<div 
  id=G${spanId} 
  class="textae-editor__grid" 
  style="top: ${top}px; left: ${left}px; width: ${width}px;">
</div>
`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/SpanInstance/updateGridPosition/isStaying.js

    /* harmony default export */ function isStaying(gridElement, top, left) {
      if (
        gridElement.style &&
        parseFloat(gridElement.style.top) === top &&
        parseFloat(gridElement.style.left) === left
      ) {
        return true
      }
      return false
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/SpanInstance/updateGridPosition/index.js

    /* harmony default export */ function updateGridPosition(
      gridElement,
      top,
      left
    ) {
      if (!isStaying(gridElement, top, left)) {
        gridElement.style.top = `${top}px`
        gridElement.style.left = `${left}px`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/getAnnotationBox.js

    // Get the display area for denotations and relations.
    /* harmony default export */ function getAnnotationBox(editorHTMLElement) {
      return editorHTMLElement.querySelector('.textae-editor__annotation-box')
    } // CONCATENATED MODULE: ./src/lib/Editor/getRightElement.js

    /* harmony default export */ function getRightElement(
      editorHTMLElement,
      element,
      className
    ) {
      console.assert(element, 'element MUST exists.')

      const all = editorHTMLElement.querySelectorAll(`.${className}`)
      const index = Array.from(all).indexOf(element)

      if (all.length - index > 1) {
        return all[index + 1]
      }

      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/getRightSpanElement.js

    /* harmony default export */ function getRightSpanElement(
      editorHTMLElement,
      spanId
    ) {
      return getRightElement(
        editorHTMLElement,
        document.querySelector(`#${spanId}`),
        'textae-editor__span'
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/SpanInstance/getRightGrid.js

    /* harmony default export */ function getRightGrid(
      editorHTMLElement,
      spanId
    ) {
      const rightSpan = getRightSpanElement(editorHTMLElement, spanId)

      if (rightSpan) {
        return document.querySelector(`#G${rightSpan.id}`)
      }

      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/createRangeToSpan/getRenderingPosition/getOffset.js

    /* harmony default export */ function getOffset(span, startOfTextNode) {
      const start = span.begin - startOfTextNode
      const end = span.end - startOfTextNode

      return {
        start,
        end
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/createRangeToSpan/getRenderingPosition/getRenderingPositionFromParent.js

    /* harmony default export */ function getRenderingPositionFromParent(span) {
      const { start, end } = getOffset(span, span.parent.begin)

      return {
        textNode: span.parent.element.firstChild,
        start,
        end
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/isBoundaryCrossing.js

    /* harmony default export */ function isBoundaryCrossing(
      begin,
      end,
      existSpan
    ) {
      const isStartOfCandidateSpanBetweenExistsSpan =
        existSpan.begin < begin && begin < existSpan.end && existSpan.end < end

      const isEndOfCandidateSpanBetweenExistSpan =
        begin < existSpan.begin && existSpan.begin < end && end < existSpan.end

      return (
        isStartOfCandidateSpanBetweenExistsSpan ||
        isEndOfCandidateSpanBetweenExistSpan
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/createRangeToSpan/getRenderingPosition/getRenderingPositionFromBigBrother.js

    /* harmony default export */ function getRenderingPositionFromBigBrother(
      span,
      bigBrotherSpan
    ) {
      if (isBoundaryCrossing(span.begin, span.end, bigBrotherSpan)) {
        throw new Error(`span ${span.id} is corrisng with ${bigBrotherSpan.id}`)
      }

      let { start, end } = getOffset(span, bigBrotherSpan.end)
      let textNode = bigBrotherSpan.element.nextSibling

      // Google chrome and Safari have a 65536 character limit on the text node.
      //  A string may consist of two or more text nodes.
      // If the start position is larger than the length of the text node,
      //  the next text node is used as the range for creating a span.
      if (textNode.length < start) {
        start = start - textNode.length
        end = end - textNode.length
        textNode = textNode.nextSibling
      }

      return {
        textNode,
        start,
        end
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/createRangeToSpan/getRenderingPosition/index.js

    /* harmony default export */ function getRenderingPosition(span) {
      const bigBrotherSpan = span.bigBrother

      if (bigBrotherSpan) {
        // The target text arrounded by span is in a textNode after the bigBrotherSpan
        // if bigBrotherSpan exists.
        return getRenderingPositionFromBigBrother(span, bigBrotherSpan)
      } else {
        // There is no big brother if the span is first in the text.
        // The target text arrounded by span is the first child of parent
        // unless bigBrotherSpan exists.
        return getRenderingPositionFromParent(span)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/createRangeToSpan/createRange.js

    /* harmony default export */ function createRange(textNode, start, end) {
      const range = document.createRange()

      range.setStart(textNode, start)
      range.setEnd(textNode, end)

      return range
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/createRangeToSpan/index.js

    // Get the Range to that new span tag insert.
    // This function works well when no child span is rendered.
    /* harmony default export */ function createRangeToSpan(span) {
      const { textNode, start, end } = getRenderingPosition(span)

      if (!textNode) {
        throw new Error(
          `The textNode on to create a span is not found. ${span.id}`
        )
      }

      if (start < 0) {
        throw new Error(`start must be positive, but ${start} for ${span.id}.`)
      }

      if (textNode.length < end) {
        throw new Error(
          `oh my god! I cannot render ${span.id}. "${textNode.textContent.slice(
            start,
            end
          )}" at ${start}~${end} of text(${textNode.textContent.length}) as "${
            textNode.textContent
          }".`
        )
      }

      return createRange(textNode, start, end)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/SpanInstance/index.js

    class SpanInstance {
      constructor(
        editorID,
        editorHTMLElement,
        begin,
        end,
        spanInstanceContainer
      ) {
        this._editorID = editorID
        this._editorHTMLElement = editorHTMLElement
        this._begin = begin
        this._end = end
        this._spanInstanceContainer = spanInstanceContainer
        this._isGridRendered = false
        this._isSelected = false
        /**
         * @type {Set<import('../../../EntityInstance').EntityInstance>}
         */
        this._entities = new Set()

        this.severTies()
      }

      get begin() {
        return this._begin
      }

      get end() {
        return this._end
      }

      get title() {
        return `${this._begin}-${this._end}`
      }

      get types() {
        return []
      }

      /**
       * @return {[import('../../../EntityInstance').EntityInstance]}
       */
      get entities() {
        return [...this._entities]
      }

      get relations() {
        return this.entities.map(({ relations }) => relations).flat()
      }

      get bigBrother() {
        // The parent of a big Brother and the span is the same.
        const bros = this.parent.children
        const index = bros.indexOf(this)
        return index === 0 ? null : bros[index - 1]
      }

      get root() {
        return this._spanInstanceContainer
      }

      get parent() {
        return this._parent
      }

      get children() {
        return this._children
      }

      /**
       *
       * @param {import('../../../EntityInstance').EntityInstance} entity
       */
      add(entity) {
        this._entities.add(entity)
      }

      /**
       *
       * @param {import('../../../EntityInstance').EntityInstance} entity
       */
      remove(entity) {
        this._entities.delete(entity)
      }

      severTies() {
        // Reset parent
        this._parent = null
        // Reset children
        this._children = []
      }

      beChildOf(parent) {
        parent.children.push(this)
        this._parent = parent
      }

      traverse(preOrderFunction) {
        preOrderFunction(this)

        for (const child of this._children) {
          child.traverse(preOrderFunction)
        }
      }

      get element() {
        return document.querySelector(`#${this.id}`)
      }

      render() {
        // Destroy children spans to wrap a TextNode with <span> tag when new span over exists spans.
        this.traverse((span) => {
          if (span.element !== null) {
            span.destroyElement()
          }
        })

        // Reflow occurs when acquiring the position information of the span to draw the grid.
        // If the span drawing and grid drawing are repeated at the first display,
        // the reflow effect will slow down the process.
        // Here, only the span will be drawn,
        // and the grid drawing will be done at another time.
        this.traverse((span) => span.renderElement())
      }

      erase() {
        if (this.hasStyle) {
          const spanElement = this.element
          spanElement.removeAttribute('tabindex')
          spanElement.classList.remove('textae-editor__span')
        } else {
          this.destroyElement()
        }
        this._destroyGridElement()
      }

      renderElement() {
        const element = dohtml_default().create(this._contentHTML)
        const targetRange = createRangeToSpan(this)
        targetRange.surroundContents(element)
      }

      destroyElement() {
        const spanElement = this.element
        const parent = spanElement.parentNode

        // Move the textNode wrapped this span in front of this span.
        while (spanElement.firstChild) {
          parent.insertBefore(spanElement.firstChild, spanElement)
        }

        parent.removeChild(spanElement)
        parent.normalize()
      }

      get gridElement() {
        return document.querySelector(`#G${this.id}`)
      }

      get gridHeight() {
        return this.entities
          .map(({ heightWithTypeGap }) => heightWithTypeGap)
          .reduce((sum, entityHeight) => sum + entityHeight, 0)
      }

      get isGridRendered() {
        return this._isGridRendered
      }

      get isSelected() {
        return this._selected
      }

      select() {
        this._selected = true
      }

      deselect() {
        this._selected = false
      }

      focus() {
        // Grids outside the rendering area may not be rendered.
        this.forceRenderGrid()
        this.element.focus()
      }

      addEntityElementToGridElement(entityElement) {
        this.gridElement.insertAdjacentElement('beforeend', entityElement)
      }

      updateSelfAndAncestorsGridPosition() {
        // Do nothing.
        // This method overrided in the DenotationSpanInstance.
      }

      drawGrid(clientHeight, clientWidth) {
        if (this.isGridInDrawArea(clientHeight, clientWidth)) {
          this.forceRenderGrid()
        } else {
          this._destroyGridElement()
        }
      }

      forceRenderGrid() {
        if (this._isGridRendered) {
          return
        }

        this._renderGridElement()
        for (const entity of this.entities) {
          entity.render()
        }
      }

      isGridInDrawArea() {
        throw new Error(
          'SpanInstance.isGridInDrawArea should be implemented in a subclass.'
        )
      }

      _renderGridElement() {
        if (this.isGridRendered) {
          return this.gridElement
        }

        const rightGrid = getRightGrid(this._editorHTMLElement, this.id)
        if (rightGrid) {
          // insert before the right grid.
          rightGrid.insertAdjacentElement(
            'beforebegin',
            this._createGridElement()
          )
          this._isGridRendered = true

          return rightGrid.previousElementSibling
        } else {
          // append to the annotation area.
          const container = getAnnotationBox(this._editorHTMLElement)
          container.insertAdjacentElement(
            'beforeend',
            this._createGridElement()
          )
          this._isGridRendered = true

          return container.lastElementChild
        }
      }

      _createGridElement() {
        const { offsetTopOfGrid, offsetLeftOfGrid, widthOfGrid } = this
        const html = createGridHtml(
          this.id,
          round(offsetTopOfGrid),
          round(offsetLeftOfGrid),
          widthOfGrid
        )
        return dohtml_default().create(html)
      }

      updateGridPosition() {
        if (this.isGridRendered) {
          const { offsetTopOfGrid, offsetLeftOfGrid } = this
          updateGridPosition(
            this.gridElement,
            round(offsetTopOfGrid),
            round(offsetLeftOfGrid)
          )
        }
      }

      _destroyGridElement() {
        if (this.isGridRendered) {
          this._isGridRendered = false

          for (const entity of this.entities) {
            entity.erase()
          }

          this.gridElement.remove()
        }
      }

      get _styleClasses() {
        return [...this.styles.values()].map(
          (style) => `textae-editor__style textae-editor__style--${style}`
        )
      }

      /**
       *
       * @param {import('../../../UseCase/Presenter/EditMode/SelectionWrapper').default} selectionWrapper
       */
      getShortenInAnchorNodeToFocusNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (anchor < focus) {
          // shorten the left boundary
          return {
            begin: spanAdjuster.forwardFromBegin(sourceDoc, focus, spanConfig),
            end: this.end
          }
        } else {
          // shorten the right boundary
          return {
            begin: this.begin,
            end: spanAdjuster.backFromEnd(sourceDoc, focus - 1, spanConfig) + 1
          }
        }
      }

      getShortenInFocusNodeToAnchorNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (focus < anchor) {
          // shorten the left boundary
          return {
            begin: spanAdjuster.forwardFromBegin(sourceDoc, anchor, spanConfig),
            end: this.end
          }
        } else {
          // shorten the right boundary
          return {
            begin: this.begin,
            end: spanAdjuster.backFromEnd(sourceDoc, anchor - 1, spanConfig) + 1
          }
        }
      }

      getExpandedInAnchorNodeToFocusNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (anchor < focus) {
          // expand to the right
          return {
            begin: this.begin,
            end:
              spanAdjuster.forwardFromEnd(sourceDoc, focus - 1, spanConfig) + 1
          }
        } else {
          // expand to the left
          return {
            begin: spanAdjuster.backFromBegin(sourceDoc, focus, spanConfig),
            end: this.end
          }
        }
      }

      getExpandedInFocusNodeToAnchorNodeDirection(
        spanAdjuster,
        selectionWrapper,
        sourceDoc,
        spanConfig
      ) {
        const { anchor, focus } = selectionWrapper.positionsOnAnnotation

        if (focus < anchor) {
          // expand to the right
          return {
            begin: this.begin,
            end:
              spanAdjuster.forwardFromEnd(sourceDoc, anchor - 1, spanConfig) + 1
          }
        } else {
          // expand to the left
          return {
            begin: spanAdjuster.backFromBegin(sourceDoc, anchor, spanConfig),
            end: this.end
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/isTouchable.js

    // https://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript/4819886#4819886
    /* harmony default export */ function isTouchable() {
      return (
        'ontouchstart' in window ||
        navigator.maxTouchPoints > 0 ||
        navigator.msMaxTouchPoints > 0
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/DenotationSpanInstance/index.js

    const TEXT_HEIGHT = 23
    const MARGIN_TOP = 5
    class DenotationSpanInstance extends SpanInstance {
      constructor(
        editorID,
        editorHTMLElement,
        begin,
        end,
        entityInstanceContainer,
        spanInstanceContainer
      ) {
        super(editorID, editorHTMLElement, begin, end, spanInstanceContainer)
        this._entityInstanceContainer = entityInstanceContainer
      }

      get id() {
        return makeDenotationSpanHTMLElementID(
          this._editorID,
          this._begin,
          this._end
        )
      }

      passesAllEntitiesTo(newSpan) {
        for (const entity of this.entities) {
          entity.span = newSpan
        }
      }

      get hasStyle() {
        return this.styles.size > 0
      }

      // Merges a span and a typesetting so that it can be rendered as a single DOM element.
      get styles() {
        return this._spanInstanceContainer.getStyle(this.id)
      }

      get _offsetLeft() {
        const spanElement = this.element

        // An element.offsetTop and element.offsetLeft does not work in the Firefox,
        // when much spans are loaded like http://pubannotation.org/docs/sourcedb/PMC/sourceid/1315279/divs/10/annotations.json.
        const rectOfSpan = spanElement.getBoundingClientRect()
        const rectOfTextBox =
          spanElement.offsetParent.offsetParent.getBoundingClientRect()

        const left = rectOfSpan.left - rectOfTextBox.left

        return left
      }

      get isDenotation() {
        return true
      }

      addEntityElementToGridElement(entityElement) {
        super.addEntityElementToGridElement(entityElement)
        this.updateSelfAndAncestorsGridPosition()
      }

      updateSelfAndAncestorsGridPosition() {
        this.updateGridPosition()
        let parentSpan = this.parent
        while (parentSpan instanceof DenotationSpanInstance) {
          parentSpan.updateGridPosition()
          parentSpan = parentSpan.parent
        }
      }

      updateDenotationEntitiesWidth() {
        if (this.isGridRendered) {
          const { widthOfGrid } = this
          this.gridElement.style.width = `${widthOfGrid}px`
        }
      }

      select() {
        super.select()

        const el = super.element
        el.classList.add(SpanInstanceContainer_SELECTED)

        // Set focus to the span element in order to scroll the browser to the position of the element.
        // Focusing the span with the mouseup event on the context menu
        // will trigger the textae-editor click event in the Chrome browser on Android.
        // This will trigger the body click event, which will deselect the span.
        // To prevent this, we will focus the span in the next event loop cycle.
        setTimeout(() => el.focus(), 0)
      }

      deselect() {
        super.deselect()

        const el = super.element

        // A dom does not exist when it is deleted.
        if (el) {
          el.classList.remove(SpanInstanceContainer_SELECTED)
        }
      }

      get heightIncludeDescendantGrids() {
        return this._gridHeightIncludeDescendantGrids + TEXT_HEIGHT + MARGIN_TOP
      }

      get widthOfGrid() {
        if (isTouchable) {
          const rectOfSpan = this.element.getBoundingClientRect()
          const rectOfTextBox =
            this.element.offsetParent.offsetParent.getBoundingClientRect()
          const left = rectOfSpan.left - rectOfTextBox.left

          // To fix the position of the toolbar, we use position: sticky.
          // On Android chrome, if an element is drawn at a position that is out of the device width,
          // the sticky position will be shifted upward by the width of the overhang.
          // To prevent this, the grid is not drawn outside the text box.
          const width = Math.min(rectOfSpan.width, rectOfTextBox.width - left)

          return round(width)
        } else {
          return round(this.element.getBoundingClientRect().width)
        }
      }

      get offsetCenterOfGrid() {
        return this._offsetLeft + this.widthOfGrid / 2
      }

      get clientTopOfGrid() {
        return (
          this.element.getBoundingClientRect().top -
          this._gridHeightIncludeDescendantGrids
        )
      }

      get offsetTopOfGrid() {
        // An element.offsetTop and element.offsetLeft does not work in the Firefox,
        // when much spans are loaded like http://pubannotation.org/docs/sourcedb/PMC/sourceid/1315279/divs/10/annotations.json.
        const offsetTop =
          this.element.getBoundingClientRect().top -
          this.element.offsetParent.offsetParent.getBoundingClientRect().top
        return offsetTop - this._gridHeightIncludeDescendantGrids
      }

      get offsetLeftOfGrid() {
        return this._offsetLeft
      }

      isGridInViewport(clientHeight, clientWidth) {
        return this._isGridInViewPort(clientHeight, clientWidth, 0)
      }

      isGridInDrawArea(clientHeight, clientWidth) {
        return this._isGridInViewPort(clientHeight, clientWidth, clientHeight)
      }

      _isGridInViewPort(clientHeight, clientWidth, margin) {
        const { top, left } = this.element.getBoundingClientRect()
        const gridHeightIncludeDescendantGrids =
          this._gridHeightIncludeDescendantGrids
        const gridBottom =
          top - gridHeightIncludeDescendantGrids + this.gridHeight
        const gridTop = top - gridHeightIncludeDescendantGrids

        return (
          0 - margin <= gridBottom &&
          gridTop <= clientHeight + margin &&
          left <= clientWidth
        )
      }

      get _contentHTML() {
        return `
      <span
        id="${this.id}"
        title="${this.title}"
        tabindex="0"
        class="${['textae-editor__span'].concat(this._styleClasses).join(' ')}"
        >
      </span>
    `
      }

      get _gridHeightIncludeDescendantGrids() {
        return getGridHeightIncludeDescendantGrids(this)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/StyleSpanInstance.js

    class StyleSpanInstance extends SpanInstance {
      constructor(
        editorID,
        editorHTMLElement,
        begin,
        end,
        spanInstanceContainer,
        style
      ) {
        super(
          editorID,
          editorHTMLElement,
          begin,
          end,
          spanInstanceContainer,
          style
        )
        this.styles = new Set([style])
      }

      get id() {
        return makeStyleSpanHTMLElementID(
          this._editorID,
          this._begin,
          this._end
        )
      }

      // Mark it not to be rendered as a span.
      get styleOnly() {
        return true
      }

      appendStyles(styles) {
        this.styles = new Set([...this.styles, ...styles])
      }

      get _contentHTML() {
        return `
      <span
        id="${this.id}"
        title="${this.title}"
        class="${this._styleClasses.join(' ')}"
        >
      </span>
    `
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/BlockSpanInstance/renderBackground.js

    /* harmony default export */ function renderBackground(parentElement, id) {
      const div = dohtml_default().create(`
    <div id="${id}" class="textae-editor__block-bg"></div>
  `)

      // Always add to the top of the annotation box to place it behind the grid.
      parentElement.insertAdjacentElement('afterbegin', div)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/BlockSpanInstance/setPosition.js

    /* harmony default export */ function setPosition(
      element,
      top,
      left,
      width,
      height
    ) {
      element.style.top = `${top}px`
      element.style.left = `${left}px`
      element.style.width = `${width}px`
      element.style.height = `${height}px`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/BlockSpanInstance/index.js

    // Leave a gap between the text and the block border.
    const gapBetweenText = 8
    class BlockSpanInstance extends SpanInstance {
      /**
       *
       * @param {import('../../createTextBox/TextBox').default} textBox
       */
      constructor(
        editorID,
        editorHTMLElement,
        begin,
        end,
        entityInstanceContainer,
        spanInstanceContainer,
        textBox
      ) {
        super(editorID, editorHTMLElement, begin, end, spanInstanceContainer)
        this._entityInstanceContainer = entityInstanceContainer
        this._textBox = textBox
      }

      // Utility to distinguish with otehr type spans.
      get isBlock() {
        return true
      }

      passesAllEntitiesTo(newSpan) {
        for (const entity of this.entities) {
          entity.span = newSpan
        }
      }

      get id() {
        return makeBlockSpanHTMLElementID(
          this._editorID,
          this._begin,
          this._end
        )
      }

      select() {
        super.select()

        const el = super.element
        el.classList.add(SpanInstanceContainer_SELECTED)

        this._backgroundElement.classList.add(SpanInstanceContainer_SELECTED)

        // Set focus to the span element in order to scroll the browser to the position of the element.
        el.focus()
      }

      deselect() {
        super.deselect()

        const el = super.element

        // A dom does not exist when it is deleted.
        if (el) {
          el.classList.remove(SpanInstanceContainer_SELECTED)
        }

        if (this._backgroundElement) {
          this._backgroundElement.classList.remove(
            SpanInstanceContainer_SELECTED
          )
        }
      }

      updateBackgroundPosition() {
        if (this.isGridRendered) {
          const height = this._height

          const clientRect = this.element.getBoundingClientRect()
          const offsetLeft =
            clientRect.left -
            this._textBox.boundingClientRect.left -
            gapBetweenText
          const width = clientRect.width + gapBetweenText

          setPosition(
            this._backgroundElement,
            this._offsetTop,
            offsetLeft,
            width,
            height
          )

          // The div height cannot be obtained at grid rendering time,
          // so set it at move.
          this.gridElement.style.height = `${height}px`
        }
      }

      renderElement() {
        super.renderElement()

        // Place the background in the annotation box
        // to shift the background up by half a line from the block span area.
        const annotationBox = getAnnotationBox(this._editorHTMLElement)
        renderBackground(annotationBox, this._backgroundId)
      }

      destroyElement() {
        super.destroyElement()
        this._backgroundElement.remove()
      }

      get heightIncludeDescendantGrids() {
        return super.gridHeight + 35
      }

      get widthOfGrid() {
        return 100
      }

      get offsetCenterOfGrid() {
        return this._textBox.boundingClientRect.width - 58
      }

      get offsetTopOfGrid() {
        return this._offsetTop
      }

      get clientBottomOfGrid() {
        return this._clientTop + this._height
      }

      get offsetBottomOfGrid() {
        return this._offsetTop + this._height
      }

      get offsetLeftOfGrid() {
        return this._textBox.boundingClientRect.width - 108
      }

      updateGridPosition() {
        super.updateGridPosition()

        if (this._entityToFocusOn) {
          // A block span has only one entity.
          this._entityToFocusOn.select()
          this._entityToFocusOn = null
        }
      }

      get isGridBeforePositioned() {
        return !this.gridElement.style.top
      }

      set entityToFocusOn(val) {
        this._entityToFocusOn = val
      }

      isGridInViewport(clientHeight) {
        return this._isGridInViewPort(clientHeight, 0)
      }

      isGridInDrawArea(clientHeight) {
        return this._isGridInViewPort(clientHeight, clientHeight)
      }

      get _height() {
        return this.element.getBoundingClientRect().height
      }

      get _offsetTop() {
        return this._clientTop - this._textBox.boundingClientRect.top
      }

      get _backgroundId() {
        return `bg_of_${this.id}`
      }

      get _backgroundElement() {
        return document.querySelector(`#${this._backgroundId}`)
      }

      _isGridInViewPort(clientHeight, margin) {
        return (
          0 - margin <= this._clientBottom &&
          this._clientTop <= clientHeight + margin
        )
      }

      // Shifting up half a line from the original block position.
      get _clientTop() {
        return this._shiftUpGrid(this.element.getBoundingClientRect().top)
      }

      get _clientBottom() {
        return this._shiftUpGrid(this.element.getBoundingClientRect().bottom)
      }

      _shiftUpGrid(y) {
        return y - this._textBox.lineHeight / 2 + 20
      }

      get _contentHTML() {
        return `<div id="${this.id}" class="textae-editor__block"></div>`
      }

      _createGridElement() {
        const el = super._createGridElement()
        el.classList.add('textae-editor__block-hit-area')
        el.dataset.id = this.id
        el.title = this.title
        return el
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/getBoundaryCrossingSpans.js

    /* harmony default export */ function getBoundaryCrossingSpans(
      spans,
      begin,
      end
    ) {
      return spans.filter(({ span }) => isBoundaryCrossing(begin, end, span))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/isBoundaryCrossingWithOtherSpans.js

    // A span its range is coross over with other spans are not able to rendered.
    // Because spans are renderd with span tag. Html tags can not be cross over.
    /* harmony default export */ function isBoundaryCrossingWithOtherSpans(
      spans,
      begin,
      end
    ) {
      console.assert(end !== undefined, 'end is necessary.')

      return (
        getBoundaryCrossingSpans(
          spans.map((span) => ({ span })),
          begin,
          end
        ).length > 0
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/rangeFrom.js

    /* harmony default export */ function rangeFrom(
      spanInstanceContainer,
      firstId,
      secondId
    ) {
      const first = spanInstanceContainer.get(firstId)
      const second = spanInstanceContainer.get(secondId)
      let left = first
      let right = second

      // switch if seconfId before firstId
      if (spanComparator(first, second) > 0) {
        left = second
        right = first
      }

      // When the parent-child span is selected, the child span will be on the right.
      // In this case, the end of the child span is to the left of the end of the parent span.
      return [...spanInstanceContainer.values()]
        .filter(
          (span) =>
            left.begin <= span.begin &&
            (span.end <= left.end || span.end <= right.end)
        )
        .map((span) => span.id)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/getCurrentMaxHeight.js

    /* harmony default export */ function getCurrentMaxHeight(spans) {
      const maxHeight = Math.max(
        ...spans.map((span) => span.heightIncludeDescendantGrids)
      )
      return maxHeight
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/SpanInstanceContainer/index.js

    class SpanInstanceContainer {
      /**
       *
       * @param {import('../createTextBox/TextBox').default} textBox
       */
      constructor(
        editorID,
        editorHTMLElement,
        emitter,
        entityContainer,
        textBox
      ) {
        this._editorID = editorID
        this._editorHTMLElement = editorHTMLElement
        this._emitter = emitter
        this._entityContainer = entityContainer
        this._textBox = textBox

        this._denotations = new Map()
        this._blocks = new Map()
        this._styles = new Map()
      }

      // expected span is like { "begin": 19, "end": 49 }
      add(newValue) {
        console.assert(newValue, 'span is necessary.')

        // When redoing, the newValue is instance of the BlockSpanInstance
        // or the DenotationSpan already.
        if (newValue instanceof BlockSpanInstance) {
          return this._addBlock(newValue)
        } else if (newValue instanceof DenotationSpanInstance) {
          return this._addDenotation(newValue)
        } else if (newValue.isBlock) {
          console.assert(
            !this.doesParentOrSameSpanExist(newValue.begin, newValue.end),
            `There are some parent spans of {begin: ${newValue.begin}, end: ${newValue.end}}.`
          )

          const blockSpan = new BlockSpanInstance(
            this._editorID,
            this._editorHTMLElement,
            newValue.begin,
            newValue.end,
            this._entityContainer,
            this,
            this._textBox
          )
          return this._addBlock(blockSpan)
        } else {
          console.assert(
            !this.hasDenotationSpan(newValue.begin, newValue.end),
            'There is already a span.'
          )
          const denotationSpan = new DenotationSpanInstance(
            this._editorID,
            this._editorHTMLElement,
            newValue.begin,
            newValue.end,
            this._entityContainer,
            this
          )
          return this._addDenotation(denotationSpan)
        }
      }

      // Does not draw the instance.
      // When loading for the first time, all instances will be loaded at once.
      // The drawing of the instance is performed at a different time.
      addSource(source, type) {
        for (const element of source) {
          this._addInstanceFromElement(type, element)
        }

        this._updateSpanTree()
      }

      hasDenotationSpan(begin, end) {
        const spanID = makeDenotationSpanHTMLElementID(
          this._editorID,
          begin,
          end
        )
        return this._denotations.has(spanID)
      }

      hasBlockSpan(begin, end) {
        const spanID = makeBlockSpanHTMLElementID(this._editorID, begin, end)
        return this._blocks.has(spanID)
      }

      hasBlockSpanBetween(begin, end, option = {}) {
        for (const blockSpan of this._blocks.values()) {
          if (
            begin <= blockSpan.begin &&
            blockSpan.end <= end &&
            option &&
            blockSpan.id !== option.excluded
          ) {
            return true
          }
        }

        return false
      }

      hasParentOf(begin, end, spanID) {
        for (const parent of this.all) {
          if (parent.id === spanID) {
            continue
          }

          if (parent.begin <= begin && end <= parent.end) {
            return true
          }
        }

        return false
      }

      /**
       *
       * @returns {import('./SpanInstance').SpanInstance}
       */
      get(spanID) {
        if (this._denotations.has(spanID)) {
          return this._denotations.get(spanID)
        } else if (this._blocks.has(spanID)) {
          return this._blocks.get(spanID)
        } else {
          // Returns a typesetting only.
          return this._styles.get(spanID)
        }
      }

      getStyle(spanID) {
        if (this._styles.has(spanID)) {
          return this._styles.get(spanID).styles
        } else {
          return new Set()
        }
      }

      getDenotationSpan(spanID) {
        if (this._denotations.has(spanID)) {
          return this._denotations.get(spanID)
        }
      }

      rangeDenotationSpan(firstID, secondID) {
        return rangeFrom(this._denotations, firstID, secondID)
      }

      rangeBlockSpan(firstID, secondID) {
        return rangeFrom(this._blocks, firstID, secondID)
      }

      get topLevel() {
        return this.all
          .filter((span) => span.parent === this)
          .sort(spanComparator)
      }

      get children() {
        return this.topLevel
      }

      clear() {
        this._denotations.clear()
        this._blocks.clear()
        this._styles.clear()
      }

      remove(id) {
        const blockSpan = this._blocks.get(id)
        if (blockSpan) {
          this._removeBlock(blockSpan)
          this._emitter.emit(
            `textae-event.annotation-data.span.remove`,
            blockSpan
          )
          return
        }

        const denotationSpan = this._denotations.get(id)
        if (denotationSpan) {
          this._removeDenotation(denotationSpan)
          this._emitter.emit(
            `textae-event.annotation-data.span.remove`,
            denotationSpan
          )
          return
        }

        console.assert(false, `There is no target for remove for ${id}!`)
      }

      // Since moving a span is deleting and adding span tags,
      // we will delete and add the instance as well.
      moveDenotationSpan(id, begin, end) {
        console.assert(
          id !== makeDenotationSpanHTMLElementID(this._editorID, begin, end),
          `Do not need move span:  ${id} ${begin} ${end}`
        )

        const oldSpan = this._denotations.get(id)
        console.assert(oldSpan, `There is no target for move for ${id}!`)

        this._removeDenotation(oldSpan)

        const newOne = new DenotationSpanInstance(
          this._editorID,
          this._editorHTMLElement,
          begin,
          end,
          this._entityContainer,
          this
        )
        this._addDenotation(newOne, oldSpan)
        this._emitter.emit('textae-event.annotation-data.span.move')

        return {
          begin: oldSpan.begin,
          end: oldSpan.end,
          id: newOne.id
        }
      }

      moveBlockSpan(id, begin, end) {
        console.assert(
          id !== makeBlockSpanHTMLElementID(this._editorID, begin, end),
          `Do not need move span:  ${id} ${begin} ${end}`
        )

        const oldSpan = this._blocks.get(id)
        this._removeBlock(oldSpan)

        const newOne = new BlockSpanInstance(
          this._editorID,
          this._editorHTMLElement,
          begin,
          end,
          this._entityContainer,
          this,
          this._textBox
        )
        this._addBlock(newOne, oldSpan)
        this._emitter.emit('textae-event.annotation-data.span.move')

        return {
          begin: oldSpan.begin,
          end: oldSpan.end,
          id: newOne.id
        }
      }

      _addDenotation(denotationSpan, oldSpan = null) {
        this._addSpan(this._denotations, denotationSpan, oldSpan)
        this._emitter.emit(
          `textae-event.annotation-data.span.add`,
          denotationSpan
        )

        return denotationSpan
      }

      _addBlock(blockSpan, oldSpan = null) {
        this._addSpan(this._blocks, blockSpan, oldSpan)
        this._emitter.emit(`textae-event.annotation-data.span.add`, blockSpan)

        return blockSpan
      }

      _addSpan(container, span, oldSpan = null) {
        container.set(span.id, span)
        this._updateSpanTree()

        if (oldSpan) {
          // Span.entities depends on the property of the entity.
          // Span DOM element is rendered by 'span.add' event.
          // We need to update the span ID of the entity before 'span.add' event.
          oldSpan.passesAllEntitiesTo(span)
        }

        span.render()

        const { clientHeight, clientWidth } = document.documentElement
        span.drawGrid(clientHeight, clientWidth)
      }

      _removeDenotation(span) {
        this._denotations.delete(span.id)
        span.erase()
        // When changing the length of a span, the span is erased and rendered again.
        // When the span is erased, the span erase event fires and the position calculations for all annotations are performed.
        // The event is not fired in this function.
      }

      _removeBlock(span) {
        this._blocks.delete(span.id)
        span.erase()
        // When changing the length of a span, the span is erased and rendered again.
        // When the span is erased, the span erase event fires and the position calculations for all annotations are performed.
        // The event is not fired in this function.
      }

      isBoundaryCrossingWithOtherSpans(begin, end) {
        return isBoundaryCrossingWithOtherSpans(this.all, begin, end)
      }

      doesParentOrSameSpanExist(begin, end) {
        const isParent = (span) => span.begin <= begin && end <= span.end

        return (
          [...this._denotations.values()].some(isParent) ||
          [...this._blocks.values()].some(isParent) ||
          [...this._styles.values()].some(isParent)
        )
      }

      get all() {
        const styleOnlySpans = [...this._styles.values()].filter(
          (s) => !this._denotations.has(s.id)
        )
        return [...this._blocks.values()]
          .concat([...this._denotations.values()])
          .concat(styleOnlySpans)
      }

      get selectedItems() {
        return [...this._blocks.values()]
          .concat([...this._denotations.values()])
          .filter(({ isSelected }) => isSelected)
      }

      /**
       * @returns {import('./DenotationSpanInstance').DenotationSpanInstance[]}
       */
      get allDenotationSpans() {
        return [...this._denotations.values()]
      }

      get allBlockSpans() {
        return [...this._blocks.values()]
      }

      // It has a common interface with the span instance so that it can be the parent of the span instance.
      get begin() {
        return 0
      }

      // It has a common interface with the span instance so that it can be the parent of the span instance
      get element() {
        return this._editorHTMLElement.querySelector(`.textae-editor__text-box`)
      }

      _updateSpanTree() {
        // Register a typesetting in the span tree to put it in the span rendering flow.
        updateSpanTree(this, this.all)
      }

      _addInstanceFromElement(type, denotation) {
        switch (type) {
          case 'denotation': {
            const objectSpan = new DenotationSpanInstance(
              this._editorID,
              this._editorHTMLElement,
              denotation.span.begin,
              denotation.span.end,
              this._entityContainer,
              this
            )

            if (!this._denotations.has(objectSpan.id)) {
              this._denotations.set(objectSpan.id, objectSpan)
            }
            break
          }
          case 'block': {
            const blockSpan = new BlockSpanInstance(
              this._editorID,
              this._editorHTMLElement,
              denotation.span.begin,
              denotation.span.end,
              this._entityContainer,
              this,
              this._textBox
            )

            if (!this._blocks.has(blockSpan.id)) {
              this._blocks.set(blockSpan.id, blockSpan)
            }
            break
          }
          case 'typesetting': {
            const styleSpan = new StyleSpanInstance(
              this._editorID,
              this._editorHTMLElement,
              denotation.span.begin,
              denotation.span.end,
              this,
              denotation.style
            )

            // Merge multiple styles for the same range.
            if (this._styles.has(styleSpan.id)) {
              this._styles.get(styleSpan.id).appendStyles(styleSpan.styles)
            } else {
              this._styles.set(styleSpan.id, styleSpan)
            }

            break
          }
          default:
            throw `${type} is unknown type span!`
        }
      }

      arrangeDenotationEntityPosition() {
        for (const span of this.allDenotationSpans) {
          span.updateGridPosition()
        }
      }

      arrangeBlockEntityPosition() {
        for (const span of this.allBlockSpans) {
          span.updateGridPosition()
        }
      }

      arrangeBackgroundOfBlockSpanPosition() {
        for (const span of this.allBlockSpans) {
          span.updateBackgroundPosition()
        }
      }

      get maxHeight() {
        const spans = [...this._blocks.values()].concat([
          ...this._denotations.values()
        ])

        if (spans.length) {
          return getCurrentMaxHeight(spans)
        } else {
          return null
        }
      }
    }

    // EXTERNAL MODULE: ./node_modules/lodash.escape/index.js
    var lodash_escape = __webpack_require__(8686)
    var lodash_escape_default =
      /*#__PURE__*/ __webpack_require__.n(lodash_escape) // CONCATENATED MODULE: ./src/lib/component/anemone.js
    // Escape template literals.
    // For example:
    //  anemone`<div>${'&'}</div>` === '<div>&amp;</div>'
    //
    // If you insert a function, function is called and the result is not escaped.
    // For example:
    //  anemone`<div>${() => '&'}</div>` === '<div>&</div>'
    function anemone(strings) {
      const [first, ...rest] = strings

      let out = first
      for (const value of [...arguments].slice(1)) {
        out = `${out}${escapeUnlessFunction(value)}${rest.shift()}`
      }

      return out
    }

    function escapeUnlessFunction(value) {
      if (Array.isArray(value) && typeof value.at(0) === 'function') {
        return value.map((v) => v()).join('')
      }

      if (typeof value === 'function') {
        const result = value()

        if (Array.isArray(result)) {
          return result.join('')
        }

        return result
      }

      return lodash_escape_default()(value)
    } // CONCATENATED MODULE: ./src/lib/isURI.js

    /* harmony default export */ function isURI(type) {
      return type.trim().startsWith('http')
    } // CONCATENATED MODULE: ./src/lib/Editor/getMatchPrefix.js

    /* harmony default export */ function getMatchPrefix(namespace, type) {
      const namespaces = namespace.all
      const matchs = namespaces
        .filter((namespace) => namespace.prefix !== '_base')
        .filter((namespace) => {
          return type.indexOf(`${namespace.prefix}:`) === 0
        })
      if (matchs.length === 1) return matchs[0]
      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/getUrlMatches.js

    /* harmony default export */ function getUrlMatches(type) {
      // The regular-expression to parse URL.
      // See detail:
      // http://someweblog.com/url-regular-expression-javascript-link-shortener/
      const urlRegex =
        /\(?(?:(http|https|ftp):\/\/)?(?:((?:[^\W\s]|\.|-|[:]{1})+)@{1})?((?:www.)?(?:[^\W\s]|\.|-)+[.][^\W\s]{2,4}|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?::(\d*))?([/]?[^\s?]*[/]{1})*(?:\/?([^\s\n?[\]{}#]*(?:(?=\.)){1}|[^\s\n?[\]{}.#]*)?([.]{1}[^\s?#]*)?)?(?:\?{1}([^\s\n#[\]]*))?([#][^\s\n]*)?\)?/gi
      return urlRegex.exec(type)
    } // CONCATENATED MODULE: ./src/lib/Editor/getDisplayName/getDisplayNameFromUri.js

    // Display short name for URL(http or https);
    /* harmony default export */ function getDisplayNameFromUri(type) {
      // For tunning, search the scheme before execute a regular-expression.
      if (isURI(type)) {
        const matches = getUrlMatches(type)

        if (matches) {
          // Order to dispaly.
          // 1. The anchor without #.
          if (matches[9]) return matches[9].slice(1)

          // 2. The file name with the extention.
          if (matches[6]) return matches[6] + (matches[7] || '')

          // 3. The last directory name.
          // Exclude slash only. cf. http://hoge.com/
          if (matches[5] && matches[5].length > 1)
            return matches[5]
              .split('/')
              .filter((s) => {
                return s !== ''
              })
              .pop()

          // 4. The domain name.
          return matches[3]
        }
      }
      return type
    } // CONCATENATED MODULE: ./src/lib/Editor/getDisplayName/index.js

    /* harmony default export */ function getDisplayName(
      namespace,
      value,
      displayName
    ) {
      // When a type id has label attrdute.
      if (displayName) {
        return displayName
      }

      // When a type id is uri
      if (isURI(value)) {
        return getDisplayNameFromUri(value)
      }

      const match = getMatchPrefix(namespace, value)
      if (match) {
        return value.replace(`${match.prefix}:`, '')
      }

      return value
    } // CONCATENATED MODULE: ./src/lib/Editor/hexToRGBA.js

    /* harmony default export */ function hexToRGBA(hex, alpha) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
      console.assert(result, `${hex} is not a hexadecimal color values!`)

      return `rgba(${parseInt(result[1], 16)}, ${parseInt(
        result[2],
        16
      )}, ${parseInt(result[3], 16)}, ${alpha})`
    } // CONCATENATED MODULE: ./src/lib/Editor/getLabelBackgroundColor.js

    /* harmony default export */ function getLabelBackgroundColor() {
      return hexToRGBA('#FFFFFF', 0.6)
    } // CONCATENATED MODULE: ./src/lib/Editor/getURI.js

    /* harmony default export */ function getURI(namespace, value, uri) {
      if (isURI(value)) {
        return value
      }

      if (uri) {
        return uri
      }

      if (namespace.some) {
        const match = getMatchPrefix(namespace, value)

        if (match) {
          return `${match.uri}${value.replace(`${match.prefix}:`, '')}`
        }

        const base = namespace.all.find(
          (namespace) => namespace.prefix === '_base'
        )
        if (base) {
          return `${base.uri}${value}`
        }
      }

      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/toAnchorElement.js

    /* harmony default export */ function toAnchorElement(displayName, href) {
      return () =>
        href
          ? anemone`<a target="_blank" href="${href}">${displayName}</a>`
          : anemone`${displayName}`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AttributeInstanceContainer/AttributeInstance.js

    class AttributeInstance {
      // Expected an attribute like {id: "A1", subj: "T1", pred: "example_predicate_1", obj: "attr1"}.
      /**
       *
       * @param {import('../DefinitionContainer/index.js').default} definitionContainer
       */
      constructor(
        { id, subj, pred, obj },
        entityContainer,
        relationContainer,
        namespace,
        definitionContainer,
        mediaDictionary
      ) {
        this.id = id
        this.subj = subj
        this.pred = pred
        this._obj = obj
        this._entityContainer = entityContainer
        this._relationContainer = relationContainer
        this._namespace = namespace
        this._definitionContainer = definitionContainer
        this._mediaDictionary = mediaDictionary

        // If the extension cannot be used to determine whether the image is an image or not,
        // the Content-Type header is acquired to determine whether the image is an image or not.
        if (this.#valueType === 'string' && !this.#hasImageExtension) {
          this._mediaDictionary
            .acquireContentTypeOf(this.#href)
            .then((isImage) => {
              if (isImage) {
                this.updateElement()
              }
            })
        }
      }

      get obj() {
        return this._obj
      }

      set obj(value) {
        if (this.#valueType === 'numeric') {
          this._obj = parseFloat(value)
        } else {
          this._obj = value
        }
      }

      get subjectInstance() {
        return (
          this._entityContainer.get(this.subj) ||
          this._relationContainer.get(this.subj)
        )
      }

      get externalFormat() {
        return {
          id: this.id,
          subj: this.subj,
          pred: this.pred,
          obj: this._obj
        }
      }

      equalsTo(pred, obj) {
        // If the attribute is a numeric type,
        // then the type of obj is numeric.
        // Cast obj to a string to compare.
        return this.pred === pred && String(this._obj) === obj
      }

      updateElement() {
        this.subjectInstance.updateElement()
      }

      clarifyLabelIn(parentElement) {
        parentElement.querySelector(
          `[data-pred="${this.pred}"][data-obj="${this.obj}"] .textae-editor__signboard__attribute-label`
        ).style.backgroundColor = hexToRGBA(this.#color, 1)
      }

      declarifyLabelIn(parentElement) {
        parentElement.querySelector(
          `[data-pred="${this.pred}"][data-obj="${this.obj}"] .textae-editor__signboard__attribute-label`
        ).style.backgroundColor = getLabelBackgroundColor()
      }

      get contentHTML() {
        return () => anemone`
      <div
        class="textae-editor__signboard__attribute"
        title="${this.#title}"
        data-pred="${this.pred}"
        data-obj="${this.obj}"
        style="background-color: ${hexToRGBA(this.#color, 0.4)}; height: ${
          this.height
        }px;"
        >
        <span
          class="textae-editor__signboard__attribute-label"
          style="background-color: ${getLabelBackgroundColor()};"
          >
          ${this.#labelOrMedia}
        </span>
      </div>
      `
      }

      get height() {
        if (this._definitionContainer.get(this.pred).mediaHeight) {
          return this._definitionContainer.get(this.pred).mediaHeight
        } else {
          return 18
        }
      }

      get #title() {
        return `[${this.id}] pred: ${this.pred}, value: ${this._obj}`
      }

      get #labelOrMedia() {
        if (this.#isMedia) {
          return () => `<img src="${this.obj}" height="${this.height}" >`
        } else {
          return toAnchorElement(this.#displayName, this.#href)
        }
      }

      get #isMedia() {
        return (
          this.#valueType === 'string' &&
          (this.#hasImageExtension ||
            this._mediaDictionary.hasImageContentTypeOf(this.#href))
        )
      }

      get #hasImageExtension() {
        return /\.(jpg|png|gif)$/.test(this.#href)
      }

      get #displayName() {
        return getDisplayName(
          this._namespace,
          typeof this._obj === 'string' ? this._obj : '',
          this._definitionContainer.getDisplayName(this.pred, this._obj)
        )
      }

      get #href() {
        return getURI(
          this._namespace,
          typeof this._obj === 'string' ? this._obj : ''
        )
      }

      get #color() {
        return (
          this._definitionContainer.getColor(this.pred, this._obj) ||
          this.subjectInstance.color
        )
      }

      get #valueType() {
        return this._definitionContainer.get(this.pred).valueType
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/IdIssueContainer/index.js

    class IdIssueContainer extends InstanceContainer {
      constructor(emitter, name, prefixFunc) {
        super(emitter, name)

        this._prefixFunc = prefixFunc
      }

      addSource(source, type) {
        const collection = source.map((r) => this._toInstance(r, type))

        // Move instances without id behind others, to prevent id duplication generated and exists.
        collection.sort((a, b) => {
          if (!a.id) return 1
          if (!b.id) return -1
          if (a.id < b.id) return -1
          if (a.id > b.id) return 1

          return 0
        })

        for (const instance of collection) {
          super._addToContainer(this._assignID(instance))
        }
      }

      add(instance) {
        return super.add(this._assignID(instance))
      }

      _assignID(instance) {
        if (!instance.id) {
          instance.id = this._generateNextID(instance)
        }

        return instance
      }

      _generateNextID(instance) {
        const prefix = this._prefixFunc(instance)

        const wellFormattedIDs = new Set()
        for (const id of this._container.keys()) {
          // The format of id is a prefix and a number, for example 'T1'.
          if (new RegExp(`^${prefix}\\d+$`).test(id)) {
            wellFormattedIDs.add(id.slice(1))
          }
        }

        // The Math.max return -Infinity when the second argument array is empty.
        if (wellFormattedIDs.size === 0) {
          return `${prefix}1`
        }

        const max = Math.max(...wellFormattedIDs.values())
        return `${prefix}${max + 1}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AttributeInstanceContainer/MediaDictionary.js

    // The browser cache is not available until the HTTP request is returned.
    // To make only one request for a single URL, have an application-level cache.
    class MediaDictionary {
      constructor() {
        this._cache = new Map()
      }

      acquireContentTypeOf(url) {
        if (!url) {
          return Promise.resolve(false)
        }

        if (this._cache.has(url)) {
          return this._cache.get(url)
        }

        // Use GET method.
        // Some domains do not have CORS settings in the OPTIONS method.
        // For example, lifesciencedb.jp.
        const request = new Request(url, {
          method: 'get',
          mode: 'cors',
          cache: 'force-cache'
        })

        const promiseOfResult = new Promise((resolve) => {
          fetch(request)
            .then((response) => {
              const value = /image\/(jpg|png|gif)$/.test(
                response.headers.get('content-type')
              )

              // Set the result to the value property so that the result can be referenced from synchronous functions.
              // See: https://ourcodeworld.com/articles/read/317/how-to-check-if-a-javascript-promise-has-been-fulfilled-rejected-or-resolved
              promiseOfResult.value = value

              resolve(value)
            })
            .catch((e) => {
              console.warn(e.message, url)
              resolve(false)
            })
        })

        // Cache the promise of results, not the results themselves.
        // Caching the result causes an immediate redraw at the caller;
        // it does not wait for the HTTP response to arrive.
        this._cache.set(url, promiseOfResult)

        return promiseOfResult
      }

      hasImageContentTypeOf(url) {
        if (!url) {
          return false
        }

        return this._cache.get(url).value
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AttributeInstanceContainer/index.js

    class AttributeInstanceContainer extends IdIssueContainer {
      constructor(
        emitter,
        entityContainer,
        relationContainer,
        namespace,
        definitionContainer
      ) {
        super(emitter, 'attribute', () => 'A')

        this._entityContainer = entityContainer
        this._relationContainer = relationContainer
        this._namespace = namespace
        this._definitionContainer = definitionContainer
        this._mediaDictionary = new MediaDictionary()
      }

      _toInstance(attribute) {
        return new AttributeInstance(
          attribute,
          this._entityContainer,
          this._relationContainer,
          this._namespace,
          this._definitionContainer,
          this._mediaDictionary
        )
      }

      add(newValue) {
        // When redoing, the newValue is instance of the AttributeInstance already.
        newValue =
          newValue instanceof AttributeInstance
            ? newValue
            : this._toInstance(newValue)

        super.add(newValue)

        newValue.updateElement()

        return newValue
      }

      change(id, newPred, newObj) {
        const instance = this.get(id)

        if (newPred) {
          instance.pred = newPred
        }

        if (newObj) {
          instance.obj = newObj
        }

        return instance
      }

      remove(id) {
        const instance = super.remove(id)

        console.assert(instance, `There are no attribute ${id} to delete!`)

        instance.updateElement()
      }

      getSameDefinitionsAttributes(pred) {
        return this.all.filter((attr) => attr.pred === pred)
      }

      getSameAttributes(pred, obj) {
        return this.all.filter((a) => a.equalsTo(pred, obj))
      }

      /**
       *
       * @param {string} subj
       * @returns {AttributeInstance[]}
       */
      getAttributesFor(subj) {
        return this.all
          .filter((a) => a.subj === subj)
          .sort((a, b) =>
            this._definitionContainer.attributeCompareFunction(a, b)
          )
      }
    } // CONCATENATED MODULE: ./src/lib/TypeValues.js

    class TypeValues {
      constructor(typeName, attributes = []) {
        this._typeName = typeName
        this._attributes = attributes
      }

      get typeName() {
        return this._typeName
      }

      get attributes() {
        return this._attributes
      }

      // This property is used to copy to the system clipboard.
      get externalFormat() {
        return {
          obj: this._typeName,
          attributes: this._attributes.map(
            ({ externalFormat }) => externalFormat
          )
        }
      }

      isSameType(typeName, attributes = null) {
        if (attributes) {
          return (
            this.typeName === typeName && this._hasSameAttributes(attributes)
          )
        }

        return this.typeName === typeName
      }

      hasSpecificPredicateAttribute(pred) {
        return this.attributes.some((a) => a.pred === pred)
      }

      _hasSameAttributes(newAttributes) {
        if (newAttributes.length != this.attributes.length) {
          return false
        }

        const clone = [...newAttributes]
        for (const attribute of this.attributes) {
          const index = clone.findIndex(
            (a) => a.pred === attribute.pred && a.obj === String(attribute.obj)
          )
          if (index === -1) {
            return false
          }
          clone.splice(index, 1)
        }

        if (clone.length === 0) {
          return true
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/updatePath.js

    /* harmony default export */ function updatePath(
      path,
      curveAlgorithm,
      color,
      isBold
    ) {
      path.setAttribute('d', curveAlgorithm.pathCommands)

      path.setAttribute('style', `stroke: ${color};`)

      if (isBold) {
        path.classList.add('textae-editor__relation--isBold')
      } else {
        path.classList.remove('textae-editor__relation--isBold')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/NS.js

    const NS = {
      SVG: 'http://www.w3.org/2000/svg'
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/MarkerHeight.js

    const MarkerHeight = 6 // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/createSourceBollard.js

    /* harmony default export */ function createSourceBollard() {
      const bollard = document.createElementNS(NS.SVG, 'polygon')
      bollard.setAttribute(
        'points',
        `-4 ${MarkerHeight}, 4 ${MarkerHeight}, 0 0`
      )

      return bollard
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/createTargetBollard.js

    /* harmony default export */ function createTargetBollard() {
      const bollard = document.createElementNS(NS.SVG, 'polygon')
      bollard.setAttribute('points', `-4 0, 4 0, 0 ${MarkerHeight}`)

      return bollard
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/createPath.js

    /**
     *
     * @returns {SVGGraphicsElement} path
     */
    /* harmony default export */ function createPath() {
      const path = document.createElementNS(NS.SVG, 'path')
      path.classList.add('textae-editor__relation')
      return path
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/moveJetty.js

    /**
     *
     * @param {Element} jetty
     * @param {number} x
     * @param {number} y
     * @param {import('../../../../../EntityInstance').default} entity
     */
    /* harmony default export */ function moveJetty(jetty, x, y, entity) {
      jetty.setAttribute(
        'points',
        `${x} ${y + MarkerHeight}, ${entity.offsetCenter} ${
          y + MarkerHeight
        }, ${entity.offsetCenter} ${entity.offsetTop}`
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/createJetty.js

    /* harmony default export */ function createJetty(x, y, entity) {
      const jetty = document.createElementNS(NS.SVG, 'polyline')

      moveJetty(jetty, x, y, entity)

      return jetty
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/CurveAlgorithm.js

    class CurveAlgorithm {
      /**
       * @param {import('./StartAndEnd').startAndEnd} startAndEnd
       * @param {boolean} alignSourceBollards
       * @param {boolean} alignTargetBollards
       * @param {number} clientTopOfContainer
       * @param {number} column
       */
      constructor(
        startAndEnd,
        alignSourceBollards,
        alignTargetBollards,
        controlBarHeight,
        clientTopOfContainer
      ) {
        this._controlY =
          startAndEnd.offsetTop -
          startAndEnd.horizontalDistance / 4 -
          20 +
          (alignSourceBollards && alignTargetBollards ? 3 : 0)
        this._startAndEnd = startAndEnd
        this._controlBarHeight = controlBarHeight
        this._clientTopOfContainer = clientTopOfContainer

        this._virtualEntityWidth = 100
      }

      get sourceX() {
        return this._startAndEnd.start.x
      }
      get targetX() {
        return this._startAndEnd.end.x
      }

      get sourceY() {
        return this._startAndEnd.start.y - MarkerHeight
      }
      get targetY() {
        return this._startAndEnd.end.y - MarkerHeight
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
            C ${this._sourceControlX} ${this._controlY}, ${this._targetControlX} ${this._controlY}, ${this.targetX} ${this.targetY}`
      }

      get transformDefinitionsForSourceTriangle() {
        return `translate(${this.sourceX}, ${this.sourceY})`
      }

      get transformDefinitionsForTargetTriangle() {
        return `translate(${this.targetX}, ${this.targetY})`
      }

      getTForY(y) {
        const sample = 20

        // https://ja.javascript.info/bezier-curve
        // (1−t)3P1 + 3(1−t)2tP2 +3(1−t)t2P3 + t3P4
        return [...Array(sample).keys()]
          .map((i) => (i * 1) / sample)
          .find((t) => {
            const labelY =
              Math.pow(1 - t, 3) * this.sourceY +
              3 * Math.pow(1 - t, 2) * t * this._controlY +
              3 * (1 - t) * Math.pow(t, 2) * this._controlY +
              Math.pow(t, 3) * this.targetY
            return Math.abs(labelY - y) < 1
          })
      }

      getXOnT(_t) {
        const {
          sourceX,
          targetX,
          _sourceControlX: sourceControlX,
          _targetControlX: targetControlX
        } = this

        return (
          Math.pow(1 - _t, 3) * sourceX +
          3 * Math.pow(1 - _t, 2) * _t * sourceControlX +
          3 * (1 - _t) * Math.pow(_t, 2) * targetControlX +
          Math.pow(_t, 3) * targetX
        )
      }

      get _sourceControlX() {
        return this._startAndEnd.start.x
      }

      get _targetControlX() {
        return this._startAndEnd.end.x
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/BentOnTargetCurveAlgorithm.js

    class BentOnTargetCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return true
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
              C ${this._sourceControlX} ${this._controlY}, ${this._targetControlX} ${this._controlY}, ${this._junctionPointX} ${this._junctionPointY}
              Q ${this.targetX} ${this._additionalControlY}, ${this.targetX} ${this.targetY}`
      }

      getTForY(y) {
        const sample = 20

        // https://ja.javascript.info/bezier-curve
        // (1−t)3P1 + 3(1−t)2tP2 +3(1−t)t2P3 + t3P4
        return [...Array(sample).keys()]
          .map((i) => (i * 1) / sample)
          .find((t) => {
            const labelY =
              Math.pow(1 - t, 3) * this.sourceY +
              3 * Math.pow(1 - t, 2) * t * this._controlY +
              3 * (1 - t) * Math.pow(t, 2) * this._controlY +
              Math.pow(t, 3) * this._junctionPointY
            return Math.abs(labelY - y) < 1
          })
      }

      get _additionalControlY() {
        return this.sourceY * 0.3 + this.targetY * 0.7
      }

      get _junctionPointX() {
        return this._targetControlX * 0.25 + this.targetX * 0.75
      }

      get _junctionPointY() {
        return this._controlY * 0.25 + this._additionalControlY * 0.75
      }

      get _targetControlX() {
        return (
          this._startAndEnd.end.x +
          (this._startAndEnd.isPointingToRight ? 150 : -150)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/BentOnSourceCurveAlgorithm.js

    class BentOnSourceCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return true
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
              Q ${this.sourceX} ${this._additionalControlY}, ${this._junctionPointX} ${this._junctionPointY}
              C ${this._sourceControlX} ${this._controlY}, ${this._targetControlX} ${this._controlY}, ${this.targetX} ${this.targetY}`
      }

      getTForY(y) {
        const sample = 20

        // https://ja.javascript.info/bezier-curve
        // (1−t)3P1 + 3(1−t)2tP2 +3(1−t)t2P3 + t3P4
        return [...Array(sample).keys()]
          .map((i) => (i * 1) / sample)
          .find((t) => {
            const labelY =
              Math.pow(1 - t, 3) * this._junctionPointY +
              3 * Math.pow(1 - t, 2) * t * this._controlY +
              3 * (1 - t) * Math.pow(t, 2) * this._controlY +
              Math.pow(t, 3) * this.targetY

            return Math.abs(labelY - y) < 1
          })
      }

      get _additionalControlY() {
        return this.sourceY * 0.7 + this.targetY * 0.3
      }

      get _junctionPointX() {
        return this._sourceControlX * 0.25 + this.sourceX * 0.75
      }

      get _junctionPointY() {
        return this._controlY * 0.25 + this._additionalControlY * 0.75
      }

      get _sourceControlX() {
        return (
          this._startAndEnd.start.x +
          (this._startAndEnd.isPointingToRight ? 150 : -150)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/PointingDownCurveAlgorithm.js

    class PointingDownCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }
      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY + MarkerHeight}
      C ${this._sourceControlX} ${
        this.sourceY + Math.abs(this.targetY - this.sourceY) / 3
      }, ${this._targetControlX} ${
        this.targetY - Math.abs(this.targetY - this.sourceY) / 3
      }, ${this.targetX} ${this.targetY}`
      }

      get transformDefinitionsForSourceTriangle() {
        return `rotate(180, ${this.sourceX}, ${this.sourceY + 3}) translate(${
          this.sourceX
        }, ${this.sourceY})`
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        return this._controlBarHeight - this._clientTopOfContainer
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/PointingUpCurveAlgorithm.js

    class PointingUpCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get pathCommands() {
        return `M ${this.sourceX}, ${this.sourceY}
      C ${this._sourceControlX} ${
        this.sourceY - Math.abs(this.targetY - this.sourceY) / 3
      }, ${this._targetControlX} ${
        this.targetY + Math.abs(this.targetY - this.sourceY) / 3
      }, ${this.targetX} ${this.targetY + MarkerHeight}`
      }

      get transformDefinitionsForTargetTriangle() {
        return ` rotate(180, ${this.targetX}, ${this.targetY + 3}) translate(${
          this.targetX
        }, ${this.targetY})`
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        return this._controlBarHeight - this._clientTopOfContainer
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/ArchedCurveAlgorithm.js

    class ArchedCurveAlgorithm extends CurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return true
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/StartAndEnd.js

    class StartAndEnd_startAndEnd {
      /**
       *
       * @param {import('../../../../../../../EntityInstance').default} sourceEntity
       * @param {import('../../../../../../../EntityInstance').default} targetEntity
       * @returns
       */
      constructor(relation, alignSourceBollards, alignTargetBollards) {
        this._relation = relation
        this._sourceEntity = relation.sourceEntity
        this._targetEntity = relation.targetEntity

        const sourceY =
          this._sourceEntity.offsetTop - (alignSourceBollards ? 3 : 0)
        const targetY =
          this._targetEntity.offsetTop - (alignTargetBollards ? 3 : 0)

        const sourceAnchorPosition =
          this._sourceEntity.getSourceAnchorPosition(alignSourceBollards)
        const targetAnchorPosition =
          this._targetEntity.getTargetAnchorPosition(alignTargetBollards)

        if (
          this._sourceEntity.offsetCenter === this._targetEntity.offsetCenter
        ) {
          this._start = {
            y: sourceY,
            x: this._sourceEntity.offsetCenter
          }
          this._end = {
            y: targetY,
            x: this._targetEntity.offsetCenter
          }
          return
        }

        if (sourceY < targetY) {
          const sourceAnchor = this.isPointingToRight ? 'right' : 'left'
          const targetAnchor =
            sourceAnchorPosition[sourceAnchor] < this._targetEntity.offsetCenter
              ? 'left'
              : 'right'

          this._start = {
            y: sourceY,
            x: sourceAnchorPosition[sourceAnchor]
          }
          this._end = {
            y: targetY,
            x: targetAnchorPosition[targetAnchor]
          }
          return
        } else if (sourceY > targetY) {
          const targetAnchor = this.isPointingToRight ? 'left' : 'right'
          const sourceAnchor =
            targetAnchorPosition[targetAnchor] < this._sourceEntity.offsetCenter
              ? 'left'
              : 'right'

          this._start = {
            y: sourceY,
            x: sourceAnchorPosition[sourceAnchor]
          }
          this._end = {
            y: targetY,
            x: targetAnchorPosition[targetAnchor]
          }
          return
        } else {
          // When the source and target entities have the same height
          // Prevent source and target X coordinates from being swapped.
          if (this.isPointingToRight) {
            const targetAnchor =
              sourceAnchorPosition.right < targetAnchorPosition.left
                ? 'left'
                : 'right'

            this._start = {
              y: sourceY,
              x: sourceAnchorPosition.right
            }
            this._end = {
              y: targetY,
              x: targetAnchorPosition[targetAnchor]
            }
            return
          } else {
            const targetAnchor =
              sourceAnchorPosition.left < targetAnchorPosition.right
                ? 'left'
                : 'right'

            this._start = {
              y: sourceY,
              x: sourceAnchorPosition.left
            }
            this._end = {
              y: targetY,
              x: targetAnchorPosition[targetAnchor]
            }
            return
          }
        }
      }

      get start() {
        return this._start
      }

      get end() {
        return this._end
      }

      get isPointingToRight() {
        return this._sourceEntity.offsetCenter < this._targetEntity.offsetCenter
      }

      get isDownward() {
        return this._start.y < this._end.y
      }

      get offsetTop() {
        return Math.min(this._start.y, this._end.y)
      }

      get horizontalDistance() {
        return Math.abs(this._end.x - this._start.x)
      }

      get sourceXShiftRate() {
        const { relations } = this._sourceEntity.span
        const index = relations.indexOf(this._relation)
        return relations.length === 1 ? 0.5 : index / (relations.length - 1)
      }

      get targetXShiftRate() {
        const { relations } = this._targetEntity.span
        const index = relations.indexOf(this._relation)
        return relations.length === 1 ? 0.5 : index / (relations.length - 1)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/CutOffOnSourceBentOnSourceCurveAlgorithm.js

    class CutOffOnSourceBentOnSourceCurveAlgorithm extends BentOnSourceCurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/CutOffOnTargetBentOnTargetCurveAlgorithm.js

    class CutOffOnTargetBentOnTargetCurveAlgorithm extends BentOnTargetCurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/CutOffOnSourceBentOnTargetCurveAlgorithm.js

    class CutOffOnSourceBentOnTargetCurveAlgorithm extends BentOnTargetCurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/CutOffOnTargetBentOnSourceCurveAlgorithm.js

    class CutOffOnTargetBentOnSourceCurveAlgorithm extends BentOnSourceCurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/CutOffOnSourceArchedCurveAlgorithm.js

    class CutOffOnSourceArchedCurveAlgorithm extends ArchedCurveAlgorithm {
      get isSourceJettyVisible() {
        return false
      }

      get isTargetJettyVisible() {
        return true
      }

      get sourceX() {
        return (
          super.sourceX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.sourceXShiftRate
        )
      }

      get sourceY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/CutOffOnTargetArchedCurveAlgorithm.js

    class CutOffOnTargetArchedCurveAlgorithm extends ArchedCurveAlgorithm {
      get isSourceJettyVisible() {
        return true
      }

      get isTargetJettyVisible() {
        return false
      }

      get targetX() {
        return (
          super.targetX -
          this._virtualEntityWidth / 2 +
          this._virtualEntityWidth * this._startAndEnd.targetXShiftRate
        )
      }

      get targetY() {
        const { clientHeight } = document.documentElement
        const offsetBottomOfContainer =
          clientHeight - this._clientTopOfContainer

        return offsetBottomOfContainer - 8
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/CurveAlgorithmFactory/index.js

    class CurveAlgorithmFactory {
      static create(
        relation,
        alignSourceBollards,
        alignTargetBollards,
        clientTopOfContainer,
        controlBarHeight
      ) {
        const startAndEnd = new StartAndEnd_startAndEnd(
          relation,
          alignSourceBollards,
          alignTargetBollards
        )

        const { sourceEntity, targetEntity } = relation

        if (
          targetEntity.clientBottom < controlBarHeight &&
          targetEntity.clientTop < sourceEntity.clientTop
        ) {
          return new PointingUpCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }

        if (
          sourceEntity.clientBottom < controlBarHeight &&
          sourceEntity.clientTop < targetEntity.clientTop
        ) {
          return new PointingDownCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }

        const { clientHeight } = document.documentElement
        if (
          Math.abs(sourceEntity.clientBottom - targetEntity.clientBottom) <
            12 ||
          42 < startAndEnd.horizontalDistance
        ) {
          if (clientHeight < sourceEntity.clientTop) {
            return new CutOffOnSourceArchedCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          if (clientHeight < targetEntity.clientTop) {
            return new CutOffOnTargetArchedCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          return new ArchedCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }

        if (startAndEnd.isDownward) {
          if (clientHeight < sourceEntity.clientTop) {
            return new CutOffOnSourceBentOnTargetCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          if (clientHeight < targetEntity.clientTop) {
            return new CutOffOnTargetBentOnTargetCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          return new BentOnTargetCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        } else {
          if (clientHeight < sourceEntity.clientTop) {
            return new CutOffOnSourceBentOnSourceCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          if (clientHeight < targetEntity.clientTop) {
            return new CutOffOnTargetBentOnSourceCurveAlgorithm(
              startAndEnd,
              alignSourceBollards,
              alignTargetBollards,
              controlBarHeight,
              clientTopOfContainer
            )
          }

          return new BentOnSourceCurveAlgorithm(
            startAndEnd,
            alignSourceBollards,
            alignTargetBollards,
            controlBarHeight,
            clientTopOfContainer
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Arrow/index.js

    class Arrow {
      constructor(
        editorHTMLElement,
        relation,
        controlBarHeight,
        onAuraClick,
        onBollardClick,
        onMouseEnter,
        onMouseLeave
      ) {
        this._container = editorHTMLElement.querySelector(
          '.textae-editor__relation-box'
        )
        this._relation = relation
        this._controlBarHeight = controlBarHeight

        const sourceBollard = createSourceBollard()
        this._container.appendChild(sourceBollard)
        this._sourceBollard = sourceBollard

        const targetBollard = createTargetBollard()
        this._container.appendChild(targetBollard)
        this._targetBollard = targetBollard

        const path = createPath()
        this._container.appendChild(path)
        this._path = path

        const pathAura = document.createElementNS(NS.SVG, 'path')
        pathAura.classList.add('textae-editor__relation-aura')
        pathAura.addEventListener('click', onAuraClick)
        pathAura.addEventListener('mouseenter', onMouseEnter)
        pathAura.addEventListener('mouseleave', onMouseLeave)
        const title = document.createElementNS(NS.SVG, 'title')
        pathAura.appendChild(title)
        this._container.appendChild(pathAura)
        this._pathAura = pathAura

        const sourceBollardAura = createSourceBollard()
        sourceBollardAura.classList.add('textae-editor__relation-bollard-aura')
        sourceBollardAura.addEventListener('click', (e) =>
          onBollardClick(e, relation.sourceEntity)
        )
        sourceBollardAura.appendChild(document.createElementNS(NS.SVG, 'title'))
        this._container.appendChild(sourceBollardAura)
        this._sourceBollardAura = sourceBollardAura

        const targetBollardAura = createTargetBollard()
        targetBollardAura.classList.add('textae-editor__relation-bollard-aura')
        targetBollardAura.addEventListener('click', (e) =>
          onBollardClick(e, relation.targetEntity)
        )
        targetBollardAura.appendChild(document.createElementNS(NS.SVG, 'title'))
        this._container.appendChild(targetBollardAura)
        this._targetBollardAura = targetBollardAura

        this._sourceJetty = null
        this._targetJetty = null

        this.update(false, false, false)
      }

      update(pointUpPath, pointUpSourceBollards, pointUpTargetBollards) {
        const curveAlgorithm = CurveAlgorithmFactory.create(
          this._relation,
          pointUpSourceBollards,
          pointUpTargetBollards,
          this._container.getBoundingClientRect().top,
          this._controlBarHeight
        )
        updatePath(
          this._path,
          curveAlgorithm,
          this._relation.color,
          pointUpPath
        )
        updatePath(this._pathAura, curveAlgorithm, this._relation.color, false)
        this._pathAura.children[0].textContent = this._relation.title

        this._sourceBollard.setAttribute(
          'style',
          `fill:${this._relation.sourceColor}`
        )
        this._sourceBollard.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForSourceTriangle
        )

        this._targetBollard.setAttribute(
          'style',
          `fill:${this._relation.targetColor}`
        )
        this._targetBollard.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForTargetTriangle
        )

        this._sourceBollardAura.children[0].textContent =
          this._relation.sourceEntity.title
        this._sourceBollardAura.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForSourceTriangle
        )

        this._targetBollardAura.children[0].textContent =
          this._relation.targetEntity.title
        this._targetBollardAura.setAttribute(
          'transform',
          curveAlgorithm.transformDefinitionsForTargetTriangle
        )

        if (pointUpSourceBollards && curveAlgorithm.isSourceJettyVisible) {
          this._drawSourceJetty(curveAlgorithm)
        } else {
          this._destroySourceJetty()
        }

        if (pointUpTargetBollards && curveAlgorithm.isTargetJettyVisible) {
          this._drawTargetJetty(curveAlgorithm)
        } else {
          this._destroyTargetJetty()
        }

        this._curveAlgorithm = curveAlgorithm
      }

      destructor() {
        this._container.removeChild(this._path)
        this._container.removeChild(this._sourceBollardAura)
        this._container.removeChild(this._targetBollardAura)
        this._container.removeChild(this._pathAura)
        this._container.removeChild(this._sourceBollard)
        this._container.removeChild(this._targetBollard)

        this._destroySourceJetty()
        this._destroyTargetJetty()
      }

      get top() {
        return this._path.getBBox().y
      }

      get left() {
        return this._path.getBBox().x
      }

      get highestX() {
        const _t = this._curveAlgorithm.getTForY(this.top)

        return this._curveAlgorithm.getXOnT(_t)
      }

      get width() {
        return this._path.getBBox().width
      }

      _drawSourceJetty(curveAlgorithm) {
        const { sourceEntity } = this._relation

        if (this._sourceJetty) {
          moveJetty(
            this._sourceJetty,
            curveAlgorithm.sourceX,
            curveAlgorithm.sourceY,
            sourceEntity
          )
        } else {
          const sourceJetty = createJetty(
            curveAlgorithm.sourceX,
            curveAlgorithm.sourceY,
            sourceEntity
          )
          this._container.appendChild(sourceJetty)
          this._sourceJetty = sourceJetty
        }
      }

      _drawTargetJetty(curveAlgorithm) {
        const { targetEntity } = this._relation

        if (this._targetJetty) {
          moveJetty(
            this._targetJetty,
            curveAlgorithm.targetX,
            curveAlgorithm.targetY,
            targetEntity
          )
        } else {
          const targetJetty = createJetty(
            curveAlgorithm.targetX,
            curveAlgorithm.targetY,
            targetEntity
          )
          this._container.appendChild(targetJetty)
          this._targetJetty = targetJetty
        }
      }

      _destroySourceJetty() {
        if (this._sourceJetty) {
          this._container.removeChild(this._sourceJetty)
          this._sourceJetty = null
        }
      }

      _destroyTargetJetty() {
        if (this._targetJetty) {
          this._container.removeChild(this._targetJetty)
          this._targetJetty = null
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/SignboardHTMLElement.js

    const CSS_CLASS_SELECTED = 'textae-editor__signboard--selected'
    const CSS_CLASS_HOVERED = 'textae-editor__signboard--hovered'
    const CSS_CLASS_CUTTING = 'textae-editor__signboard--cutting'

    class SignboardHTMLElement {
      constructor(instance, entityType, HTMLId) {
        this._instance = instance
        this._element = dohtml_default().create(
          this.#getHtml(HTMLId, entityType)
        )
      }

      get element() {
        return this._element
      }

      addEventListener(event, listener) {
        this._element.addEventListener(event, listener)
      }

      hover() {
        this._element.classList.add(CSS_CLASS_HOVERED)
      }

      select() {
        this._element.classList.add(CSS_CLASS_SELECTED)
      }

      deselect() {
        this._element.classList.remove(CSS_CLASS_SELECTED)
      }

      startCut() {
        this._element.classList.add(CSS_CLASS_CUTTING)
      }

      cancelCut() {
        this._element.classList.remove(CSS_CLASS_CUTTING)
      }

      clearCSSClass() {
        this.element.className = ''
        this.element.classList.add('textae-editor__signboard')
      }

      updateLabel() {
        const typeValues = this.element.querySelector(
          '.textae-editor__signboard__type-values'
        )
        typeValues.style.backgroundColor = hexToRGBA(this._instance.color, 0.4)
        typeValues.querySelector(
          '.textae-editor__signboard__type-label'
        ).innerHTML = anemone`${this._instance.anchorHTML}`

        // Re-create all attributes.
        for (const attributeElement of typeValues.querySelectorAll(
          '.textae-editor__signboard__attribute'
        )) {
          attributeElement.remove()
        }
        for (const a of this._instance.attributes) {
          typeValues.insertAdjacentHTML('beforeend', a.contentHTML)
        }
      }

      clarifyLabel() {
        this.element.querySelector(
          '.textae-editor__signboard__type-label'
        ).style.backgroundColor = hexToRGBA(this._instance.color, 1)

        for (const a of this._instance.attributes) {
          a.clarifyLabelIn(this.element)
        }
      }

      declarifyLabel() {
        this.element.querySelector(
          '.textae-editor__signboard__type-label'
        ).style.backgroundColor = getLabelBackgroundColor()

        for (const a of this._instance.attributes) {
          a.declarifyLabelIn(this.element)
        }
      }

      focus() {
        this._element
          .querySelector('.textae-editor__signboard__type-label')
          .focus()
      }

      replaceWith(signboardHTMLElement) {
        this._element.replaceWith(signboardHTMLElement.element)
        return signboardHTMLElement
      }

      reflectTypeGapInTheHeight(height) {
        this._element.setAttribute('style', `padding-top: ${height}px;`)
      }

      remove() {
        this._element.remove()
      }

      // A Type element has an entity_pane element that has a label and will have entities.
      #getHtml(HTMLId, entityType) {
        return anemone`
  <div
    class="textae-editor__signboard"
    ${HTMLId ? `id="${HTMLId}"` : ''}
    title="${this._instance.title}"
    data-entity-type="${entityType}"
    data-id="${this._instance.id}"
    >
    <div
      class="textae-editor__signboard__type-values"
      style="background-color: ${hexToRGBA(this._instance.color, 0.4)};"
      >
      <div
        class="textae-editor__signboard__type-label"
        tabindex="0"
        style="background-color: ${getLabelBackgroundColor()};"
        >
        ${this._instance.anchorHTML}
      </div>
      ${this._instance.attributes.map((a) => a.contentHTML)}
    </div>
  </div>
  `
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/Label.js

    class Label {
      /**
       *
       * @param {HTMLElement} editorHTMLElement
       * @param {import('.').default} relation
       * @param {import('./Arrow').default} arrow
       */
      constructor(
        editorHTMLElement,
        relation,
        arrow,
        onClick,
        onMouseEnter,
        onMouseLeave
      ) {
        this._container = getAnnotationBox(editorHTMLElement)
        this._relation = relation
        this._arrow = arrow

        this._location = dohtml_default().create(
          `<div class="textae-editor__relation__signboard-location"></div>`
        )
        this._updatePosition()

        this._signboard = new SignboardHTMLElement(relation, 'relation', null)
        this._location.appendChild(this._signboard.element)
        this._container.appendChild(this._location)

        this._location.addEventListener('click', onClick)
        this._location.addEventListener('mouseenter', onMouseEnter)
        this._location.addEventListener('mouseleave', onMouseLeave)
      }

      updateValue() {
        this._updatePosition()
        this._signboard.updateLabel()
      }

      updateHighlighting() {
        this._updatePosition()

        this._signboard.clearCSSClass()

        if (this._relation.isSelected) {
          this._signboard.select()
        } else if (this._relation.isHovered) {
          this._signboard.hover()
        }
      }

      destructor() {
        this._container.removeChild(this._location)
      }

      get y() {
        return this._background.getBBox().y
      }

      get width() {
        return this._location.getBBox().width
      }

      get height() {
        return this._location.getBBox().height
      }

      _updatePosition() {
        // Set the center of the label to the X coordinate of the highest point of the curve.
        this._location.style.width = '0px'
        this._location.style.left = `${this._arrow.highestX}px`

        this._location.style.top = `${
          this._arrow.top - 18 - this._relation.attributes.length * 18
        }px`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/RelationInstance/index.js

    class RelationInstance {
      constructor(
        editorHTMLElement,
        eventEmitter,
        entityContainer,
        attributeContainer,
        { id, pred, subj, obj },
        namespace,
        definitionContainer,
        controlBarHeight
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._eventEmitter = eventEmitter
        this._entityContainer = entityContainer
        this._attributeContainer = attributeContainer
        this._id = id
        this.typeName = pred
        this._subj = subj
        this._obj = obj
        this._namespace = namespace
        this._definitionContainer = definitionContainer
        this._controlBarHeight = controlBarHeight
        this._isSelected = false

        // When you click on a relation to deselect it, the display of the relation will be in hover.
        // When you click on the body and deselect the relation, the display of the relation becomes non-hover.
        // To make this distinction, the hover state is retained.
        this._isHovered = false
      }

      get id() {
        return this._id
      }

      set id(val) {
        this._id = val
      }

      get typeName() {
        return this._typeName
      }

      set typeName(val) {
        // Replace null to 'null' if type is null and undefined too.
        this._typeName = String(val)
      }

      get typeValues() {
        return new TypeValues(
          this._typeName,
          this._attributeContainer.getAttributesFor(this._id)
        )
      }

      get subj() {
        return this._subj
      }

      get obj() {
        return this._obj
      }

      get attributes() {
        return this._attributeContainer.getAttributesFor(this._id)
      }

      /** @returns {import('../../../EntityInstance').EntityInstance} */
      get sourceEntity() {
        return this._entityContainer.get(this.subj)
      }

      /** @returns {import('../../../EntityInstance').EntityInstance} */
      get targetEntity() {
        return this._entityContainer.get(this.obj)
      }

      get sourceColor() {
        return this.sourceEntity.color
      }

      get targetColor() {
        return this.targetEntity.color
      }

      get isSelected() {
        return this._isSelected
      }

      get isHovered() {
        return this._isHovered
      }

      select() {
        if (!this._isSelected) {
          this._isSelected = true
          // When we select a relation,
          // it is hovering and we have already highlighted the line,
          // so we only need to update the label.
          if (this._label) {
            this._label.updateHighlighting()
          }
        }
      }

      deselect() {
        if (this._isSelected) {
          this._isSelected = false
          if (this._arrow || this._label) {
            this.redrawLineConsideringSelection()
          }
        }
      }

      render(clientHeight, clientWidth) {
        if (
          this.sourceEntity.isInViewport(clientHeight, clientWidth) ||
          this.targetEntity.isInViewport(clientHeight, clientWidth)
        ) {
          if (!this._arrow) {
            this._arrow = new Arrow(
              this._editorHTMLElement,
              this,
              this._controlBarHeight,
              (event) => {
                this._eventEmitter.emit(
                  'textae-event.editor.relation.click',
                  event,
                  this
                )
                event.stopPropagation()
              },
              (event, entity) => {
                this._eventEmitter.emit(
                  'textae-event.editor.relation-bollard.click',
                  event,
                  entity
                )
                event.stopPropagation()
              },
              () => this._pointUpSelfAndEntities(),
              () => this._pointDownSelfAndEntities()
            )

            this._label = new Label(
              this._editorHTMLElement,
              this,
              this._arrow,
              (event, attribute) => {
                this._eventEmitter.emit(
                  'textae-event.editor.relation.click',
                  event,
                  this,
                  attribute
                )
                event.stopPropagation()
              },
              () => this._pointUpSelfAndEntities(),
              () => this._pointDownSelfAndEntities()
            )
          } else {
            this._redrawArrowConsideringSelection()
          }

          if (
            (this.sourceEntity.clientTop > this.targetEntity.clientTop &&
              this.targetEntity.isInViewport(clientHeight, clientWidth)) ||
            (this.sourceEntity.clientTop < this.targetEntity.clientTop &&
              this.sourceEntity.isInViewport(clientHeight, clientWidth)) ||
            this.sourceEntity.clientTop === this.targetEntity.clientTop
          ) {
            if (!this._label) {
              this._label = new Label(
                this._editorHTMLElement,
                this,
                this._arrow,
                (event, attribute) => {
                  this._eventEmitter.emit(
                    'textae-event.editor.relation.click',
                    event,
                    this,
                    attribute
                  )
                  event.stopPropagation()
                },
                () => this._pointUpSelfAndEntities(),
                () => this._pointDownSelfAndEntities()
              )

              // When scrolling out of a selected relation and then scrolling in again,
              // the selected state will be highlighted.
              this._label.updateHighlighting()
            } else {
              this._redrawLabelConsideringSelection()
            }
          } else {
            if (this._label) {
              this._label.destructor()
              this._label = undefined
            }
          }
        } else {
          if (this._arrow || this._label) {
            this.erase()
          }
        }
      }

      updateElement() {
        if (this._arrow) {
          this._arrow.update(
            this.isSelected || this._relation.isHovered,
            this.isSelected || this._relation.isHovered,
            this.isSelected || this._relation.isHovered
          )
        }

        if (this._label) {
          this._label.updateValue()
        }
      }

      redrawLineConsideringSelection() {
        this._redrawArrowConsideringSelection()
        this._redrawLabelConsideringSelection()
      }

      pointUpPathAndSourceBollards() {
        if (this._arrow) {
          if (this.targetEntity.isSelected) {
            this._arrow.update(true, true, true)
          } else {
            this._arrow.update(true, true, this.isSelected)
          }
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpPathAndTargetBollards() {
        if (this._arrow) {
          if (this.sourceEntity.isSelected) {
            this._arrow.update(true, true, true)
          } else {
            this._arrow.update(true, this.isSelected, true)
          }
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpSourceBollardsAndTargetBollards() {
        if (this._arrow) {
          this._arrow.update(this.isSelected, true, true)
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpSourceBollards() {
        if (this._arrow) {
          this._arrow.update(this.isSelected, true, this.isSelected)
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      pointUpTargetBollards() {
        if (this._arrow) {
          this._arrow.update(this.isSelected, this.isSelected, true)
        }

        if (this._label) {
          this._label.updateHighlighting()
        }
      }

      erase() {
        if (this._arrow) {
          this._arrow.destructor()
          this._arrow = undefined
        }

        if (this._label) {
          this._label.destructor()
          this._label = undefined
        }
      }

      get title() {
        return `[${this.id}] pred: type, value: ${this.typeName}`
      }

      get color() {
        return this._definitionContainer.getColor(this.typeName)
      }

      get anchorHTML() {
        return toAnchorElement(this._displayName, this._href)
      }

      get _displayName() {
        return getDisplayName(
          this._namespace,
          this.typeName,
          this._definitionContainer.getLabel(this.typeName)
        )
      }

      get _href() {
        return getURI(
          this._namespace,
          this.typeName,
          this._definitionContainer.getURI(this.typeName)
        )
      }

      _pointUpSelfAndEntities() {
        this._isHovered = true
        this._arrow.update(true, true, true)
        if (this._label) {
          this._label.updateHighlighting()
        }

        const bothRelations = new Set()
        const sourceRelations = new Set()
        const targetRelations = new Set()

        for (const r of this.sourceEntity.relationsWhereThisIsSource) {
          if (r === this) {
            continue
          }

          if (r.targetEntity == this.targetEntity) {
            bothRelations.add(r)
          } else {
            sourceRelations.add(r)
          }
        }

        for (const r of this.sourceEntity.relationsWhereThisIsTarget) {
          if (r === this) {
            continue
          }

          if (r.sourceEntity == this.targetEntity) {
            bothRelations.add(r)
          } else {
            targetRelations.add(r)
          }
        }

        for (const r of this.targetEntity.relationsWhereThisIsSource) {
          if (r === this) {
            continue
          }

          if (r.targetEntity == this.sourceEntity) {
            bothRelations.add(r)
          } else {
            sourceRelations.add(r)
          }
        }

        for (const r of this.targetEntity.relationsWhereThisIsTarget) {
          if (r === this) {
            continue
          }

          if (r.sourceEntity == this.sourceEntity) {
            bothRelations.add(r)
          } else {
            targetRelations.add(r)
          }
        }

        for (const r of bothRelations) {
          r.pointUpSourceBollardsAndTargetBollards()
        }

        for (const r of sourceRelations) {
          r.pointUpSourceBollards()
        }

        for (const r of targetRelations) {
          r.pointUpTargetBollards()
        }
      }

      _pointDownSelfAndEntities() {
        this._isHovered = false

        const relations = new Set()

        for (const r of this.sourceEntity.relations) {
          relations.add(r)
        }

        for (const r of this.targetEntity.relations) {
          relations.add(r)
        }

        for (const r of relations) {
          r.redrawLineConsideringSelection()
        }
      }

      _redrawArrowConsideringSelection() {
        if (this._arrow) {
          if (this.sourceEntity.isSelected && this.targetEntity.isSelected) {
            this._arrow.update(true, true, true)
          } else if (this.sourceEntity.isSelected) {
            this._arrow.update(true, true, this.isSelected)
          } else if (this.targetEntity.isSelected) {
            this._arrow.update(true, this.isSelected, true)
          } else {
            this._arrow.update(
              this.isSelected,
              this.isSelected,
              this.isSelected
            )
          }
        }
      }

      _redrawLabelConsideringSelection() {
        if (this._label) {
          this._label.updateHighlighting()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/RelationInstanceContainer/index.js

    class RelationInstanceContainer extends IdIssueContainer {
      constructor(
        editorHTMLElement,
        eventEmitter,
        parentContainer,
        namespace,
        definitionContainer
      ) {
        super(eventEmitter, 'relation', () => 'R')
        this._editorHTMLElement = editorHTMLElement
        this._eventEmitter = eventEmitter
        this._parentContainer = parentContainer
        this._namespace = namespace
        this._definitionContainer = definitionContainer
      }

      /** @param {number} value */
      set controlBarHeight(value) {
        this._controlBarHeight = value
      }

      _toInstance(relation) {
        return new RelationInstance(
          this._editorHTMLElement,
          this._eventEmitter,
          this._parentContainer.entity,
          this._parentContainer.attribute,
          relation,
          this._namespace,
          this._definitionContainer,
          this._controlBarHeight
        )
      }

      add(newValue) {
        // When redoing, the newValue is instance of the RelationInstance already.
        newValue =
          newValue instanceof RelationInstance
            ? newValue
            : new RelationInstance(
                this._editorHTMLElement,
                this._eventEmitter,
                this._parentContainer.entity,
                this._parentContainer.attribute,
                newValue,
                this._namespace,
                this._definitionContainer,
                this._controlBarHeight
              )
        const newInstance = super.add(newValue)

        const { clientHeight, clientWidth } = document.documentElement
        newInstance.render(clientHeight, clientWidth)

        return newInstance
      }

      changeType(id, newType) {
        const relation = super.changeType(id, newType)
        relation.updateElement()
        return relation
      }

      remove(id) {
        console.assert(id, 'id is necessary!')
        const relation = super.remove(id)
        relation.erase()
      }

      clear() {
        for (const relation of this.all) {
          relation.erase()
        }
        super.clear()
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/EntityInstance.js

    const DistanceToShift = 8
    // Leave a gap half the width of the triangle so that the triangle does not intersect the vertical line.
    const MinimumDistance = DistanceToShift * 3 + 4

    class EntityInstance {
      /**
       *
       * @param {import('./AnnotationModel/SpanInstanceContainer/SpanInstance/index.js').SpanInstance} span
       */
      constructor(
        editorID,
        attributeContainer,
        relationContainer,
        typeGap,
        typeDefinition,
        span,
        typeName,
        namespace,
        controlBarHeight,
        id = null
      ) {
        this._editorID = editorID
        this.span = span
        this.typeName = typeName
        this._id = id
        this._attributeContainer = attributeContainer
        this._relationContainer = relationContainer
        this._typeGap = typeGap
        this._typeDefinition = typeDefinition
        this._namespace = namespace
        this._controlBarHeight = controlBarHeight

        this._isSelected = false
        this._isHovered = false
        // When in view mode, the mouseleave event will not declarify labels.
        this._isLabelClarified = false

        /** @type {SignboardHTMLElement} */
        this._signboard = null
      }

      get id() {
        return this._id
      }

      set id(val) {
        this._id = val
      }

      get title() {
        return `[${this.id}] pred: type, value: ${this._typeName}`
      }

      get color() {
        return this.#definitionContainer.getColor(this.typeName)
      }

      get anchorHTML() {
        return toAnchorElement(this.#displayName, this.#href)
      }

      get span() {
        return this._span
      }

      set span(val) {
        this._span = val
        val.add(this)
      }

      get typeName() {
        return this._typeName
      }

      set typeName(val) {
        // Replace null to 'null' if type is null and undefined too.
        this._typeName = String(val)
      }

      get typeValues() {
        return new TypeValues(
          this._typeName,
          this._attributeContainer.getAttributesFor(this._id)
        )
      }

      get relations() {
        return this.relationsWhereThisIsSource.concat(
          this.relationsWhereThisIsTarget
        )
      }

      /**
       * @returns {import('./AnnotationModel/AttributeInstanceContainer/AttributeInstance.js').AttributeInstance[]}
       */
      get attributes() {
        return this._attributeContainer.getAttributesFor(this._id)
      }

      get relationsWhereThisIsSource() {
        return this._relationContainer.all.filter((r) => r.subj === this.id)
      }

      get relationsWhereThisIsTarget() {
        return this._relationContainer.all.filter((r) => r.obj === this.id)
      }

      get hasMultipleEndpoints() {
        const relations = new Map()
        relations.set('whereThisIsSourceAndTargetIsOnTheLeft', new Set())
        relations.set('whereThisIsSourceAndTargetIsOnTheRight', new Set())
        relations.set('whereThisIsSourceAndTargetIsUpOrDown', new Set())

        for (const r of this.relationsWhereThisIsSource) {
          if (r.targetEntity.offsetCenter < this.offsetCenter) {
            relations.get('whereThisIsSourceAndTargetIsOnTheLeft').add(r)
          } else if (this.offsetCenter < r.targetEntity.offsetCenter) {
            relations.get('whereThisIsSourceAndTargetIsOnTheRight').add(r)
          } else {
            relations.get('whereThisIsSourceAndTargetIsUpOrDown').add(r)
          }
        }

        relations.set('whereThisIsTargetAndSourceIsOnTheLeft', new Set())
        relations.set('whereThisIsTargetAndSourceIsOnTheRight', new Set())
        relations.set('whereThisIsTargetAndSourceIsUpOrDown', new Set())

        for (const r of this.relationsWhereThisIsTarget) {
          if (r.sourceEntity.offsetCenter < this.offsetCenter) {
            relations.get('whereThisIsTargetAndSourceIsOnTheLeft').add(r)
          } else if (this.offsetCenter < r.targetEntity.offsetCenter) {
            relations.get('whereThisIsTargetAndSourceIsOnTheRight').add(r)
          } else {
            relations.get('whereThisIsTargetAndSourceIsUpOrDown').add(r)
          }
        }

        return [...relations.values()].filter((s) => s.size).length > 1
      }

      get clientTop() {
        const { span } = this

        // Calculates the top without referencing the HTML element of entities.
        if (span.isDenotation) {
          let top = span.clientTopOfGrid + this._typeGap.height

          for (const entity of span.entities) {
            if (entity === this) {
              break
            }

            top += this._typeGap.height + entity.height
          }

          return round(top)
        }

        if (span.isBlock) {
          const paddingBottomOfGridOfBlockSpan = 15
          return round(
            span.clientBottomOfGrid -
              this.height -
              paddingBottomOfGridOfBlockSpan
          )
        }

        throw new Error('Unexpected type of span')
      }

      get offsetTop() {
        return (
          this.clientTop -
          this.span.element.offsetParent.offsetParent.getBoundingClientRect()
            .top
        )
      }

      get clientBottom() {
        return this.clientTop + this.height
      }

      isInViewport(clientHeight) {
        return (
          this._controlBarHeight <= this.clientBottom &&
          this.clientTop <= clientHeight
        )
      }

      get width() {
        return this.span.widthOfGrid
      }

      get height() {
        const labelUnitHeight = 18

        return labelUnitHeight + this.#attributesHeight
      }

      get heightWithTypeGap() {
        return this.height + this._typeGap.height
      }

      get offsetCenter() {
        return round(this.span.offsetCenterOfGrid)
      }

      get isDenotation() {
        return this._span.isDenotation
      }

      get isBlock() {
        return this._span.isBlock
      }

      get isSelected() {
        return this._isSelected
      }

      getSourceAnchorPosition(alignBollards) {
        // When the entity width is small and the endpoint is displayed in the center of the entity and the entity has only one endpoint,
        // hovering will not move the entity left or right.
        const isJettyDeployed =
          this.width / 2 >= MinimumDistance ||
          (this.hasMultipleEndpoints && alignBollards)

        return {
          left: isJettyDeployed
            ? this.offsetCenter - DistanceToShift * 3
            : this.offsetCenter,
          right: isJettyDeployed
            ? this.offsetCenter + DistanceToShift * 3
            : this.offsetCenter
        }
      }

      getTargetAnchorPosition(alignBollards) {
        // When the entity width is small and the endpoint is displayed in the center of the entity and the entity has only one endpoint,
        // hovering will not move the entity left or right.
        const isJettyDeployed =
          this.width / 2 >= MinimumDistance ||
          (this.hasMultipleEndpoints && alignBollards)

        return {
          left: isJettyDeployed
            ? this.offsetCenter - DistanceToShift
            : this.offsetCenter,
          right: isJettyDeployed
            ? this.offsetCenter + DistanceToShift
            : this.offsetCenter
        }
      }

      focus() {
        if (this.isDenotation) {
          this.span.focus()
        } else if (this.isBlock) {
          // Entities outside the drawing area are not rendered.
          // Attempting to focus will result in an error.
          // Force rendering before focusing.
          this.span.forceRenderGrid()
          this._signboard.focus()
        } else {
          throw new Error('Unexpected type of entity')
        }
      }

      select() {
        if (!this._isSelected) {
          this._isSelected = true
          this.#selectElement()
          this.#updateRelationHighlighting()
        }
      }

      deselect() {
        if (this._isSelected) {
          this._isSelected = false
          if (this._signboard) {
            this._signboard.deselect()
          }
          this.#updateRelationHighlighting()
        }
      }

      startCut() {
        if (this._signboard) {
          this._signboard.startCut()
        }
      }

      cancelCut() {
        if (this._signboard) {
          this._signboard.cancelCut()
        }
      }

      render() {
        if (this._signboard) {
          return
        }

        if (this.span.isGridRendered) {
          // Append a new entity to the type
          this._signboard = this.#createSignboardElement()
          this.span.addEntityElementToGridElement(this._signboard.element)

          this.reflectTypeGapInTheHeight()

          for (const entity of this.span.entities.filter((e) => e !== this)) {
            for (const relation of entity.relations) {
              relation.redrawLineConsideringSelection()
            }
          }

          // When scrolling out of a selected entity and then scrolling in again,
          // the selected state will be highlighted.
          if (this._isSelected) {
            this._signboard.select()
          }
        }
      }

      updateElement() {
        if (this._signboard) {
          this._signboard = this._signboard.replaceWith(
            this.#createSignboardElement()
          )

          // Re-select a new entity element.
          if (this._isSelected) {
            this.#selectElement()
          }

          this.reflectTypeGapInTheHeight()

          this.span.updateSelfAndAncestorsGridPosition()
          for (const entity of this.span.entities) {
            for (const relation of entity.relations) {
              relation.redrawLineConsideringSelection()
            }
          }
        }
      }

      reflectTypeGapInTheHeight() {
        if (this.isDenotation && this._signboard) {
          this._signboard.reflectTypeGapInTheHeight(this._typeGap.height)
        }
      }

      clarifyLabel() {
        if (this._signboard) {
          this._signboard.clarifyLabel()
        }
        this._isLabelClarified = true
      }

      declarifyLabel() {
        if (!this._isHovered && this._signboard) {
          this._signboard.declarifyLabel()
        }
        this._isLabelClarified = false
      }

      erase() {
        if (this._signboard) {
          this._signboard.remove()
          this._signboard = null
          this.span.updateSelfAndAncestorsGridPosition()
        }
      }

      #createSignboardElement() {
        const signboard = new SignboardHTMLElement(
          this,
          this.isDenotation ? 'denotation' : 'block',
          `${this._editorID}__E${this.id.replace(/[:¥.]/g, '')}`
        )

        // Highlight relations when related entity is hovered.
        signboard.addEventListener('mouseenter', () => {
          signboard.clarifyLabel()
          this.#pointUpRelations()
          this._isHovered = true
        })
        signboard.addEventListener('mouseleave', () => {
          if (!this._isLabelClarified) {
            signboard.declarifyLabel()
          }
          this.#updateRelationHighlighting()
          this._isHovered = false
        })

        return signboard
      }

      #selectElement() {
        // Force rendering to select and focus on entities outside the display area.
        this.span.forceRenderGrid()
        this._signboard.select()

        // The block span renders as a div HTML element.
        // Because the positioning of div HTML elements is slower than that of span HTML elements,
        // block span grids do not move at render time.
        // Focusing before moving causes the browser to scroll to the top of the document.
        // So focus after the move, not at render time.
        if (this.span.isGridBeforePositioned) {
          this.span.entityToFocusOn = this
        } else {
          // Set focus in order to scroll the browser to the position of the element.
          this.focus()
        }
      }

      /** @return {import('./AnnotationModel/DefinitionContainer/index.js').default} */
      get #definitionContainer() {
        if (this.isDenotation) {
          return this._typeDefinition.denotation
        } else if (this.isBlock) {
          return this._typeDefinition.block
        } else {
          throw 'unknown entity type'
        }
      }

      get #displayName() {
        return getDisplayName(
          this._namespace,
          this.typeName,
          this.#definitionContainer.getLabel(this.typeName)
        )
      }

      get #href() {
        return getURI(
          this._namespace,
          this.typeName,
          this.#definitionContainer.getURI(this.typeName)
        )
      }

      get #attributesHeight() {
        return this.attributes
          .map(({ height }) => height)
          .reduce((sum, height) => sum + height, 0)
      }

      #pointUpRelations() {
        for (const relation of this.relationsWhereThisIsSource) {
          relation.pointUpPathAndSourceBollards()
        }
        for (const relation of this.relationsWhereThisIsTarget) {
          relation.pointUpPathAndTargetBollards()
        }
      }

      #updateRelationHighlighting() {
        for (const relation of this.relations) {
          relation.redrawLineConsideringSelection()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/EntityInstanceContainer.js

    class EntityInstanceContainer extends IdIssueContainer {
      constructor(editorID, eventEmitter, parent, typeGap, namespace) {
        super(eventEmitter, 'entity', (instance) =>
          instance.isDenotation ? 'T' : 'B'
        )

        this._editorID = editorID

        // Since the attribute instance container and the entity instance container are cross-referenced,
        // the entity instance retrieves other containers dynamically.
        this._parent = parent

        this._typeGap = typeGap
        this._namespace = namespace
      }

      get _spanInstanceContainer() {
        return this._parent.span
      }

      get _attributeInstanceContainer() {
        return this._parent.attribute
      }

      get _relationInstanceContainer() {
        return this._parent.relation
      }

      /** @param {number} value */
      set controlBarHeight(value) {
        this._controlBarHeight = value
      }

      _toInstance(denotation, type) {
        // Expected an entity like {id: "E21", span: "editor2__S50_54", obj: "Protein"}.
        const span = this._getSpan(type, denotation)
        const newInstance = new EntityInstance(
          this._editorID,
          this._attributeInstanceContainer,
          this._relationInstanceContainer,
          this._typeGap,
          this._parent.typeDefinition,
          span,
          denotation.obj,
          this._namespace,
          this._controlBarHeight,
          denotation.id
        )

        return newInstance
      }

      add(newValue) {
        if (!newValue.span)
          throw new Error(`entity has no span! ${JSON.stringify(newValue)}`)

        // When redoing, the newValue is instance of the EntityInstance already.
        if (newValue instanceof EntityInstance) {
          super.add(newValue)
          newValue.span.add(newValue)
          newValue.render()
          return newValue
        }

        const span = this._spanInstanceContainer.get(newValue.span)
        const newEntity = new EntityInstance(
          this._editorID,
          this._attributeInstanceContainer,
          this._relationInstanceContainer,
          this._typeGap,
          this._parent.typeDefinition,
          span,
          newValue.typeName,
          this._namespace,
          this._controlBarHeight
        )

        console.assert(
          newEntity.span.isDenotation || newEntity.span.entities.length === 0,
          'A block span cannot have more than one entity.'
        )

        super.add(newEntity)
        newEntity.render()
        return newEntity
      }

      remove(id) {
        // Calculates the grid position in response to entity removal events.
        // Remove entity from Span before the event fires.
        const instance = super.get(id)
        instance.span.remove(instance)
        super.remove(id)

        instance.erase()
      }

      changeType(id, newType) {
        const entity = super.changeType(id, newType)
        entity.updateElement()
        return entity
      }

      moveEntities(span, entities) {
        for (const entity of entities) {
          entity.erase()

          const spanBeforeMove = entity.span
          spanBeforeMove.remove(entity)
          spanBeforeMove.updateSelfAndAncestorsGridPosition()

          entity.span = span
          entity.render()

          for (const relation of entity.relations) {
            relation.redrawLineConsideringSelection()
          }
        }

        this._emit(`textae-event.annotation-data.entity.move`)
      }

      get denotations() {
        return this.all.filter((entity) => entity.isDenotation)
      }

      get blocks() {
        return this.all.filter((entity) => entity.isBlock)
      }

      redrawEntitiesWithSpecifiedAttribute(pred) {
        const entities = this.all.filter((e) =>
          e.typeValues.hasSpecificPredicateAttribute(pred)
        )
        for (const entity of entities) {
          entity.updateElement()
        }

        // If you change the media height attribute of the string attribute definition,
        // you may need to change the position of the Grid.
        for (const span of new Set([...entities.map(({ span }) => span)])) {
          span.updateGridPosition()
        }
      }

      clarifyLabelOfAll() {
        for (const entity of this.all) {
          entity.clarifyLabel()
        }
      }

      declarifyLabelOfAll() {
        for (const entity of this.all) {
          entity.declarifyLabel()
        }
      }

      _getSpan(type, denotation) {
        return this._spanInstanceContainer.get(
          this._getSpanId(type, denotation)
        )
      }

      _getSpanId(type, denotation) {
        switch (type) {
          case 'denotation':
            return makeDenotationSpanHTMLElementID(
              this._editorID,
              denotation.span.begin,
              denotation.span.end
            )
          case 'block':
            return makeBlockSpanHTMLElementID(
              this._editorID,
              denotation.span.begin,
              denotation.span.end
            )
          default:
            throw `${type} is unknown type span!`
        }
      }

      hasDenotation(denotationID) {
        return this.denotations.some(
          (denotation) => denotation.id === denotationID
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/readAcceptedAnnotationTo/IDConflictResolver.js

    // To avoid ID collisions when reading multi-track annotations,
    // add the track number before the ID.
    class IDConflictResolver {
      constructor(trackNumber) {
        this._trackNumber = trackNumber
      }

      addTrackNumberAsIDPrefix(denotation, block, relation, attribute) {
        const denotations = denotation.map((src) => ({
          ...src,
          id: this._prependToIDOf(src)
        }))

        const blocks = block.map((src) => ({
          ...src,
          id: this._prependToIDOf(src)
        }))

        // The attribute refers to the entities contained in the denotation or block by subject.
        const attributes = attribute.map((src) => ({
          ...src,
          id: this._prependToIDOf(src),
          subj: this._prependTrackNumberTo(src.subj),
          obj: src.obj
        }))

        // The relation refers to the entities contained in the denotation or block by subject and object.
        const relations = relation.map((src) => ({
          ...src,
          id: this._prependToIDOf(src),
          subj: this._prependTrackNumberTo(src.subj),
          obj: this._prependTrackNumberTo(src.obj)
        }))

        return {
          denotations,
          blocks,
          relations,
          attributes
        }
      }

      // Set Prefx to the ID if ID exists.
      // IF the ID does not exist, Set new ID in addSource function.
      _prependToIDOf(src) {
        return src.id ? this._prependTrackNumberTo(src.id) : null
      }

      _prependTrackNumberTo(val) {
        return this._trackNumber + val
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/readAcceptedAnnotationTo/convertBeginAndEndOfSpanToInteger.js

    // If the begin or end value is a string,
    // the comparison with other numbers cannot be done correctly.
    /* harmony default export */ function convertBeginAndEndOfSpanToInteger(
      typeSetting,
      denotation,
      block
    ) {
      return [
        typeSetting.map(convert),
        denotation.map(convert),
        block.map(convert)
      ]
    }

    function convert(src) {
      const { span } = src

      return {
        ...src,
        span: convertBeginAndEndToInteger(span)
      }
    }

    function convertBeginAndEndToInteger(span) {
      // You cannot generate a valid value for the ID of HTML element of span
      // from a begin or end that contains a decimal point.
      return { ...span, begin: parseInt(span.begin), end: parseInt(span.end) }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/readAcceptedAnnotationTo/index.js

    /* harmony default export */ function readAcceptedAnnotationTo(
      spanContainer,
      entityContainer,
      attributeContainer,
      relationContainer,
      accept,
      trackNumber = ''
    ) {
      const [typeSettings, denotation, block] =
        convertBeginAndEndOfSpanToInteger(
          accept.typeSetting,
          accept.denotation,
          accept.block
        )
      const { relation, attribute } = accept
      const { denotations, blocks, relations, attributes } =
        new IDConflictResolver(trackNumber).addTrackNumberAsIDPrefix(
          denotation,
          block,
          relation,
          attribute
        )

      spanContainer.addSource(typeSettings, 'typesetting')
      spanContainer.addSource(denotations, 'denotation')
      spanContainer.addSource(blocks, 'block')
      entityContainer.addSource(denotations, 'denotation')
      entityContainer.addSource(blocks, 'block')
      relationContainer.addSource(relations)
      attributeContainer.addSource(attributes)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/getSpanValidation/isBeginAndEndIn/isInText.js

    /* harmony default export */ function isInText(boundary, text) {
      return 0 <= boundary && boundary <= text.length
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/getSpanValidation/isBeginAndEndIn/index.js

    /* harmony default export */ function isBeginAndEndIn(text, span) {
      return isInText(span.begin, text) && isInText(span.end, text)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/ChainValidation/setSourceProperty.js

    /* harmony default export */ function setSourceProperty(n, name) {
      n.sourceProperty = name
      return n
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/ErrorMap.js

    class ErrorMap {
      constructor() {
        this._map = new Map()
      }

      set(key, errors, inhibitors) {
        this._map.set(key, [errors, inhibitors])
      }

      getErrors(key) {
        return this._map.has(key) ? this._map.get(key)[0] : []
      }

      getInhibitors(key) {
        return this._map.has(key) ? this._map.get(key)[1] : []
      }

      get size() {
        return this._map.size
      }
    }

    function collectErrors(name, errorMaps) {
      return errorMaps.reduce(
        (acc, errorMap) => acc.concat(errorMap.getErrors(name)),
        []
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/ChainValidation/index.js

    class ChainValidation {
      constructor(
        candidates,
        sourcePropertyName,
        name = '',
        predicate = () => true,
        prevValidation
      ) {
        this._candidates = candidates || []
        this._name = name
        this._predicate = predicate
        this._prevValidation = prevValidation
        this._sourcePropertyName = sourcePropertyName
      }

      and(name, predicate) {
        return new ChainValidation(
          this._candidates,
          this._sourcePropertyName,
          name,
          predicate,
          this
        )
      }

      validateAll() {
        const errorMap = new ErrorMap()

        let validation
        let qualifieds
        for (
          validation = this, qualifieds = this._candidates;
          validation;
          validation = validation._prevValidation
        ) {
          qualifieds = validation._validate(
            qualifieds,
            this._candidates,
            errorMap
          )
        }

        return [qualifieds, errorMap]
      }

      _validate(qualifieds, candidates, errorMap) {
        if (this._getRejects(candidates).length > 0) {
          errorMap.set(
            this._name,
            this._getRejects(candidates),
            this._getInhibitors(candidates)
          )
        }

        return this._getAccepts(qualifieds)
      }

      _getAccepts(candidates) {
        return candidates.filter((c) => this._test(c))
      }

      _getRejects(candidates) {
        return candidates
          .filter((c) => !this._test(c))
          .map((n) => setSourceProperty(n, this._sourcePropertyName))
      }

      // Returns the elements affectting to the validation to debug.
      // For example, the Span of the cross-boundary partner.
      _getInhibitors(candidates) {
        const inhibitors = new Map()

        for (const c of candidates) {
          const result = this._predicate(c)

          if (Array.isArray(result) && !result[0]) {
            inhibitors.set(c, result[1])
          }
        }

        return inhibitors
      }

      // A predicate function can return both consequences and inhibitors.
      // This function returns consequences only.
      _test(c) {
        const result = this._predicate(c)

        if (Array.isArray(result)) {
          return result[0]
        }

        return result
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/getSpanValidation/index.js

    /* harmony default export */ function getSpanValidation(
      targetSpans,
      text,
      allSpans,
      sourcePropertyName
    ) {
      return new ChainValidation(targetSpans, sourcePropertyName)
        .and('hasLength', (n) => n.span.end - n.span.begin > 0)
        .and('inText', (n) => isBeginAndEndIn(text, n.span))
        .and('isNotCrossing', (n) => {
          const bondaryCrossingSpans = getBoundaryCrossingSpans(
            allSpans,
            n.span.begin,
            n.span.end
          )
          return [bondaryCrossingSpans.length === 0, bondaryCrossingSpans]
        })
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/validateTypeSettings.js

    /* harmony default export */ function validateTypeSettings(
      text,
      targetSpans,
      allSpans
    ) {
      return getSpanValidation(
        targetSpans,
        text,
        allSpans,
        'typesettings'
      ).validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/isContains.js

    /* harmony default export */ function isContains(
      dictionary,
      referedEntityId
    ) {
      return dictionary.some((entry) => entry.id === referedEntityId)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/validateAttribute/isUniqueIn.js

    /* harmony default export */ function isUniqueIn(attributes, node) {
      return (
        attributes.filter(
          (a) =>
            a.subj === node.subj && a.pred === node.pred && a.obj === node.obj
        ).length === 1
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/validateAttribute/index.js

    /* harmony default export */ function validateAttribute(
      subjects,
      attributes
    ) {
      return new ChainValidation(attributes)
        .and('subject', (a) => isContains(subjects, a.subj))
        .and('unique', (node) => isUniqueIn(attributes, node))
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/validateRelation.js

    /* harmony default export */ function validateRelation(
      denotations,
      relations
    ) {
      return new ChainValidation(relations)
        .and('object', (r) => isContains(denotations, r.obj))
        .and('subject', (r) => isContains(denotations, r.subj))
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/transformToReferencedEntitiesError.js

    /* harmony default export */ function transformToReferencedEntitiesError(
      attributeSubj,
      relationObj,
      relationSubj
    ) {
      // Combine rejects for referenced object errer.
      // Mark the column you want to highlight.
      return attributeSubj
        .map((attribute) => {
          attribute.sourceProperty = 'attributes'
          attribute.alertSubj = true
          return attribute
        })
        .concat(
          relationObj.map((relation) => {
            relation.sourceProperty = 'relations'
            relation.alertObj = true
            return relation
          })
        )
        .concat(
          relationSubj.map((relation) => {
            relation.sourceProperty = 'relations'
            relation.alertSubj = true
            return relation
          })
        )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/isIDUnique.js

    /* harmony default export */ function isIDUnique(spans, node) {
      // Span without ID is acceptable.
      return (
        node.id === undefined ||
        spans.filter((d) => node.id && node.id === d.id).length === 1
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/validateDenotation.js

    /* harmony default export */ function validateDenotation(
      text,
      denotations,
      spanOfAllTracks,
      spansInTrack
    ) {
      return getSpanValidation(
        denotations,
        text,
        spanOfAllTracks,
        'denotations'
      )
        .and('uniqueID', (n) => isIDUnique(spansInTrack, n))
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/validateBlock.js

    /* harmony default export */ function validateBlock(
      text,
      blocks,
      spanOfAllTracks,
      spansInTrack
    ) {
      return getSpanValidation(blocks, text, spanOfAllTracks, 'blocks')
        .and('uniqueID', (n) => isIDUnique(spansInTrack, n))
        .and(
          'uniqueRange',
          ({ span }) =>
            blocks.filter(
              ({ span: otherSpan }) =>
                (span.begin === otherSpan.begin) & (span.end === otherSpan.end)
            ).length === 1
        )
        .validateAll()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/debugLogCrossing.js

    /* harmony default export */ function debugLogCrossing(name, errors) {
      for (const [key, values] of errors.getInhibitors('isNotCrossing')) {
        console.warn(
          `Crossing ${name}: [${key.span.begin}:${key.span.end}](${
            key.id
          }) crosses with ${values
            .map(({ id, span }) => `[${span.begin}:${span.end}](${id})`)
            .join(', ')}`
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/getAllSpansIn.js

    /* harmony default export */ function getAllSpansIn(track) {
      const { typesettings, denotations, blocks } = track
      return (typesettings || []).concat(denotations || []).concat(blocks || [])
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/validateAnnotation/index.js

    /* harmony default export */ function validateAnnotation(
      text,
      spanOfAllTracks,
      track
    ) {
      const [typeSetting, errorTypeSettings] = validateTypeSettings(
        text,
        track.typesettings,
        spanOfAllTracks
      )

      const spansInTrack = getAllSpansIn(track)

      const [denotation, errorDenotations] = validateDenotation(
        text,
        track.denotations,
        spanOfAllTracks,
        spansInTrack
      )

      const [block, errorBlocks] = validateBlock(
        text,
        track.blocks,
        spanOfAllTracks,
        spansInTrack
      )

      const [relation, errorRelations] = validateRelation(
        denotation.concat(block),
        track.relations
      )

      const [attribute, errorAttributes] = validateAttribute(
        denotation.concat(block).concat(relation),
        track.attributes
      )

      debugLogCrossing('TypeSettings', errorTypeSettings)
      debugLogCrossing('Denotations', errorDenotations)
      debugLogCrossing('Blocks', errorBlocks)

      return {
        accept: {
          denotation,
          attribute,
          relation,
          typeSetting,
          block
        },
        reject: {
          wrongRangeDenotations: errorDenotations.getErrors('hasLength'),
          outOfTextDenotations: errorDenotations.getErrors('inText'),
          wrongRangeBlocks: errorBlocks.getErrors('hasLength'),
          outOfTextBlocks: errorBlocks.getErrors('inText'),
          duplicatedRangeBlocks: errorBlocks.getErrors('uniqueRange'),
          wrongRangeTypesettings: errorTypeSettings.getErrors('hasLength'),
          outOfTextTypesettings: errorTypeSettings.getErrors('inText'),
          duplicatedIDs: collectErrors('uniqueID', [
            errorDenotations,
            errorBlocks
          ]),
          boundaryCrossingSpans: collectErrors('isNotCrossing', [
            errorTypeSettings,
            errorDenotations,
            errorBlocks
          ]),
          referencedEntitiesDoNotExist: transformToReferencedEntitiesError(
            errorAttributes.getErrors('subject'),
            errorRelations.getErrors('object'),
            errorRelations.getErrors('subject')
          ),
          duplicatedAttributes: errorAttributes.getErrors('unique'),
          hasError:
            errorDenotations.size ||
            errorBlocks.size ||
            errorAttributes.size ||
            errorRelations.size ||
            errorTypeSettings.size
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/parseTracks.js

    /* harmony default export */ function parseTracks(
      spanContainer,
      entityContainer,
      attributeContainer,
      relationContainer,
      text,
      spans,
      rowData
    ) {
      console.assert(rowData.tracks)

      const { tracks } = rowData
      delete rowData.tracks

      return tracks.map((track, i) => {
        const number = i + 1
        const trackNumber = `track${number}_`

        const { accept, reject } = validateAnnotation(text, spans, track)
        readAcceptedAnnotationTo(
          spanContainer,
          entityContainer,
          attributeContainer,
          relationContainer,
          accept,
          trackNumber
        )
        reject.name = `Track ${number} annotations.`
        return reject
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/getAllSpansOf.js

    // The boundraries of elements in the typesetings and
    // the denotations and blocks cannot cross each other.

    // The same is true when across the tracks.
    /* harmony default export */ function getAllSpansOf(rowData) {
      let spans = getAllSpansIn(rowData)

      if (rowData.tracks) {
        for (const track of rowData.tracks) {
          spans = spans.concat(getAllSpansIn(track))
        }
      }

      return spans
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/AnnotationParser/index.js

    class AnnotationParser {
      constructor(
        namespaceContainer,
        spanContainer,
        entityContainer,
        attributeContainer,
        relationContainer,
        rowData
      ) {
        this._namespaceContainer = namespaceContainer
        this._spanContainer = spanContainer
        this._entityContainer = entityContainer
        this._attributeContainer = attributeContainer
        this._relationContainer = relationContainer
        this._rowData = rowData
      }

      parse() {
        // Read namespaces
        if (this._rowData.namespaces) {
          this._namespaceContainer.addSource(
            this._rowData.namespaces.map((n) => ({
              id: n.prefix,
              ...n
            }))
          )
        } else {
          this._namespaceContainer.addSource([])
        }

        // Read the root annotation.
        const { accept, reject } = validateAnnotation(
          this._text,
          this._spans,
          this._rowData
        )

        readAcceptedAnnotationTo(
          this._spanContainer,
          this._entityContainer,
          this._attributeContainer,
          this._relationContainer,
          accept
        )

        reject.name = 'Root annotations.'
        this._rootReject = reject

        // Read multiple track annotations.
        if (this.hasMultiTracks) {
          this._trackRejects = parseTracks(
            this._spanContainer,
            this._entityContainer,
            this._attributeContainer,
            this._relationContainer,
            this._text,
            this._spans,
            this._rowData
          )
        }
      }

      get hasMultiTracks() {
        return Boolean(this._rowData.tracks)
      }

      get rejects() {
        if (this.hasMultiTracks) {
          return [this._rootReject].concat(this._trackRejects)
        } else {
          return [this._rootReject]
        }
      }

      get _text() {
        return this._rowData.text
      }

      get _spans() {
        return getAllSpansOf(this._rowData)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/clearAnnotationModel.js

    /* harmony default export */ function clearAnnotationModel(
      annotationModel
    ) {
      annotationModel.span.clear()
      annotationModel.entity.clear()
      annotationModel.attribute.clear()
      annotationModel.relation.clear()
      annotationModel.namespace.clear()
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/toDenotations.js

    /* harmony default export */ function toDenotations(annotationModel) {
      return annotationModel.entity.denotations.map((entity) => ({
        id: entity.id,
        span: {
          begin: entity.span.begin,
          end: entity.span.end
        },
        obj: entity.typeName
      }))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/toRelations.js

    /* harmony default export */ function toRelations(annotationModel) {
      return annotationModel.relation.all.map((r) => {
        return {
          id: r.id,
          pred: r.typeName,
          subj: r.subj,
          obj: r.obj
        }
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/toBlocks.js

    /* harmony default export */ function toBlocks(annotationModel) {
      return annotationModel.entity.blocks.map((entity) => ({
        id: entity.id,
        span: {
          begin: entity.span.begin,
          end: entity.span.end
        },
        obj: entity.typeName
      }))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/getReplicationRanges/getDuplicateSentenceFromText.js

    /* harmony default export */ function getDuplicateSentenceFromText(
      text,
      beginOfSentence,
      endOfSentence
    ) {
      const searchSentence = text.substring(beginOfSentence, endOfSentence)
      const sentenceLength = endOfSentence - beginOfSentence
      const findRanges = []

      let end = 0

      for (
        let begin = text.indexOf(searchSentence);
        begin !== -1;
        begin = text.indexOf(searchSentence, end)
      ) {
        end = begin + sentenceLength

        findRanges.push({
          begin,
          end
        })
      }

      return findRanges
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/getReplicationRanges/isWord.js

    // The preceding charactor and the following of a word charactor are delimiter.
    // For example, 't' ,a part of 'that', is not same with an origin span when it is 't'.
    /* harmony default export */ function isWord(
      sourceDoc,
      begin,
      end,
      isDelimiterFunc
    ) {
      const precedingChar = sourceDoc.charAt(begin - 1)
      const followingChar = sourceDoc.charAt(end)

      return isDelimiterFunc(precedingChar) && isDelimiterFunc(followingChar)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/getReplicationRanges/index.js

    // Check replications are word or not if spanConfig is set.
    /* harmony default export */ function getReplicationRanges(
      sourceDoc,
      beginOfSample,
      endOfSample,
      span,
      isDelimiterFunc
    ) {
      return getDuplicateSentenceFromText(sourceDoc, beginOfSample, endOfSample)
        .filter(
          ({ begin }) =>
            // The candidateSpan is a same span when begin is same.
            // Because string of each others are same. End of them are same too.
            begin !== beginOfSample
        )
        .filter(({ begin, end }) =>
          isWord(sourceDoc, begin, end, isDelimiterFunc)
        )
        .filter(({ begin, end }) => !span.hasDenotationSpan(begin, end))
        .filter(
          ({ begin, end }) => !span.isBoundaryCrossingWithOtherSpans(begin, end)
        )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/TypeGap.js

    class TypeGap {
      constructor(callback) {
        // The typeGap is changed from the Setting dialog or
        // by changing mode showing or not showing instances.
        this._isGapShown = true
        this._numberOfGap = 1
        this._callback = callback
      }

      set show(val) {
        if (this._isGapShown !== val) {
          this._isGapShown = val
          this._callback(this.value)
        }
      }

      get show() {
        return this._isGapShown
      }

      get value() {
        return this._isGapShown ? this._numberOfGap : 0
      }

      get height() {
        const typeGapUnitHeight = 24

        return this.value * typeGapUnitHeight
      }

      // The typeGap be able to be changed when mode showing instances.
      set value(val) {
        if (this._numberOfGap !== val) {
          this._numberOfGap = val
          this._callback(val)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/createTextBox/focusEditorWhenFocusedChildRemoved.js

    // Focus of the editor or children element is necessary to listen to keyboard events.
    // Elements be able to focused are the editor, spans and entity types.
    // The focus is lost when spans or entity types are remove.
    // Next elements are selected automatically by user deleting.
    // Next elements are not selected automatically by undo creation.
    // So, focus the editor when spans or entity types are removed and lost focus.
    /* harmony default export */ function focusEditorWhenFocusedChildRemoved(
      editorHTMLElement
    ) {
      // Observe a removing the focused document object.
      new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (
            mutation.removedNodes.length &&
            mutation.removedNodes[0].nodeType === 1
          ) {
            if (
              mutation.removedNodes[0].classList.contains(
                'textae-editor__span'
              ) ||
              mutation.removedNodes[0].classList.contains('textae-editor__type')
            ) {
              if (document.activeElement.tagName === 'BODY') {
                editorHTMLElement.focus()
              }
            }
          }
        })
      }).observe(editorHTMLElement.querySelector('.textae-editor__body'), {
        childList: true,
        subtree: true
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/createTextBox/TextBox/pixelToInt.js

    /* harmony default export */ function pixelToInt(str) {
      // The default value of google chrome line-height is "normal".
      // "normal" cannot be converted to an integer.
      const i = parseInt(str, 10)
      return isNaN(i) ? 0 : i
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/createTextBox/TextBox/getLineHeight.js

    /* harmony default export */ function getLineHeight(textBox) {
      const style = window.getComputedStyle(textBox)
      return pixelToInt(style.lineHeight)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/createTextBox/TextBox/setLineHeight.js

    /* harmony default export */ function setLineHeight(textBox, heightValue) {
      textBox.style.lineHeight = `${heightValue}px`
      textBox.style.paddingTop = `${heightValue / 2}px`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/createTextBox/TextBox/updateTextBoxHeight.js

    // Reduce the space under the .textae-editor__text-box same as padding-top.
    /* harmony default export */ function updateTextBoxHeight(textBox) {
      const style = window.getComputedStyle(textBox)

      // The height calculated by auto is exclude the value of the padding top.
      // Rest small space.
      textBox.style.height = 'auto'
      textBox.style.height = `${
        textBox.offsetHeight - pixelToInt(style.paddingTop) + 20
      }px`
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/createTextBox/TextBox/index.js

    class TextBox {
      constructor(editorHTMLElement, annotationModel) {
        this._editorHTMLElement = editorHTMLElement
        this._el = editorHTMLElement.querySelector('.textae-editor__text-box')
        this._annotationModel = annotationModel
      }

      get boundingClientRect() {
        return this._el.getBoundingClientRect()
      }

      get lineHeight() {
        return getLineHeight(this._el)
      }

      set lineHeight(val) {
        setLineHeight(this._el, val)
        this.forceUpdate()
        this._annotationModel.updatePosition()
      }

      render(text) {
        // https://stackoverflow.com/questions/6234773/can-i-escape-html-special-chars-in-javascript
        this._el.innerHTML = text
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;')
      }

      updateLineHeight() {
        const lineHeight = this._annotationModel.span.maxHeight

        if (lineHeight) {
          this.lineHeight = lineHeight
        } else {
          this._resetLineHeight()
        }
      }

      forceUpdate() {
        updateTextBoxHeight(this._el)
        this._updateSizeOfRelationBox()
      }

      _resetLineHeight() {
        // The default line height follows the editor's line height.
        const { lineHeight } = window.getComputedStyle(this._editorHTMLElement)
        this.lineHeight = pixelToInt(lineHeight)
      }

      _updateSizeOfRelationBox() {
        const relationBox = this._editorHTMLElement.querySelector(
          '.textae-editor__relation-box'
        )
        relationBox.style.height = this._el.style.height

        // When determining the width of one editor, vertical scroll bars are not needed,
        // and when annotations are loaded in another editor and vertical scroll bars appear,
        // the original editor is not wide enough and horizontal scroll bars appear.
        // Reduce the size of the relational display area to prevent horizontal scroll bars from appearing.
        // Why not resize the editor?
        // It is not possible to detect that a scroll bar has been displayed, so a notification is needed to change the height of the editor.
        // The editor does not have a notification mechanism.
        // It would be a big step to add a notification mechanism for this purpose.
        const width = parseFloat(window.getComputedStyle(this._el).width)
        relationBox.style.width = `${width - 10}px`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/createTextBox/index.js

    /* harmony default export */ function createTextBox(
      editorHTMLElement,
      annotationModel
    ) {
      // Place the text box behind the annotation box to allow you
      // to select the text behind the relationship label in entity editing mode.
      const html = `
    <div class="textae-editor__body">
      <div class="textae-editor__annotation-box"></div>
      <svg
        namespace="http://www.w3.org/2000/svg"
        class="textae-editor__relation-box">
      </svg>
      <div class="textae-editor__text-box"></div>
    </div>
    `
      // The editor itself has a "white-space: pre" style for processing text that contains a series of whitespace.
      // In this case, HTML line breaks are included in the editor's height calculation.
      // Remove CRLF so that it is not included in the height calculation.
      editorHTMLElement.innerHTML = html.replace(/[\n\r]+/g, '')
      focusEditorWhenFocusedChildRemoved(editorHTMLElement)

      return new TextBox(editorHTMLElement, annotationModel)
    }

    // EXTERNAL MODULE: ./node_modules/observ/index.js
    var observ = __webpack_require__(9462)
    var observ_default = /*#__PURE__*/ __webpack_require__.n(observ) // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/TypeDefinition.js
    class TypeDefinition {
      /**
       *
       * @param {import('../AttributeDefinitionContainer').default} attribute
       */
      constructor(
        eventEmitter,
        denotation,
        block,
        relation,
        attribute,
        configLocked = true
      ) {
        this._eventEmitter = eventEmitter
        this._denotationContainer = denotation
        this._blockContainer = block
        this._relationContainer = relation
        this._attributeContainer = attribute

        this._lockStateObservable = new (observ_default())(false)
        this._lockStateObservable(() =>
          this._eventEmitter.emit(`textae-event.type-definition.lock`)
        )
        this._lockStateObservable.set(configLocked)
      }

      get denotation() {
        return this._denotationContainer
      }

      get block() {
        return this._blockContainer
      }

      get relation() {
        return this._relationContainer
      }

      get attribute() {
        return this._attributeContainer
      }

      get config() {
        const ret = {}

        if (this._denotationContainer.config.length) {
          ret['entity types'] = this._denotationContainer.config
        }

        if (this._relationContainer.config.length) {
          ret['relation types'] = this._relationContainer.config
        }

        if (this._attributeContainer.config.length) {
          ret['attribute types'] = this._attributeContainer.config
        }

        if (this._blockContainer.config.length) {
          ret['block types'] = this._blockContainer.config
        }

        return ret
      }

      get isLock() {
        return this._lockStateObservable()
      }

      lockEdit() {
        this._lockStateObservable.set(true)
      }
      unlockEdit() {
        this._lockStateObservable.set(false)
      }

      setTypeConfig(config) {
        if (config) {
          this._denotationContainer.definedTypes = config['entity types'] || []
          this._relationContainer.definedTypes = config['relation types'] || []
          this._attributeContainer.definedTypes =
            config['attribute types'] || []
          this._blockContainer.definedTypes = config['block types'] || []
          this.autocompletionWs = config['autocompletion_ws']
        } else {
          this._denotationContainer.definedTypes = []
          this._relationContainer.definedTypes = []
          this._attributeContainer.definedTypes = []
          this._blockContainer.definedTypes = []
          this.autocompletionWs = ''
        }

        this._eventEmitter.emit(`textae-event.type-definition.reset`)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/formatForPallet/index.js

    /* harmony default export */ function formatForPallet(
      types,
      countMap,
      definedTypes,
      defaultType,
      defaultColor
    ) {
      return types.map((id) => ({
        id,
        label:
          (definedTypes.has(id) && definedTypes.get(id).label) || undefined,
        defaultType: id === defaultType,
        uri: getUrlMatches(id) ? id : undefined,
        color:
          (definedTypes.has(id) && definedTypes.get(id).color) || defaultColor,
        useNumber: countMap.get(id).usage
      }))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/DefinedTypeContainer/getConfig/getForwardMatchTypes.js

    /* harmony default export */ function getForwardMatchTypes(typeIds, id) {
      const forwardMatchTypes = []

      for (const definedType of typeIds) {
        if (
          definedType.indexOf('*') !== -1 &&
          id.indexOf(definedType.slice(0, -1)) === 0
        ) {
          forwardMatchTypes.push(definedType)
        }
      }

      return forwardMatchTypes
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/DefinedTypeContainer/getConfig/getLongestIdMatchType.js

    /* harmony default export */ function getLongestIdMatchType(typeIds) {
      let longestMatchId = ''

      for (const id of typeIds) {
        if (id.length > longestMatchId.length) {
          longestMatchId = id
        }
      }

      return longestMatchId
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/DefinedTypeContainer/getConfig/getForwardMatchType.js

    /* harmony default export */ function getForwardMatchType(
      definedTypes,
      id
    ) {
      // '*' at the last char of id means wildcard.
      const forwardMatchTypes = getForwardMatchTypes(definedTypes.ids(), id)

      if (forwardMatchTypes.length === 0) {
        return null
      }

      // If some wildcard-id are matched, return the type of the most longest matched.
      return definedTypes.get(getLongestIdMatchType(forwardMatchTypes))
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/DefinedTypeContainer/getConfig/index.js

    /* harmony default export */ function getConfig(definedTypes, id) {
      // Return value if perfectly matched
      if (definedTypes.has(id)) {
        return definedTypes.get(id)
      }

      // Return value if forward matched
      return getForwardMatchType(definedTypes, id)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/DefinedTypeContainer/index.js

    class DefinedTypeContainer {
      // Expected values is an array of object.
      // An example of object is {"id": "Regulation","color": "#FFFF66","default": true}.
      constructor(values) {
        // If the order of the type definitions changes,
        // it will be treated as a change, so preserve the order.
        this._list = values
      }

      has(id) {
        return this.map.has(id)
      }

      get(id) {
        return { ...this.map.get(id) }
      }

      replace(id, newType) {
        const index = this._list.findIndex((elem) => elem.id === id)

        if (index !== -1) {
          this._list.splice(index, 1, newType)
        } else {
          this._list.push(newType)
        }
      }

      delete(id) {
        this._list = this._list.filter((elem) => elem.id !== id)
      }

      ids() {
        return this.map.keys()
      }

      getConfig(id) {
        return getConfig(this, id)
      }

      labelIncludes(term) {
        return this._list
          .filter((t) => t.label)
          .filter((t) => t.label.includes(term))
      }

      get map() {
        return this._list.reduce((acc, cur) => acc.set(cur.id, cur), new Map())
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/sortByCountAndName.js

    /* harmony default export */ function sortByCountAndName(countTypeUse) {
      // Sort by number of types, and by name if numbers are same.
      const typeNames = Array.from(countTypeUse.keys())

      typeNames.sort((a, b) => {
        const diff = countTypeUse.get(b).usage - countTypeUse.get(a).usage
        return diff !== 0 ? diff : a > b ? 1 : a < b ? -1 : 0
      })

      return typeNames
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/countUsage.js

    /* harmony default export */ function countUsage(map, instances) {
      for (const [key, value] of map.entries()) {
        map.set(key, { ...value, usage: 0 })
      }

      return instances.reduce((countMap, { typeName }) => {
        countMap.get(typeName).usage += 1

        return countMap
      }, map)
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/DefinitionContainer/index.js

    class DefinitionContainer {
      constructor(
        eventEmitter,
        annotationType,
        getAllInstanceFunc,
        defaultColor
      ) {
        this._eventEmitter = eventEmitter
        this._annotationType = annotationType
        /** @type {DefinedTypeContainer} **/
        this._definedTypes = null
        this._getAllInstanceFunc = getAllInstanceFunc
        this._defaultColor = defaultColor
      }

      get annotationType() {
        return this._annotationType
      }

      set definedTypes(value) {
        this._definedTypes = new DefinedTypeContainer(value)

        // Set default type
        const defaultType = value.find((type) => type.default === true)
        if (defaultType) {
          delete defaultType.default
          this._defaultType = defaultType.id
        } else {
          this._defaultType = null
        }
      }

      has(id) {
        return this._definedTypes.has(id)
      }

      get(id) {
        const type = { ...this._definedTypes.get(id) }

        if (this._defaultType === id) {
          type.default = true
          return type
        } else {
          delete type.default
          return type
        }
      }

      replace(id, newType) {
        this._definedTypes.replace(id, newType)
        this._eventEmitter.emit(
          `textae-event.type-definition.${this._annotationType}.change`,
          newType.id
        )
      }

      addDefinedType(newType) {
        if (typeof newType.color === 'undefined') {
          const forwardMatchColor = this.getColor(newType.id)
          if (forwardMatchColor !== this._defaultColor) {
            newType.color = forwardMatchColor
          }
        }

        if (typeof newType.label === 'undefined') {
          const forwardMatchLabel = this.getLabel(newType.id)
          if (forwardMatchLabel) {
            newType.label = forwardMatchLabel
          }
        }

        if (newType.default) {
          this._defaultType = newType.id
        }

        this.replace(newType.id, newType)
      }

      get definedTypes() {
        return this._definedTypes
      }

      // Return the type that has the default property or the most used type.
      get defaultType() {
        if (this._defaultType) {
          return this._defaultType
        }

        if (this._getAllInstanceFunc().length > 0) {
          return sortByCountAndName(
            countUsage(this._typeMap, this._getAllInstanceFunc())
          )[0]
        }

        return 'something'
      }

      // The default value can be removed.
      set defaultType(id) {
        this._defaultType = id
        this._eventEmitter.emit(
          `textae-event.type-definition.${this._annotationType}.change-default`,
          id
        )
      }

      get defaultColor() {
        return this._defaultColor
      }

      getColor(id) {
        const config = this._definedTypes.getConfig(id)
        return (config && config.color) || this._defaultColor
      }

      getLabel(id) {
        const config = this._definedTypes.getConfig(id)
        return config && config.label
      }

      getURI(id) {
        return getUrlMatches(id) ? id : undefined
      }

      findByLabel(term) {
        return this.definedTypes.labelIncludes(term)
      }

      get pallet() {
        const countMap = countUsage(this._typeMap, this._getAllInstanceFunc())
        const types = sortByCountAndName(countMap)

        return formatForPallet(
          types,
          countMap,
          this._definedTypes,
          this.defaultType,
          this._defaultColor
        )
      }

      get config() {
        const types = this._typeMap

        // Make default type and delete defalut type from original configuratian.
        for (const [key, type] of types.entries()) {
          // Make a copy so as not to destroy the original object.
          const copy = { ...type }
          if (type.id === this.defaultType) {
            copy.default = true
          } else {
            delete copy.default
          }
          types.set(key, copy)
        }

        return [...types.values()]
      }

      get _typeMap() {
        // Get type definitions.
        // Copy map to add definitions from instance.
        const types = this._definedTypes.map

        // Get types from instances.
        for (const { typeName } of this._getAllInstanceFunc()) {
          if (!types.has(typeName)) {
            types.set(typeName, { id: typeName })
          }
        }

        return types
      }

      delete(id, defaultType) {
        this._definedTypes.delete(id)
        this._defaultType = defaultType
        this._eventEmitter.emit(
          `textae-event.type-definition.${this._annotationType}.delete`,
          id
        )
      }
    } // CONCATENATED MODULE: ./node_modules/array-move/index.js

    function arrayMoveMutable(array, fromIndex, toIndex) {
      const startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex

      if (startIndex >= 0 && startIndex < array.length) {
        const endIndex = toIndex < 0 ? array.length + toIndex : toIndex

        const [item] = array.splice(fromIndex, 1)
        array.splice(endIndex, 0, item)
      }
    }

    function arrayMoveImmutable(array, fromIndex, toIndex) {
      array = [...array]
      arrayMoveMutable(array, fromIndex, toIndex)
      return array
    } // CONCATENATED MODULE: ./src/lib/AttributeDefinition.js

    class AttributeDefinition {
      constructor(valueType, pred) {
        this.valueType = valueType
        this.pred = pred
      }

      get values() {
        console.assert(this._values, 'this._values to return!')

        return this._values
      }

      get externalFormat() {
        return {
          pred: this.pred
        }
      }

      get _valuesClone() {
        console.assert(this._values, 'this._values is necessary to clone!')

        const values = []
        for (const value of this._values) {
          values.push({ ...value })
        }
        return values
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/FlagAttributeDefinition.js

    class FlagAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this.default = true
        this.label = hash.label
        this.color = hash.color
      }

      getLabel() {
        return this.label
      }

      getDisplayName() {
        if (this.label) {
          return this.label
        }

        return this.pred
      }

      getColor() {
        return this.color
      }

      get externalFormat() {
        return {
          ...super.externalFormat,
          ...{
            'value type': 'flag',
            default: this.default,
            label: this.label,
            color: this.color
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/gte.js

    /* harmony default export */ function gte(left, right) {
      return left <= right
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/gt.js

    /* harmony default export */ function gt(left, right) {
      return left < right
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/getLowwerCond.js

    /* harmony default export */ function getLowwerCond(str) {
      if (str.startsWith('[')) {
        return (right) => gte(new Number(str.replace('[', '')), right)
      }
      if (str.startsWith('(')) {
        return (right) => gt(new Number(str.replace('(', '')), right)
      }
      throw `${str} is not valid interval notation`
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/getUpperCond.js

    /* harmony default export */ function getUpperCond(str) {
      if (str.endsWith(']')) {
        return (left) => gte(left, new Number(str.replace(']', '')))
      }
      if (str.endsWith(')')) {
        return (left) => gt(left, new Number(str.replace(')', '')))
      }
      throw `${str} is not valid interval notation`
    } // CONCATENATED MODULE: ./src/lib/IntervalNotation/index.js

    // https://www.varsitytutors.com/hotmath/hotmath_help/topics/interval-notation
    class IntervalNotation {
      constructor(str) {
        const [left, right] = str.split(',')

        if (!right) {
          if (left.startsWith('[') || left.startsWith('(')) {
            // Upper limit is omitted
            this._lowwerCond = getLowwerCond(left)
            this._upperCond = (_) => true
          }

          if (left.endsWith(']') || left.endsWith(')')) {
            // Lowwer limit is omitted
            this._lowwerCond = (_) => true
            this._upperCond = getUpperCond(left)
          }
        } else {
          this._lowwerCond = getLowwerCond(left)
          this._upperCond = getUpperCond(right)
        }

        if (!this._lowwerCond || !this._upperCond) {
          throw `${str} is not valid interval notation`
        }
      }

      test(value) {
        return this._lowwerCond(value) && this._upperCond(value)
      }
    } // CONCATENATED MODULE: ./src/lib/isAbleToParseFloat.js

    /* harmony default export */ function isAbleToParseFloat(str) {
      return !Number.isNaN(parseFloat(str))
    } // CONCATENATED MODULE: ./src/lib/NumericAttributeDefinition.js

    const DEFAULT = 0
    const STEP = 2

    class NumericAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this.default = isAbleToParseFloat(hash.default)
          ? parseFloat(hash.default)
          : DEFAULT
        if (isAbleToParseFloat(hash.min)) {
          this.min = parseFloat(hash.min)
        }
        if (isAbleToParseFloat(hash.max)) {
          this.max = parseFloat(hash.max)
        }
        this.step = isAbleToParseFloat(hash.step) ? parseFloat(hash.step) : STEP
        this._values = hash.values || []
      }

      getLabel(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.label) {
          return def.label
        }
      }

      getDisplayName(obj) {
        return this.getLabel(obj) || String(obj)
      }

      getColor(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.color) {
          return def.color
        }

        return null
      }

      _getMatchedValue(obj) {
        const match = this._values
          .filter((a) => a.range !== 'default')
          .find((a) => new IntervalNotation(a.range).test(obj))

        if (match) {
          return match
        }

        const defaultValue = this._values.find((a) => a.range === 'default')
        if (defaultValue) {
          return defaultValue
        }

        return null
      }

      get externalFormat() {
        return {
          ...super.externalFormat,
          ...{
            'value type': 'numeric',
            default: this.default,
            min: this.min,
            max: this.max,
            step: this.step,
            values: super._valuesClone
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/SelectionAttributeDefinition.js

    class SelectionAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this._values = hash.values || []
      }

      get default() {
        return this.values.find((a) => a.default).id
      }

      getLabel(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.label) {
          return def.label
        }
      }

      getDisplayName(obj) {
        return this.getLabel(obj)
      }

      getColor(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.color) {
          return def.color
        }

        return null
      }

      get values() {
        return this._values
      }

      get hasOnlyOneValue() {
        return this._values.length === 1
      }

      _getMatchedValue(obj) {
        return this.values.find((a) => a.id == obj)
      }

      get externalFormat() {
        return {
          ...super.externalFormat,
          ...{
            'value type': 'selection',
            values: super._valuesClone
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/StringAttributeDefinition.js

    class StringAttributeDefinition extends AttributeDefinition {
      constructor(valueType, hash) {
        super(valueType, hash.pred)
        this.autocompletionWs = hash.autocompletion_ws
        this.default = hash.default
        if (isAbleToParseFloat(hash['media height'])) {
          this.mediaHeight = parseFloat(hash['media height'])
        }
        this._values = hash.values || []
      }

      getLabel(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.label) {
          return def.label
        }
      }

      getDisplayName(obj) {
        return this.getLabel(obj)
      }

      getColor(obj) {
        const def = this._getMatchedValue(obj)

        if (def && def.color) {
          return def.color
        }

        return null
      }

      _getMatchedValue(obj) {
        const match = this._values
          .filter((a) => a.pattern !== 'default')
          .find((a) => new RegExp(a.pattern).test(obj))

        if (match) {
          return match
        }

        const defaultValue = this._values.find((a) => a.pattern === 'default')
        if (defaultValue) {
          return defaultValue
        }

        return null
      }

      get externalFormat() {
        return {
          ...super.externalFormat,
          ...{
            'value type': 'string',
            autocompletion_ws: this.autocompletionWs,
            default: this.default,
            values: super._valuesClone,
            'media height': this.mediaHeight
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/createAttributeDefinition/index.js

    /* harmony default export */ function createAttributeDefinition(
      valueType,
      hash
    ) {
      switch (valueType) {
        case 'flag':
          return new FlagAttributeDefinition(valueType, hash)
        case 'numeric':
          return new NumericAttributeDefinition(valueType, hash)
        case 'selection':
          return new SelectionAttributeDefinition(valueType, hash)
        case 'string':
          return new StringAttributeDefinition(valueType, hash)
        default:
          throw new Error(
            `${valueType} of ${JSON.stringify(hash)} is Uknown Attribute`
          )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AttributeDefinitionContainer/index.js

    class AttributeDefinitionContainer {
      constructor(eventEmitter, getAllInstanceFunc) {
        this._eventEmitter = eventEmitter
        this._getAllInstanceFunc = getAllInstanceFunc
      }

      set definedTypes(attributes) {
        this._definedTypes = new Map(
          (attributes || []).map((a) => [
            a.pred,
            createAttributeDefinition(a['value type'], a)
          ])
        )
      }

      create(valueType, attrDef, index = null) {
        // To restore the position of a deleted attribute,
        // insert the new attribute at the specified index, if specified.
        // Note: 0 is false in JavaScript
        // When index and the number of attribute definitions are the same,
        // the position of the deleted definition is the last. Add to the end of the attribute definition.
        if (index !== null && this._definedTypes.size !== index) {
          this._definedTypes = new Map(
            Array.from(this._definedTypes.entries()).reduce(
              (acc, [key, val], i) => {
                if (i === index) {
                  acc.push([
                    attrDef.pred,
                    createAttributeDefinition(valueType, attrDef)
                  ])
                }
                acc.push([key, val])

                return acc
              },
              []
            )
          )
        } else {
          this._definedTypes.set(
            attrDef.pred,
            createAttributeDefinition(valueType, attrDef)
          )
        }

        this._eventEmitter.emit(
          `textae-event.type-definition.attribute.create`,
          attrDef.pred
        )
      }

      get(pred) {
        return this._definedTypes.get(pred)
      }

      update(oldPred, attrDef) {
        // Predicate as key of map may be changed.
        // Keep oreder of attributes.
        // So that re-create an map instance.
        this._definedTypes = new Map(
          Array.from(this._definedTypes.entries()).map(([key, val]) => {
            if (key === oldPred) {
              return [
                attrDef.pred,
                createAttributeDefinition(val.valueType, attrDef)
              ]
            } else {
              return [key, val]
            }
          })
        )

        this._eventEmitter.emit(
          `textae-event.type-definition.attribute.change`,
          attrDef.pred
        )

        return this.get(attrDef.pred)
      }

      updateValues(pred, values) {
        const hash = this.get(pred).externalFormat
        return this.update(pred, { ...hash, ...{ values } })
      }

      move(oldIndex, newIndex) {
        this._definedTypes = new Map(
          arrayMoveImmutable(this.attributes, oldIndex, newIndex).map((a) => [
            a.pred,
            a
          ])
        )

        // -1 points to the end of the array.
        const { pred } =
          this.attributes[
            newIndex === -1 ? this.attributes.length - 1 : newIndex
          ]

        // When an attribute definition move is undoed,
        // it fires an event to notify the palette to immediately reflect the display content.
        this._eventEmitter.emit(
          `textae-event.type-definition.attribute.move`,
          pred
        )
      }

      delete(pred) {
        this._definedTypes.delete(pred)
        this._eventEmitter.emit(`textae-event.type-definition.attribute.delete`)
      }

      get attributes() {
        return Array.from(this._definedTypes.values()) || []
      }

      get config() {
        return this.attributes.map((a) => a.externalFormat)
      }

      isSelectionAttributeValueIndelible(pred, id) {
        if (this.get(pred).hasOnlyOneValue) {
          return true
        }

        // If there is an instance that uses a selection attribute, do not delete it.
        if (this._getAllInstanceFunc().some((a) => a.equalsTo(pred, id))) {
          return true
        }

        return false
      }

      getLabel(pred, obj) {
        console.assert(
          this._definedTypes.has(pred),
          `There is no attribute definition for ${pred}.`
        )

        return this.get(pred).getLabel(obj)
      }

      getDisplayName(pred, obj) {
        console.assert(
          this._definedTypes.has(pred),
          `There is no attribute definition for ${pred}.`
        )

        return this.get(pred).getDisplayName(obj)
      }

      getColor(pred, obj) {
        if (this._definedTypes.has(pred)) {
          return this.get(pred).getColor(obj)
        }
      }

      getIndexOf(pred) {
        return Array.from(this._definedTypes.values()).findIndex(
          (a) => a.pred === pred
        )
      }

      getAttributeAt(number) {
        return Array.from(this._definedTypes.values())[number - 1]
      }

      attributeCompareFunction(a, b) {
        // Order by attribute definition order.
        const indexOfA = this.getIndexOf(a.pred)
        const indexOfB = this.getIndexOf(b.pred)
        if (indexOfA !== indexOfB) {
          return indexOfA - indexOfB
        }

        if (a.id && b.id) {
          return a.id.localeCompare(b.id)
        }

        return 0
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/LineHeightAuto.js

    class LineHeightAuto {
      /**
       *
       * @param {import('./createTextBox/TextBox').default} textBox
       */
      constructor(eventEmitter, textBox) {
        this._textBox = textBox
        this._enable = false

        eventEmitter.on(
          'textae-event.control.button.push',
          ({ name, isPushed }) => {
            if (name === 'auto adjust lineheight') {
              this._enable = isPushed
            }
          }
        )
      }

      updateLineHeight() {
        if (this._enable) {
          this._textBox.updateLineHeight()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModel/index.js

    class AnnotationModel {
      constructor(
        editorID,
        editorHTMLElement,
        eventEmitter,
        editorCSSClass,
        startJQueryUIDialogWait,
        endJQueryUIDialogWait,
        isConfigLocked
      ) {
        this._sourceDoc = ''
        this.namespace = new InstanceContainer(eventEmitter, 'namespace')
        const relationDefinitionContainer = new DefinitionContainer(
          eventEmitter,
          'relation',
          () => this.relation.all,
          '#00CC66'
        )

        this.relation = new RelationInstanceContainer(
          editorHTMLElement,
          eventEmitter,
          this,
          this.namespace,
          relationDefinitionContainer
        )
        this._typeGap = new TypeGap(() => {
          for (const entity of this.entity.denotations) {
            entity.reflectTypeGapInTheHeight()
          }
          this._textBox.updateLineHeight()
          eventEmitter.emit('textae-event.annotation-data.entity-gap.change')
        })

        this.entity = new EntityInstanceContainer(
          editorID,
          eventEmitter,
          this,
          this._typeGap,
          this.namespace
        )

        this.attributeDefinitionContainer = new AttributeDefinitionContainer(
          eventEmitter,
          () => this.attribute.all
        )
        this.attribute = new AttributeInstanceContainer(
          eventEmitter,
          this.entity,
          this.relation,
          this.namespace,
          this.attributeDefinitionContainer
        )

        this.updatePosition = () => {
          try {
            editorCSSClass.startWait()
            startJQueryUIDialogWait()

            this._rearrangeAllAnnotations()
          } catch (e) {
            console.error(e)
          } finally {
            editorCSSClass.endWait()
            endJQueryUIDialogWait()
          }
        }
        this._textBox = createTextBox(editorHTMLElement, this)
        this._lineHeightAuto = new LineHeightAuto(eventEmitter, this._textBox)
        this.span = new SpanInstanceContainer(
          editorID,
          editorHTMLElement,
          eventEmitter,
          this.entity,
          this._textBox
        )

        this.denotationDefinitionContainer = new DefinitionContainer(
          eventEmitter,
          'entity',
          () => this.entity.denotations,
          '#77DDDD'
        )
        const blockDefinitionContainer = new DefinitionContainer(
          eventEmitter,
          'entity',
          () => this.entity.blocks,
          '#77DDDD'
        )
        this._typeDefinition = new TypeDefinition(
          eventEmitter,
          this.denotationDefinitionContainer,
          blockDefinitionContainer,
          relationDefinitionContainer,
          this.attributeDefinitionContainer,
          isConfigLocked
        )

        eventEmitter
          .on('textae-event.annotation-data.span.add', (span) => {
            if (span.isDenotation || span.isBlock) {
              this._textBox.forceUpdate()
              this._rearrangeAllAnnotations()
            }
          })
          .on('textae-event.annotation-data.span.remove', (span) => {
            if (span.isDenotation || span.isBlock) {
              this._textBox.forceUpdate()
              this._rearrangeAllAnnotations()
            }
          })
          .on('textae-event.annotation-data.entity.add', (entity) => {
            if (entity.span.isDenotation) {
              this._lineHeightAuto.updateLineHeight()
            }
          })
          .on('textae-event.annotation-data.entity.remove', (entity) => {
            if (entity.span.isDenotation) {
              this._lineHeightAuto.updateLineHeight()
            }
          })

        // Bind type-definition events.
        eventEmitter
          .on('textae-event.type-definition.entity.change', (typeName) => {
            for (const entity of this.entity.all) {
              // If the type name ends in a wildcard, look for the DOMs to update with a forward match.
              if (
                entity.typeName === typeName ||
                (typeName.lastIndexOf('*') === typeName.length - 1 &&
                  entity.typeName.indexOf(typeName.slice(0, -1) === 0))
              ) {
                entity.updateElement()
              }
            }
          })
          .on('textae-event.type-definition.attribute.change', (pred) =>
            this.entity.redrawEntitiesWithSpecifiedAttribute(pred)
          )
          .on('textae-event.type-definition.attribute.move', (pred) =>
            this.entity.redrawEntitiesWithSpecifiedAttribute(pred)
          )
          .on('textae-event.type-definition.relation.change', (typeName) => {
            for (const relation of this.relation.all) {
              // If the type name ends in a wildcard, look for the DOMs to update with a forward match.
              if (
                relation.typeName === typeName ||
                (typeName.lastIndexOf('*') === typeName.length - 1 &&
                  relation.typeName.indexOf(typeName.slice(0, -1) === 0))
              ) {
                relation.updateElement()
              }
            }
          })

        this._editorHTMLElement = editorHTMLElement
        this._eventEmitter = eventEmitter
      }

      reset(rawData, config) {
        console.assert(rawData.text, 'This is not a json file of annotations.')

        this._typeDefinition.setTypeConfig(config)
        this._sourceDoc = rawData.text
        this._textBox.render(this.sourceDoc)

        clearAnnotationModel(this)
        const { namespace, span, entity, attribute, relation } = this
        const annotationParser = new AnnotationParser(
          namespace,
          span,
          entity,
          attribute,
          relation,
          rawData
        )
        annotationParser.parse()

        this._clearAndDrawAllAnnotations()

        this._eventEmitter.emit(
          'textae-event.annotation-data.all.change',
          this,
          annotationParser.hasMultiTracks,
          annotationParser.rejects
        )

        // When reading some annotation Grid may be drawn out of alignment.
        // For example, http://pubannotation.org/projects/GlyCosmos6-Glycan-Motif-Structure/docs/sourcedb/PubMed/sourceid/3571288/annotations.json .
        // This seems to happen especially when the browser is wide with only one editor.
        // The true cause is unknown, but it can be avoided by doing the layout twice.
        this.reLayout()
      }

      get externalFormat() {
        return {
          denotations: toDenotations(this),
          attributes: this.attribute.all.map(
            ({ externalFormat }) => externalFormat
          ),
          relations: toRelations(this),
          blocks: toBlocks(this)
        }
      }

      getReplicationRanges(span, isDelimiterFunc) {
        return getReplicationRanges(
          this.sourceDoc,
          span.begin,
          span.end,
          this.span,
          isDelimiterFunc
        )
      }

      get typeGap() {
        return this._typeGap
      }

      get textBox() {
        return this._textBox
      }

      get sourceDoc() {
        // Since 6.0.0, the text-box is set to "white-space: pre-wrap;"
        // in order to render line breaks contained in text as they are in the browser.
        // "\r\n" is rendered as a single character.
        // Replace "\r\n" with "\n" so that the browser can render "\r\n" as two characters.
        return this._sourceDoc.replaceAll(/\r\n/g, ' \n')
      }

      get typeDefinition() {
        return this._typeDefinition
      }

      drawGridsInSight() {
        if (this._isEditorInSight) {
          const { clientHeight, clientWidth } = document.documentElement

          for (const span of this.span.allDenotationSpans) {
            span.drawGrid(clientHeight, clientWidth)
          }

          for (const span of this.span.allBlockSpans) {
            span.drawGrid(clientHeight, clientWidth)
            span.updateBackgroundPosition()
          }

          for (const relation of this.relation.all) {
            relation.render(clientHeight, clientWidth)
          }
        }
      }

      reLayout() {
        this._textBox.forceUpdate()

        if (this._isEditorInSight) {
          this.updatePosition()
        }
      }

      /** @param {number} value */
      set controlBarHeight(value) {
        this.entity.controlBarHeight = value
        this.relation.controlBarHeight = value
      }

      get _isEditorInSight() {
        const { clientHeight } = document.documentElement
        const { top, bottom } = this._editorHTMLElement.getBoundingClientRect()

        return 0 <= bottom && top <= clientHeight
      }

      focusDenotation(denotationID) {
        console.assert(
          this.entity.hasDenotation(denotationID),
          'The denotation does not exist.'
        )

        const { span } = this.entity.get(denotationID)
        span.focus()
      }

      _clearAndDrawAllAnnotations() {
        getAnnotationBox(this._editorHTMLElement).innerHTML = ''

        this._textBox.updateLineHeight()

        for (const span of this.span.topLevel) {
          span.render()
        }

        // Reflects the addition and deletion of line breaks by span.
        this._textBox.forceUpdate()

        const { clientHeight, clientWidth } = document.documentElement

        for (const span of this.span.allDenotationSpans) {
          span.drawGrid(clientHeight, clientWidth)
        }

        for (const span of this.span.allBlockSpans) {
          span.drawGrid(clientHeight, clientWidth)
        }

        for (const relation of this.relation.all) {
          relation.render(clientHeight, clientWidth)
        }
      }

      _rearrangeAllAnnotations() {
        this.span.arrangeDenotationEntityPosition()

        // When you undo the deletion of a block span,
        // if you move the background first, the grid will move to a better position.
        this.span.arrangeBackgroundOfBlockSpanPosition()
        this.span.arrangeBlockEntityPosition()

        for (const relation of this.relation.all) {
          // The Grid disappears while the span is moving.
          if (
            relation.sourceEntity.span.isGridRendered &&
            relation.targetEntity.span.isGridRendered
          ) {
            relation.redrawLineConsideringSelection()
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/SpanConfig.js

    const defaults = {
      'delimiter characters': [
        ' ',
        '.',
        '!',
        '?',
        ',',
        ':',
        ';',
        '-',
        '/',
        '&',
        '(',
        ')',
        '{',
        '}',
        '[',
        ']',
        '+',
        '*',
        '\\',
        '"',
        "'",
        '\n',
        '–'
      ],
      'non-edge characters': [' ', '\n']
    }

    class SpanConfig {
      constructor() {
        this._delimiterCharacters = []
        this._blankCharacters = []
      }

      set(config) {
        const settings = { ...defaults, ...config }

        this._delimiterCharacters = settings['delimiter characters']
        this._blankCharacters = settings['non-edge characters']
        return config
      }

      isDelimiter(char) {
        if (this._delimiterCharacters.indexOf('ANY') >= 0) {
          return 1
        }

        return this._delimiterCharacters.indexOf(char) >= 0
      }

      isBlankCharacter(char) {
        return this._blankCharacters.indexOf(char) >= 0
      }

      removeBlankChractors(str) {
        for (const char of this._blankCharacters) {
          str = str.replaceAll(char, '')
        }

        return str
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/History.js

    // histories of edit to undo and redo.
    class History {
      constructor(eventEmitter) {
        this._resetHistory()
        this._eventEmitter = eventEmitter

        eventEmitter
          .on('textae-event.type-definition.reset', () => {
            this._removeConfigurationOperationsFromHistory()
            this._trigger()
          })
          .on('textae-event.annotation-data.all.change', () => {
            this._resetHistory()
            this._trigger()
          })
          .on('textae-event.resource.annotation.save', () => {
            this._trigger()
          })
          .on('textae-event.resource.configuration.save', () => {
            this._trigger()
          })
      }

      push(command) {
        // Delete the following history.
        this._histories.splice(
          this._pointer + 1,
          this._histories.length - this._pointer,
          command
        )
        this._pointer++
        this._trigger()
      }

      next() {
        this._pointer++
        const next = this._histories[this._pointer]
        this._trigger()
        return next
      }

      prev() {
        const prev = this._histories[this._pointer]
        this._pointer--
        this._trigger()
        return prev
      }

      get hasAnythingToUndo() {
        return this._pointer > -1
      }

      get hasAnythingToRedo() {
        return this._pointer < this._histories.length - 1
      }

      _trigger() {
        this._eventEmitter.emit('textae-event.history.change', this)
      }

      _removeConfigurationOperationsFromHistory() {
        for (let i = 0; i < this._histories.length; i++) {
          if (this._histories[i].isExactly('configuration_command')) {
            this._pointer--
            this._histories.splice(i, 1)
          }
        }
      }

      _resetHistory() {
        this._pointer = -1
        this._histories = []
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/commandLog.js

    /* harmony default export */ function commandLog(self, message, object) {
      // For debug
      if (object) {
        console.log(`[${self.constructor.name}]`, message, object)
      } else {
        console.log(`[${self.constructor.name}]`, message)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/BaseCommand.js

    class BaseCommand {
      get isEmpty() {
        return false
      }

      isExactly(kind) {
        return this.kind.has(kind) && this.kind.size === 1
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/AnnotationCommand.js

    class AnnotationCommand extends BaseCommand {
      get kind() {
        return new Set(['annotation_command'])
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/commandTemplate.js

    class CreateCommand extends AnnotationCommand {
      constructor(
        annotationModel,
        annotationType,
        instance,
        selectionModel = null
      ) {
        super()
        this._annotationModel = annotationModel
        this._annotationType = annotationType
        this._instance = instance
        this._selectionModel = selectionModel
      }

      execute() {
        this._instance = this._annotationModel[this._annotationType].add(
          this._instance
        )

        if (this._selectionModel) {
          this._selectionModel.add(this._annotationType, [this._instance.id])
        }

        commandLog(this, `${this._annotationType}: ${this._instance.id}`)
      }

      revert() {
        return new RemoveCommand(
          this._annotationModel,
          this._annotationType,
          this._instance
        )
      }
    }

    class RemoveCommand extends AnnotationCommand {
      constructor(annotationModel, annotationType, instance) {
        super()
        this._annotationModel = annotationModel
        this._annotationType = annotationType
        this._instance = instance
      }

      execute() {
        this._annotationModel[this._annotationType].remove(this._instance.id)

        commandLog(this, `${this._annotationType}: ${this._instance.id}`)
      }

      revert() {
        return new CreateCommand(
          this._annotationModel,
          this._annotationType,
          this._instance
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ConfigurationCommand.js

    class ConfigurationCommand extends BaseCommand {
      get kind() {
        return new Set(['configuration_command'])
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/RemoveValueFromAttributeDefinitionCommand.js

    class RemoveValueFromAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(
        definitionContainer,
        attrDef,
        index,
        indexThatAddDefaultTo = null
      ) {
        super()
        this._definitionContainer = definitionContainer
        this._attrDef = attrDef
        this._index = index
        this._indexThatAddDefaultTo = indexThatAddDefaultTo
      }

      execute() {
        const values = [...this._attrDef.values]
        // When removing value with default property.
        if (
          this._attrDef.valueType === 'selection' &&
          values[this._index].default &&
          this._indexThatAddDefaultTo === null
        ) {
          let indexThatAddDefaultTo = null

          values.forEach((_, index) => {
            if (indexThatAddDefaultTo === null && index != this._index) {
              indexThatAddDefaultTo = index
            }
          })

          values[indexThatAddDefaultTo] = {
            ...values[indexThatAddDefaultTo],
            ...{ default: true }
          }
        }

        this._deletedValue = values.splice(this._index, 1)[0]

        // When undoing to add new value with default property.
        if (
          this._attrDef.valueType === 'selection' &&
          this._indexThatAddDefaultTo !== null
        ) {
          values[this._indexThatAddDefaultTo] = {
            ...values[this._indexThatAddDefaultTo],
            ...{ default: true }
          }
        }

        this._updatedAttrDef = this._definitionContainer.updateValues(
          this._attrDef.pred,
          values
        )

        commandLog(
          this,
          `remove a value from an attrribute:${this._attrDef.pred}, index:${
            this._index
          }, updated values: \n ${values
            .map((v) => JSON.stringify(v))
            .join('\n ')}`
        )
      }

      revert() {
        return new AddValueToAttributeDefinitionCommand(
          this._definitionContainer,
          this._updatedAttrDef,
          this._deletedValue,
          this._index
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/AddValueToAttributeDefinitionCommand.js

    class AddValueToAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, attrDef, value, index = null) {
        super()
        this._definitionContainer = definitionContainer
        this._pred = attrDef.pred
        this._index = index
        this._value = value

        const values = [...attrDef.values]
        if (attrDef.valueType === 'selection') {
          // When adding default, remove default property from existing default value.
          if (value.default) {
            if (!this._indexThatRemoveDefaultFrom) {
              this._indexThatRemoveDefaultFrom = values.findIndex(
                (v) => v.default
              )
            }

            const newValue = { ...values[this._indexThatRemoveDefaultFrom] }
            delete newValue.default
            values[this._indexThatRemoveDefaultFrom] = newValue
          }
        }

        // When undoing, insert to the position before remove.
        // The array of values is a copy. If you add values to the array of values when the command executes,
        // the value object will increase each time the command is executed.
        values.splice(index || values.length, 0, value)

        this._modifiedValues = values
      }

      execute() {
        this._updatedAttrDef = this._definitionContainer.updateValues(
          this._pred,
          this._modifiedValues
        )

        commandLog(
          this,
          `add a new value to attrribute:${this._pred}, value: ${JSON.stringify(
            this._value
          )}, index: ${this._index}, updated values: \n ${this._modifiedValues
            .map((v) => JSON.stringify(v))
            .join('\n ')}`
        )
      }

      revert() {
        return new RemoveValueFromAttributeDefinitionCommand(
          this._definitionContainer,
          this._updatedAttrDef,
          this._updatedAttrDef.values.length - 1,
          this._indexThatRemoveDefaultFrom
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CompositeCommand.js

    class CompositeCommand extends BaseCommand {
      constructor() {
        super()
        this._isExecuteSubCommandsInReverseOrderWhenRevert = true
      }

      execute() {
        console.assert(this._subCommands, '_subCommands is necessary!')

        // If subCommands is empty, pretend to be executed and don't log.
        if (this.isEmpty) {
          this.revert = () => ({
            execute() {}
          })
          return
        }

        for (const c of this._subCommands) {
          c.execute()
        }

        if (this._afterInvoke) {
          this._afterInvoke()
        }

        const self = this
        this.revert = () => ({
          _subCommands: this._subCommands,
          _logMessage: this._logMessage,
          _afterInvoke: this._afterInvoke,
          _isExecuteSubCommandsInReverseOrderWhenRevert:
            this._isExecuteSubCommandsInReverseOrderWhenRevert,
          execute() {
            let subCommands = this._subCommands.map((c) => c.revert())

            if (this._isExecuteSubCommandsInReverseOrderWhenRevert) {
              subCommands = subCommands.reverse()
            }

            for (const c of subCommands) {
              c.execute()
            }

            if (this._afterInvoke) {
              this._afterInvoke()
            }

            commandLog(self, `revert: ${this._logMessage}`)
          }
        })
        commandLog(this, this._logMessage)
      }

      get kind() {
        return this._subCommands.reduce(
          (acc, curr) => new Set([...acc, ...curr.kind]),
          new Set()
        )
      }

      get isEmpty() {
        return !this._subCommands || this._subCommands.length === 0
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeAttributeDefinitionAndRefectInstancesCommand/ChangeAttributeDefinitionCommand/applyChangedProperties.js

    /* harmony default export */ function applyChangedProperties(
      oldAttrDef,
      changedProperties
    ) {
      const newAttrDef = oldAttrDef.externalFormat
      const revertChangedProperties = new Map()
      // change config
      for (const [key, property] of changedProperties.entries()) {
        if (property === null && typeof oldAttrDef[key] !== 'undefined') {
          delete newAttrDef[key]
          revertChangedProperties.set(key, oldAttrDef[key])
        } else if (property !== null) {
          newAttrDef[key] = property
          revertChangedProperties.set(
            key,
            typeof oldAttrDef[key] === 'undefined' ? null : oldAttrDef[key]
          )
        }
      }
      return [newAttrDef, revertChangedProperties]
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeAttributeDefinitionAndRefectInstancesCommand/ChangeAttributeDefinitionCommand/index.js

    class ChangeAttributeDefinitionCommand extends ConfigurationCommand {
      /**
       *
       * @param {import('../../../../../AttributeDefinitionContainer').default} definitionContainer
       */
      constructor(definitionContainer, attrDef, changedProperties) {
        super()
        this._definitionContainer = definitionContainer
        this._attrDef = attrDef
        this._changedProperties = changedProperties
      }

      execute() {
        const oldPred = this._attrDef.pred
        const [newAttrDef, revertChangedProperties] = applyChangedProperties(
          this._attrDef,
          this._changedProperties
        )

        this._revertAttrDef = this._definitionContainer.update(
          oldPred,
          newAttrDef
        )
        this._revertChangedProperties = revertChangedProperties

        commandLog(
          this,
          `change old pred:${oldPred} to new attridute definition:${JSON.stringify(
            newAttrDef
          )}`
        )
      }

      revert() {
        return new ChangeAttributeDefinitionCommand(
          this._definitionContainer,
          this._revertAttrDef,
          this._revertChangedProperties
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeAttributeCommand.js

    class ChangeAttributeCommand extends AnnotationCommand {
      constructor(annotationModel, attribute, newPred, newObj) {
        super()
        this._annotationModel = annotationModel
        this._attribute = attribute
        this._oldPred = attribute.pred
        this._oldObj = attribute.obj
        this._newPred = newPred
        this._newObj = newObj
      }

      execute() {
        this._newInstance = this._annotationModel.attribute.change(
          this._attribute.id,
          this._newPred,
          this._newObj
        )

        commandLog(
          this,
          `attribute: ${this._attribute.id} changed from ${this._oldPred}:${this._oldObj} to ${this._newInstance.pred}:${this._newInstance.obj}.`
        )
      }

      revert() {
        return new ChangeAttributeCommand(
          this._annotationModel,
          this._newInstance,
          this._oldPred,
          this._oldObj
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeAttributeDefinitionAndRefectInstancesCommand/index.js

    class ChangeAttributeDefinitionAndRefectInstancesCommand extends CompositeCommand {
      constructor(
        eventEmitter,
        annotationModel,
        definitionContainer,
        attrDef,
        changedProperties
      ) {
        super()

        // After updating the attribute definition, the value type of the attribute can be retrieved.
        // This is true for both normal and undo executions.
        this._isExecuteSubCommandsInReverseOrderWhenRevert = false

        // change config
        const changeConfigCommands = [
          new ChangeAttributeDefinitionCommand(
            definitionContainer,
            attrDef,
            changedProperties
          )
        ]

        let changAnnotationCommands = []
        // change annotation
        if (changedProperties.has('pred')) {
          const sameDefinitionAttributes =
            annotationModel.attribute.getSameDefinitionsAttributes(attrDef.pred)

          changAnnotationCommands = sameDefinitionAttributes.map(
            (attribute) => {
              return new ChangeAttributeCommand(
                annotationModel,
                attribute,
                changedProperties.get('pred'),
                attribute.obj
              )
            }
          )

          this._afterInvoke = () => {
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              sameDefinitionAttributes
            )
          }
        }

        this._subCommands = changeConfigCommands.concat(changAnnotationCommands)
        this._logMessage = `set ${[...changedProperties.entries()].map(
          ([id, val]) => `${id}:${val}`
        )} to attribute definition ${attrDef.pred}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeAttributeObjOfItemsCommand.js

    class ChangeAttributeObjOfItemsCommand extends CompositeCommand {
      constructor(eventEmitter, annotationModel, items, attrDef, newObj) {
        super()

        const effectedAttributes = []
        for (const item of items) {
          const attribute = item.attributes.find(
            (a) => a.pred == attrDef.pred && a.obj !== newObj
          )

          if (attribute) {
            effectedAttributes.push(attribute)
          }
        }

        this._subCommands = effectedAttributes.map(
          (attribute) =>
            new ChangeAttributeCommand(annotationModel, attribute, null, newObj)
        )

        if (effectedAttributes.length) {
          this._afterInvoke = () =>
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              effectedAttributes
            )
        }

        this._logMessage = `update obj ${newObj} to attributes: ${effectedAttributes
          .map((attribute) => attribute.id)
          .join(',')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/getAddPatternToStringAttributeDefinitionCommand.js

    /* harmony default export */ function getAddPatternToStringAttributeDefinitionCommand(
      definitionContainer,
      attrDef,
      obj,
      label
    ) {
      // When the value of the string attribute is acquired by auto-complete,
      // if the label of the acquired value is not registered in the attribute definition pattern,
      // it will be additionally registered.
      if (
        attrDef.valueType === 'string' &&
        label &&
        !attrDef.values.some((v) => v.pattern === obj) &&
        label !== attrDef.getLabel(obj)
      ) {
        return new AddValueToAttributeDefinitionCommand(
          definitionContainer,
          attrDef,
          {
            pattern: obj,
            label
          }
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeStringAttributeObjOfItemsCommand.js

    class ChangeStringAttributeObjOfItemsCommand extends CompositeCommand {
      constructor(
        eventEmitter,
        annotationModel,
        definitionContainer,
        items,
        attrDef,
        newObj,
        newLabel = null
      ) {
        super()

        const effectedAttributes = []
        for (const item of items) {
          const attribute = item.attributes.find(
            (a) => a.pred == attrDef.pred && a.obj !== newObj
          )

          if (attribute) {
            effectedAttributes.push(attribute)
          }
        }

        this._subCommands = effectedAttributes.map(
          (attribute) =>
            new ChangeAttributeCommand(annotationModel, attribute, null, newObj)
        )

        if (effectedAttributes.length) {
          this._afterInvoke = () =>
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              effectedAttributes
            )
        }

        const commnad = getAddPatternToStringAttributeDefinitionCommand(
          definitionContainer,
          attrDef,
          newObj,
          newLabel
        )
        if (commnad) {
          this._subCommands.push(commnad)
        }

        this._logMessage = `update obj ${newObj} to attributes: ${effectedAttributes
          .map((attribute) => attribute.id)
          .join(',')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeAnnotationCommand.js

    class ChangeAnnotationCommand extends AnnotationCommand {
      constructor(annotationModel, annotationType, id, newType) {
        super()
        this._annotationModel = annotationModel
        this._annotationType = annotationType
        this._id = id
        this._newType = newType
      }

      execute() {
        this.oldType = this._annotationModel[this._annotationType].get(
          this._id
        ).typeName

        // Update instance
        const targetInstance = this._annotationModel[
          this._annotationType
        ].changeType(this._id, this._newType)
        commandLog(
          this,
          `change type of a ${this._annotationType}. old type:${this.oldType} ${this._annotationType}:`,
          targetInstance
        )
      }

      revert() {
        return new ChangeAnnotationCommand(
          this._annotationModel,
          this._annotationType,
          this._id,
          this.oldType
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeNameAndAttributeOfSelectedItemsCommand/getChangeAttributeCommands.js

    /* harmony default export */ function getChangeAttributeCommands(
      items,
      attributes,
      annotationModel
    ) {
      const changeAttributeCommnads = []

      for (const item of items) {
        if (item.typeValues) {
          for (const oldAttribute of item.attributes) {
            const newAttribute = attributes.find((a) =>
              oldAttribute.equalsTo(a.pred, a.obj)
            )
            if (newAttribute) {
              if (String(oldAttribute.obj) !== newAttribute.obj) {
                changeAttributeCommnads.push(
                  new ChangeAttributeCommand(
                    annotationModel,
                    oldAttribute,
                    newAttribute.pred,
                    newAttribute.obj
                  )
                )
              }
            } else {
              changeAttributeCommnads.push(
                new RemoveCommand(annotationModel, 'attribute', oldAttribute)
              )
            }
          }
        }

        for (const newAttribute of attributes) {
          if (
            !item.attributes.some((a) =>
              a.equalsTo(newAttribute.pred, newAttribute.obj)
            )
          ) {
            changeAttributeCommnads.push(
              new CreateCommand(annotationModel, 'attribute', {
                subj: item.id,
                pred: newAttribute.pred,
                obj: newAttribute.obj
              })
            )
          }
        }
      }

      return changeAttributeCommnads
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeNameAndAttributeOfSelectedItemsCommand/index.js

    class ChangeTypeNameAndAttributeOfSelectedItemsCommand extends CompositeCommand {
      constructor(
        annotationModel,
        selectionModel,
        annotationType,
        typeName,
        attributes
      ) {
        super()

        // Get only items with changes.
        const itemsWithChange = selectionModel[annotationType].all.filter(
          (item) => !item.typeValues.isSameType(typeName, attributes)
        )

        // Change type of items.
        this._subCommands = itemsWithChange.map(
          (item) =>
            new ChangeAnnotationCommand(
              annotationModel,
              annotationType,
              item.id,
              typeName
            )
        )

        // Change attributes
        this._subCommands = this._subCommands.concat(
          getChangeAttributeCommands(
            itemsWithChange,
            attributes,
            annotationModel
          )
        )

        for (const { pred, obj, label } of attributes) {
          const definitionContainer = annotationModel.typeDefinition.attribute
          const attrDef = definitionContainer.get(pred)
          const commnad = getAddPatternToStringAttributeDefinitionCommand(
            definitionContainer,
            attrDef,
            obj,
            label
          )
          if (commnad) {
            this._subCommands.push(commnad)
          }
        }

        this._logMessage = `set type ${typeName}${
          attributes.length > 0
            ? ` and attributes ${JSON.stringify(attributes)}`
            : ``
        } to ${annotationType} items ${itemsWithChange.map((i) => i.id)}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeDefinitionCommand/applyChangedProperties.js

    /* harmony default export */ function ChangeTypeDefinitionCommand_applyChangedProperties(
      changedProperties,
      oldType
    ) {
      const newType = { ...oldType }
      const revertChangedProperties = new Map()

      // change config
      for (const [key, property] of changedProperties.entries()) {
        if (property === null && typeof oldType[key] !== 'undefined') {
          delete newType[key]
          revertChangedProperties.set(key, oldType[key])
        } else if (property !== null) {
          newType[key] = property
          revertChangedProperties.set(
            key,
            typeof oldType[key] === 'undefined' ? null : oldType[key]
          )
        }
      }

      return [newType, revertChangedProperties]
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeDefinitionCommand/index.js

    class ChangeTypeDefinitionCommand extends ConfigurationCommand {
      constructor(
        annotationModel,
        definitionContainer,
        id,
        changedProperties,
        newDefaultTypeId
      ) {
        super()
        this._annotationModel = annotationModel
        this._definitionContainer = definitionContainer
        this._id = id
        this._changedProperties = changedProperties
        this._newDefaultTypeId = newDefaultTypeId
      }

      execute() {
        const oldType = this._definitionContainer.get(this._id)
        const [newType, revertChangedProperties] =
          ChangeTypeDefinitionCommand_applyChangedProperties(
            this._changedProperties,
            oldType
          )
        this._definitionContainer.replace(this._id, newType)

        if (newType.default) {
          // remember the current default, because revert command will not understand what type was it.
          this.revertDefaultTypeId = this._definitionContainer.defaultType
          this._definitionContainer.defaultType = newType.id
        } else if (this._newDefaultTypeId) {
          this._definitionContainer.defaultType = this._newDefaultTypeId
        }

        this.revertId = newType.id
        this.revertChangedProperties = revertChangedProperties

        commandLog(
          this,
          `change old type:${JSON.stringify(
            oldType
          )} to new type:${JSON.stringify(newType)}, default is ${
            this._definitionContainer.defaultType
          }`
        )
      }

      revert() {
        return new ChangeTypeDefinitionCommand(
          this._annotationModel,
          this._definitionContainer,
          this.revertId,
          this.revertChangedProperties,
          this.revertDefaultTypeId
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/RemoveTypeDefinitionCommand.js

    class RemoveTypeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, removeType, revertDefaultTypeId) {
        super()
        this._definitionContainer = definitionContainer
        this._removeType = removeType
        this._revertDefaultTypeId = revertDefaultTypeId
      }

      execute() {
        const { id } = this._removeType
        const oldType = this._definitionContainer.get(id)

        this._definitionContainer.delete(id, this._revertDefaultTypeId)

        if (oldType) {
          this._removeType = oldType
        }

        commandLog(
          this,
          `remove a type:${JSON.stringify(this._removeType)}, default is ${
            this._definitionContainer.defaultType
          }`
        )
      }

      revert() {
        return new CreateTypeDefinitionCommand(
          this._definitionContainer,
          this._removeType
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateTypeDefinitionCommand.js

    class CreateTypeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, newType) {
        super()
        this._definitionContainer = definitionContainer
        this._newType = newType
      }

      execute() {
        // For UNDO, remember the default value before running this command.
        this._revertDefaultTypeId = this._definitionContainer._defaultType

        this._definitionContainer.addDefinedType(this._newType)

        commandLog(
          this,
          `create a new type:${JSON.stringify(this._newType)}, default is ${
            this._definitionContainer.defaultType
          }`
        )
      }

      revert() {
        return new RemoveTypeDefinitionCommand(
          this._definitionContainer,
          this._newType,
          this._revertDefaultTypeId
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/createChangeConfigCommand.js

    /* harmony default export */ function createChangeConfigCommand(
      definitionContainer,
      id,
      annotationModel,
      changedProperties
    ) {
      // The palette also displays instance types other than type in the typeDefinition,
      // so modified type may not be in the typeDefinition.
      if (definitionContainer.has(id)) {
        return new ChangeTypeDefinitionCommand(
          annotationModel,
          definitionContainer,
          id,
          changedProperties,
          null
        )
      } else {
        // The change properties contain only the changed attributes.
        // When the ID is changed, it does not overwrite the ID with the old ID.
        // When you add a label, the old ID is used to add the type definition.
        return new CreateTypeDefinitionCommand(definitionContainer, {
          id,
          ...Object.fromEntries(changedProperties)
        })
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeValuesCommand.js

    class ChangeTypeValuesCommand extends CompositeCommand {
      constructor(
        annotationModel,
        selectionModel,
        label,
        value,
        definitionContainer,
        attributes
      ) {
        super()

        const commands = []
        if (label) {
          commands.push(
            createChangeConfigCommand(
              definitionContainer,
              value,
              annotationModel,
              new Map([['label', label]])
            )
          )
        }

        const changeItemsCommand =
          new ChangeTypeNameAndAttributeOfSelectedItemsCommand(
            annotationModel,
            selectionModel,
            definitionContainer.annotationType,
            value,
            attributes
          )
        if (!changeItemsCommand.isEmpty) {
          commands.push(changeItemsCommand)
        }

        this._subCommands = commands
        this._logMessage = `change ${
          definitionContainer.annotationType
        } value:"${value}"${label ? `, label:"${label}"` : ``}${
          attributes.length > 0
            ? `, attributes:${JSON.stringify(attributes)}`
            : ``
        }`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeDefinitionAndRefectInstancesCommand/createChangeAnnotationCommands.js

    /* harmony default export */ function createChangeAnnotationCommands(
      annotationModel,
      annotationType,
      oldTypeName,
      newTypeName
    ) {
      return annotationModel[annotationType].all
        .filter((instance) => instance.typeName === oldTypeName)
        .map((instance) => {
          return new ChangeAnnotationCommand(
            annotationModel,
            annotationType,
            instance.id,
            newTypeName
          )
        })
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeDefinitionAndRefectInstancesCommand/index.js

    class ChangeTypeDefinitionAndRefectInstancesCommand extends CompositeCommand {
      constructor(
        annotationModel,
        definitionContainer,
        annotationType,
        id,
        changedProperties
      ) {
        super()

        // change config
        const changeConfigcommands = [
          createChangeConfigCommand(
            definitionContainer,
            id,
            annotationModel,
            changedProperties
          )
        ]

        let changAnnotationCommands = []
        // change annotation
        if (changedProperties.has('id')) {
          changAnnotationCommands = createChangeAnnotationCommands(
            annotationModel,
            annotationType,
            id,
            changedProperties.get('id')
          )
        }

        this._subCommands = changeConfigcommands.concat(changAnnotationCommands)
        this._logMessage = `set ${[...changedProperties.entries()].map(
          ([id, val]) => `${id}:${val}`
        )} to type definition ${id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeTypeOfSelectedItemsCommand.js

    class ChangeTypeOfSelectedItemsCommand extends CompositeCommand {
      constructor(annotationModel, selectionModel, annotationType, typeName) {
        super()

        const itemsWithChange = selectionModel[annotationType].all.filter(
          (item) => !item.typeValues.isSameType(typeName)
        )

        this._subCommands = itemsWithChange.map(
          (item) =>
            new ChangeAnnotationCommand(
              annotationModel,
              annotationType,
              item.id,
              typeName
            )
        )
        this._logMessage = `set type ${typeName} to ${annotationType} items ${itemsWithChange}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand/ChangeValueOfAttributeDefinitionCommand.js

    class ChangeValueOfAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(
        definitionContainer,
        attrDef,
        targetIndex,
        newValue,
        indexThatRemoveDefaultFrom
      ) {
        super()
        this._definitionContainer = definitionContainer
        this._attrDef = attrDef
        this._targetIndex = targetIndex
        this._newValue = newValue
        this._indexThatRemoveDefaultFrom = indexThatRemoveDefaultFrom
      }

      execute() {
        // Change default value of selection attribute.
        if (this._attrDef['value type'] === 'selection') {
          // When adding default
          if (
            !this._attrDef.values[this._targetIndex].default &&
            this._newValue.default
          ) {
            if (!this._indexThatRemoveDefaultFrom) {
              this._indexThatRemoveDefaultFrom = this._attrDef.values.findIndex(
                (v) => v.default
              )
            }

            delete this._attrDef.values[this._indexThatRemoveDefaultFrom]
              .default
          }

          // When removeing default.
          if (
            this._attrDef.values[this._targetIndex].default &&
            !this._newValue.default
          ) {
            if (this._attrDef.values.length === 1) {
              this._newValue.default = true
            } else if (this._indexThatRemoveDefaultFrom) {
              this._attrDef.values[this._indexThatRemoveDefaultFrom].default =
                true
            } else {
              let indexThatAddDefaultTo = null

              this._attrDef.values.forEach((v, index) => {
                if (
                  indexThatAddDefaultTo === null &&
                  index != this._targetIndex
                ) {
                  indexThatAddDefaultTo = index
                }
              })

              this._attrDef.values[indexThatAddDefaultTo].default = true
              this._indexThatRemoveDefaultFrom = indexThatAddDefaultTo
            }
          }
        }

        this._valueBeforeChange = this._attrDef.values.splice(
          this._targetIndex,
          1,
          this._newValue
        )[0]

        this._definitionContainer.update(this._attrDef.pred, this._attrDef)

        commandLog(
          this,
          `change value of attrribute:${
            this._attrDef.pred
          }, oldValue: ${JSON.stringify(
            this._valueBeforeChange
          )}, newValue: ${JSON.stringify(this._newValue)}`
        )
      }

      revert() {
        return new ChangeValueOfAttributeDefinitionCommand(
          this._definitionContainer,
          this._attrDef,
          this._targetIndex,
          this._valueBeforeChange,
          this._indexThatRemoveDefaultFrom
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand/index.js

    class ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand extends CompositeCommand {
      constructor(
        eventEmitter,
        annotationModel,
        definitionContainer,
        attrDef,
        index,
        value,
        indexThatRemoveDefaultFrom
      ) {
        super()

        this._subCommands = [
          new ChangeValueOfAttributeDefinitionCommand(
            definitionContainer,
            attrDef,
            index,
            value,
            indexThatRemoveDefaultFrom
          )
        ]

        if (
          attrDef['value type'] === 'selection' &&
          attrDef.values[index].id !== value.id
        ) {
          const sameAttributes = annotationModel.attribute.getSameAttributes(
            attrDef.pred,
            attrDef.values[index].id
          )
          const changeAnnotationCommands = sameAttributes.map(
            (a) =>
              new ChangeAttributeCommand(annotationModel, a, null, value.id)
          )

          this._subCommands = this._subCommands.concat(changeAnnotationCommands)
          this._afterInvoke = () =>
            eventEmitter.emit(
              'textae-event.commander.attributes.change',
              sameAttributes
            )
        }

        this._logMessage = `attribute: ${attrDef.pred}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/DeleteAttributeDefinitionCommand.js

    class DeleteAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, attrDef) {
        super()
        this._definitionContainer = definitionContainer
        this._removeAttrdef = attrDef
        this._index = definitionContainer.getIndexOf(attrDef.pred)
      }

      execute() {
        this._definitionContainer.delete(this._removeAttrdef.pred)

        commandLog(
          this,
          `remove an attrribute definition:${JSON.stringify(
            this._removeAttrdef
          )}, index:${this._index}`
        )
      }

      revert() {
        return new CreateAttributeDefinitionCommand(
          this._definitionContainer,
          this._removeAttrdef,
          this._index
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateAttributeDefinitionCommand.js

    class CreateAttributeDefinitionCommand extends ConfigurationCommand {
      /** @param {import("../../../AttributeDefinitionContainer").default} definitionContainer */
      constructor(definitionContainer, attrDef, index) {
        super()
        this._definitionContainer = definitionContainer
        this._newAttrDef = attrDef
        this._index = index
      }

      execute() {
        // Added default value to newly created selection attribute definition.
        // Except when undoing the deletion of selection attribute definition.
        if (
          this._newAttrDef.valueType === 'selection' &&
          !this._newAttrDef.values
        ) {
          this._newAttrDef.values = [
            {
              id: 'default',
              default: true
            }
          ]
        }

        this._definitionContainer.create(
          this._newAttrDef.valueType,
          this._newAttrDef,
          this._index
        )

        commandLog(
          this,
          `create a new attrribute definition:${JSON.stringify(
            this._newAttrDef
          )}, index: ${this._index}`
        )
      }

      revert() {
        return new DeleteAttributeDefinitionCommand(
          this._definitionContainer,
          this._newAttrDef
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/getCreateAttributeToItemsCommands.js

    /* harmony default export */ function getCreateAttributeToItemsCommands(
      annotationModel,
      items,
      pred,
      obj
    ) {
      return items
        .filter((i) => !i.typeValues.hasSpecificPredicateAttribute(pred))
        .map(({ id }) => {
          return new CreateCommand(annotationModel, 'attribute', {
            id: null,
            subj: id,
            pred,
            obj
          })
        })
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateAttributeToItemsCommand.js

    class CreateAttributeToItemsCommand extends CompositeCommand {
      constructor(annotationModel, items, attributeDefinition, obj) {
        super()

        this._subCommands = getCreateAttributeToItemsCommands(
          annotationModel,
          items,
          attributeDefinition.pred,
          obj || attributeDefinition.default
        )

        this._logMessage = `create attirbute ${attributeDefinition.pred}:${
          attributeDefinition.default
        } to item ${items.map(({ id }) => id).join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateEntityAndAttributesCommand/CreateAttributeToTheLatestEntityCommand.js

    class CreateAttributeToTheLatestEntityCommand extends CreateCommand {
      constructor(annotationModel, obj, pred) {
        super(annotationModel, 'attribute', {
          obj,
          pred
        })
      }

      execute() {
        const subj = this._annotationModel.entity.all.pop().id
        this._instance.subj = subj
        return super.execute()
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateEntityAndAttributesCommand/index.js

    class CreateEntityAndAttributesCommand extends CompositeCommand {
      constructor(annotationModel, selectionModel, span, typeName, attributes) {
        super()

        this._subCommands = [
          new CreateCommand(
            annotationModel,
            'entity',
            {
              span,
              typeName
            },
            selectionModel
          )
        ].concat(
          attributes.map(
            ({ obj, pred }) =>
              // Only one entity was created.
              new CreateAttributeToTheLatestEntityCommand(
                annotationModel,
                obj,
                pred
              )
          )
        )

        this._logMessage = `span: ${span}, type: ${typeName}${
          attributes.length
            ? `, attributes: ${attributes.map(({ pred }) => pred).join(', ')}`
            : ''
        }`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateBlockSpanCommand.js

    class CreateBlockCommand extends CompositeCommand {
      constructor(
        editorID,
        annotationModel,
        selectionModel,
        begin,
        end,
        defaultType
      ) {
        super()

        const spanId = makeBlockSpanHTMLElementID(editorID, begin, end)
        const createSpanCommand = new CreateCommand(
          annotationModel,
          'span',
          {
            begin,
            end,
            isBlock: true
          },
          selectionModel
        )
        const createEntityCommand = new CreateEntityAndAttributesCommand(
          annotationModel,
          selectionModel,
          spanId,
          defaultType,
          []
        )

        this._subCommands = [createSpanCommand, createEntityCommand]
        this._logMessage = `create a span ${spanId}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateDefaultTypeEntityToSelectedSpansCommand.js

    class CreateDefaultTypeEntityToSelectedSpansCommand extends CompositeCommand {
      constructor(annotationModel, selectionModel, typeName) {
        super()

        const selectedSpans = selectionModel.span.all
          .filter((span) => span.isDenotation)
          .map((span) => span.id)
        this._subCommands = selectedSpans.map(
          (span) =>
            new CreateCommand(
              annotationModel,
              'entity',
              {
                span,
                typeName
              },
              selectionModel
            )
        )

        this._logMessage = `create a ${typeName} type entity to ${selectedSpans}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateSpanAndTypesCommand.js

    class CreateSpanAndTypesCommand extends CompositeCommand {
      constructor(
        annotationModel,
        selectionModel,
        spanId,
        begin,
        end,
        typeValuesList
      ) {
        super()

        this._subCommands = [
          new CreateCommand(
            annotationModel,
            'span',
            {
              begin,
              end
            },
            selectionModel
          )
        ].concat(
          typeValuesList.map(
            (typeValues) =>
              new CreateEntityAndAttributesCommand(
                annotationModel,
                selectionModel,
                spanId,
                typeValues.typeName,
                typeValues.attributes
              )
          )
        )
        this._logMessage = `span: ${spanId}, types: ${typeValuesList
          .map(({ typeName }) => typeName)
          .join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ReplicateSpanCommand.js

    class ReplicateSpanCommand extends CompositeCommand {
      constructor(
        editorID,
        annotationModel,
        selectionModel,
        span,
        typeValeusList,
        isDelimiterFunc
      ) {
        super()

        this._subCommands = annotationModel
          .getReplicationRanges(span, isDelimiterFunc)
          .map(({ begin, end }) => {
            const spanId = makeDenotationSpanHTMLElementID(editorID, begin, end)

            return new CreateSpanAndTypesCommand(
              annotationModel,
              selectionModel,
              spanId,
              begin,
              end,
              typeValeusList
            )
          })
        this._logMessage = `from span: ${makeDenotationSpanHTMLElementID(
          editorID,
          span.begin,
          span.end
        )}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/CreateSpanAndAutoReplicateCommand.js

    const BLOCK_THRESHOLD = 100

    class CreateSpanAndAutoReplicateCommand extends CompositeCommand {
      constructor(
        editorID,
        annotationModel,
        selectionModel,
        newSpan,
        defaultType,
        isReplicateAuto,
        isDelimiterFunc
      ) {
        super()

        const typeValuesList = [new TypeValues(defaultType)]

        const spanID = makeDenotationSpanHTMLElementID(
          editorID,
          newSpan.begin,
          newSpan.end
        )

        this._subCommands = [
          new CreateSpanAndTypesCommand(
            annotationModel,
            selectionModel,
            spanID,
            newSpan.begin,
            newSpan.end,
            typeValuesList
          )
        ]
        this._logMessage = `create a span ${newSpan.begin}:${newSpan.end} with type ${typeValuesList[0].typeName}`

        if (isReplicateAuto && newSpan.end - newSpan.begin <= BLOCK_THRESHOLD) {
          this._subCommands.push(
            new ReplicateSpanCommand(
              editorID,
              annotationModel,
              selectionModel,
              {
                begin: newSpan.begin,
                end: newSpan.end
              },
              typeValuesList,
              isDelimiterFunc
            )
          )
          this._logMessage = `${this._logMessage} and replicate auto`
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/MoveAttributeDefinitionCommand.js

    class MoveAttributeDefinitionCommand extends ConfigurationCommand {
      constructor(definitionContainer, oldIndex, newIndex) {
        super()
        this._definitionContainer = definitionContainer
        this._oldIndex = oldIndex
        this._newIndex = newIndex
      }

      execute() {
        this._definitionContainer.move(this._oldIndex, this._newIndex)

        commandLog(
          this,
          `move the attrribute definition: from ${this._oldIndex} to ${this._newIndex}`
        )
      }

      revert() {
        return new MoveAttributeDefinitionCommand(
          this._definitionContainer,
          this._newIndex,
          this._oldIndex
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/MoveBlockSpanCommand.js

    class MoveBlockSpanCommand extends AnnotationCommand {
      constructor(annotationModel, spanId, begin, end) {
        super()
        this._annotationModel = annotationModel
        this._spanId = spanId
        this._begin = begin
        this._end = end
      }

      execute() {
        // Update instance.
        const { id, begin, end } = this._annotationModel.span.moveBlockSpan(
          this._spanId,
          this._begin,
          this._end
        )

        this._newId = id
        this._oldBegin = begin
        this._oldEnd = end

        commandLog(
          this,
          `move span: ${this._spanId} to {begin: ${this._begin}, end: ${this._end}}`
        )
      }

      revert() {
        return new MoveBlockSpanCommand(
          this._annotationModel,
          this._newId,
          this._oldBegin,
          this._oldEnd
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/MoveDenotationSpanCommand.js

    class MoveDenotationSpanCommand extends AnnotationCommand {
      constructor(annotationModel, spanId, begin, end) {
        super()
        this._annotationModel = annotationModel
        this._spanId = spanId
        this._begin = begin
        this._end = end
      }

      execute() {
        // Update instance.
        const { id, begin, end } =
          this._annotationModel.span.moveDenotationSpan(
            this._spanId,
            this._begin,
            this._end
          )

        this._newId = id
        this._oldBegin = begin
        this._oldEnd = end

        commandLog(
          this,
          `move span: ${this._spanId} to {begin: ${this._begin}, end: ${this._end}}`
        )
      }

      revert() {
        return new MoveDenotationSpanCommand(
          this._annotationModel,
          this._newId,
          this._oldBegin,
          this._oldEnd
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/areAllEntiesOfSpan.js

    /* harmony default export */ function areAllEntiesOfSpan(span, entities) {
      return span.entities.every((entity) => entities.includes(entity))
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/MoveEntitiesToSelectedSpanCommand/MoveEntitiesToSpanCommand/RevertMoveEntitiesCommand.js

    class RevertMoveEntitiesCommand extends CompositeCommand {
      constructor(annotationModel, moveMap) {
        super()

        this._subCommands = []
        for (const [span, entities] of moveMap.entries()) {
          this._subCommands.push(
            new MoveEntitiesToSpanCommand(annotationModel, span, entities)
          )
        }

        this._logMessage = `revert: move entities ${Array.from(moveMap.values())
          .flat()
          .map((e) => e.id)
          .join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/MoveEntitiesToSelectedSpanCommand/MoveEntitiesToSpanCommand/index.js

    class MoveEntitiesToSpanCommand extends AnnotationCommand {
      constructor(annotationModel, span, entities) {
        super()

        this._annotationModel = annotationModel
        this._span = span
        this._entities = entities
      }

      execute() {
        // Save move map to revert this command.
        this._moveMap = this._entities.reduce((map, entity) => {
          if (map.has(entity.span)) {
            map.get(entity.span).push(entity)
          } else {
            map.set(entity.span, [entity])
          }
          return map
        }, new Map())

        const message = `${Array.from(this._moveMap.entries())
          .map(([_, entities]) => {
            return `${entities.map((e) => e.id).join(', ')} from ${
              entities[0].span.id
            } to ${this._span.id}`
          })
          .join(', ')}`

        this._annotationModel.entity.moveEntities(this._span, this._entities)

        commandLog(this, message)
      }

      revert() {
        return new RevertMoveEntitiesCommand(
          this._annotationModel,
          this._moveMap
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/MoveEntitiesToSelectedSpanCommand/index.js

    class MoveEntitiesToSelectedSpanCommand extends CompositeCommand {
      constructor(annotationModel, selectionModel, entities) {
        console.assert(
          selectionModel.span.single,
          'There must be one span to be pasted.'
        )

        super()

        // Move cut entities to the selected span.
        const commands = [
          new MoveEntitiesToSpanCommand(
            annotationModel,
            selectionModel.span.single,
            entities
          )
        ]

        // Remove spans losing all entities.
        for (const span of entities
          .map((entity) => entity.span)
          .reduce((acc, span) => {
            acc.add(span)
            return acc
          }, new Set())
          .values()) {
          if (areAllEntiesOfSpan(span, entities)) {
            commands.push(new RemoveCommand(annotationModel, 'span', span))
          }
        }

        this._subCommands = commands

        this._logMessage = `paste cut entities`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/PasteTypesToSelectedSpansCommand.js

    class PasteTypesToSelectedSpansCommand extends CompositeCommand {
      constructor(
        annotationModel,
        selectionModel,
        typeValuesList,
        newTypes,
        attrDefs,
        newSelectionAttributeObjects
      ) {
        super()

        const selecteedSpans = selectionModel.span.all.map((span) => span.id)
        this._subCommands = []

        for (const newType of newTypes) {
          this._subCommands.push(
            new CreateTypeDefinitionCommand(
              annotationModel.denotationDefinitionContainer,
              newType
            )
          )
        }

        for (const attrDef of attrDefs) {
          this._subCommands.push(
            new CreateAttributeDefinitionCommand(
              annotationModel.attributeDefinitionContainer,
              { valueType: attrDef['value type'], ...attrDef }
            )
          )
        }

        for (const { pred, value } of newSelectionAttributeObjects) {
          this._subCommands.push(
            new AddValueToAttributeDefinitionCommand(
              annotationModel.attributeDefinitionContainer,
              annotationModel.attributeDefinitionContainer.get(pred),
              value
            )
          )
        }

        this._subCommands = this._subCommands.concat(
          selecteedSpans
            .map((span) =>
              typeValuesList.map(
                (typeValues) =>
                  new CreateEntityAndAttributesCommand(
                    annotationModel,
                    selectionModel,
                    span,
                    typeValues.typeName,
                    typeValues.attributes
                  )
              )
            )
            .flat()
        )

        this._logMessage = `paste types [${typeValuesList.map(
          ({ typeName, attributes }) =>
            [`{type:${typeName}}`].concat(
              attributes.map(({ pred, obj }) => `{${pred}:${obj}}`)
            )
        )}] to ${selecteedSpans}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/getRemoveAttributesByPredCommands.js

    /* harmony default export */ function getRemoveAttributesByPredCommands(
      annotationModel,
      items,
      pred
    ) {
      return items
        .reduce((attrs, { attributes }) => attrs.concat(attributes), [])
        .filter((a) => a.pred === pred)
        .map((a) => new RemoveCommand(annotationModel, 'attribute', a))
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/RemoveAttributesFromItemsByPredCommand.js

    class RemoveAttributesFromItemsByPredCommand extends CompositeCommand {
      constructor(annotationModel, items, attributeDefinition) {
        super()

        const removeAttributeCommands = getRemoveAttributesByPredCommands(
          annotationModel,
          items,
          attributeDefinition.pred
        )

        this._subCommands = removeAttributeCommands
        this._logMessage = `remove ${
          attributeDefinition.pred
        } attribute from items ${items.map((i) => i.id).join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/aggregateTargetRelations.js

    /* harmony default export */ function aggregateTargetRelations(
      targetRelations,
      targetAttributes,
      relation
    ) {
      targetRelations.add(relation)
      for (const attribute of relation.attributes) {
        targetAttributes.add(attribute)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/aggregateTargetEntities.js

    /* harmony default export */ function aggregateTargetEntities(
      targetEntities,
      targetRelations,
      targetAttributes,
      entity
    ) {
      targetEntities.add(entity)
      for (const attribute of entity.attributes) {
        targetAttributes.add(attribute)
      }
      for (const relation of entity.relations) {
        aggregateTargetRelations(targetRelations, targetAttributes, relation)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/RemoveSelectedCommand.js

    class RemoveSelectedCommand extends CompositeCommand {
      constructor(annotationModel, selectionModel) {
        super()

        // Aggregate seleceted targets
        const targetSpans = new Set()
        const targetEntities = new Set()
        const targetRelations = new Set()
        const targetAttributes = new Set()
        for (const span of selectionModel.span.all) {
          targetSpans.add(span)
          for (const entity of span.entities) {
            aggregateTargetEntities(
              targetEntities,
              targetRelations,
              targetAttributes,
              entity
            )
          }
        }
        for (const entity of selectionModel.entity.all) {
          aggregateTargetEntities(
            targetEntities,
            targetRelations,
            targetAttributes,
            entity
          )
        }
        for (const relation of selectionModel.relation.all) {
          aggregateTargetRelations(targetRelations, targetAttributes, relation)
        }

        // Aggregate spans to lose all entities.
        for (const span of annotationModel.span.all) {
          if (
            span.entities.every((e) => selectionModel.entity.all.includes(e))
          ) {
            if (!span.styleOnly) {
              targetSpans.add(span)
            }
          }
        }

        this._subCommands = []
        for (const attribute of targetAttributes) {
          this._subCommands.push(
            new RemoveCommand(annotationModel, 'attribute', attribute)
          )
        }
        for (const relation of targetRelations) {
          this._subCommands.push(
            new RemoveCommand(annotationModel, 'relation', relation)
          )
        }
        for (const entity of targetEntities) {
          this._subCommands.push(
            new RemoveCommand(annotationModel, 'entity', entity)
          )
        }
        for (const span of targetSpans) {
          this._subCommands.push(
            new RemoveCommand(annotationModel, 'span', span)
          )
        }

        this._logMessage = `remove selected ${[
          ...targetSpans,
          ...targetEntities,
          ...targetRelations,
          ...targetAttributes
        ]
          .map(({ id }) => id)
          .join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/RemoveRelationAndAssociatesCommand.js

    class RemoveRelationAndAssociatesCommand extends CompositeCommand {
      constructor(annotationModel, relation) {
        super()
        const removeRelation = new RemoveCommand(
          annotationModel,
          'relation',
          relation
        )
        const removeAttribute = relation.attributes.map(
          (attribute) =>
            new RemoveCommand(annotationModel, 'attribute', attribute)
        )

        this._subCommands = removeAttribute.concat(removeRelation)
        this._logMessage = `remove a relation ${relation.id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/RemoveEntityAndAssociatesCommand.js

    class RemoveEntityAndAssociatesCommand extends CompositeCommand {
      constructor(annotationModel, entity) {
        super()
        const removeEntity = new RemoveCommand(
          annotationModel,
          'entity',
          entity
        )
        const removeRelation = entity.relations.map(
          (relation) =>
            new RemoveRelationAndAssociatesCommand(annotationModel, relation)
        )
        const removeAttribute = entity.attributes.map(
          (attribute) =>
            new RemoveCommand(annotationModel, 'attribute', attribute)
        )

        this._subCommands = removeRelation
          .concat(removeAttribute)
          .concat(removeEntity)
        this._logMessage = `remove an entity ${entity.id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/RemoveSpanCommand.js

    class RemoveSpanCommand extends CompositeCommand {
      constructor(annotationModel, id) {
        super()

        const span = annotationModel.span.get(id)
        const removeEntities = span.entities.map(
          (entity) =>
            new RemoveEntityAndAssociatesCommand(annotationModel, entity)
        )

        const removeSpan = new RemoveCommand(annotationModel, 'span', span)

        this._subCommands = removeEntities.concat(removeSpan)
        this._logMessage = `remove a span ${id}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/ToggleFlagAttributeToItemsCommand.js

    class ToggleFlagAttributeToItemsCommand extends CompositeCommand {
      constructor(annotationModel, items, attributeDefinition) {
        super()

        this._subCommands = getCreateAttributeToItemsCommands(
          annotationModel,
          items,
          attributeDefinition.pred,
          attributeDefinition.default
        )

        // Toggle exisitng flag type attributes
        const removeAttributeCommands = getRemoveAttributesByPredCommands(
          annotationModel,
          items,
          attributeDefinition.pred
        )

        this._subCommands = this._subCommands.concat(removeAttributeCommands)

        this._logMessage = `toggle flag attirbute ${
          attributeDefinition.pred
        } to item ${items.map(({ id }) => id).join(', ')}`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/Factory/index.js

    class Factory {
      constructor(editorID, eventEmitter, annotationModel, selectionModel) {
        this._editorID = editorID
        this._eventEmitter = eventEmitter
        this._annotationModel = annotationModel
        this._selectionModel = selectionModel
      }

      addValueToAttributeDefinitionCommand(attributeDefinition, value) {
        return new AddValueToAttributeDefinitionCommand(
          this._annotationModel.typeDefinition.attribute,
          attributeDefinition,
          value
        )
      }

      changeAttributeDefinitionCommand(attributeDefinition, changedProperties) {
        return new ChangeAttributeDefinitionAndRefectInstancesCommand(
          this._eventEmitter,
          this._annotationModel,
          this._annotationModel.typeDefinition.attribute,
          attributeDefinition,
          changedProperties
        )
      }

      changeAttributeObjOfItemsCommand(items, attributeDefinition, newObj) {
        return new ChangeAttributeObjOfItemsCommand(
          this._eventEmitter,
          this._annotationModel,
          items,
          attributeDefinition,
          newObj
        )
      }

      changeStringAttributeObjOfItemsCommand(
        items,
        attributeDefinition,
        newObj,
        newLabel
      ) {
        return new ChangeStringAttributeObjOfItemsCommand(
          this._eventEmitter,
          this._annotationModel,
          this._annotationModel.typeDefinition.attribute,
          items,
          attributeDefinition,
          newObj,
          newLabel
        )
      }

      changeTypeValuesCommand(label, value, definitionContainer, attributes) {
        return new ChangeTypeValuesCommand(
          this._annotationModel,
          this._selectionModel,
          label,
          value,
          definitionContainer,
          attributes
        )
      }

      changeTypeDefinitionCommand(
        definitionContainer,
        annotationType,
        id,
        changedProperties
      ) {
        return new ChangeTypeDefinitionAndRefectInstancesCommand(
          this._annotationModel,
          definitionContainer,
          annotationType,
          id,
          changedProperties
        )
      }

      changeTypeOfSelectedItemsCommand(annotationType, newType) {
        return new ChangeTypeOfSelectedItemsCommand(
          this._annotationModel,
          this._selectionModel,
          annotationType,
          newType
        )
      }

      changeValueOfAttributeDefinitionAndObjectOfSelectionAttributeCommand(
        attributeDefinition,
        index,
        value
      ) {
        return new ChangeValueOfAttributeDefinitionAndObjectOfAttributeCommand(
          this._eventEmitter,
          this._annotationModel,
          this._annotationModel.typeDefinition.attribute,
          attributeDefinition,
          index,
          value
        )
      }

      createAttributeDefinitionCommand(attributeDefinition) {
        return new CreateAttributeDefinitionCommand(
          this._annotationModel.typeDefinition.attribute,
          attributeDefinition
        )
      }

      createAttributeToItemsCommand(items, attributeDefinition, obj = null) {
        return new CreateAttributeToItemsCommand(
          this._annotationModel,
          items,
          attributeDefinition,
          obj
        )
      }

      createBlockSpanCommand(newSpan) {
        return new CreateBlockCommand(
          this._editorID,
          this._annotationModel,
          this._selectionModel,
          newSpan.begin,
          newSpan.end,
          this._annotationModel.typeDefinition.block.defaultType
        )
      }

      createDefaultTypeEntityToSelectedSpansCommand(typeName) {
        return new CreateDefaultTypeEntityToSelectedSpansCommand(
          this._annotationModel,
          this._selectionModel,
          typeName
        )
      }

      createRelationCommand(relation) {
        return new CreateCommand(
          this._annotationModel,
          'relation',
          relation,
          this._selectionModel
        )
      }

      createSpanAndAutoReplicateCommand(
        newSpan,
        isReplicateAuto,
        isDelimiterFunc
      ) {
        return new CreateSpanAndAutoReplicateCommand(
          this._editorID,
          this._annotationModel,
          this._selectionModel,
          newSpan,
          this._annotationModel.typeDefinition.denotation.defaultType,
          isReplicateAuto,
          isDelimiterFunc
        )
      }

      createTypeDefinitionCommand(definitionContainer, newType) {
        return new CreateTypeDefinitionCommand(definitionContainer, newType)
      }

      deleteAttributeDefinitionCommand(attributeDefinition) {
        return new DeleteAttributeDefinitionCommand(
          this._annotationModel.typeDefinition.attribute,
          attributeDefinition
        )
      }

      moveAttributeDefintionComannd(oldIndex, newIndex) {
        return new MoveAttributeDefinitionCommand(
          this._annotationModel.typeDefinition.attribute,
          oldIndex,
          newIndex
        )
      }

      moveBlockSpanCommand(spanId, begin, end) {
        return new MoveBlockSpanCommand(
          this._annotationModel,
          spanId,
          begin,
          end
        )
      }

      moveDenotationSpanCommand(spanId, begin, end) {
        return new MoveDenotationSpanCommand(
          this._annotationModel,
          spanId,
          begin,
          end
        )
      }

      moveEntitiesToSelectedSpanCommand(entities) {
        return new MoveEntitiesToSelectedSpanCommand(
          this._annotationModel,
          this._selectionModel,
          entities
        )
      }

      pasteTypesToSelectedSpansCommand(
        typeValuesList,
        newTypes = [],
        attrDefs = [],
        newSelectionAttributeObjects = []
      ) {
        return new PasteTypesToSelectedSpansCommand(
          this._annotationModel,
          this._selectionModel,
          typeValuesList,
          newTypes,
          attrDefs,
          newSelectionAttributeObjects
        )
      }

      replicateSpanCommand(span, typeValuesList, isDelimiterFunc) {
        return new ReplicateSpanCommand(
          this._editorID,
          this._annotationModel,
          this._selectionModel,
          span,
          typeValuesList,
          isDelimiterFunc
        )
      }

      removeAttributesFromItemsByPredCommand(items, attributeDefinition) {
        return new RemoveAttributesFromItemsByPredCommand(
          this._annotationModel,
          items,
          attributeDefinition
        )
      }

      removeSpanCommand(id) {
        return new RemoveSpanCommand(this._annotationModel, id)
      }

      removeSelectedComand() {
        return new RemoveSelectedCommand(
          this._annotationModel,
          this._selectionModel
        )
      }

      removeTypeDefinitionCommand(definitionContainer, removeType) {
        return new RemoveTypeDefinitionCommand(definitionContainer, removeType)
      }

      removeValueFromAttributeDefinitionCommand(attributeDefinition, index) {
        return new RemoveValueFromAttributeDefinitionCommand(
          this._annotationModel.typeDefinition.attribute,
          attributeDefinition,
          index
        )
      }

      toggleFlagAttributeToItemsCommand(items, attributeDefinition) {
        return new ToggleFlagAttributeToItemsCommand(
          this._annotationModel,
          items,
          attributeDefinition
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Commander/index.js

    // A command is an operation by user that is saved as history, and can undo and redo.
    // Users can edit model only via commands.
    class Commander {
      constructor(
        editorHTMLElement,
        editorID,
        eventEmitter,
        annotationModel,
        selectionModel
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._editorID = editorID
        this._eventEmitter = eventEmitter
        this._annotationModel = annotationModel
        this._selectionModel = selectionModel
        this._history = new History(eventEmitter)
      }

      invoke(command) {
        if (command.isEmpty) {
          return
        }

        command.execute()
        this._history.push(command)
      }

      undo() {
        if (this._history.hasAnythingToUndo) {
          // Focus the editor.
          // Focus is lost when undo a creation.
          this._selectionModel.removeAll()
          this._editorHTMLElement.focus()

          const command = this._history.prev()
          if (command.kind.has('configuration_command')) {
            alertify_default().success('configuration has been undone')
          }

          command.revert().execute()
        }
      }

      redo() {
        if (this._history.hasAnythingToRedo) {
          // Select only new element when redo a creation.
          this._selectionModel.removeAll()

          const command = this._history.next()
          if (command.kind.has('configuration_command')) {
            alertify_default().success('configuration has been redo')
          }

          command.execute()
        }
      }

      get factory() {
        return new Factory(
          this._editorID,
          this._eventEmitter,
          this._annotationModel,
          this._selectionModel,
          this._annotationModel.typeDefinition
        )
      }
    } // CONCATENATED MODULE: ./src/lib/MODE.js

    const MODE = {
      INIT: 'Init',
      VIEW: 'View',
      EDIT_DENOTATION: 'Term',
      EDIT_BLOCK: 'Block',
      EDIT_RELATION: 'Relation'
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/State.js

    class StateMachine {
      /**
       *
       * @param {import('../../../AnnotationModel/RelationInstanceContainer').RelationInstanceContainer} relationContainer
       * @param {import('./Transition').default} transition
       * @param {import('../../FunctionAvailability').default} functionAvailability
       */
      constructor(relationContainer, eventEmitter, functionAvailability) {
        this._currentShowRelation = false
        this._currentState = MODE.INIT

        this._relationContainer = relationContainer
        this._eventEmitter = eventEmitter
        this._functionAvailability = functionAvailability
      }

      get currentState() {
        return this._currentState
      }

      toViewMode(showRelation) {
        this._currentShowRelation = showRelation
        this._currentState = MODE.VIEW
        this._emit()
      }

      toTermMode(showRelation) {
        this._currentShowRelation = showRelation
        this._currentState = MODE.EDIT_DENOTATION
        this._emit()
      }

      toBlockMode(showRelation) {
        this._currentShowRelation = showRelation
        this._currentState = MODE.EDIT_BLOCK
        this._emit()
      }

      toRelationMode() {
        this._currentShowRelation = true
        this._currentState = MODE.EDIT_RELATION
        this._emit()
      }

      toggleSimpleMode() {
        switch (this.currentState) {
          case MODE.EDIT_DENOTATION:
            this.toTermMode(!this._currentShowRelation)
            break
          case MODE.EDIT_BLOCK:
            this.toBlockMode(!this._currentShowRelation)
            break
          case MODE.VIEW:
            this.toViewMode(!this._currentShowRelation)
            break
          default:
            throw new Error(`Invalid state: ${this.currentState}`)
        }
      }

      changeModeByShortcut() {
        const modes = this._availableModes

        // No mode to change.
        if (modes.length <= 1) {
          return
        }

        const currentIndex = modes.findIndex(
          (mode) => mode.name === this.currentState
        )

        if (currentIndex < modes.length - 1) {
          // Change to the next mode.
          this[modes[currentIndex + 1].funcName](this.nextShowRelation)
        } else {
          // Change to the first mode.
          this[modes[0].funcName](this.nextShowRelation)
        }
      }

      get nextShowRelation() {
        if (this._currentState === MODE.EDIT_RELATION) {
          return this._relationContainer.some
        } else {
          return this._currentShowRelation
        }
      }

      _emit() {
        this._eventEmitter.emit(
          'textae-event.edit-mode.transition',
          this._currentState,
          this._currentShowRelation
        )
      }

      // Look at Function Availability and return the possible transition modes.
      get _availableModes() {
        const all = [
          {
            name: MODE.VIEW,
            availabilityName: 'view mode',
            funcName: 'toViewMode'
          },
          {
            name: MODE.EDIT_DENOTATION,
            availabilityName: 'term edit mode',
            funcName: 'toTermMode'
          },
          {
            name: MODE.EDIT_BLOCK,
            availabilityName: 'block edit mode',
            funcName: 'toBlockMode'
          },
          {
            name: MODE.EDIT_RELATION,
            availabilityName: 'relation edit mode',
            funcName: 'toRelationMode'
          }
        ]

        return all.filter((mode) =>
          this._functionAvailability.get(mode.availabilityName)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/clearTextSelection.js

    /* harmony default export */ function clearTextSelection() {
      window.getSelection().removeAllRanges()
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/isNodeDenotationSpan.js

    /* harmony default export */ function isNodeDenotationSpan(node) {
      return node.classList.contains('textae-editor__span')
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/isNodeTextBox.js

    /* harmony default export */ function isNodeTextBox(node) {
      return node.classList.contains('textae-editor__text-box')
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/isNodeStyleSpan.js

    /* harmony default export */ function isNodeStyleSpan(node) {
      return node.classList.contains('textae-editor__style')
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/isNodeBlockSpan.js

    /* harmony default export */ function isNodeBlockSpan(node) {
      return node.classList.contains('textae-editor__block')
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/PositionsOnAnnotation/getOffsetFromParent.js

    /* harmony default export */ function getOffsetFromParent(node) {
      let offset = 0

      for (const prevNode of node.parentElement.childNodes) {
        // until the focus node
        if (prevNode == node) {
          break
        }

        if (prevNode.nodeName === '#text') {
          offset += prevNode.nodeValue.length
        } else {
          offset += prevNode.textContent.length
        }
      }

      return offset
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/PositionsOnAnnotation/getParentOffset.js

    /* harmony default export */ function getParentOffset(span, node) {
      const parent = node.parentElement
      if (isNodeTextBox(parent)) {
        return 0
      }
      if (
        isNodeDenotationSpan(parent) ||
        isNodeBlockSpan(parent) ||
        isNodeStyleSpan(parent)
      ) {
        return span.get(parent.id).begin
      }
      throw new Error(`Can not get position of a node : ${node} ${node.data}`)
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/PositionsOnAnnotation/index.js

    class PositionsOnAnnotation {
      constructor(spanModelContainer, selectionWrapper) {
        this._spanModelContainer = spanModelContainer
        this._selection = selectionWrapper.selection
      }

      get anchor() {
        const position =
          getParentOffset(
            this._spanModelContainer,
            this._selection.anchorNode
          ) + getOffsetFromParent(this._selection.anchorNode)

        return position + this._selection.anchorOffset
      }

      get focus() {
        const position =
          getParentOffset(this._spanModelContainer, this._selection.focusNode) +
          getOffsetFromParent(this._selection.focusNode)

        return position + this._selection.focusOffset
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/SelectionWrapper/index.js

    class SelectionWrapper {
      constructor(spanModelContainer) {
        this.selection = window.getSelection()

        console.assert(
          this.parentOfAnchorNode.closest('.textae-editor__text-box') ===
            this.parentOfFocusNode.closest('.textae-editor__text-box'),
          'Text selection across editors is disabled'
        )

        this._spanModelContainer = spanModelContainer
      }

      get isParentOfAnchorNodeTextBox() {
        return isNodeTextBox(this.parentOfAnchorNode)
      }

      get isParentOfAnchorNodeDenotationSpan() {
        return isNodeDenotationSpan(this.parentOfAnchorNode)
      }

      get isParentOfAnchorNodeBlockSpan() {
        return isNodeBlockSpan(this.parentOfAnchorNode)
      }

      get isParentOfAnchorNodeStyleSpan() {
        return isNodeStyleSpan(this.parentOfAnchorNode)
      }

      get isParentOfFocusNodeTextBox() {
        return isNodeTextBox(this.parentOfFocusNode)
      }

      get isParentOfFocusNodeDenotationSpan() {
        return isNodeDenotationSpan(this.parentOfFocusNode)
      }

      get isParentOfFocusNodeBlockSpan() {
        return isNodeBlockSpan(this.parentOfFocusNode)
      }

      get isParentOfFocusNodeStyleSpan() {
        return isNodeStyleSpan(this.parentOfFocusNode)
      }

      get isParentOfBothNodesSame() {
        return this.parentOfAnchorNode === this.parentOfFocusNode
      }

      get isParentOfBothNodesTextBox() {
        return (
          this.isParentOfAnchorNodeTextBox && this.isParentOfFocusNodeTextBox
        )
      }

      get isParentsParentOfAnchorNodeAndFocusedNodeSame() {
        return (
          this.parentOfAnchorNode.parentElement ===
          this.parentOfFocusNode.parentElement
        )
      }

      get isAnchorNodeParentIsDescendantOfFocusNodeParent() {
        return this.parentOfAnchorNode.closest(`#${this.parentOfFocusNode.id}`)
      }

      get ancestorDenotationSpanOfAnchorNode() {
        return this.parentOfAnchorNode.closest('.textae-editor__span')
      }

      get ancestorDenotationSpanOfFocusNode() {
        return this.parentOfFocusNode.closest('.textae-editor__span')
      }

      get ancestorBlockSpanOfAnchorNode() {
        return this.parentOfAnchorNode.closest('.textae-editor__block')
      }

      get ancestorBlockSpanOfFocusNode() {
        return this.parentOfFocusNode.closest('.textae-editor__block')
      }

      get doesFitInOneBlockSpan() {
        return (
          this.ancestorBlockSpanOfAnchorNode ===
          this.ancestorBlockSpanOfFocusNode
        )
      }

      get parentOfAnchorNode() {
        return this.selection.anchorNode.parentElement
      }

      get parentOfFocusNode() {
        return this.selection.focusNode.parentElement
      }

      get positionsOnAnnotation() {
        return new PositionsOnAnnotation(this._spanModelContainer, this)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/selectSpan.js

    /* harmony default export */ function selectSpan(
      selectionModel,
      rangeOfSpans,
      event,
      spanID
    ) {
      if (rangeOfSpans.length) {
        selectionModel.selectSpanRange(rangeOfSpans)
        return
      }

      if (event.ctrlKey || event.metaKey) {
        selectionModel.span.toggle(spanID)
        return
      }

      selectionModel.selectSpan(spanID)
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/isRangeInTextBox.js

    /* harmony default export */ function isRangeInTextBox(
      selection,
      textBoxHTMLElement
    ) {
      return (
        selection.type === 'Range' &&
        textBoxHTMLElement.contains(selection.anchorNode) &&
        textBoxHTMLElement.contains(selection.focusNode)
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/MouseEventHandler.js

    class MouseEventHandler {
      constructor(
        editorHTMLElement,
        annotationModel,
        selectionModel,
        pallet,
        spanEditor
      ) {
        this._annotationModel = annotationModel
        this._selectionModel = selectionModel
        this._spanEditor = spanEditor
        this._editorHTMLElement = editorHTMLElement
        this._pallet = pallet
      }

      bodyClicked() {
        this._pallet.hide()
        this._selectionModel.removeAll()
      }

      textBoxClicked() {
        this._pallet.hide()

        const selection = window.getSelection()

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
        } else {
          this._selectionModel.removeAll()
        }
      }

      denotationSpanClicked(event) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (event.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        // When you create a denotation span and
        // click on another denotation span while holding down the Shift key,
        // the Selection type will be 'None'.
        if (selection.type === 'Caret' || selection.type === 'None') {
          this._selectSpan(event, event.target.id)
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
        }
      }

      blockSpanClicked(e) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (e.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
        }
      }

      styleSpanClicked(e) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (e.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          const span = e.target.closest('.textae-editor__span')
          if (span) {
            this._selectSpan(e, span.id)
          } else {
            this._selectionModel.removeAll()
          }
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
        }
      }

      signboardClicked() {
        this._editorHTMLElement.focus()
      }

      typeValuesClicked(event, entityID) {
        if (this._annotationModel.entity.get(entityID).isDenotation) {
          if (event.ctrlKey || event.metaKey) {
            this._selectionModel.entity.toggle(entityID)
          } else {
            this._selectionModel.selectEntity(entityID)
          }
        }
      }

      _selectSpan(event, spanID) {
        const selectedSpanID = this._selectionModel.span.singleId
        const rangeOfSpans =
          event.shiftKey && selectedSpanID
            ? this._annotationModel.span.rangeDenotationSpan(
                selectedSpanID,
                spanID
              )
            : []

        selectSpan(this._selectionModel, rangeOfSpans, event, spanID)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/SpanEditor/create/createCommand.js

    /* harmony default export */ function createCommand(
      commander,
      newSpan,
      isReplicateAuto,
      isDelimiterFunc
    ) {
      return commander.factory.createSpanAndAutoReplicateCommand(
        {
          begin: newSpan.begin,
          end: newSpan.end
        },
        isReplicateAuto,
        isDelimiterFunc
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/OrderedPositions.js

    class OrderedPositions {
      constructor(positions) {
        this._positions = positions
      }

      // switch the position when the selection is made from right to left
      get begin() {
        if (this._positions.anchor < this._positions.focus) {
          return this._positions.anchor
        }

        return this._positions.focus
      }

      // switch the position when the selection is made from right to left
      get end() {
        if (this._positions.anchor < this._positions.focus) {
          return this._positions.focus
        }

        return this._positions.anchor
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/getNewSpan.js

    /* harmony default export */ function getNewSpan(
      sourceDoc,
      spanAdjuster,
      selectionWrapper,
      spanConfig
    ) {
      const { positionsOnAnnotation } = selectionWrapper
      const orderedPositions = new OrderedPositions(positionsOnAnnotation)

      return {
        begin: spanAdjuster.backFromBegin(
          sourceDoc,
          orderedPositions.begin,
          spanConfig
        ),
        end:
          spanAdjuster.forwardFromEnd(
            sourceDoc,
            orderedPositions.end - 1,
            spanConfig
          ) + 1
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/SpanEditor/validateNewDennotationSpan.js

    /**
     *
     * @param {import('../../../../../AnnotationModel/SpanModelContainer').default} spanModelContainer
     * @returns
     */
    /* harmony default export */ function validateNewDennotationSpan(
      spanModelContainer,
      begin,
      end
    ) {
      // The span cross exists spans.
      if (spanModelContainer.isBoundaryCrossingWithOtherSpans(begin, end)) {
        alertify_default().warning(
          'A span cannot be modifyed to make a boundary crossing.'
        )
        return false
      }

      // The span exists already.
      if (spanModelContainer.hasDenotationSpan(begin, end)) {
        return false
      }

      // There is a BlockSpan that is a child.
      if (spanModelContainer.hasBlockSpanBetween(begin, end)) {
        return false
      }

      return true
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/SpanEditor/create/index.js

    /* harmony default export */ function create(
      sourceDoc,
      spanModelContainer,
      commander,
      spanAdjuster,
      isReplicateAuto,
      selectionWrapper,
      spanConfig,
      isDelimiterFunc
    ) {
      const { begin, end } = getNewSpan(
        sourceDoc,
        spanAdjuster,
        selectionWrapper,
        spanConfig
      )

      if (validateNewDennotationSpan(spanModelContainer, begin, end)) {
        const command = createCommand(
          commander,
          { begin, end },
          isReplicateAuto,
          isDelimiterFunc
        )

        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/shrinkSpan/shrinkSpanToSelection.js

    /**
     *
     * @param {import('../../../../AnnotationModel/SpanModelContainer').default} spanModelContainer
     */
    /* harmony default export */ function shrinkSpanToSelection(
      spanModelContainer,
      sourceDoc,
      commander,
      spanAdjuster,
      spanId,
      selectionWrapper,
      spanConfig,
      moveHandler
    ) {
      const { begin, end } = spanModelContainer
        .get(spanId)
        .getShortenInAnchorNodeToFocusNodeDirection(
          spanAdjuster,
          selectionWrapper,
          sourceDoc,
          spanConfig
        )

      // The span cross exists spans.
      if (spanModelContainer.isBoundaryCrossingWithOtherSpans(begin, end)) {
        alertify_default().warning(
          'A span cannot be shrinked to make a boundary crossing.'
        )
        return false
      }

      const doesExists = spanModelContainer.hasDenotationSpan(begin, end)

      if (begin < end && !doesExists) {
        moveHandler(begin, end)
      } else {
        commander.invoke(commander.factory.removeSpanCommand(spanId))
        return true
      }

      return false
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/shrinkSpan/index.js

    /* harmony default export */ function shrinkSpan(
      editorHTMLElement,
      spanModelContainer,
      sourceDoc,
      selectionModel,
      commander,
      spanAdjuster,
      spanId,
      selectionWrapper,
      spanConfig,
      moveHandler
    ) {
      if (spanId) {
        selectionModel.removeAll()

        // Get the next span before removing the old span.
        const nextSpan = getRightSpanElement(editorHTMLElement, spanId)
        const removed = shrinkSpanToSelection(
          spanModelContainer,
          sourceDoc,
          commander,
          spanAdjuster,
          spanId,
          selectionWrapper,
          spanConfig,
          moveHandler
        )

        if (removed && nextSpan) {
          selectionModel.selectSpan(nextSpan.id)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/hasCharacters.js

    // A span cannot be created include nonEdgeCharacters only.
    /* harmony default export */ function hasCharacters(
      sourceDoc,
      spanConfig,
      selectionWrapper
    ) {
      const { positionsOnAnnotation } = selectionWrapper
      const orderedPositions = new OrderedPositions(positionsOnAnnotation)
      const selectedString = sourceDoc.substring(
        orderedPositions.begin,
        orderedPositions.end
      )

      return spanConfig.removeBlankChractors(selectedString).length > 0
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/getIsDelimiterFunc.js

    /* harmony default export */ function getIsDelimiterFunc(
      controlViewModel,
      spanConfig
    ) {
      if (controlViewModel.isPushed('boundary detection')) {
        return (char) => spanConfig.isDelimiter(char)
      } else {
        return () => true
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/SpanEditor/isPositionBetweenSpan.js

    /* harmony default export */ function isPositionBetweenSpan(
      span,
      position
    ) {
      if (!span) {
        return false
      }

      return span.begin < position && position < span.end
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/SpanEditor/index.js

    class SpanEditor {
      constructor(
        editorHTMLElemnt,
        annotationModel,
        selectionModel,
        commander,
        controlViewModel,
        spanConfig
      ) {
        this._editorHTMLElement = editorHTMLElemnt
        this._annotationModel = annotationModel
        this._spanModelContainer = annotationModel.span
        this._selectionModel = selectionModel
        this._commander = commander
        this._controlViewModel = controlViewModel
        this._spanConfig = spanConfig
      }

      editFor(selectionWrapper) {
        if (selectionWrapper.isParentOfAnchorNodeTextBox) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInTextBoxFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInTextBoxFocusNodeInDenotationSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInTextBoxFocusNodeInBlockSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInTextBoxFocusNodeInStyleSpan(selectionWrapper)
            return
          }
        }
        if (selectionWrapper.isParentOfAnchorNodeDenotationSpan) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInDenotationSpanFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInDenotationSpanFocusNodeInDenotationSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInDenotationSpanFocusNodeInBlockSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInDenotationSpanFocusNodeInStyleSpan(
              selectionWrapper
            )
            return
          }
        }
        if (selectionWrapper.isParentOfAnchorNodeBlockSpan) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInBlockSpanFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInBlockSpanFocusNodeInDenotationSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInBlockSpanFocusNodeInBlockSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInBlockSpanFocusNodeInStyleSpan(selectionWrapper)
            return
          }
        }
        if (selectionWrapper.isParentOfAnchorNodeStyleSpan) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._anchorNodeInStyleSpanFocusNodeInTextBox(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeDenotationSpan) {
            this._anchorNodeInStyleSpanFocusNodeInDenotationSpan(
              selectionWrapper
            )
            return
          }
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._anchorNodeInStyleSpanFocusNodeInBlockSpan(selectionWrapper)
            return
          }
          if (selectionWrapper.isParentOfFocusNodeStyleSpan) {
            this._anchorNodeInStyleSpanFocusNodeInStyleSpan(selectionWrapper)
            return
          }
        }
      }

      cerateSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._spanModelContainer)

        if (selectionWrapper.isParentOfBothNodesSame) {
          this._create(selectionWrapper)
        }
      }

      expandForTouchDevice() {
        const expandedSpan = this._getExpandedSpanForTouchDevice()
        if (expandedSpan) {
          const { spanID, begin, end } = expandedSpan

          // The span cross exists spans.
          if (
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )
          ) {
            return
          }

          // A span cannot be expanded a span to the same as an existing span.
          if (this._spanModelContainer.hasDenotationSpan(begin, end)) {
            return
          }

          this._commander.invoke(
            this._commander.factory.moveDenotationSpanCommand(
              spanID,
              begin,
              end
            )
          )
        }
      }

      shrinkForTouchDevice() {
        const shrinkedSpan = this._getShrinkedSpanForTouchDevice()
        if (shrinkedSpan) {
          const { spanID, begin, end } = shrinkedSpan
          const nextSpan = getRightSpanElement(this._editorHTMLElement, spanID)

          // The span cross exists spans.
          if (
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )
          ) {
            alertify_default().warning(
              'A span cannot be shrinked to make a boundary crossing.'
            )
            return
          }

          const doesExists = this._spanModelContainer.hasDenotationSpan(
            begin,
            end
          )
          if (begin < end && !doesExists) {
            this._commander.invoke(
              this._commander.factory.moveDenotationSpanCommand(
                spanID,
                begin,
                end
              )
            )
          } else {
            this._commander.invoke(
              this._commander.factory.removeSpanCommand(spanID)
            )
            if (nextSpan) {
              this._selectionModel.selectSpan(nextSpan.id)
            }
          }
        }
      }

      _getExpandedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._spanModelContainer)

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to expand does not exist.
        if (
          selectionWrapper.ancestorDenotationSpanOfAnchorNode == null &&
          selectionWrapper.ancestorDenotationSpanOfFocusNode == null
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfAnchorNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getExpandedInAnchorNodeToFocusNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfFocusNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getExpandedInFocusNodeToAnchorNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }
      }

      _getShrinkedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(this._spanModelContainer)

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to shrink does not exist.
        if (
          selectionWrapper.ancestorDenotationSpanOfAnchorNode == null &&
          selectionWrapper.ancestorDenotationSpanOfFocusNode == null
        ) {
          return null
        }

        // On mobile devices,
        // do not shrink the denotation span when the selected text fits into one denotation span.
        if (
          selectionWrapper.parentOfAnchorNode ===
          selectionWrapper.parentOfFocusNode
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfAnchorNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getShortenInFocusNodeToAnchorNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfFocusNode.id

          return {
            spanID,
            ...this._spanModelContainer
              .get(spanID)
              .getShortenInAnchorNodeToFocusNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }
      }

      _anchorNodeInTextBoxFocusNodeInTextBox(selectionWrapper) {
        // The parent of the focusNode is the text.
        this._create(selectionWrapper)
      }

      _anchorNodeInTextBoxFocusNodeInDenotationSpan(selectionWrapper) {
        const targetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (targetSpanID) {
          this._shrink(selectionWrapper, targetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInTextBoxFocusNodeInBlockSpan() {
        clearTextSelection()
      }

      _anchorNodeInTextBoxFocusNodeInStyleSpan(selectionWrapper) {
        // There is a Span between the StyleSpan and the text.
        // Shrink Span when mousedown on the text or a span and mouseup on the styleSpan.
        const targetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (targetSpanID) {
          this._shrink(selectionWrapper, targetSpanID)
          return
        }

        this._create(selectionWrapper)
      }

      _anchorNodeInDenotationSpanFocusNodeInTextBox(selectionWrapper) {
        this._expand(selectionWrapper, selectionWrapper.parentOfAnchorNode.id)
      }

      _anchorNodeInDenotationSpanFocusNodeInDenotationSpan(selectionWrapper) {
        const shrinkableEndSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkableEndSpanID) {
          this._shrink(selectionWrapper, shrinkableEndSpanID)
          return
        }

        // The anchor node and the focus node are in the same span.
        if (selectionWrapper.isParentOfBothNodesSame) {
          this._create(selectionWrapper)
          return
        }

        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        // Mouse down on the child DenotationSpan
        // and mouse up on the sibling DenotationSpan of the parent DenotationSpan
        // to expand the the child DenotationSpan.
        // The condition for this is that the ancestor of the anchor node
        // and the ancestor of the focus node are the same.
        // Since this is always true, it will always expand when it is neither create nor shrink.
        this._expand(selectionWrapper, selectionWrapper.parentOfAnchorNode.id)
      }

      _anchorNodeInDenotationSpanFocusNodeInBlockSpan(selectionWrapper) {
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          this._expand(selectionWrapper, selectionWrapper.parentOfAnchorNode.id)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInDenotationSpanFocusNodeInStyleSpan(selectionWrapper) {
        const shrinkTargetEndSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkTargetEndSpanID) {
          this._shrink(selectionWrapper, shrinkTargetEndSpanID)
          return
        }

        if (
          selectionWrapper.parentOfAnchorNode ===
          selectionWrapper.ancestorDenotationSpanOfFocusNode
        ) {
          this._create(selectionWrapper)
          return
        }

        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }
      }

      _anchorNodeInBlockSpanFocusNodeInTextBox() {
        clearTextSelection()
      }

      _anchorNodeInBlockSpanFocusNodeInDenotationSpan(selectionWrapper) {
        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInBlockSpanFocusNodeInBlockSpan(selectionWrapper) {
        this._create(selectionWrapper)
      }

      _anchorNodeInBlockSpanFocusNodeInStyleSpan(selectionWrapper) {
        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInStyleSpanFocusNodeInTextBox(selectionWrapper) {
        // If the anchor node is a style span but has a parent span, extend the parent span.
        if (selectionWrapper.ancestorDenotationSpanOfAnchorNode) {
          const spanID = selectionWrapper.ancestorDenotationSpanOfAnchorNode.id

          if (spanID) {
            this._expand(selectionWrapper, spanID)
          }
          return
        }

        this._create(selectionWrapper)
      }

      _anchorNodeInStyleSpanFocusNodeInDenotationSpan(selectionWrapper) {
        const shrinkTargetEndSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkTargetEndSpanID) {
          this._shrink(selectionWrapper, shrinkTargetEndSpanID)
          return
        }

        if (
          selectionWrapper.ancestorDenotationSpanOfAnchorNode ===
          selectionWrapper.parentOfFocusNode
        ) {
          this._create(selectionWrapper)
          return
        }

        const shrinkTargetSpanID = this._getShrinkableSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _anchorNodeInStyleSpanFocusNodeInBlockSpan(selectionWrapper) {
        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        this._create(selectionWrapper)
      }

      _anchorNodeInStyleSpanFocusNodeInStyleSpan(selectionWrapper) {
        const shrinkTargetSpanID =
          this._getShrinkableEndSpanID(selectionWrapper)
        if (shrinkTargetSpanID) {
          this._shrink(selectionWrapper, shrinkTargetSpanID)
          return
        }

        if (
          selectionWrapper.isParentOfBothNodesSame ||
          selectionWrapper.isParentsParentOfAnchorNodeAndFocusedNodeSame
        ) {
          this._create(selectionWrapper)
          return
        }

        const expandTargetSpanID = this._getExpandableSpanID(selectionWrapper)
        if (expandTargetSpanID) {
          this._expand(selectionWrapper, expandTargetSpanID)
          return
        }

        clearTextSelection()
      }

      _getShrinkableEndSpanID(selectionWrapper) {
        if (selectionWrapper.ancestorDenotationSpanOfAnchorNode) {
          const { anchor } = selectionWrapper.positionsOnAnnotation

          const { begin, end } = this._spanModelContainer.getDenotationSpan(
            selectionWrapper.ancestorDenotationSpanOfAnchorNode.id
          )
          if (anchor === begin || anchor === end) {
            // Shrink the span of the ends.
            if (
              selectionWrapper.ancestorDenotationSpanOfAnchorNode ===
              selectionWrapper.ancestorDenotationSpanOfFocusNode
            ) {
              return selectionWrapper.ancestorDenotationSpanOfAnchorNode.id
            }

            // Shrink the parent of the parent-child span at the end.
            if (
              selectionWrapper.ancestorDenotationSpanOfAnchorNode !==
                selectionWrapper.ancestorDenotationSpanOfFocusNode &&
              selectionWrapper.ancestorDenotationSpanOfFocusNode.contains(
                selectionWrapper.ancestorDenotationSpanOfAnchorNode
              )
            ) {
              return selectionWrapper.ancestorDenotationSpanOfFocusNode.id
            }
          }
        }
      }

      _getShrinkableSpanID(selectionWrapper) {
        const targetSpanElement =
          selectionWrapper.ancestorDenotationSpanOfFocusNode

        if (targetSpanElement) {
          if (
            selectionWrapper.ancestorDenotationSpanOfAnchorNode !==
              targetSpanElement &&
            (!selectionWrapper.ancestorDenotationSpanOfAnchorNode ||
              selectionWrapper.ancestorDenotationSpanOfAnchorNode.contains(
                targetSpanElement
              ))
          ) {
            return targetSpanElement.id
          }
        }

        // If the parent of the anchor node is a descendant of the focus node,
        // and the focus node is selected, shrink the focus node.
        if (selectionWrapper.isAnchorNodeParentIsDescendantOfFocusNodeParent) {
          if (
            isPositionBetweenSpan(
              this._selectionModel.span.single,
              selectionWrapper.positionsOnAnnotation.focus
            )
          ) {
            return this._selectionModel.span.single.element.id
          }
        }
      }

      _getExpandableSpanID(selectionWrapper) {
        const targetSpanElement =
          selectionWrapper.ancestorDenotationSpanOfAnchorNode

        if (targetSpanElement) {
          const { ancestorDenotationSpanOfFocusNode } = selectionWrapper

          if (ancestorDenotationSpanOfFocusNode) {
            if (
              targetSpanElement !== ancestorDenotationSpanOfFocusNode &&
              (targetSpanElement.parentElement ===
                ancestorDenotationSpanOfFocusNode.parentElement ||
                ancestorDenotationSpanOfFocusNode.contains(targetSpanElement))
            ) {
              return targetSpanElement.id
            }
          } else {
            return targetSpanElement.id
          }
        }
      }

      _create(selectionWrapper) {
        if (
          hasCharacters(
            this._annotationModel.sourceDoc,
            this._spanConfig,
            selectionWrapper
          )
        ) {
          this._selectionModel.removeAll()
          create(
            this._annotationModel.sourceDoc,
            this._spanModelContainer,
            this._commander,
            this._controlViewModel.spanAdjuster,
            this._isReplicateAuto,
            selectionWrapper,
            this._spanConfig,
            getIsDelimiterFunc(this._controlViewModel, this._spanConfig)
          )
        }
        clearTextSelection()
      }

      _expand(selectionWrapper, spanID) {
        this._selectionModel.removeAll()

        const { begin, end } = this._spanModelContainer
          .get(spanID)
          .getExpandedInAnchorNodeToFocusNodeDirection(
            this._controlViewModel.spanAdjuster,
            selectionWrapper,
            this._annotationModel.sourceDoc,
            this._spanConfig
          )

        if (validateNewDennotationSpan(this._spanModelContainer, begin, end)) {
          this._commander.invoke(
            this._commander.factory.moveDenotationSpanCommand(
              spanID,
              begin,
              end
            )
          )
        }

        clearTextSelection()
      }

      _shrink(selectionWrapper, spanID) {
        shrinkSpan(
          this._editorHTMLElement,
          this._spanModelContainer,
          this._annotationModel.sourceDoc,
          this._selectionModel,
          this._commander,
          this._controlViewModel.spanAdjuster,
          spanID,
          selectionWrapper,
          this._spanConfig,
          (begin, end) => {
            this._commander.invoke(
              this._commander.factory.moveDenotationSpanCommand(
                spanID,
                begin,
                end
              )
            )
          }
        )

        clearTextSelection()
      }

      get _isReplicateAuto() {
        return this._controlViewModel.isPushed('auto replicate')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/forwardMethods.js

    /* harmony default export */ function forwardMethods(
      delegator,
      getTargetFunction,
      methods
    ) {
      for (const method of methods) {
        delegator[method] = (...args) => {
          const target = getTargetFunction()
          console.assert(
            target[method],
            `No ${method} method to forward`,
            target
          )

          return target[method].apply(target, args)
        }
      }

      return delegator
    } // CONCATENATED MODULE: ./src/lib/component/PromiseDialog.js

    class PromiseDialog extends Dialog {
      constructor(title, contentHtml, option, getResultsFunc) {
        const onOKButtonClick = () => {
          const results = getResultsFunc()
          if (results) {
            this.resolveFunc(results)
          }
          super.close()
        }
        const okButton = {
          text: 'OK',
          click: onOKButtonClick
        }
        option.buttons = option.buttons
          ? option.buttons.concat([okButton])
          : [okButton]

        super(title, contentHtml, option)

        delegate_default()(
          super.el,
          '.textae-editor__promise-dialog__observable-element',
          'keyup',
          (e) => {
            if (e.keyCode === 13) {
              onOKButtonClick()
            }
          }
        )
      }

      open() {
        super.open()
        return new Promise((resolveFunc) => (this.resolveFunc = resolveFunc))
      }
    }

    // EXTERNAL MODULE: ./node_modules/jquery-ui/ui/widgets/autocomplete.js
    var autocomplete = __webpack_require__(2993) // CONCATENATED MODULE: ./src/lib/component/customize-jquery-ui-autocomplete.js
    /* eslint no-underscore-dangle: 0 */
    // Customize jQuery-ui autocomplete
    /* harmony default export */ function customize_jquery_ui_autocomplete() {
      // Replace @ to font awesome icon
      jquery_default().ui.autocomplete.prototype._renderItem = (
        $ul,
        { id, label }
      ) => {
        const $li = jquery_default()(anemone`
      <li>
        <div>
          ${label}
          <i class="fa fa-globe"></i>
          ${id}
        </div>
      </li>`)

        $ul.append($li)

        return $li
      }
      jquery_default().ui.autocomplete.prototype._resizeMenu = () => {
        // Prepend resize menu
      }
    } // CONCATENATED MODULE: ./src/lib/component/searchTerm.js

    /* harmony default export */ function searchTerm(
      autocompletionWs,
      localData,
      term,
      done
    ) {
      if (!autocompletionWs) {
        done(localData)
        return
      }

      const request = new XMLHttpRequest()

      // Append a term parameter.
      const url = new URL(autocompletionWs, location)
      url.searchParams.append('term edit mode', term)

      request.open('GET', url.href, true)
      request.onload = () => {
        if (request.status >= 200 && request.status < 400) {
          // Success!
          const data = JSON.parse(request.response)

          // Prior lacal data if duplicated
          const filtteredData = data.filter(
            (t) => !localData.some((l) => t.id === l.id)
          )

          done(localData.concat(filtteredData))
        }
      }

      request.send()
    } // CONCATENATED MODULE: ./src/lib/component/TypeDefinitionDialog/select.js

    /* harmony default export */ function TypeDefinitionDialog_select(
      inputId,
      inputLabel,
      { item }
    ) {
      inputId.value = item.id
      inputLabel.value = item.label
      return false
    } // CONCATENATED MODULE: ./src/lib/component/TypeDefinitionDialog/setSourceOfAutoComplete.js

    customize_jquery_ui_autocomplete()

    /* harmony default export */ function setSourceOfAutoComplete(
      el,
      autocompletionWs,
      getLocalData
    ) {
      const inputs = el.querySelectorAll('input')

      // Update the source
      jquery_default()(inputs[0]).autocomplete({
        source: (request, response) =>
          searchTerm(
            autocompletionWs,
            getLocalData(request.term),
            request.term,
            response
          ),
        minLength: 3,
        select: (_, ui) => TypeDefinitionDialog_select(inputs[0], inputs[1], ui)
      })

      jquery_default()(inputs[1]).autocomplete({
        source: (request, response) =>
          searchTerm(
            autocompletionWs,
            getLocalData(request.term),
            request.term,
            response
          ),
        minLength: 3,
        select: (_, ui) => TypeDefinitionDialog_select(inputs[0], inputs[1], ui)
      })
    } // CONCATENATED MODULE: ./src/lib/component/TypeDefinitionDialog/template.js

    function template(context) {
      const { id, label, color, isDefault } = context
      return anemone`
<div class="textae-editor__type-definition-dialog__container">
  <div class="textae-editor__type-definition-dialog__row ui-front">
    <label>Id</label>
    <input
      class="textae-editor__type-definition-dialog--id textae-editor__promise-dialog__observable-element"
      value="${id || ''}">
  </div>
  <div class="textae-editor__type-definition-dialog__row ui-front">
    <label>Label<span></span></label>
    <input value="${label}">
  </div>
  <div class="textae-editor__type-definition-dialog__color-picker">
    <label><input
      class="textae-editor__type-definition-dialog__color-picker__input"
      type="color"
      value="${color}">
    Color</label>
  </div>
  <div class="textae-editor__type-definition-dialog__set-default">
    <label><input
      class="textae-editor__type-definition-dialog__set-default__input"
      type="checkbox" ${
        isDefault ? 'checked="checked" disabled="disabled"' : ''
      }>
    Default type</label>
  </div>
</div>`
    } // CONCATENATED MODULE: ./src/lib/component/TypeDefinitionDialog/index.js

    class TypeDefinitionDialog extends PromiseDialog {
      constructor(
        title,
        content,
        definitionContainer,
        autocompletionWs,
        convertToResultsFunc
      ) {
        super(title, template(content), {}, () => {
          const inputs = super.el.querySelectorAll('input')
          return convertToResultsFunc(
            inputs[0].value,
            inputs[1].value,
            inputs[2].value,
            inputs[3].checked
          )
        })

        setSourceOfAutoComplete(super.el, autocompletionWs, (term) =>
          definitionContainer.findByLabel(term)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/component/CreateTypeDefinitionDialog.js

    class CreateTypeDefinitionDialog extends TypeDefinitionDialog {
      constructor(definitionContainer, autocompletionWs) {
        const convertToReseltsFunc = (
          newId,
          newLabel,
          newColor,
          newDefault
        ) => {
          if (newId === '') {
            return
          }

          const newType = {
            id: newId,
            color: newColor
          }

          if (newLabel !== '') {
            newType.label = newLabel
          }

          if (newDefault) {
            newType.default = newDefault
          }

          return { newType }
        }

        super(
          'New type',
          {
            id: null,
            label: '',
            color: definitionContainer.defaultColor,
            isDefault: false
          },
          definitionContainer,
          autocompletionWs,
          convertToReseltsFunc
        )
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeDefinitionDialog/getDifference.js

    /* harmony default export */ function getDifference(before, after) {
      const changedProperties = new Map()

      if (before.id !== after.id) {
        changedProperties.set('id', after.id)
      }

      if (before.label !== after.label) {
        changedProperties.set('label', after.label === '' ? null : after.label)
      }

      if (before.color !== after.color) {
        changedProperties.set('color', after.color === '' ? null : after.color)
      }

      if (before.isDefault !== after.isDefault) {
        changedProperties.set('default', after.isDefault ? true : null)
      }

      return changedProperties
    } // CONCATENATED MODULE: ./src/lib/component/EditTypeDefinitionDialog/index.js

    class EditTypeDefinitionDialog extends TypeDefinitionDialog {
      constructor(definitionContainer, id, color, isDefault, autocompletionWs) {
        const label = definitionContainer.getLabel(id) || ''

        const beforeChange = {
          id,
          label,
          color,
          isDefault
        }

        const convertToReseltsFunc = (
          newId,
          newLabel,
          newColor,
          newDefault
        ) => {
          const afterChange = {
            id: newId,
            label: newLabel,
            color: newColor,
            isDefault: newDefault
          }

          const changedProperties = getDifference(beforeChange, afterChange)

          return {
            id,
            changedProperties
          }
        }

        super(
          'Edit type',
          beforeChange,
          definitionContainer,
          autocompletionWs,
          convertToReseltsFunc
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/Edit/bindPalletEvents/checkButtonEnable.js

    /* harmony default export */ function checkButtonEnable(targetNode) {
      return !targetNode.classList.contains(
        'textae-editor__pallet__table-button--disabled'
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/Edit/bindPalletEvents/index.js

    /* harmony default export */ function bindPalletEvents(
      pallet,
      commander,
      getAutocompletionWs,
      definitionContainer,
      annotationType,
      selectionModel,
      annotationModel
    ) {
      delegate_default()(
        pallet.el,
        `.textae-editor__pallet__add-button`,
        'click',
        () => {
          new CreateTypeDefinitionDialog(
            definitionContainer,
            getAutocompletionWs()
          )
            .open()
            .then(({ newType }) =>
              commander.invoke(
                commander.factory.createTypeDefinitionCommand(
                  definitionContainer,
                  newType
                )
              )
            )
        }
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__label',
        'click',
        (e) =>
          commander.invoke(
            commander.factory.changeTypeOfSelectedItemsCommand(
              annotationType,
              e.delegateTarget.dataset.id
            )
          )
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__select-all',
        'click',
        (e) => {
          if (!checkButtonEnable(e.target)) {
            return
          }

          selectionModel.removeAll()
          const ids = annotationModel[annotationType]
            .findByType(e.delegateTarget.dataset.id)
            .map(({ id }) => id)
          selectionModel.add(annotationType, ids)
        }
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__edit-type',
        'click',
        (e) => {
          new EditTypeDefinitionDialog(
            definitionContainer,
            e.target.dataset.id,
            e.target.dataset.color.toLowerCase(),
            e.target.dataset.isDefault === 'true',
            getAutocompletionWs()
          )
            .open()
            .then(({ id, changedProperties }) => {
              if (changedProperties.size) {
                commander.invoke(
                  commander.factory.changeTypeDefinitionCommand(
                    definitionContainer,
                    annotationType,
                    id,
                    changedProperties
                  )
                )
              }
            })
        }
      )

      delegate_default()(
        pallet.el,
        '.textae-editor__pallet__remove',
        'click',
        (e) => {
          if (!checkButtonEnable(e.target)) {
            return
          }
          const { id } = e.delegateTarget.dataset
          const { label } = e.delegateTarget.dataset

          const removeType = {
            id,
            label: label || ''
          }

          if (typeof id === 'undefined') {
            throw new Error('You must set the type id to remove.')
          }

          commander.invoke(
            commander.factory.removeTypeDefinitionCommand(
              definitionContainer,
              removeType
            )
          )
        }
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/Edit/index.js

    class Edit {
      constructor(
        editorHTMLElement,
        selectionModel,
        annotationModel,
        pallet,
        commander,
        getAutocompletionWs,
        definitionContainer,
        annotationType
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
        this._annotationModel = annotationModel
        this._getAutocompletionWs = getAutocompletionWs
        this._definitionContainer = definitionContainer
        this._commander = commander

        this._pallet = pallet

        bindPalletEvents(
          pallet,
          commander,
          getAutocompletionWs,
          definitionContainer,
          annotationType,
          selectionModel,
          annotationModel
        )

        editorHTMLElement.appendChild(pallet.el)

        forwardMethods(this, () => pallet, [
          'showPallet',
          'selectLeftAttributeTab',
          'selectRightAttributeTab'
        ])
      }

      get pallet() {
        return this._pallet
      }

      // Dummy functions
      createSpan() {}
      expandSpan() {}
      shrinkSpan() {}
      relationClicked() {}
      relationBollardClicked() {}

      manipulateAttribute(number, shiftKey) {
        if (shiftKey) {
          this._attributeEditor.deleteAt(number)
        } else {
          this._attributeEditor.addOrEditAt(number)
        }
      }

      _typeValuesChanged({ typeName, label, attributes = [] }) {
        const commands = this._commander.factory.changeTypeValuesCommand(
          label,
          typeName,
          this._definitionContainer,
          attributes
        )

        if (typeName) {
          this._commander.invoke(commands)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/getEntityHTMLelementFromChild.js

    /* harmony default export */ function getEntityHTMLelementFromChild(
      elementInEntityHtmlelement
    ) {
      return elementInEntityHtmlelement.closest('.textae-editor__signboard')
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/bindMouseEvents.js

    // For support context menu.
    // Mouse up event occurs when either left or right button is clicked.
    // Change mouse events to monitor from mouseup to click since v5.0.0.
    /* harmony default export */ function bindMouseEvents(
      editorHTMLElement,
      mouseEventHandler
    ) {
      const listeners = []

      // In Friefox, the text box click event fires when you shrink and erase a span.
      // To do this, the span mouse-up event selects the span to the right of the erased span,
      // and then the text box click event deselects it.
      // To prevent this, we set a flag to indicate that it is immediately after the span's mouse-up event.
      let afterSpanMouseUpEventFlag = false

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__text-box',
          'click',
          (e) => {
            if (
              e.target.classList.contains('textae-editor__text-box') &&
              !afterSpanMouseUpEventFlag
            ) {
              mouseEventHandler.textBoxClicked()
            }
          }
        )
      )

      // When extending span, the behavior depends on whether span is selected or not;
      // you must not deselect span before editing it.
      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor',
          'click',
          (e) => {
            // The delegate also fires events for child elements of the selector.
            // Ignores events that occur in child elements.
            // Otherwise, you cannot select child elements.
            if (e.target.classList.contains('textae-editor')) {
              mouseEventHandler.bodyClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard',
          'mousedown',
          () => mouseEventHandler.signboardClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard__type-values',
          'click',
          (event) => {
            const entityID = getEntityHTMLelementFromChild(event.target).dataset
              .id
            mouseEventHandler.typeValuesClicked(event, entityID)
          }
        )
      )

      // To shrink a span listen the mouseup event.
      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__span',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__span')) {
              mouseEventHandler.denotationSpanClicked(e)
              afterSpanMouseUpEventFlag = true

              // In Chrome, the text box click event does not fire when you shrink the span and erase it.
              // Instead of beating the flag on the text box click event,
              // it uses a timer to beat the flag instantly, faster than any user action.
              setTimeout(() => (afterSpanMouseUpEventFlag = false), 0)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__block',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__block')) {
              mouseEventHandler.blockSpanClicked(e)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__style',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__style')) {
              mouseEventHandler.styleSpanClicked(e)
            }
          }
        )
      )

      return listeners
    }

    // EXTERNAL MODULE: ./node_modules/jquery-ui/ui/widgets/draggable.js
    var draggable = __webpack_require__(7285) // CONCATENATED MODULE: ./src/lib/component/Pallet/enableJqueryDraggable.js
    /* harmony default export */ function enableJqueryDraggable(
      element,
      editorHTMLElement
    ) {
      jquery_default()(element).draggable({
        containment: editorHTMLElement,
        distance: 10
      })
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/setWidthWithin.js

    /* harmony default export */ function setWidthWithin(pallet, width) {
      pallet.style.width = 'auto'

      if (width - 2 <= pallet.offsetWidth) {
        pallet.style.width = `${width - 4}px`
      }
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/setHeightWithin.js

    const BORDER_HEIGHT = 7 * 2

    /* harmony default export */ function setHeightWithin(pallet, height) {
      if (height - BORDER_HEIGHT <= pallet.offsetHeight) {
        pallet.style.height = `${height - BORDER_HEIGHT}px`
      } else {
        pallet.style.height = null
      }
    } // CONCATENATED MODULE: ./src/lib/component/Pallet/index.js

    class Pallet {
      constructor(editorHTMLElement, title, mousePoint) {
        this._editorHTMLElement = editorHTMLElement
        this._title = title
        this._el = this.createElement()
        this._mousePoint = mousePoint

        // let the pallet draggable.
        enableJqueryDraggable(this._el, editorHTMLElement)

        // bugfix: Shortcut keys do not work after operating palette buttons.
        //
        // Some browsers focus button at clicking it.
        // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        // There are hacks that can override this behavior.
        // See: https://stackoverflow.com/questions/8735764/prevent-firing-focus-event-when-clicking-on-div
        // Simply refocus the editor for the following reasons:
        // 1. It's hard to see which browsers are hack-enabled using mousedown + preventDefault
        // 2. preventDefault changes default operations other than focus. Difficult to investigate impact range
        // 3. Operations that focus on a specific DOM element will work in any browser
        // 4. Refocusing on a focused DOM element has no side effects
        delegate_default()(this._el, '[type="button"]', 'click', () =>
          editorHTMLElement.focus()
        )

        delegate_default()(
          this._el,
          '.textae-editor__pallet__close-button',
          'click',
          () => this.hide()
        )
      }

      updateDisplay() {
        if (this.visibly) {
          this._updateDisplay()
        }
      }

      get el() {
        return this._el
      }

      show() {
        this._el.style.display = 'block'
        this._updateDisplay()

        this._moveInto()
      }

      hide() {
        this._el.style.display = 'none'
      }

      get visibly() {
        return this._el.style.display !== 'none'
      }

      createElement() {
        // Add ui-dialog class to prohibit the entity edit dialog from taking the focus.
        const html = `
        <div
          class="textae-editor__pallet ui-dialog"
          style="display: none;"
          >
        </div>`
        return dohtml_default().create(html)
      }

      _updateDisplay() {
        // Wrap the content in a special class so that you can determine if the target of the event is an element of the palette
        // even after the content has been removed from the DOM tree.
        // The taxtae-editor deselects itself when a click event to something other than taxtae-editor occurs.
        // After updating the palette, the click event reaches the body.
        // At that time, if the target of the event is the palette, you can see that it is an event for textae-editor.
        this._el.innerHTML = `
      <div class="textae-editor__pallet__container">
        <div class="textae-editor__pallet__title-bar ui-widget-header ui-corner-all">
          <span class="textae-editor__pallet__title-string">${this._title}</span>
          <button
            type="button"
            class="textae-editor__pallet__close-button ui-button ui-corner-all ui-widget ui-button-icon-only ui-dialog-titlebar-close"
            title="Close">
            <span class="ui-button-icon ui-icon ui-icon-closethick"></span>
            <span class="ui-button-icon-space"> </span>Close
          </button>
        </div>
        <div class="textae-editor__pallet__content">${this._content}</div>
      </div>
    `

        setWidthWithin(this._el, this._maxWidth)
        setHeightWithin(
          this._el.querySelector('.textae-editor__pallet__container'),
          this._maxHeight
        )
      }

      _moveInto() {
        this._el.style.left = `${this._left}px`
        this._el.style.top = `${this._top}px`
      }

      get _left() {
        const { clientX } = this._mousePoint
        const left = clientX - this._editorHTMLElement.getBoundingClientRect().x

        // Pull left the pallet when the pallet protrudes from right of the editor.
        if (this._maxWidth < left + this._el.offsetWidth) {
          return this._maxWidth - this._el.offsetWidth - 2
        }

        return left
      }

      get _top() {
        const { clientY } = this._mousePoint
        const editorClientY = this._editorHTMLElement.getBoundingClientRect().y

        // Pull up the pallet when the pallet protrudes from bottom of the window.
        if (this._maxHeight < clientY + this._el.offsetHeight) {
          return this._maxHeight - this._el.offsetHeight - editorClientY - 2
        }

        return clientY - editorClientY
      }

      get _maxWidth() {
        return this._editorHTMLElement.offsetWidth
      }

      get _maxHeight() {
        return document.documentElement.clientHeight
      }
    } // CONCATENATED MODULE: ./src/lib/component/getInputElementValue.js

    /* harmony default export */ function getInputElementValue(el, selector) {
      return (
        el.querySelector(`input${selector}`) &&
        el.querySelector(`input${selector}`).value
      )
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputDefault.js

    /* harmony default export */ function inputDefault(
      componentClassName,
      defaultValue
    ) {
      return () => anemone`
  <div class="${componentClassName}__row">
    <label>Default</label>
    <input
      value="${defaultValue || ''}"
      class="${componentClassName}__default-value"
    >
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputMediaHeight.js

    /* harmony default export */ function inputMediaHeight(
      componentClassName,
      mediaHeight
    ) {
      return () => anemone`
    <div class="${componentClassName}__row">
      <label>Media Height</label>
      <input
        type="text"
        value="${mediaHeight || ''}"
        class="${componentClassName}__media-height"
      >
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/getRandomColorString.js

    /* harmony default export */ function getRandomColorString() {
      return `#${getRandomHEXFrom64ToFF()}${getRandomHEXFrom64ToFF()}${getRandomHEXFrom64ToFF()}`
    }

    function getRandomHEXFrom64ToFF() {
      return Math.floor(Math.random() * 155 + 100).toString(16)
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputLabelAndColor.js

    /* harmony default export */ function inputLabelAndColor(
      componentClassName,
      label,
      color
    ) {
      return () => anemone`
    <div class="${componentClassName}__row">
      <label>Label</label>
      <input
        type="text"
        value="${label || ''}"
        class="${componentClassName}__label"
      >
    </div>
    <div class="${componentClassName}__row">
      <label>Color</label>
      <input
        type="color"
        value="${color || getRandomColorString()}"
        class="${componentClassName}__color"
      >
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/inputNumeric.js

    /* harmony default export */ function inputNumeric(
      componentClassName,
      min,
      max,
      step
    ) {
      return () => anemone`
    <div class="${componentClassName}__row">
      <label>Min</label>
      <input
        type="text"
        value="${min || ''}"
        class="${componentClassName}__min"
      >
    </div>
    <div class="${componentClassName}__row">
      <label>Max</label>
      <input
        type="text"
        value="${max || ''}"
        class="${componentClassName}__max"
      >
    </div>
    <div class="${componentClassName}__row">
      <label>Step</label>
      <input
        type="text"
        value="${step || STEP}"
        class="${componentClassName}__step"
      >
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/inputAttributeDefinition/index.js

    /* harmony default export */ function inputAttributeDefinition(
      componentClassName,
      context
    ) {
      const {
        pred,
        default: defaultValue,
        mediaHeight,
        label,
        color,
        min,
        max,
        step,
        valueType
      } = context

      const showDefault = valueType === 'numeric' || valueType === 'string'
      const showMediaHeight = valueType === 'string'
      const showLabelAndColor = valueType === 'flag'
      const showNumeric = valueType === 'numeric'

      return anemone`
    <div class="${componentClassName}__row">
      <label>Predicate</label>
      <input
        value="${pred || ''}"
        class="${componentClassName}__pred textae-editor__promise-dialog__observable-element"
      >
    </div>
    ${showDefault ? inputDefault(componentClassName, defaultValue) : ''}
    ${showMediaHeight ? inputMediaHeight(componentClassName, mediaHeight) : ''}
    ${
      showLabelAndColor
        ? inputLabelAndColor(componentClassName, label, color)
        : ''
    }
    ${showNumeric ? inputNumeric(componentClassName, min, max, step) : ''}
  `
    } // CONCATENATED MODULE: ./src/lib/component/CreateAttributeDefinitionDialog/template.js

    /* harmony default export */ function CreateAttributeDefinitionDialog_template(
      componentClassName,
      context
    ) {
      const { valueType } = context

      return anemone`
<div class="${componentClassName}__container">
  <div class="${componentClassName}__row">
    <label>Attribute type</label>
    <div class="${componentClassName}__value-type-row">
      <label>
        <input
          type="radio"
          name="${componentClassName}__value-type"
          value="flag"
          ${valueType === 'flag' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--flag">
        flag
      </label>
      <label>
        <input
          type="radio"
          name="${componentClassName}__value-type"
          value="selection"
          ${valueType === 'selection' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--selection">
        selection
      </label>
      <label>
        <input
          type="radio"
          name="${componentClassName}__value-type"
          value="string"
          ${valueType === 'string' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--string">
        string
      </label>
      <label>
        <input
          type="radio"
          name="${componentClassName}__value-type"
          value="numeric"
          ${valueType === 'numeric' ? `checked` : ``}
          >
        <span class="${componentClassName}__value-type--numeric">
        numeric
      </label>
    </div>
  </div>
  ${() => inputAttributeDefinition(componentClassName, context)}
</div>`
    } // CONCATENATED MODULE: ./src/lib/component/CreateAttributeDefinitionDialog/index.js

    const componentClassName = `textae-editor__create-attribute-definition-dialog`

    class CreateAttributeDefinitionDialog extends PromiseDialog {
      constructor() {
        super(
          'New attribute',
          CreateAttributeDefinitionDialog_template(componentClassName, {
            valueType: 'flag'
          }),
          {},
          () => this._state
        )

        delegate_default()(
          super.el,
          `[name="${componentClassName}__value-type"]`,
          'change',
          () => {
            const html = CreateAttributeDefinitionDialog_template(
              componentClassName,
              this._state
            )
            super.el.closest('.ui-dialog-content').innerHTML = html
          }
        )
      }

      get _state() {
        const valueType = super.el.querySelector(
          `[name="${componentClassName}__value-type"]:checked`
        ).value
        const pred = getInputElementValue(
          super.el,
          `.${componentClassName}__pred`
        )
        const label = getInputElementValue(
          super.el,
          `.${componentClassName}__label`
        )
        const color = getInputElementValue(
          super.el,
          `.${componentClassName}__color`
        )
        const defaultValue = getInputElementValue(
          super.el,
          `.${componentClassName}__default-value`
        )
        const mediaHeight = getInputElementValue(
          super.el,
          `.${componentClassName}__media-height`
        )
        const min = getInputElementValue(
          super.el,
          `.${componentClassName}__min`
        )
        const max = getInputElementValue(
          super.el,
          `.${componentClassName}__max`
        )
        const step = getInputElementValue(
          super.el,
          `.${componentClassName}__step`
        )

        return {
          pred,
          label,
          color,
          default: defaultValue,
          'media height': mediaHeight,
          min,
          max,
          step,
          valueType
        }
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditAttributeDefinitionDialog/isChanged.js

    /* harmony default export */ function isChanged(orig, changed) {
      // Ignore non number value.
      return !Number.isNaN(parseFloat(changed)) && orig !== parseFloat(changed)
    } // CONCATENATED MODULE: ./src/lib/component/EditAttributeDefinitionDialog/template.js

    /* harmony default export */ function EditAttributeDefinitionDialog_template(
      componentClassName,
      context
    ) {
      return `
<div class="${componentClassName}__container">
  ${inputAttributeDefinition(componentClassName, context)}
</div>`
    } // CONCATENATED MODULE: ./src/lib/component/EditAttributeDefinitionDialog/index.js

    const EditAttributeDefinitionDialog_componentClassName = `textae-editor__edit-attribute-definition-dialog`

    class EditAttributeDefinitionDialog extends PromiseDialog {
      constructor(attrDef) {
        super(
          'Edit attribute',
          EditAttributeDefinitionDialog_template(
            EditAttributeDefinitionDialog_componentClassName,
            attrDef
          ),
          {},
          () => {
            const pred = getInputElementValue(
              super.el,
              `.${EditAttributeDefinitionDialog_componentClassName}__pred`
            )
            const defaultValue = getInputElementValue(
              super.el,
              `.${EditAttributeDefinitionDialog_componentClassName}__default-value`
            )

            const diff = new Map()

            if (attrDef.pred !== pred) {
              diff.set('pred', pred)
            }

            if (attrDef.valueType === 'flag') {
              const label = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__label`
              )
              const color = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__color`
              )

              if (attrDef.label !== label) {
                diff.set('label', label)
              }

              if (attrDef.color !== color) {
                diff.set('color', color)
              }
            }

            if (attrDef.valueType === 'string') {
              if (attrDef.default !== defaultValue) {
                diff.set('default', defaultValue)
              }

              const mediaHeight = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__media-height`
              )

              if (attrDef.mediaHeight !== mediaHeight) {
                diff.set('media height', mediaHeight)
              }
            }

            if (attrDef.valueType === 'numeric') {
              if (isChanged(attrDef.default, defaultValue)) {
                diff.set('default', defaultValue)
              }

              const min = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__min`
              )
              const max = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__max`
              )
              const step = getInputElementValue(
                super.el,
                `.${EditAttributeDefinitionDialog_componentClassName}__step`
              )

              if (isChanged(attrDef.min, min)) {
                diff.set('min', min)
              }

              if (isChanged(attrDef.max, max)) {
                diff.set('max', max)
              }

              if (isChanged(attrDef.step, step)) {
                diff.set('step', step)
              }
            }

            return diff
          }
        )
      }
    } // CONCATENATED MODULE: ./src/lib/component/CreateOrEditValueOfAttributeDefinitionDialog/inputDefault.js

    /* harmony default export */ function CreateOrEditValueOfAttributeDefinitionDialog_inputDefault(
      showDefault,
      isDefault
    ) {
      return () =>
        showDefault
          ? anemone`
    <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
      <label>
        <input
          type="checkbox"
          ${isDefault ? `checked="checked"` : ``}
          class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__default"
        >
        default
      </label>
    </div>
    `
          : ``
    } // CONCATENATED MODULE: ./src/lib/component/CreateOrEditValueOfAttributeDefinitionDialog/template.js

    /* harmony default export */ function CreateOrEditValueOfAttributeDefinitionDialog_template(
      context
    ) {
      const {
        labelForRangeOrIdOrPattern,
        rangeOrIdOrPattern,
        showDefault,
        default: defaultValue,
        label,
        color
      } = context

      return anemone`
<div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__container">
  <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
    <label>${labelForRangeOrIdOrPattern}</label>
    <input
      value="${rangeOrIdOrPattern || ''}"
      class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern textae-editor__promise-dialog__observable-element"
    >
  </div>
  ${CreateOrEditValueOfAttributeDefinitionDialog_inputDefault(
    showDefault,
    defaultValue
  )}
  <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
    <label>label</label>
    <input
      value="${label || ''}"
      class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__label textae-editor__promise-dialog__observable-element"
    >
  </div>
  <div class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__row">
    <label>
      <input
        type="color"
        value="${color || getRandomColorString()}"
        class="textae-editor__create-or-edit-value-of-attribute-definition-dialog__color"
      >
      color
    </label>
  </div>
</div>`
    } // CONCATENATED MODULE: ./src/lib/component/enableHTMLElement.js

    // Since the style is specified by [disabled = "disabled"],
    // set the attribute to disabled without using the disable property.
    /* harmony default export */ function enableHTMLElement(element, enable) {
      if (enable) {
        element.removeAttribute('disabled')
      } else {
        element.setAttribute('disabled', 'disabled')
      }
    } // CONCATENATED MODULE: ./src/lib/component/CreateOrEditValueOfAttributeDefinitionDialog/index.js

    class CreateOrEditValueOfAttributeDefinitionDialog extends PromiseDialog {
      constructor(valueType, value = {}) {
        const bindingObject = {
          label: value.label,
          color: value.color
        }

        switch (valueType) {
          case 'numeric':
            bindingObject.labelForRangeOrIdOrPattern = 'range'
            bindingObject.rangeOrIdOrPattern = value.range
            break
          case 'selection':
            bindingObject.labelForRangeOrIdOrPattern = 'id'
            bindingObject.rangeOrIdOrPattern = value.id
            bindingObject.showDefault = true
            bindingObject.default = value.default
            break
          case 'string':
            bindingObject.labelForRangeOrIdOrPattern = 'pattern'
            bindingObject.rangeOrIdOrPattern = value.pattern
            break
          default:
            throw new Error(`${valueType} is Unknown Attribute`)
        }

        super(
          Object.keys(value).length
            ? 'Edit attribute values'
            : 'New attribute value',
          CreateOrEditValueOfAttributeDefinitionDialog_template(bindingObject),
          {},
          () => {
            const rangeOrIdOrPattern = getInputElementValue(
              super.el,
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern'
            )

            const label = getInputElementValue(
              super.el,
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__label'
            )

            const color = getInputElementValue(
              super.el,
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__color'
            )

            // Set a key only when there is a value.
            const ret = {}
            if (label) {
              ret.label = label
            }
            if (color) {
              ret.color = color
            }

            switch (valueType) {
              case 'numeric':
                ret.range = rangeOrIdOrPattern
                break
              case 'selection':
                ret.id = rangeOrIdOrPattern

                if (
                  super.el.querySelector(
                    'input.textae-editor__create-or-edit-value-of-attribute-definition-dialog__default'
                  ).checked
                ) {
                  ret.default = true
                }

                break
              case 'string':
                ret.pattern = rangeOrIdOrPattern
                break
              default:
              // A value type is checked already.
            }

            return ret
          }
        )

        // validation range
        if (valueType === 'numeric') {
          super.el
            .querySelector(
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern'
            )
            .addEventListener('input', (e) => {
              const { value } = e.target
              try {
                new IntervalNotation(value)
                enableHTMLElement(super.button, true)
              } catch (error) {
                enableHTMLElement(super.button, false)
              }
            })
        }

        // validation pattern
        if (valueType === 'string') {
          super.el
            .querySelector(
              '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__range_or_id_or_pattern'
            )
            .addEventListener('input', (e) => {
              const { value } = e.target
              try {
                new RegExp(value)
                enableHTMLElement(super.button, true)
              } catch (error) {
                enableHTMLElement(super.button, false)
              }
            })
        }

        // validation color
        super.el
          .querySelector(
            '.textae-editor__create-or-edit-value-of-attribute-definition-dialog__color'
          )
          .addEventListener('input', (e) => {
            const { value } = e.target
            enableHTMLElement(
              super.button,
              !value || /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)
            )
          })
      }
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrag/showDropTargets.js

    /* harmony default export */ function showDropTargets(e) {
      e.target
        .closest('.textae-editor__pallet__content')
        .classList.add('textae-editor__pallet__content--dragging')
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrag/hideDropTargets.js

    /* harmony default export */ function hideDropTargets(e) {
      e.target
        .closest('.textae-editor__pallet__content')
        .classList.remove('textae-editor__pallet__content--dragging')
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrag/index.js

    /* harmony default export */ function enableAttributeTabDrag(el) {
      delegate_default()(
        el,
        '.textae-editor__pallet__attribute',
        'dragstart',
        (e) => {
          e.dataTransfer.setData(
            'application/x-textae-attribute-tab-old-index',
            e.target.dataset.index
          )
          showDropTargets(e)
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__attribute',
        'dragend',
        (e) => {
          hideDropTargets(e)
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/enableAttributeTabDrop.js

    /* harmony default export */ function enableAttributeTabDrop(
      el,
      commander
    ) {
      delegate_default()(
        el,
        '.textae-editor__pallet__drop-target',
        'dragover',
        (e) => {
          // Display the image after the drop.
          const width = e.target
            .closest('.textae-editor__pallet__content')
            .querySelector('.textae-editor__pallet__attribute').offsetWidth
          e.target.innerHTML = `<div style="width: ${width}px;"></div>`

          // Enable drop targets to fire drop events.
          e.preventDefault()
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__drop-target',
        'dragleave',
        (e) => {
          // Hide the image after the drop.
          e.target.innerHTML = ''
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__drop-target',
        'drop',
        (e) => {
          const oldIndex = parseInt(
            e.dataTransfer.getData(
              'application/x-textae-attribute-tab-old-index'
            )
          )
          const newIndex = parseInt(e.target.dataset.index)

          commander.invoke(
            commander.factory.moveAttributeDefintionComannd(
              oldIndex,
              oldIndex < newIndex ? newIndex - 1 : newIndex
            )
          )
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/EditNumericAttributeDialog.js

    function EditNumericAttributeDialog_template(context) {
      const { subjects, pred, min, max, step, value } = context
      return anemone`
<div class="textae-editor__edit-numeric-attribute-dialog__container">
  <div class="textae-editor__edit-numeric-attribute-dialog__row">
    <label>Subject</label>
    <div class="textae-editor__edit-numeric-attribute-dialog__subject-row">
      <input
      class="textae-editor__edit-numeric-attribute-dialog__subject-input"
        value="${subjects}"
        disabled="disabled">
      <button
        class="textae-editor__edit-numeric-attribute-dialog__subject-edit-button"
        title="properties">...</button>
    </div>
  </div>
  <div class="textae-editor__edit-numeric-attribute-dialog__row">
    <label>Predicate</label>
    <input
      value="${pred}"
      disabled="disabled">
  </div>
  <div class="textae-editor__edit-numeric-attribute-dialog__row ui-front">
    <label>Object</label>
    <input
      class="textae-editor__edit-numeric-attribute-dialog__value textae-editor__promise-dialog__observable-element"
      type="number"
      ${typeof min === 'number' ? `min="${min}"` : ''}
      ${typeof max === 'number' ? `max="${max}"` : ''}
      step="${step}"
      value="${value}"
      autofocus>
  </div>
</div>`
    }

    class EditNumericAttributeDialog extends PromiseDialog {
      constructor(
        attrDef,
        attribute,
        targetAttributes,
        deletable,
        editProperties,
        pallet
      ) {
        const buttons = []

        if (deletable) {
          buttons.unshift({
            class:
              'textae-editor__edit-numeric-attribute-dialog__remove-attribute',
            click: () => {
              this.close()
              this.resolveFunc({ newObj: null })
            }
          })
        }

        if (pallet) {
          buttons.unshift({
            text: '...',
            title: 'configuration',
            click: () => {
              this.close()
              pallet.show()
              pallet.showAttribute(attribute.pred)
            }
          })
        }

        super(
          `Attribute [${targetAttributes
            .map(({ id }) => id || '-')
            .join(',')}]`,
          EditNumericAttributeDialog_template({
            subjects: `${targetAttributes
              .map(({ subj }) => subj || '-')
              .join(', ')}`,
            pred: attribute.pred,
            value: attribute.obj,
            min: attrDef.min,
            max: attrDef.max,
            step: attrDef.step
          }),
          { buttons },
          () => {
            const input = super.el.querySelector(
              '.textae-editor__edit-numeric-attribute-dialog__value'
            )

            // Numeric attribute obj value type must be Number type.
            return { newObj: input.value }
          }
        )

        if (editProperties) {
          delegate_default()(
            super.el,
            '.textae-editor__edit-numeric-attribute-dialog__subject-edit-button',
            'click',
            () => {
              this.close()
              editProperties()
            }
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/openEditNumericAttributeDialog.js

    /* harmony default export */ function openEditNumericAttributeDialog(
      selectionModelEntity,
      attrDef,
      attribute,
      commander,
      editProperties,
      pallet
    ) {
      new EditNumericAttributeDialog(
        attrDef,
        attribute,
        selectionModelEntity.all.reduce((attrs, entity) => {
          attrs.push(entity.attributes.find((a) => a.pred == attribute.pred))
          return attrs
        }, []),
        true,
        editProperties,
        pallet
      )
        .open()
        .then(({ newObj }) => {
          const command = newObj
            ? commander.factory.changeAttributeObjOfItemsCommand(
                selectionModelEntity.all,
                attrDef,
                newObj
              )
            : commander.factory.removeAttributesFromItemsByPredCommand(
                selectionModelEntity.all,
                attrDef
              )

          commander.invoke(command)
        })
    } // CONCATENATED MODULE: ./src/lib/component/setSourceOfAutoComplete.js

    customize_jquery_ui_autocomplete()

    /* harmony default export */ function component_setSourceOfAutoComplete(
      inputElement,
      labelSpan,
      autocompletionWs,
      getLocalData
    ) {
      jquery_default()(inputElement).autocomplete({
        source: (request, response) => {
          if (labelSpan) {
            if (labelSpan instanceof HTMLInputElement) {
              labelSpan.value = ''
            } else {
              labelSpan.innerText = ''
            }
          }

          searchTerm(
            autocompletionWs,
            getLocalData(request.term),
            request.term,
            response
          )
        },
        minLength: 3,
        select: (_, { item }) => {
          inputElement.value = item.id

          console.log(123)
          if (labelSpan) {
            if (labelSpan instanceof HTMLInputElement) {
              labelSpan.value = item.label
            } else {
              labelSpan.innerText = item.label
            }
          }

          return false
        }
      })
    } // CONCATENATED MODULE: ./src/lib/component/EditStringAttributeDialog.js

    function EditStringAttributeDialog_template(context) {
      const { subjects, pred, value } = context

      return anemone`
<div class="textae-editor__edit-string-attribute-dialog__container">
  <div class="textae-editor__edit-numeric-attribute-dialog__row">
    <label>Subject</label>
    <div class="textae-editor__edit-numeric-attribute-dialog__subject-row">
      <input
      class="textae-editor__edit-numeric-attribute-dialog__subject-input"
        value="${subjects}"
        disabled="disabled">
      <button
        class="textae-editor__edit-numeric-attribute-dialog__subject-edit-button"
        title="properties">...</button>
    </div>
  </div>
  <div class="textae-editor__edit-string-attribute-dialog__row">
    <label>Predicate</label>
    <input
      value="${pred}" disabled="disabled">
  </div>
  <div class="textae-editor__edit-string-attribute-dialog__row ui-front">
    <label>Object</label>
    <input
      class="textae-editor__edit-string-attribute-dialog__value textae-editor__promise-dialog__observable-element"
      value="${value}"
      autofocus>
  </div>
  <div class="textae-editor__edit-string-attribute-dialog__row">
    <label>Label</label>
    <input
      class="textae-editor__edit-string-attribute-dialog__label"
      value="" disabled="disabled">
  </div>
</div>`
    }

    class EditStringAttributeDialog extends PromiseDialog {
      constructor(
        attrDef,
        attribute,
        targetAttributes,
        deletable,
        editProperties,
        pallet
      ) {
        const buttons = []

        if (deletable) {
          buttons.unshift({
            class:
              'textae-editor__edit-string-attribute-dialog__remove-attribute',
            click: () => {
              this.close()
              this.resolveFunc({ newObj: null })
            }
          })
        }

        if (pallet) {
          buttons.unshift({
            text: '...',
            title: 'configuration',
            click: () => {
              this.close()
              pallet.show()
              pallet.showAttribute(attribute.pred)
            }
          })
        }

        super(
          `Attribute [${targetAttributes
            .map(({ id }) => id || '-')
            .join(',')}]`,
          EditStringAttributeDialog_template({
            subjects: `${targetAttributes
              .map(({ subj }) => subj || '-')
              .join(', ')}`,
            pred: attribute.pred,
            value: attribute.obj
          }),
          { buttons },
          () => {
            const input = super.el.querySelector(
              '.textae-editor__edit-string-attribute-dialog__value'
            )

            return {
              newObj: input.value,
              newLabel: super.el.querySelector(
                '.textae-editor__edit-string-attribute-dialog__label'
              ).value
            }
          }
        )

        if (editProperties) {
          delegate_default()(
            super.el,
            '.textae-editor__edit-numeric-attribute-dialog__subject-edit-button',
            'click',
            () => {
              this.close()
              editProperties()
            }
          )
        }

        component_setSourceOfAutoComplete(
          super.el.querySelector(
            '.textae-editor__edit-string-attribute-dialog__value'
          ),
          super.el.querySelector(
            '.textae-editor__edit-string-attribute-dialog__label'
          ),
          attrDef.autocompletionWs,
          () => []
        )
      }
    } // CONCATENATED MODULE: ./src/lib/openEditStringAttributeDialog.js

    /* harmony default export */ function openEditStringAttributeDialog(
      selectionModelEntity,
      attribute,
      commander,
      attrDef,
      editProperties,
      pallet
    ) {
      new EditStringAttributeDialog(
        attrDef,
        attribute,
        selectionModelEntity.all.reduce((attrs, entity) => {
          attrs.push(entity.attributes.find((a) => a.pred == attribute.pred))
          return attrs
        }, []),
        true,
        editProperties,
        pallet
      )
        .open()
        .then(({ newObj, newLabel }) => {
          if (newObj) {
            commander.invoke(
              commander.factory.changeStringAttributeObjOfItemsCommand(
                selectionModelEntity.all,
                attrDef,
                newObj,
                newLabel
              )
            )
          } else {
            commander.invoke(
              commander.factory.removeAttributesFromItemsByPredCommand(
                selectionModelEntity.all,
                attrDef
              )
            )
          }
        })
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/bindAttributeEvent/index.js

    /**
     * @param {import('../../../Editor/UseCase/Commander').default} commander
     */
    /* harmony default export */ function bindAttributeEvent(
      pallet,
      el,
      commander,
      selectionModelEntity
    ) {
      enableAttributeTabDrag(el)
      enableAttributeTabDrop(el, commander)

      delegate_default()(
        el,
        '.textae-editor__pallet__attribute',
        'click',
        (e) => {
          pallet.showAttribute(e.target.dataset['attribute'])
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__create-predicate',
        'click',
        () =>
          new CreateAttributeDefinitionDialog().open().then((attrDef) => {
            // Predicate is necessary and Ignore without predicate.
            if (attrDef.pred) {
              commander.invoke(
                commander.factory.createAttributeDefinitionCommand(attrDef)
              )
            }
          })
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__edit-predicate',
        'click',
        () =>
          new EditAttributeDefinitionDialog(pallet.attrDef)
            .open()
            .then((changedProperties) => {
              // Predicate is necessary and Ignore without predicate.
              if (
                changedProperties.size &&
                changedProperties.get('pred') !== ''
              ) {
                commander.invoke(
                  commander.factory.changeAttributeDefinitionCommand(
                    pallet.attrDef,
                    changedProperties
                  )
                )
              }
            })
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__delete-predicate',
        'click',
        () =>
          commander.invoke(
            commander.factory.deleteAttributeDefinitionCommand(pallet.attrDef)
          )
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__selection-attribute-label',
        'click',
        (e) => {
          if (
            selectionModelEntity.selectedWithAttributeOf(pallet.attrDef.pred)
          ) {
            if (
              selectionModelEntity.isDupulicatedPredAttrributeSelected(
                pallet.attrDef.pred
              )
            ) {
              alertify_default().warning(
                'An item among the selected has this attribute multiple times.'
              )
            } else {
              const command =
                commander.factory.changeAttributeObjOfItemsCommand(
                  selectionModelEntity.all,
                  pallet.attrDef,
                  e.target.dataset.id
                )
              commander.invoke(command)
            }
          } else {
            const command = commander.factory.createAttributeToItemsCommand(
              selectionModelEntity.all,
              pallet.attrDef,
              e.target.dataset.id
            )
            commander.invoke(command)
          }
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__add-attribute-value-button',
        'click',
        () =>
          new CreateOrEditValueOfAttributeDefinitionDialog(
            pallet.attrDef.valueType
          )
            .open()
            .then((value) => {
              if (value.range || value.id || value.pattern) {
                commander.invoke(
                  commander.factory.addValueToAttributeDefinitionCommand(
                    pallet.attrDef,
                    value
                  )
                )
              }
            })
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__edit-value',
        'click',
        (e) => {
          const oldValue = pallet.attrDef.values[e.target.dataset.index]
          new CreateOrEditValueOfAttributeDefinitionDialog(
            pallet.attrDef.valueType,
            oldValue
          )
            .open()
            .then((newValue) => {
              if (newValue.range || newValue.id || newValue.pattern) {
                const changed =
                  Object.keys(newValue).reduce((acc, cur) => {
                    return acc || newValue[cur] !== oldValue[cur]
                  }, false) ||
                  Object.keys(oldValue).reduce((acc, cur) => {
                    return acc || newValue[cur] !== oldValue[cur]
                  }, false)
                // Ignore if there is no change
                if (!changed) {
                  return
                }

                commander.invoke(
                  commander.factory.changeValueOfAttributeDefinitionAndObjectOfSelectionAttributeCommand(
                    pallet.attrDef.externalFormat,
                    e.target.dataset.index,
                    newValue
                  )
                )
              }
            })
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__remove-value',
        'click',
        (e) =>
          commander.invoke(
            commander.factory.removeValueFromAttributeDefinitionCommand(
              pallet.attrDef,
              e.target.dataset.index
            )
          )
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__add-attribute',
        'click',
        () =>
          commander.invoke(
            commander.factory.createAttributeToItemsCommand(
              selectionModelEntity.all,
              pallet.attrDef
            )
          )
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__edit-object',
        'click',
        () => {
          const attribute =
            selectionModelEntity.findSelectedAttributeWithSamePredicate(
              pallet.attrDef.pred
            )
          switch (pallet.attrDef.valueType) {
            case 'numeric':
              openEditNumericAttributeDialog(
                selectionModelEntity,
                pallet.attrDef,
                attribute,
                commander
              )
              break
            case 'string':
              openEditStringAttributeDialog(
                selectionModelEntity,
                attribute,
                commander,
                pallet.attrDef
              )
              break
            default:
              throw new Error(
                `Invalid attribute valueType: ${pallet.attrDef.valueType}`
              )
          }
        }
      )

      delegate_default()(
        el,
        '.textae-editor__pallet__remove-attribute',
        'click',
        () =>
          commander.invoke(
            commander.factory.removeAttributesFromItemsByPredCommand(
              selectionModelEntity.all,
              pallet.attrDef
            )
          )
      )
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/getSelectedEntityLabel.js

    /* harmony default export */ function getSelectedEntityLabel(
      numberOfSelectedItems
    ) {
      return numberOfSelectedItems === 1
        ? '1 item selected'
        : numberOfSelectedItems > 1
          ? `${numberOfSelectedItems} items selected`
          : ''
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/attributeTabTemplate.js

    /* harmony default export */ function attributeTabTemplate(
      { pred },
      index,
      array,
      selectedPred
    ) {
      // Moving an attribute to before or after the current position does not change the position.
      const previous = array[index - 1]
      const droppable =
        pred !== selectedPred &&
        (previous ? previous.pred !== selectedPred : true)

      return () => anemone`
    ${
      droppable
        ? () =>
            `<span class="textae-editor__pallet__drop-target" data-index="${index}"></span>`
        : ''
    }
    <p
      class="textae-editor__pallet__attribute${
        pred === selectedPred
          ? ' textae-editor__pallet__attribute--selected'
          : ''
      }"
      data-attribute="${pred}"
      data-index="${index}"
      ${pred === selectedPred ? 'draggable="true"' : ''}>
      ${index < 9 ? `${index + 1}:` : ''}${pred}
    </p>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/addAttributeButtonTemplate.js

    /* harmony default export */ function addAttributeButtonTemplate(context) {
      const { selectionModelItems, selectedPred } = context
      const isEntityWithoutSamePredSelected =
        selectionModelItems.selectedWithoutAttributeOf(selectedPred)

      return () =>
        isEntityWithoutSamePredSelected
          ? `
      <button
        type="button"
        class="textae-editor__pallet__add-attribute"
        >add to</button>
      `
          : `
      <button
        type="button"
        class="textae-editor__pallet__add-attribute"
        disabled="disabled"
        title="All the selected items already have this attribute."
        >add to</button>
      `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/editAttributeButtonTemplate.js

    /* harmony default export */ function editAttributeButtonTemplate(context) {
      const { attrDef, selectionModelItems, selectedPred } = context
      const { valueType } = attrDef
      const isOnlyEntityWithJustOneSamePredSelected =
        selectionModelItems.onlySelectedWithJustOneAttributeOf(selectedPred)

      return () =>
        valueType === 'string' || valueType === 'numeric'
          ? isOnlyEntityWithJustOneSamePredSelected
            ? `
        <button
          type="button"
          class="textae-editor__pallet__edit-object"
          >edit object of
        </button>
        `
            : `
        <button
          type="button"
          class="textae-editor__pallet__edit-object"
          disabled="disabled"
          title="Some selected items has zero or multi this attribute."
          >edit object of
        </button>
      `
          : ``
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/removeAttributeButtonTemplate.js

    /* harmony default export */ function removeAttributeButtonTemplate(
      context
    ) {
      const { selectionModelItems, selectedPred } = context
      const isEntityWithSamePredSelected =
        selectionModelItems.selectedWithAttributeOf(selectedPred)

      return () =>
        isEntityWithSamePredSelected
          ? `
      <button
        type="button"
        class="textae-editor__pallet__remove-attribute"
        >remove from</button>
      `
          : `
      <button
        type="button"
        class="textae-editor__pallet__remove-attribute"
        disabled="disabled"
        title="None of the selected items has this attribute."
        >remove from</button>
      `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/addNewAttributeTabTemplate.js

    function addNewAttributeTabTemplate(
      isLock,
      lastAttributeSelected,
      isEnableToAddAttribute
    ) {
      return () =>
        isLock
          ? ''
          : `
        ${
          lastAttributeSelected
            ? ''
            : '<span class="textae-editor__pallet__drop-target" data-index="-1"></span>'
        }
        ${
          isEnableToAddAttribute
            ? `
            <p class="textae-editor__pallet__attribute textae-editor__pallet__create-predicate">
              <span class="textae-editor__pallet__create-predicate__button" title="Add a new attribute"></span>
            </p>
            `
            : ''
        }`
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/headerTemplate/index.js

    /* harmony default export */ function headerTemplate(context) {
      const { isLock, selectionModelItems, selectedPred, attributes, hasDiff } =
        context

      const selectedEntityLabel = getSelectedEntityLabel(
        selectionModelItems.size
      )
      const isEnableToAddAttribute = attributes.length < 30
      const lastAttributeSelected =
        selectedPred ===
        (attributes[attributes.length - 1] &&
          attributes[attributes.length - 1].pred)

      return () => anemone`
<div class="textae-editor__pallet__header-first-row">
  <div class="textae-editor__pallet__information">
    <span class="textae-editor__pallet__lock-icon" style="display: ${
      isLock ? 'inline-block' : 'none'
    };">locked</span>
    ${
      selectedPred && selectionModelItems.size > 0
        ? `
          ${addAttributeButtonTemplate(context)}
          ${editAttributeButtonTemplate(context)}
          ${removeAttributeButtonTemplate(context)}
          the
          `
        : ``
    }
    <span class="textae-editor__pallet__selected-entity-label">${selectedEntityLabel}</span>
  </div>
  <div class="textae-editor__pallet__buttons">
    <span class="textae-editor__pallet__button textae-editor__pallet__import-button" title="Import"></span>
    <span class="textae-editor__pallet__button textae-editor__pallet__upload-button ${
      hasDiff ? 'textae-editor__pallet__upload-button--transit' : ''
    }" title="Upload"></span>
  </div>
</div>
<div class="textae-editor__pallet__header-second-row">
  <p class="textae-editor__pallet__attribute ${
    selectedPred ? '' : 'textae-editor__pallet__attribute--selected'
  }" data-attribute="">
    Type
  </p>
  ${attributes.map((a, index, array) =>
    attributeTabTemplate(a, index, array, selectedPred)
  )}
  ${addNewAttributeTabTemplate(
    isLock,
    lastAttributeSelected,
    isEnableToAddAttribute
  )}
</div>
`
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/typeTemplate/editButtonsTemplate.js

    function editButtonsTemplate(id, color, defaultType, label, useNumber) {
      return () => anemone`
          <button
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__edit-type"
            title="Edit this type." data-id="${id}"
            data-color="${color}"
            data-is-default="${defaultType}">
          </button>
          <button
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__remove${
              useNumber ? ' textae-editor__pallet__table-button--disabled' : ''
            }"
            title="${
              useNumber
                ? 'To activate this button, remove all the annotations of this type.'
                : 'Remove this type.'
            }"
            data-id="${id}"
            data-label="${label}">
          </button>
          `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/typeTemplate/toTypeRow.js

    function toTypeRow(color, id, uri, defaultType, label, useNumber, isLock) {
      return () => anemone`
      <tr class="textae-editor__pallet__row" style="background-color: ${color};">
        <td class="textae-editor__pallet__label" data-id="${id}">
          <span title="${id}">
            ${id}
          </span>
          ${
            uri
              ? () =>
                  anemone`<a href="${uri}" target="_blank"><span class="textae-editor__pallet__link"></span></a>`
              : ``
          }
          ${
            defaultType
              ? () =>
                  '<span class="textae-editor__pallet__default-icon" title="This type is set as a default type."></span>'
              : ''
          }
        </td>
        <td class="textae-editor__pallet__short-label">
          ${label}
        </td>
        <td class="textae-editor__pallet__use-number">
          ${useNumber}
        </td>
        <td class="textae-editor__pallet__table-buttons">
          <button
            type="button"
            class="textae-editor__pallet__table-button textae-editor__pallet__select-all${
              useNumber ? '' : ' textae-editor__pallet__table-button--disabled'
            }"
            title="Select all the cases of this type."
            data-id="${id}"
            data-use-number="${useNumber}">
          </button>
          ${
            isLock
              ? ''
              : editButtonsTemplate(id, color, defaultType, label, useNumber)
          }
        </td>
      </tr>`
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/typeTemplate/index.js

    /* harmony default export */ function typeTemplate(context) {
      const { types, isLock } = context

      return anemone`
  ${headerTemplate(context)}
  <table>
    <tbody>
      <tr>
        <th>id</th>
        <th>label</th>
        <th title="Number of annotations.">#</th>
        <th>
          ${
            isLock
              ? ''
              : () =>
                  '<span class="textae-editor__pallet__add-button" title="Add new type"></span>'
          }
        </th>
      </tr>
      ${
        types.length
          ? types.map(
              ({ color = '', id, uri, defaultType, label = '', useNumber }) =>
                toTypeRow(color, id, uri, defaultType, label, useNumber, isLock)
            )
          : () => `
            <tr class="textae-editor__pallet__row">
              <td class="textae-editor__pallet__no-config" colspan="4">There is no Entity definition.</td>
            </tr>
            `
      }
    </tbody>
  </table>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/predicateControllerTemplate/toDeleteButton.js

    function toDeleteButton(numberOfItemsUsingSelectedPred) {
      return numberOfItemsUsingSelectedPred.size > 0
        ? `
      <button
        type="button"
        class="textae-editor__pallet__table-button textae-editor__pallet__table-button--disabled textae-editor__pallet__delete-predicate"
        disabled="disabled"
        title="It cannot be deleted, as this attribute is used for ${numberOfItemsUsingSelectedPred.size} items.">
      </button>
    `
        : `
      <button
        type="button"
        class="textae-editor__pallet__table-button textae-editor__pallet__delete-predicate"
        title="Delete this predicate.">
      </button>
    `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/predicateControllerTemplate/editAttributeDefinitionBlockTemplate.js

    /* harmony default export */ function editAttributeDefinitionBlockTemplate(
      context
    ) {
      const { isLock, numberOfItemsUsingSelectedPred } = context

      if (isLock) {
        return () => `
      <button
        type="button"
        class="textae-editor__pallet__table-button textae-editor__pallet__table-button--disabled textae-editor__pallet__edit-predicate"
        disabled="disabled">
      </button>
      <button
        type="button"
        class="textae-editor__pallet__table-button textae-editor__pallet__table-button--disabled textae-editor__pallet__delete-predicate"
        disabled="disabled">
      </button>
    `
      }

      return () => `
    <button
      type="button"
      class="textae-editor__pallet__table-button textae-editor__pallet__edit-predicate"
      title="Edit this predicate.">
    </button>
    ${toDeleteButton(numberOfItemsUsingSelectedPred)}
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/predicateControllerTemplate/index.js

    /* harmony default export */ function predicateControllerTemplate(context) {
      const { attrDef } = context
      const { pred } = attrDef
      const { valueType } = attrDef

      return () => anemone`
    <div>
      Attribute
      <span
        class="textae-editor__pallet__predicate__value-type textae-editor__pallet__predicate__value-type--${valueType}"
        title="${valueType} type">
      </span>
      "${pred}"
      ${editAttributeDefinitionBlockTemplate(context)}
    </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/flagAttributeTemplate.js

    /* harmony default export */ function flagAttributeTemplate(context) {
      const { label, color } = context.attrDef

      return anemone`
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
      label: "${label || ''}"
      color: "${color || ''}"
    </div>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/showAddAttributeValueButton.js

    /* harmony default export */ function showAddAttributeValueButton(isLock) {
      return isLock
        ? ''
        : () => `
        <th>
          <span class="textae-editor__pallet__add-attribute-value-button" title="Add new value"></span>
        </th>`
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/valueButtonsTemplate.js

    /* harmony default export */ function valueButtonsTemplate(
      isLock,
      index,
      indelible
    ) {
      return isLock
        ? ''
        : () => `
  <td class="textae-editor__pallet__table-attribute-buttons">
    <button
      type="button"
      class="textae-editor__pallet__table-button textae-editor__pallet__edit-value"
      title="Edit this value." data-index="${index}">
    </button>
    <button
      type="button"
      class="textae-editor__pallet__table-button textae-editor__pallet__remove-value${
        indelible ? ' textae-editor__pallet__table-button--disabled' : ''
      }"
      title="${
        indelible
          ? 'To activate this button, remove all the annotations of this type.'
          : 'Remove this value.'
      }"
      ${indelible ? ' disabled="disabled"' : ''}
      data-index="${index}">
    </button>
  </td>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/numericAttributeTemplate/toBodyRow.js

    function toBodyRow(color, range, label, isLock, index, indelible) {
      return () => anemone`
    <tr class="textae-editor__pallet__row" style="background-color: ${color};">
      <td class="textae-editor__pallet__attribute-label">
        ${range}
      </td>
      <td class="textae-editor__pallet__short-label">
        ${label}
      </td>
      <td class="textae-editor__pallet__short-label">
        ${color}
      </td>
      ${valueButtonsTemplate(isLock, index, indelible)}
    </tr>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/numericAttributeTemplate/index.js

    /* harmony default export */ function numericAttributeTemplate(context) {
      const { min, max, step, default: defaultValue, values } = context.attrDef
      const { isLock } = context

      return anemone`
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
      min: ${min || '""'}
      max: ${max || '""'}
      step: ${step}
      default: ${defaultValue}
    </div>

    <table>
      <thead>
        <tr>
          <th>range</th>
          <th>label</th>
          <th>color</th>
          ${showAddAttributeValueButton(isLock)}
        </tr>
      </thead>
      <tbody>
        ${values.map(({ color = '', range, label = '', indelible }, index) =>
          toBodyRow(color, range, label, isLock, index, indelible)
        )}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/selectionAttributeTemplate/toBodyRow.js

    function toBodyRow_toBodyRow(
      color,
      id,
      defaultValue,
      label,
      isLock,
      index,
      attributeContainer,
      selectedPred
    ) {
      return () => anemone`
    <tr class="textae-editor__pallet__row" style="background-color: ${color};">
      <td class="textae-editor__pallet__selection-attribute-label" data-id="${id}">
        ${id}
        ${
          defaultValue
            ? '<span class="textae-editor__pallet__default-icon" title="This type is set as a default type."></span>'
            : ''
        }
      </td>
      <td class="textae-editor__pallet__short-label">
        ${label}
      </td>
      <td class="textae-editor__pallet__short-label">
        ${color}
      </td>
      ${valueButtonsTemplate(
        isLock,
        index,
        attributeContainer.isSelectionAttributeValueIndelible(
          // Disable to press the remove button for the value used in the selection attribute.
          selectedPred,
          id
        )
      )}
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/selectionAttributeTemplate/index.js

    /* harmony default export */ function selectionAttributeTemplate(
      context,
      attributeContainer
    ) {
      const { values } = context.attrDef
      const { isLock, selectedPred } = context

      return anemone`
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
    </div>

    <table>
      <thead>
        <tr>
          <th>id</th>
          <th>label</th>
          <th>color</th>
          ${showAddAttributeValueButton(isLock)}
        </tr>
      </thead>
      <tbody>
        ${values.map(
          ({ color = '', id, default: defaultValue, label = '' }, index) =>
            toBodyRow_toBodyRow(
              color,
              id,
              defaultValue,
              label,
              isLock,
              index,
              attributeContainer,
              selectedPred
            )
        )}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/stringAttributeTemplate/toBodyRow.js

    function stringAttributeTemplate_toBodyRow_toBodyRow(
      color,
      pattern,
      label,
      isLock,
      index,
      indelible
    ) {
      return () => anemone`
    <tr class="textae-editor__pallet__row" style="background-color: ${color};">
      <td class="textae-editor__pallet__attribute-label">
        ${pattern}
      </td>
      <td class="textae-editor__pallet__short-label">
        ${label}
      </td>
      <td class="textae-editor__pallet__short-label">
        ${color}
      </td>
      ${valueButtonsTemplate(isLock, index, indelible)}
    </tr>`
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/stringAttributeTemplate/index.js

    /* harmony default export */ function stringAttributeTemplate(context) {
      const { default: defaultValue, mediaHeight, values } = context.attrDef
      const { isLock } = context

      return anemone`
  ${headerTemplate(context)}
  <div>
    <div class="textae-editor__pallet__predicate">
      ${predicateControllerTemplate(context)}
      media height: ${mediaHeight || '""'}
      default: ${defaultValue}
    </div>

    <table>
      <thead>
        <tr>
          <th>pattern</th>
          <th>label</th>
          <th>color</th>
          ${showAddAttributeValueButton(isLock)}
        </tr>
      </thead>
      <tbody>
        ${values.map(
          ({ color = ' ', pattern = '', label = '', indelible }, index) =>
            stringAttributeTemplate_toBodyRow_toBodyRow(
              color,
              pattern,
              label,
              isLock,
              index,
              indelible
            )
        )}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/createContentHtml/index.js

    /* harmony default export */ function createContentHtml(
      types,
      hasDiff,
      selectedPred,
      selectionModelItems,
      attributeContainer,
      attributeInstances,
      isLock
    ) {
      const { attributes } = attributeContainer

      if (!selectedPred) {
        return typeTemplate({
          isLock,
          attributes,
          hasDiff,
          types,
          selectionModelItems
        })
      }

      const attrDef = attributes.find((a) => a.pred === selectedPred)

      // When you re-read the configuration,
      // you may not find the attribute definition.
      if (!attrDef) {
        return typeTemplate({
          isLock,
          attributes,
          hasDiff,
          types,
          selectionModelItems
        })
      }

      const context = {
        isLock,
        attributes,
        hasDiff,
        attrDef,
        selectedPred,
        selectionModelItems,
        numberOfItemsUsingSelectedPred: new Set(
          attributeInstances
            .filter((a) => a.pred === selectedPred)
            .map((a) => a.subj)
        )
      }

      switch (attrDef.valueType) {
        case 'flag':
          return flagAttributeTemplate(context)
        case 'numeric':
          return numericAttributeTemplate(context)
        case 'selection':
          return selectionAttributeTemplate(context, attributeContainer)
        case 'string':
          return stringAttributeTemplate(context)
        default:
          throw `attrDef.valueType is unknown attribute`
      }
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/enableDrag.js

    /* harmony default export */ function enableDrag(el) {
      for (const attributeTab of el.querySelectorAll(
        '.textae-editor__pallet__attribute'
      )) {
        attributeTab.addEventListener('mousedown', (e) => {
          // Stop event propagation to prevent the jQueryUI.dragging widget
          // from disabling the default handling of mousedown events.
          e.stopPropagation()
        })
      }
    } // CONCATENATED MODULE: ./src/lib/component/TypeValuesPallet/index.js

    class TypeValuesPallet extends Pallet {
      /**
       *
       * @param {import('../../Editor/AnnotationModel/TypeDefinition').default} typeDefinition
       * @param {import('../../Editor/AttributeDefinitionContainer').default} attributeInstanceContainer
       */
      constructor(
        editorHTMLElement,
        eventEmitter,
        typeDefinition,
        attributeInstanceContainer,
        definitionContainer,
        selectionModelEntity,
        commander,
        title,
        controlViewModel,
        mousePoint
      ) {
        super(editorHTMLElement, title, mousePoint)

        this._eventEmitter = eventEmitter
        this._typeDefinition = typeDefinition
        this._attributeInstanceContainer = attributeInstanceContainer
        this._definitionContainer = definitionContainer
        this._selectionModelItems = selectionModelEntity
        this._controlViewModel = controlViewModel

        delegate_default()(
          this._el,
          `.textae-editor__pallet__import-button`,
          'click',
          () => eventEmitter.emit('textae-event.pallet.import-button.click')
        )

        delegate_default()(
          this._el,
          '.textae-editor__pallet__upload-button',
          'click',
          () => eventEmitter.emit('textae-event.pallet.upload-button.click')
        )

        bindAttributeEvent(this, this._el, commander, selectionModelEntity)

        eventEmitter
          .on('textae-event.type-definition.attribute.create', (pred) => {
            // Reload pallet when reverting deleted attribute.
            this.showAttribute(pred)
          })
          .on('textae-event.type-definition.attribute.change', (pred) => {
            // Reload pallet when reverting change attribute.
            this.showAttribute(pred)
          })
          .on('textae-event.type-definition.attribute.delete', () => {
            // Reload pallet when undo deleted attribute.
            this.showAttribute(null)
          })
          .on('textae-event.type-definition.attribute.move', () => {
            this.updateDisplay()
          })

        // Reload when instance addition / deletion is undo / redo.
        eventEmitter.on(
          'textae-event.annotation-data.events-observer.unsaved-change',
          () => this.updateDisplay()
        )

        // Update selected entity label
        eventEmitter.on('textae-event.selection.entity.change', () =>
          this.updateDisplay()
        )

        eventEmitter
          .on('textae-event.editor.unselect', () => this.hide()) // Close pallet when selecting other editor.
          .on('textae-event.original-data.configuration.reset', () =>
            this.updateDisplay()
          )
          .on(`textae-event.type-definition.lock`, () => this.updateDisplay())

        // Update the palette when undoing and redoing add entity and relation definition.
        eventEmitter
          .on('textae-event.type-definition.entity.change', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.entity.delete', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.entity.change-default', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.relation.change', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.relation.delete', () =>
            this.updateDisplay()
          )
          .on('textae-event.type-definition.relation.change-default', () =>
            this.updateDisplay()
          )
      }

      updateDisplay() {
        super.updateDisplay()
        enableDrag(this._el, this)
      }

      showPallet() {
        this.show()
      }

      show() {
        this._selectedPred = null
        super.show()
        enableDrag(this._el, this)
      }

      showAttribute(pred) {
        this._selectedPred = pred
        this.updateDisplay()
      }

      selectLeftAttributeTab() {
        // Ignore when type is seleceted.
        if (this._selectedPred) {
          // Select type when the first attribute selected.
          if (this._selectedIndex === 0) {
            this.showAttribute()
          } else {
            this.showAttribute(
              this._attributeDefinitions[this._selectedIndex - 1].pred
            )
          }
        }
      }

      selectRightAttributeTab() {
        if (this._selectedPred) {
          // Ignore when the last attribute is selected.
          if (this._selectedIndex === this._attributeDefinitions.length - 1) {
            return
          }

          this.showAttribute(
            this._attributeDefinitions[this._selectedIndex + 1].pred
          )
        } else {
          // Select the first attribute when type selected.
          if (this._attributeDefinitions.length) {
            this.showAttribute(this._attributeDefinitions[0].pred)
          }
        }
      }

      get _selectedIndex() {
        return this._attributeDefinitions.findIndex(
          (attribute) => attribute.pred === this._selectedPred
        )
      }

      get _content() {
        return createContentHtml(
          this._definitionContainer.pallet,
          this._controlViewModel.diffOfConfiguration,
          this._selectedPred,
          this._selectionModelItems,
          this._typeDefinition.attribute,
          this._attributeInstanceContainer.all,
          this._typeDefinition.isLock
        )
      }

      get attrDef() {
        return this._typeDefinition.attribute.get(this._selectedPred)
      }

      get _attributeDefinitions() {
        return this._typeDefinition.attribute.attributes
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/AttributeEditor/createNumericAttributeOrShowEditNumericAttributeDialog.js

    /* harmony default export */ function createNumericAttributeOrShowEditNumericAttributeDialog(
      selectionModelItems,
      attrDef,
      commander,
      pallet,
      editProperties
    ) {
      const attribute =
        selectionModelItems.findSelectedAttributeWithSamePredicate(attrDef.pred)

      if (attribute) {
        const isOnlyEntityWithJsutOneSamePredSelected =
          selectionModelItems.onlySelectedWithJustOneAttributeOf(attrDef.pred)

        if (isOnlyEntityWithJsutOneSamePredSelected) {
          openEditNumericAttributeDialog(
            selectionModelItems,
            attrDef,
            attribute,
            commander,
            pallet,
            editProperties
          )
        } else {
          alertify_default().warning(
            'Some selected items has zero or multi this attribute.'
          )
        }
      } else {
        const command = commander.factory.createAttributeToItemsCommand(
          selectionModelItems.all,
          attrDef
        )
        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/AttributeEditor/createStringAttributeOrShowEditStringAttributeDialog.js

    /* harmony default export */ function createStringAttributeOrShowEditStringAttributeDialog(
      selectionModelItems,
      attrDef,
      commander,
      editProperties,
      pallet
    ) {
      const attribute =
        selectionModelItems.findSelectedAttributeWithSamePredicate(attrDef.pred)

      if (attribute) {
        const isOnlyEntityWithJsutOneSamePredSelected =
          selectionModelItems.onlySelectedWithJustOneAttributeOf(attrDef.pred)

        if (isOnlyEntityWithJsutOneSamePredSelected) {
          openEditStringAttributeDialog(
            selectionModelItems,
            attribute,
            commander,
            attrDef,
            editProperties,
            pallet
          )
        } else {
          alertify_default().warning(
            'Some selected items has zero or multi this attribute.'
          )
        }
      } else {
        const command = commander.factory.createAttributeToItemsCommand(
          selectionModelItems.all,
          attrDef
        )
        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/AttributeEditor/index.js

    class AttributeEditor {
      constructor(
        commander,
        annotationModel,
        selectionModelItems,
        selectionAttributePallet,
        editProperties,
        typeValuesPallet
      ) {
        this._commander = commander
        this._annotationModel = annotationModel
        this._selectionModelItems = selectionModelItems
        this._selectionAttributePallet = selectionAttributePallet
        this._typeDefinition = annotationModel.typeDefinition
        this._editProperties = editProperties
        this._typeValuesPallet = typeValuesPallet
      }

      addOrEditAt(number) {
        this._selectionAttributePallet.hide()

        const attrDef = this._typeDefinition.attribute.getAttributeAt(number)

        if (!attrDef) {
          alertify_default().warning(`Attribute No.${number} is not defined`)
          return
        }

        switch (attrDef.valueType) {
          case 'flag':
            this._commander.invoke(
              this._commander.factory.toggleFlagAttributeToItemsCommand(
                this._selectionModelItems.all,
                attrDef
              )
            )
            break
          case 'numeric':
            createNumericAttributeOrShowEditNumericAttributeDialog(
              this._selectionModelItems,
              attrDef,
              this._commander,
              this._editProperties,
              this._typeValuesPallet
            )
            break
          case 'selection':
            {
              if (
                this._selectionModelItems.selectedWithAttributeOf(attrDef.pred)
              ) {
                this._selectionAttributePallet.show(attrDef).then((newObj) => {
                  if (
                    this._selectionModelItems.isDupulicatedPredAttrributeSelected(
                      attrDef.pred
                    )
                  ) {
                    alertify_default().warning(
                      'An item among the selected has this attribute multiple times.'
                    )
                  } else {
                    const command =
                      this._commander.factory.changeAttributeObjOfItemsCommand(
                        this._selectionModelItems.all,
                        attrDef,
                        newObj
                      )
                    this._commander.invoke(command)
                  }
                })
              } else {
                const command =
                  this._commander.factory.createAttributeToItemsCommand(
                    this._selectionModelItems.all,
                    attrDef
                  )
                this._commander.invoke(command)
              }
            }
            break
          case 'string':
            createStringAttributeOrShowEditStringAttributeDialog(
              this._selectionModelItems,
              attrDef,
              this._commander,
              this._editProperties,
              this._typeValuesPallet
            )
            break
          default:
            throw `${attrDef.valueType} is unknown attribute`
        }
      }

      deleteAt(number) {
        const attrDef = this._typeDefinition.attribute.getAttributeAt(number)

        if (!attrDef) {
          alertify_default().warning(`Attribute No.${number} is not defined`)
          return
        }

        if (this._selectionModelItems.selectedWithAttributeOf(attrDef.pred)) {
          const command =
            this._commander.factory.removeAttributesFromItemsByPredCommand(
              this._selectionModelItems.all,
              attrDef
            )
          this._commander.invoke(command)
        } else {
          alertify_default().warning(
            'None of the selected items has this attribute.'
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/component/SelectionAttributePallet/toBodyRow.js

    function SelectionAttributePallet_toBodyRow_toBodyRow(
      color,
      id,
      defaultValue,
      label
    ) {
      return () => anemone`
        <tr class="textae-editor__pallet__row" style="background-color: ${color};">
          <td class="textae-editor__pallet__selection-attribute-label" data-id="${id}">
            ${id}
            ${() =>
              defaultValue
                ? '<span class="textae-editor__pallet__default-icon" title="This type is set as a default type."></span>'
                : ''}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${label}
          </td>
          <td class="textae-editor__pallet__short-label">
            ${color}
          </td>
        </tr>
        `
    } // CONCATENATED MODULE: ./src/lib/component/SelectionAttributePallet/template.js

    /* harmony default export */ function SelectionAttributePallet_template(
      context
    ) {
      const { values } = context.attrDef

      return anemone`
  <div>
    <table>
      <thead>
        <tr>
          <th>id</th>
          <th>label</th>
          <th>color</th>
        </tr>
      </thead>
      <tbody>
        ${values.map(({ color = '', id, default: defaultValue, label = '' }) =>
          SelectionAttributePallet_toBodyRow_toBodyRow(
            color,
            id,
            defaultValue,
            label
          )
        )}
      </tbody>
    </table>
  </div>
  `
    } // CONCATENATED MODULE: ./src/lib/component/SelectionAttributePallet/index.js

    class SelectionAttributePallet extends Pallet {
      constructor(editorHTMLElement, mousePoint) {
        super(editorHTMLElement, 'Selection attribute', mousePoint)

        this._veil = dohtml_default().create(
          `<div style="position: fixed; right: 0; top: 0; bottom:0; left: 0; background-color: rgba(0, 0, 10, 0.3);"></div>`
        )

        // Close the SelectionAttributePallet with the Esc key.
        this._el.addEventListener('keydown', (event) => {
          if (event.code === 'Escape') {
            event.preventDefault()
            this.hide()
          }
        })
      }

      show(attrDef, zIndex = 90, opener = null) {
        this._editorHTMLElement.appendChild(this._veil)
        this._editorHTMLElement.appendChild(this.el)
        this._veil.style['z-index'] = zIndex + 1
        this._el.style['z-index'] = zIndex + 1
        this._attributeDefinition = attrDef
        super.show()

        // Focus on the close button to listen keydown events.
        // Store focusing element to revert focus when closeed.
        this._el.querySelector('.textae-editor__pallet__close-button').focus()
        this._opener = opener

        this._show = true

        return new Promise((resolve) => {
          delegate_default()(
            this._el,
            '.textae-editor__pallet__selection-attribute-label',
            'click',
            (e) => {
              this.hide()
              resolve(e.target.dataset.id)
            }
          )
        })
      }

      hide() {
        if (this._show) {
          this._editorHTMLElement.removeChild(this._veil)
          this._editorHTMLElement.removeChild(this.el)

          this._show = false
        }

        // Focus on the button used to open the palette
        // so that the Entity Edit dialog can be closed with the Esc key.
        if (this._opner) {
          this._opener.focus()
        }
      }

      get _content() {
        const values = {
          attrDef: this._attributeDefinition.externalFormat
        }
        return SelectionAttributePallet_template(values)
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/getValues.js

    /* harmony default export */ function getValues(content) {
      const typeName = content.querySelector(
        '.textae-editor__edit-type-values-dialog__type-name'
      ).value

      const label = content.querySelector(
        '.textae-editor__edit-type-values-dialog__type-label'
      ).innerText

      const attributes = []
      for (const attr of content.querySelectorAll(
        '.textae-editor__edit-type-values-dialog__attribute'
      )) {
        attributes.push({
          id: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.id,
          subj: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.subj,
          pred: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-predicate'
          ).dataset.pred,
          obj: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.obj,
          label: attr.querySelector(
            '.textae-editor__edit-type-values-dialog__attribute-value'
          ).dataset.label
        })
      }

      return { typeName, label, attributes }
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/createContentHTML/toEntityHTML.js

    /* harmony default export */ function toEntityHTML(value, entityContainer) {
      const label = entityContainer.getLabel(value) || ''

      return () => anemone`
    <tr>
      <td rowspan="2"></td>
      <td>
        <span class="textae-editor__edit-type-values-dialog__type-predicate">type</span>
      </td>
      <td class="ui-front">
        <input class="textae-editor__edit-type-values-dialog__type-name textae-editor__promise-dialog__observable-element" value="${value}">
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        <span class="textae-editor__edit-type-values-dialog__type-label">${label}</span>
      </td>
    </tr>
  `
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/createContentHTML/toAttributeHTML/getLabelOf.js

    /* harmony default export */ function getLabelOf(
      attribute,
      attributeContainer
    ) {
      const { pred, obj } = attribute
      const { valueType } = attributeContainer.get(pred)

      switch (valueType) {
        case 'string':
          // In the case of String attributes,
          // Labels completed by autocomplete can be reflected in attribute definitions.
          // We want to keep the label in the attribute hash until we press the OK button.
          return attribute.label || attributeContainer.getLabel(pred, obj) || ''
        case 'selection':
        case 'numeric':
        case 'flag':
          // In the case of Selection or Numeric or flag attributes,
          // we want to refer only to the label of the attribute definition.
          return attributeContainer.getLabel(pred, obj) || ''
        default:
          throw `unknown attribute type: ${valueType}`
      }
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/createContentHTML/toAttributeHTML/index.js

    /* harmony default export */ function toAttributeHTML(
      attribute,
      index,
      attributeInstances,
      attributeContainer
    ) {
      const { id, subj, pred, obj } = attribute
      const previousAttribute = attributeInstances[index - 1]
      const previousPredicate = previousAttribute && previousAttribute.pred
      const definitionIndex = attributeContainer.getIndexOf(pred)
      const { valueType } = attributeContainer.get(pred)

      const shortcutKeyColumn = () =>
        pred === previousPredicate
          ? `<td class="shortcut-key" rowspan="2"></td>`
          : `<td class="shortcut-key" rowspan="2">
          ${
            definitionIndex < 9
              ? `<span class="textae-editor__edit-type-values-dialog__shortcut-key" title="Shortcut key for this predicate">${
                  definitionIndex + 1
                }</span>`
              : ''
          }
        </td>
        `

      return () => anemone`
<tr class="textae-editor__edit-type-values-dialog__attribute">
  ${shortcutKeyColumn}
  <td rowspan="2">
    <span
      class="textae-editor__edit-type-values-dialog__attribute-predicate ${
        pred === previousPredicate
          ? ''
          : `textae-editor__edit-type-values-dialog__attribute-predicate--${valueType}`
      }"
      data-pred="${pred}"
      title="${valueType} type"
      >
      ${pred === previousPredicate ? '' : pred}
    </span>
  </td>
  <td>
    <span
      class="textae-editor__edit-type-values-dialog__attribute-value"
      data-id="${id}"
      data-subj="${subj || ''}""
      data-obj="${obj}"
      data-label="${getLabelOf(attribute, attributeContainer)}"
      >
      ${getLabelOf(attribute, attributeContainer) || obj}
    </span>
  </td>
</tr>
<tr>
  <td>
    <button
      type="button"
      class="textae-editor__edit-type-values-dialog__edit-attribute"
      data-pred="${pred}"
      data-index="${index}"
      ${valueType === 'flag' ? 'disabled="disabled"' : ''}>
    </button>
    <button
      type="button"
      class="textae-editor__edit-type-values-dialog__remove-attribute"
      data-index="${index}">
    </button>
  </td>
</tr>
`
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/createContentHTML/toAddAttributeButton.js

    function toAddAttributeButton(valueType, pred, isDisabled) {
      const title = () =>
        isDisabled
          ? `disabled="disabled" title="This predicate is already used with its default value."`
          : anemone`title="${valueType} type"`

      return () => anemone`
    <button
     type="button"
     class="textae-editor__edit-type-values-dialog__add-attribute textae-editor__edit-type-values-dialog__add-attribute--${valueType}"
     data-pred="${pred}"
      ${title}> ${pred}</button>`
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/createContentHTML/index.js

    /* harmony default export */ function createContentHTML(
      typeName,
      attributes,
      entityContainer,
      attributeContainer,
      palletName
    ) {
      return anemone`
    <div style="overflow-y: auto; max-height: 36em; overflow-x: hidden;">
      <table class="textae-editor__edit-type-values-dialog__table">
        <thead>
          <tr>
            <th></th>
            <th>Predicate</th>
            <th>Value/Label</th>
          </tr>
        </thead>
        <tbody>
          ${toEntityHTML(typeName, entityContainer)}
          ${attributes.map((a, index, list) =>
            toAttributeHTML(a, index, list, attributeContainer)
          )}
          </tbody>
      </table>
    </div>
    <fieldset>
      <legend>
        <span class="textae-editor__edit-type-values-dialog__open-pallet" title="${palletName} Configuration"></span>
        Available Predicates:
      </legend>
      <div class="textae-editor__edit-type-values-dialog__add-attribute-buttons">
      ${attributeContainer.attributes.map(({ pred, valueType }) =>
        toAddAttributeButton(
          valueType,
          pred,
          isAlreadyUsed(attributes, pred, attributeContainer)
        )
      )}
      </div>
    </fieldset>
  `
    }

    function isAlreadyUsed(attributes, pred, attributeContainer) {
      return attributes.some(
        (i) =>
          i.pred === pred &&
          String(i.obj) === String(attributeContainer.get(pred).default)
      )
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/mergedTypeValuesOf.js

    // When you select multiple entities and display the edit dialog,
    // this is used to display the merged type name and attributes.
    /* harmony default export */ function mergedTypeValuesOf(entities) {
      const { typeName } = entities[entities.length - 1]

      const mergedAttributes = []
      for (const { attributes } of entities) {
        for (const attribute of attributes) {
          if (
            !mergedAttributes.some((a) =>
              a.equalsTo(attribute.pred, attribute.obj)
            )
          ) {
            mergedAttributes.push(attribute)
          }
        }
      }

      return new TypeValues(typeName, mergedAttributes)
    } // CONCATENATED MODULE: ./src/lib/component/EditPropertiesDialog/index.js

    class EditPropertiesDialog extends PromiseDialog {
      constructor(
        editorHTMLElement,
        annotationType,
        palletName,
        entityContainer,
        attributeContainer,
        autocompletionWs,
        selectedItems,
        typeValuesPallet,
        mousePoint
      ) {
        const { typeName, attributes } = mergedTypeValuesOf(selectedItems)
        const contentHtml = createContentHTML(
          typeName,
          attributes,
          entityContainer,
          attributeContainer,
          palletName
        )

        super(
          `${annotationType} [${selectedItems
            .map(({ id }) => id)
            .join(',')}] Properties`,
          contentHtml,
          {
            maxWidth: 800
          },
          () => getValues(super.el)
        )

        // Observe edit an attribute button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__edit-attribute',
          'click',
          (e) => {
            const { pred } = e.target.dataset
            const attrDef = attributeContainer.get(pred)
            const zIndex = parseInt(
              super.el.closest('.textae-editor__dialog').style['z-index']
            )
            const { typeName, attributes } = getValues(super.el)

            switch (attrDef.valueType) {
              case 'numeric':
                new EditNumericAttributeDialog(
                  attrDef,
                  attributes[e.target.dataset.index],
                  [attributes[e.target.dataset.index]]
                )
                  .open()
                  .then(({ newObj }) => {
                    attributes[e.target.dataset.index].obj = newObj
                    this.#updateDisplay(
                      typeName,
                      attributes,
                      attributeContainer,
                      entityContainer
                    )
                  })
                break
              case 'selection':
                new SelectionAttributePallet(editorHTMLElement, mousePoint)
                  .show(attrDef, zIndex, e.target)
                  .then((newObj) => {
                    attributes[e.target.dataset.index].obj = newObj
                    this.#updateDisplay(
                      typeName,
                      attributes,
                      attributeContainer,
                      entityContainer
                    )
                  })
                break
              case 'string':
                new EditStringAttributeDialog(
                  attrDef,
                  attributes[e.target.dataset.index],
                  [attributes[e.target.dataset.index]]
                )
                  .open()
                  .then(({ newObj, newLabel }) => {
                    attributes[e.target.dataset.index].obj = newObj
                    attributes[e.target.dataset.index].label = newLabel
                    this.#updateDisplay(
                      typeName,
                      attributes,
                      attributeContainer,
                      entityContainer
                    )
                  })
                break
              default:
                throw `${attrDef.valueType} is unknown attribute.`
            }
          }
        )

        // Observe remove an attribute button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__remove-attribute',
          'click',
          (e) => {
            const { index } = e.target.dataset
            const indexOfAttribute = parseInt(index)
            const { typeName, attributes } = getValues(super.el)
            this.#updateDisplay(
              typeName,
              attributes.filter((_, i) => i !== indexOfAttribute),
              attributeContainer,
              entityContainer
            )
          }
        )

        // Observe open pallet button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__open-pallet',
          'click',
          () => {
            super.close()
            typeValuesPallet.show()
          }
        )

        // Observe add an attribute button.
        delegate_default()(
          super.el,
          '.textae-editor__edit-type-values-dialog__add-attribute',
          'click',
          (e) => {
            const { pred } = e.target.dataset
            const defaultValue = attributeContainer.get(pred).default

            const { typeName, attributes } = getValues(super.el)
            this.#updateDisplay(
              typeName,
              attributes
                .concat({ pred, obj: defaultValue, id: '' })
                .sort((a, b) =>
                  attributeContainer.attributeCompareFunction(a, b)
                ),
              attributeContainer,
              entityContainer
            )
          }
        )

        // Setup autocomplete
        const typeNameElement = super.el.querySelector(
          '.textae-editor__edit-type-values-dialog__type-name'
        )
        const typeLabelElement = super.el.querySelector(
          '.textae-editor__edit-type-values-dialog__type-label'
        )
        component_setSourceOfAutoComplete(
          typeNameElement,
          typeLabelElement,
          autocompletionWs,
          (term) => entityContainer.findByLabel(term)
        )
      }

      #updateDisplay(
        typeName,
        attributes,
        attributeContainer,
        entityContainer
      ) {
        const contentHtml = createContentHTML(
          typeName,
          attributes,
          entityContainer,
          attributeContainer
        )
        super.el.closest('.ui-dialog-content').innerHTML = contentHtml
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditDenotation/index.js

    class EditDenotation extends Edit {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationModel,
        selectionModel,
        commander,
        controlViewModel,
        spanConfig,
        autocompletionWs,
        mousePoint
      ) {
        const denotationPallet = new TypeValuesPallet(
          editorHTMLElement,
          eventEmitter,
          annotationModel.typeDefinition,
          annotationModel.attribute,
          annotationModel.typeDefinition.denotation,
          selectionModel.entity,
          commander,
          'Term configuration',
          controlViewModel,
          mousePoint
        )

        const spanEditor = new SpanEditor(
          editorHTMLElement,
          annotationModel,
          selectionModel,
          commander,
          controlViewModel,
          spanConfig
        )

        const getAutocompletionWs = () =>
          autocompletionWs || annotationModel.typeDefinition.autocompletionWs

        super(
          editorHTMLElement,
          selectionModel,
          annotationModel,
          denotationPallet,
          commander,
          getAutocompletionWs,
          annotationModel.typeDefinition.denotation,
          'entity'
        )

        this._mouseEventHandler = new MouseEventHandler(
          editorHTMLElement,
          annotationModel,
          selectionModel,
          denotationPallet,
          spanEditor
        )
        this._spanEditor = spanEditor
        this._controlViewModel = controlViewModel
        this._textBox = editorHTMLElement.querySelector(
          '.textae-editor__text-box'
        )
        this._spanModelContainer = annotationModel.span

        this._attributeEditor = new AttributeEditor(
          commander,
          annotationModel,
          selectionModel.entity,
          new SelectionAttributePallet(editorHTMLElement, mousePoint),
          () => this.editProperties(),
          denotationPallet
        )
        this._mousePoint = mousePoint
      }

      bindMouseEvents() {
        return bindMouseEvents(this._editorHTMLElement, this._mouseEventHandler)
      }

      createSpan() {
        this._spanEditor.cerateSpanForTouchDevice()
      }

      expandSpan() {
        this._spanEditor.expandForTouchDevice()
      }

      shrinkSpan() {
        this._spanEditor.shrinkForTouchDevice()
      }

      applyTextSelection() {
        if (isRangeInTextBox(window.getSelection(), this._textBox)) {
          const selectionWrapper = new SelectionWrapper(
            this._spanModelContainer
          )
          const { begin, end } = new OrderedPositions(
            selectionWrapper.positionsOnAnnotation
          )
          const isSelectionTextCrossingAnySpan =
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )

          this._controlViewModel.updateManipulateSpanButtons(
            selectionWrapper.isParentOfBothNodesSame,
            isSelectionTextCrossingAnySpan,
            isSelectionTextCrossingAnySpan
          )
        } else {
          this._controlViewModel.updateManipulateSpanButtons(
            false,
            false,
            false
          )
        }
      }

      editProperties() {
        if (this._selectionModel.entity.some) {
          new EditPropertiesDialog(
            this._editorHTMLElement,
            'Entity',
            'Entity',
            this._definitionContainer,
            this._annotationModel.typeDefinition.attribute,
            this._getAutocompletionWs(),
            this._selectionModel.entity.all,
            this.pallet,
            this._mousePoint
          )
            .open()
            .then((values) => this._typeValuesChanged(values))
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditBlock/validateNewBlockSpan.js

    /* harmony default export */ function validateNewBlockSpan(
      annotationModel,
      begin,
      end,
      spanID
    ) {
      // The span cross exists spans.
      if (annotationModel.span.isBoundaryCrossingWithOtherSpans(begin, end)) {
        alertify_default().warning(
          'A span cannot be modifyed to make a boundary crossing.'
        )
        return false
      }

      if (annotationModel.span.doesParentOrSameSpanExist(begin, end)) {
        return false
      }

      // There is a BlockSpan that is a child.
      if (
        annotationModel.span.hasBlockSpanBetween(begin, end, {
          excluded: spanID
        })
      ) {
        return false
      }

      return true
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditBlock/create.js

    /* harmony default export */ function EditBlock_create(
      annotationModel,
      commander,
      spanAdjuster,
      selectionWrapper,
      spanConfig
    ) {
      const { begin, end } = getNewSpan(
        annotationModel.sourceDoc,
        spanAdjuster,
        selectionWrapper,
        spanConfig
      )

      if (validateNewBlockSpan(annotationModel, begin, end)) {
        const command = commander.factory.createBlockSpanCommand({
          begin,
          end
        })

        commander.invoke(command)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditBlock/SpanEditor.js

    class SpanEditor_SpanEditor {
      constructor(
        editorHTMLElement,
        annotationModel,
        spanConfig,
        commander,
        controlViewModel,
        selectionModel
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._annotationModel = annotationModel
        this._spanConfig = spanConfig
        this._commander = commander
        this._controlViewModel = controlViewModel
        this._selectionModel = selectionModel
      }

      /**
       *
       * @param {SelectionWrapper} selectionWrapper
       */
      editFor(selectionWrapper) {
        if (selectionWrapper.isParentOfAnchorNodeTextBox) {
          if (selectionWrapper.isParentOfFocusNodeTextBox) {
            this._create(selectionWrapper)
            return
          }

          if (
            selectionWrapper.isParentOfFocusNodeDenotationSpan ||
            selectionWrapper.isParentOfFocusNodeStyleSpan
          ) {
            if (selectionWrapper.ancestorBlockSpanOfFocusNode) {
              this._shrink(selectionWrapper)
            } else {
              this._create(selectionWrapper)
            }

            return
          }

          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._shrink(selectionWrapper)
            return
          }
        }

        if (
          selectionWrapper.isParentOfAnchorNodeDenotationSpan ||
          selectionWrapper.isParentOfAnchorNodeStyleSpan
        ) {
          if (
            selectionWrapper.isParentOfFocusNodeTextBox ||
            selectionWrapper.isParentOfFocusNodeDenotationSpan ||
            selectionWrapper.isParentOfFocusNodeStyleSpan
          ) {
            if (selectionWrapper.ancestorBlockSpanOfAnchorNode) {
              if (selectionWrapper.doesFitInOneBlockSpan) {
                const { anchor, focus } = selectionWrapper.positionsOnAnnotation
                const spanOnAnchor = this._annotationModel.span.get(
                  selectionWrapper.parentOfAnchorNode.id
                )
                const blockSpanOnAnchor = this._annotationModel.span.get(
                  selectionWrapper.ancestorBlockSpanOfAnchorNode.id
                )

                if (
                  anchor < focus &&
                  spanOnAnchor.begin === blockSpanOnAnchor.begin
                ) {
                  this._shrink(selectionWrapper)
                } else if (
                  focus < anchor &&
                  spanOnAnchor.end === blockSpanOnAnchor.end
                ) {
                  this._shrink(selectionWrapper)
                } else {
                  clearTextSelection()
                }
              } else {
                // Expand when the selection exceeds a single block span.
                this._expand(selectionWrapper)
              }
            } else if (selectionWrapper.ancestorBlockSpanOfFocusNode) {
              this._shrink(selectionWrapper)
            } else {
              this._create(selectionWrapper)
            }

            return
          }

          // When collapsing a block containing the beginning or end of the text,
          // and also when the beginning or end of the text is a denotation or style span,
          // the anchor node is within the denotation or style span.
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            this._shrink(selectionWrapper)
            return
          }
        }

        if (selectionWrapper.isParentOfAnchorNodeBlockSpan) {
          if (
            selectionWrapper.isParentOfFocusNodeTextBox ||
            selectionWrapper.isParentOfFocusNodeDenotationSpan ||
            selectionWrapper.isParentOfFocusNodeStyleSpan
          ) {
            if (selectionWrapper.ancestorBlockSpanOfFocusNode) {
              this._shrink(selectionWrapper)
            } else {
              this._expand(selectionWrapper)
            }

            return
          }

          // When you shrink a block containing the beginning or end of the text,
          // the anchor node is in the block.
          if (selectionWrapper.isParentOfFocusNodeBlockSpan) {
            const { anchor } = selectionWrapper.positionsOnAnnotation
            const blockSpanOnFocus = this._annotationModel.span.get(
              selectionWrapper.parentOfFocusNode.id
            )

            // Shrink the block span
            // only when the anchor position matches the begin or end position of the block span.
            if (
              anchor === blockSpanOnFocus.begin ||
              anchor === blockSpanOnFocus.end
            ) {
              this._shrink(selectionWrapper)
              return
            }
          }
        }

        clearTextSelection()
      }

      cerateSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(
          this._annotationModel.span
        )

        if (selectionWrapper.isParentOfBothNodesTextBox) {
          this._create(selectionWrapper)
        }
      }

      expandForTouchDevice() {
        const expandedSpan = this._getExpandedSpanForTouchDevice()
        if (expandedSpan) {
          const { spanID, begin, end } = expandedSpan

          if (validateNewBlockSpan(this._annotationModel, begin, end, spanID)) {
            this._commander.invoke(
              this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
            )
          }
        }
      }

      shrinkForTouchDevice() {
        const shrinkedSpan = this._getShrinkedSpanForTouchDevice()
        if (shrinkedSpan) {
          const { spanID, begin, end } = shrinkedSpan
          const nextSpan = getRightSpanElement(this._editorHTMLElement, spanID)

          // The span cross exists spans.
          if (
            this._annotationModel.span.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )
          ) {
            alertify_default().warning(
              'A span cannot be modifyed to make a boundary crossing.'
            )
            return
          }

          // There is parant span.
          if (this._annotationModel.span.hasParentOf(begin, end, spanID)) {
            return
          }

          const doesExists = this._annotationModel.span.hasBlockSpan(begin, end)
          if (begin < end && !doesExists) {
            this._commander.invoke(
              this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
            )
          } else {
            this._commander.invoke(
              this._commander.factory.removeSpanCommand(spanID)
            )
            if (nextSpan) {
              this._selectionModel.selectSpan(nextSpan.id)
            }
          }
        }
      }

      _create(selectionWrapper) {
        if (
          hasCharacters(
            this._annotationModel.sourceDoc,
            this._spanConfig,
            selectionWrapper
          )
        ) {
          this._selectionModel.removeAll()
          EditBlock_create(
            this._annotationModel,
            this._commander,
            this._controlViewModel.spanAdjuster,
            selectionWrapper,
            this._spanConfig
          )
        }
        clearTextSelection()
      }

      _expand(selectionWrapper) {
        const spanID = selectionWrapper.ancestorBlockSpanOfAnchorNode.id

        this._selectionModel.removeAll()

        const { begin, end } = this._annotationModel.span
          .get(spanID)
          .getExpandedInAnchorNodeToFocusNodeDirection(
            this._controlViewModel.spanAdjuster,
            selectionWrapper,
            this._annotationModel.sourceDoc,
            this._spanConfig
          )

        if (validateNewBlockSpan(this._annotationModel, begin, end, spanID)) {
          this._commander.invoke(
            this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
          )
        }

        clearTextSelection()
      }

      _shrink(selectionWrapper) {
        const spanID = selectionWrapper.ancestorBlockSpanOfFocusNode.id

        shrinkSpan(
          this._editorHTMLElement,
          this._annotationModel.span,
          this._annotationModel.sourceDoc,
          this._selectionModel,
          this._commander,
          this._controlViewModel.spanAdjuster,
          spanID,
          selectionWrapper,
          this._spanConfig,
          (begin, end) => {
            this._commander.invoke(
              this._commander.factory.moveBlockSpanCommand(spanID, begin, end)
            )
          }
        )

        clearTextSelection()
      }

      _getExpandedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(
          this._annotationModel.span
        )

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to expand does not exist.
        if (
          selectionWrapper.ancestorBlockSpanOfAnchorNode == null &&
          selectionWrapper.ancestorBlockSpanOfFocusNode == null
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.parentOfAnchorNode.id

          return {
            spanID,
            ...this._annotationModel.span
              .get(spanID)
              .getExpandedInAnchorNodeToFocusNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.parentOfFocusNode.id

          return {
            spanID,
            ...this._annotationModel.span
              .get(spanID)
              .getExpandedInFocusNodeToAnchorNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }
      }

      _getShrinkedSpanForTouchDevice() {
        const selectionWrapper = new SelectionWrapper(
          this._annotationModel.span
        )

        // When there is no denotation span in ancestors of anchor node and focus node,
        // a span to shrink does not exist.
        if (
          selectionWrapper.ancestorBlockSpanOfAnchorNode == null &&
          selectionWrapper.ancestorBlockSpanOfFocusNode == null
        ) {
          return null
        }

        // On mobile devices,
        // do not shrink the block span when the selected text fits into one block span.
        if (
          selectionWrapper.parentOfAnchorNode ===
          selectionWrapper.parentOfFocusNode
        ) {
          return null
        }

        // When you select text by mouse operation,
        // the anchor node of the selected string is always inside the span to be extended,
        // and the focus node is outside.
        if (
          selectionWrapper.parentOfFocusNode.contains(
            selectionWrapper.parentOfAnchorNode
          )
        ) {
          const spanID = selectionWrapper.parentOfAnchorNode.id

          return {
            spanID,
            ...this._annotationModel.span
              .get(spanID)
              .getShortenInFocusNodeToAnchorNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }

        // On touch devices, the focus node of the selected string may be inside the span to be extended,
        // and the anchor node may be outside.
        if (
          selectionWrapper.parentOfAnchorNode.contains(
            selectionWrapper.parentOfFocusNode
          )
        ) {
          const spanID = selectionWrapper.parentOfFocusNode.id

          return {
            spanID,
            ...this._annotationModel.span
              .get(spanID)
              .getShortenInAnchorNodeToFocusNodeDirection(
                this._controlViewModel.spanAdjuster,
                selectionWrapper,
                this._annotationModel.sourceDoc,
                this._spanConfig
              )
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditBlock/bindMouseEvents.js

    /* harmony default export */ function EditBlock_bindMouseEvents(
      editorHTMLElement,
      mouseEventHandler
    ) {
      const listeners = []

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__text-box',
          'click',
          (e) => {
            if (e.target.classList.contains('textae-editor__text-box')) {
              mouseEventHandler.textBoxClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor',
          'click',
          (e) => {
            // The delegate also fires events for child elements of the selector.
            // Ignores events that occur in child elements.
            // Otherwise, you cannot select child elements.
            if (e.target.classList.contains('textae-editor')) {
              mouseEventHandler.bodyClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard',
          'mousedown',
          () => mouseEventHandler.signboardClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard__type-values',
          'click',
          (event) => {
            const entityID = getEntityHTMLelementFromChild(event.target).dataset
              .id
            mouseEventHandler.typeValuesClicked(event, entityID)
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__block',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__block')) {
              mouseEventHandler.blockSpanClicked()
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__block-hit-area',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__block-hit-area')) {
              mouseEventHandler.blockHitAreaClicked(e)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__style',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__style')) {
              mouseEventHandler.styleSpanClicked(e)
            }
          }
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__span',
          'mouseup',
          (e) => {
            if (e.target.classList.contains('textae-editor__span')) {
              mouseEventHandler.denotationSpanClicked(e)
            }
          }
        )
      )

      return listeners
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditBlock/MouseEventHandler.js

    class MouseEventHandler_MouseEventHandler {
      /**
       *
       * @param {import('./SpanEditor').default} spanEditor
       */
      constructor(
        editorHTMLElement,
        annotationModel,
        selectionModel,
        spanEditor,
        pallet
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._annotationModel = annotationModel
        this._selectionModel = selectionModel
        this._spanEditor = spanEditor
        this._pallet = pallet
      }

      bodyClicked() {
        this._pallet.hide()
        this._selectionModel.removeAll()
      }

      textBoxClicked() {
        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          this._pallet.hide()
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
        }
      }

      blockSpanClicked() {
        const selection = window.getSelection()

        if (selection.type === 'Caret') {
          this._pallet.hide()
          clearTextSelection()
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
        }
      }

      // Mouse events to the block span are handled by the hit area instead,
      // to show the block span shifted up half a line.
      blockHitAreaClicked(e) {
        // When you click on the text, the browser will automatically select the word.
        // Therefore, the editor shrinks spans instead of selecting spans.
        // Deselect the text.
        if (e.button === 2) {
          clearTextSelection()
        }

        const selection = window.getSelection()

        // When you create a block span and
        // click on another block span while holding down the Shift key,
        // the Selection type will be 'None'.
        if (selection.type === 'Caret' || selection.type === 'None') {
          const spanId = e.target.dataset.id

          this._selectSpanAndEntity(e, spanId)
        }
      }

      styleSpanClicked(e) {
        const selection = window.getSelection()
        if (selection.type === 'Caret') {
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
          e.stopPropagation()
        }
      }

      denotationSpanClicked(e) {
        const selection = window.getSelection()
        if (selection.type === 'Caret') {
          this._selectionModel.removeAll()
        }

        if (
          isRangeInTextBox(
            selection,
            this._editorHTMLElement.querySelector('.textae-editor__text-box')
          )
        ) {
          this._spanEditor.editFor(
            new SelectionWrapper(this._annotationModel.span)
          )
          e.stopPropagation()
        }
      }

      signboardClicked() {
        this._editorHTMLElement.focus()
      }

      typeValuesClicked(event, entityID) {
        const entity = this._annotationModel.entity.get(entityID)

        if (entity.isBlock) {
          if (event.ctrlKey || event.metaKey) {
            this._selectionModel.entity.toggle(entityID)
          } else {
            this._selectionModel.selectEntity(entityID)
          }

          // Select span of the selected entity.
          const spans = this._selectionModel.entity.all
            .map((entity) => entity.span)
            .map((span) => span.id)
          this._selectionModel.add('span', spans)
        }
      }

      _selectSpanAndEntity(event, spanID) {
        const selectedSpanID = this._selectionModel.span.singleId
        const rangeOfSpans =
          event.shiftKey && selectedSpanID
            ? this._annotationModel.span.rangeBlockSpan(selectedSpanID, spanID)
            : []

        selectSpan(this._selectionModel, rangeOfSpans, event, spanID)

        // Select entities of the selected span.
        // Block is a first entity of the span.
        const entities = this._selectionModel.span.all
          .map((span) => span.entities.at(0))
          .map((entity) => entity.id)

        this._selectionModel.add('entity', entities)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditBlock/index.js

    class EditBlock extends Edit {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationModel,
        selectionModel,
        spanConfig,
        commander,
        controlViewModel,
        autocompletionWs,
        mousePoint
      ) {
        const spanEditor = new SpanEditor_SpanEditor(
          editorHTMLElement,
          annotationModel,
          spanConfig,
          commander,
          controlViewModel,
          selectionModel
        )

        const blockPallet = new TypeValuesPallet(
          editorHTMLElement,
          eventEmitter,
          annotationModel.typeDefinition,
          annotationModel.attribute,
          annotationModel.typeDefinition.block,
          selectionModel.entity,
          commander,
          'Block configuration',
          controlViewModel,
          mousePoint
        )

        const getAutocompletionWs = () =>
          autocompletionWs || annotationModel.typeDefinition.autocompletionWs

        super(
          editorHTMLElement,
          selectionModel,
          annotationModel,
          blockPallet,
          commander,
          getAutocompletionWs,
          annotationModel.typeDefinition.block,
          'entity'
        )

        this._mouseEventHandler = new MouseEventHandler_MouseEventHandler(
          editorHTMLElement,
          annotationModel,
          selectionModel,
          spanEditor,
          blockPallet
        )
        this._spanEditor = spanEditor
        this._controlViewModel = controlViewModel
        this._textBox = editorHTMLElement.querySelector(
          '.textae-editor__text-box'
        )
        this._spanModelContainer = annotationModel.span

        this._attributeEditor = new AttributeEditor(
          commander,
          annotationModel,
          selectionModel.entity,
          new SelectionAttributePallet(editorHTMLElement, mousePoint),
          () => this.editProperties(),
          blockPallet
        )
        this._mousePoint = mousePoint
      }

      bindMouseEvents() {
        return EditBlock_bindMouseEvents(
          this._editorHTMLElement,
          this._mouseEventHandler
        )
      }

      createSpan() {
        this._spanEditor.cerateSpanForTouchDevice()
      }

      expandSpan() {
        this._spanEditor.expandForTouchDevice()
      }

      shrinkSpan() {
        this._spanEditor.shrinkForTouchDevice()
      }

      applyTextSelection() {
        if (isRangeInTextBox(window.getSelection(), this._textBox)) {
          const selectionWrapper = new SelectionWrapper(
            this._spanModelContainer
          )
          const { begin, end } = new OrderedPositions(
            selectionWrapper.positionsOnAnnotation
          )
          const isSelectionTextCrossingAnySpan =
            this._spanModelContainer.isBoundaryCrossingWithOtherSpans(
              begin,
              end
            )

          this._controlViewModel.updateManipulateSpanButtons(
            selectionWrapper.isParentOfBothNodesTextBox,
            isSelectionTextCrossingAnySpan,
            isSelectionTextCrossingAnySpan
          )
        } else {
          this._controlViewModel.updateManipulateSpanButtons(
            false,
            false,
            false
          )
        }
      }

      editProperties() {
        if (this._selectionModel.entity.some) {
          new EditPropertiesDialog(
            this._editorHTMLElement,
            'Block',
            'Entity',
            this._definitionContainer,
            this._annotationModel.typeDefinition.attribute,
            this._getAutocompletionWs(),
            this._selectionModel.entity.all,
            this.pallet,
            this._mousePoint
          )
            .open()
            .then((values) => this._typeValuesChanged(values))
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditRelation/bindMouseEvents.js

    // Manipulate only entities and relations on the Edit Relation mode.
    // For support context menu.
    // Mouse up event occurs when either left or right button is clicked.
    // Change mouse events to monitor from mouseup to click since v5.0.0.
    /* harmony default export */ function EditRelation_bindMouseEvents(
      editorHTMLElement,
      mouseEventHandler
    ) {
      const listeners = []

      // In relation mode does not manipulate the child elements in the text box.
      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__text-box',
          'click',
          () => mouseEventHandler.bodyClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor',
          'click',
          (e) => {
            // The delegate also fires events for child elements of the selector.
            // Ignores events that occur in child elements.
            // Otherwise, you cannot select child elements.
            if (e.target.classList.contains('textae-editor')) {
              mouseEventHandler.bodyClicked()
            }
          }
        )
      )

      listeners.push(
        // When a relation is selected, the HTML element of the relation is recreated,
        // so the click event is not fired on the parent element.
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard',
          'mousedown',
          () => mouseEventHandler.signboardClicked()
        )
      )

      listeners.push(
        delegate_default()(
          editorHTMLElement,
          '.textae-editor__signboard__type-values',
          'click',
          (event) => {
            const entityID = getEntityHTMLelementFromChild(event.target).dataset
              .id
            mouseEventHandler.typeValuesClicked(event, entityID)
          }
        )
      )

      return listeners
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditRelation/MouseEventHandler/typeValuesClicked/updateSelectionOfEntity.js

    /* harmony default export */ function updateSelectionOfEntity(
      event,
      selectionModel,
      subjectEntityId,
      objectEntityId
    ) {
      if (event.ctrlKey || event.metaKey) {
        // Remaining selection of the subject entity.
        selectionModel.remove('entity', objectEntityId)
      } else if (event.shiftKey) {
        selectionModel.remove('entity', subjectEntityId)
        selectionModel.add('entity', [objectEntityId])
      } else {
        selectionModel.remove('entity', subjectEntityId)
        selectionModel.remove('entity', objectEntityId)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditRelation/MouseEventHandler/typeValuesClicked/index.js

    /* harmony default export */ function typeValuesClicked(
      selectionModel,
      commander,
      relationDefinitionContainer,
      event,
      entityID
    ) {
      if (!selectionModel.entity.some) {
        selectionModel.selectEntity(entityID)
      } else {
        const subjectEntityId = selectionModel.entity.singleId
        const objectEntityId = entityID

        // Cannot make a self reference relation.
        if (subjectEntityId === objectEntityId) {
          selectionModel.entity.toggle(subjectEntityId)
        } else {
          commander.invoke(
            commander.factory.createRelationCommand({
              subj: subjectEntityId,
              obj: objectEntityId,
              pred: relationDefinitionContainer.defaultType
            })
          )

          updateSelectionOfEntity(
            event,
            selectionModel,
            subjectEntityId,
            objectEntityId
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditRelation/MouseEventHandler/index.js

    class EditRelation_MouseEventHandler_MouseEventHandler {
      constructor(
        editorHTMLElement,
        selectionModel,
        commander,
        typeDefinition,
        pallet
      ) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
        this._commander = commander
        this._typeDefinition = typeDefinition
        this._pallet = pallet
      }

      bodyClicked() {
        this._pallet.hide()
        this._selectionModel.removeAll()
      }

      signboardClicked() {
        this._editorHTMLElement.focus()
      }

      typeValuesClicked(event, entityID) {
        typeValuesClicked(
          this._selectionModel,
          this._commander,
          this._typeDefinition.relation,
          event,
          entityID
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/EditRelation/index.js

    class EditRelation extends Edit {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationModel,
        selectionModel,
        commander,
        autocompletionWs,
        controlViewModel,
        mousePoint
      ) {
        const relationPallet = new TypeValuesPallet(
          editorHTMLElement,
          eventEmitter,
          annotationModel.typeDefinition,
          annotationModel.attribute,
          annotationModel.typeDefinition.relation,
          selectionModel.relation,
          commander,
          'Relation configuration',
          controlViewModel,
          mousePoint
        )

        const getAutocompletionWs = () =>
          autocompletionWs || annotationModel.typeDefinition.autocompletionWs

        super(
          editorHTMLElement,
          selectionModel,
          annotationModel,
          relationPallet,
          commander,
          getAutocompletionWs,
          annotationModel.typeDefinition.relation,
          'relation'
        )

        this._editorHTMLElement = editorHTMLElement
        this._mouseEventHandler =
          new EditRelation_MouseEventHandler_MouseEventHandler(
            editorHTMLElement,
            selectionModel,
            commander,
            annotationModel.typeDefinition,
            relationPallet
          )
        this._controlViewModel = controlViewModel
        this._attributeEditor = new AttributeEditor(
          commander,
          annotationModel,
          selectionModel.relation,
          new SelectionAttributePallet(editorHTMLElement, mousePoint),
          () => this.editProperties(),
          relationPallet
        )
        this._mousePoint = mousePoint
      }

      bindMouseEvents() {
        return EditRelation_bindMouseEvents(
          this._editorHTMLElement,
          this._mouseEventHandler
        )
      }

      applyTextSelection() {
        this._controlViewModel.updateManipulateSpanButtons(false, false, false)
      }

      editProperties() {
        if (this._selectionModel.relation.some) {
          new EditPropertiesDialog(
            this._editorHTMLElement,
            'Relation',
            'Relation',
            this._definitionContainer,
            this._annotationModel.typeDefinition.attribute,
            this._getAutocompletionWs(),
            this._selectionModel.relation.all,
            this.pallet,
            this._mousePoint
          )
            .open()
            .then((values) => this._typeValuesChanged(values))
        }
      }

      relationClicked(event, relation) {
        if (event.ctrlKey || event.metaKey) {
          this._selectionModel.relation.toggle(relation.id)
        } else {
          this._selectionModel.selectRelation(relation.id)
        }
      }

      relationBollardClicked(entity) {
        entity.span.forceRenderGrid()
        this._selectionModel.selectEntity(entity.id)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/ModeReactor/EditorCSS.js

    class EditorCSS {
      constructor(editorHTMLElement) {
        this._editorHTMLElement = editorHTMLElement
      }

      clear() {
        for (const cssClass of this._editorHTMLElement.classList) {
          if (cssClass.startsWith('textae-editor__mode')) {
            this._editorHTMLElement.classList.remove(cssClass)
          }
        }
      }

      setFor(mode) {
        this._editorHTMLElement.classList.add(`textae-editor__mode--${mode}`)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/ModeReactor/index.js

    class ModeReactor {
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationModel,
        cancelSelect,
        editDenotation,
        editBlock,
        editRelation
      ) {
        this._listeners = []

        const editorCSS = new EditorCSS(editorHTMLElement)
        eventEmitter.on(
          'textae-event.edit-mode.transition',
          (mode, showRelation) => {
            cancelSelect()
            this._unbindAllMouseEventHandler()
            editorCSS.clear()

            switch (mode) {
              case MODE.VIEW:
                annotationModel.typeGap.show = showRelation
                if (showRelation) {
                  editorCSS.setFor('view-with-relation')
                } else {
                  editorCSS.setFor('view-without-relation')
                }
                break
              case MODE.EDIT_DENOTATION:
                annotationModel.typeGap.show = showRelation
                this._listeners = editDenotation.bindMouseEvents()
                if (showRelation) {
                  editorCSS.setFor('denotation-with-relation')
                } else {
                  editorCSS.setFor('denotation-without-relation')
                }
                break
              case MODE.EDIT_BLOCK:
                annotationModel.typeGap.show = showRelation
                this._listeners = editBlock.bindMouseEvents()
                if (showRelation) {
                  editorCSS.setFor('block-with-relation')
                } else {
                  editorCSS.setFor('block-without-relation')
                }
                break
              case MODE.EDIT_RELATION:
                annotationModel.typeGap.show = true
                this._listeners = editRelation.bindMouseEvents()
                editorCSS.setFor('relation')
                break
              default:
                throw new Error(`Unknown mode: ${mode}`)
            }
          }
        )
      }

      _unbindAllMouseEventHandler() {
        for (const listener of this._listeners) {
          listener.destroy()
        }
        this._listeners = []
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/EditMode/index.js

    class EditMode {
      #editDenotation
      #editBlock
      #editRelation
      #state
      #annotationModel
      #selectionModel
      #inlineOptions

      /**
       *
       * @param {import('../../../HTMLInlineOptions').HTMLInlineOption} inlineOptions
       */
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationModel,
        selectionModel,
        spanConfig,
        commander,
        controlViewModel,
        inlineOptions,
        functionAvailability,
        mousePoint
      ) {
        this.#editDenotation = new EditDenotation(
          editorHTMLElement,
          eventEmitter,
          annotationModel,
          selectionModel,
          commander,
          controlViewModel,
          spanConfig,
          inlineOptions.autocompletionWs,
          mousePoint
        )

        this.#editBlock = new EditBlock(
          editorHTMLElement,
          eventEmitter,
          annotationModel,
          selectionModel,
          spanConfig,
          commander,
          controlViewModel,
          inlineOptions.autocompletionWs,
          mousePoint
        )

        this.#editRelation = new EditRelation(
          editorHTMLElement,
          eventEmitter,
          annotationModel,
          selectionModel,
          commander,
          inlineOptions.autocompletionWs,
          controlViewModel,
          mousePoint
        )

        new ModeReactor(
          editorHTMLElement,
          eventEmitter,
          annotationModel,
          () => this.cancelSelect(),
          this.#editDenotation,
          this.#editBlock,
          this.#editRelation
        )

        this.#state = new StateMachine(
          annotationModel.relation,
          eventEmitter,
          functionAvailability
        )

        this.#annotationModel = annotationModel
        this.#selectionModel = selectionModel
        this.#inlineOptions = inlineOptions

        eventEmitter
          .on('textae-event.editor.relation.click', (event, relation) =>
            this.currentEdit.relationClicked(event, relation)
          )
          .on('textae-event.editor.relation-bollard.click', (event, entity) =>
            this.currentEdit.relationBollardClicked(entity)
          )
      }

      toViewMode() {
        this.#state.toViewMode(this.#state.nextShowRelation)
      }

      toTermMode() {
        this.#state.toTermMode(this.#state.nextShowRelation)
      }

      toBlockMode() {
        this.#state.toBlockMode(this.#state.nextShowRelation)
      }

      toRelationMode() {
        this.#state.toRelationMode()
      }

      toggleSimpleMode() {
        this.#state.toggleSimpleMode()
      }

      changeModeByShortcut() {
        this.#state.changeModeByShortcut()
      }

      get isEditDenotation() {
        return this.#state.currentState === MODE.EDIT_DENOTATION
      }

      /**
       * For an initiation transition on an annotations data loaded.
       */
      reset() {
        if (this.#inlineOptions.isTermEditMode) {
          this.#state.toTermMode(this.#annotationModel.relation.some)
          return
        }

        if (this.#inlineOptions.isBlockEditMode) {
          this.#state.toBlockMode(this.#annotationModel.relation.some)
          return
        }

        if (this.#inlineOptions.isRelationEditMode) {
          this.#state.toRelationMode()
          return
        }

        this.#state.toViewMode(this.#annotationModel.relation.some)
      }

      cancelSelect() {
        // Close all pallets.
        this.#editDenotation.pallet.hide()
        this.#editBlock.pallet.hide()
        this.#editRelation.pallet.hide()

        this.#selectionModel.removeAll()
      }

      get isTypeValuesPalletShown() {
        return (
          this.#editDenotation.pallet.visibly ||
          this.#editBlock.pallet.visibly ||
          this.#editRelation.pallet.visibly
        )
      }

      selectLeftAttributeTab() {
        this.currentEdit.pallet.selectLeftAttributeTab()
      }

      selectRightAttributeTab() {
        this.currentEdit.pallet.selectRightAttributeTab()
      }

      get currentEdit() {
        switch (this.#state.currentState) {
          case MODE.EDIT_DENOTATION:
            return this.#editDenotation
          case MODE.EDIT_BLOCK:
            return this.#editBlock
          case MODE.EDIT_RELATION:
            return this.#editRelation
          default:
            return {
              showPallet() {},
              selectLeftAttributeTab() {},
              selectRightAttributeTab() {},
              editProperties() {},
              manipulateAttribute() {},
              relationClicked() {},
              relationBollardClicked(entity) {
                entity.focus()
              },
              applyTextSelection() {}
            }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/Horizontal.js

    class Horizontal {
      constructor(editorHTMLElement, selectionModel) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
      }

      left(shiftKey) {
        const nextSpan = this._searchLeft('.textae-editor__span')
        if (nextSpan) {
          if (shiftKey) {
            this._selectionModel.add('span', [nextSpan.id])
          } else {
            this._selectionModel.selectSpan(nextSpan.id)
          }
          return
        }

        const nextEntity = this._searchLeft(
          '.textae-editor__grid .textae-editor__signboard'
        )
        if (nextEntity) {
          if (shiftKey) {
            this._selectionModel.add('entity', [nextEntity.dataset.id])
          } else {
            this._selectionModel.selectEntity(nextEntity.dataset.id)
          }
        }
      }

      right(shiftKey) {
        const nextSpan = this._searchRight('.textae-editor__span')
        if (nextSpan) {
          if (shiftKey) {
            this._selectionModel.add('span', [nextSpan.id])
          } else {
            this._selectionModel.selectSpan(nextSpan.id)
          }
          return
        }

        const nextEntity = this._searchRight(
          '.textae-editor__grid .textae-editor__signboard'
        )
        if (nextEntity) {
          if (shiftKey) {
            this._selectionModel.add('entity', [nextEntity.dataset.id])
          } else {
            this._selectionModel.selectEntity(nextEntity.dataset.id)
          }
        }
      }

      _searchLeft(selector) {
        const elements = this._editorHTMLElement.querySelectorAll(selector)
        const firstSelectedIndex = [...elements].findIndex(
          (el) =>
            el.classList.contains('ui-selected') ||
            el.classList.contains('textae-editor__signboard--selected')
        )

        if (firstSelectedIndex > 0) {
          return elements[firstSelectedIndex - 1]
        }
      }

      _searchRight(selector) {
        const elements = this._editorHTMLElement.querySelectorAll(selector)
        const lastSelectedIndex = [...elements]
          .reverse()
          .findIndex(
            (el) =>
              el.classList.contains('ui-selected') ||
              el.classList.contains('textae-editor__signboard--selected')
          )

        if (elements.length - lastSelectedIndex > 0) {
          return elements[elements.length - lastSelectedIndex]
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/Vertical.js

    class Vertical {
      constructor(editorHTMLElement, selectionModel) {
        this._editorHTMLElement = editorHTMLElement
        this._selectionModel = selectionModel
      }

      up() {
        // When one span is selected.
        if (this._selectionModel.span.single) {
          const grid = this._selectionModel.span.single.gridElement
          const entity = grid.querySelector('.textae-editor__signboard')
          this._selectionModel.selectEntity(entity.dataset.id)
        }
      }

      down() {
        const selectedEntityHtmlelement = this._editorHTMLElement.querySelector(
          '.textae-editor__signboard--selected'
        )

        if (selectedEntityHtmlelement) {
          const spanId = selectedEntityHtmlelement
            .closest('.textae-editor__grid')
            .id.substring(1)

          this._selectionModel.selectSpan(spanId)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/debounce300.js

    /* harmony default export */ function debounce300(func) {
      return debounce_default()(func, 300)
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/bindChangeLockConfig.js

    /* harmony default export */ function bindChangeLockConfig(
      content,
      typeDefinition
    ) {
      delegate_default()(
        content,
        '.textae-editor__setting-dialog__lock-config-text',
        'change',
        debounce300((e) => {
          if (e.target.checked) {
            typeDefinition.lockEdit()
          } else {
            typeDefinition.unlockEdit()
          }
        })
      )
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/redrawAllEditor.js

    // Redraw all editors in tha windows.
    function redrawAllEditor() {
      const event = new Event('resize')
      window.dispatchEvent(event)
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/bindChangeLineHeight.js

    /* harmony default export */ function bindChangeLineHeight(
      content,
      textBox
    ) {
      delegate_default()(
        content,
        '.textae-editor__setting-dialog__line-height-text',
        'change',
        debounce300((e) => {
          textBox.lineHeight = e.target.value
          redrawAllEditor()
        })
      )
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/bindChangeTypeGap.js

    /* harmony default export */ function bindChangeTypeGap(
      content,
      typeGap,
      textBox
    ) {
      delegate_default()(
        content,
        '.textae-editor__setting-dialog__type-gap-text',
        'change',
        debounce300((e) => {
          typeGap.value = Number(e.target.value)
          content.querySelector(
            '.textae-editor__setting-dialog__line-height-text'
          ).value = textBox.lineHeight
        })
      )
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/reflectImmediately/index.js

    /* harmony default export */ function reflectImmediately(
      content,
      typeGap,
      typeDefinition,
      textBox
    ) {
      bindChangeTypeGap(content, typeGap, textBox)
      bindChangeLineHeight(content, textBox)
      bindChangeLockConfig(content, typeDefinition)
    } // CONCATENATED MODULE: ./package.json

    const package_namespaceObject = { i8: '12.12.1' } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/template.js
    function template_template(context) {
      const {
        typeGap,
        typeGapDisabled,
        lineHeight,
        typeDefinitionLocked,
        version
      } = context

      return anemone`
<div class="textae-editor__setting-dialog__container">
  <div class="textae-editor__setting-dialog__row">
    <label>Type Gap</label>
    <input
      type="number"
      class="textae-editor__setting-dialog__type-gap-text"
      step="1"
      min="0"
      max="5"
      value="${typeGap}" ${typeGapDisabled ? `disabled="disabled"` : ''}>
  </div>
  <div class="textae-editor__setting-dialog__row">
    <label>Line Height(px)</label>
    <input
      type="number" class="textae-editor__setting-dialog__line-height-text"
      step="1"
      min="50"
      max="500"
      value="${lineHeight}">
  </div>
  <div class="textae-editor__setting-dialog__row">
    <label>
      <input
        type="checkbox"
        class="textae-editor__setting-dialog__lock-config-text"
        ${typeDefinitionLocked ? `checked="checked"` : ''}>
      Lock Edit Config
    </label>
  </div>
  <div class="textae-editor__setting-dialog__row">
    <label>Version ${version}</label>
  </div>
</div>
`
    } // CONCATENATED MODULE: ./src/lib/component/SettingDialog/index.js

    class SettingDialog extends Dialog {
      constructor(typeDefinition, typeGap, textBox) {
        const contentHtml = template_template({
          typeGapDisabled: !typeGap.show,
          typeGap: typeGap.value,
          lineHeight: textBox.lineHeight,
          typeDefinitionLocked: typeDefinition.isLock,
          version: package_namespaceObject.i8
        })

        super('Setting', contentHtml)

        // Reflects configuration changes in real time.
        reflectImmediately(super.el, typeGap, typeDefinition, textBox)

        // Observe enter key press
        delegate_default()(super.el, `.textae-editor__dialog`, 'keyup', (e) => {
          if (e.keyCode === 13) {
            super.close()
          }
        })
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Presenter/index.js

    class Presenter {
      #editorHTMLElement
      #eventEmitter
      #commander
      #selectionModel
      #annotationModel
      #controlViewModel
      #spanConfig
      #clipBoard
      #editMode
      #horizontal
      #vertical
      #isActive

      /**
       *
       * @param {import('../../HTMLInlineOptions').HTMLInlineOption} inlineOptions
       */
      constructor(
        editorHTMLElement,
        eventEmitter,
        annotationModel,
        selectionModel,
        commander,
        spanConfig,
        clipBoard,
        controlViewModel,
        inlineOptions,
        functionAvailability,
        mousePoint
      ) {
        const editMode = new EditMode(
          editorHTMLElement,
          eventEmitter,
          annotationModel,
          selectionModel,
          spanConfig,
          commander,
          controlViewModel,
          inlineOptions,
          functionAvailability,
          mousePoint
        )

        eventEmitter
          .on(
            'textae-event.annotation-data.all.change',
            (_, hasMultiTracks) => {
              if (inlineOptions.isEditMode && hasMultiTracks) {
                alertify_default().success(
                  'track annotations have been merged to root annotations.'
                )
              }

              editMode.reset()
            }
          )
          .on('textae-event.edit-mode.transition', (mode) => {
            switch (mode) {
              case MODE.VIEW:
                annotationModel.entity.clarifyLabelOfAll()
                break
              default:
                annotationModel.entity.declarifyLabelOfAll()
            }
          })

        this.#editorHTMLElement = editorHTMLElement
        this.#eventEmitter = eventEmitter
        this.#commander = commander
        this.#selectionModel = selectionModel
        this.#annotationModel = annotationModel
        this.#controlViewModel = controlViewModel
        this.#spanConfig = spanConfig
        this.#clipBoard = clipBoard
        this.#editMode = editMode
        this.#horizontal = new Horizontal(editorHTMLElement, selectionModel)
        this.#vertical = new Vertical(editorHTMLElement, selectionModel)
        this.#isActive = false

        forwardMethods(this, () => this.#editMode, [
          'toViewMode',
          'toTermMode',
          'toBlockMode',
          'toRelationMode',
          'toggleSimpleMode',
          'changeModeByShortcut'
        ])
        forwardMethods(this, () => this.#editMode.currentEdit, [
          'createSpan',
          'expandSpan',
          'shrinkSpan',
          'showPallet',
          'selectLeftAttributeTab',
          'selectRightAttributeTab',
          'editProperties',
          'manipulateAttribute'
        ])
        forwardMethods(this, () => this.#clipBoard, [
          'copyEntitiesToLocalClipboard',
          'copyEntitiesToSystemClipboard',
          'cutEntitiesToLocalClipboard',
          'cutEntitiesToSystemClipboard',
          'pasteEntitiesFromLocalClipboard',
          'pasteEntitiesFromSystemClipboard'
        ])
        forwardMethods(this, () => this.#controlViewModel, ['toggleButton'])
      }

      removeSelectedElements() {
        const commands = this.#commander.factory.removeSelectedComand()

        // Select the next element before clear selection.
        this.#horizontal.right(null)

        this.#commander.invoke(commands)
      }

      createEntity() {
        const command =
          this.#commander.factory.createDefaultTypeEntityToSelectedSpansCommand(
            this.#annotationModel.typeDefinition.denotation.defaultType
          )

        if (!command.isEmpty) {
          this.#commander.invoke(command)
        }
      }

      replicate() {
        const isDelimiterFunc = getIsDelimiterFunc(
          this.#controlViewModel,
          this.#spanConfig
        )

        if (this.#selectionModel.span.single) {
          this.#commander.invoke(
            this.#commander.factory.replicateSpanCommand(
              this.#selectionModel.span.single,
              this.#selectionModel.span.single.entities.map(
                (e) => e.typeValues
              ),
              isDelimiterFunc
            )
          )
        } else {
          alertify_default().warning(
            'You can replicate span annotation when there is only span selected.'
          )
        }
      }

      cancelSelect() {
        this.#editMode.cancelSelect()
        // Focus the editor for ESC key
        this.#editorHTMLElement.focus()
      }

      showSettingDialog() {
        new SettingDialog(
          this.#annotationModel.typeDefinition,
          this.#annotationModel.typeGap,
          this.#annotationModel.textBox
        ).open()
      }

      get isActive() {
        return this.#isActive
      }

      activate() {
        this.#editorHTMLElement.classList.add('textae-editor--active')
        this.#isActive = true
      }

      deactivate() {
        this.#editorHTMLElement.classList.remove('textae-editor--active')
        this.#eventEmitter.emit('textae-event.editor.unselect')
        this.#isActive = false
      }

      selectLeft(shiftKey) {
        if (this.#editMode.isTypeValuesPalletShown) {
          this.selectLeftAttributeTab()
        } else {
          this.#horizontal.left(shiftKey)
        }
      }

      selectRight(shiftKey) {
        if (this.#editMode.isTypeValuesPalletShown) {
          this.selectRightAttributeTab()
        } else {
          this.#horizontal.right(shiftKey)
        }
      }

      selectUp() {
        if (this.#editMode.isEditDenotation) {
          this.#vertical.up()
        }
      }

      selectDown() {
        if (this.#editMode.isEditDenotation) {
          this.#vertical.down()
        }
      }

      applyTextSelection() {
        if (this.#isActive) {
          this.#editMode.currentEdit.applyTextSelection()
        }
      }
    }

    // EXTERNAL MODULE: ./node_modules/dropzone/dist/dropzone.js
    var dropzone = __webpack_require__(2025)
    var dropzone_default = /*#__PURE__*/ __webpack_require__.n(dropzone) // CONCATENATED MODULE: ./src/lib/isJSON.js
    /* harmony default export */ function isJSON(arg) {
      if (typeof arg !== 'string') {
        return false
      }

      try {
        JSON.parse(arg)
      } catch (e) {
        return false
      }

      return true
    } // CONCATENATED MODULE: ./src/lib/component/LoadDialog/maximizeOverlay.js

    /* harmony default export */ function maximizeOverlay(overlayDropzone) {
      const { element } = overlayDropzone
      element.classList.add(
        'textae-editor__load-dialog__overlay-dropzone--maximized'
      )
      element.style.zIndex = parseInt(element.style.zIndex) + 1
    } // CONCATENATED MODULE: ./src/lib/component/LoadDialog/revertMaximizeOverlay.js

    /* harmony default export */ function revertMaximizeOverlay(
      overlayDropzone,
      zIndexOfOverlayDropzone
    ) {
      overlayDropzone.element.classList.remove(
        'textae-editor__load-dialog__overlay-dropzone--maximized'
      )
      overlayDropzone.element.style.zIndex = zIndexOfOverlayDropzone
    } // CONCATENATED MODULE: ./node_modules/@codemirror/state/dist/index.js

    /**
The data structure for documents. @nonabstract
*/
    class Text {
      /**
    Get the line description around the given position.
    */
      lineAt(pos) {
        if (pos < 0 || pos > this.length)
          throw new RangeError(
            `Invalid position ${pos} in document of length ${this.length}`
          )
        return this.lineInner(pos, false, 1, 0)
      }
      /**
    Get the description for the given (1-based) line number.
    */
      line(n) {
        if (n < 1 || n > this.lines)
          throw new RangeError(
            `Invalid line number ${n} in ${this.lines}-line document`
          )
        return this.lineInner(n, true, 1, 0)
      }
      /**
    Replace a range of the text with the given content.
    */
      replace(from, to, text) {
        ;[from, to] = clip(this, from, to)
        let parts = []
        this.decompose(0, from, parts, 2 /* Open.To */)
        if (text.length)
          text.decompose(
            0,
            text.length,
            parts,
            1 /* Open.From */ | 2 /* Open.To */
          )
        this.decompose(to, this.length, parts, 1 /* Open.From */)
        return TextNode.from(parts, this.length - (to - from) + text.length)
      }
      /**
    Append another document to this one.
    */
      append(other) {
        return this.replace(this.length, this.length, other)
      }
      /**
    Retrieve the text between the given points.
    */
      slice(from, to = this.length) {
        ;[from, to] = clip(this, from, to)
        let parts = []
        this.decompose(from, to, parts, 0)
        return TextNode.from(parts, to - from)
      }
      /**
    Test whether this text is equal to another instance.
    */
      eq(other) {
        if (other == this) return true
        if (other.length != this.length || other.lines != this.lines)
          return false
        let start = this.scanIdentical(other, 1),
          end = this.length - this.scanIdentical(other, -1)
        let a = new RawTextCursor(this),
          b = new RawTextCursor(other)
        for (let skip = start, pos = start; ; ) {
          a.next(skip)
          b.next(skip)
          skip = 0
          if (
            a.lineBreak != b.lineBreak ||
            a.done != b.done ||
            a.value != b.value
          )
            return false
          pos += a.value.length
          if (a.done || pos >= end) return true
        }
      }
      /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
      iter(dir = 1) {
        return new RawTextCursor(this, dir)
      }
      /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
      iterRange(from, to = this.length) {
        return new PartialTextCursor(this, from, to)
      }
      /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
      iterLines(from, to) {
        let inner
        if (from == null) {
          inner = this.iter()
        } else {
          if (to == null) to = this.lines + 1
          let start = this.line(from).from
          inner = this.iterRange(
            start,
            Math.max(
              start,
              to == this.lines + 1
                ? this.length
                : to <= 1
                  ? 0
                  : this.line(to - 1).to
            )
          )
        }
        return new LineCursor(inner)
      }
      /**
    Return the document as a string, using newline characters to
    separate lines.
    */
      toString() {
        return this.sliceString(0)
      }
      /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
      toJSON() {
        let lines = []
        this.flatten(lines)
        return lines
      }
      /**
    @internal
    */
      constructor() {}
      /**
    Create a `Text` instance for the given array of lines.
    */
      static of(text) {
        if (text.length == 0)
          throw new RangeError('A document must have at least one line')
        if (text.length == 1 && !text[0]) return Text.empty
        return text.length <= 32 /* Tree.Branch */
          ? new TextLeaf(text)
          : TextNode.from(TextLeaf.split(text, []))
      }
    }
    // Leaves store an array of line strings. There are always line breaks
    // between these strings. Leaves are limited in size and have to be
    // contained in TextNode instances for bigger documents.
    class TextLeaf extends Text {
      constructor(text, length = textLength(text)) {
        super()
        this.text = text
        this.length = length
      }
      get lines() {
        return this.text.length
      }
      get children() {
        return null
      }
      lineInner(target, isLine, line, offset) {
        for (let i = 0; ; i++) {
          let string = this.text[i],
            end = offset + string.length
          if ((isLine ? line : end) >= target)
            return new Line(offset, end, line, string)
          offset = end + 1
          line++
        }
      }
      decompose(from, to, target, open) {
        let text =
          from <= 0 && to >= this.length
            ? this
            : new TextLeaf(
                sliceText(this.text, from, to),
                Math.min(to, this.length) - Math.max(0, from)
              )
        if (open & 1 /* Open.From */) {
          let prev = target.pop()
          let joined = appendText(text.text, prev.text.slice(), 0, text.length)
          if (joined.length <= 32 /* Tree.Branch */) {
            target.push(new TextLeaf(joined, prev.length + text.length))
          } else {
            let mid = joined.length >> 1
            target.push(
              new TextLeaf(joined.slice(0, mid)),
              new TextLeaf(joined.slice(mid))
            )
          }
        } else {
          target.push(text)
        }
      }
      replace(from, to, text) {
        if (!(text instanceof TextLeaf)) return super.replace(from, to, text)
        ;[from, to] = clip(this, from, to)
        let lines = appendText(
          this.text,
          appendText(text.text, sliceText(this.text, 0, from)),
          to
        )
        let newLen = this.length + text.length - (to - from)
        if (lines.length <= 32 /* Tree.Branch */)
          return new TextLeaf(lines, newLen)
        return TextNode.from(TextLeaf.split(lines, []), newLen)
      }
      sliceString(from, to = this.length, lineSep = '\n') {
        ;[from, to] = clip(this, from, to)
        let result = ''
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
          let line = this.text[i],
            end = pos + line.length
          if (pos > from && i) result += lineSep
          if (from < end && to > pos)
            result += line.slice(Math.max(0, from - pos), to - pos)
          pos = end + 1
        }
        return result
      }
      flatten(target) {
        for (let line of this.text) target.push(line)
      }
      scanIdentical() {
        return 0
      }
      static split(text, target) {
        let part = [],
          len = -1
        for (let line of text) {
          part.push(line)
          len += line.length + 1
          if (part.length == 32 /* Tree.Branch */) {
            target.push(new TextLeaf(part, len))
            part = []
            len = -1
          }
        }
        if (len > -1) target.push(new TextLeaf(part, len))
        return target
      }
    }
    // Nodes provide the tree structure of the `Text` type. They store a
    // number of other nodes or leaves, taking care to balance themselves
    // on changes. There are implied line breaks _between_ the children of
    // a node (but not before the first or after the last child).
    class TextNode extends Text {
      constructor(children, length) {
        super()
        this.children = children
        this.length = length
        this.lines = 0
        for (let child of children) this.lines += child.lines
      }
      lineInner(target, isLine, line, offset) {
        for (let i = 0; ; i++) {
          let child = this.children[i],
            end = offset + child.length,
            endLine = line + child.lines - 1
          if ((isLine ? endLine : end) >= target)
            return child.lineInner(target, isLine, line, offset)
          offset = end + 1
          line = endLine + 1
        }
      }
      decompose(from, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
          let child = this.children[i],
            end = pos + child.length
          if (from <= end && to >= pos) {
            let childOpen =
              open &
              ((pos <= from ? 1 /* Open.From */ : 0) |
                (end >= to ? 2 /* Open.To */ : 0))
            if (pos >= from && end <= to && !childOpen) target.push(child)
            else child.decompose(from - pos, to - pos, target, childOpen)
          }
          pos = end + 1
        }
      }
      replace(from, to, text) {
        ;[from, to] = clip(this, from, to)
        if (text.lines < this.lines)
          for (let i = 0, pos = 0; i < this.children.length; i++) {
            let child = this.children[i],
              end = pos + child.length
            // Fast path: if the change only affects one child and the
            // child's size remains in the acceptable range, only update
            // that child
            if (from >= pos && to <= end) {
              let updated = child.replace(from - pos, to - pos, text)
              let totalLines = this.lines - child.lines + updated.lines
              if (
                updated.lines < totalLines >> (5 /* Tree.BranchShift */ - 1) &&
                updated.lines > totalLines >> (5 /* Tree.BranchShift */ + 1)
              ) {
                let copy = this.children.slice()
                copy[i] = updated
                return new TextNode(
                  copy,
                  this.length - (to - from) + text.length
                )
              }
              return super.replace(pos, end, updated)
            }
            pos = end + 1
          }
        return super.replace(from, to, text)
      }
      sliceString(from, to = this.length, lineSep = '\n') {
        ;[from, to] = clip(this, from, to)
        let result = ''
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
          let child = this.children[i],
            end = pos + child.length
          if (pos > from && i) result += lineSep
          if (from < end && to > pos)
            result += child.sliceString(from - pos, to - pos, lineSep)
          pos = end + 1
        }
        return result
      }
      flatten(target) {
        for (let child of this.children) child.flatten(target)
      }
      scanIdentical(other, dir) {
        if (!(other instanceof TextNode)) return 0
        let length = 0
        let [iA, iB, eA, eB] =
          dir > 0
            ? [0, 0, this.children.length, other.children.length]
            : [this.children.length - 1, other.children.length - 1, -1, -1]
        for (; ; iA += dir, iB += dir) {
          if (iA == eA || iB == eB) return length
          let chA = this.children[iA],
            chB = other.children[iB]
          if (chA != chB) return length + chA.scanIdentical(chB, dir)
          length += chA.length + 1
        }
      }
      static from(
        children,
        length = children.reduce((l, ch) => l + ch.length + 1, -1)
      ) {
        let lines = 0
        for (let ch of children) lines += ch.lines
        if (lines < 32 /* Tree.Branch */) {
          let flat = []
          for (let ch of children) ch.flatten(flat)
          return new TextLeaf(flat, length)
        }
        let chunk = Math.max(
            32 /* Tree.Branch */,
            lines >> 5 /* Tree.BranchShift */
          ),
          maxChunk = chunk << 1,
          minChunk = chunk >> 1
        let chunked = [],
          currentLines = 0,
          currentLen = -1,
          currentChunk = []
        function add(child) {
          let last
          if (child.lines > maxChunk && child instanceof TextNode) {
            for (let node of child.children) add(node)
          } else if (
            child.lines > minChunk &&
            (currentLines > minChunk || !currentLines)
          ) {
            flush()
            chunked.push(child)
          } else if (
            child instanceof TextLeaf &&
            currentLines &&
            (last = currentChunk[currentChunk.length - 1]) instanceof
              TextLeaf &&
            child.lines + last.lines <= 32 /* Tree.Branch */
          ) {
            currentLines += child.lines
            currentLen += child.length + 1
            currentChunk[currentChunk.length - 1] = new TextLeaf(
              last.text.concat(child.text),
              last.length + 1 + child.length
            )
          } else {
            if (currentLines + child.lines > chunk) flush()
            currentLines += child.lines
            currentLen += child.length + 1
            currentChunk.push(child)
          }
        }
        function flush() {
          if (currentLines == 0) return
          chunked.push(
            currentChunk.length == 1
              ? currentChunk[0]
              : TextNode.from(currentChunk, currentLen)
          )
          currentLen = -1
          currentLines = currentChunk.length = 0
        }
        for (let child of children) add(child)
        flush()
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length)
      }
    }
    Text.empty = /*@__PURE__*/ new TextLeaf([''], 0)
    function textLength(text) {
      let length = -1
      for (let line of text) length += line.length + 1
      return length
    }
    function appendText(text, target, from = 0, to = 1e9) {
      for (
        let pos = 0, i = 0, first = true;
        i < text.length && pos <= to;
        i++
      ) {
        let line = text[i],
          end = pos + line.length
        if (end >= from) {
          if (end > to) line = line.slice(0, to - pos)
          if (pos < from) line = line.slice(from - pos)
          if (first) {
            target[target.length - 1] += line
            first = false
          } else target.push(line)
        }
        pos = end + 1
      }
      return target
    }
    function sliceText(text, from, to) {
      return appendText(text, [''], from, to)
    }
    class RawTextCursor {
      constructor(text, dir = 1) {
        this.dir = dir
        this.done = false
        this.lineBreak = false
        this.value = ''
        this.nodes = [text]
        this.offsets = [
          dir > 0
            ? 1
            : (text instanceof TextLeaf
                ? text.text.length
                : text.children.length) << 1
        ]
      }
      nextInner(skip, dir) {
        this.done = this.lineBreak = false
        for (;;) {
          let last = this.nodes.length - 1
          let top = this.nodes[last],
            offsetValue = this.offsets[last],
            offset = offsetValue >> 1
          let size =
            top instanceof TextLeaf ? top.text.length : top.children.length
          if (offset == (dir > 0 ? size : 0)) {
            if (last == 0) {
              this.done = true
              this.value = ''
              return this
            }
            if (dir > 0) this.offsets[last - 1]++
            this.nodes.pop()
            this.offsets.pop()
          } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
            this.offsets[last] += dir
            if (skip == 0) {
              this.lineBreak = true
              this.value = '\n'
              return this
            }
            skip--
          } else if (top instanceof TextLeaf) {
            // Move to the next string
            let next = top.text[offset + (dir < 0 ? -1 : 0)]
            this.offsets[last] += dir
            if (next.length > Math.max(0, skip)) {
              this.value =
                skip == 0
                  ? next
                  : dir > 0
                    ? next.slice(skip)
                    : next.slice(0, next.length - skip)
              return this
            }
            skip -= next.length
          } else {
            let next = top.children[offset + (dir < 0 ? -1 : 0)]
            if (skip > next.length) {
              skip -= next.length
              this.offsets[last] += dir
            } else {
              if (dir < 0) this.offsets[last]--
              this.nodes.push(next)
              this.offsets.push(
                dir > 0
                  ? 1
                  : (next instanceof TextLeaf
                      ? next.text.length
                      : next.children.length) << 1
              )
            }
          }
        }
      }
      next(skip = 0) {
        if (skip < 0) {
          this.nextInner(-skip, -this.dir)
          skip = this.value.length
        }
        return this.nextInner(skip, this.dir)
      }
    }
    class PartialTextCursor {
      constructor(text, start, end) {
        this.value = ''
        this.done = false
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1)
        this.pos = start > end ? text.length : 0
        this.from = Math.min(start, end)
        this.to = Math.max(start, end)
      }
      nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
          this.value = ''
          this.done = true
          return this
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos)
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos
        if (skip > limit) skip = limit
        limit -= skip
        let { value } = this.cursor.next(skip)
        this.pos += (value.length + skip) * dir
        this.value =
          value.length <= limit
            ? value
            : dir < 0
              ? value.slice(value.length - limit)
              : value.slice(0, limit)
        this.done = !this.value
        return this
      }
      next(skip = 0) {
        if (skip < 0) skip = Math.max(skip, this.from - this.pos)
        else if (skip > 0) skip = Math.min(skip, this.to - this.pos)
        return this.nextInner(skip, this.cursor.dir)
      }
      get lineBreak() {
        return this.cursor.lineBreak && this.value != ''
      }
    }
    class LineCursor {
      constructor(inner) {
        this.inner = inner
        this.afterBreak = true
        this.value = ''
        this.done = false
      }
      next(skip = 0) {
        let { done, lineBreak, value } = this.inner.next(skip)
        if (done && this.afterBreak) {
          this.value = ''
          this.afterBreak = false
        } else if (done) {
          this.done = true
          this.value = ''
        } else if (lineBreak) {
          if (this.afterBreak) {
            this.value = ''
          } else {
            this.afterBreak = true
            this.next()
          }
        } else {
          this.value = value
          this.afterBreak = false
        }
        return this
      }
      get lineBreak() {
        return false
      }
    }
    if (typeof Symbol != 'undefined') {
      Text.prototype[Symbol.iterator] = function () {
        return this.iter()
      }
      RawTextCursor.prototype[Symbol.iterator] =
        PartialTextCursor.prototype[Symbol.iterator] =
        LineCursor.prototype[Symbol.iterator] =
          function () {
            return this
          }
    }
    /**
This type describes a line in the document. It is created
on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).
*/
    class Line {
      /**
    @internal
    */
      constructor(
        /**
    The position of the start of the line.
    */
        from,
        /**
    The position at the end of the line (_before_ the line break,
    or at the end of document for the last line).
    */
        to,
        /**
    This line's line number (1-based).
    */
        number,
        /**
    The line's content.
    */
        text
      ) {
        this.from = from
        this.to = to
        this.number = number
        this.text = text
      }
      /**
    The length of the line (not including any line break after it).
    */
      get length() {
        return this.to - this.from
      }
    }
    function clip(text, from, to) {
      from = Math.max(0, Math.min(text.length, from))
      return [from, Math.max(from, Math.min(text.length, to))]
    }

    // Compressed representation of the Grapheme_Cluster_Break=Extend
    // information from
    // http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
    // Each pair of elements represents a range, as an offet from the
    // previous range and a length. Numbers are in base-36, with the empty
    // string being a shorthand for 1.
    let extend =
      /*@__PURE__*/ 'lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o'
        .split(',')
        .map((s) => (s ? parseInt(s, 36) : 1))
    // Convert offsets into absolute values
    for (let i = 1; i < extend.length; i++) extend[i] += extend[i - 1]
    function isExtendingChar(code) {
      for (let i = 1; i < extend.length; i += 2)
        if (extend[i] > code) return extend[i - 1] <= code
      return false
    }
    function isRegionalIndicator(code) {
      return code >= 0x1f1e6 && code <= 0x1f1ff
    }
    const ZWJ = 0x200d
    /**
Returns a next grapheme cluster break _after_ (not equal to)
`pos`, if `forward` is true, or before otherwise. Returns `pos`
itself if no further cluster break is available in the string.
Moves across surrogate pairs, extending characters (when
`includeExtending` is true), characters joined with zero-width
joiners, and flag emoji.
*/
    function findClusterBreak(
      str,
      pos,
      forward = true,
      includeExtending = true
    ) {
      return (forward ? nextClusterBreak : prevClusterBreak)(
        str,
        pos,
        includeExtending
      )
    }
    function nextClusterBreak(str, pos, includeExtending) {
      if (pos == str.length) return pos
      // If pos is in the middle of a surrogate pair, move to its start
      if (
        pos &&
        surrogateLow(str.charCodeAt(pos)) &&
        surrogateHigh(str.charCodeAt(pos - 1))
      )
        pos--
      let prev = codePointAt(str, pos)
      pos += codePointSize(prev)
      while (pos < str.length) {
        let next = codePointAt(str, pos)
        if (
          prev == ZWJ ||
          next == ZWJ ||
          (includeExtending && isExtendingChar(next))
        ) {
          pos += codePointSize(next)
          prev = next
        } else if (isRegionalIndicator(next)) {
          let countBefore = 0,
            i = pos - 2
          while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
            countBefore++
            i -= 2
          }
          if (countBefore % 2 == 0) break
          else pos += 2
        } else {
          break
        }
      }
      return pos
    }
    function prevClusterBreak(str, pos, includeExtending) {
      while (pos > 0) {
        let found = nextClusterBreak(str, pos - 2, includeExtending)
        if (found < pos) return found
        pos--
      }
      return 0
    }
    function surrogateLow(ch) {
      return ch >= 0xdc00 && ch < 0xe000
    }
    function surrogateHigh(ch) {
      return ch >= 0xd800 && ch < 0xdc00
    }
    /**
Find the code point at the given position in a string (like the
[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
string method).
*/
    function codePointAt(str, pos) {
      let code0 = str.charCodeAt(pos)
      if (!surrogateHigh(code0) || pos + 1 == str.length) return code0
      let code1 = str.charCodeAt(pos + 1)
      if (!surrogateLow(code1)) return code0
      return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000
    }
    /**
Given a Unicode codepoint, return the JavaScript string that
respresents it (like
[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
*/
    function fromCodePoint(code) {
      if (code <= 0xffff) return String.fromCharCode(code)
      code -= 0x10000
      return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00)
    }
    /**
The amount of positions a character takes up a JavaScript string.
*/
    function codePointSize(code) {
      return code < 0x10000 ? 1 : 2
    }

    const DefaultSplit = /\r\n?|\n/
    /**
Distinguishes different ways in which positions can be mapped.
*/
    var MapMode = /*@__PURE__*/ (function (MapMode) {
      /**
    Map a position to a valid new position, even when its context
    was deleted.
    */
      MapMode[(MapMode['Simple'] = 0)] = 'Simple'
      /**
    Return null if deletion happens across the position.
    */
      MapMode[(MapMode['TrackDel'] = 1)] = 'TrackDel'
      /**
    Return null if the character _before_ the position is deleted.
    */
      MapMode[(MapMode['TrackBefore'] = 2)] = 'TrackBefore'
      /**
    Return null if the character _after_ the position is deleted.
    */
      MapMode[(MapMode['TrackAfter'] = 3)] = 'TrackAfter'
      return MapMode
    })(MapMode || (MapMode = {}))
    /**
A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
that doesn't store the inserted text. As such, it can't be
applied, but is cheaper to store and manipulate.
*/
    class ChangeDesc {
      // Sections are encoded as pairs of integers. The first is the
      // length in the current document, and the second is -1 for
      // unaffected sections, and the length of the replacement content
      // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
      // 0), and a replacement two positive numbers.
      /**
    @internal
    */
      constructor(
        /**
    @internal
    */
        sections
      ) {
        this.sections = sections
      }
      /**
    The length of the document before the change.
    */
      get length() {
        let result = 0
        for (let i = 0; i < this.sections.length; i += 2)
          result += this.sections[i]
        return result
      }
      /**
    The length of the document after the change.
    */
      get newLength() {
        let result = 0
        for (let i = 0; i < this.sections.length; i += 2) {
          let ins = this.sections[i + 1]
          result += ins < 0 ? this.sections[i] : ins
        }
        return result
      }
      /**
    False when there are actual changes in this set.
    */
      get empty() {
        return (
          this.sections.length == 0 ||
          (this.sections.length == 2 && this.sections[1] < 0)
        )
      }
      /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
      iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
          let len = this.sections[i++],
            ins = this.sections[i++]
          if (ins < 0) {
            f(posA, posB, len)
            posB += len
          } else {
            posB += ins
          }
          posA += len
        }
      }
      /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
      iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual)
      }
      /**
    Get a description of the inverted form of these changes.
    */
      get invertedDesc() {
        let sections = []
        for (let i = 0; i < this.sections.length; ) {
          let len = this.sections[i++],
            ins = this.sections[i++]
          if (ins < 0) sections.push(len, ins)
          else sections.push(ins, len)
        }
        return new ChangeDesc(sections)
      }
      /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
      composeDesc(other) {
        return this.empty
          ? other
          : other.empty
            ? this
            : composeSets(this, other)
      }
      /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `other` happened before the ones in `this`.
    */
      mapDesc(other, before = false) {
        return other.empty ? this : mapSet(this, other, before)
      }
      mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0,
          posB = 0
        for (let i = 0; i < this.sections.length; ) {
          let len = this.sections[i++],
            ins = this.sections[i++],
            endA = posA + len
          if (ins < 0) {
            if (endA > pos) return posB + (pos - posA)
            posB += len
          } else {
            if (
              mode != MapMode.Simple &&
              endA >= pos &&
              ((mode == MapMode.TrackDel && posA < pos && endA > pos) ||
                (mode == MapMode.TrackBefore && posA < pos) ||
                (mode == MapMode.TrackAfter && endA > pos))
            )
              return null
            if (endA > pos || (endA == pos && assoc < 0 && !len))
              return pos == posA || assoc < 0 ? posB : posB + ins
            posB += ins
          }
          posA = endA
        }
        if (pos > posA)
          throw new RangeError(
            `Position ${pos} is out of range for changeset of length ${posA}`
          )
        return posB
      }
      /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
      touchesRange(from, to = from) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
          let len = this.sections[i++],
            ins = this.sections[i++],
            end = pos + len
          if (ins >= 0 && pos <= to && end >= from)
            return pos < from && end > to ? 'cover' : true
          pos = end
        }
        return false
      }
      /**
    @internal
    */
      toString() {
        let result = ''
        for (let i = 0; i < this.sections.length; ) {
          let len = this.sections[i++],
            ins = this.sections[i++]
          result += (result ? ' ' : '') + len + (ins >= 0 ? ':' + ins : '')
        }
        return result
      }
      /**
    Serialize this change desc to a JSON-representable value.
    */
      toJSON() {
        return this.sections
      }
      /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
      static fromJSON(json) {
        if (
          !Array.isArray(json) ||
          json.length % 2 ||
          json.some((a) => typeof a != 'number')
        )
          throw new RangeError('Invalid JSON representation of ChangeDesc')
        return new ChangeDesc(json)
      }
      /**
    @internal
    */
      static create(sections) {
        return new ChangeDesc(sections)
      }
    }
    /**
A change set represents a group of modifications to a document. It
stores the document length, and can only be applied to documents
with exactly that length.
*/
    class ChangeSet extends ChangeDesc {
      constructor(
        sections,
        /**
    @internal
    */
        inserted
      ) {
        super(sections)
        this.inserted = inserted
      }
      /**
    Apply the changes to a document, returning the modified
    document.
    */
      apply(doc) {
        if (this.length != doc.length)
          throw new RangeError(
            'Applying change set to a document with the wrong length'
          )
        iterChanges(
          this,
          (fromA, toA, fromB, _toB, text) =>
            (doc = doc.replace(fromB, fromB + (toA - fromA), text)),
          false
        )
        return doc
      }
      mapDesc(other, before = false) {
        return mapSet(this, other, before, true)
      }
      /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
      invert(doc) {
        let sections = this.sections.slice(),
          inserted = []
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
          let len = sections[i],
            ins = sections[i + 1]
          if (ins >= 0) {
            sections[i] = ins
            sections[i + 1] = len
            let index = i >> 1
            while (inserted.length < index) inserted.push(Text.empty)
            inserted.push(len ? doc.slice(pos, pos + len) : Text.empty)
          }
          pos += len
        }
        return new ChangeSet(sections, inserted)
      }
      /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA` → `docB` and `other` represents `docB` → `docC`, the
    returned value will represent the change `docA` → `docC`.
    */
      compose(other) {
        return this.empty
          ? other
          : other.empty
            ? this
            : composeSets(this, other, true)
      }
      /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
      map(other, before = false) {
        return other.empty ? this : mapSet(this, other, before, true)
      }
      /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
      iterChanges(f, individual = false) {
        iterChanges(this, f, individual)
      }
      /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
      get desc() {
        return ChangeDesc.create(this.sections)
      }
      /**
    @internal
    */
      filter(ranges) {
        let resultSections = [],
          resultInserted = [],
          filteredSections = []
        let iter = new SectionIter(this)
        done: for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++]
          while (pos < next || (pos == next && iter.len == 0)) {
            if (iter.done) break done
            let len = Math.min(iter.len, next - pos)
            addSection(filteredSections, len, -1)
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0
            addSection(resultSections, len, ins)
            if (ins > 0) addInsert(resultInserted, resultSections, iter.text)
            iter.forward(len)
            pos += len
          }
          let end = ranges[i++]
          while (pos < end) {
            if (iter.done) break done
            let len = Math.min(iter.len, end - pos)
            addSection(resultSections, len, -1)
            addSection(
              filteredSections,
              len,
              iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0
            )
            iter.forward(len)
            pos += len
          }
        }
        return {
          changes: new ChangeSet(resultSections, resultInserted),
          filtered: ChangeDesc.create(filteredSections)
        }
      }
      /**
    Serialize this change set to a JSON-representable value.
    */
      toJSON() {
        let parts = []
        for (let i = 0; i < this.sections.length; i += 2) {
          let len = this.sections[i],
            ins = this.sections[i + 1]
          if (ins < 0) parts.push(len)
          else if (ins == 0) parts.push([len])
          else parts.push([len].concat(this.inserted[i >> 1].toJSON()))
        }
        return parts
      }
      /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
      static of(changes, length, lineSep) {
        let sections = [],
          inserted = [],
          pos = 0
        let total = null
        function flush(force = false) {
          if (!force && !sections.length) return
          if (pos < length) addSection(sections, length - pos, -1)
          let set = new ChangeSet(sections, inserted)
          total = total ? total.compose(set.map(total)) : set
          sections = []
          inserted = []
          pos = 0
        }
        function process(spec) {
          if (Array.isArray(spec)) {
            for (let sub of spec) process(sub)
          } else if (spec instanceof ChangeSet) {
            if (spec.length != length)
              throw new RangeError(
                `Mismatched change set length (got ${spec.length}, expected ${length})`
              )
            flush()
            total = total ? total.compose(spec.map(total)) : spec
          } else {
            let { from, to = from, insert } = spec
            if (from > to || from < 0 || to > length)
              throw new RangeError(
                `Invalid change range ${from} to ${to} (in doc of length ${length})`
              )
            let insText = !insert
              ? Text.empty
              : typeof insert == 'string'
                ? Text.of(insert.split(lineSep || DefaultSplit))
                : insert
            let insLen = insText.length
            if (from == to && insLen == 0) return
            if (from < pos) flush()
            if (from > pos) addSection(sections, from - pos, -1)
            addSection(sections, to - from, insLen)
            addInsert(inserted, sections, insText)
            pos = to
          }
        }
        process(changes)
        flush(!total)
        return total
      }
      /**
    Create an empty changeset of the given length.
    */
      static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], [])
      }
      /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
      static fromJSON(json) {
        if (!Array.isArray(json))
          throw new RangeError('Invalid JSON representation of ChangeSet')
        let sections = [],
          inserted = []
        for (let i = 0; i < json.length; i++) {
          let part = json[i]
          if (typeof part == 'number') {
            sections.push(part, -1)
          } else if (
            !Array.isArray(part) ||
            typeof part[0] != 'number' ||
            part.some((e, i) => i && typeof e != 'string')
          ) {
            throw new RangeError('Invalid JSON representation of ChangeSet')
          } else if (part.length == 1) {
            sections.push(part[0], 0)
          } else {
            while (inserted.length < i) inserted.push(Text.empty)
            inserted[i] = Text.of(part.slice(1))
            sections.push(part[0], inserted[i].length)
          }
        }
        return new ChangeSet(sections, inserted)
      }
      /**
    @internal
    */
      static createSet(sections, inserted) {
        return new ChangeSet(sections, inserted)
      }
    }
    function addSection(sections, len, ins, forceJoin = false) {
      if (len == 0 && ins <= 0) return
      let last = sections.length - 2
      if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len
      else if (len == 0 && sections[last] == 0) sections[last + 1] += ins
      else if (forceJoin) {
        sections[last] += len
        sections[last + 1] += ins
      } else sections.push(len, ins)
    }
    function addInsert(values, sections, value) {
      if (value.length == 0) return
      let index = (sections.length - 2) >> 1
      if (index < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value)
      } else {
        while (values.length < index) values.push(Text.empty)
        values.push(value)
      }
    }
    function iterChanges(desc, f, individual) {
      let inserted = desc.inserted
      for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
        let len = desc.sections[i++],
          ins = desc.sections[i++]
        if (ins < 0) {
          posA += len
          posB += len
        } else {
          let endA = posA,
            endB = posB,
            text = Text.empty
          for (;;) {
            endA += len
            endB += ins
            if (ins && inserted) text = text.append(inserted[(i - 2) >> 1])
            if (
              individual ||
              i == desc.sections.length ||
              desc.sections[i + 1] < 0
            )
              break
            len = desc.sections[i++]
            ins = desc.sections[i++]
          }
          f(posA, endA, posB, endB, text)
          posA = endA
          posB = endB
        }
      }
    }
    function mapSet(setA, setB, before, mkSet = false) {
      // Produce a copy of setA that applies to the document after setB
      // has been applied (assuming both start at the same document).
      let sections = [],
        insert = mkSet ? [] : null
      let a = new SectionIter(setA),
        b = new SectionIter(setB)
      // Iterate over both sets in parallel. inserted tracks, for changes
      // in A that have to be processed piece-by-piece, whether their
      // content has been inserted already, and refers to the section
      // index.
      for (let inserted = -1; ; ) {
        if (a.ins == -1 && b.ins == -1) {
          // Move across ranges skipped by both sets.
          let len = Math.min(a.len, b.len)
          addSection(sections, len, -1)
          a.forward(len)
          b.forward(len)
        } else if (
          b.ins >= 0 &&
          (a.ins < 0 ||
            inserted == a.i ||
            (a.off == 0 && (b.len < a.len || (b.len == a.len && !before))))
        ) {
          // If there's a change in B that comes before the next change in
          // A (ordered by start pos, then len, then before flag), skip
          // that (and process any changes in A it covers).
          let len = b.len
          addSection(sections, b.ins, -1)
          while (len) {
            let piece = Math.min(a.len, len)
            if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
              addSection(sections, 0, a.ins)
              if (insert) addInsert(insert, sections, a.text)
              inserted = a.i
            }
            a.forward(piece)
            len -= piece
          }
          b.next()
        } else if (a.ins >= 0) {
          // Process the part of a change in A up to the start of the next
          // non-deletion change in B (if overlapping).
          let len = 0,
            left = a.len
          while (left) {
            if (b.ins == -1) {
              let piece = Math.min(left, b.len)
              len += piece
              left -= piece
              b.forward(piece)
            } else if (b.ins == 0 && b.len < left) {
              left -= b.len
              b.next()
            } else {
              break
            }
          }
          addSection(sections, len, inserted < a.i ? a.ins : 0)
          if (insert && inserted < a.i) addInsert(insert, sections, a.text)
          inserted = a.i
          a.forward(a.len - left)
        } else if (a.done && b.done) {
          return insert
            ? ChangeSet.createSet(sections, insert)
            : ChangeDesc.create(sections)
        } else {
          throw new Error('Mismatched change set lengths')
        }
      }
    }
    function composeSets(setA, setB, mkSet = false) {
      let sections = []
      let insert = mkSet ? [] : null
      let a = new SectionIter(setA),
        b = new SectionIter(setB)
      for (let open = false; ; ) {
        if (a.done && b.done) {
          return insert
            ? ChangeSet.createSet(sections, insert)
            : ChangeDesc.create(sections)
        } else if (a.ins == 0) {
          // Deletion in A
          addSection(sections, a.len, 0, open)
          a.next()
        } else if (b.len == 0 && !b.done) {
          // Insertion in B
          addSection(sections, 0, b.ins, open)
          if (insert) addInsert(insert, sections, b.text)
          b.next()
        } else if (a.done || b.done) {
          throw new Error('Mismatched change set lengths')
        } else {
          let len = Math.min(a.len2, b.len),
            sectionLen = sections.length
          if (a.ins == -1) {
            let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins
            addSection(sections, len, insB, open)
            if (insert && insB) addInsert(insert, sections, b.text)
          } else if (b.ins == -1) {
            addSection(sections, a.off ? 0 : a.len, len, open)
            if (insert) addInsert(insert, sections, a.textBit(len))
          } else {
            addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open)
            if (insert && !b.off) addInsert(insert, sections, b.text)
          }
          open =
            (a.ins > len || (b.ins >= 0 && b.len > len)) &&
            (open || sections.length > sectionLen)
          a.forward2(len)
          b.forward(len)
        }
      }
    }
    class SectionIter {
      constructor(set) {
        this.set = set
        this.i = 0
        this.next()
      }
      next() {
        let { sections } = this.set
        if (this.i < sections.length) {
          this.len = sections[this.i++]
          this.ins = sections[this.i++]
        } else {
          this.len = 0
          this.ins = -2
        }
        this.off = 0
      }
      get done() {
        return this.ins == -2
      }
      get len2() {
        return this.ins < 0 ? this.len : this.ins
      }
      get text() {
        let { inserted } = this.set,
          index = (this.i - 2) >> 1
        return index >= inserted.length ? Text.empty : inserted[index]
      }
      textBit(len) {
        let { inserted } = this.set,
          index = (this.i - 2) >> 1
        return index >= inserted.length && !len
          ? Text.empty
          : inserted[index].slice(
              this.off,
              len == null ? undefined : this.off + len
            )
      }
      forward(len) {
        if (len == this.len) this.next()
        else {
          this.len -= len
          this.off += len
        }
      }
      forward2(len) {
        if (this.ins == -1) this.forward(len)
        else if (len == this.ins) this.next()
        else {
          this.ins -= len
          this.off += len
        }
      }
    }

    /**
A single selection range. When
[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
multiple ranges. By default, selections hold exactly one range.
*/
    class SelectionRange {
      constructor(
        /**
    The lower boundary of the range.
    */
        from,
        /**
    The upper boundary of the range.
    */
        to,
        flags
      ) {
        this.from = from
        this.to = to
        this.flags = flags
      }
      /**
    The anchor of the range—the side that doesn't move when you
    extend it.
    */
      get anchor() {
        return this.flags & 32 /* RangeFlag.Inverted */ ? this.to : this.from
      }
      /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
      get head() {
        return this.flags & 32 /* RangeFlag.Inverted */ ? this.from : this.to
      }
      /**
    True when `anchor` and `head` are at the same position.
    */
      get empty() {
        return this.from == this.to
      }
      /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
      get assoc() {
        return this.flags & 8 /* RangeFlag.AssocBefore */
          ? -1
          : this.flags & 16 /* RangeFlag.AssocAfter */
            ? 1
            : 0
      }
      /**
    The bidirectional text level associated with this cursor, if
    any.
    */
      get bidiLevel() {
        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */
        return level == 7 ? null : level
      }
      /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
      get goalColumn() {
        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */
        return value == 16777215 /* RangeFlag.NoGoalColumn */
          ? undefined
          : value
      }
      /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
      map(change, assoc = -1) {
        let from, to
        if (this.empty) {
          from = to = change.mapPos(this.from, assoc)
        } else {
          from = change.mapPos(this.from, 1)
          to = change.mapPos(this.to, -1)
        }
        return from == this.from && to == this.to
          ? this
          : new SelectionRange(from, to, this.flags)
      }
      /**
    Extend this range to cover at least `from` to `to`.
    */
      extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
          return dist_EditorSelection.range(from, to)
        let head =
          Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to
        return dist_EditorSelection.range(this.anchor, head)
      }
      /**
    Compare this range to another range.
    */
      eq(other) {
        return this.anchor == other.anchor && this.head == other.head
      }
      /**
    Return a JSON-serializable object representing the range.
    */
      toJSON() {
        return { anchor: this.anchor, head: this.head }
      }
      /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
      static fromJSON(json) {
        if (
          !json ||
          typeof json.anchor != 'number' ||
          typeof json.head != 'number'
        )
          throw new RangeError('Invalid JSON representation for SelectionRange')
        return dist_EditorSelection.range(json.anchor, json.head)
      }
      /**
    @internal
    */
      static create(from, to, flags) {
        return new SelectionRange(from, to, flags)
      }
    }
    /**
An editor selection holds one or more selection ranges.
*/
    class dist_EditorSelection {
      constructor(
        /**
    The ranges in the selection, sorted by position. Ranges cannot
    overlap (but they may touch, if they aren't empty).
    */
        ranges,
        /**
    The index of the _main_ range in the selection (which is
    usually the range that was added last).
    */
        mainIndex
      ) {
        this.ranges = ranges
        this.mainIndex = mainIndex
      }
      /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
      map(change, assoc = -1) {
        if (change.empty) return this
        return dist_EditorSelection.create(
          this.ranges.map((r) => r.map(change, assoc)),
          this.mainIndex
        )
      }
      /**
    Compare this selection to another selection.
    */
      eq(other) {
        if (
          this.ranges.length != other.ranges.length ||
          this.mainIndex != other.mainIndex
        )
          return false
        for (let i = 0; i < this.ranges.length; i++)
          if (!this.ranges[i].eq(other.ranges[i])) return false
        return true
      }
      /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
      get main() {
        return this.ranges[this.mainIndex]
      }
      /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
      asSingle() {
        return this.ranges.length == 1
          ? this
          : new dist_EditorSelection([this.main], 0)
      }
      /**
    Extend this selection with an extra range.
    */
      addRange(range, main = true) {
        return dist_EditorSelection.create(
          [range].concat(this.ranges),
          main ? 0 : this.mainIndex + 1
        )
      }
      /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
      replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice()
        ranges[which] = range
        return dist_EditorSelection.create(ranges, this.mainIndex)
      }
      /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
      toJSON() {
        return {
          ranges: this.ranges.map((r) => r.toJSON()),
          main: this.mainIndex
        }
      }
      /**
    Create a selection from a JSON representation.
    */
      static fromJSON(json) {
        if (
          !json ||
          !Array.isArray(json.ranges) ||
          typeof json.main != 'number' ||
          json.main >= json.ranges.length
        )
          throw new RangeError(
            'Invalid JSON representation for EditorSelection'
          )
        return new dist_EditorSelection(
          json.ranges.map((r) => SelectionRange.fromJSON(r)),
          json.main
        )
      }
      /**
    Create a selection holding a single range.
    */
      static single(anchor, head = anchor) {
        return new dist_EditorSelection(
          [dist_EditorSelection.range(anchor, head)],
          0
        )
      }
      /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
      static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
          throw new RangeError('A selection needs at least one range')
        for (let pos = 0, i = 0; i < ranges.length; i++) {
          let range = ranges[i]
          if (range.empty ? range.from <= pos : range.from < pos)
            return dist_EditorSelection.normalized(ranges.slice(), mainIndex)
          pos = range.to
        }
        return new dist_EditorSelection(ranges, mainIndex)
      }
      /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
      static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(
          pos,
          pos,
          (assoc == 0
            ? 0
            : assoc < 0
              ? 8 /* RangeFlag.AssocBefore */
              : 16) /* RangeFlag.AssocAfter */ |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |
            ((goalColumn !== null && goalColumn !== void 0
              ? goalColumn
              : 16777215) /* RangeFlag.NoGoalColumn */ <<
              6) /* RangeFlag.GoalColumnOffset */
        )
      }
      /**
    Create a selection range.
    */
      static range(anchor, head, goalColumn, bidiLevel) {
        let flags =
          ((goalColumn !== null && goalColumn !== void 0
            ? goalColumn
            : 16777215) /* RangeFlag.NoGoalColumn */ <<
            6) /* RangeFlag.GoalColumnOffset */ |
          (bidiLevel == null ? 7 : Math.min(6, bidiLevel))
        return head < anchor
          ? SelectionRange.create(
              head,
              anchor,
              32 /* RangeFlag.Inverted */ |
                16 /* RangeFlag.AssocAfter */ |
                flags
            )
          : SelectionRange.create(
              anchor,
              head,
              (head > anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags
            )
      }
      /**
    @internal
    */
      static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex]
        ranges.sort((a, b) => a.from - b.from)
        mainIndex = ranges.indexOf(main)
        for (let i = 1; i < ranges.length; i++) {
          let range = ranges[i],
            prev = ranges[i - 1]
          if (range.empty ? range.from <= prev.to : range.from < prev.to) {
            let from = prev.from,
              to = Math.max(range.to, prev.to)
            if (i <= mainIndex) mainIndex--
            ranges.splice(
              --i,
              2,
              range.anchor > range.head
                ? dist_EditorSelection.range(to, from)
                : dist_EditorSelection.range(from, to)
            )
          }
        }
        return new dist_EditorSelection(ranges, mainIndex)
      }
    }
    function checkSelection(selection, docLength) {
      for (let range of selection.ranges)
        if (range.to > docLength)
          throw new RangeError('Selection points outside of document')
    }

    let nextID = 0
    /**
A facet is a labeled value that is associated with an editor
state. It takes inputs from any number of extensions, and combines
those into a single output value.

Examples of uses of facets are the [tab
size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor
attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update
listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).

Note that `Facet` instances can be used anywhere where
[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.
*/
    class Facet {
      constructor(
        /**
    @internal
    */
        combine,
        /**
    @internal
    */
        compareInput,
        /**
    @internal
    */
        compare,
        isStatic,
        enables
      ) {
        this.combine = combine
        this.compareInput = compareInput
        this.compare = compare
        this.isStatic = isStatic
        /**
        @internal
        */
        this.id = nextID++
        this.default = combine([])
        this.extensions = typeof enables == 'function' ? enables(this) : enables
      }
      /**
    Returns a facet reader for this facet, which can be used to
    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
    */
      get reader() {
        return this
      }
      /**
    Define a new facet.
    */
      static define(config = {}) {
        return new Facet(
          config.combine || ((a) => a),
          config.compareInput || ((a, b) => a === b),
          config.compare || (!config.combine ? sameArray : (a, b) => a === b),
          !!config.static,
          config.enables
        )
      }
      /**
    Returns an extension that adds the given value to this facet.
    */
      of(value) {
        return new FacetProvider([], this, 0 /* Provider.Static */, value)
      }
      /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
      compute(deps, get) {
        if (this.isStatic) throw new Error("Can't compute a static facet")
        return new FacetProvider(deps, this, 1 /* Provider.Single */, get)
      }
      /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
      computeN(deps, get) {
        if (this.isStatic) throw new Error("Can't compute a static facet")
        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get)
      }
      from(field, get) {
        if (!get) get = (x) => x
        return this.compute([field], (state) => get(state.field(field)))
      }
    }
    function sameArray(a, b) {
      return a == b || (a.length == b.length && a.every((e, i) => e === b[i]))
    }
    class FacetProvider {
      constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies
        this.facet = facet
        this.type = type
        this.value = value
        this.id = nextID++
      }
      dynamicSlot(addresses) {
        var _a
        let getter = this.value
        let compare = this.facet.compareInput
        let id = this.id,
          idx = addresses[id] >> 1,
          multi = this.type == 2 /* Provider.Multi */
        let depDoc = false,
          depSel = false,
          depAddrs = []
        for (let dep of this.dependencies) {
          if (dep == 'doc') depDoc = true
          else if (dep == 'selection') depSel = true
          else if (
            (((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) &
              1) ==
            0
          )
            depAddrs.push(addresses[dep.id])
        }
        return {
          create(state) {
            state.values[idx] = getter(state)
            return 1 /* SlotStatus.Changed */
          },
          update(state, tr) {
            if (
              (depDoc && tr.docChanged) ||
              (depSel && (tr.docChanged || tr.selection)) ||
              ensureAll(state, depAddrs)
            ) {
              let newVal = getter(state)
              if (
                multi
                  ? !compareArray(newVal, state.values[idx], compare)
                  : !compare(newVal, state.values[idx])
              ) {
                state.values[idx] = newVal
                return 1 /* SlotStatus.Changed */
              }
            }
            return 0
          },
          reconfigure: (state, oldState) => {
            let newVal,
              oldAddr = oldState.config.address[id]
            if (oldAddr != null) {
              let oldVal = getAddr(oldState, oldAddr)
              if (
                this.dependencies.every((dep) => {
                  return dep instanceof Facet
                    ? oldState.facet(dep) === state.facet(dep)
                    : dep instanceof StateField
                      ? oldState.field(dep, false) == state.field(dep, false)
                      : true
                }) ||
                (multi
                  ? compareArray((newVal = getter(state)), oldVal, compare)
                  : compare((newVal = getter(state)), oldVal))
              ) {
                state.values[idx] = oldVal
                return 0
              }
            } else {
              newVal = getter(state)
            }
            state.values[idx] = newVal
            return 1 /* SlotStatus.Changed */
          }
        }
      }
    }
    function compareArray(a, b, compare) {
      if (a.length != b.length) return false
      for (let i = 0; i < a.length; i++) if (!compare(a[i], b[i])) return false
      return true
    }
    function ensureAll(state, addrs) {
      let changed = false
      for (let addr of addrs)
        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */) changed = true
      return changed
    }
    function dynamicFacetSlot(addresses, facet, providers) {
      let providerAddrs = providers.map((p) => addresses[p.id])
      let providerTypes = providers.map((p) => p.type)
      let dynamic = providerAddrs.filter((p) => !(p & 1))
      let idx = addresses[facet.id] >> 1
      function get(state) {
        let values = []
        for (let i = 0; i < providerAddrs.length; i++) {
          let value = getAddr(state, providerAddrs[i])
          if (providerTypes[i] == 2 /* Provider.Multi */)
            for (let val of value) values.push(val)
          else values.push(value)
        }
        return facet.combine(values)
      }
      return {
        create(state) {
          for (let addr of providerAddrs) ensureAddr(state, addr)
          state.values[idx] = get(state)
          return 1 /* SlotStatus.Changed */
        },
        update(state, tr) {
          if (!ensureAll(state, dynamic)) return 0
          let value = get(state)
          if (facet.compare(value, state.values[idx])) return 0
          state.values[idx] = value
          return 1 /* SlotStatus.Changed */
        },
        reconfigure(state, oldState) {
          let depChanged = ensureAll(state, providerAddrs)
          let oldProviders = oldState.config.facets[facet.id],
            oldValue = oldState.facet(facet)
          if (
            oldProviders &&
            !depChanged &&
            sameArray(providers, oldProviders)
          ) {
            state.values[idx] = oldValue
            return 0
          }
          let value = get(state)
          if (facet.compare(value, oldValue)) {
            state.values[idx] = oldValue
            return 0
          }
          state.values[idx] = value
          return 1 /* SlotStatus.Changed */
        }
      }
    }
    const initField = /*@__PURE__*/ Facet.define({ static: true })
    /**
Fields can store additional information in an editor state, and
keep it in sync with the rest of the state.
*/
    class StateField {
      constructor(
        /**
    @internal
    */
        id,
        createF,
        updateF,
        compareF,
        /**
    @internal
    */
        spec
      ) {
        this.id = id
        this.createF = createF
        this.updateF = updateF
        this.compareF = compareF
        this.spec = spec
        /**
        @internal
        */
        this.provides = undefined
      }
      /**
    Define a state field.
    */
      static define(config) {
        let field = new StateField(
          nextID++,
          config.create,
          config.update,
          config.compare || ((a, b) => a === b),
          config
        )
        if (config.provide) field.provides = config.provide(field)
        return field
      }
      create(state) {
        let init = state.facet(initField).find((i) => i.field == this)
        return (
          (init === null || init === void 0 ? void 0 : init.create) ||
          this.createF
        )(state)
      }
      /**
    @internal
    */
      slot(addresses) {
        let idx = addresses[this.id] >> 1
        return {
          create: (state) => {
            state.values[idx] = this.create(state)
            return 1 /* SlotStatus.Changed */
          },
          update: (state, tr) => {
            let oldVal = state.values[idx]
            let value = this.updateF(oldVal, tr)
            if (this.compareF(oldVal, value)) return 0
            state.values[idx] = value
            return 1 /* SlotStatus.Changed */
          },
          reconfigure: (state, oldState) => {
            if (oldState.config.address[this.id] != null) {
              state.values[idx] = oldState.field(this)
              return 0
            }
            state.values[idx] = this.create(state)
            return 1 /* SlotStatus.Changed */
          }
        }
      }
      /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
      init(create) {
        return [this, initField.of({ field: this, create })]
      }
      /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
      get extension() {
        return this
      }
    }
    const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 }
    function prec(value) {
      return (ext) => new PrecExtension(ext, value)
    }
    /**
By default extensions are registered in the order they are found
in the flattened form of nested array that was provided.
Individual extension values can be assigned a precedence to
override this. Extensions that do not have a precedence set get
the precedence of the nearest parent with a precedence, or
[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
final ordering of extensions is determined by first sorting by
precedence and then by order within each precedence.
*/
    const Prec = {
      /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
      highest: /*@__PURE__*/ prec(Prec_.highest),
      /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
      high: /*@__PURE__*/ prec(Prec_.high),
      /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
      default: /*@__PURE__*/ prec(Prec_.default),
      /**
    A lower-than-default precedence.
    */
      low: /*@__PURE__*/ prec(Prec_.low),
      /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
      lowest: /*@__PURE__*/ prec(Prec_.lowest)
    }
    class PrecExtension {
      constructor(inner, prec) {
        this.inner = inner
        this.prec = prec
      }
    }
    /**
Extension compartments can be used to make a configuration
dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
configuration in a compartment, you can later
[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
transaction.
*/
    class Compartment {
      /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
      of(ext) {
        return new CompartmentInstance(this, ext)
      }
      /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
      reconfigure(content) {
        return Compartment.reconfigure.of({
          compartment: this,
          extension: content
        })
      }
      /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
      get(state) {
        return state.config.compartments.get(this)
      }
    }
    class CompartmentInstance {
      constructor(compartment, inner) {
        this.compartment = compartment
        this.inner = inner
      }
    }
    class Configuration {
      constructor(
        base,
        compartments,
        dynamicSlots,
        address,
        staticValues,
        facets
      ) {
        this.base = base
        this.compartments = compartments
        this.dynamicSlots = dynamicSlots
        this.address = address
        this.staticValues = staticValues
        this.facets = facets
        this.statusTemplate = []
        while (this.statusTemplate.length < dynamicSlots.length)
          this.statusTemplate.push(0 /* SlotStatus.Unresolved */)
      }
      staticFacet(facet) {
        let addr = this.address[facet.id]
        return addr == null ? facet.default : this.staticValues[addr >> 1]
      }
      static resolve(base, compartments, oldState) {
        let fields = []
        let facets = Object.create(null)
        let newCompartments = new Map()
        for (let ext of flatten(base, compartments, newCompartments)) {
          if (ext instanceof StateField) fields.push(ext)
          else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext)
        }
        let address = Object.create(null)
        let staticValues = []
        let dynamicSlots = []
        for (let field of fields) {
          address[field.id] = dynamicSlots.length << 1
          dynamicSlots.push((a) => field.slot(a))
        }
        let oldFacets =
          oldState === null || oldState === void 0
            ? void 0
            : oldState.config.facets
        for (let id in facets) {
          let providers = facets[id],
            facet = providers[0].facet
          let oldProviders = (oldFacets && oldFacets[id]) || []
          if (providers.every((p) => p.type == 0 /* Provider.Static */)) {
            address[facet.id] = (staticValues.length << 1) | 1
            if (sameArray(oldProviders, providers)) {
              staticValues.push(oldState.facet(facet))
            } else {
              let value = facet.combine(providers.map((p) => p.value))
              staticValues.push(
                oldState && facet.compare(value, oldState.facet(facet))
                  ? oldState.facet(facet)
                  : value
              )
            }
          } else {
            for (let p of providers) {
              if (p.type == 0 /* Provider.Static */) {
                address[p.id] = (staticValues.length << 1) | 1
                staticValues.push(p.value)
              } else {
                address[p.id] = dynamicSlots.length << 1
                dynamicSlots.push((a) => p.dynamicSlot(a))
              }
            }
            address[facet.id] = dynamicSlots.length << 1
            dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers))
          }
        }
        let dynamic = dynamicSlots.map((f) => f(address))
        return new Configuration(
          base,
          newCompartments,
          dynamic,
          address,
          staticValues,
          facets
        )
      }
    }
    function flatten(extension, compartments, newCompartments) {
      let result = [[], [], [], [], []]
      let seen = new Map()
      function inner(ext, prec) {
        let known = seen.get(ext)
        if (known != null) {
          if (known <= prec) return
          let found = result[known].indexOf(ext)
          if (found > -1) result[known].splice(found, 1)
          if (ext instanceof CompartmentInstance)
            newCompartments.delete(ext.compartment)
        }
        seen.set(ext, prec)
        if (Array.isArray(ext)) {
          for (let e of ext) inner(e, prec)
        } else if (ext instanceof CompartmentInstance) {
          if (newCompartments.has(ext.compartment))
            throw new RangeError(`Duplicate use of compartment in extensions`)
          let content = compartments.get(ext.compartment) || ext.inner
          newCompartments.set(ext.compartment, content)
          inner(content, prec)
        } else if (ext instanceof PrecExtension) {
          inner(ext.inner, ext.prec)
        } else if (ext instanceof StateField) {
          result[prec].push(ext)
          if (ext.provides) inner(ext.provides, prec)
        } else if (ext instanceof FacetProvider) {
          result[prec].push(ext)
          if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default)
        } else {
          let content = ext.extension
          if (!content)
            throw new Error(
              `Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`
            )
          inner(content, prec)
        }
      }
      inner(extension, Prec_.default)
      return result.reduce((a, b) => a.concat(b))
    }
    function ensureAddr(state, addr) {
      if (addr & 1) return 2 /* SlotStatus.Computed */
      let idx = addr >> 1
      let status = state.status[idx]
      if (status == 4 /* SlotStatus.Computing */)
        throw new Error('Cyclic dependency between fields and/or facets')
      if (status & 2 /* SlotStatus.Computed */) return status
      state.status[idx] = 4 /* SlotStatus.Computing */
      let changed = state.computeSlot(state, state.config.dynamicSlots[idx])
      return (state.status[idx] = 2 /* SlotStatus.Computed */ | changed)
    }
    function getAddr(state, addr) {
      return addr & 1
        ? state.config.staticValues[addr >> 1]
        : state.values[addr >> 1]
    }

    const languageData = /*@__PURE__*/ Facet.define()
    const allowMultipleSelections = /*@__PURE__*/ Facet.define({
      combine: (values) => values.some((v) => v),
      static: true
    })
    const lineSeparator = /*@__PURE__*/ Facet.define({
      combine: (values) => (values.length ? values[0] : undefined),
      static: true
    })
    const changeFilter = /*@__PURE__*/ Facet.define()
    const transactionFilter = /*@__PURE__*/ Facet.define()
    const transactionExtender = /*@__PURE__*/ Facet.define()
    const readOnly = /*@__PURE__*/ Facet.define({
      combine: (values) => (values.length ? values[0] : false)
    })

    /**
Annotations are tagged values that are used to add metadata to
transactions in an extensible way. They should be used to model
things that effect the entire transaction (such as its [time
stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
_alongside_ the other changes made by the transaction, [state
effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
*/
    class Annotation {
      /**
    @internal
    */
      constructor(
        /**
    The annotation type.
    */
        type,
        /**
    The value of this annotation.
    */
        value
      ) {
        this.type = type
        this.value = value
      }
      /**
    Define a new type of annotation.
    */
      static define() {
        return new AnnotationType()
      }
    }
    /**
Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
*/
    class AnnotationType {
      /**
    Create an instance of this annotation.
    */
      of(value) {
        return new Annotation(this, value)
      }
    }
    /**
Representation of a type of state effect. Defined with
[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
*/
    class StateEffectType {
      /**
    @internal
    */
      constructor(
        // The `any` types in these function types are there to work
        // around TypeScript issue #37631, where the type guard on
        // `StateEffect.is` mysteriously stops working when these properly
        // have type `Value`.
        /**
    @internal
    */
        map
      ) {
        this.map = map
      }
      /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
      of(value) {
        return new StateEffect(this, value)
      }
    }
    /**
State effects can be used to represent additional effects
associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
are often useful to model changes to custom [state
fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
document or selection changes.
*/
    class StateEffect {
      /**
    @internal
    */
      constructor(
        /**
    @internal
    */
        type,
        /**
    The value of this effect.
    */
        value
      ) {
        this.type = type
        this.value = value
      }
      /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
      map(mapping) {
        let mapped = this.type.map(this.value, mapping)
        return mapped === undefined
          ? undefined
          : mapped == this.value
            ? this
            : new StateEffect(this.type, mapped)
      }
      /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
      is(type) {
        return this.type == type
      }
      /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds. It should be a type that
    doesn't include `undefined`, since that is used in
    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
    removed.
    */
      static define(spec = {}) {
        return new StateEffectType(spec.map || ((v) => v))
      }
      /**
    Map an array of effects through a change set.
    */
      static mapEffects(effects, mapping) {
        if (!effects.length) return effects
        let result = []
        for (let effect of effects) {
          let mapped = effect.map(mapping)
          if (mapped) result.push(mapped)
        }
        return result
      }
    }
    /**
This effect can be used to reconfigure the root extensions of
the editor. Doing this will discard any extensions
[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
compartments.
*/
    StateEffect.reconfigure = /*@__PURE__*/ StateEffect.define()
    /**
Append extensions to the top-level configuration of the editor.
*/
    StateEffect.appendConfig = /*@__PURE__*/ StateEffect.define()
    /**
Changes to the editor state are grouped into transactions.
Typically, a user action creates a single transaction, which may
contain any number of document changes, may change the selection,
or have other effects. Create a transaction by calling
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately
dispatch one by calling
[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).
*/
    class Transaction {
      constructor(
        /**
    The state from which the transaction starts.
    */
        startState,
        /**
    The document changes made by this transaction.
    */
        changes,
        /**
    The selection set by this transaction, or undefined if it
    doesn't explicitly set a selection.
    */
        selection,
        /**
    The effects added to the transaction.
    */
        effects,
        /**
    @internal
    */
        annotations,
        /**
    Whether the selection should be scrolled into view after this
    transaction is dispatched.
    */
        scrollIntoView
      ) {
        this.startState = startState
        this.changes = changes
        this.selection = selection
        this.effects = effects
        this.annotations = annotations
        this.scrollIntoView = scrollIntoView
        /**
        @internal
        */
        this._doc = null
        /**
        @internal
        */
        this._state = null
        if (selection) checkSelection(selection, changes.newLength)
        if (!annotations.some((a) => a.type == Transaction.time))
          this.annotations = annotations.concat(Transaction.time.of(Date.now()))
      }
      /**
    @internal
    */
      static create(
        startState,
        changes,
        selection,
        effects,
        annotations,
        scrollIntoView
      ) {
        return new Transaction(
          startState,
          changes,
          selection,
          effects,
          annotations,
          scrollIntoView
        )
      }
      /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
      get newDoc() {
        return (
          this._doc || (this._doc = this.changes.apply(this.startState.doc))
        )
      }
      /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
      get newSelection() {
        return this.selection || this.startState.selection.map(this.changes)
      }
      /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
      get state() {
        if (!this._state) this.startState.applyTransaction(this)
        return this._state
      }
      /**
    Get the value of the given annotation type, if any.
    */
      annotation(type) {
        for (let ann of this.annotations) if (ann.type == type) return ann.value
        return undefined
      }
      /**
    Indicates whether the transaction changed the document.
    */
      get docChanged() {
        return !this.changes.empty
      }
      /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
      get reconfigured() {
        return this.startState.config != this.state.config
      }
      /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
      isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent)
        return !!(
          e &&
          (e == event ||
            (e.length > event.length &&
              e.slice(0, event.length) == event &&
              e[event.length] == '.'))
        )
      }
    }
    /**
Annotation used to store transaction timestamps. Automatically
added to every transaction, holding `Date.now()`.
*/
    Transaction.time = /*@__PURE__*/ Annotation.define()
    /**
Annotation used to associate a transaction with a user interface
event. Holds a string identifying the event, using a
dot-separated format to support attaching more specific
information. The events used by the core libraries are:

 - `"input"` when content is entered
   - `"input.type"` for typed input
     - `"input.type.compose"` for composition
   - `"input.paste"` for pasted input
   - `"input.drop"` when adding content with drag-and-drop
   - `"input.complete"` when autocompleting
 - `"delete"` when the user deletes content
   - `"delete.selection"` when deleting the selection
   - `"delete.forward"` when deleting forward from the selection
   - `"delete.backward"` when deleting backward from the selection
   - `"delete.cut"` when cutting to the clipboard
 - `"move"` when content is moved
   - `"move.drop"` when content is moved within the editor through drag-and-drop
 - `"select"` when explicitly changing the selection
   - `"select.pointer"` when selecting with a mouse or other pointing device
 - `"undo"` and `"redo"` for history actions

Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
whether the annotation matches a given event.
*/
    Transaction.userEvent = /*@__PURE__*/ Annotation.define()
    /**
Annotation indicating whether a transaction should be added to
the undo history or not.
*/
    Transaction.addToHistory = /*@__PURE__*/ Annotation.define()
    /**
Annotation indicating (when present and true) that a transaction
represents a change made by some other actor, not the user. This
is used, for example, to tag other people's changes in
collaborative editing.
*/
    Transaction.remote = /*@__PURE__*/ Annotation.define()
    function joinRanges(a, b) {
      let result = []
      for (let iA = 0, iB = 0; ; ) {
        let from, to
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
          from = a[iA++]
          to = a[iA++]
        } else if (iB < b.length) {
          from = b[iB++]
          to = b[iB++]
        } else return result
        if (!result.length || result[result.length - 1] < from)
          result.push(from, to)
        else if (result[result.length - 1] < to) result[result.length - 1] = to
      }
    }
    function mergeTransaction(a, b, sequential) {
      var _a
      let mapForA, mapForB, changes
      if (sequential) {
        mapForA = b.changes
        mapForB = ChangeSet.empty(b.changes.length)
        changes = a.changes.compose(b.changes)
      } else {
        mapForA = b.changes.map(a.changes)
        mapForB = a.changes.mapDesc(b.changes, true)
        changes = a.changes.compose(mapForA)
      }
      return {
        changes,
        selection: b.selection
          ? b.selection.map(mapForB)
          : (_a = a.selection) === null || _a === void 0
            ? void 0
            : _a.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(
          StateEffect.mapEffects(b.effects, mapForB)
        ),
        annotations: a.annotations.length
          ? a.annotations.concat(b.annotations)
          : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
      }
    }
    function resolveTransactionInner(state, spec, docSize) {
      let sel = spec.selection,
        annotations = asArray(spec.annotations)
      if (spec.userEvent)
        annotations = annotations.concat(
          Transaction.userEvent.of(spec.userEvent)
        )
      return {
        changes:
          spec.changes instanceof ChangeSet
            ? spec.changes
            : ChangeSet.of(
                spec.changes || [],
                docSize,
                state.facet(lineSeparator)
              ),
        selection:
          sel &&
          (sel instanceof dist_EditorSelection
            ? sel
            : dist_EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
      }
    }
    function resolveTransaction(state, specs, filter) {
      let s = resolveTransactionInner(
        state,
        specs.length ? specs[0] : {},
        state.doc.length
      )
      if (specs.length && specs[0].filter === false) filter = false
      for (let i = 1; i < specs.length; i++) {
        if (specs[i].filter === false) filter = false
        let seq = !!specs[i].sequential
        s = mergeTransaction(
          s,
          resolveTransactionInner(
            state,
            specs[i],
            seq ? s.changes.newLength : state.doc.length
          ),
          seq
        )
      }
      let tr = Transaction.create(
        state,
        s.changes,
        s.selection,
        s.effects,
        s.annotations,
        s.scrollIntoView
      )
      return extendTransaction(filter ? filterTransaction(tr) : tr)
    }
    // Finish a transaction by applying filters if necessary.
    function filterTransaction(tr) {
      let state = tr.startState
      // Change filters
      let result = true
      for (let filter of state.facet(changeFilter)) {
        let value = filter(tr)
        if (value === false) {
          result = false
          break
        }
        if (Array.isArray(value))
          result = result === true ? value : joinRanges(result, value)
      }
      if (result !== true) {
        let changes, back
        if (result === false) {
          back = tr.changes.invertedDesc
          changes = ChangeSet.empty(state.doc.length)
        } else {
          let filtered = tr.changes.filter(result)
          changes = filtered.changes
          back = filtered.filtered.mapDesc(filtered.changes).invertedDesc
        }
        tr = Transaction.create(
          state,
          changes,
          tr.selection && tr.selection.map(back),
          StateEffect.mapEffects(tr.effects, back),
          tr.annotations,
          tr.scrollIntoView
        )
      }
      // Transaction filters
      let filters = state.facet(transactionFilter)
      for (let i = filters.length - 1; i >= 0; i--) {
        let filtered = filters[i](tr)
        if (filtered instanceof Transaction) tr = filtered
        else if (
          Array.isArray(filtered) &&
          filtered.length == 1 &&
          filtered[0] instanceof Transaction
        )
          tr = filtered[0]
        else tr = resolveTransaction(state, asArray(filtered), false)
      }
      return tr
    }
    function extendTransaction(tr) {
      let state = tr.startState,
        extenders = state.facet(transactionExtender),
        spec = tr
      for (let i = extenders.length - 1; i >= 0; i--) {
        let extension = extenders[i](tr)
        if (extension && Object.keys(extension).length)
          spec = mergeTransaction(
            spec,
            resolveTransactionInner(state, extension, tr.changes.newLength),
            true
          )
      }
      return spec == tr
        ? tr
        : Transaction.create(
            state,
            tr.changes,
            tr.selection,
            spec.effects,
            spec.annotations,
            spec.scrollIntoView
          )
    }
    const none = []
    function asArray(value) {
      return value == null ? none : Array.isArray(value) ? value : [value]
    }

    /**
The categories produced by a [character
categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
do things like selecting by word.
*/
    var dist_CharCategory = /*@__PURE__*/ (function (CharCategory) {
      /**
    Word characters.
    */
      CharCategory[(CharCategory['Word'] = 0)] = 'Word'
      /**
    Whitespace.
    */
      CharCategory[(CharCategory['Space'] = 1)] = 'Space'
      /**
    Anything else.
    */
      CharCategory[(CharCategory['Other'] = 2)] = 'Other'
      return CharCategory
    })(dist_CharCategory || (dist_CharCategory = {}))
    const nonASCIISingleCaseWordChar =
      /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
    let wordChar
    try {
      wordChar = /*@__PURE__*/ new RegExp('[\\p{Alphabetic}\\p{Number}_]', 'u')
    } catch (_) {}
    function hasWordChar(str) {
      if (wordChar) return wordChar.test(str)
      for (let i = 0; i < str.length; i++) {
        let ch = str[i]
        if (
          /\w/.test(ch) ||
          (ch > '\x80' &&
            (ch.toUpperCase() != ch.toLowerCase() ||
              nonASCIISingleCaseWordChar.test(ch)))
        )
          return true
      }
      return false
    }
    function makeCategorizer(wordChars) {
      return (char) => {
        if (!/\S/.test(char)) return dist_CharCategory.Space
        if (hasWordChar(char)) return dist_CharCategory.Word
        for (let i = 0; i < wordChars.length; i++)
          if (char.indexOf(wordChars[i]) > -1) return dist_CharCategory.Word
        return dist_CharCategory.Other
      }
    }

    /**
The editor state class is a persistent (immutable) data structure.
To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
instance, without modifying the original object.

As such, _never_ mutate properties of a state directly. That'll
just break things.
*/
    class EditorState {
      constructor(
        /**
    @internal
    */
        config,
        /**
    The current document.
    */
        doc,
        /**
    The current selection.
    */
        selection,
        /**
    @internal
    */
        values,
        computeSlot,
        tr
      ) {
        this.config = config
        this.doc = doc
        this.selection = selection
        this.values = values
        this.status = config.statusTemplate.slice()
        this.computeSlot = computeSlot
        // Fill in the computed state immediately, so that further queries
        // for it made during the update return this state
        if (tr) tr._state = this
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
          ensureAddr(this, i << 1)
        this.computeSlot = null
      }
      field(field, require = true) {
        let addr = this.config.address[field.id]
        if (addr == null) {
          if (require)
            throw new RangeError('Field is not present in this state')
          return undefined
        }
        ensureAddr(this, addr)
        return getAddr(this, addr)
      }
      /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
      update(...specs) {
        return resolveTransaction(this, specs, true)
      }
      /**
    @internal
    */
      applyTransaction(tr) {
        let conf = this.config,
          { base, compartments } = conf
        for (let effect of tr.effects) {
          if (effect.is(Compartment.reconfigure)) {
            if (conf) {
              compartments = new Map()
              conf.compartments.forEach((val, key) =>
                compartments.set(key, val)
              )
              conf = null
            }
            compartments.set(effect.value.compartment, effect.value.extension)
          } else if (effect.is(StateEffect.reconfigure)) {
            conf = null
            base = effect.value
          } else if (effect.is(StateEffect.appendConfig)) {
            conf = null
            base = asArray(base).concat(effect.value)
          }
        }
        let startValues
        if (!conf) {
          conf = Configuration.resolve(base, compartments, this)
          let intermediateState = new EditorState(
            conf,
            this.doc,
            this.selection,
            conf.dynamicSlots.map(() => null),
            (state, slot) => slot.reconfigure(state, this),
            null
          )
          startValues = intermediateState.values
        } else {
          startValues = tr.startState.values.slice()
        }
        let selection = tr.startState.facet(allowMultipleSelections)
          ? tr.newSelection
          : tr.newSelection.asSingle()
        new EditorState(
          conf,
          tr.newDoc,
          selection,
          startValues,
          (state, slot) => slot.update(state, tr),
          tr
        )
      }
      /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
      replaceSelection(text) {
        if (typeof text == 'string') text = this.toText(text)
        return this.changeByRange((range) => ({
          changes: { from: range.from, to: range.to, insert: text },
          range: dist_EditorSelection.cursor(range.from + text.length)
        }))
      }
      /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
      changeByRange(f) {
        let sel = this.selection
        let result1 = f(sel.ranges[0])
        let changes = this.changes(result1.changes),
          ranges = [result1.range]
        let effects = asArray(result1.effects)
        for (let i = 1; i < sel.ranges.length; i++) {
          let result = f(sel.ranges[i])
          let newChanges = this.changes(result.changes),
            newMapped = newChanges.map(changes)
          for (let j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped)
          let mapBy = changes.mapDesc(newChanges, true)
          ranges.push(result.range.map(mapBy))
          changes = changes.compose(newMapped)
          effects = StateEffect.mapEffects(effects, newMapped).concat(
            StateEffect.mapEffects(asArray(result.effects), mapBy)
          )
        }
        return {
          changes,
          selection: dist_EditorSelection.create(ranges, sel.mainIndex),
          effects
        }
      }
      /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
      changes(spec = []) {
        if (spec instanceof ChangeSet) return spec
        return ChangeSet.of(
          spec,
          this.doc.length,
          this.facet(EditorState.lineSeparator)
        )
      }
      /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
      toText(string) {
        return Text.of(
          string.split(this.facet(EditorState.lineSeparator) || DefaultSplit)
        )
      }
      /**
    Return the given range of the document as a string.
    */
      sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak)
      }
      /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
      facet(facet) {
        let addr = this.config.address[facet.id]
        if (addr == null) return facet.default
        ensureAddr(this, addr)
        return getAddr(this, addr)
      }
      /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
      toJSON(fields) {
        let result = {
          doc: this.sliceDoc(),
          selection: this.selection.toJSON()
        }
        if (fields)
          for (let prop in fields) {
            let value = fields[prop]
            if (
              value instanceof StateField &&
              this.config.address[value.id] != null
            )
              result[prop] = value.spec.toJSON(this.field(fields[prop]), this)
          }
        return result
      }
      /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
      static fromJSON(json, config = {}, fields) {
        if (!json || typeof json.doc != 'string')
          throw new RangeError('Invalid JSON representation for EditorState')
        let fieldInit = []
        if (fields)
          for (let prop in fields) {
            if (Object.prototype.hasOwnProperty.call(json, prop)) {
              let field = fields[prop],
                value = json[prop]
              fieldInit.push(
                field.init((state) => field.spec.fromJSON(value, state))
              )
            }
          }
        return EditorState.create({
          doc: json.doc,
          selection: dist_EditorSelection.fromJSON(json.selection),
          extensions: config.extensions
            ? fieldInit.concat([config.extensions])
            : fieldInit
        })
      }
      /**
    Create a new state. You'll usually only need this when
    initializing an editor—updated states are created by applying
    transactions.
    */
      static create(config = {}) {
        let configuration = Configuration.resolve(
          config.extensions || [],
          new Map()
        )
        let doc =
          config.doc instanceof Text
            ? config.doc
            : Text.of(
                (config.doc || '').split(
                  configuration.staticFacet(EditorState.lineSeparator) ||
                    DefaultSplit
                )
              )
        let selection = !config.selection
          ? dist_EditorSelection.single(0)
          : config.selection instanceof dist_EditorSelection
            ? config.selection
            : dist_EditorSelection.single(
                config.selection.anchor,
                config.selection.head
              )
        checkSelection(selection, doc.length)
        if (!configuration.staticFacet(allowMultipleSelections))
          selection = selection.asSingle()
        return new EditorState(
          configuration,
          doc,
          selection,
          configuration.dynamicSlots.map(() => null),
          (state, slot) => slot.create(state),
          null
        )
      }
      /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
      get tabSize() {
        return this.facet(EditorState.tabSize)
      }
      /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
      get lineBreak() {
        return this.facet(EditorState.lineSeparator) || '\n'
      }
      /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
      get readOnly() {
        return this.facet(readOnly)
      }
      /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
      phrase(phrase, ...insert) {
        for (let map of this.facet(EditorState.phrases))
          if (Object.prototype.hasOwnProperty.call(map, phrase)) {
            phrase = map[phrase]
            break
          }
        if (insert.length)
          phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
            if (i == '$') return '$'
            let n = +(i || 1)
            return !n || n > insert.length ? m : insert[n - 1]
          })
        return phrase
      }
      /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    
    Examples of language data fields are...
    
    - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
      comment syntax.
    - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
      for providing language-specific completion sources.
    - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
      characters that should be considered part of words in this
      language.
    - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
      bracket closing behavior.
    */
      languageDataAt(name, pos, side = -1) {
        let values = []
        for (let provider of this.facet(languageData)) {
          for (let result of provider(this, pos, side)) {
            if (Object.prototype.hasOwnProperty.call(result, name))
              values.push(result[name])
          }
        }
        return values
      }
      /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
      charCategorizer(at) {
        return makeCategorizer(this.languageDataAt('wordChars', at).join(''))
      }
      /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
      wordAt(pos) {
        let { text, from, length } = this.doc.lineAt(pos)
        let cat = this.charCategorizer(pos)
        let start = pos - from,
          end = pos - from
        while (start > 0) {
          let prev = findClusterBreak(text, start, false)
          if (cat(text.slice(prev, start)) != dist_CharCategory.Word) break
          start = prev
        }
        while (end < length) {
          let next = findClusterBreak(text, end)
          if (cat(text.slice(end, next)) != dist_CharCategory.Word) break
          end = next
        }
        return start == end
          ? null
          : dist_EditorSelection.range(start + from, end + from)
      }
    }
    /**
A facet that, when enabled, causes the editor to allow multiple
ranges to be selected. Be careful though, because by default the
editor relies on the native DOM selection, which cannot handle
multiple selections. An extension like
[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
secondary selections visible to the user.
*/
    EditorState.allowMultipleSelections = allowMultipleSelections
    /**
Configures the tab size to use in this state. The first
(highest-precedence) value of the facet is used. If no value is
given, this defaults to 4.
*/
    EditorState.tabSize = /*@__PURE__*/ Facet.define({
      combine: (values) => (values.length ? values[0] : 4)
    })
    /**
The line separator to use. By default, any of `"\n"`, `"\r\n"`
and `"\r"` is treated as a separator when splitting lines, and
lines are joined with `"\n"`.

When you configure a value here, only that precise separator
will be used, allowing you to round-trip documents through the
editor without normalizing line separators.
*/
    EditorState.lineSeparator = lineSeparator
    /**
This facet controls the value of the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
consulted by commands and extensions that implement editing
functionality to determine whether they should apply. It
defaults to false, but when its highest-precedence value is
`true`, such functionality disables itself.

Not to be confused with
[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
controls whether the editor's DOM is set to be editable (and
thus focusable).
*/
    EditorState.readOnly = readOnly
    /**
Registers translation phrases. The
[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
all objects registered with this facet to find translations for
its argument.
*/
    EditorState.phrases = /*@__PURE__*/ Facet.define({
      compare(a, b) {
        let kA = Object.keys(a),
          kB = Object.keys(b)
        return kA.length == kB.length && kA.every((k) => a[k] == b[k])
      }
    })
    /**
A facet used to register [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
*/
    EditorState.languageData = languageData
    /**
Facet used to register change filters, which are called for each
transaction (unless explicitly
[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
part of the transaction's changes.

Such a function can return `true` to indicate that it doesn't
want to do anything, `false` to completely stop the changes in
the transaction, or a set of ranges in which changes should be
suppressed. Such ranges are represented as an array of numbers,
with each pair of two numbers indicating the start and end of a
range. So for example `[10, 20, 100, 110]` suppresses changes
between 10 and 20, and between 100 and 110.
*/
    EditorState.changeFilter = changeFilter
    /**
Facet used to register a hook that gets a chance to update or
replace transaction specs before they are applied. This will
only be applied for transactions that don't have
[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
can either return a single transaction spec (possibly the input
transaction), or an array of specs (which will be combined in
the same way as the arguments to
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

When possible, it is recommended to avoid accessing
[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
since it will force creation of a state that will then be
discarded again, if the transaction is actually filtered.

(This functionality should be used with care. Indiscriminately
modifying transaction is likely to break something or degrade
the user experience.)
*/
    EditorState.transactionFilter = transactionFilter
    /**
This is a more limited form of
[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
which can only add
[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
of filter runs even if the transaction has disabled regular
[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
for effects that don't need to touch the changes or selection,
but do want to process every transaction.

Extenders run _after_ filters, when both are present.
*/
    EditorState.transactionExtender = transactionExtender
    Compartment.reconfigure = /*@__PURE__*/ StateEffect.define()

    /**
Utility function for combining behaviors to fill in a config
object from an array of provided configs. `defaults` should hold
default values for all optional fields in `Config`.

The function will, by default, error
when a field gets two values that aren't `===`-equal, but you can
provide combine functions per field to do something else.
*/
    function combineConfig(
      configs,
      defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
      combine = {}
    ) {
      let result = {}
      for (let config of configs)
        for (let key of Object.keys(config)) {
          let value = config[key],
            current = result[key]
          if (current === undefined) result[key] = value
          else if (current === value || value === undefined);
          else if (Object.hasOwnProperty.call(combine, key))
            // No conflict
            result[key] = combine[key](current, value)
          else throw new Error('Config merge conflict for field ' + key)
        }
      for (let key in defaults)
        if (result[key] === undefined) result[key] = defaults[key]
      return result
    }

    /**
Each range is associated with a value, which must inherit from
this class.
*/
    class RangeValue {
      /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
      eq(other) {
        return this == other
      }
      /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
      range(from, to = from) {
        return Range.create(from, to, this)
      }
    }
    RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0
    RangeValue.prototype.point = false
    RangeValue.prototype.mapMode = MapMode.TrackDel
    /**
A range associates a value with a range of positions.
*/
    class Range {
      constructor(
        /**
    The range's start position.
    */
        from,
        /**
    Its end position.
    */
        to,
        /**
    The value associated with this range.
    */
        value
      ) {
        this.from = from
        this.to = to
        this.value = value
      }
      /**
    @internal
    */
      static create(from, to, value) {
        return new Range(from, to, value)
      }
    }
    function cmpRange(a, b) {
      return a.from - b.from || a.value.startSide - b.value.startSide
    }
    class Chunk {
      constructor(
        from,
        to,
        value,
        // Chunks are marked with the largest point that occurs
        // in them (or -1 for no points), so that scans that are
        // only interested in points (such as the
        // heightmap-related logic) can skip range-only chunks.
        maxPoint
      ) {
        this.from = from
        this.to = to
        this.value = value
        this.maxPoint = maxPoint
      }
      get length() {
        return this.to[this.to.length - 1]
      }
      // Find the index of the given position and side. Use the ranges'
      // `from` pos when `end == false`, `to` when `end == true`.
      findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from
        for (let lo = startAt, hi = arr.length; ; ) {
          if (lo == hi) return lo
          let mid = (lo + hi) >> 1
          let diff =
            arr[mid] - pos ||
            (end ? this.value[mid].endSide : this.value[mid].startSide) - side
          if (mid == lo) return diff >= 0 ? lo : hi
          if (diff >= 0) hi = mid
          else lo = mid + 1
        }
      }
      between(offset, from, to, f) {
        for (
          let i = this.findIndex(from, -1000000000 /* C.Far */, true),
            e = this.findIndex(to, 1000000000 /* C.Far */, false, i);
          i < e;
          i++
        )
          if (
            f(this.from[i] + offset, this.to[i] + offset, this.value[i]) ===
            false
          )
            return false
      }
      map(offset, changes) {
        let value = [],
          from = [],
          to = [],
          newPos = -1,
          maxPoint = -1
        for (let i = 0; i < this.value.length; i++) {
          let val = this.value[i],
            curFrom = this.from[i] + offset,
            curTo = this.to[i] + offset,
            newFrom,
            newTo
          if (curFrom == curTo) {
            let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode)
            if (mapped == null) continue
            newFrom = newTo = mapped
            if (val.startSide != val.endSide) {
              newTo = changes.mapPos(curFrom, val.endSide)
              if (newTo < newFrom) continue
            }
          } else {
            newFrom = changes.mapPos(curFrom, val.startSide)
            newTo = changes.mapPos(curTo, val.endSide)
            if (
              newFrom > newTo ||
              (newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            )
              continue
          }
          if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue
          if (newPos < 0) newPos = newFrom
          if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom)
          value.push(val)
          from.push(newFrom - newPos)
          to.push(newTo - newPos)
        }
        return {
          mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,
          pos: newPos
        }
      }
    }
    /**
A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a
way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and
[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data
structure.
*/
    class dist_RangeSet {
      constructor(
        /**
    @internal
    */
        chunkPos,
        /**
    @internal
    */
        chunk,
        /**
    @internal
    */
        nextLayer,
        /**
    @internal
    */
        maxPoint
      ) {
        this.chunkPos = chunkPos
        this.chunk = chunk
        this.nextLayer = nextLayer
        this.maxPoint = maxPoint
      }
      /**
    @internal
    */
      static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new dist_RangeSet(chunkPos, chunk, nextLayer, maxPoint)
      }
      /**
    @internal
    */
      get length() {
        let last = this.chunk.length - 1
        return last < 0
          ? 0
          : Math.max(this.chunkEnd(last), this.nextLayer.length)
      }
      /**
    The number of ranges in the set.
    */
      get size() {
        if (this.isEmpty) return 0
        let size = this.nextLayer.size
        for (let chunk of this.chunk) size += chunk.value.length
        return size
      }
      /**
    @internal
    */
      chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length
      }
      /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
      update(updateSpec) {
        let {
          add = [],
          sort = false,
          filterFrom = 0,
          filterTo = this.length
        } = updateSpec
        let filter = updateSpec.filter
        if (add.length == 0 && !filter) return this
        if (sort) add = add.slice().sort(cmpRange)
        if (this.isEmpty) return add.length ? dist_RangeSet.of(add) : this
        let cur = new LayerCursor(this, null, -1).goto(0),
          i = 0,
          spill = []
        let builder = new RangeSetBuilder()
        while (cur.value || i < add.length) {
          if (
            i < add.length &&
            (cur.from - add[i].from ||
              cur.startSide - add[i].value.startSide) >= 0
          ) {
            let range = add[i++]
            if (!builder.addInner(range.from, range.to, range.value))
              spill.push(range)
          } else if (
            cur.rangeIndex == 1 &&
            cur.chunkIndex < this.chunk.length &&
            (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
            (!filter ||
              filterFrom > this.chunkEnd(cur.chunkIndex) ||
              filterTo < this.chunkPos[cur.chunkIndex]) &&
            builder.addChunk(
              this.chunkPos[cur.chunkIndex],
              this.chunk[cur.chunkIndex]
            )
          ) {
            cur.nextChunk()
          } else {
            if (
              !filter ||
              filterFrom > cur.to ||
              filterTo < cur.from ||
              filter(cur.from, cur.to, cur.value)
            ) {
              if (!builder.addInner(cur.from, cur.to, cur.value))
                spill.push(Range.create(cur.from, cur.to, cur.value))
            }
            cur.next()
          }
        }
        return builder.finishInner(
          this.nextLayer.isEmpty && !spill.length
            ? dist_RangeSet.empty
            : this.nextLayer.update({
                add: spill,
                filter,
                filterFrom,
                filterTo
              })
        )
      }
      /**
    Map this range set through a set of changes, return the new set.
    */
      map(changes) {
        if (changes.empty || this.isEmpty) return this
        let chunks = [],
          chunkPos = [],
          maxPoint = -1
        for (let i = 0; i < this.chunk.length; i++) {
          let start = this.chunkPos[i],
            chunk = this.chunk[i]
          let touch = changes.touchesRange(start, start + chunk.length)
          if (touch === false) {
            maxPoint = Math.max(maxPoint, chunk.maxPoint)
            chunks.push(chunk)
            chunkPos.push(changes.mapPos(start))
          } else if (touch === true) {
            let { mapped, pos } = chunk.map(start, changes)
            if (mapped) {
              maxPoint = Math.max(maxPoint, mapped.maxPoint)
              chunks.push(mapped)
              chunkPos.push(pos)
            }
          }
        }
        let next = this.nextLayer.map(changes)
        return chunks.length == 0
          ? next
          : new dist_RangeSet(
              chunkPos,
              chunks,
              next || dist_RangeSet.empty,
              maxPoint
            )
      }
      /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
      between(from, to, f) {
        if (this.isEmpty) return
        for (let i = 0; i < this.chunk.length; i++) {
          let start = this.chunkPos[i],
            chunk = this.chunk[i]
          if (
            to >= start &&
            from <= start + chunk.length &&
            chunk.between(start, from - start, to - start, f) === false
          )
            return
        }
        this.nextLayer.between(from, to, f)
      }
      /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
      iter(from = 0) {
        return HeapCursor.from([this]).goto(from)
      }
      /**
    @internal
    */
      get isEmpty() {
        return this.nextLayer == this
      }
      /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
      static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from)
      }
      /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
      static compare(
        oldSets,
        newSets,
        /**
    This indicates how the underlying data changed between these
    ranges, and is needed to synchronize the iteration.
    */
        textDiff,
        comparator,
        /**
    Can be used to ignore all non-point ranges, and points below
    the given size. When -1, all ranges are compared.
    */
        minPointSize = -1
      ) {
        let a = oldSets.filter(
          (set) =>
            set.maxPoint > 0 || (!set.isEmpty && set.maxPoint >= minPointSize)
        )
        let b = newSets.filter(
          (set) =>
            set.maxPoint > 0 || (!set.isEmpty && set.maxPoint >= minPointSize)
        )
        let sharedChunks = findSharedChunks(a, b, textDiff)
        let sideA = new SpanCursor(a, sharedChunks, minPointSize)
        let sideB = new SpanCursor(b, sharedChunks, minPointSize)
        textDiff.iterGaps((fromA, fromB, length) =>
          compare(sideA, fromA, sideB, fromB, length, comparator)
        )
        if (textDiff.empty && textDiff.length == 0)
          compare(sideA, 0, sideB, 0, 0, comparator)
      }
      /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
      static eq(oldSets, newSets, from = 0, to) {
        if (to == null) to = 1000000000 /* C.Far */ - 1
        let a = oldSets.filter(
          (set) => !set.isEmpty && newSets.indexOf(set) < 0
        )
        let b = newSets.filter(
          (set) => !set.isEmpty && oldSets.indexOf(set) < 0
        )
        if (a.length != b.length) return false
        if (!a.length) return true
        let sharedChunks = findSharedChunks(a, b)
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),
          sideB = new SpanCursor(b, sharedChunks, 0).goto(from)
        for (;;) {
          if (
            sideA.to != sideB.to ||
            !sameValues(sideA.active, sideB.active) ||
            (sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          )
            return false
          if (sideA.to > to) return true
          sideA.next()
          sideB.next()
        }
      }
      /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
      static spans(
        sets,
        from,
        to,
        iterator,
        /**
    When given and greater than -1, only points of at least this
    size are taken into account.
    */
        minPointSize = -1
      ) {
        let cursor = new SpanCursor(sets, null, minPointSize).goto(from),
          pos = from
        let openRanges = cursor.openStart
        for (;;) {
          let curTo = Math.min(cursor.to, to)
          if (cursor.point) {
            let active = cursor.activeForPoint(cursor.to)
            let openCount =
              cursor.pointFrom < from
                ? active.length + 1
                : Math.min(active.length, openRanges)
            iterator.point(
              pos,
              curTo,
              cursor.point,
              active,
              openCount,
              cursor.pointRank
            )
            openRanges = Math.min(cursor.openEnd(curTo), active.length)
          } else if (curTo > pos) {
            iterator.span(pos, curTo, cursor.active, openRanges)
            openRanges = cursor.openEnd(curTo)
          }
          if (cursor.to > to)
            return openRanges + (cursor.point && cursor.to > to ? 1 : 0)
          pos = cursor.to
          cursor.next()
        }
      }
      /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
      static of(ranges, sort = false) {
        let build = new RangeSetBuilder()
        for (let range of ranges instanceof Range
          ? [ranges]
          : sort
            ? lazySort(ranges)
            : ranges)
          build.add(range.from, range.to, range.value)
        return build.finish()
      }
    }
    /**
The empty set of ranges.
*/
    dist_RangeSet.empty = /*@__PURE__*/ new dist_RangeSet([], [], null, -1)
    function lazySort(ranges) {
      if (ranges.length > 1)
        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
          let cur = ranges[i]
          if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange)
          prev = cur
        }
      return ranges
    }
    dist_RangeSet.empty.nextLayer = dist_RangeSet.empty
    /**
A range set builder is a data structure that helps build up a
[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating
an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.
*/
    class RangeSetBuilder {
      finishChunk(newArrays) {
        this.chunks.push(
          new Chunk(this.from, this.to, this.value, this.maxPoint)
        )
        this.chunkPos.push(this.chunkStart)
        this.chunkStart = -1
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)
        this.maxPoint = -1
        if (newArrays) {
          this.from = []
          this.to = []
          this.value = []
        }
      }
      /**
    Create an empty builder.
    */
      constructor() {
        this.chunks = []
        this.chunkPos = []
        this.chunkStart = -1
        this.last = null
        this.lastFrom = -1000000000 /* C.Far */
        this.lastTo = -1000000000 /* C.Far */
        this.from = []
        this.to = []
        this.value = []
        this.maxPoint = -1
        this.setMaxPoint = -1
        this.nextLayer = null
      }
      /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
      add(from, to, value) {
        if (!this.addInner(from, to, value))
          (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(
            from,
            to,
            value
          )
      }
      /**
    @internal
    */
      addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide
        if (
          diff <= 0 &&
          (from - this.lastFrom || value.startSide - this.last.startSide) < 0
        )
          throw new Error(
            'Ranges must be added sorted by `from` position and `startSide`'
          )
        if (diff < 0) return false
        if (this.from.length == 250 /* C.ChunkSize */) this.finishChunk(true)
        if (this.chunkStart < 0) this.chunkStart = from
        this.from.push(from - this.chunkStart)
        this.to.push(to - this.chunkStart)
        this.last = value
        this.lastFrom = from
        this.lastTo = to
        this.value.push(value)
        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from)
        return true
      }
      /**
    @internal
    */
      addChunk(from, chunk) {
        if (
          (from - this.lastTo || chunk.value[0].startSide - this.last.endSide) <
          0
        )
          return false
        if (this.from.length) this.finishChunk(true)
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint)
        this.chunks.push(chunk)
        this.chunkPos.push(from)
        let last = chunk.value.length - 1
        this.last = chunk.value[last]
        this.lastFrom = chunk.from[last] + from
        this.lastTo = chunk.to[last] + from
        return true
      }
      /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
      finish() {
        return this.finishInner(dist_RangeSet.empty)
      }
      /**
    @internal
    */
      finishInner(next) {
        if (this.from.length) this.finishChunk(false)
        if (this.chunks.length == 0) return next
        let result = dist_RangeSet.create(
          this.chunkPos,
          this.chunks,
          this.nextLayer ? this.nextLayer.finishInner(next) : next,
          this.setMaxPoint
        )
        this.from = null // Make sure further `add` calls produce errors
        return result
      }
    }
    function findSharedChunks(a, b, textDiff) {
      let inA = new Map()
      for (let set of a)
        for (let i = 0; i < set.chunk.length; i++)
          if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i])
      let shared = new Set()
      for (let set of b)
        for (let i = 0; i < set.chunk.length; i++) {
          let known = inA.get(set.chunk[i])
          if (
            known != null &&
            (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&
            !(textDiff === null || textDiff === void 0
              ? void 0
              : textDiff.touchesRange(known, known + set.chunk[i].length))
          )
            shared.add(set.chunk[i])
        }
      return shared
    }
    class LayerCursor {
      constructor(layer, skip, minPoint, rank = 0) {
        this.layer = layer
        this.skip = skip
        this.minPoint = minPoint
        this.rank = rank
      }
      get startSide() {
        return this.value ? this.value.startSide : 0
      }
      get endSide() {
        return this.value ? this.value.endSide : 0
      }
      goto(pos, side = -1000000000 /* C.Far */) {
        this.chunkIndex = this.rangeIndex = 0
        this.gotoInner(pos, side, false)
        return this
      }
      gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
          let next = this.layer.chunk[this.chunkIndex]
          if (
            !(
              (this.skip && this.skip.has(next)) ||
              this.layer.chunkEnd(this.chunkIndex) < pos ||
              next.maxPoint < this.minPoint
            )
          )
            break
          this.chunkIndex++
          forward = false
        }
        if (this.chunkIndex < this.layer.chunk.length) {
          let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(
            pos - this.layer.chunkPos[this.chunkIndex],
            side,
            true
          )
          if (!forward || this.rangeIndex < rangeIndex)
            this.setRangeIndex(rangeIndex)
        }
        this.next()
      }
      forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
          this.gotoInner(pos, side, true)
      }
      next() {
        for (;;) {
          if (this.chunkIndex == this.layer.chunk.length) {
            this.from = this.to = 1000000000 /* C.Far */
            this.value = null
            break
          } else {
            let chunkPos = this.layer.chunkPos[this.chunkIndex],
              chunk = this.layer.chunk[this.chunkIndex]
            let from = chunkPos + chunk.from[this.rangeIndex]
            this.from = from
            this.to = chunkPos + chunk.to[this.rangeIndex]
            this.value = chunk.value[this.rangeIndex]
            this.setRangeIndex(this.rangeIndex + 1)
            if (
              this.minPoint < 0 ||
              (this.value.point && this.to - this.from >= this.minPoint)
            )
              break
          }
        }
      }
      setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
          this.chunkIndex++
          if (this.skip) {
            while (
              this.chunkIndex < this.layer.chunk.length &&
              this.skip.has(this.layer.chunk[this.chunkIndex])
            )
              this.chunkIndex++
          }
          this.rangeIndex = 0
        } else {
          this.rangeIndex = index
        }
      }
      nextChunk() {
        this.chunkIndex++
        this.rangeIndex = 0
        this.next()
      }
      compare(other) {
        return (
          this.from - other.from ||
          this.startSide - other.startSide ||
          this.rank - other.rank ||
          this.to - other.to ||
          this.endSide - other.endSide
        )
      }
    }
    class HeapCursor {
      constructor(heap) {
        this.heap = heap
      }
      static from(sets, skip = null, minPoint = -1) {
        let heap = []
        for (let i = 0; i < sets.length; i++) {
          for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
            if (cur.maxPoint >= minPoint)
              heap.push(new LayerCursor(cur, skip, minPoint, i))
          }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap)
      }
      get startSide() {
        return this.value ? this.value.startSide : 0
      }
      goto(pos, side = -1000000000 /* C.Far */) {
        for (let cur of this.heap) cur.goto(pos, side)
        for (let i = this.heap.length >> 1; i >= 0; i--)
          heapBubble(this.heap, i)
        this.next()
        return this
      }
      forward(pos, side) {
        for (let cur of this.heap) cur.forward(pos, side)
        for (let i = this.heap.length >> 1; i >= 0; i--)
          heapBubble(this.heap, i)
        if ((this.to - pos || this.value.endSide - side) < 0) this.next()
      }
      next() {
        if (this.heap.length == 0) {
          this.from = this.to = 1000000000 /* C.Far */
          this.value = null
          this.rank = -1
        } else {
          let top = this.heap[0]
          this.from = top.from
          this.to = top.to
          this.value = top.value
          this.rank = top.rank
          if (top.value) top.next()
          heapBubble(this.heap, 0)
        }
      }
    }
    function heapBubble(heap, index) {
      for (let cur = heap[index]; ; ) {
        let childIndex = (index << 1) + 1
        if (childIndex >= heap.length) break
        let child = heap[childIndex]
        if (
          childIndex + 1 < heap.length &&
          child.compare(heap[childIndex + 1]) >= 0
        ) {
          child = heap[childIndex + 1]
          childIndex++
        }
        if (cur.compare(child) < 0) break
        heap[childIndex] = cur
        heap[index] = child
        index = childIndex
      }
    }
    class SpanCursor {
      constructor(sets, skip, minPoint) {
        this.minPoint = minPoint
        this.active = []
        this.activeTo = []
        this.activeRank = []
        this.minActive = -1
        // A currently active point range, if any
        this.point = null
        this.pointFrom = 0
        this.pointRank = 0
        this.to = -1000000000 /* C.Far */
        this.endSide = 0
        // The amount of open active ranges at the start of the iterator.
        // Not including points.
        this.openStart = -1
        this.cursor = HeapCursor.from(sets, skip, minPoint)
      }
      goto(pos, side = -1000000000 /* C.Far */) {
        this.cursor.goto(pos, side)
        this.active.length = this.activeTo.length = this.activeRank.length = 0
        this.minActive = -1
        this.to = pos
        this.endSide = side
        this.openStart = -1
        this.next()
        return this
      }
      forward(pos, side) {
        while (
          this.minActive > -1 &&
          (this.activeTo[this.minActive] - pos ||
            this.active[this.minActive].endSide - side) < 0
        )
          this.removeActive(this.minActive)
        this.cursor.forward(pos, side)
      }
      removeActive(index) {
        remove(this.active, index)
        remove(this.activeTo, index)
        remove(this.activeRank, index)
        this.minActive = findMinIndex(this.active, this.activeTo)
      }
      addActive(trackOpen) {
        let i = 0,
          { value, to, rank } = this.cursor
        while (i < this.activeRank.length && this.activeRank[i] <= rank) i++
        insert(this.active, i, value)
        insert(this.activeTo, i, to)
        insert(this.activeRank, i, rank)
        if (trackOpen) insert(trackOpen, i, this.cursor.from)
        this.minActive = findMinIndex(this.active, this.activeTo)
      }
      // After calling this, if `this.point` != null, the next range is a
      // point. Otherwise, it's a regular range, covered by `this.active`.
      next() {
        let from = this.to,
          wasPoint = this.point
        this.point = null
        let trackOpen = this.openStart < 0 ? [] : null
        for (;;) {
          let a = this.minActive
          if (
            a > -1 &&
            (this.activeTo[a] - this.cursor.from ||
              this.active[a].endSide - this.cursor.startSide) < 0
          ) {
            if (this.activeTo[a] > from) {
              this.to = this.activeTo[a]
              this.endSide = this.active[a].endSide
              break
            }
            this.removeActive(a)
            if (trackOpen) remove(trackOpen, a)
          } else if (!this.cursor.value) {
            this.to = this.endSide = 1000000000 /* C.Far */
            break
          } else if (this.cursor.from > from) {
            this.to = this.cursor.from
            this.endSide = this.cursor.startSide
            break
          } else {
            let nextVal = this.cursor.value
            if (!nextVal.point) {
              // Opening a range
              this.addActive(trackOpen)
              this.cursor.next()
            } else if (
              wasPoint &&
              this.cursor.to == this.to &&
              this.cursor.from < this.cursor.to
            ) {
              // Ignore any non-empty points that end precisely at the end of the prev point
              this.cursor.next()
            } else {
              // New point
              this.point = nextVal
              this.pointFrom = this.cursor.from
              this.pointRank = this.cursor.rank
              this.to = this.cursor.to
              this.endSide = nextVal.endSide
              this.cursor.next()
              this.forward(this.to, this.endSide)
              break
            }
          }
        }
        if (trackOpen) {
          this.openStart = 0
          for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
            this.openStart++
        }
      }
      activeForPoint(to) {
        if (!this.active.length) return this.active
        let active = []
        for (let i = this.active.length - 1; i >= 0; i--) {
          if (this.activeRank[i] < this.pointRank) break
          if (
            this.activeTo[i] > to ||
            (this.activeTo[i] == to &&
              this.active[i].endSide >= this.point.endSide)
          )
            active.push(this.active[i])
        }
        return active.reverse()
      }
      openEnd(to) {
        let open = 0
        for (
          let i = this.activeTo.length - 1;
          i >= 0 && this.activeTo[i] > to;
          i--
        )
          open++
        return open
      }
    }
    function compare(a, startA, b, startB, length, comparator) {
      a.goto(startA)
      b.goto(startB)
      let endB = startB + length
      let pos = startB,
        dPos = startB - startA
      for (;;) {
        let diff = a.to + dPos - b.to || a.endSide - b.endSide
        let end = diff < 0 ? a.to + dPos : b.to,
          clipEnd = Math.min(end, endB)
        if (a.point || b.point) {
          if (
            !(
              a.point &&
              b.point &&
              (a.point == b.point || a.point.eq(b.point)) &&
              sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))
            )
          )
            comparator.comparePoint(pos, clipEnd, a.point, b.point)
        } else {
          if (clipEnd > pos && !sameValues(a.active, b.active))
            comparator.compareRange(pos, clipEnd, a.active, b.active)
        }
        if (end > endB) break
        pos = end
        if (diff <= 0) a.next()
        if (diff >= 0) b.next()
      }
    }
    function sameValues(a, b) {
      if (a.length != b.length) return false
      for (let i = 0; i < a.length; i++)
        if (a[i] != b[i] && !a[i].eq(b[i])) return false
      return true
    }
    function remove(array, index) {
      for (let i = index, e = array.length - 1; i < e; i++)
        array[i] = array[i + 1]
      array.pop()
    }
    function insert(array, index, value) {
      for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i]
      array[index] = value
    }
    function findMinIndex(value, array) {
      let found = -1,
        foundPos = 1000000000 /* C.Far */
      for (let i = 0; i < array.length; i++)
        if (
          (array[i] - foundPos || value[i].endSide - value[found].endSide) < 0
        ) {
          found = i
          foundPos = array[i]
        }
      return found
    }

    /**
Count the column position at the given offset into the string,
taking extending characters and tab size into account.
*/
    function countColumn(string, tabSize, to = string.length) {
      let n = 0
      for (let i = 0; i < to; ) {
        if (string.charCodeAt(i) == 9) {
          n += tabSize - (n % tabSize)
          i++
        } else {
          n++
          i = findClusterBreak(string, i)
        }
      }
      return n
    }
    /**
Find the offset that corresponds to the given column position in a
string, taking extending characters and tab size into account. By
default, the string length is returned when it is too short to
reach the column. Pass `strict` true to make it return -1 in that
situation.
*/
    function findColumn(string, col, tabSize, strict) {
      for (let i = 0, n = 0; ; ) {
        if (n >= col) return i
        if (i == string.length) break
        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1
        i = findClusterBreak(string, i)
      }
      return strict === true ? -1 : string.length
    } // CONCATENATED MODULE: ./node_modules/style-mod/src/style-mod.js

    const C = '\u037c'
    const COUNT = typeof Symbol == 'undefined' ? '__' + C : Symbol.for(C)
    const SET =
      typeof Symbol == 'undefined'
        ? '__styleSet' + Math.floor(Math.random() * 1e8)
        : Symbol('styleSet')
    const style_mod_top =
      typeof globalThis != 'undefined'
        ? globalThis
        : typeof window != 'undefined'
          ? window
          : {}

    // :: - Style modules encapsulate a set of CSS rules defined from
    // JavaScript. Their definitions are only available in a given DOM
    // root after it has been _mounted_ there with `StyleModule.mount`.
    //
    // Style modules should be created once and stored somewhere, as
    // opposed to re-creating them every time you need them. The amount of
    // CSS rules generated for a given DOM root is bounded by the amount
    // of style modules that were used. So to avoid leaking rules, don't
    // create these dynamically, but treat them as one-time allocations.
    class StyleModule {
      // :: (Object<Style>, ?{finish: ?(string) → string})
      // Create a style module from the given spec.
      //
      // When `finish` is given, it is called on regular (non-`@`)
      // selectors (after `&` expansion) to compute the final selector.
      constructor(spec, options) {
        this.rules = []
        let { finish } = options || {}

        function splitSelector(selector) {
          return /^@/.test(selector) ? [selector] : selector.split(/,\s*/)
        }

        function render(selectors, spec, target, isKeyframes) {
          let local = [],
            isAt = /^@(\w+)\b/.exec(selectors[0]),
            keyframes = isAt && isAt[1] == 'keyframes'
          if (isAt && spec == null) return target.push(selectors[0] + ';')
          for (let prop in spec) {
            let value = spec[prop]
            if (/&/.test(prop)) {
              render(
                prop
                  .split(/,\s*/)
                  .map((part) => selectors.map((sel) => part.replace(/&/, sel)))
                  .reduce((a, b) => a.concat(b)),
                value,
                target
              )
            } else if (value && typeof value == 'object') {
              if (!isAt)
                throw new RangeError(
                  'The value of a property (' +
                    prop +
                    ') should be a primitive value.'
                )
              render(splitSelector(prop), value, local, keyframes)
            } else if (value != null) {
              local.push(
                prop
                  .replace(/_.*/, '')
                  .replace(/[A-Z]/g, (l) => '-' + l.toLowerCase()) +
                  ': ' +
                  value +
                  ';'
              )
            }
          }
          if (local.length || keyframes) {
            target.push(
              (finish && !isAt && !isKeyframes
                ? selectors.map(finish)
                : selectors
              ).join(', ') +
                ' {' +
                local.join(' ') +
                '}'
            )
          }
        }

        for (let prop in spec)
          render(splitSelector(prop), spec[prop], this.rules)
      }

      // :: () → string
      // Returns a string containing the module's CSS rules.
      getRules() {
        return this.rules.join('\n')
      }

      // :: () → string
      // Generate a new unique CSS class name.
      static newName() {
        let id = style_mod_top[COUNT] || 1
        style_mod_top[COUNT] = id + 1
        return C + id.toString(36)
      }

      // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
      //
      // Mount the given set of modules in the given DOM root, which ensures
      // that the CSS rules defined by the module are available in that
      // context.
      //
      // Rules are only added to the document once per root.
      //
      // Rule order will follow the order of the modules, so that rules from
      // modules later in the array take precedence of those from earlier
      // modules. If you call this function multiple times for the same root
      // in a way that changes the order of already mounted modules, the old
      // order will be changed.
      //
      // If a Content Security Policy nonce is provided, it is added to
      // the `<style>` tag generated by the library.
      static mount(root, modules, options) {
        let set = root[SET],
          nonce = options && options.nonce
        if (!set) set = new StyleSet(root, nonce)
        else if (nonce) set.setNonce(nonce)
        set.mount(Array.isArray(modules) ? modules : [modules])
      }
    }

    let adoptedSet = new Map() //<Document, StyleSet>

    class StyleSet {
      constructor(root, nonce) {
        let doc = root.ownerDocument || root,
          win = doc.defaultView
        if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
          let adopted = adoptedSet.get(doc)
          if (adopted) {
            root.adoptedStyleSheets = [
              adopted.sheet,
              ...root.adoptedStyleSheets
            ]
            return (root[SET] = adopted)
          }
          this.sheet = new win.CSSStyleSheet()
          root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]
          adoptedSet.set(doc, this)
        } else {
          this.styleTag = doc.createElement('style')
          if (nonce) this.styleTag.setAttribute('nonce', nonce)
          let target = root.head || root
          target.insertBefore(this.styleTag, target.firstChild)
        }
        this.modules = []
        root[SET] = this
      }

      mount(modules) {
        let sheet = this.sheet
        let pos = 0 /* Current rule offset */,
          j = 0 /* Index into this.modules */
        for (let i = 0; i < modules.length; i++) {
          let mod = modules[i],
            index = this.modules.indexOf(mod)
          if (index < j && index > -1) {
            // Ordering conflict
            this.modules.splice(index, 1)
            j--
            index = -1
          }
          if (index == -1) {
            this.modules.splice(j++, 0, mod)
            if (sheet)
              for (let k = 0; k < mod.rules.length; k++)
                sheet.insertRule(mod.rules[k], pos++)
          } else {
            while (j < index) pos += this.modules[j++].rules.length
            pos += mod.rules.length
            j++
          }
        }

        if (!sheet) {
          let text = ''
          for (let i = 0; i < this.modules.length; i++)
            text += this.modules[i].getRules() + '\n'
          this.styleTag.textContent = text
        }
      }

      setNonce(nonce) {
        if (this.styleTag && this.styleTag.getAttribute('nonce') != nonce)
          this.styleTag.setAttribute('nonce', nonce)
      }
    } // CONCATENATED MODULE: ./node_modules/w3c-keyname/index.js

    // Style::Object<union<Style,string>>
    //
    // A style is an object that, in the simple case, maps CSS property
    // names to strings holding their values, as in `{color: "red",
    // fontWeight: "bold"}`. The property names can be given in
    // camel-case—the library will insert a dash before capital letters
    // when converting them to CSS.
    //
    // If you include an underscore in a property name, it and everything
    // after it will be removed from the output, which can be useful when
    // providing a property multiple times, for browser compatibility
    // reasons.
    //
    // A property in a style object can also be a sub-selector, which
    // extends the current context to add a pseudo-selector or a child
    // selector. Such a property should contain a `&` character, which
    // will be replaced by the current selector. For example `{"&:before":
    // {content: '"hi"'}}`. Sub-selectors and regular properties can
    // freely be mixed in a given object. Any property containing a `&` is
    // assumed to be a sub-selector.
    //
    // Finally, a property can specify an @-block to be wrapped around the
    // styles defined inside the object that's the property's value. For
    // example to create a media query you can do `{"@media screen and
    // (min-width: 400px)": {...}}`.

    var base = {
      8: 'Backspace',
      9: 'Tab',
      10: 'Enter',
      12: 'NumLock',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      44: 'PrintScreen',
      45: 'Insert',
      46: 'Delete',
      59: ';',
      61: '=',
      91: 'Meta',
      92: 'Meta',
      106: '*',
      107: '+',
      108: ',',
      109: '-',
      110: '.',
      111: '/',
      144: 'NumLock',
      145: 'ScrollLock',
      160: 'Shift',
      161: 'Shift',
      162: 'Control',
      163: 'Control',
      164: 'Alt',
      165: 'Alt',
      173: '-',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: "'"
    }

    var shift = {
      48: ')',
      49: '!',
      50: '@',
      51: '#',
      52: '$',
      53: '%',
      54: '^',
      55: '&',
      56: '*',
      57: '(',
      59: ':',
      61: '+',
      173: '_',
      186: ':',
      187: '+',
      188: '<',
      189: '_',
      190: '>',
      191: '?',
      192: '~',
      219: '{',
      220: '|',
      221: '}',
      222: '"'
    }

    var mac = typeof navigator != 'undefined' && /Mac/.test(navigator.platform)
    var ie =
      typeof navigator != 'undefined' &&
      /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)

    // Fill in the digit keys
    for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

    // The function keys
    for (var i = 1; i <= 24; i++) base[i + 111] = 'F' + i

    // And the alphabetic keys
    for (var i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32)
      shift[i] = String.fromCharCode(i)
    }

    // For each code that doesn't have a shift-equivalent, copy the base name
    for (var code in base)
      if (!shift.hasOwnProperty(code)) shift[code] = base[code]

    function keyName(event) {
      // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
      // On IE, shift effect is never included in `.key`.
      var ignoreKey =
        (mac &&
          event.metaKey &&
          event.shiftKey &&
          !event.ctrlKey &&
          !event.altKey) ||
        (ie && event.shiftKey && event.key && event.key.length == 1) ||
        event.key == 'Unidentified'
      var name =
        (!ignoreKey && event.key) ||
        (event.shiftKey ? shift : base)[event.keyCode] ||
        event.key ||
        'Unidentified'
      // Edge sometimes produces wrong names (Issue #3)
      if (name == 'Esc') name = 'Escape'
      if (name == 'Del') name = 'Delete'
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
      if (name == 'Left') name = 'ArrowLeft'
      if (name == 'Up') name = 'ArrowUp'
      if (name == 'Right') name = 'ArrowRight'
      if (name == 'Down') name = 'ArrowDown'
      return name
    } // CONCATENATED MODULE: ./node_modules/@codemirror/view/dist/index.js

    function getSelection(root) {
      let target
      // Browsers differ on whether shadow roots have a getSelection
      // method. If it exists, use that, otherwise, call it on the
      // document.
      if (root.nodeType == 11) {
        // Shadow root
        target = root.getSelection ? root : root.ownerDocument
      } else {
        target = root
      }
      return target.getSelection()
    }
    function contains(dom, node) {
      return node
        ? dom == node ||
            dom.contains(node.nodeType != 1 ? node.parentNode : node)
        : false
    }
    function deepActiveElement(doc) {
      let elt = doc.activeElement
      while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement
      return elt
    }
    function hasSelection(dom, selection) {
      if (!selection.anchorNode) return false
      try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return contains(dom, selection.anchorNode)
      } catch (_) {
        return false
      }
    }
    function clientRectsFor(dom) {
      if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects()
      else if (dom.nodeType == 1) return dom.getClientRects()
      else return []
    }
    // Scans forward and backward through DOM positions equivalent to the
    // given one to see if the two are in the same place (i.e. after a
    // text node vs at the end of that text node)
    function isEquivalentPosition(node, off, targetNode, targetOff) {
      return targetNode
        ? scanFor(node, off, targetNode, targetOff, -1) ||
            scanFor(node, off, targetNode, targetOff, 1)
        : false
    }
    function domIndex(node) {
      for (var index = 0; ; index++) {
        node = node.previousSibling
        if (!node) return index
      }
    }
    function scanFor(node, off, targetNode, targetOff, dir) {
      for (;;) {
        if (node == targetNode && off == targetOff) return true
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
          if (node.nodeName == 'DIV') return false
          let parent = node.parentNode
          if (!parent || parent.nodeType != 1) return false
          off = domIndex(node) + (dir < 0 ? 0 : 1)
          node = parent
        } else if (node.nodeType == 1) {
          node = node.childNodes[off + (dir < 0 ? -1 : 0)]
          if (node.nodeType == 1 && node.contentEditable == 'false')
            return false
          off = dir < 0 ? maxOffset(node) : 0
        } else {
          return false
        }
      }
    }
    function maxOffset(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
    }
    function flattenRect(rect, left) {
      let x = left ? rect.left : rect.right
      return { left: x, right: x, top: rect.top, bottom: rect.bottom }
    }
    function windowRect(win) {
      return { left: 0, right: win.innerWidth, top: 0, bottom: win.innerHeight }
    }
    function getScale(elt, rect) {
      let scaleX = rect.width / elt.offsetWidth
      let scaleY = rect.height / elt.offsetHeight
      if (
        (scaleX > 0.995 && scaleX < 1.005) ||
        !isFinite(scaleX) ||
        Math.abs(rect.width - elt.offsetWidth) < 1
      )
        scaleX = 1
      if (
        (scaleY > 0.995 && scaleY < 1.005) ||
        !isFinite(scaleY) ||
        Math.abs(rect.height - elt.offsetHeight) < 1
      )
        scaleY = 1
      return { scaleX, scaleY }
    }
    function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
      let doc = dom.ownerDocument,
        win = doc.defaultView || window
      for (let cur = dom, stop = false; cur && !stop; ) {
        if (cur.nodeType == 1) {
          // Element
          let bounding,
            top = cur == doc.body
          let scaleX = 1,
            scaleY = 1
          if (top) {
            bounding = windowRect(win)
          } else {
            if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
              stop = true
            if (
              cur.scrollHeight <= cur.clientHeight &&
              cur.scrollWidth <= cur.clientWidth
            ) {
              cur = cur.assignedSlot || cur.parentNode
              continue
            }
            let rect = cur.getBoundingClientRect()
            ;({ scaleX, scaleY } = getScale(cur, rect))
            // Make sure scrollbar width isn't included in the rectangle
            bounding = {
              left: rect.left,
              right: rect.left + cur.clientWidth * scaleX,
              top: rect.top,
              bottom: rect.top + cur.clientHeight * scaleY
            }
          }
          let moveX = 0,
            moveY = 0
          if (y == 'nearest') {
            if (rect.top < bounding.top) {
              moveY = -(bounding.top - rect.top + yMargin)
              if (side > 0 && rect.bottom > bounding.bottom + moveY)
                moveY = rect.bottom - bounding.bottom + moveY + yMargin
            } else if (rect.bottom > bounding.bottom) {
              moveY = rect.bottom - bounding.bottom + yMargin
              if (side < 0 && rect.top - moveY < bounding.top)
                moveY = -(bounding.top + moveY - rect.top + yMargin)
            }
          } else {
            let rectHeight = rect.bottom - rect.top,
              boundingHeight = bounding.bottom - bounding.top
            let targetTop =
              y == 'center' && rectHeight <= boundingHeight
                ? rect.top + rectHeight / 2 - boundingHeight / 2
                : y == 'start' || (y == 'center' && side < 0)
                  ? rect.top - yMargin
                  : rect.bottom - boundingHeight + yMargin
            moveY = targetTop - bounding.top
          }
          if (x == 'nearest') {
            if (rect.left < bounding.left) {
              moveX = -(bounding.left - rect.left + xMargin)
              if (side > 0 && rect.right > bounding.right + moveX)
                moveX = rect.right - bounding.right + moveX + xMargin
            } else if (rect.right > bounding.right) {
              moveX = rect.right - bounding.right + xMargin
              if (side < 0 && rect.left < bounding.left + moveX)
                moveX = -(bounding.left + moveX - rect.left + xMargin)
            }
          } else {
            let targetLeft =
              x == 'center'
                ? rect.left +
                  (rect.right - rect.left) / 2 -
                  (bounding.right - bounding.left) / 2
                : (x == 'start') == ltr
                  ? rect.left - xMargin
                  : rect.right - (bounding.right - bounding.left) + xMargin
            moveX = targetLeft - bounding.left
          }
          if (moveX || moveY) {
            if (top) {
              win.scrollBy(moveX, moveY)
            } else {
              let movedX = 0,
                movedY = 0
              if (moveY) {
                let start = cur.scrollTop
                cur.scrollTop += moveY / scaleY
                movedY = (cur.scrollTop - start) * scaleY
              }
              if (moveX) {
                let start = cur.scrollLeft
                cur.scrollLeft += moveX / scaleX
                movedX = (cur.scrollLeft - start) * scaleX
              }
              rect = {
                left: rect.left - movedX,
                top: rect.top - movedY,
                right: rect.right - movedX,
                bottom: rect.bottom - movedY
              }
              if (movedX && Math.abs(movedX - moveX) < 1) x = 'nearest'
              if (movedY && Math.abs(movedY - moveY) < 1) y = 'nearest'
            }
          }
          if (top) break
          cur = cur.assignedSlot || cur.parentNode
        } else if (cur.nodeType == 11) {
          // A shadow root
          cur = cur.host
        } else {
          break
        }
      }
    }
    function scrollableParent(dom) {
      let doc = dom.ownerDocument
      for (let cur = dom.parentNode; cur; ) {
        if (cur == doc.body) {
          break
        } else if (cur.nodeType == 1) {
          if (
            cur.scrollHeight > cur.clientHeight ||
            cur.scrollWidth > cur.clientWidth
          )
            return cur
          cur = cur.assignedSlot || cur.parentNode
        } else if (cur.nodeType == 11) {
          cur = cur.host
        } else {
          break
        }
      }
      return null
    }
    class DOMSelectionState {
      constructor() {
        this.anchorNode = null
        this.anchorOffset = 0
        this.focusNode = null
        this.focusOffset = 0
      }
      eq(domSel) {
        return (
          this.anchorNode == domSel.anchorNode &&
          this.anchorOffset == domSel.anchorOffset &&
          this.focusNode == domSel.focusNode &&
          this.focusOffset == domSel.focusOffset
        )
      }
      setRange(range) {
        let { anchorNode, focusNode } = range
        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)
        this.set(
          anchorNode,
          Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0),
          focusNode,
          Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0)
        )
      }
      set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode
        this.anchorOffset = anchorOffset
        this.focusNode = focusNode
        this.focusOffset = focusOffset
      }
    }
    let preventScrollSupported = null
    // Feature-detects support for .focus({preventScroll: true}), and uses
    // a fallback kludge when not supported.
    function focusPreventScroll(dom) {
      if (dom.setActive) return dom.setActive() // in IE
      if (preventScrollSupported) return dom.focus(preventScrollSupported)
      let stack = []
      for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft)
        if (cur == cur.ownerDocument) break
      }
      dom.focus(
        preventScrollSupported == null
          ? {
              get preventScroll() {
                preventScrollSupported = { preventScroll: true }
                return true
              }
            }
          : undefined
      )
      if (!preventScrollSupported) {
        preventScrollSupported = false
        for (let i = 0; i < stack.length; ) {
          let elt = stack[i++],
            top = stack[i++],
            left = stack[i++]
          if (elt.scrollTop != top) elt.scrollTop = top
          if (elt.scrollLeft != left) elt.scrollLeft = left
        }
      }
    }
    let scratchRange
    function textRange(node, from, to = from) {
      let range = scratchRange || (scratchRange = document.createRange())
      range.setEnd(node, to)
      range.setStart(node, from)
      return range
    }
    function dispatchKey(elt, name, code) {
      let options = {
        key: name,
        code: name,
        keyCode: code,
        which: code,
        cancelable: true
      }
      let down = new KeyboardEvent('keydown', options)
      down.synthetic = true
      elt.dispatchEvent(down)
      let up = new KeyboardEvent('keyup', options)
      up.synthetic = true
      elt.dispatchEvent(up)
      return down.defaultPrevented || up.defaultPrevented
    }
    function getRoot(node) {
      while (node) {
        if (node && (node.nodeType == 9 || (node.nodeType == 11 && node.host)))
          return node
        node = node.assignedSlot || node.parentNode
      }
      return null
    }
    function clearAttributes(node) {
      while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0])
    }
    function atElementStart(doc, selection) {
      let node = selection.focusNode,
        offset = selection.focusOffset
      if (
        !node ||
        selection.anchorNode != node ||
        selection.anchorOffset != offset
      )
        return false
      // Safari can report bogus offsets (#1152)
      offset = Math.min(offset, maxOffset(node))
      for (;;) {
        if (offset) {
          if (node.nodeType != 1) return false
          let prev = node.childNodes[offset - 1]
          if (prev.contentEditable == 'false') offset--
          else {
            node = prev
            offset = maxOffset(node)
          }
        } else if (node == doc) {
          return true
        } else {
          offset = domIndex(node)
          node = node.parentNode
        }
      }
    }
    function isScrolledToBottom(elt) {
      return (
        elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4)
      )
    }

    class DOMPos {
      constructor(node, offset, precise = true) {
        this.node = node
        this.offset = offset
        this.precise = precise
      }
      static before(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom), precise)
      }
      static after(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise)
      }
    }
    const noChildren = []
    class ContentView {
      constructor() {
        this.parent = null
        this.dom = null
        this.flags = 2 /* ViewFlag.NodeDirty */
      }
      get overrideDOMText() {
        return null
      }
      get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0
      }
      get posAtEnd() {
        return this.posAtStart + this.length
      }
      posBefore(view) {
        let pos = this.posAtStart
        for (let child of this.children) {
          if (child == view) return pos
          pos += child.length + child.breakAfter
        }
        throw new RangeError('Invalid child in posBefore')
      }
      posAfter(view) {
        return this.posBefore(view) + view.length
      }
      sync(view, track) {
        if (this.flags & 2 /* ViewFlag.NodeDirty */) {
          let parent = this.dom
          let prev = null,
            next
          for (let child of this.children) {
            if (child.flags & 7 /* ViewFlag.Dirty */) {
              if (
                !child.dom &&
                (next = prev ? prev.nextSibling : parent.firstChild)
              ) {
                let contentView = ContentView.get(next)
                if (
                  !contentView ||
                  (!contentView.parent && contentView.canReuseDOM(child))
                )
                  child.reuseDOM(next)
              }
              child.sync(view, track)
              child.flags &= ~7 /* ViewFlag.Dirty */
            }
            next = prev ? prev.nextSibling : parent.firstChild
            if (
              track &&
              !track.written &&
              track.node == parent &&
              next != child.dom
            )
              track.written = true
            if (child.dom.parentNode == parent) {
              while (next && next != child.dom) next = rm$1(next)
            } else {
              parent.insertBefore(child.dom, next)
            }
            prev = child.dom
          }
          next = prev ? prev.nextSibling : parent.firstChild
          if (next && track && track.node == parent) track.written = true
          while (next) next = rm$1(next)
        } else if (this.flags & 1 /* ViewFlag.ChildDirty */) {
          for (let child of this.children)
            if (child.flags & 7 /* ViewFlag.Dirty */) {
              child.sync(view, track)
              child.flags &= ~7 /* ViewFlag.Dirty */
            }
        }
      }
      reuseDOM(_dom) {}
      localPosFromDOM(node, offset) {
        let after
        if (node == this.dom) {
          after = this.dom.childNodes[offset]
        } else {
          let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1
          for (;;) {
            let parent = node.parentNode
            if (parent == this.dom) break
            if (bias == 0 && parent.firstChild != parent.lastChild) {
              if (node == parent.firstChild) bias = -1
              else bias = 1
            }
            node = parent
          }
          if (bias < 0) after = node
          else after = node.nextSibling
        }
        if (after == this.dom.firstChild) return 0
        while (after && !ContentView.get(after)) after = after.nextSibling
        if (!after) return this.length
        for (let i = 0, pos = 0; ; i++) {
          let child = this.children[i]
          if (child.dom == after) return pos
          pos += child.length + child.breakAfter
        }
      }
      domBoundsAround(from, to, offset = 0) {
        let fromI = -1,
          fromStart = -1,
          toI = -1,
          toEnd = -1
        for (
          let i = 0, pos = offset, prevEnd = offset;
          i < this.children.length;
          i++
        ) {
          let child = this.children[i],
            end = pos + child.length
          if (pos < from && end > to)
            return child.domBoundsAround(from, to, pos)
          if (end >= from && fromI == -1) {
            fromI = i
            fromStart = pos
          }
          if (pos > to && child.dom.parentNode == this.dom) {
            toI = i
            toEnd = prevEnd
            break
          }
          prevEnd = end
          pos = end + child.breakAfter
        }
        return {
          from: fromStart,
          to: toEnd < 0 ? offset + this.length : toEnd,
          startDOM:
            (fromI ? this.children[fromI - 1].dom.nextSibling : null) ||
            this.dom.firstChild,
          endDOM:
            toI < this.children.length && toI >= 0
              ? this.children[toI].dom
              : null
        }
      }
      markDirty(andParent = false) {
        this.flags |= 2 /* ViewFlag.NodeDirty */
        this.markParentsDirty(andParent)
      }
      markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
          if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */
          if (parent.flags & 1 /* ViewFlag.ChildDirty */) return
          parent.flags |= 1 /* ViewFlag.ChildDirty */
          childList = false
        }
      }
      setParent(parent) {
        if (this.parent != parent) {
          this.parent = parent
          if (this.flags & 7 /* ViewFlag.Dirty */) this.markParentsDirty(true)
        }
      }
      setDOM(dom) {
        if (this.dom == dom) return
        if (this.dom) this.dom.cmView = null
        this.dom = dom
        dom.cmView = this
      }
      get rootView() {
        for (let v = this; ; ) {
          let parent = v.parent
          if (!parent) return v
          v = parent
        }
      }
      replaceChildren(from, to, children = noChildren) {
        this.markDirty()
        for (let i = from; i < to; i++) {
          let child = this.children[i]
          if (child.parent == this && children.indexOf(child) < 0)
            child.destroy()
        }
        this.children.splice(from, to - from, ...children)
        for (let i = 0; i < children.length; i++) children[i].setParent(this)
      }
      ignoreMutation(_rec) {
        return false
      }
      ignoreEvent(_event) {
        return false
      }
      childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length)
      }
      childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias)
      }
      toString() {
        let name = this.constructor.name.replace('View', '')
        return (
          name +
          (this.children.length
            ? '(' + this.children.join() + ')'
            : this.length
              ? '[' + (name == 'Text' ? this.text : this.length) + ']'
              : '') +
          (this.breakAfter ? '#' : '')
        )
      }
      static get(node) {
        return node.cmView
      }
      get isEditable() {
        return true
      }
      get isWidget() {
        return false
      }
      get isHidden() {
        return false
      }
      merge(from, to, source, hasStart, openStart, openEnd) {
        return false
      }
      become(other) {
        return false
      }
      canReuseDOM(other) {
        return (
          other.constructor == this.constructor &&
          !(((this.flags | other.flags) & 8) /* ViewFlag.Composition */)
        )
      }
      // When this is a zero-length view with a side, this should return a
      // number <= 0 to indicate it is before its position, or a
      // number > 0 when after its position.
      getSide() {
        return 0
      }
      destroy() {
        for (let child of this.children)
          if (child.parent == this) child.destroy()
        this.parent = null
      }
    }
    ContentView.prototype.breakAfter = 0
    // Remove a DOM node and return its next sibling.
    function rm$1(dom) {
      let next = dom.nextSibling
      dom.parentNode.removeChild(dom)
      return next
    }
    class ChildCursor {
      constructor(children, pos, i) {
        this.children = children
        this.pos = pos
        this.i = i
        this.off = 0
      }
      findPos(pos, bias = 1) {
        for (;;) {
          if (
            pos > this.pos ||
            (pos == this.pos &&
              (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
          ) {
            this.off = pos - this.pos
            return this
          }
          let next = this.children[--this.i]
          this.pos -= next.length + next.breakAfter
        }
      }
    }
    function replaceRange(
      parent,
      fromI,
      fromOff,
      toI,
      toOff,
      insert,
      breakAtStart,
      openStart,
      openEnd
    ) {
      let { children } = parent
      let before = children.length ? children[fromI] : null
      let last = insert.length ? insert[insert.length - 1] : null
      let breakAtEnd = last ? last.breakAfter : breakAtStart
      // Change within a single child
      if (
        fromI == toI &&
        before &&
        !breakAtStart &&
        !breakAtEnd &&
        insert.length < 2 &&
        before.merge(
          fromOff,
          toOff,
          insert.length ? last : null,
          fromOff == 0,
          openStart,
          openEnd
        )
      )
        return
      if (toI < children.length) {
        let after = children[toI]
        // Make sure the end of the child after the update is preserved in `after`
        if (
          after &&
          (toOff < after.length ||
            (after.breakAfter &&
              (last === null || last === void 0 ? void 0 : last.breakAfter)))
        ) {
          // If we're splitting a child, separate part of it to avoid that
          // being mangled when updating the child before the update.
          if (fromI == toI) {
            after = after.split(toOff)
            toOff = 0
          }
          // If the element after the replacement should be merged with
          // the last replacing element, update `content`
          if (
            !breakAtEnd &&
            last &&
            after.merge(0, toOff, last, true, 0, openEnd)
          ) {
            insert[insert.length - 1] = after
          } else {
            // Remove the start of the after element, if necessary, and
            // add it to `content`.
            if (toOff || (after.children.length && !after.children[0].length))
              after.merge(0, toOff, null, false, 0, openEnd)
            insert.push(after)
          }
        } else if (
          after === null || after === void 0 ? void 0 : after.breakAfter
        ) {
          // The element at `toI` is entirely covered by this range.
          // Preserve its line break, if any.
          if (last) last.breakAfter = 1
          else breakAtStart = 1
        }
        // Since we've handled the next element from the current elements
        // now, make sure `toI` points after that.
        toI++
      }
      if (before) {
        before.breakAfter = breakAtStart
        if (fromOff > 0) {
          if (
            !breakAtStart &&
            insert.length &&
            before.merge(fromOff, before.length, insert[0], false, openStart, 0)
          ) {
            before.breakAfter = insert.shift().breakAfter
          } else if (
            fromOff < before.length ||
            (before.children.length &&
              before.children[before.children.length - 1].length == 0)
          ) {
            before.merge(fromOff, before.length, null, false, openStart, 0)
          }
          fromI++
        }
      }
      // Try to merge widgets on the boundaries of the replacement
      while (fromI < toI && insert.length) {
        if (children[toI - 1].become(insert[insert.length - 1])) {
          toI--
          insert.pop()
          openEnd = insert.length ? 0 : openStart
        } else if (children[fromI].become(insert[0])) {
          fromI++
          insert.shift()
          openStart = insert.length ? 0 : openEnd
        } else {
          break
        }
      }
      if (
        !insert.length &&
        fromI &&
        toI < children.length &&
        !children[fromI - 1].breakAfter &&
        children[toI].merge(
          0,
          0,
          children[fromI - 1],
          false,
          openStart,
          openEnd
        )
      )
        fromI--
      if (fromI < toI || insert.length)
        parent.replaceChildren(fromI, toI, insert)
    }
    function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
      let cur = parent.childCursor()
      let { i: toI, off: toOff } = cur.findPos(to, 1)
      let { i: fromI, off: fromOff } = cur.findPos(from, -1)
      let dLen = from - to
      for (let view of insert) dLen += view.length
      parent.length += dLen
      replaceRange(
        parent,
        fromI,
        fromOff,
        toI,
        toOff,
        insert,
        0,
        openStart,
        openEnd
      )
    }

    let nav =
      typeof navigator != 'undefined'
        ? navigator
        : { userAgent: '', vendor: '', platform: '' }
    let doc =
      typeof document != 'undefined'
        ? document
        : { documentElement: { style: {} } }
    const ie_edge = /*@__PURE__*/ /Edge\/(\d+)/.exec(nav.userAgent)
    const ie_upto10 = /*@__PURE__*/ /MSIE \d/.test(nav.userAgent)
    const ie_11up = /*@__PURE__*/ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
      nav.userAgent
    )
    const dist_ie = !!(ie_upto10 || ie_11up || ie_edge)
    const gecko = !dist_ie && /*@__PURE__*/ /gecko\/(\d+)/i.test(nav.userAgent)
    const chrome = !dist_ie && /*@__PURE__*/ /Chrome\/(\d+)/.exec(nav.userAgent)
    const webkit = 'webkitFontSmoothing' in doc.documentElement.style
    const safari = !dist_ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor)
    const ios =
      safari &&
      /*@__PURE__*/ (/Mobile\/\w+/.test(nav.userAgent) ||
        nav.maxTouchPoints > 2)
    var browser = {
      mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),
      windows: /*@__PURE__*/ /Win/.test(nav.platform),
      linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),
      ie: dist_ie,
      ie_version: ie_upto10
        ? doc.documentMode || 6
        : ie_11up
          ? +ie_11up[1]
          : ie_edge
            ? +ie_edge[1]
            : 0,
      gecko,
      gecko_version: gecko
        ? +/*@__PURE__*/ (/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1]
        : 0,
      chrome: !!chrome,
      chrome_version: chrome ? +chrome[1] : 0,
      ios,
      android: /*@__PURE__*/ /Android\b/.test(nav.userAgent),
      webkit,
      safari,
      webkit_version: webkit
        ? +/*@__PURE__*/ (/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [
            0, 0
          ])[1]
        : 0,
      tabSize:
        doc.documentElement.style.tabSize != null ? 'tab-size' : '-moz-tab-size'
    }

    const MaxJoinLen = 256
    class TextView extends ContentView {
      constructor(text) {
        super()
        this.text = text
      }
      get length() {
        return this.text.length
      }
      createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text))
      }
      sync(view, track) {
        if (!this.dom) this.createDOM()
        if (this.dom.nodeValue != this.text) {
          if (track && track.node == this.dom) track.written = true
          this.dom.nodeValue = this.text
        }
      }
      reuseDOM(dom) {
        if (dom.nodeType == 3) this.createDOM(dom)
      }
      merge(from, to, source) {
        if (
          this.flags & 8 /* ViewFlag.Composition */ ||
          (source &&
            (!(source instanceof TextView) ||
              this.length - (to - from) + source.length > MaxJoinLen ||
              source.flags & 8 /* ViewFlag.Composition */))
        )
          return false
        this.text =
          this.text.slice(0, from) +
          (source ? source.text : '') +
          this.text.slice(to)
        this.markDirty()
        return true
      }
      split(from) {
        let result = new TextView(this.text.slice(from))
        this.text = this.text.slice(0, from)
        this.markDirty()
        result.flags |= this.flags & 8 /* ViewFlag.Composition */
        return result
      }
      localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0
      }
      domAtPos(pos) {
        return new DOMPos(this.dom, pos)
      }
      domBoundsAround(_from, _to, offset) {
        return {
          from: offset,
          to: offset + this.length,
          startDOM: this.dom,
          endDOM: this.dom.nextSibling
        }
      }
      coordsAt(pos, side) {
        return textCoords(this.dom, pos, side)
      }
    }
    class MarkView extends ContentView {
      constructor(mark, children = [], length = 0) {
        super()
        this.mark = mark
        this.children = children
        this.length = length
        for (let ch of children) ch.setParent(this)
      }
      setAttrs(dom) {
        clearAttributes(dom)
        if (this.mark.class) dom.className = this.mark.class
        if (this.mark.attrs)
          for (let name in this.mark.attrs)
            dom.setAttribute(name, this.mark.attrs[name])
        return dom
      }
      canReuseDOM(other) {
        return (
          super.canReuseDOM(other) &&
          !(((this.flags | other.flags) & 8) /* ViewFlag.Composition */)
        )
      }
      reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
          this.setDOM(node)
          this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */
        }
      }
      sync(view, track) {
        if (!this.dom)
          this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)))
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */)
          this.setAttrs(this.dom)
        super.sync(view, track)
      }
      merge(from, to, source, _hasStart, openStart, openEnd) {
        if (
          source &&
          (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) ||
            (to < this.length && openEnd <= 0))
        )
          return false
        mergeChildrenInto(
          this,
          from,
          to,
          source ? source.children.slice() : [],
          openStart - 1,
          openEnd - 1
        )
        this.markDirty()
        return true
      }
      split(from) {
        let result = [],
          off = 0,
          detachFrom = -1,
          i = 0
        for (let elt of this.children) {
          let end = off + elt.length
          if (end > from) result.push(off < from ? elt.split(from - off) : elt)
          if (detachFrom < 0 && off >= from) detachFrom = i
          off = end
          i++
        }
        let length = this.length - from
        this.length = from
        if (detachFrom > -1) {
          this.children.length = detachFrom
          this.markDirty()
        }
        return new MarkView(this.mark, result, length)
      }
      domAtPos(pos) {
        return inlineDOMAtPos(this, pos)
      }
      coordsAt(pos, side) {
        return coordsInChildren(this, pos, side)
      }
    }
    function textCoords(text, pos, side) {
      let length = text.nodeValue.length
      if (pos > length) pos = length
      let from = pos,
        to = pos,
        flatten = 0
      if ((pos == 0 && side < 0) || (pos == length && side >= 0)) {
        if (!(browser.chrome || browser.gecko)) {
          // These browsers reliably return valid rectangles for empty ranges
          if (pos) {
            from--
            flatten = 1
          } // FIXME this is wrong in RTL text
          else if (to < length) {
            to++
            flatten = -1
          }
        }
      } else {
        if (side < 0) from--
        else if (to < length) to++
      }
      let rects = textRange(text, from, to).getClientRects()
      if (!rects.length) return null
      let rect =
        rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1]
      if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, (r) => r.width) || rect
      return flatten ? flattenRect(rect, flatten < 0) : rect || null
    }
    // Also used for collapsed ranges that don't have a placeholder widget!
    class WidgetView extends ContentView {
      static create(widget, length, side) {
        return new WidgetView(widget, length, side)
      }
      constructor(widget, length, side) {
        super()
        this.widget = widget
        this.length = length
        this.side = side
        this.prevWidget = null
      }
      split(from) {
        let result = WidgetView.create(
          this.widget,
          this.length - from,
          this.side
        )
        this.length -= from
        return result
      }
      sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom)
          this.prevWidget = null
          this.setDOM(this.widget.toDOM(view))
          this.dom.contentEditable = 'false'
        }
      }
      getSide() {
        return this.side
      }
      merge(from, to, source, hasStart, openStart, openEnd) {
        if (
          source &&
          (!(source instanceof WidgetView) ||
            !this.widget.compare(source.widget) ||
            (from > 0 && openStart <= 0) ||
            (to < this.length && openEnd <= 0))
        )
          return false
        this.length = from + (source ? source.length : 0) + (this.length - to)
        return true
      }
      become(other) {
        if (
          other instanceof WidgetView &&
          other.side == this.side &&
          this.widget.constructor == other.widget.constructor
        ) {
          if (!this.widget.compare(other.widget)) this.markDirty(true)
          if (this.dom && !this.prevWidget) this.prevWidget = this.widget
          this.widget = other.widget
          this.length = other.length
          return true
        }
        return false
      }
      ignoreMutation() {
        return true
      }
      ignoreEvent(event) {
        return this.widget.ignoreEvent(event)
      }
      get overrideDOMText() {
        if (this.length == 0) return Text.empty
        let top = this
        while (top.parent) top = top.parent
        let { view } = top,
          text = view && view.state.doc,
          start = this.posAtStart
        return text ? text.slice(start, start + this.length) : Text.empty
      }
      domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0)
          ? DOMPos.before(this.dom)
          : DOMPos.after(this.dom, pos == this.length)
      }
      domBoundsAround() {
        return null
      }
      coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side)
        if (custom) return custom
        let rects = this.dom.getClientRects(),
          rect = null
        if (!rects.length) return null
        let fromBack = this.side ? this.side < 0 : pos > 0
        for (
          let i = fromBack ? rects.length - 1 : 0;
          ;
          i += fromBack ? -1 : 1
        ) {
          rect = rects[i]
          if (
            pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom
          )
            break
        }
        return flattenRect(rect, !fromBack)
      }
      get isEditable() {
        return false
      }
      get isWidget() {
        return true
      }
      get isHidden() {
        return this.widget.isHidden
      }
      destroy() {
        super.destroy()
        if (this.dom) this.widget.destroy(this.dom)
      }
    }
    // These are drawn around uneditable widgets to avoid a number of
    // browser bugs that show up when the cursor is directly next to
    // uneditable inline content.
    class WidgetBufferView extends ContentView {
      constructor(side) {
        super()
        this.side = side
      }
      get length() {
        return 0
      }
      merge() {
        return false
      }
      become(other) {
        return other instanceof WidgetBufferView && other.side == this.side
      }
      split() {
        return new WidgetBufferView(this.side)
      }
      sync() {
        if (!this.dom) {
          let dom = document.createElement('img')
          dom.className = 'cm-widgetBuffer'
          dom.setAttribute('aria-hidden', 'true')
          this.setDOM(dom)
        }
      }
      getSide() {
        return this.side
      }
      domAtPos(pos) {
        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom)
      }
      localPosFromDOM() {
        return 0
      }
      domBoundsAround() {
        return null
      }
      coordsAt(pos) {
        return this.dom.getBoundingClientRect()
      }
      get overrideDOMText() {
        return Text.empty
      }
      get isHidden() {
        return true
      }
    }
    TextView.prototype.children =
      WidgetView.prototype.children =
      WidgetBufferView.prototype.children =
        noChildren
    function inlineDOMAtPos(parent, pos) {
      let dom = parent.dom,
        { children } = parent,
        i = 0
      for (let off = 0; i < children.length; i++) {
        let child = children[i],
          end = off + child.length
        if (end == off && child.getSide() <= 0) continue
        if (pos > off && pos < end && child.dom.parentNode == dom)
          return child.domAtPos(pos - off)
        if (pos <= off) break
        off = end
      }
      for (let j = i; j > 0; j--) {
        let prev = children[j - 1]
        if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length)
      }
      for (let j = i; j < children.length; j++) {
        let next = children[j]
        if (next.dom.parentNode == dom) return next.domAtPos(0)
      }
      return new DOMPos(dom, 0)
    }
    // Assumes `view`, if a mark view, has precisely 1 child.
    function joinInlineInto(parent, view, open) {
      let last,
        { children } = parent
      if (
        open > 0 &&
        view instanceof MarkView &&
        children.length &&
        (last = children[children.length - 1]) instanceof MarkView &&
        last.mark.eq(view.mark)
      ) {
        joinInlineInto(last, view.children[0], open - 1)
      } else {
        children.push(view)
        view.setParent(parent)
      }
      parent.length += view.length
    }
    function coordsInChildren(view, pos, side) {
      let before = null,
        beforePos = -1,
        after = null,
        afterPos = -1
      function scan(view, pos) {
        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
          let child = view.children[i],
            end = off + child.length
          if (end >= pos) {
            if (child.children.length) {
              scan(child, pos - off)
            } else if (
              (!after || (after.isHidden && side > 0)) &&
              (end > pos || (off == end && child.getSide() > 0))
            ) {
              after = child
              afterPos = pos - off
            } else if (
              off < pos ||
              (off == end && child.getSide() < 0 && !child.isHidden)
            ) {
              before = child
              beforePos = pos - off
            }
          }
          off = end
        }
      }
      scan(view, pos)
      let target = (side < 0 ? before : after) || before || after
      if (target)
        return target.coordsAt(
          Math.max(0, target == before ? beforePos : afterPos),
          side
        )
      return fallbackRect(view)
    }
    function fallbackRect(view) {
      let last = view.dom.lastChild
      if (!last) return view.dom.getBoundingClientRect()
      let rects = clientRectsFor(last)
      return rects[rects.length - 1] || null
    }

    function combineAttrs(source, target) {
      for (let name in source) {
        if (name == 'class' && target.class) target.class += ' ' + source.class
        else if (name == 'style' && target.style)
          target.style += ';' + source.style
        else target[name] = source[name]
      }
      return target
    }
    const noAttrs = /*@__PURE__*/ Object.create(null)
    function attrsEq(a, b, ignore) {
      if (a == b) return true
      if (!a) a = noAttrs
      if (!b) b = noAttrs
      let keysA = Object.keys(a),
        keysB = Object.keys(b)
      if (
        keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
        keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)
      )
        return false
      for (let key of keysA) {
        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
          return false
      }
      return true
    }
    function updateAttrs(dom, prev, attrs) {
      let changed = false
      if (prev)
        for (let name in prev)
          if (!(attrs && name in attrs)) {
            changed = true
            if (name == 'style') dom.style.cssText = ''
            else dom.removeAttribute(name)
          }
      if (attrs)
        for (let name in attrs)
          if (!(prev && prev[name] == attrs[name])) {
            changed = true
            if (name == 'style') dom.style.cssText = attrs[name]
            else dom.setAttribute(name, attrs[name])
          }
      return changed
    }
    function getAttrs(dom) {
      let attrs = Object.create(null)
      for (let i = 0; i < dom.attributes.length; i++) {
        let attr = dom.attributes[i]
        attrs[attr.name] = attr.value
      }
      return attrs
    }

    class LineView extends ContentView {
      constructor() {
        super(...arguments)
        this.children = []
        this.length = 0
        this.prevAttrs = undefined
        this.attrs = null
        this.breakAfter = 0
      }
      // Consumes source
      merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
          if (!(source instanceof LineView)) return false
          if (!this.dom) source.transferDOM(this) // Reuse source.dom when appropriate
        }
        if (hasStart) this.setDeco(source ? source.attrs : null)
        mergeChildrenInto(
          this,
          from,
          to,
          source ? source.children.slice() : [],
          openStart,
          openEnd
        )
        return true
      }
      split(at) {
        let end = new LineView()
        end.breakAfter = this.breakAfter
        if (this.length == 0) return end
        let { i, off } = this.childPos(at)
        if (off) {
          end.append(this.children[i].split(off), 0)
          this.children[i].merge(
            off,
            this.children[i].length,
            null,
            false,
            0,
            0
          )
          i++
        }
        for (let j = i; j < this.children.length; j++)
          end.append(this.children[j], 0)
        while (i > 0 && this.children[i - 1].length == 0)
          this.children[--i].destroy()
        this.children.length = i
        this.markDirty()
        this.length = at
        return end
      }
      transferDOM(other) {
        if (!this.dom) return
        this.markDirty()
        other.setDOM(this.dom)
        other.prevAttrs =
          this.prevAttrs === undefined ? this.attrs : this.prevAttrs
        this.prevAttrs = undefined
        this.dom = null
      }
      setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
          if (this.dom) {
            this.prevAttrs = this.attrs
            this.markDirty()
          }
          this.attrs = attrs
        }
      }
      append(child, openStart) {
        joinInlineInto(this, child, openStart)
      }
      // Only called when building a line view in ContentBuilder
      addLineDeco(deco) {
        let attrs = deco.spec.attributes,
          cls = deco.spec.class
        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {})
        if (cls) this.attrs = combineAttrs({ class: cls }, this.attrs || {})
      }
      domAtPos(pos) {
        return inlineDOMAtPos(this, pos)
      }
      reuseDOM(node) {
        if (node.nodeName == 'DIV') {
          this.setDOM(node)
          this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */
        }
      }
      sync(view, track) {
        var _a
        if (!this.dom) {
          this.setDOM(document.createElement('div'))
          this.dom.className = 'cm-line'
          this.prevAttrs = this.attrs ? null : undefined
        } else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {
          clearAttributes(this.dom)
          this.dom.className = 'cm-line'
          this.prevAttrs = this.attrs ? null : undefined
        }
        if (this.prevAttrs !== undefined) {
          updateAttrs(this.dom, this.prevAttrs, this.attrs)
          this.dom.classList.add('cm-line')
          this.prevAttrs = undefined
        }
        super.sync(view, track)
        let last = this.dom.lastChild
        while (last && ContentView.get(last) instanceof MarkView)
          last = last.lastChild
        if (
          !last ||
          !this.length ||
          (last.nodeName != 'BR' &&
            ((_a = ContentView.get(last)) === null || _a === void 0
              ? void 0
              : _a.isEditable) == false &&
            (!browser.ios ||
              !this.children.some((ch) => ch instanceof TextView)))
        ) {
          let hack = document.createElement('BR')
          hack.cmIgnore = true
          this.dom.appendChild(hack)
        }
      }
      measureTextSize() {
        if (this.children.length == 0 || this.length > 20) return null
        let totalWidth = 0,
          textHeight
        for (let child of this.children) {
          if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
            return null
          let rects = clientRectsFor(child.dom)
          if (rects.length != 1) return null
          totalWidth += rects[0].width
          textHeight = rects[0].height
        }
        return !totalWidth
          ? null
          : {
              lineHeight: this.dom.getBoundingClientRect().height,
              charWidth: totalWidth / this.length,
              textHeight
            }
      }
      coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side)
        // Correct rectangle height for empty lines when the returned
        // height is larger than the text height.
        if (!this.children.length && rect && this.parent) {
          let { heightOracle } = this.parent.view.viewState,
            height = rect.bottom - rect.top
          if (
            Math.abs(height - heightOracle.lineHeight) < 2 &&
            heightOracle.textHeight < height
          ) {
            let dist = (height - heightOracle.textHeight) / 2
            return {
              top: rect.top + dist,
              bottom: rect.bottom - dist,
              left: rect.left,
              right: rect.left
            }
          }
        }
        return rect
      }
      become(_other) {
        return false
      }
      covers() {
        return true
      }
      static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
          let block = docView.children[i],
            end = off + block.length
          if (end >= pos) {
            if (block instanceof LineView) return block
            if (end > pos) break
          }
          off = end + block.breakAfter
        }
        return null
      }
    }
    class BlockWidgetView extends ContentView {
      constructor(widget, length, deco) {
        super()
        this.widget = widget
        this.length = length
        this.deco = deco
        this.breakAfter = 0
        this.prevWidget = null
      }
      merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (
          source &&
          (!(source instanceof BlockWidgetView) ||
            !this.widget.compare(source.widget) ||
            (from > 0 && openStart <= 0) ||
            (to < this.length && openEnd <= 0))
        )
          return false
        this.length = from + (source ? source.length : 0) + (this.length - to)
        return true
      }
      domAtPos(pos) {
        return pos == 0
          ? DOMPos.before(this.dom)
          : DOMPos.after(this.dom, pos == this.length)
      }
      split(at) {
        let len = this.length - at
        this.length = at
        let end = new BlockWidgetView(this.widget, len, this.deco)
        end.breakAfter = this.breakAfter
        return end
      }
      get children() {
        return noChildren
      }
      sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom)
          this.prevWidget = null
          this.setDOM(this.widget.toDOM(view))
          this.dom.contentEditable = 'false'
        }
      }
      get overrideDOMText() {
        return this.parent
          ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd)
          : Text.empty
      }
      domBoundsAround() {
        return null
      }
      become(other) {
        if (
          other instanceof BlockWidgetView &&
          other.widget.constructor == this.widget.constructor
        ) {
          if (!other.widget.compare(this.widget)) this.markDirty(true)
          if (this.dom && !this.prevWidget) this.prevWidget = this.widget
          this.widget = other.widget
          this.length = other.length
          this.deco = other.deco
          this.breakAfter = other.breakAfter
          return true
        }
        return false
      }
      ignoreMutation() {
        return true
      }
      ignoreEvent(event) {
        return this.widget.ignoreEvent(event)
      }
      get isEditable() {
        return false
      }
      get isWidget() {
        return true
      }
      coordsAt(pos, side) {
        return this.widget.coordsAt(this.dom, pos, side)
      }
      destroy() {
        super.destroy()
        if (this.dom) this.widget.destroy(this.dom)
      }
      covers(side) {
        let { startSide, endSide } = this.deco
        return startSide == endSide
          ? false
          : side < 0
            ? startSide < 0
            : endSide > 0
      }
    }

    /**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even if the decorations
that define them are recreated.
*/
    class WidgetType {
      /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
      eq(widget) {
        return false
      }
      /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
      updateDOM(dom, view) {
        return false
      }
      /**
    @internal
    */
      compare(other) {
        return (
          this == other ||
          (this.constructor == other.constructor && this.eq(other))
        )
      }
      /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
      get estimatedHeight() {
        return -1
      }
      /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
      get lineBreaks() {
        return 0
      }
      /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
      ignoreEvent(event) {
        return true
      }
      /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queried—less than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
      coordsAt(dom, pos, side) {
        return null
      }
      /**
    @internal
    */
      get isHidden() {
        return false
      }
      /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
      destroy(dom) {}
    }
    /**
The different types of blocks that can occur in an editor view.
*/
    var BlockType = /*@__PURE__*/ (function (BlockType) {
      /**
    A line of text.
    */
      BlockType[(BlockType['Text'] = 0)] = 'Text'
      /**
    A block widget associated with the position after it.
    */
      BlockType[(BlockType['WidgetBefore'] = 1)] = 'WidgetBefore'
      /**
    A block widget associated with the position before it.
    */
      BlockType[(BlockType['WidgetAfter'] = 2)] = 'WidgetAfter'
      /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
      BlockType[(BlockType['WidgetRange'] = 3)] = 'WidgetRange'
      return BlockType
    })(BlockType || (BlockType = {}))
    /**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
@nonabstract
*/
    class Decoration extends RangeValue {
      constructor(
        /**
    @internal
    */
        startSide,
        /**
    @internal
    */
        endSide,
        /**
    @internal
    */
        widget,
        /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
        spec
      ) {
        super()
        this.startSide = startSide
        this.endSide = endSide
        this.widget = widget
        this.spec = spec
      }
      /**
    @internal
    */
      get heightRelevant() {
        return false
      }
      /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
      static mark(spec) {
        return new MarkDecoration(spec)
      }
      /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
      static widget(spec) {
        let side = Math.max(-10000, Math.min(10000, spec.side || 0)),
          block = !!spec.block
        side +=
          block && !spec.inlineOrder
            ? side > 0
              ? 300000000 /* Side.BlockAfter */
              : -400000000 /* Side.BlockBefore */
            : side > 0
              ? 100000000 /* Side.InlineAfter */
              : -100000000 /* Side.InlineBefore */
        return new PointDecoration(
          spec,
          side,
          side,
          block,
          spec.widget || null,
          false
        )
      }
      /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
      static replace(spec) {
        let block = !!spec.block,
          startSide,
          endSide
        if (spec.isBlockGap) {
          startSide = -500000000 /* Side.GapStart */
          endSide = 400000000 /* Side.GapEnd */
        } else {
          let { start, end } = getInclusive(spec, block)
          startSide =
            (start
              ? block
                ? -300000000 /* Side.BlockIncStart */
                : -1 /* Side.InlineIncStart */
              : 500000000) /* Side.NonIncStart */ - 1
          endSide =
            (end
              ? block
                ? 200000000 /* Side.BlockIncEnd */
                : 1 /* Side.InlineIncEnd */
              : -600000000) /* Side.NonIncEnd */ + 1
        }
        return new PointDecoration(
          spec,
          startSide,
          endSide,
          block,
          spec.widget || null,
          true
        )
      }
      /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
      static line(spec) {
        return new LineDecoration(spec)
      }
      /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
      static set(of, sort = false) {
        return dist_RangeSet.of(of, sort)
      }
      /**
    @internal
    */
      hasHeight() {
        return this.widget ? this.widget.estimatedHeight > -1 : false
      }
    }
    /**
The empty set of decorations.
*/
    Decoration.none = dist_RangeSet.empty
    class MarkDecoration extends Decoration {
      constructor(spec) {
        let { start, end } = getInclusive(spec)
        super(
          start
            ? -1 /* Side.InlineIncStart */
            : 500000000 /* Side.NonIncStart */,
          end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */,
          null,
          spec
        )
        this.tagName = spec.tagName || 'span'
        this.class = spec.class || ''
        this.attrs = spec.attributes || null
      }
      eq(other) {
        var _a, _b
        return (
          this == other ||
          (other instanceof MarkDecoration &&
            this.tagName == other.tagName &&
            (this.class ||
              ((_a = this.attrs) === null || _a === void 0
                ? void 0
                : _a.class)) ==
              (other.class ||
                ((_b = other.attrs) === null || _b === void 0
                  ? void 0
                  : _b.class)) &&
            attrsEq(this.attrs, other.attrs, 'class'))
        )
      }
      range(from, to = from) {
        if (from >= to)
          throw new RangeError('Mark decorations may not be empty')
        return super.range(from, to)
      }
    }
    MarkDecoration.prototype.point = false
    class LineDecoration extends Decoration {
      constructor(spec) {
        super(
          -200000000 /* Side.Line */,
          -200000000 /* Side.Line */,
          null,
          spec
        )
      }
      eq(other) {
        return (
          other instanceof LineDecoration &&
          this.spec.class == other.spec.class &&
          attrsEq(this.spec.attributes, other.spec.attributes)
        )
      }
      range(from, to = from) {
        if (to != from)
          throw new RangeError('Line decoration ranges must be zero-length')
        return super.range(from, to)
      }
    }
    LineDecoration.prototype.mapMode = MapMode.TrackBefore
    LineDecoration.prototype.point = true
    class PointDecoration extends Decoration {
      constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec)
        this.block = block
        this.isReplace = isReplace
        this.mapMode = !block
          ? MapMode.TrackDel
          : startSide <= 0
            ? MapMode.TrackBefore
            : MapMode.TrackAfter
      }
      // Only relevant when this.block == true
      get type() {
        return this.startSide != this.endSide
          ? BlockType.WidgetRange
          : this.startSide <= 0
            ? BlockType.WidgetBefore
            : BlockType.WidgetAfter
      }
      get heightRelevant() {
        return (
          this.block ||
          (!!this.widget &&
            (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0))
        )
      }
      eq(other) {
        return (
          other instanceof PointDecoration &&
          widgetsEq(this.widget, other.widget) &&
          this.block == other.block &&
          this.startSide == other.startSide &&
          this.endSide == other.endSide
        )
      }
      range(from, to = from) {
        if (
          this.isReplace &&
          (from > to || (from == to && this.startSide > 0 && this.endSide <= 0))
        )
          throw new RangeError('Invalid range for replacement decoration')
        if (!this.isReplace && to != from)
          throw new RangeError(
            'Widget decorations can only have zero-length ranges'
          )
        return super.range(from, to)
      }
    }
    PointDecoration.prototype.point = true
    function getInclusive(spec, block = false) {
      let { inclusiveStart: start, inclusiveEnd: end } = spec
      if (start == null) start = spec.inclusive
      if (end == null) end = spec.inclusive
      return {
        start: start !== null && start !== void 0 ? start : block,
        end: end !== null && end !== void 0 ? end : block
      }
    }
    function widgetsEq(a, b) {
      return a == b || !!(a && b && a.compare(b))
    }
    function addRange(from, to, ranges, margin = 0) {
      let last = ranges.length - 1
      if (last >= 0 && ranges[last] + margin >= from)
        ranges[last] = Math.max(ranges[last], to)
      else ranges.push(from, to)
    }

    class ContentBuilder {
      constructor(doc, pos, end, disallowBlockEffectsFor) {
        this.doc = doc
        this.pos = pos
        this.end = end
        this.disallowBlockEffectsFor = disallowBlockEffectsFor
        this.content = []
        this.curLine = null
        this.breakAtStart = 0
        this.pendingBuffer = 0 /* Buf.No */
        this.bufferMarks = []
        // Set to false directly after a widget that covers the position after it
        this.atCursorPos = true
        this.openStart = -1
        this.openEnd = -1
        this.text = ''
        this.textOff = 0
        this.cursor = doc.iter()
        this.skip = pos
      }
      posCovered() {
        if (this.content.length == 0)
          return (
            !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos
          )
        let last = this.content[this.content.length - 1]
        return !(
          last.breakAfter ||
          (last instanceof BlockWidgetView && last.deco.endSide < 0)
        )
      }
      getLine() {
        if (!this.curLine) {
          this.content.push((this.curLine = new LineView()))
          this.atCursorPos = true
        }
        return this.curLine
      }
      flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
          this.curLine.append(
            wrapMarks(new WidgetBufferView(-1), active),
            active.length
          )
          this.pendingBuffer = 0 /* Buf.No */
        }
      }
      addBlockWidget(view) {
        this.flushBuffer()
        this.curLine = null
        this.content.push(view)
      }
      finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
          this.flushBuffer()
        else this.pendingBuffer = 0 /* Buf.No */
        if (
          !this.posCovered() &&
          !(
            openEnd &&
            this.content.length &&
            this.content[this.content.length - 1] instanceof BlockWidgetView
          )
        )
          this.getLine()
      }
      buildText(length, active, openStart) {
        while (length > 0) {
          if (this.textOff == this.text.length) {
            let { value, lineBreak, done } = this.cursor.next(this.skip)
            this.skip = 0
            if (done)
              throw new Error(
                'Ran out of text content when drawing inline views'
              )
            if (lineBreak) {
              if (!this.posCovered()) this.getLine()
              if (this.content.length)
                this.content[this.content.length - 1].breakAfter = 1
              else this.breakAtStart = 1
              this.flushBuffer()
              this.curLine = null
              this.atCursorPos = true
              length--
              continue
            } else {
              this.text = value
              this.textOff = 0
            }
          }
          let take = Math.min(
            this.text.length - this.textOff,
            length,
            512 /* T.Chunk */
          )
          this.flushBuffer(active.slice(active.length - openStart))
          this.getLine().append(
            wrapMarks(
              new TextView(this.text.slice(this.textOff, this.textOff + take)),
              active
            ),
            openStart
          )
          this.atCursorPos = true
          this.textOff += take
          length -= take
          openStart = 0
        }
      }
      span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart)
        this.pos = to
        if (this.openStart < 0) this.openStart = openStart
      }
      point(from, to, deco, active, openStart, index) {
        if (
          this.disallowBlockEffectsFor[index] &&
          deco instanceof PointDecoration
        ) {
          if (deco.block)
            throw new RangeError(
              'Block decorations may not be specified via plugins'
            )
          if (to > this.doc.lineAt(this.pos).to)
            throw new RangeError(
              'Decorations that replace line breaks may not be specified via plugins'
            )
        }
        let len = to - from
        if (deco instanceof PointDecoration) {
          if (deco.block) {
            if (deco.startSide > 0 && !this.posCovered()) this.getLine()
            this.addBlockWidget(
              new BlockWidgetView(
                deco.widget || new NullWidget('div'),
                len,
                deco
              )
            )
          } else {
            let view = WidgetView.create(
              deco.widget || new NullWidget('span'),
              len,
              len ? 0 : deco.startSide
            )
            let cursorBefore =
              this.atCursorPos &&
              !view.isEditable &&
              openStart <= active.length &&
              (from < to || deco.startSide > 0)
            let cursorAfter =
              !view.isEditable &&
              (from < to || openStart > active.length || deco.startSide <= 0)
            let line = this.getLine()
            if (
              this.pendingBuffer == 2 /* Buf.IfCursor */ &&
              !cursorBefore &&
              !view.isEditable
            )
              this.pendingBuffer = 0 /* Buf.No */
            this.flushBuffer(active)
            if (cursorBefore) {
              line.append(wrapMarks(new WidgetBufferView(1), active), openStart)
              openStart = active.length + Math.max(0, openStart - active.length)
            }
            line.append(wrapMarks(view, active), openStart)
            this.atCursorPos = cursorAfter
            this.pendingBuffer = !cursorAfter
              ? 0 /* Buf.No */
              : from < to || openStart > active.length
                ? 1 /* Buf.Yes */
                : 2 /* Buf.IfCursor */
            if (this.pendingBuffer) this.bufferMarks = active.slice()
          }
        } else if (this.doc.lineAt(this.pos).from == this.pos) {
          // Line decoration
          this.getLine().addLineDeco(deco)
        }
        if (len) {
          // Advance the iterator past the replaced content
          if (this.textOff + len <= this.text.length) {
            this.textOff += len
          } else {
            this.skip += len - (this.text.length - this.textOff)
            this.text = ''
            this.textOff = 0
          }
          this.pos = to
        }
        if (this.openStart < 0) this.openStart = openStart
      }
      static build(text, from, to, decorations, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap)
        builder.openEnd = dist_RangeSet.spans(decorations, from, to, builder)
        if (builder.openStart < 0) builder.openStart = builder.openEnd
        builder.finish(builder.openEnd)
        return builder
      }
    }
    function wrapMarks(view, active) {
      for (let mark of active) view = new MarkView(mark, [view], view.length)
      return view
    }
    class NullWidget extends WidgetType {
      constructor(tag) {
        super()
        this.tag = tag
      }
      eq(other) {
        return other.tag == this.tag
      }
      toDOM() {
        return document.createElement(this.tag)
      }
      updateDOM(elt) {
        return elt.nodeName.toLowerCase() == this.tag
      }
      get isHidden() {
        return true
      }
    }

    const clickAddsSelectionRange = /*@__PURE__*/ Facet.define()
    const dragMovesSelection$1 = /*@__PURE__*/ Facet.define()
    const mouseSelectionStyle = /*@__PURE__*/ Facet.define()
    const exceptionSink = /*@__PURE__*/ Facet.define()
    const updateListener = /*@__PURE__*/ Facet.define()
    const inputHandler = /*@__PURE__*/ Facet.define()
    const focusChangeEffect = /*@__PURE__*/ Facet.define()
    const perLineTextDirection = /*@__PURE__*/ Facet.define({
      combine: (values) => values.some((x) => x)
    })
    const nativeSelectionHidden = /*@__PURE__*/ Facet.define({
      combine: (values) => values.some((x) => x)
    })
    class ScrollTarget {
      constructor(
        range,
        y = 'nearest',
        x = 'nearest',
        yMargin = 5,
        xMargin = 5,
        // This data structure is abused to also store precise scroll
        // snapshots, instead of a `scrollIntoView` request. When this
        // flag is `true`, `range` points at a position in the reference
        // line, `yMargin` holds the difference between the top of that
        // line and the top of the editor, and `xMargin` holds the
        // editor's `scrollLeft`.
        isSnapshot = false
      ) {
        this.range = range
        this.y = y
        this.x = x
        this.yMargin = yMargin
        this.xMargin = xMargin
        this.isSnapshot = isSnapshot
      }
      map(changes) {
        return changes.empty
          ? this
          : new ScrollTarget(
              this.range.map(changes),
              this.y,
              this.x,
              this.yMargin,
              this.xMargin,
              this.isSnapshot
            )
      }
      clip(state) {
        return this.range.to <= state.doc.length
          ? this
          : new ScrollTarget(
              dist_EditorSelection.cursor(state.doc.length),
              this.y,
              this.x,
              this.yMargin,
              this.xMargin,
              this.isSnapshot
            )
      }
    }
    const scrollIntoView = /*@__PURE__*/ StateEffect.define({
      map: (t, ch) => t.map(ch)
    })
    /**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/
    function dist_logException(state, exception, context) {
      let handler = state.facet(exceptionSink)
      if (handler.length) handler[0](exception)
      else if (window.onerror)
        window.onerror(
          String(exception),
          context,
          undefined,
          undefined,
          exception
        )
      else if (context) console.error(context + ':', exception)
      else console.error(exception)
    }
    const editable = /*@__PURE__*/ Facet.define({
      combine: (values) => (values.length ? values[0] : true)
    })
    let nextPluginID = 0
    const viewPlugin = /*@__PURE__*/ Facet.define()
    /**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/
    class dist_ViewPlugin {
      constructor(
        /**
    @internal
    */
        id,
        /**
    @internal
    */
        create,
        /**
    @internal
    */
        domEventHandlers,
        /**
    @internal
    */
        domEventObservers,
        buildExtensions
      ) {
        this.id = id
        this.create = create
        this.domEventHandlers = domEventHandlers
        this.domEventObservers = domEventObservers
        this.extension = buildExtensions(this)
      }
      /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
      static define(create, spec) {
        const {
          eventHandlers,
          eventObservers,
          provide,
          decorations: deco
        } = spec || {}
        return new dist_ViewPlugin(
          nextPluginID++,
          create,
          eventHandlers,
          eventObservers,
          (plugin) => {
            let ext = [viewPlugin.of(plugin)]
            if (deco)
              ext.push(
                decorations.of((view) => {
                  let pluginInst = view.plugin(plugin)
                  return pluginInst ? deco(pluginInst) : Decoration.none
                })
              )
            if (provide) ext.push(provide(plugin))
            return ext
          }
        )
      }
      /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
      static fromClass(cls, spec) {
        return dist_ViewPlugin.define((view) => new cls(view), spec)
      }
    }
    class PluginInstance {
      constructor(spec) {
        this.spec = spec
        // When starting an update, all plugins have this field set to the
        // update object, indicating they need to be updated. When finished
        // updating, it is set to `false`. Retrieving a plugin that needs to
        // be updated with `view.plugin` forces an eager update.
        this.mustUpdate = null
        // This is null when the plugin is initially created, but
        // initialized on the first update.
        this.value = null
      }
      update(view) {
        if (!this.value) {
          if (this.spec) {
            try {
              this.value = this.spec.create(view)
            } catch (e) {
              dist_logException(view.state, e, 'CodeMirror plugin crashed')
              this.deactivate()
            }
          }
        } else if (this.mustUpdate) {
          let update = this.mustUpdate
          this.mustUpdate = null
          if (this.value.update) {
            try {
              this.value.update(update)
            } catch (e) {
              dist_logException(update.state, e, 'CodeMirror plugin crashed')
              if (this.value.destroy)
                try {
                  this.value.destroy()
                } catch (_) {}
              this.deactivate()
            }
          }
        }
        return this
      }
      destroy(view) {
        var _a
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
          try {
            this.value.destroy()
          } catch (e) {
            dist_logException(view.state, e, 'CodeMirror plugin crashed')
          }
        }
      }
      deactivate() {
        this.spec = this.value = null
      }
    }
    const editorAttributes = /*@__PURE__*/ Facet.define()
    const contentAttributes = /*@__PURE__*/ Facet.define()
    // Provide decorations
    const decorations = /*@__PURE__*/ Facet.define()
    const atomicRanges = /*@__PURE__*/ Facet.define()
    const bidiIsolatedRanges = /*@__PURE__*/ Facet.define()
    function getIsolatedRanges(view, from, to) {
      let isolates = view.state.facet(bidiIsolatedRanges)
      if (!isolates.length) return isolates
      let sets = isolates.map((i) => (i instanceof Function ? i(view) : i))
      let result = []
      dist_RangeSet.spans(sets, from, to, {
        point() {},
        span(from, to, active, open) {
          let level = result
          for (let i = active.length - 1; i >= 0; i--, open--) {
            let iso = active[i].spec.bidiIsolate,
              update
            if (iso == null) continue
            if (
              open > 0 &&
              level.length &&
              (update = level[level.length - 1]).to == from &&
              update.direction == iso
            ) {
              update.to = to
              level = update.inner
            } else {
              let add = { from, to, direction: iso, inner: [] }
              level.push(add)
              level = add.inner
            }
          }
        }
      })
      return result
    }
    const scrollMargins = /*@__PURE__*/ Facet.define()
    function getScrollMargins(view) {
      let left = 0,
        right = 0,
        top = 0,
        bottom = 0
      for (let source of view.state.facet(scrollMargins)) {
        let m = source(view)
        if (m) {
          if (m.left != null) left = Math.max(left, m.left)
          if (m.right != null) right = Math.max(right, m.right)
          if (m.top != null) top = Math.max(top, m.top)
          if (m.bottom != null) bottom = Math.max(bottom, m.bottom)
        }
      }
      return { left, right, top, bottom }
    }
    const styleModule = /*@__PURE__*/ Facet.define()
    class ChangedRange {
      constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA
        this.toA = toA
        this.fromB = fromB
        this.toB = toB
      }
      join(other) {
        return new ChangedRange(
          Math.min(this.fromA, other.fromA),
          Math.max(this.toA, other.toA),
          Math.min(this.fromB, other.fromB),
          Math.max(this.toB, other.toB)
        )
      }
      addToSet(set) {
        let i = set.length,
          me = this
        for (; i > 0; i--) {
          let range = set[i - 1]
          if (range.fromA > me.toA) continue
          if (range.toA < me.fromA) break
          me = me.join(range)
          set.splice(i - 1, 1)
        }
        set.splice(i, 0, me)
        return set
      }
      static extendWithRanges(diff, ranges) {
        if (ranges.length == 0) return diff
        let result = []
        for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
          let next = dI == diff.length ? null : diff[dI],
            off = posA - posB
          let end = next ? next.fromB : 1e9
          while (rI < ranges.length && ranges[rI] < end) {
            let from = ranges[rI],
              to = ranges[rI + 1]
            let fromB = Math.max(posB, from),
              toB = Math.min(end, to)
            if (fromB <= toB)
              new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(
                result
              )
            if (to > end) break
            else rI += 2
          }
          if (!next) return result
          new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(
            result
          )
          posA = next.toA
          posB = next.toB
        }
      }
    }
    /**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/
    class ViewUpdate {
      constructor(
        /**
    The editor view that the update is associated with.
    */
        view,
        /**
    The new editor state.
    */
        state,
        /**
    The transactions involved in the update. May be empty.
    */
        transactions
      ) {
        this.view = view
        this.state = state
        this.transactions = transactions
        /**
        @internal
        */
        this.flags = 0
        this.startState = view.state
        this.changes = ChangeSet.empty(this.startState.doc.length)
        for (let tr of transactions)
          this.changes = this.changes.compose(tr.changes)
        let changedRanges = []
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) =>
          changedRanges.push(new ChangedRange(fromA, toA, fromB, toB))
        )
        this.changedRanges = changedRanges
      }
      /**
    @internal
    */
      static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions)
      }
      /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
      get viewportChanged() {
        return (this.flags & 4) /* UpdateFlag.Viewport */ > 0
      }
      /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
      get heightChanged() {
        return (this.flags & 2) /* UpdateFlag.Height */ > 0
      }
      /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
      get geometryChanged() {
        return (
          this.docChanged ||
          (this.flags &
            (8 /* UpdateFlag.Geometry */ | 2) /* UpdateFlag.Height */) >
            0
        )
      }
      /**
    True when this update indicates a focus change.
    */
      get focusChanged() {
        return (this.flags & 1) /* UpdateFlag.Focus */ > 0
      }
      /**
    Whether the document changed in this update.
    */
      get docChanged() {
        return !this.changes.empty
      }
      /**
    Whether the selection was explicitly set in this update.
    */
      get selectionSet() {
        return this.transactions.some((tr) => tr.selection)
      }
      /**
    @internal
    */
      get empty() {
        return this.flags == 0 && this.transactions.length == 0
      }
    }

    /**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/
    var Direction = /*@__PURE__*/ (function (Direction) {
      // (These are chosen to match the base levels, in bidi algorithm
      // terms, of spans in that direction.)
      /**
    Left-to-right.
    */
      Direction[(Direction['LTR'] = 0)] = 'LTR'
      /**
    Right-to-left.
    */
      Direction[(Direction['RTL'] = 1)] = 'RTL'
      return Direction
    })(Direction || (Direction = {}))
    const LTR = Direction.LTR,
      RTL = Direction.RTL
    // Decode a string with each type encoded as log2(type)
    function dec(str) {
      let result = []
      for (let i = 0; i < str.length; i++) result.push(1 << +str[i])
      return result
    }
    // Character types for codepoints 0 to 0xf8
    const LowTypes = /*@__PURE__*/ dec(
      '88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008'
    )
    // Character types for codepoints 0x600 to 0x6f9
    const ArabicTypes = /*@__PURE__*/ dec(
      '4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333'
    )
    const Brackets = /*@__PURE__*/ Object.create(null),
      BracketStack = []
    // There's a lot more in
    // https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
    // which are left out to keep code size down.
    for (let p of ['()', '[]', '{}']) {
      let l = /*@__PURE__*/ p.charCodeAt(0),
        r = /*@__PURE__*/ p.charCodeAt(1)
      Brackets[l] = r
      Brackets[r] = -l
    }
    function charType(ch) {
      return ch <= 0xf7
        ? LowTypes[ch]
        : 0x590 <= ch && ch <= 0x5f4
          ? 2 /* T.R */
          : 0x600 <= ch && ch <= 0x6f9
            ? ArabicTypes[ch - 0x600]
            : 0x6ee <= ch && ch <= 0x8ac
              ? 4 /* T.AL */
              : 0x2000 <= ch && ch <= 0x200c
                ? 256 /* T.NI */
                : 0xfb50 <= ch && ch <= 0xfdff
                  ? 4 /* T.AL */
                  : 1 /* T.L */
    }
    const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/
    /**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/
    class BidiSpan {
      /**
    The direction of this span.
    */
      get dir() {
        return this.level % 2 ? RTL : LTR
      }
      /**
    @internal
    */
      constructor(
        /**
    The start of the span (relative to the start of the line).
    */
        from,
        /**
    The end of the span.
    */
        to,
        /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
        level
      ) {
        this.from = from
        this.to = to
        this.level = level
      }
      /**
    @internal
    */
      side(end, dir) {
        return (this.dir == dir) == end ? this.to : this.from
      }
      /**
    @internal
    */
      static find(order, index, level, assoc) {
        let maybe = -1
        for (let i = 0; i < order.length; i++) {
          let span = order[i]
          if (span.from <= index && span.to >= index) {
            if (span.level == level) return i
            // When multiple spans match, if assoc != 0, take the one that
            // covers that side, otherwise take the one with the minimum
            // level.
            if (
              maybe < 0 ||
              (assoc != 0
                ? assoc < 0
                  ? span.from < index
                  : span.to > index
                : order[maybe].level > span.level)
            )
              maybe = i
          }
        }
        if (maybe < 0) throw new RangeError('Index out of range')
        return maybe
      }
    }
    function isolatesEq(a, b) {
      if (a.length != b.length) return false
      for (let i = 0; i < a.length; i++) {
        let iA = a[i],
          iB = b[i]
        if (
          iA.from != iB.from ||
          iA.to != iB.to ||
          iA.direction != iB.direction ||
          !isolatesEq(iA.inner, iB.inner)
        )
          return false
      }
      return true
    }
    // Reused array of character types
    const types = []
    // Fill in the character types (in `types`) from `from` to `to` and
    // apply W normalization rules.
    function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
      for (let iI = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom,
          to = iI < isolates.length ? isolates[iI].from : rTo
        let prevType = iI ? 256 /* T.NI */ : outerType
        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        // (Left after this: L, R, EN, AN, ET, CS, NI)
        for (
          let i = from, prev = prevType, prevStrong = prevType;
          i < to;
          i++
        ) {
          let type = charType(line.charCodeAt(i))
          if (type == 512 /* T.NSM */) type = prev
          else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)
            type = 16 /* T.AN */
          types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type
          if (type & 7 /* T.Strong */) prevStrong = type
          prev = type
        }
        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        // (Left after this: L, R, EN+AN, NI)
        for (
          let i = from, prev = prevType, prevStrong = prevType;
          i < to;
          i++
        ) {
          let type = types[i]
          if (type == 128 /* T.CS */) {
            if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */)
              type = types[i] = prev
            else types[i] = 256 /* T.NI */
          } else if (type == 64 /* T.ET */) {
            let end = i + 1
            while (end < to && types[end] == 64 /* T.ET */) end++
            let replace =
              (i && prev == 8) /* T.EN */ ||
              (end < rTo && types[end] == 8) /* T.EN */
                ? prevStrong == 1 /* T.L */
                  ? 1 /* T.L */
                  : 8 /* T.EN */
                : 256 /* T.NI */
            for (let j = i; j < end; j++) types[j] = replace
            i = end - 1
          } else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {
            types[i] = 1 /* T.L */
          }
          prev = type
          if (type & 7 /* T.Strong */) prevStrong = type
        }
      }
    }
    // Process brackets throughout a run sequence.
    function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
      let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */
      for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom,
          to = iI < isolates.length ? isolates[iI].from : rTo
        // N0. Process bracket pairs in an isolating run sequence
        // sequentially in the logical order of the text positions of the
        // opening paired brackets using the logic given below. Within this
        // scope, bidirectional types EN and AN are treated as R.
        for (let i = from, ch, br, type; i < to; i++) {
          // Keeps [startIndex, type, strongSeen] triples for each open
          // bracket on BracketStack.
          if ((br = Brackets[(ch = line.charCodeAt(i))])) {
            if (br < 0) {
              // Closing bracket
              for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                if (BracketStack[sJ + 1] == -br) {
                  let flags = BracketStack[sJ + 2]
                  let type =
                    flags & 2 /* Bracketed.EmbedInside */
                      ? outerType
                      : !((flags & 4) /* Bracketed.OppositeInside */)
                        ? 0
                        : flags & 1 /* Bracketed.OppositeBefore */
                          ? oppositeType
                          : outerType
                  if (type) types[i] = types[BracketStack[sJ]] = type
                  sI = sJ
                  break
                }
              }
            } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
              break
            } else {
              BracketStack[sI++] = i
              BracketStack[sI++] = ch
              BracketStack[sI++] = context
            }
          } else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
            let embed = type == outerType
            context = embed ? 0 : 1 /* Bracketed.OppositeBefore */
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              let cur = BracketStack[sJ + 2]
              if (cur & 2 /* Bracketed.EmbedInside */) break
              if (embed) {
                BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */
              } else {
                if (cur & 4 /* Bracketed.OppositeInside */) break
                BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */
              }
            }
          }
        }
      }
    }
    function processNeutrals(rFrom, rTo, isolates, outerType) {
      for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom,
          to = iI < isolates.length ? isolates[iI].from : rTo
        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        // (Left after this: L, R, EN+AN)
        for (let i = from; i < to; ) {
          let type = types[i]
          if (type == 256 /* T.NI */) {
            let end = i + 1
            for (;;) {
              if (end == to) {
                if (iI == isolates.length) break
                end = isolates[iI++].to
                to = iI < isolates.length ? isolates[iI].from : rTo
              } else if (types[end] == 256 /* T.NI */) {
                end++
              } else {
                break
              }
            }
            let beforeL = prev == 1 /* T.L */
            let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */
            let replace =
              beforeL == afterL
                ? beforeL
                  ? 1 /* T.L */
                  : 2 /* T.R */
                : outerType
            for (
              let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom;
              j > i;

            ) {
              if (j == fromJ) {
                j = isolates[--jI].from
                fromJ = jI ? isolates[jI - 1].to : rFrom
              }
              types[--j] = replace
            }
            i = end
          } else {
            prev = type
            i++
          }
        }
      }
    }
    // Find the contiguous ranges of character types in a given range, and
    // emit spans for them. Flip the order of the spans as appropriate
    // based on the level, and call through to compute the spans for
    // isolates at the proper point.
    function emitSpans(line, from, to, level, baseLevel, isolates, order) {
      let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */
      if (level % 2 == baseLevel % 2) {
        // Same dir as base direction, don't flip
        for (let iCh = from, iI = 0; iCh < to; ) {
          // Scan a section of characters in direction ourType, unless
          // there's another type of char right after iCh, in which case
          // we scan a section of other characters (which, if ourType ==
          // T.L, may contain both T.R and T.AN chars).
          let sameDir = true,
            isNum = false
          if (iI == isolates.length || iCh < isolates[iI].from) {
            let next = types[iCh]
            if (next != ourType) {
              sameDir = false
              isNum = next == 16 /* T.AN */
            }
          }
          // Holds an array of isolates to pass to a recursive call if we
          // must recurse (to distinguish T.AN inside an RTL section in
          // LTR text), null if we can emit directly
          let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null
          let localLevel = sameDir ? level : level + 1
          let iScan = iCh
          run: for (;;) {
            if (iI < isolates.length && iScan == isolates[iI].from) {
              if (isNum) break run
              let iso = isolates[iI]
              // Scan ahead to verify that there is another char in this dir after the isolate(s)
              if (!sameDir)
                for (let upto = iso.to, jI = iI + 1; ; ) {
                  if (upto == to) break run
                  if (jI < isolates.length && isolates[jI].from == upto)
                    upto = isolates[jI++].to
                  else if (types[upto] == ourType) break run
                  else break
                }
              iI++
              if (recurse) {
                recurse.push(iso)
              } else {
                if (iso.from > iCh)
                  order.push(new BidiSpan(iCh, iso.from, localLevel))
                let dirSwap = (iso.direction == LTR) != !(localLevel % 2)
                computeSectionOrder(
                  line,
                  dirSwap ? level + 1 : level,
                  baseLevel,
                  iso.inner,
                  iso.from,
                  iso.to,
                  order
                )
                iCh = iso.to
              }
              iScan = iso.to
            } else if (
              iScan == to ||
              (sameDir ? types[iScan] != ourType : types[iScan] == ourType)
            ) {
              break
            } else {
              iScan++
            }
          }
          if (recurse)
            emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order)
          else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel))
          iCh = iScan
        }
      } else {
        // Iterate in reverse to flip the span order. Same code again, but
        // going from the back of the section to the front
        for (let iCh = to, iI = isolates.length; iCh > from; ) {
          let sameDir = true,
            isNum = false
          if (!iI || iCh > isolates[iI - 1].to) {
            let next = types[iCh - 1]
            if (next != ourType) {
              sameDir = false
              isNum = next == 16 /* T.AN */
            }
          }
          let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null
          let localLevel = sameDir ? level : level + 1
          let iScan = iCh
          run: for (;;) {
            if (iI && iScan == isolates[iI - 1].to) {
              if (isNum) break run
              let iso = isolates[--iI]
              // Scan ahead to verify that there is another char in this dir after the isolate(s)
              if (!sameDir)
                for (let upto = iso.from, jI = iI; ; ) {
                  if (upto == from) break run
                  if (jI && isolates[jI - 1].to == upto)
                    upto = isolates[--jI].from
                  else if (types[upto - 1] == ourType) break run
                  else break
                }
              if (recurse) {
                recurse.push(iso)
              } else {
                if (iso.to < iCh)
                  order.push(new BidiSpan(iso.to, iCh, localLevel))
                let dirSwap = (iso.direction == LTR) != !(localLevel % 2)
                computeSectionOrder(
                  line,
                  dirSwap ? level + 1 : level,
                  baseLevel,
                  iso.inner,
                  iso.from,
                  iso.to,
                  order
                )
                iCh = iso.from
              }
              iScan = iso.from
            } else if (
              iScan == from ||
              (sameDir
                ? types[iScan - 1] != ourType
                : types[iScan - 1] == ourType)
            ) {
              break
            } else {
              iScan--
            }
          }
          if (recurse)
            emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order)
          else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel))
          iCh = iScan
        }
      }
    }
    function computeSectionOrder(
      line,
      level,
      baseLevel,
      isolates,
      from,
      to,
      order
    ) {
      let outerType = level % 2 ? 2 /* T.R */ : 1 /* T.L */
      computeCharTypes(line, from, to, isolates, outerType)
      processBracketPairs(line, from, to, isolates, outerType)
      processNeutrals(from, to, isolates, outerType)
      emitSpans(line, from, to, level, baseLevel, isolates, order)
    }
    function computeOrder(line, direction, isolates) {
      if (!line) return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)]
      if (direction == LTR && !isolates.length && !BidiRE.test(line))
        return trivialOrder(line.length)
      if (isolates.length)
        while (line.length > types.length) types[types.length] = 256 /* T.NI */ // Make sure types array has no gaps
      let order = [],
        level = direction == LTR ? 0 : 1
      computeSectionOrder(line, level, level, isolates, 0, line.length, order)
      return order
    }
    function trivialOrder(length) {
      return [new BidiSpan(0, length, 0)]
    }
    let movedOver = ''
    function moveVisually(line, order, dir, start, forward) {
      var _a
      let startIndex = start.head - line.from,
        spanI = -1
      if (startIndex == 0) {
        if (!forward || !line.length) return null
        if (order[0].level != dir) {
          startIndex = order[0].side(false, dir)
          spanI = 0
        }
      } else if (startIndex == line.length) {
        if (forward) return null
        let last = order[order.length - 1]
        if (last.level != dir) {
          startIndex = last.side(true, dir)
          spanI = order.length - 1
        }
      }
      if (spanI < 0)
        spanI = BidiSpan.find(
          order,
          startIndex,
          (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1,
          start.assoc
        )
      let span = order[spanI]
      // End of span. (But not end of line--that was checked for above.)
      if (startIndex == span.side(forward, dir)) {
        span = order[(spanI += forward ? 1 : -1)]
        startIndex = span.side(!forward, dir)
      }
      let indexForward = forward == (span.dir == dir)
      let nextIndex = findClusterBreak(line.text, startIndex, indexForward)
      movedOver = line.text.slice(
        Math.min(startIndex, nextIndex),
        Math.max(startIndex, nextIndex)
      )
      if (nextIndex > span.from && nextIndex < span.to)
        return dist_EditorSelection.cursor(
          nextIndex + line.from,
          indexForward ? -1 : 1,
          span.level
        )
      let nextSpan =
        spanI == (forward ? order.length - 1 : 0)
          ? null
          : order[spanI + (forward ? 1 : -1)]
      if (!nextSpan && span.level != dir)
        return dist_EditorSelection.cursor(
          forward ? line.to : line.from,
          forward ? -1 : 1,
          dir
        )
      if (nextSpan && nextSpan.level < span.level)
        return dist_EditorSelection.cursor(
          nextSpan.side(!forward, dir) + line.from,
          forward ? 1 : -1,
          nextSpan.level
        )
      return dist_EditorSelection.cursor(
        nextIndex + line.from,
        forward ? -1 : 1,
        span.level
      )
    }

    class DocView extends ContentView {
      get length() {
        return this.view.state.doc.length
      }
      constructor(view) {
        super()
        this.view = view
        this.decorations = []
        this.dynamicDecorationMap = []
        this.domChanged = null
        this.hasComposition = null
        this.markedForComposition = new Set()
        // Track a minimum width for the editor. When measuring sizes in
        // measureVisibleLineHeights, this is updated to point at the width
        // of a given element and its extent in the document. When a change
        // happens in that range, these are reset. That way, once we've seen
        // a line/element of a given length, we keep the editor wide enough
        // to fit at least that element, until it is changed, at which point
        // we forget it again.
        this.minWidth = 0
        this.minWidthFrom = 0
        this.minWidthTo = 0
        // Track whether the DOM selection was set in a lossy way, so that
        // we don't mess it up when reading it back it
        this.impreciseAnchor = null
        this.impreciseHead = null
        this.forceSelection = false
        // Used by the resize observer to ignore resizes that we caused
        // ourselves
        this.lastUpdate = Date.now()
        this.setDOM(view.contentDOM)
        this.children = [new LineView()]
        this.children[0].setParent(this)
        this.updateDeco()
        this.updateInner(
          [new ChangedRange(0, 0, 0, view.state.doc.length)],
          0,
          null
        )
      }
      // Update the document view to a given state.
      update(update) {
        var _a
        let changedRanges = update.changedRanges
        if (this.minWidth > 0 && changedRanges.length) {
          if (
            !changedRanges.every(
              ({ fromA, toA }) =>
                toA < this.minWidthFrom || fromA > this.minWidthTo
            )
          ) {
            this.minWidth = this.minWidthFrom = this.minWidthTo = 0
          } else {
            this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1)
            this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1)
          }
        }
        let readCompositionAt = -1
        if (this.view.inputState.composing >= 0) {
          if (
            (_a = this.domChanged) === null || _a === void 0
              ? void 0
              : _a.newSel
          )
            readCompositionAt = this.domChanged.newSel.head
          else if (
            !touchesComposition(update.changes, this.hasComposition) &&
            !update.selectionSet
          )
            readCompositionAt = update.state.selection.main.head
        }
        let composition =
          readCompositionAt > -1
            ? findCompositionRange(this.view, update.changes, readCompositionAt)
            : null
        this.domChanged = null
        if (this.hasComposition) {
          this.markedForComposition.clear()
          let { from, to } = this.hasComposition
          changedRanges = new ChangedRange(
            from,
            to,
            update.changes.mapPos(from, -1),
            update.changes.mapPos(to, 1)
          ).addToSet(changedRanges.slice())
        }
        this.hasComposition = composition
          ? { from: composition.range.fromB, to: composition.range.toB }
          : null
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        if (
          (browser.ie || browser.chrome) &&
          !composition &&
          update &&
          update.state.doc.lines != update.startState.doc.lines
        )
          this.forceSelection = true
        let prevDeco = this.decorations,
          deco = this.updateDeco()
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes)
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff)
        if (
          !((this.flags & 7) /* ViewFlag.Dirty */) &&
          changedRanges.length == 0
        ) {
          return false
        } else {
          this.updateInner(
            changedRanges,
            update.startState.doc.length,
            composition
          )
          if (update.transactions.length) this.lastUpdate = Date.now()
          return true
        }
      }
      // Used by update and the constructor do perform the actual DOM
      // update
      updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true
        this.updateChildren(changes, oldLength, composition)
        let { observer } = this.view
        observer.ignore(() => {
          // Lock the height during redrawing, since Chrome sometimes
          // messes with the scroll position during DOM mutation (though
          // no relayout is triggered and I cannot imagine how it can
          // recompute the scroll position without a layout)
          this.dom.style.height =
            this.view.viewState.contentHeight / this.view.scaleY + 'px'
          this.dom.style.flexBasis = this.minWidth ? this.minWidth + 'px' : ''
          // Chrome will sometimes, when DOM mutations occur directly
          // around the selection, get confused and report a different
          // selection from the one it displays (issue #218). This tries
          // to detect that situation.
          let track =
            browser.chrome || browser.ios
              ? { node: observer.selectionRange.focusNode, written: false }
              : undefined
          this.sync(this.view, track)
          this.flags &= ~7 /* ViewFlag.Dirty */
          if (
            track &&
            (track.written || observer.selectionRange.focusNode != track.node)
          )
            this.forceSelection = true
          this.dom.style.height = ''
        })
        this.markedForComposition.forEach(
          (cView) => (cView.flags &= ~8) /* ViewFlag.Composition */
        )
        let gaps = []
        if (
          this.view.viewport.from ||
          this.view.viewport.to < this.view.state.doc.length
        )
          for (let child of this.children)
            if (
              child instanceof BlockWidgetView &&
              child.widget instanceof BlockGapWidget
            )
              gaps.push(child.dom)
        observer.updateGaps(gaps)
      }
      updateChildren(changes, oldLength, composition) {
        let ranges = composition
          ? composition.range.addToSet(changes.slice())
          : changes
        let cursor = this.childCursor(oldLength)
        for (let i = ranges.length - 1; ; i--) {
          let next = i >= 0 ? ranges[i] : null
          if (!next) break
          let { fromA, toA, fromB, toB } = next,
            content,
            breakAtStart,
            openStart,
            openEnd
          if (
            composition &&
            composition.range.fromB < toB &&
            composition.range.toB > fromB
          ) {
            let before = ContentBuilder.build(
              this.view.state.doc,
              fromB,
              composition.range.fromB,
              this.decorations,
              this.dynamicDecorationMap
            )
            let after = ContentBuilder.build(
              this.view.state.doc,
              composition.range.toB,
              toB,
              this.decorations,
              this.dynamicDecorationMap
            )
            breakAtStart = before.breakAtStart
            openStart = before.openStart
            openEnd = after.openEnd
            let compLine = this.compositionView(composition)
            if (after.breakAtStart) {
              compLine.breakAfter = 1
            } else if (
              after.content.length &&
              compLine.merge(
                compLine.length,
                compLine.length,
                after.content[0],
                false,
                after.openStart,
                0
              )
            ) {
              compLine.breakAfter = after.content[0].breakAfter
              after.content.shift()
            }
            if (
              before.content.length &&
              compLine.merge(
                0,
                0,
                before.content[before.content.length - 1],
                true,
                0,
                before.openEnd
              )
            ) {
              before.content.pop()
            }
            content = before.content.concat(compLine).concat(after.content)
          } else {
            ;({ content, breakAtStart, openStart, openEnd } =
              ContentBuilder.build(
                this.view.state.doc,
                fromB,
                toB,
                this.decorations,
                this.dynamicDecorationMap
              ))
          }
          let { i: toI, off: toOff } = cursor.findPos(toA, 1)
          let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1)
          replaceRange(
            this,
            fromI,
            fromOff,
            toI,
            toOff,
            content,
            breakAtStart,
            openStart,
            openEnd
          )
        }
        if (composition) this.fixCompositionDOM(composition)
      }
      compositionView(composition) {
        let cur = new TextView(composition.text.nodeValue)
        cur.flags |= 8 /* ViewFlag.Composition */
        for (let { deco } of composition.marks)
          cur = new MarkView(deco, [cur], cur.length)
        let line = new LineView()
        line.append(cur, 0)
        return line
      }
      fixCompositionDOM(composition) {
        let fix = (dom, cView) => {
          cView.flags |=
            8 /* ViewFlag.Composition */ |
            (cView.children.some((c) => c.flags & 7 /* ViewFlag.Dirty */)
              ? 1 /* ViewFlag.ChildDirty */
              : 0)
          this.markedForComposition.add(cView)
          let prev = ContentView.get(dom)
          if (prev && prev != cView) prev.dom = null
          cView.setDOM(dom)
        }
        let pos = this.childPos(composition.range.fromB, 1)
        let cView = this.children[pos.i]
        fix(composition.line, cView)
        for (let i = composition.marks.length - 1; i >= -1; i--) {
          pos = cView.childPos(pos.off, 1)
          cView = cView.children[pos.i]
          fix(i >= 0 ? composition.marks[i].node : composition.text, cView)
        }
      }
      // Sync the DOM selection to this.state.selection
      updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
          this.view.observer.readSelectionRange()
        let activeElt = this.view.root.activeElement,
          focused = activeElt == this.dom
        let selectionNotFocus =
          !focused &&
          hasSelection(this.dom, this.view.observer.selectionRange) &&
          !(activeElt && this.dom.contains(activeElt))
        if (!(focused || fromPointer || selectionNotFocus)) return
        let force = this.forceSelection
        this.forceSelection = false
        let main = this.view.state.selection.main
        let anchor = this.moveToLine(this.domAtPos(main.anchor))
        let head = main.empty
          ? anchor
          : this.moveToLine(this.domAtPos(main.head))
        // Always reset on Firefox when next to an uneditable node to
        // avoid invisible cursor bugs (#111)
        if (
          browser.gecko &&
          main.empty &&
          !this.hasComposition &&
          betweenUneditable(anchor)
        ) {
          let dummy = document.createTextNode('')
          this.view.observer.ignore(() =>
            anchor.node.insertBefore(
              dummy,
              anchor.node.childNodes[anchor.offset] || null
            )
          )
          anchor = head = new DOMPos(dummy, 0)
          force = true
        }
        let domSel = this.view.observer.selectionRange
        // If the selection is already here, or in an equivalent position, don't touch it
        if (
          force ||
          !domSel.focusNode ||
          !isEquivalentPosition(
            anchor.node,
            anchor.offset,
            domSel.anchorNode,
            domSel.anchorOffset
          ) ||
          !isEquivalentPosition(
            head.node,
            head.offset,
            domSel.focusNode,
            domSel.focusOffset
          )
        ) {
          this.view.observer.ignore(() => {
            // Chrome Android will hide the virtual keyboard when tapping
            // inside an uneditable node, and not bring it back when we
            // move the cursor to its proper position. This tries to
            // restore the keyboard by cycling focus.
            if (
              browser.android &&
              browser.chrome &&
              this.dom.contains(domSel.focusNode) &&
              inUneditable(domSel.focusNode, this.dom)
            ) {
              this.dom.blur()
              this.dom.focus({ preventScroll: true })
            }
            let rawSel = getSelection(this.view.root)
            if (!rawSel);
            else if (main.empty) {
              // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
              if (browser.gecko) {
                let nextTo = nextToUneditable(anchor.node, anchor.offset)
                if (
                  nextTo &&
                  nextTo != (1 /* NextTo.Before */ | 2) /* NextTo.After */
                ) {
                  let text = nearbyTextNode(
                    anchor.node,
                    anchor.offset,
                    nextTo == 1 /* NextTo.Before */ ? 1 : -1
                  )
                  if (text) anchor = new DOMPos(text.node, text.offset)
                }
              }
              rawSel.collapse(anchor.node, anchor.offset)
              if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined)
                rawSel.caretBidiLevel = main.bidiLevel
            } else if (rawSel.extend) {
              // Selection.extend can be used to create an 'inverted' selection
              // (one where the focus is before the anchor), but not all
              // browsers support it yet.
              rawSel.collapse(anchor.node, anchor.offset)
              // Safari will ignore the call above when the editor is
              // hidden, and then raise an error on the call to extend
              // (#940).
              try {
                rawSel.extend(head.node, head.offset)
              } catch (_) {}
            } else {
              // Primitive (IE) way
              let range = document.createRange()
              if (main.anchor > main.head) [anchor, head] = [head, anchor]
              range.setEnd(head.node, head.offset)
              range.setStart(anchor.node, anchor.offset)
              rawSel.removeAllRanges()
              rawSel.addRange(range)
            }
            if (selectionNotFocus && this.view.root.activeElement == this.dom) {
              this.dom.blur()
              if (activeElt) activeElt.focus()
            }
          })
          this.view.observer.setSelectionRange(anchor, head)
        }
        this.impreciseAnchor = anchor.precise
          ? null
          : new DOMPos(domSel.anchorNode, domSel.anchorOffset)
        this.impreciseHead = head.precise
          ? null
          : new DOMPos(domSel.focusNode, domSel.focusOffset)
      }
      enforceCursorAssoc() {
        if (this.hasComposition) return
        let { view } = this,
          cursor = view.state.selection.main
        let sel = getSelection(view.root)
        let { anchorNode, anchorOffset } = view.observer.selectionRange
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return
        let line = LineView.find(this, cursor.head)
        if (!line) return
        let lineStart = line.posAtStart
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
          return
        let before = this.coordsAt(cursor.head, -1),
          after = this.coordsAt(cursor.head, 1)
        if (!before || !after || before.bottom > after.top) return
        let dom = this.domAtPos(cursor.head + cursor.assoc)
        sel.collapse(dom.node, dom.offset)
        sel.modify(
          'move',
          cursor.assoc < 0 ? 'forward' : 'backward',
          'lineboundary'
        )
        // This can go wrong in corner cases like single-character lines,
        // so check and reset if necessary.
        view.observer.readSelectionRange()
        let newRange = view.observer.selectionRange
        if (
          view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) !=
          cursor.from
        )
          sel.collapse(anchorNode, anchorOffset)
      }
      // If a position is in/near a block widget, move it to a nearby text
      // line, since we don't want the cursor inside a block widget.
      moveToLine(pos) {
        // Block widgets will return positions before/after them, which
        // are thus directly in the document DOM element.
        let dom = this.dom,
          newPos
        if (pos.node != dom) return pos
        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
          let view = ContentView.get(dom.childNodes[i])
          if (view instanceof LineView) newPos = view.domAtPos(0)
        }
        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
          let view = ContentView.get(dom.childNodes[i])
          if (view instanceof LineView) newPos = view.domAtPos(view.length)
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos
      }
      nearest(dom) {
        for (let cur = dom; cur; ) {
          let domView = ContentView.get(cur)
          if (domView && domView.rootView == this) return domView
          cur = cur.parentNode
        }
        return null
      }
      posFromDOM(node, offset) {
        let view = this.nearest(node)
        if (!view)
          throw new RangeError(
            'Trying to find position for a DOM position outside of the document'
          )
        return view.localPosFromDOM(node, offset) + view.posAtStart
      }
      domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1)
        for (; i < this.children.length - 1; ) {
          let child = this.children[i]
          if (off < child.length || child instanceof LineView) break
          i++
          off = 0
        }
        return this.children[i].domAtPos(off)
      }
      coordsAt(pos, side) {
        let best = null,
          bestPos = 0
        for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
          let child = this.children[i],
            end = off - child.breakAfter,
            start = end - child.length
          if (end < pos) break
          if (
            start <= pos &&
            (start < pos || child.covers(-1)) &&
            (end > pos || child.covers(1)) &&
            (!best ||
              (child instanceof LineView &&
                !(best instanceof LineView && side >= 0)))
          ) {
            best = child
            bestPos = start
          }
          off = start
        }
        return best ? best.coordsAt(pos - bestPos, side) : null
      }
      coordsForChar(pos) {
        let { i, off } = this.childPos(pos, 1),
          child = this.children[i]
        if (!(child instanceof LineView)) return null
        while (child.children.length) {
          let { i, off: childOff } = child.childPos(off, 1)
          for (; ; i++) {
            if (i == child.children.length) return null
            if ((child = child.children[i]).length) break
          }
          off = childOff
        }
        if (!(child instanceof TextView)) return null
        let end = findClusterBreak(child.text, off)
        if (end == off) return null
        let rects = textRange(child.dom, off, end).getClientRects()
        for (let i = 0; i < rects.length; i++) {
          let rect = rects[i]
          if (
            i == rects.length - 1 ||
            (rect.top < rect.bottom && rect.left < rect.right)
          )
            return rect
        }
        return null
      }
      measureVisibleLineHeights(viewport) {
        let result = [],
          { from, to } = viewport
        let contentWidth = this.view.contentDOM.clientWidth
        let isWider =
          contentWidth >
          Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1
        let widest = -1,
          ltr = this.view.textDirection == Direction.LTR
        for (let pos = 0, i = 0; i < this.children.length; i++) {
          let child = this.children[i],
            end = pos + child.length
          if (end > to) break
          if (pos >= from) {
            let childRect = child.dom.getBoundingClientRect()
            result.push(childRect.height)
            if (isWider) {
              let last = child.dom.lastChild
              let rects = last ? clientRectsFor(last) : []
              if (rects.length) {
                let rect = rects[rects.length - 1]
                let width = ltr
                  ? rect.right - childRect.left
                  : childRect.right - rect.left
                if (width > widest) {
                  widest = width
                  this.minWidth = contentWidth
                  this.minWidthFrom = pos
                  this.minWidthTo = end
                }
              }
            }
          }
          pos = end + child.breakAfter
        }
        return result
      }
      textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1)
        return getComputedStyle(this.children[i].dom).direction == 'rtl'
          ? Direction.RTL
          : Direction.LTR
      }
      measureTextSize() {
        for (let child of this.children) {
          if (child instanceof LineView) {
            let measure = child.measureTextSize()
            if (measure) return measure
          }
        }
        // If no workable line exists, force a layout of a measurable element
        let dummy = document.createElement('div'),
          lineHeight,
          charWidth,
          textHeight
        dummy.className = 'cm-line'
        dummy.style.width = '99999px'
        dummy.style.position = 'absolute'
        dummy.textContent = 'abc def ghi jkl mno pqr stu'
        this.view.observer.ignore(() => {
          this.dom.appendChild(dummy)
          let rect = clientRectsFor(dummy.firstChild)[0]
          lineHeight = dummy.getBoundingClientRect().height
          charWidth = rect ? rect.width / 27 : 7
          textHeight = rect ? rect.height : lineHeight
          dummy.remove()
        })
        return { lineHeight, charWidth, textHeight }
      }
      childCursor(pos = this.length) {
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        let i = this.children.length
        if (i) pos -= this.children[--i].length
        return new ChildCursor(this.children, pos, i)
      }
      computeBlockGapDeco() {
        let deco = [],
          vs = this.view.viewState
        for (let pos = 0, i = 0; ; i++) {
          let next = i == vs.viewports.length ? null : vs.viewports[i]
          let end = next ? next.from - 1 : this.length
          if (end > pos) {
            let height =
              (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) /
              this.view.scaleY
            deco.push(
              Decoration.replace({
                widget: new BlockGapWidget(height),
                block: true,
                inclusive: true,
                isBlockGap: true
              }).range(pos, end)
            )
          }
          if (!next) break
          pos = next.to + 1
        }
        return Decoration.set(deco)
      }
      updateDeco() {
        let allDeco = this.view.state.facet(decorations).map((d, i) => {
          let dynamic = (this.dynamicDecorationMap[i] = typeof d == 'function')
          return dynamic ? d(this.view) : d
        })
        for (let i = allDeco.length; i < allDeco.length + 3; i++)
          this.dynamicDecorationMap[i] = false
        return (this.decorations = [
          ...allDeco,
          this.computeBlockGapDeco(),
          this.view.viewState.lineGapDeco
        ])
      }
      scrollIntoView(target) {
        if (target.isSnapshot) {
          let ref = this.view.viewState.lineBlockAt(target.range.head)
          this.view.scrollDOM.scrollTop = ref.top - target.yMargin
          this.view.scrollDOM.scrollLeft = target.xMargin
          return
        }
        let { range } = target
        let rect = this.coordsAt(
            range.head,
            range.empty ? range.assoc : range.head > range.anchor ? -1 : 1
          ),
          other
        if (!rect) return
        if (
          !range.empty &&
          (other = this.coordsAt(
            range.anchor,
            range.anchor > range.head ? -1 : 1
          ))
        )
          rect = {
            left: Math.min(rect.left, other.left),
            top: Math.min(rect.top, other.top),
            right: Math.max(rect.right, other.right),
            bottom: Math.max(rect.bottom, other.bottom)
          }
        let margins = getScrollMargins(this.view)
        let targetRect = {
          left: rect.left - margins.left,
          top: rect.top - margins.top,
          right: rect.right + margins.right,
          bottom: rect.bottom + margins.bottom
        }
        let { offsetWidth, offsetHeight } = this.view.scrollDOM
        scrollRectIntoView(
          this.view.scrollDOM,
          targetRect,
          range.head < range.anchor ? -1 : 1,
          target.x,
          target.y,
          Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth),
          Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight),
          this.view.textDirection == Direction.LTR
        )
      }
    }
    function betweenUneditable(pos) {
      return (
        pos.node.nodeType == 1 &&
        pos.node.firstChild &&
        (pos.offset == 0 ||
          pos.node.childNodes[pos.offset - 1].contentEditable == 'false') &&
        (pos.offset == pos.node.childNodes.length ||
          pos.node.childNodes[pos.offset].contentEditable == 'false')
      )
    }
    class BlockGapWidget extends WidgetType {
      constructor(height) {
        super()
        this.height = height
      }
      toDOM() {
        let elt = document.createElement('div')
        this.updateDOM(elt)
        return elt
      }
      eq(other) {
        return other.height == this.height
      }
      updateDOM(elt) {
        elt.style.height = this.height + 'px'
        return true
      }
      get estimatedHeight() {
        return this.height
      }
    }
    function findCompositionNode(view, headPos) {
      let sel = view.observer.selectionRange
      let textNode =
        sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0)
      if (!textNode) return null
      let from = headPos - textNode.offset
      return {
        from,
        to: from + textNode.node.nodeValue.length,
        node: textNode.node
      }
    }
    function findCompositionRange(view, changes, headPos) {
      let found = findCompositionNode(view, headPos)
      if (!found) return null
      let { node: textNode, from, to } = found,
        text = textNode.nodeValue
      // Don't try to preserve multi-line compositions
      if (/[\n\r]/.test(text)) return null
      if (view.state.doc.sliceString(found.from, found.to) != text) return null
      let inv = changes.invertedDesc
      let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to)
      let marks = []
      for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
        let parentView = ContentView.get(parent)
        if (parentView instanceof MarkView)
          marks.push({ node: parent, deco: parentView.mark })
        else if (
          parentView instanceof LineView ||
          (parent.nodeName == 'DIV' && parent.parentNode == view.contentDOM)
        )
          return { range, text: textNode, marks, line: parent }
        else if (parent != view.contentDOM)
          marks.push({
            node: parent,
            deco: new MarkDecoration({
              inclusive: true,
              attributes: getAttrs(parent),
              tagName: parent.tagName.toLowerCase()
            })
          })
        else return null
      }
    }
    function nearbyTextNode(startNode, startOffset, side) {
      if (side <= 0)
        for (let node = startNode, offset = startOffset; ; ) {
          if (node.nodeType == 3) return { node: node, offset: offset }
          if (node.nodeType == 1 && offset > 0) {
            node = node.childNodes[offset - 1]
            offset = maxOffset(node)
          } else {
            break
          }
        }
      if (side >= 0)
        for (let node = startNode, offset = startOffset; ; ) {
          if (node.nodeType == 3) return { node: node, offset: offset }
          if (
            node.nodeType == 1 &&
            offset < node.childNodes.length &&
            side >= 0
          ) {
            node = node.childNodes[offset]
            offset = 0
          } else {
            break
          }
        }
      return null
    }
    function nextToUneditable(node, offset) {
      if (node.nodeType != 1) return 0
      return (
        (offset && node.childNodes[offset - 1].contentEditable == 'false'
          ? 1 /* NextTo.Before */
          : 0) |
        (offset < node.childNodes.length &&
        node.childNodes[offset].contentEditable == 'false'
          ? 2 /* NextTo.After */
          : 0)
      )
    }
    let DecorationComparator$1 = class DecorationComparator {
      constructor() {
        this.changes = []
      }
      compareRange(from, to) {
        addRange(from, to, this.changes)
      }
      comparePoint(from, to) {
        addRange(from, to, this.changes)
      }
    }
    function findChangedDeco(a, b, diff) {
      let comp = new DecorationComparator$1()
      dist_RangeSet.compare(a, b, diff, comp)
      return comp.changes
    }
    function inUneditable(node, inside) {
      for (
        let cur = node;
        cur && cur != inside;
        cur = cur.assignedSlot || cur.parentNode
      ) {
        if (cur.nodeType == 1 && cur.contentEditable == 'false') {
          return true
        }
      }
      return false
    }
    function touchesComposition(changes, composition) {
      let touched = false
      if (composition)
        changes.iterChangedRanges((from, to) => {
          if (from < composition.to && to > composition.from) touched = true
        })
      return touched
    }

    function groupAt(state, pos, bias = 1) {
      let categorize = state.charCategorizer(pos)
      let line = state.doc.lineAt(pos),
        linePos = pos - line.from
      if (line.length == 0) return dist_EditorSelection.cursor(pos)
      if (linePos == 0) bias = 1
      else if (linePos == line.length) bias = -1
      let from = linePos,
        to = linePos
      if (bias < 0) from = findClusterBreak(line.text, linePos, false)
      else to = findClusterBreak(line.text, linePos)
      let cat = categorize(line.text.slice(from, to))
      while (from > 0) {
        let prev = findClusterBreak(line.text, from, false)
        if (categorize(line.text.slice(prev, from)) != cat) break
        from = prev
      }
      while (to < line.length) {
        let next = findClusterBreak(line.text, to)
        if (categorize(line.text.slice(to, next)) != cat) break
        to = next
      }
      return dist_EditorSelection.range(from + line.from, to + line.from)
    }
    // Search the DOM for the {node, offset} position closest to the given
    // coordinates. Very inefficient and crude, but can usually be avoided
    // by calling caret(Position|Range)FromPoint instead.
    function getdx(x, rect) {
      return rect.left > x ? rect.left - x : Math.max(0, x - rect.right)
    }
    function getdy(y, rect) {
      return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom)
    }
    function yOverlap(a, b) {
      return a.top < b.bottom - 1 && a.bottom > b.top + 1
    }
    function upTop(rect, top) {
      return top < rect.top
        ? { top, left: rect.left, right: rect.right, bottom: rect.bottom }
        : rect
    }
    function upBot(rect, bottom) {
      return bottom > rect.bottom
        ? { top: rect.top, left: rect.left, right: rect.right, bottom }
        : rect
    }
    function domPosAtCoords(parent, x, y) {
      let closest,
        closestRect,
        closestX,
        closestY,
        closestOverlap = false
      let above, below, aboveRect, belowRect
      for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child)
        for (let i = 0; i < rects.length; i++) {
          let rect = rects[i]
          if (closestRect && yOverlap(closestRect, rect))
            rect = upTop(upBot(rect, closestRect.bottom), closestRect.top)
          let dx = getdx(x, rect),
            dy = getdy(y, rect)
          if (dx == 0 && dy == 0)
            return child.nodeType == 3
              ? domPosInText(child, x, y)
              : domPosAtCoords(child, x, y)
          if (!closest || closestY > dy || (closestY == dy && closestX > dx)) {
            closest = child
            closestRect = rect
            closestX = dx
            closestY = dy
            let side = dy
              ? y < rect.top
                ? -1
                : 1
              : dx
                ? x < rect.left
                  ? -1
                  : 1
                : 0
            closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0)
          }
          if (dx == 0) {
            if (
              y > rect.bottom &&
              (!aboveRect || aboveRect.bottom < rect.bottom)
            ) {
              above = child
              aboveRect = rect
            } else if (
              y < rect.top &&
              (!belowRect || belowRect.top > rect.top)
            ) {
              below = child
              belowRect = rect
            }
          } else if (aboveRect && yOverlap(aboveRect, rect)) {
            aboveRect = upBot(aboveRect, rect.bottom)
          } else if (belowRect && yOverlap(belowRect, rect)) {
            belowRect = upTop(belowRect, rect.top)
          }
        }
      }
      if (aboveRect && aboveRect.bottom >= y) {
        closest = above
        closestRect = aboveRect
      } else if (belowRect && belowRect.top <= y) {
        closest = below
        closestRect = belowRect
      }
      if (!closest) return { node: parent, offset: 0 }
      let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x))
      if (closest.nodeType == 3) return domPosInText(closest, clipX, y)
      if (closestOverlap && closest.contentEditable != 'false')
        return domPosAtCoords(closest, clipX, y)
      let offset =
        Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0)
      return { node: parent, offset }
    }
    function domPosInText(node, x, y) {
      let len = node.nodeValue.length
      let closestOffset = -1,
        closestDY = 1e9,
        generalSide = 0
      for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects()
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j]
          if (rect.top == rect.bottom) continue
          if (!generalSide) generalSide = x - rect.left
          let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1
          if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
            let right = x >= (rect.left + rect.right) / 2,
              after = right
            if (browser.chrome || browser.gecko) {
              // Check for RTL on browsers that support getting client
              // rects for empty ranges.
              let rectBefore = textRange(node, i).getBoundingClientRect()
              if (rectBefore.left == rect.right) after = !right
            }
            if (dy <= 0) return { node, offset: i + (after ? 1 : 0) }
            closestOffset = i + (after ? 1 : 0)
            closestDY = dy
          }
        }
      }
      return {
        node,
        offset:
          closestOffset > -1
            ? closestOffset
            : generalSide > 0
              ? node.nodeValue.length
              : 0
      }
    }
    function posAtCoords(view, coords, precise, bias = -1) {
      var _a, _b
      let content = view.contentDOM.getBoundingClientRect(),
        docTop = content.top + view.viewState.paddingTop
      let block,
        { docHeight } = view.viewState
      let { x, y } = coords,
        yOffset = y - docTop
      if (yOffset < 0) return 0
      if (yOffset > docHeight) return view.state.doc.length
      // Scan for a text block near the queried y position
      for (
        let halfLine = view.viewState.heightOracle.textHeight / 2,
          bounced = false;
        ;

      ) {
        block = view.elementAtHeight(yOffset)
        if (block.type == BlockType.Text) break
        for (;;) {
          // Move the y position out of this block
          yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine
          if (yOffset >= 0 && yOffset <= docHeight) break
          // If the document consists entirely of replaced widgets, we
          // won't find a text block, so return 0
          if (bounced) return precise ? null : 0
          bounced = true
          bias = -bias
        }
      }
      y = docTop + yOffset
      let lineStart = block.from
      // If this is outside of the rendered viewport, we can't determine a position
      if (lineStart < view.viewport.from)
        return view.viewport.from == 0
          ? 0
          : precise
            ? null
            : posAtCoordsImprecise(view, content, block, x, y)
      if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length
          ? view.state.doc.length
          : precise
            ? null
            : posAtCoordsImprecise(view, content, block, x, y)
      // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
      let doc = view.dom.ownerDocument
      let root = view.root.elementFromPoint ? view.root : doc
      let element = root.elementFromPoint(x, y)
      if (element && !view.contentDOM.contains(element)) element = null
      // If the element is unexpected, clip x at the sides of the content area and try again
      if (!element) {
        x = Math.max(content.left + 1, Math.min(content.right - 1, x))
        element = root.elementFromPoint(x, y)
        if (element && !view.contentDOM.contains(element)) element = null
      }
      // There's visible editor content under the point, so we can try
      // using caret(Position|Range)FromPoint as a shortcut
      let node,
        offset = -1
      if (
        element &&
        ((_a = view.docView.nearest(element)) === null || _a === void 0
          ? void 0
          : _a.isEditable) != false
      ) {
        if (doc.caretPositionFromPoint) {
          let pos = doc.caretPositionFromPoint(x, y)
          if (pos) ({ offsetNode: node, offset } = pos)
        } else if (doc.caretRangeFromPoint) {
          let range = doc.caretRangeFromPoint(x, y)
          if (range) {
            ;({ startContainer: node, startOffset: offset } = range)
            if (
              !view.contentDOM.contains(node) ||
              (browser.safari &&
                isSuspiciousSafariCaretResult(node, offset, x)) ||
              (browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
            )
              node = undefined
          }
        }
      }
      // No luck, do our own (potentially expensive) search
      if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart)
        if (!line)
          return yOffset > block.top + block.height / 2 ? block.to : block.from
        ;({ node, offset } = domPosAtCoords(line.dom, x, y))
      }
      let nearest = view.docView.nearest(node)
      if (!nearest) return null
      if (
        nearest.isWidget &&
        ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) ==
          1
      ) {
        let rect = nearest.dom.getBoundingClientRect()
        return coords.y < rect.top ||
          (coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2)
          ? nearest.posAtStart
          : nearest.posAtEnd
      } else {
        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart
      }
    }
    function posAtCoordsImprecise(view, contentRect, block, x, y) {
      let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth)
      if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let textHeight = view.viewState.heightOracle.textHeight
        let line = Math.floor(
          (y - block.top - (view.defaultLineHeight - textHeight) * 0.5) /
            textHeight
        )
        into += line * view.viewState.heightOracle.lineLength
      }
      let content = view.state.sliceDoc(block.from, block.to)
      return block.from + findColumn(content, into, view.state.tabSize)
    }
    // In case of a high line height, Safari's caretRangeFromPoint treats
    // the space between lines as belonging to the last character of the
    // line before. This is used to detect such a result so that it can be
    // ignored (issue #401).
    function isSuspiciousSafariCaretResult(node, offset, x) {
      let len
      if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false
      for (let next = node.nextSibling; next; next = next.nextSibling)
        if (next.nodeType != 1 || next.nodeName != 'BR') return false
      return textRange(node, len - 1, len).getBoundingClientRect().left > x
    }
    // Chrome will move positions between lines to the start of the next line
    function isSuspiciousChromeCaretResult(node, offset, x) {
      if (offset != 0) return false
      for (let cur = node; ; ) {
        let parent = cur.parentNode
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
          return false
        if (parent.classList.contains('cm-line')) break
        cur = parent
      }
      let rect =
        node.nodeType == 1
          ? node.getBoundingClientRect()
          : textRange(
              node,
              0,
              Math.max(node.nodeValue.length, 1)
            ).getBoundingClientRect()
      return x - rect.left > 5
    }
    function blockAt(view, pos) {
      let line = view.lineBlockAt(pos)
      if (Array.isArray(line.type))
        for (let l of line.type) {
          if (
            l.to > pos ||
            (l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          )
            return l
        }
      return line
    }
    function moveToLineBoundary(view, start, forward, includeWrap) {
      let line = blockAt(view, start.head)
      let coords =
        !includeWrap ||
        line.type != BlockType.Text ||
        !(view.lineWrapping || line.widgetLineBreaks)
          ? null
          : view.coordsAtPos(
              start.assoc < 0 && start.head > line.from
                ? start.head - 1
                : start.head
            )
      if (coords) {
        let editorRect = view.dom.getBoundingClientRect()
        let direction = view.textDirectionAt(line.from)
        let pos = view.posAtCoords({
          x:
            forward == (direction == Direction.LTR)
              ? editorRect.right - 1
              : editorRect.left + 1,
          y: (coords.top + coords.bottom) / 2
        })
        if (pos != null)
          return dist_EditorSelection.cursor(pos, forward ? -1 : 1)
      }
      return dist_EditorSelection.cursor(
        forward ? line.to : line.from,
        forward ? -1 : 1
      )
    }
    function moveByChar(view, start, forward, by) {
      let line = view.state.doc.lineAt(start.head),
        spans = view.bidiSpans(line)
      let direction = view.textDirectionAt(line.from)
      for (let cur = start, check = null; ; ) {
        let next = moveVisually(line, spans, direction, cur, forward),
          char = movedOver
        if (!next) {
          if (line.number == (forward ? view.state.doc.lines : 1)) return cur
          char = '\n'
          line = view.state.doc.line(line.number + (forward ? 1 : -1))
          spans = view.bidiSpans(line)
          next = dist_EditorSelection.cursor(forward ? line.from : line.to)
        }
        if (!check) {
          if (!by) return next
          check = by(char)
        } else if (!check(char)) {
          return cur
        }
        cur = next
      }
    }
    function byGroup(view, pos, start) {
      let categorize = view.state.charCategorizer(pos)
      let cat = categorize(start)
      return (next) => {
        let nextCat = categorize(next)
        if (cat == dist_CharCategory.Space) cat = nextCat
        return cat == nextCat
      }
    }
    function moveVertically(view, start, forward, distance) {
      let startPos = start.head,
        dir = forward ? 1 : -1
      if (startPos == (forward ? view.state.doc.length : 0))
        return dist_EditorSelection.cursor(startPos, start.assoc)
      let goal = start.goalColumn,
        startY
      let rect = view.contentDOM.getBoundingClientRect()
      let startCoords = view.coordsAtPos(startPos, start.assoc || -1),
        docTop = view.documentTop
      if (startCoords) {
        if (goal == null) goal = startCoords.left - rect.left
        startY = dir < 0 ? startCoords.top : startCoords.bottom
      } else {
        let line = view.viewState.lineBlockAt(startPos)
        if (goal == null)
          goal = Math.min(
            rect.right - rect.left,
            view.defaultCharacterWidth * (startPos - line.from)
          )
        startY = (dir < 0 ? line.top : line.bottom) + docTop
      }
      let resolvedGoal = rect.left + goal
      let dist =
        distance !== null && distance !== void 0
          ? distance
          : view.viewState.heightOracle.textHeight >> 1
      for (let extra = 0; ; extra += 10) {
        let curY = startY + (dist + extra) * dir
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir)
        if (
          curY < rect.top ||
          curY > rect.bottom ||
          (dir < 0 ? pos < startPos : pos > startPos)
        ) {
          let charRect = view.docView.coordsForChar(pos)
          let assoc = !charRect || curY < charRect.top ? -1 : 1
          return dist_EditorSelection.cursor(pos, assoc, undefined, goal)
        }
      }
    }
    function skipAtomicRanges(atoms, pos, bias) {
      for (;;) {
        let moved = 0
        for (let set of atoms) {
          set.between(pos - 1, pos + 1, (from, to, value) => {
            if (pos > from && pos < to) {
              let side = moved || bias || (pos - from < to - pos ? -1 : 1)
              pos = side < 0 ? from : to
              moved = side
            }
          })
        }
        if (!moved) return pos
      }
    }
    function skipAtoms(view, oldPos, pos) {
      let newPos = skipAtomicRanges(
        view.state.facet(atomicRanges).map((f) => f(view)),
        pos.from,
        oldPos.head > pos.from ? -1 : 1
      )
      return newPos == pos.from
        ? pos
        : dist_EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1)
    }

    // This will also be where dragging info and such goes
    class InputState {
      setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin
        this.lastSelectionTime = Date.now()
      }
      constructor(view) {
        this.view = view
        this.lastKeyCode = 0
        this.lastKeyTime = 0
        this.lastTouchTime = 0
        this.lastFocusTime = 0
        this.lastScrollTop = 0
        this.lastScrollLeft = 0
        // On iOS, some keys need to have their default behavior happen
        // (after which we retroactively handle them and reset the DOM) to
        // avoid messing up the virtual keyboard state.
        this.pendingIOSKey = undefined
        this.lastSelectionOrigin = null
        this.lastSelectionTime = 0
        this.lastEscPress = 0
        this.lastContextMenu = 0
        this.scrollHandlers = []
        this.handlers = Object.create(null)
        // -1 means not in a composition. Otherwise, this counts the number
        // of changes made during the composition. The count is used to
        // avoid treating the start state of the composition, before any
        // changes have been made, as part of the composition.
        this.composing = -1
        // Tracks whether the next change should be marked as starting the
        // composition (null means no composition, true means next is the
        // first, false means first has already been marked for this
        // composition)
        this.compositionFirstChange = null
        // End time of the previous composition
        this.compositionEndedAt = 0
        // Used in a kludge to detect when an Enter keypress should be
        // considered part of the composition on Safari, which fires events
        // in the wrong order
        this.compositionPendingKey = false
        // Used to categorize changes as part of a composition, even when
        // the mutation events fire shortly after the compositionend event
        this.compositionPendingChange = false
        this.mouseSelection = null
        // When a drag from the editor is active, this points at the range
        // being dragged.
        this.draggedContent = null
        this.handleEvent = this.handleEvent.bind(this)
        this.notifiedFocused = view.hasFocus
        // On Safari adding an input event handler somehow prevents an
        // issue where the composition vanishes when you press enter.
        if (browser.safari)
          view.contentDOM.addEventListener('input', () => null)
        if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument)
      }
      handleEvent(event) {
        if (
          !eventBelongsToEditor(this.view, event) ||
          this.ignoreDuringComposition(event)
        )
          return
        if (event.type == 'keydown' && this.keydown(event)) return
        this.runHandlers(event.type, event)
      }
      runHandlers(type, event) {
        let handlers = this.handlers[type]
        if (handlers) {
          for (let observer of handlers.observers) observer(this.view, event)
          for (let handler of handlers.handlers) {
            if (event.defaultPrevented) break
            if (handler(this.view, event)) {
              event.preventDefault()
              break
            }
          }
        }
      }
      ensureHandlers(plugins) {
        let handlers = computeHandlers(plugins),
          prev = this.handlers,
          dom = this.view.contentDOM
        for (let type in handlers)
          if (type != 'scroll') {
            let passive = !handlers[type].handlers.length
            let exists = prev[type]
            if (exists && passive != !exists.handlers.length) {
              dom.removeEventListener(type, this.handleEvent)
              exists = null
            }
            if (!exists)
              dom.addEventListener(type, this.handleEvent, { passive })
          }
        for (let type in prev)
          if (type != 'scroll' && !handlers[type])
            dom.removeEventListener(type, this.handleEvent)
        this.handlers = handlers
      }
      keydown(event) {
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode
        this.lastKeyTime = Date.now()
        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000)
          return true
        if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
          this.view.inputState.lastEscPress = 0
        // Chrome for Android usually doesn't fire proper key events, but
        // occasionally does, usually surrounded by a bunch of complicated
        // composition changes. When an enter or backspace key event is
        // seen, hold off on handling DOM events for a bit, and then
        // dispatch it.
        if (
          browser.android &&
          browser.chrome &&
          !event.synthetic &&
          (event.keyCode == 13 || event.keyCode == 8)
        ) {
          this.view.observer.delayAndroidKey(event.key, event.keyCode)
          return true
        }
        // Preventing the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        let pending
        if (
          browser.ios &&
          !event.synthetic &&
          !event.altKey &&
          !event.metaKey &&
          (((pending = PendingKeys.find(
            (key) => key.keyCode == event.keyCode
          )) &&
            !event.ctrlKey) ||
            (EmacsyPendingKeys.indexOf(event.key) > -1 &&
              event.ctrlKey &&
              !event.shiftKey))
        ) {
          this.pendingIOSKey = pending || event
          setTimeout(() => this.flushIOSKey(), 250)
          return true
        }
        if (event.keyCode != 229) this.view.observer.forceFlush()
        return false
      }
      flushIOSKey() {
        let key = this.pendingIOSKey
        if (!key) return false
        this.pendingIOSKey = undefined
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode)
      }
      ignoreDuringComposition(event) {
        if (!/^key/.test(event.type)) return false
        if (this.composing > 0) return true
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (
          browser.safari &&
          !browser.ios &&
          this.compositionPendingKey &&
          Date.now() - this.compositionEndedAt < 100
        ) {
          this.compositionPendingKey = false
          return true
        }
        return false
      }
      startMouseSelection(mouseSelection) {
        if (this.mouseSelection) this.mouseSelection.destroy()
        this.mouseSelection = mouseSelection
      }
      update(update) {
        if (this.mouseSelection) this.mouseSelection.update(update)
        if (this.draggedContent && update.docChanged)
          this.draggedContent = this.draggedContent.map(update.changes)
        if (update.transactions.length)
          this.lastKeyCode = this.lastSelectionTime = 0
      }
      destroy() {
        if (this.mouseSelection) this.mouseSelection.destroy()
      }
    }
    function bindHandler(plugin, handler) {
      return (view, event) => {
        try {
          return handler.call(plugin, event, view)
        } catch (e) {
          dist_logException(view.state, e)
        }
      }
    }
    function computeHandlers(plugins) {
      let result = Object.create(null)
      function record(type) {
        return result[type] || (result[type] = { observers: [], handlers: [] })
      }
      for (let plugin of plugins) {
        let spec = plugin.spec
        if (spec && spec.domEventHandlers)
          for (let type in spec.domEventHandlers) {
            let f = spec.domEventHandlers[type]
            if (f) record(type).handlers.push(bindHandler(plugin.value, f))
          }
        if (spec && spec.domEventObservers)
          for (let type in spec.domEventObservers) {
            let f = spec.domEventObservers[type]
            if (f) record(type).observers.push(bindHandler(plugin.value, f))
          }
      }
      for (let type in handlers) record(type).handlers.push(handlers[type])
      for (let type in observers) record(type).observers.push(observers[type])
      return result
    }
    const PendingKeys = [
      { key: 'Backspace', keyCode: 8, inputType: 'deleteContentBackward' },
      { key: 'Enter', keyCode: 13, inputType: 'insertParagraph' },
      { key: 'Enter', keyCode: 13, inputType: 'insertLineBreak' },
      { key: 'Delete', keyCode: 46, inputType: 'deleteContentForward' }
    ]
    const EmacsyPendingKeys = 'dthko'
    // Key codes for modifier keys
    const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225]
    const dragScrollMargin = 6
    function dragScrollSpeed(dist) {
      return Math.max(0, dist) * 0.7 + 8
    }
    function dist(a, b) {
      return Math.max(
        Math.abs(a.clientX - b.clientX),
        Math.abs(a.clientY - b.clientY)
      )
    }
    class MouseSelection {
      constructor(view, startEvent, style, mustSelect) {
        this.view = view
        this.startEvent = startEvent
        this.style = style
        this.mustSelect = mustSelect
        this.scrollSpeed = { x: 0, y: 0 }
        this.scrolling = -1
        this.lastEvent = startEvent
        this.scrollParent = scrollableParent(view.contentDOM)
        this.atoms = view.state.facet(atomicRanges).map((f) => f(view))
        let doc = view.contentDOM.ownerDocument
        doc.addEventListener('mousemove', (this.move = this.move.bind(this)))
        doc.addEventListener('mouseup', (this.up = this.up.bind(this)))
        this.extend = startEvent.shiftKey
        this.multiple =
          view.state.facet(EditorState.allowMultipleSelections) &&
          addsSelectionRange(view, startEvent)
        this.dragging =
          isInPrimarySelection(view, startEvent) &&
          getClickType(startEvent) == 1
            ? null
            : false
      }
      start(event) {
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false) this.select(event)
      }
      move(event) {
        var _a
        if (event.buttons == 0) return this.destroy()
        if (
          this.dragging ||
          (this.dragging == null && dist(this.startEvent, event) < 10)
        )
          return
        this.select((this.lastEvent = event))
        let sx = 0,
          sy = 0
        let rect = ((_a = this.scrollParent) === null || _a === void 0
          ? void 0
          : _a.getBoundingClientRect()) || {
          left: 0,
          top: 0,
          right: this.view.win.innerWidth,
          bottom: this.view.win.innerHeight
        }
        let margins = getScrollMargins(this.view)
        if (event.clientX - margins.left <= rect.left + dragScrollMargin)
          sx = -dragScrollSpeed(rect.left - event.clientX)
        else if (event.clientX + margins.right >= rect.right - dragScrollMargin)
          sx = dragScrollSpeed(event.clientX - rect.right)
        if (event.clientY - margins.top <= rect.top + dragScrollMargin)
          sy = -dragScrollSpeed(rect.top - event.clientY)
        else if (
          event.clientY + margins.bottom >=
          rect.bottom - dragScrollMargin
        )
          sy = dragScrollSpeed(event.clientY - rect.bottom)
        this.setScrollSpeed(sx, sy)
      }
      up(event) {
        if (this.dragging == null) this.select(this.lastEvent)
        if (!this.dragging) event.preventDefault()
        this.destroy()
      }
      destroy() {
        this.setScrollSpeed(0, 0)
        let doc = this.view.contentDOM.ownerDocument
        doc.removeEventListener('mousemove', this.move)
        doc.removeEventListener('mouseup', this.up)
        this.view.inputState.mouseSelection =
          this.view.inputState.draggedContent = null
      }
      setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy }
        if (sx || sy) {
          if (this.scrolling < 0)
            this.scrolling = setInterval(() => this.scroll(), 50)
        } else if (this.scrolling > -1) {
          clearInterval(this.scrolling)
          this.scrolling = -1
        }
      }
      scroll() {
        if (this.scrollParent) {
          this.scrollParent.scrollLeft += this.scrollSpeed.x
          this.scrollParent.scrollTop += this.scrollSpeed.y
        } else {
          this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y)
        }
        if (this.dragging === false) this.select(this.lastEvent)
      }
      skipAtoms(sel) {
        let ranges = null
        for (let i = 0; i < sel.ranges.length; i++) {
          let range = sel.ranges[i],
            updated = null
          if (range.empty) {
            let pos = skipAtomicRanges(this.atoms, range.from, 0)
            if (pos != range.from)
              updated = dist_EditorSelection.cursor(pos, -1)
          } else {
            let from = skipAtomicRanges(this.atoms, range.from, -1)
            let to = skipAtomicRanges(this.atoms, range.to, 1)
            if (from != range.from || to != range.to)
              updated = dist_EditorSelection.range(
                range.from == range.anchor ? from : to,
                range.from == range.head ? from : to
              )
          }
          if (updated) {
            if (!ranges) ranges = sel.ranges.slice()
            ranges[i] = updated
          }
        }
        return ranges ? dist_EditorSelection.create(ranges, sel.mainIndex) : sel
      }
      select(event) {
        let { view } = this,
          selection = this.skipAtoms(
            this.style.get(event, this.extend, this.multiple)
          )
        if (
          this.mustSelect ||
          !selection.eq(view.state.selection) ||
          (selection.main.assoc != view.state.selection.main.assoc &&
            this.dragging === false)
        )
          this.view.dispatch({
            selection,
            userEvent: 'select.pointer'
          })
        this.mustSelect = false
      }
      update(update) {
        if (this.style.update(update))
          setTimeout(() => this.select(this.lastEvent), 20)
      }
    }
    function addsSelectionRange(view, event) {
      let facet = view.state.facet(clickAddsSelectionRange)
      return facet.length
        ? facet[0](event)
        : browser.mac
          ? event.metaKey
          : event.ctrlKey
    }
    function dragMovesSelection(view, event) {
      let facet = view.state.facet(dragMovesSelection$1)
      return facet.length
        ? facet[0](event)
        : browser.mac
          ? !event.altKey
          : !event.ctrlKey
    }
    function isInPrimarySelection(view, event) {
      let { main } = view.state.selection
      if (main.empty) return false
      // On boundary clicks, check whether the coordinates are inside the
      // selection's client rectangles
      let sel = getSelection(view.root)
      if (!sel || sel.rangeCount == 0) return true
      let rects = sel.getRangeAt(0).getClientRects()
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i]
        if (
          rect.left <= event.clientX &&
          rect.right >= event.clientX &&
          rect.top <= event.clientY &&
          rect.bottom >= event.clientY
        )
          return true
      }
      return false
    }
    function eventBelongsToEditor(view, event) {
      if (!event.bubbles) return true
      if (event.defaultPrevented) return false
      for (
        let node = event.target, cView;
        node != view.contentDOM;
        node = node.parentNode
      )
        if (
          !node ||
          node.nodeType == 11 ||
          ((cView = ContentView.get(node)) && cView.ignoreEvent(event))
        )
          return false
      return true
    }
    const handlers = /*@__PURE__*/ Object.create(null)
    const observers = /*@__PURE__*/ Object.create(null)
    // This is very crude, but unfortunately both these browsers _pretend_
    // that they have a clipboard API—all the objects and methods are
    // there, they just don't work, and they are hard to test.
    const brokenClipboardAPI =
      (browser.ie && browser.ie_version < 15) ||
      (browser.ios && browser.webkit_version < 604)
    function capturePaste(view) {
      let parent = view.dom.parentNode
      if (!parent) return
      let target = parent.appendChild(document.createElement('textarea'))
      target.style.cssText = 'position: fixed; left: -10000px; top: 10px'
      target.focus()
      setTimeout(() => {
        view.focus()
        target.remove()
        doPaste(view, target.value)
      }, 50)
    }
    function doPaste(view, input) {
      let { state } = view,
        changes,
        i = 1,
        text = state.toText(input)
      let byLine = text.lines == state.selection.ranges.length
      let linewise =
        lastLinewiseCopy != null &&
        state.selection.ranges.every((r) => r.empty) &&
        lastLinewiseCopy == text.toString()
      if (linewise) {
        let lastLine = -1
        changes = state.changeByRange((range) => {
          let line = state.doc.lineAt(range.from)
          if (line.from == lastLine) return { range }
          lastLine = line.from
          let insert = state.toText(
            (byLine ? text.line(i++).text : input) + state.lineBreak
          )
          return {
            changes: { from: line.from, insert },
            range: dist_EditorSelection.cursor(range.from + insert.length)
          }
        })
      } else if (byLine) {
        changes = state.changeByRange((range) => {
          let line = text.line(i++)
          return {
            changes: { from: range.from, to: range.to, insert: line.text },
            range: dist_EditorSelection.cursor(range.from + line.length)
          }
        })
      } else {
        changes = state.replaceSelection(text)
      }
      view.dispatch(changes, {
        userEvent: 'input.paste',
        scrollIntoView: true
      })
    }
    observers.scroll = (view) => {
      view.inputState.lastScrollTop = view.scrollDOM.scrollTop
      view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft
    }
    handlers.keydown = (view, event) => {
      view.inputState.setSelectionOrigin('select')
      if (event.keyCode == 27) view.inputState.lastEscPress = Date.now()
      return false
    }
    observers.touchstart = (view, e) => {
      view.inputState.lastTouchTime = Date.now()
      view.inputState.setSelectionOrigin('select.pointer')
    }
    observers.touchmove = (view) => {
      view.inputState.setSelectionOrigin('select.pointer')
    }
    handlers.mousedown = (view, event) => {
      view.observer.flush()
      if (view.inputState.lastTouchTime > Date.now() - 2000) return false // Ignore touch interaction
      let style = null
      for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event)
        if (style) break
      }
      if (!style && event.button == 0) style = basicMouseSelection(view, event)
      if (style) {
        let mustFocus = !view.hasFocus
        view.inputState.startMouseSelection(
          new MouseSelection(view, event, style, mustFocus)
        )
        if (mustFocus)
          view.observer.ignore(() => focusPreventScroll(view.contentDOM))
        let mouseSel = view.inputState.mouseSelection
        if (mouseSel) {
          mouseSel.start(event)
          return mouseSel.dragging === false
        }
      }
      return false
    }
    function rangeForClick(view, pos, bias, type) {
      if (type == 1) {
        // Single click
        return dist_EditorSelection.cursor(pos, bias)
      } else if (type == 2) {
        // Double click
        return groupAt(view.state, pos, bias)
      } else {
        // Triple click
        let visual = LineView.find(view.docView, pos),
          line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos)
        let from = visual ? visual.posAtStart : line.from,
          to = visual ? visual.posAtEnd : line.to
        if (to < view.state.doc.length && to == line.to) to++
        return dist_EditorSelection.range(from, to)
      }
    }
    let insideY = (y, rect) => y >= rect.top && y <= rect.bottom
    let inside = (x, y, rect) =>
      insideY(y, rect) && x >= rect.left && x <= rect.right
    // Try to determine, for the given coordinates, associated with the
    // given position, whether they are related to the element before or
    // the element after the position.
    function findPositionSide(view, pos, x, y) {
      let line = LineView.find(view.docView, pos)
      if (!line) return 1
      let off = pos - line.posAtStart
      // Line boundaries point into the line
      if (off == 0) return 1
      if (off == line.length) return -1
      // Positions on top of an element point at that element
      let before = line.coordsAt(off, -1)
      if (before && inside(x, y, before)) return -1
      let after = line.coordsAt(off, 1)
      if (after && inside(x, y, after)) return 1
      // This is probably a line wrap point. Pick before if the point is
      // beside it.
      return before && insideY(y, before) ? -1 : 1
    }
    function queryPos(view, event) {
      let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false)
      return {
        pos,
        bias: findPositionSide(view, pos, event.clientX, event.clientY)
      }
    }
    const BadMouseDetail = browser.ie && browser.ie_version <= 11
    let lastMouseDown = null,
      lastMouseDownCount = 0,
      lastMouseDownTime = 0
    function getClickType(event) {
      if (!BadMouseDetail) return event.detail
      let last = lastMouseDown,
        lastTime = lastMouseDownTime
      lastMouseDown = event
      lastMouseDownTime = Date.now()
      return (lastMouseDownCount =
        !last ||
        (lastTime > Date.now() - 400 &&
          Math.abs(last.clientX - event.clientX) < 2 &&
          Math.abs(last.clientY - event.clientY) < 2)
          ? (lastMouseDownCount + 1) % 3
          : 1)
    }
    function basicMouseSelection(view, event) {
      let start = queryPos(view, event),
        type = getClickType(event)
      let startSel = view.state.selection
      return {
        update(update) {
          if (update.docChanged) {
            start.pos = update.changes.mapPos(start.pos)
            startSel = startSel.map(update.changes)
          }
        },
        get(event, extend, multiple) {
          let cur = queryPos(view, event),
            removed
          let range = rangeForClick(view, cur.pos, cur.bias, type)
          if (start.pos != cur.pos && !extend) {
            let startRange = rangeForClick(view, start.pos, start.bias, type)
            let from = Math.min(startRange.from, range.from),
              to = Math.max(startRange.to, range.to)
            range =
              from < range.from
                ? dist_EditorSelection.range(from, to)
                : dist_EditorSelection.range(to, from)
          }
          if (extend)
            return startSel.replaceRange(
              startSel.main.extend(range.from, range.to)
            )
          else if (
            multiple &&
            type == 1 &&
            startSel.ranges.length > 1 &&
            (removed = removeRangeAround(startSel, cur.pos))
          )
            return removed
          else if (multiple) return startSel.addRange(range)
          else return dist_EditorSelection.create([range])
        }
      }
    }
    function removeRangeAround(sel, pos) {
      for (let i = 0; i < sel.ranges.length; i++) {
        let { from, to } = sel.ranges[i]
        if (from <= pos && to >= pos)
          return dist_EditorSelection.create(
            sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)),
            sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0)
          )
      }
      return null
    }
    handlers.dragstart = (view, event) => {
      let {
        selection: { main: range }
      } = view.state
      if (event.target.draggable) {
        let cView = view.docView.nearest(event.target)
        if (cView && cView.isWidget) {
          let from = cView.posAtStart,
            to = from + cView.length
          if (from >= range.to || to <= range.from)
            range = dist_EditorSelection.range(from, to)
        }
      }
      let { inputState } = view
      if (inputState.mouseSelection) inputState.mouseSelection.dragging = true
      inputState.draggedContent = range
      if (event.dataTransfer) {
        event.dataTransfer.setData(
          'Text',
          view.state.sliceDoc(range.from, range.to)
        )
        event.dataTransfer.effectAllowed = 'copyMove'
      }
      return false
    }
    handlers.dragend = (view) => {
      view.inputState.draggedContent = null
      return false
    }
    function dropText(view, event, text, direct) {
      if (!text) return
      let dropPos = view.posAtCoords(
        { x: event.clientX, y: event.clientY },
        false
      )
      let { draggedContent } = view.inputState
      let del =
        direct && draggedContent && dragMovesSelection(view, event)
          ? { from: draggedContent.from, to: draggedContent.to }
          : null
      let ins = { from: dropPos, insert: text }
      let changes = view.state.changes(del ? [del, ins] : ins)
      view.focus()
      view.dispatch({
        changes,
        selection: {
          anchor: changes.mapPos(dropPos, -1),
          head: changes.mapPos(dropPos, 1)
        },
        userEvent: del ? 'move.drop' : 'input.drop'
      })
      view.inputState.draggedContent = null
    }
    handlers.drop = (view, event) => {
      if (!event.dataTransfer) return false
      if (view.state.readOnly) return true
      let files = event.dataTransfer.files
      if (files && files.length) {
        // For a file drop, read the file's text.
        let text = Array(files.length),
          read = 0
        let finishFile = () => {
          if (++read == files.length)
            dropText(
              view,
              event,
              text.filter((s) => s != null).join(view.state.lineBreak),
              false
            )
        }
        for (let i = 0; i < files.length; i++) {
          let reader = new FileReader()
          reader.onerror = finishFile
          reader.onload = () => {
            if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
              text[i] = reader.result
            finishFile()
          }
          reader.readAsText(files[i])
        }
        return true
      } else {
        let text = event.dataTransfer.getData('Text')
        if (text) {
          dropText(view, event, text, true)
          return true
        }
      }
      return false
    }
    handlers.paste = (view, event) => {
      if (view.state.readOnly) return true
      view.observer.flush()
      let data = brokenClipboardAPI ? null : event.clipboardData
      if (data) {
        doPaste(
          view,
          data.getData('text/plain') || data.getData('text/uri-text')
        )
        return true
      } else {
        capturePaste(view)
        return false
      }
    }
    function captureCopy(view, text) {
      // The extra wrapper is somehow necessary on IE/Edge to prevent the
      // content from being mangled when it is put onto the clipboard
      let parent = view.dom.parentNode
      if (!parent) return
      let target = parent.appendChild(document.createElement('textarea'))
      target.style.cssText = 'position: fixed; left: -10000px; top: 10px'
      target.value = text
      target.focus()
      target.selectionEnd = text.length
      target.selectionStart = 0
      setTimeout(() => {
        target.remove()
        view.focus()
      }, 50)
    }
    function copiedRange(state) {
      let content = [],
        ranges = [],
        linewise = false
      for (let range of state.selection.ranges)
        if (!range.empty) {
          content.push(state.sliceDoc(range.from, range.to))
          ranges.push(range)
        }
      if (!content.length) {
        // Nothing selected, do a line-wise copy
        let upto = -1
        for (let { from } of state.selection.ranges) {
          let line = state.doc.lineAt(from)
          if (line.number > upto) {
            content.push(line.text)
            ranges.push({
              from: line.from,
              to: Math.min(state.doc.length, line.to + 1)
            })
          }
          upto = line.number
        }
        linewise = true
      }
      return { text: content.join(state.lineBreak), ranges, linewise }
    }
    let lastLinewiseCopy = null
    handlers.copy = handlers.cut = (view, event) => {
      let { text, ranges, linewise } = copiedRange(view.state)
      if (!text && !linewise) return false
      lastLinewiseCopy = linewise ? text : null
      if (event.type == 'cut' && !view.state.readOnly)
        view.dispatch({
          changes: ranges,
          scrollIntoView: true,
          userEvent: 'delete.cut'
        })
      let data = brokenClipboardAPI ? null : event.clipboardData
      if (data) {
        data.clearData()
        data.setData('text/plain', text)
        return true
      } else {
        captureCopy(view, text)
        return false
      }
    }
    const isFocusChange = /*@__PURE__*/ Annotation.define()
    function focusChangeTransaction(state, focus) {
      let effects = []
      for (let getEffect of state.facet(focusChangeEffect)) {
        let effect = getEffect(state, focus)
        if (effect) effects.push(effect)
      }
      return effects
        ? state.update({ effects, annotations: isFocusChange.of(true) })
        : null
    }
    function updateForFocusChange(view) {
      setTimeout(() => {
        let focus = view.hasFocus
        if (focus != view.inputState.notifiedFocused) {
          let tr = focusChangeTransaction(view.state, focus)
          if (tr) view.dispatch(tr)
          else view.update([])
        }
      }, 10)
    }
    observers.focus = (view) => {
      view.inputState.lastFocusTime = Date.now()
      // When focusing reset the scroll position, move it back to where it was
      if (
        !view.scrollDOM.scrollTop &&
        (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)
      ) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft
      }
      updateForFocusChange(view)
    }
    observers.blur = (view) => {
      view.observer.clearSelectionRange()
      updateForFocusChange(view)
    }
    observers.compositionstart = observers.compositionupdate = (view) => {
      if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true
      if (view.inputState.composing < 0) {
        // FIXME possibly set a timeout to clear it again on Android
        view.inputState.composing = 0
      }
    }
    observers.compositionend = (view) => {
      view.inputState.composing = -1
      view.inputState.compositionEndedAt = Date.now()
      view.inputState.compositionPendingKey = true
      view.inputState.compositionPendingChange =
        view.observer.pendingRecords().length > 0
      view.inputState.compositionFirstChange = null
      if (browser.chrome && browser.android) {
        // Delay flushing for a bit on Android because it'll often fire a
        // bunch of contradictory changes in a row at end of compositon
        view.observer.flushSoon()
      } else if (view.inputState.compositionPendingChange) {
        // If we found pending records, schedule a flush.
        Promise.resolve().then(() => view.observer.flush())
      } else {
        // Otherwise, make sure that, if no changes come in soon, the
        // composition view is cleared.
        setTimeout(() => {
          if (view.inputState.composing < 0 && view.docView.hasComposition)
            view.update([])
        }, 50)
      }
    }
    observers.contextmenu = (view) => {
      view.inputState.lastContextMenu = Date.now()
    }
    handlers.beforeinput = (view, event) => {
      var _a
      // Because Chrome Android doesn't fire useful key events, use
      // beforeinput to detect backspace (and possibly enter and delete,
      // but those usually don't even seem to fire beforeinput events at
      // the moment) and fake a key event for it.
      //
      // (preventDefault on beforeinput, though supported in the spec,
      // seems to do nothing at all on Chrome).
      let pending
      if (
        browser.chrome &&
        browser.android &&
        (pending = PendingKeys.find((key) => key.inputType == event.inputType))
      ) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode)
        if (pending.key == 'Backspace' || pending.key == 'Delete') {
          let startViewHeight =
            ((_a = window.visualViewport) === null || _a === void 0
              ? void 0
              : _a.height) || 0
          setTimeout(() => {
            var _a
            // Backspacing near uneditable nodes on Chrome Android sometimes
            // closes the virtual keyboard. This tries to crudely detect
            // that and refocus to get it back.
            if (
              (((_a = window.visualViewport) === null || _a === void 0
                ? void 0
                : _a.height) || 0) >
                startViewHeight + 10 &&
              view.hasFocus
            ) {
              view.contentDOM.blur()
              view.focus()
            }
          }, 100)
        }
      }
      return false
    }
    const appliedFirefoxHack = /*@__PURE__*/ new Set()
    // In Firefox, when cut/copy handlers are added to the document, that
    // somehow avoids a bug where those events aren't fired when the
    // selection is empty. See https://github.com/codemirror/dev/issues/1082
    // and https://bugzilla.mozilla.org/show_bug.cgi?id=995961
    function firefoxCopyCutHack(doc) {
      if (!appliedFirefoxHack.has(doc)) {
        appliedFirefoxHack.add(doc)
        doc.addEventListener('copy', () => {})
        doc.addEventListener('cut', () => {})
      }
    }

    const wrappingWhiteSpace = [
      'pre-wrap',
      'normal',
      'pre-line',
      'break-spaces'
    ]
    class HeightOracle {
      constructor(lineWrapping) {
        this.lineWrapping = lineWrapping
        this.doc = Text.empty
        this.heightSamples = {}
        this.lineHeight = 14 // The height of an entire line (line-height)
        this.charWidth = 7
        this.textHeight = 14 // The height of the actual font (font-size)
        this.lineLength = 30
        // Used to track, during updateHeight, if any actual heights changed
        this.heightChanged = false
      }
      heightForGap(from, to) {
        let lines =
          this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1
        if (this.lineWrapping)
          lines += Math.max(
            0,
            Math.ceil(
              (to - from - lines * this.lineLength * 0.5) / this.lineLength
            )
          )
        return this.lineHeight * lines
      }
      heightForLine(length) {
        if (!this.lineWrapping) return this.lineHeight
        let lines =
          1 +
          Math.max(
            0,
            Math.ceil((length - this.lineLength) / (this.lineLength - 5))
          )
        return lines * this.lineHeight
      }
      setDoc(doc) {
        this.doc = doc
        return this
      }
      mustRefreshForWrapping(whiteSpace) {
        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping
      }
      mustRefreshForHeights(lineHeights) {
        let newHeight = false
        for (let i = 0; i < lineHeights.length; i++) {
          let h = lineHeights[i]
          if (h < 0) {
            i++
          } else if (!this.heightSamples[Math.floor(h * 10)]) {
            // Round to .1 pixels
            newHeight = true
            this.heightSamples[Math.floor(h * 10)] = true
          }
        }
        return newHeight
      }
      refresh(
        whiteSpace,
        lineHeight,
        charWidth,
        textHeight,
        lineLength,
        knownHeights
      ) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1
        let changed =
          Math.round(lineHeight) != Math.round(this.lineHeight) ||
          this.lineWrapping != lineWrapping
        this.lineWrapping = lineWrapping
        this.lineHeight = lineHeight
        this.charWidth = charWidth
        this.textHeight = textHeight
        this.lineLength = lineLength
        if (changed) {
          this.heightSamples = {}
          for (let i = 0; i < knownHeights.length; i++) {
            let h = knownHeights[i]
            if (h < 0) i++
            else this.heightSamples[Math.floor(h * 10)] = true
          }
        }
        return changed
      }
    }
    // This object is used by `updateHeight` to make DOM measurements
    // arrive at the right nides. The `heights` array is a sequence of
    // block heights, starting from position `from`.
    class MeasuredHeights {
      constructor(from, heights) {
        this.from = from
        this.heights = heights
        this.index = 0
      }
      get more() {
        return this.index < this.heights.length
      }
    }
    /**
Record used to represent information about a block-level element
in the editor view.
*/
    class BlockInfo {
      /**
    @internal
    */
      constructor(
        /**
    The start of the element in the document.
    */
        from,
        /**
    The length of the element.
    */
        length,
        /**
    The top position of the element (relative to the top of the
    document).
    */
        top,
        /**
    Its height.
    */
        height,
        /**
    @internal Weird packed field that holds an array of children
    for composite blocks, a decoration for block widgets, and a
    number indicating the amount of widget-create line breaks for
    text blocks.
    */
        _content
      ) {
        this.from = from
        this.length = length
        this.top = top
        this.height = height
        this._content = _content
      }
      /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
      get type() {
        return typeof this._content == 'number'
          ? BlockType.Text
          : Array.isArray(this._content)
            ? this._content
            : this._content.type
      }
      /**
    The end of the element as a document position.
    */
      get to() {
        return this.from + this.length
      }
      /**
    The bottom position of the element.
    */
      get bottom() {
        return this.top + this.height
      }
      /**
    If this is a widget block, this will return the widget
    associated with it.
    */
      get widget() {
        return this._content instanceof PointDecoration
          ? this._content.widget
          : null
      }
      /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
      get widgetLineBreaks() {
        return typeof this._content == 'number' ? this._content : 0
      }
      /**
    @internal
    */
      join(other) {
        let content = (
          Array.isArray(this._content) ? this._content : [this]
        ).concat(Array.isArray(other._content) ? other._content : [other])
        return new BlockInfo(
          this.from,
          this.length + other.length,
          this.top,
          this.height + other.height,
          content
        )
      }
    }
    var QueryType = /*@__PURE__*/ (function (QueryType) {
      QueryType[(QueryType['ByPos'] = 0)] = 'ByPos'
      QueryType[(QueryType['ByHeight'] = 1)] = 'ByHeight'
      QueryType[(QueryType['ByPosNoHeight'] = 2)] = 'ByPosNoHeight'
      return QueryType
    })(QueryType || (QueryType = {}))
    const Epsilon = 1e-3
    class HeightMap {
      constructor(
        length, // The number of characters covered
        height, // Height of this part of the document
        flags = 2 /* Flag.Outdated */
      ) {
        this.length = length
        this.height = height
        this.flags = flags
      }
      get outdated() {
        return (this.flags & 2) /* Flag.Outdated */ > 0
      }
      set outdated(value) {
        this.flags =
          (value ? 2 /* Flag.Outdated */ : 0) |
          (this.flags & ~2) /* Flag.Outdated */
      }
      setHeight(oracle, height) {
        if (this.height != height) {
          if (Math.abs(this.height - height) > Epsilon)
            oracle.heightChanged = true
          this.height = height
        }
      }
      // Base case is to replace a leaf node, which simply builds a tree
      // from the new nodes and returns that (HeightMapBranch and
      // HeightMapGap override this to actually use from/to)
      replace(_from, _to, nodes) {
        return HeightMap.of(nodes)
      }
      // Again, these are base cases, and are overridden for branch and gap nodes.
      decomposeLeft(_to, result) {
        result.push(this)
      }
      decomposeRight(_from, result) {
        result.push(this)
      }
      applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this,
          doc = oracle.doc
        for (let i = changes.length - 1; i >= 0; i--) {
          let { fromA, toA, fromB, toB } = changes[i]
          let start = me.lineAt(
            fromA,
            QueryType.ByPosNoHeight,
            oracle.setDoc(oldDoc),
            0,
            0
          )
          let end =
            start.to >= toA
              ? start
              : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0)
          toB += end.to - toA
          toA = end.to
          while (i > 0 && start.from <= changes[i - 1].toA) {
            fromA = changes[i - 1].fromA
            fromB = changes[i - 1].fromB
            i--
            if (fromA < start.from)
              start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0)
          }
          fromB += start.from - fromA
          fromA = start.from
          let nodes = NodeBuilder.build(
            oracle.setDoc(doc),
            decorations,
            fromB,
            toB
          )
          me = me.replace(fromA, toA, nodes)
        }
        return me.updateHeight(oracle, 0)
      }
      static empty() {
        return new HeightMapText(0, 0)
      }
      // nodes uses null values to indicate the position of line breaks.
      // There are never line breaks at the start or end of the array, or
      // two line breaks next to each other, and the array isn't allowed
      // to be empty (same restrictions as return value from the builder).
      static of(nodes) {
        if (nodes.length == 1) return nodes[0]
        let i = 0,
          j = nodes.length,
          before = 0,
          after = 0
        for (;;) {
          if (i == j) {
            if (before > after * 2) {
              let split = nodes[i - 1]
              if (split.break)
                nodes.splice(--i, 1, split.left, null, split.right)
              else nodes.splice(--i, 1, split.left, split.right)
              j += 1 + split.break
              before -= split.size
            } else if (after > before * 2) {
              let split = nodes[j]
              if (split.break) nodes.splice(j, 1, split.left, null, split.right)
              else nodes.splice(j, 1, split.left, split.right)
              j += 2 + split.break
              after -= split.size
            } else {
              break
            }
          } else if (before < after) {
            let next = nodes[i++]
            if (next) before += next.size
          } else {
            let next = nodes[--j]
            if (next) after += next.size
          }
        }
        let brk = 0
        if (nodes[i - 1] == null) {
          brk = 1
          i--
        } else if (nodes[i] == null) {
          brk = 1
          j++
        }
        return new HeightMapBranch(
          HeightMap.of(nodes.slice(0, i)),
          brk,
          HeightMap.of(nodes.slice(j))
        )
      }
    }
    HeightMap.prototype.size = 1
    class HeightMapBlock extends HeightMap {
      constructor(length, height, deco) {
        super(length, height)
        this.deco = deco
      }
      blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(
          offset,
          this.length,
          top,
          this.height,
          this.deco || 0
        )
      }
      lineAt(_value, _type, oracle, top, offset) {
        return this.blockAt(0, oracle, top, offset)
      }
      forEachLine(from, to, oracle, top, offset, f) {
        if (from <= offset + this.length && to >= offset)
          f(this.blockAt(0, oracle, top, offset))
      }
      updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
          this.setHeight(oracle, measured.heights[measured.index++])
        this.outdated = false
        return this
      }
      toString() {
        return `block(${this.length})`
      }
    }
    class HeightMapText extends HeightMapBlock {
      constructor(length, height) {
        super(length, height, null)
        this.collapsed = 0 // Amount of collapsed content in the line
        this.widgetHeight = 0 // Maximum inline widget height
        this.breaks = 0 // Number of widget-introduced line breaks on the line
      }
      blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.breaks)
      }
      replace(_from, _to, nodes) {
        let node = nodes[0]
        if (
          nodes.length == 1 &&
          (node instanceof HeightMapText ||
            (node instanceof HeightMapGap &&
              node.flags & 4 /* Flag.SingleLine */)) &&
          Math.abs(this.length - node.length) < 10
        ) {
          if (node instanceof HeightMapGap)
            node = new HeightMapText(node.length, this.height)
          else node.height = this.height
          if (!this.outdated) node.outdated = false
          return node
        } else {
          return HeightMap.of(nodes)
        }
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
          this.setHeight(oracle, measured.heights[measured.index++])
        else if (force || this.outdated)
          this.setHeight(
            oracle,
            Math.max(
              this.widgetHeight,
              oracle.heightForLine(this.length - this.collapsed)
            ) +
              this.breaks * oracle.lineHeight
          )
        this.outdated = false
        return this
      }
      toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ''}${
          this.widgetHeight ? ':' + this.widgetHeight : ''
        })`
      }
    }
    class HeightMapGap extends HeightMap {
      constructor(length) {
        super(length, 0)
      }
      heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number,
          lastLine = oracle.doc.lineAt(offset + this.length).number
        let lines = lastLine - firstLine + 1
        let perLine,
          perChar = 0
        if (oracle.lineWrapping) {
          let totalPerLine = Math.min(this.height, oracle.lineHeight * lines)
          perLine = totalPerLine / lines
          if (this.length > lines + 1)
            perChar = (this.height - totalPerLine) / (this.length - lines - 1)
        } else {
          perLine = this.height / lines
        }
        return { firstLine, lastLine, perLine, perChar }
      }
      blockAt(height, oracle, top, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(
          oracle,
          offset
        )
        if (oracle.lineWrapping) {
          let guess =
            offset +
            Math.round(
              Math.max(0, Math.min(1, (height - top) / this.height)) *
                this.length
            )
          let line = oracle.doc.lineAt(guess),
            lineHeight = perLine + line.length * perChar
          let lineTop = Math.max(top, height - lineHeight / 2)
          return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0)
        } else {
          let line = Math.max(
            0,
            Math.min(lastLine - firstLine, Math.floor((height - top) / perLine))
          )
          let { from, length } = oracle.doc.line(firstLine + line)
          return new BlockInfo(from, length, top + perLine * line, perLine, 0)
        }
      }
      lineAt(value, type, oracle, top, offset) {
        if (type == QueryType.ByHeight)
          return this.blockAt(value, oracle, top, offset)
        if (type == QueryType.ByPosNoHeight) {
          let { from, to } = oracle.doc.lineAt(value)
          return new BlockInfo(from, to - from, 0, 0, 0)
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset)
        let line = oracle.doc.lineAt(value),
          lineHeight = perLine + line.length * perChar
        let linesAbove = line.number - firstLine
        let lineTop =
          top +
          perLine * linesAbove +
          perChar * (line.from - offset - linesAbove)
        return new BlockInfo(
          line.from,
          line.length,
          Math.max(top, Math.min(lineTop, top + this.height - lineHeight)),
          lineHeight,
          0
        )
      }
      forEachLine(from, to, oracle, top, offset, f) {
        from = Math.max(from, offset)
        to = Math.min(to, offset + this.length)
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset)
        for (let pos = from, lineTop = top; pos <= to; ) {
          let line = oracle.doc.lineAt(pos)
          if (pos == from) {
            let linesAbove = line.number - firstLine
            lineTop +=
              perLine * linesAbove + perChar * (from - offset - linesAbove)
          }
          let lineHeight = perLine + perChar * line.length
          f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0))
          lineTop += lineHeight
          pos = line.to + 1
        }
      }
      replace(from, to, nodes) {
        let after = this.length - to
        if (after > 0) {
          let last = nodes[nodes.length - 1]
          if (last instanceof HeightMapGap)
            nodes[nodes.length - 1] = new HeightMapGap(last.length + after)
          else nodes.push(null, new HeightMapGap(after - 1))
        }
        if (from > 0) {
          let first = nodes[0]
          if (first instanceof HeightMapGap)
            nodes[0] = new HeightMapGap(from + first.length)
          else nodes.unshift(new HeightMapGap(from - 1), null)
        }
        return HeightMap.of(nodes)
      }
      decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null)
      }
      decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1))
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length
        if (
          measured &&
          measured.from <= offset + this.length &&
          measured.more
        ) {
          // Fill in part of this gap with measured lines. We know there
          // can't be widgets or collapsed ranges in those lines, because
          // they would already have been added to the heightmap (gaps
          // only contain plain text).
          let nodes = [],
            pos = Math.max(offset, measured.from),
            singleHeight = -1
          if (measured.from > offset)
            nodes.push(
              new HeightMapGap(measured.from - offset - 1).updateHeight(
                oracle,
                offset
              )
            )
          while (pos <= end && measured.more) {
            let len = oracle.doc.lineAt(pos).length
            if (nodes.length) nodes.push(null)
            let height = measured.heights[measured.index++]
            if (singleHeight == -1) singleHeight = height
            else if (Math.abs(height - singleHeight) >= Epsilon)
              singleHeight = -2
            let line = new HeightMapText(len, height)
            line.outdated = false
            nodes.push(line)
            pos += len + 1
          }
          if (pos <= end)
            nodes.push(
              null,
              new HeightMapGap(end - pos).updateHeight(oracle, pos)
            )
          let result = HeightMap.of(nodes)
          if (
            singleHeight < 0 ||
            Math.abs(result.height - this.height) >= Epsilon ||
            Math.abs(
              singleHeight - this.heightMetrics(oracle, offset).perLine
            ) >= Epsilon
          )
            oracle.heightChanged = true
          return result
        } else if (force || this.outdated) {
          this.setHeight(
            oracle,
            oracle.heightForGap(offset, offset + this.length)
          )
          this.outdated = false
        }
        return this
      }
      toString() {
        return `gap(${this.length})`
      }
    }
    class HeightMapBranch extends HeightMap {
      constructor(left, brk, right) {
        super(
          left.length + brk + right.length,
          left.height + right.height,
          brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0)
        )
        this.left = left
        this.right = right
        this.size = left.size + right.size
      }
      get break() {
        return this.flags & 1 /* Flag.Break */
      }
      blockAt(height, oracle, top, offset) {
        let mid = top + this.left.height
        return height < mid
          ? this.left.blockAt(height, oracle, top, offset)
          : this.right.blockAt(
              height,
              oracle,
              mid,
              offset + this.left.length + this.break
            )
      }
      lineAt(value, type, oracle, top, offset) {
        let rightTop = top + this.left.height,
          rightOffset = offset + this.left.length + this.break
        let left =
          type == QueryType.ByHeight ? value < rightTop : value < rightOffset
        let base = left
          ? this.left.lineAt(value, type, oracle, top, offset)
          : this.right.lineAt(value, type, oracle, rightTop, rightOffset)
        if (
          this.break ||
          (left ? base.to < rightOffset : base.from > rightOffset)
        )
          return base
        let subQuery =
          type == QueryType.ByPosNoHeight
            ? QueryType.ByPosNoHeight
            : QueryType.ByPos
        if (left)
          return base.join(
            this.right.lineAt(
              rightOffset,
              subQuery,
              oracle,
              rightTop,
              rightOffset
            )
          )
        else
          return this.left
            .lineAt(rightOffset, subQuery, oracle, top, offset)
            .join(base)
      }
      forEachLine(from, to, oracle, top, offset, f) {
        let rightTop = top + this.left.height,
          rightOffset = offset + this.left.length + this.break
        if (this.break) {
          if (from < rightOffset)
            this.left.forEachLine(from, to, oracle, top, offset, f)
          if (to >= rightOffset)
            this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f)
        } else {
          let mid = this.lineAt(
            rightOffset,
            QueryType.ByPos,
            oracle,
            top,
            offset
          )
          if (from < mid.from)
            this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f)
          if (mid.to >= from && mid.from <= to) f(mid)
          if (to > mid.to)
            this.right.forEachLine(
              mid.to + 1,
              to,
              oracle,
              rightTop,
              rightOffset,
              f
            )
        }
      }
      replace(from, to, nodes) {
        let rightStart = this.left.length + this.break
        if (to < rightStart)
          return this.balanced(this.left.replace(from, to, nodes), this.right)
        if (from > this.left.length)
          return this.balanced(
            this.left,
            this.right.replace(from - rightStart, to - rightStart, nodes)
          )
        let result = []
        if (from > 0) this.decomposeLeft(from, result)
        let left = result.length
        for (let node of nodes) result.push(node)
        if (from > 0) mergeGaps(result, left - 1)
        if (to < this.length) {
          let right = result.length
          this.decomposeRight(to, result)
          mergeGaps(result, right)
        }
        return HeightMap.of(result)
      }
      decomposeLeft(to, result) {
        let left = this.left.length
        if (to <= left) return this.left.decomposeLeft(to, result)
        result.push(this.left)
        if (this.break) {
          left++
          if (to >= left) result.push(null)
        }
        if (to > left) this.right.decomposeLeft(to - left, result)
      }
      decomposeRight(from, result) {
        let left = this.left.length,
          right = left + this.break
        if (from >= right)
          return this.right.decomposeRight(from - right, result)
        if (from < left) this.left.decomposeRight(from, result)
        if (this.break && from < right) result.push(null)
        result.push(this.right)
      }
      balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
          return HeightMap.of(this.break ? [left, null, right] : [left, right])
        this.left = left
        this.right = right
        this.height = left.height + right.height
        this.outdated = left.outdated || right.outdated
        this.size = left.size + right.size
        this.length = left.length + this.break + right.length
        return this
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this,
          rightStart = offset + left.length + this.break,
          rebalance = null
        if (measured && measured.from <= offset + left.length && measured.more)
          rebalance = left = left.updateHeight(oracle, offset, force, measured)
        else left.updateHeight(oracle, offset, force)
        if (
          measured &&
          measured.from <= rightStart + right.length &&
          measured.more
        )
          rebalance = right = right.updateHeight(
            oracle,
            rightStart,
            force,
            measured
          )
        else right.updateHeight(oracle, rightStart, force)
        if (rebalance) return this.balanced(left, right)
        this.height = this.left.height + this.right.height
        this.outdated = false
        return this
      }
      toString() {
        return this.left + (this.break ? ' ' : '-') + this.right
      }
    }
    function mergeGaps(nodes, around) {
      let before, after
      if (
        nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap
      )
        nodes.splice(
          around - 1,
          3,
          new HeightMapGap(before.length + 1 + after.length)
        )
    }
    const relevantWidgetHeight = 5
    class NodeBuilder {
      constructor(pos, oracle) {
        this.pos = pos
        this.oracle = oracle
        this.nodes = []
        this.lineStart = -1
        this.lineEnd = -1
        this.covering = null
        this.writtenTo = pos
      }
      get isCovered() {
        return (
          this.covering && this.nodes[this.nodes.length - 1] == this.covering
        )
      }
      span(_from, to) {
        if (this.lineStart > -1) {
          let end = Math.min(to, this.lineEnd),
            last = this.nodes[this.nodes.length - 1]
          if (last instanceof HeightMapText) last.length += end - this.pos
          else if (end > this.pos || !this.isCovered)
            this.nodes.push(new HeightMapText(end - this.pos, -1))
          this.writtenTo = end
          if (to > end) {
            this.nodes.push(null)
            this.writtenTo++
            this.lineStart = -1
          }
        }
        this.pos = to
      }
      point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
          let height = deco.widget ? deco.widget.estimatedHeight : 0
          let breaks = deco.widget ? deco.widget.lineBreaks : 0
          if (height < 0) height = this.oracle.lineHeight
          let len = to - from
          if (deco.block) {
            this.addBlock(new HeightMapBlock(len, height, deco))
          } else if (len || breaks || height >= relevantWidgetHeight) {
            this.addLineDeco(height, breaks, len)
          }
        } else if (to > from) {
          this.span(from, to)
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
          this.lineEnd = this.oracle.doc.lineAt(this.pos).to
      }
      enterLine() {
        if (this.lineStart > -1) return
        let { from, to } = this.oracle.doc.lineAt(this.pos)
        this.lineStart = from
        this.lineEnd = to
        if (this.writtenTo < from) {
          if (
            this.writtenTo < from - 1 ||
            this.nodes[this.nodes.length - 1] == null
          )
            this.nodes.push(this.blankContent(this.writtenTo, from - 1))
          this.nodes.push(null)
        }
        if (this.pos > from)
          this.nodes.push(new HeightMapText(this.pos - from, -1))
        this.writtenTo = this.pos
      }
      blankContent(from, to) {
        let gap = new HeightMapGap(to - from)
        if (this.oracle.doc.lineAt(from).to == to)
          gap.flags |= 4 /* Flag.SingleLine */
        return gap
      }
      ensureLine() {
        this.enterLine()
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null
        if (last instanceof HeightMapText) return last
        let line = new HeightMapText(0, -1)
        this.nodes.push(line)
        return line
      }
      addBlock(block) {
        this.enterLine()
        let deco = block.deco
        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine()
        this.nodes.push(block)
        this.writtenTo = this.pos = this.pos + block.length
        if (deco && deco.endSide > 0) this.covering = block
      }
      addLineDeco(height, breaks, length) {
        let line = this.ensureLine()
        line.length += length
        line.collapsed += length
        line.widgetHeight = Math.max(line.widgetHeight, height)
        line.breaks += breaks
        this.writtenTo = this.pos = this.pos + length
      }
      finish(from) {
        let last =
          this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1]
        if (
          this.lineStart > -1 &&
          !(last instanceof HeightMapText) &&
          !this.isCovered
        )
          this.nodes.push(new HeightMapText(0, -1))
        else if (this.writtenTo < this.pos || last == null)
          this.nodes.push(this.blankContent(this.writtenTo, this.pos))
        let pos = from
        for (let node of this.nodes) {
          if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos)
          pos += node ? node.length : 1
        }
        return this.nodes
      }
      // Always called with a region that on both sides either stretches
      // to a line break or the end of the document.
      // The returned array uses null to indicate line breaks, but never
      // starts or ends in a line break, or has multiple line breaks next
      // to each other.
      static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle)
        dist_RangeSet.spans(decorations, from, to, builder, 0)
        return builder.finish(from)
      }
    }
    function heightRelevantDecoChanges(a, b, diff) {
      let comp = new DecorationComparator()
      dist_RangeSet.compare(a, b, diff, comp, 0)
      return comp.changes
    }
    class DecorationComparator {
      constructor() {
        this.changes = []
      }
      compareRange() {}
      comparePoint(from, to, a, b) {
        if (from < to || (a && a.heightRelevant) || (b && b.heightRelevant))
          addRange(from, to, this.changes, 5)
      }
    }

    function visiblePixelRange(dom, paddingTop) {
      let rect = dom.getBoundingClientRect()
      let doc = dom.ownerDocument,
        win = doc.defaultView || window
      let left = Math.max(0, rect.left),
        right = Math.min(win.innerWidth, rect.right)
      let top = Math.max(0, rect.top),
        bottom = Math.min(win.innerHeight, rect.bottom)
      for (let parent = dom.parentNode; parent && parent != doc.body; ) {
        if (parent.nodeType == 1) {
          let elt = parent
          let style = window.getComputedStyle(elt)
          if (
            (elt.scrollHeight > elt.clientHeight ||
              elt.scrollWidth > elt.clientWidth) &&
            style.overflow != 'visible'
          ) {
            let parentRect = elt.getBoundingClientRect()
            left = Math.max(left, parentRect.left)
            right = Math.min(right, parentRect.right)
            top = Math.max(top, parentRect.top)
            bottom =
              parent == dom.parentNode
                ? parentRect.bottom
                : Math.min(bottom, parentRect.bottom)
          }
          parent =
            style.position == 'absolute' || style.position == 'fixed'
              ? elt.offsetParent
              : elt.parentNode
        } else if (parent.nodeType == 11) {
          // Shadow root
          parent = parent.host
        } else {
          break
        }
      }
      return {
        left: left - rect.left,
        right: Math.max(left, right) - rect.left,
        top: top - (rect.top + paddingTop),
        bottom: Math.max(top, bottom) - (rect.top + paddingTop)
      }
    }
    function fullPixelRange(dom, paddingTop) {
      let rect = dom.getBoundingClientRect()
      return {
        left: 0,
        right: rect.right - rect.left,
        top: paddingTop,
        bottom: rect.bottom - (rect.top + paddingTop)
      }
    }
    // Line gaps are placeholder widgets used to hide pieces of overlong
    // lines within the viewport, as a kludge to keep the editor
    // responsive when a ridiculously long line is loaded into it.
    class LineGap {
      constructor(from, to, size) {
        this.from = from
        this.to = to
        this.size = size
      }
      static same(a, b) {
        if (a.length != b.length) return false
        for (let i = 0; i < a.length; i++) {
          let gA = a[i],
            gB = b[i]
          if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
            return false
        }
        return true
      }
      draw(viewState, wrapping) {
        return Decoration.replace({
          widget: new LineGapWidget(
            this.size * (wrapping ? viewState.scaleY : viewState.scaleX),
            wrapping
          )
        }).range(this.from, this.to)
      }
    }
    class LineGapWidget extends WidgetType {
      constructor(size, vertical) {
        super()
        this.size = size
        this.vertical = vertical
      }
      eq(other) {
        return other.size == this.size && other.vertical == this.vertical
      }
      toDOM() {
        let elt = document.createElement('div')
        if (this.vertical) {
          elt.style.height = this.size + 'px'
        } else {
          elt.style.width = this.size + 'px'
          elt.style.height = '2px'
          elt.style.display = 'inline-block'
        }
        return elt
      }
      get estimatedHeight() {
        return this.vertical ? this.size : -1
      }
    }
    class ViewState {
      constructor(state) {
        this.state = state
        // These are contentDOM-local coordinates
        this.pixelViewport = {
          left: 0,
          right: window.innerWidth,
          top: 0,
          bottom: 0
        }
        this.inView = true
        this.paddingTop = 0 // Padding above the document, scaled
        this.paddingBottom = 0 // Padding below the document, scaled
        this.contentDOMWidth = 0 // contentDOM.getBoundingClientRect().width
        this.contentDOMHeight = 0 // contentDOM.getBoundingClientRect().height
        this.editorHeight = 0 // scrollDOM.clientHeight, unscaled
        this.editorWidth = 0 // scrollDOM.clientWidth, unscaled
        this.scrollTop = 0 // Last seen scrollDOM.scrollTop, scaled
        this.scrolledToBottom = true
        // The CSS-transformation scale of the editor (transformed size /
        // concrete size)
        this.scaleX = 1
        this.scaleY = 1
        // The vertical position (document-relative) to which to anchor the
        // scroll position. -1 means anchor to the end of the document.
        this.scrollAnchorPos = 0
        // The height at the anchor position. Set by the DOM update phase.
        // -1 means no height available.
        this.scrollAnchorHeight = -1
        // See VP.MaxDOMHeight
        this.scaler = IdScaler
        this.scrollTarget = null
        // Briefly set to true when printing, to disable viewport limiting
        this.printing = false
        // Flag set when editor content was redrawn, so that the next
        // measure stage knows it must read DOM layout
        this.mustMeasureContent = true
        this.defaultTextDirection = Direction.LTR
        this.visibleRanges = []
        // Cursor 'assoc' is only significant when the cursor is on a line
        // wrap point, where it must stick to the character that it is
        // associated with. Since browsers don't provide a reasonable
        // interface to set or query this, when a selection is set that
        // might cause this to be significant, this flag is set. The next
        // measure phase will check whether the cursor is on a line-wrapping
        // boundary and, if so, reset it to make sure it is positioned in
        // the right place.
        this.mustEnforceCursorAssoc = false
        let guessWrapping = state
          .facet(contentAttributes)
          .some((v) => typeof v != 'function' && v.class == 'cm-lineWrapping')
        this.heightOracle = new HeightOracle(guessWrapping)
        this.stateDeco = state
          .facet(decorations)
          .filter((d) => typeof d != 'function')
        this.heightMap = HeightMap.empty().applyChanges(
          this.stateDeco,
          Text.empty,
          this.heightOracle.setDoc(state.doc),
          [new ChangedRange(0, 0, 0, state.doc.length)]
        )
        this.viewport = this.getViewport(0, null)
        this.updateViewportLines()
        this.updateForViewport()
        this.lineGaps = this.ensureLineGaps([])
        this.lineGapDeco = Decoration.set(
          this.lineGaps.map((gap) => gap.draw(this, false))
        )
        this.computeVisibleRanges()
      }
      updateForViewport() {
        let viewports = [this.viewport],
          { main } = this.state.selection
        for (let i = 0; i <= 1; i++) {
          let pos = i ? main.head : main.anchor
          if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
            let { from, to } = this.lineBlockAt(pos)
            viewports.push(new Viewport(from, to))
          }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from)
        this.scaler =
          this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */
            ? IdScaler
            : new BigScaler(this.heightOracle, this.heightMap, this.viewports)
      }
      updateViewportLines() {
        this.viewportLines = []
        this.heightMap.forEachLine(
          this.viewport.from,
          this.viewport.to,
          this.heightOracle.setDoc(this.state.doc),
          0,
          0,
          (block) => {
            this.viewportLines.push(
              this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler)
            )
          }
        )
      }
      update(update, scrollTarget = null) {
        this.state = update.state
        let prevDeco = this.stateDeco
        this.stateDeco = this.state
          .facet(decorations)
          .filter((d) => typeof d != 'function')
        let contentChanges = update.changedRanges
        let heightChanges = ChangedRange.extendWithRanges(
          contentChanges,
          heightRelevantDecoChanges(
            prevDeco,
            this.stateDeco,
            update ? update.changes : ChangeSet.empty(this.state.doc.length)
          )
        )
        let prevHeight = this.heightMap.height
        let scrollAnchor = this.scrolledToBottom
          ? null
          : this.scrollAnchorAt(this.scrollTop)
        this.heightMap = this.heightMap.applyChanges(
          this.stateDeco,
          update.startState.doc,
          this.heightOracle.setDoc(this.state.doc),
          heightChanges
        )
        if (this.heightMap.height != prevHeight)
          update.flags |= 2 /* UpdateFlag.Height */
        if (scrollAnchor) {
          this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1)
          this.scrollAnchorHeight = scrollAnchor.top
        } else {
          this.scrollAnchorPos = -1
          this.scrollAnchorHeight = this.heightMap.height
        }
        let viewport = heightChanges.length
          ? this.mapViewport(this.viewport, update.changes)
          : this.viewport
        if (
          (scrollTarget &&
            (scrollTarget.range.head < viewport.from ||
              scrollTarget.range.head > viewport.to)) ||
          !this.viewportIsAppropriate(viewport)
        )
          viewport = this.getViewport(0, scrollTarget)
        let updateLines =
          !update.changes.empty ||
          update.flags & 2 /* UpdateFlag.Height */ ||
          viewport.from != this.viewport.from ||
          viewport.to != this.viewport.to
        this.viewport = viewport
        this.updateForViewport()
        if (updateLines) this.updateViewportLines()
        if (
          this.lineGaps.length ||
          this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1
        )
          this.updateLineGaps(
            this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes))
          )
        update.flags |= this.computeVisibleRanges()
        if (scrollTarget) this.scrollTarget = scrollTarget
        if (
          !this.mustEnforceCursorAssoc &&
          update.selectionSet &&
          update.view.lineWrapping &&
          update.state.selection.main.empty &&
          update.state.selection.main.assoc &&
          !update.state.facet(nativeSelectionHidden)
        )
          this.mustEnforceCursorAssoc = true
      }
      measure(view) {
        let dom = view.contentDOM,
          style = window.getComputedStyle(dom)
        let oracle = this.heightOracle
        let whiteSpace = style.whiteSpace
        this.defaultTextDirection =
          style.direction == 'rtl' ? Direction.RTL : Direction.LTR
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace)
        let domRect = dom.getBoundingClientRect()
        let measureContent =
          refresh ||
          this.mustMeasureContent ||
          this.contentDOMHeight != domRect.height
        this.contentDOMHeight = domRect.height
        this.mustMeasureContent = false
        let result = 0,
          bias = 0
        if (domRect.width && domRect.height) {
          let { scaleX, scaleY } = getScale(dom, domRect)
          if (this.scaleX != scaleX || this.scaleY != scaleY) {
            this.scaleX = scaleX
            this.scaleY = scaleY
            result |= 8 /* UpdateFlag.Geometry */
            refresh = measureContent = true
          }
        }
        // Vertical padding
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY
        if (
          this.paddingTop != paddingTop ||
          this.paddingBottom != paddingBottom
        ) {
          this.paddingTop = paddingTop
          this.paddingBottom = paddingBottom
          result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
          if (oracle.lineWrapping) measureContent = true
          this.editorWidth = view.scrollDOM.clientWidth
          result |= 8 /* UpdateFlag.Geometry */
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY
        if (this.scrollTop != scrollTop) {
          this.scrollAnchorHeight = -1
          this.scrollTop = scrollTop
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM)
        // Pixel viewport
        let pixelViewport = (
          this.printing ? fullPixelRange : visiblePixelRange
        )(dom, this.paddingTop)
        let dTop = pixelViewport.top - this.pixelViewport.top,
          dBottom = pixelViewport.bottom - this.pixelViewport.bottom
        this.pixelViewport = pixelViewport
        let inView =
          this.pixelViewport.bottom > this.pixelViewport.top &&
          this.pixelViewport.right > this.pixelViewport.left
        if (inView != this.inView) {
          this.inView = inView
          if (inView) measureContent = true
        }
        if (!this.inView && !this.scrollTarget) return 0
        let contentWidth = domRect.width
        if (
          this.contentDOMWidth != contentWidth ||
          this.editorHeight != view.scrollDOM.clientHeight
        ) {
          this.contentDOMWidth = domRect.width
          this.editorHeight = view.scrollDOM.clientHeight
          result |= 8 /* UpdateFlag.Geometry */
        }
        if (measureContent) {
          let lineHeights = view.docView.measureVisibleLineHeights(
            this.viewport
          )
          if (oracle.mustRefreshForHeights(lineHeights)) refresh = true
          if (
            refresh ||
            (oracle.lineWrapping &&
              Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth)
          ) {
            let { lineHeight, charWidth, textHeight } =
              view.docView.measureTextSize()
            refresh =
              lineHeight > 0 &&
              oracle.refresh(
                whiteSpace,
                lineHeight,
                charWidth,
                textHeight,
                contentWidth / charWidth,
                lineHeights
              )
            if (refresh) {
              view.docView.minWidth = 0
              result |= 8 /* UpdateFlag.Geometry */
            }
          }
          if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom)
          else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom)
          oracle.heightChanged = false
          for (let vp of this.viewports) {
            let heights =
              vp.from == this.viewport.from
                ? lineHeights
                : view.docView.measureVisibleLineHeights(vp)
            this.heightMap = (
              refresh
                ? HeightMap.empty().applyChanges(
                    this.stateDeco,
                    Text.empty,
                    this.heightOracle,
                    [new ChangedRange(0, 0, 0, view.state.doc.length)]
                  )
                : this.heightMap
            ).updateHeight(
              oracle,
              0,
              refresh,
              new MeasuredHeights(vp.from, heights)
            )
          }
          if (oracle.heightChanged) result |= 2 /* UpdateFlag.Height */
        }
        let viewportChange =
          !this.viewportIsAppropriate(this.viewport, bias) ||
          (this.scrollTarget &&
            (this.scrollTarget.range.head < this.viewport.from ||
              this.scrollTarget.range.head > this.viewport.to))
        if (viewportChange)
          this.viewport = this.getViewport(bias, this.scrollTarget)
        this.updateForViewport()
        if (result & 2 /* UpdateFlag.Height */ || viewportChange)
          this.updateViewportLines()
        if (
          this.lineGaps.length ||
          this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1
        )
          this.updateLineGaps(
            this.ensureLineGaps(refresh ? [] : this.lineGaps, view)
          )
        result |= this.computeVisibleRanges()
        if (this.mustEnforceCursorAssoc) {
          this.mustEnforceCursorAssoc = false
          // This is done in the read stage, because moving the selection
          // to a line end is going to trigger a layout anyway, so it
          // can't be a pure write. It should be rare that it does any
          // writing.
          view.docView.enforceCursorAssoc()
        }
        return result
      }
      get visibleTop() {
        return this.scaler.fromDOM(this.pixelViewport.top)
      }
      get visibleBottom() {
        return this.scaler.fromDOM(this.pixelViewport.bottom)
      }
      getViewport(bias, scrollTarget) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        let marginTop =
          0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2))
        let map = this.heightMap,
          oracle = this.heightOracle
        let { visibleTop, visibleBottom } = this
        let viewport = new Viewport(
          map.lineAt(
            visibleTop - marginTop * 1000 /* VP.Margin */,
            QueryType.ByHeight,
            oracle,
            0,
            0
          ).from,
          map.lineAt(
            visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */,
            QueryType.ByHeight,
            oracle,
            0,
            0
          ).to
        )
        // If scrollTarget is given, make sure the viewport includes that position
        if (scrollTarget) {
          let { head } = scrollTarget.range
          if (head < viewport.from || head > viewport.to) {
            let viewHeight = Math.min(
              this.editorHeight,
              this.pixelViewport.bottom - this.pixelViewport.top
            )
            let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0),
              topPos
            if (scrollTarget.y == 'center')
              topPos = (block.top + block.bottom) / 2 - viewHeight / 2
            else if (
              scrollTarget.y == 'start' ||
              (scrollTarget.y == 'nearest' && head < viewport.from)
            )
              topPos = block.top
            else topPos = block.bottom - viewHeight
            viewport = new Viewport(
              map.lineAt(
                topPos - 1000 /* VP.Margin */ / 2,
                QueryType.ByHeight,
                oracle,
                0,
                0
              ).from,
              map.lineAt(
                topPos + viewHeight + 1000 /* VP.Margin */ / 2,
                QueryType.ByHeight,
                oracle,
                0,
                0
              ).to
            )
          }
        }
        return viewport
      }
      mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1),
          to = changes.mapPos(viewport.to, 1)
        return new Viewport(
          this.heightMap.lineAt(
            from,
            QueryType.ByPos,
            this.heightOracle,
            0,
            0
          ).from,
          this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to
        )
      }
      // Checks if a given viewport covers the visible part of the
      // document and not too much beyond that.
      viewportIsAppropriate({ from, to }, bias = 0) {
        if (!this.inView) return true
        let { top } = this.heightMap.lineAt(
          from,
          QueryType.ByPos,
          this.heightOracle,
          0,
          0
        )
        let { bottom } = this.heightMap.lineAt(
          to,
          QueryType.ByPos,
          this.heightOracle,
          0,
          0
        )
        let { visibleTop, visibleBottom } = this
        return (
          (from == 0 ||
            top <=
              visibleTop -
                Math.max(
                  10 /* VP.MinCoverMargin */,
                  Math.min(-bias, 250 /* VP.MaxCoverMargin */)
                )) &&
          (to == this.state.doc.length ||
            bottom >=
              visibleBottom +
                Math.max(
                  10 /* VP.MinCoverMargin */,
                  Math.min(bias, 250 /* VP.MaxCoverMargin */)
                )) &&
          top > visibleTop - 2 * 1000 /* VP.Margin */ &&
          bottom < visibleBottom + 2 * 1000 /* VP.Margin */
        )
      }
      mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty) return gaps
        let mapped = []
        for (let gap of gaps)
          if (!changes.touchesRange(gap.from, gap.to))
            mapped.push(
              new LineGap(
                changes.mapPos(gap.from),
                changes.mapPos(gap.to),
                gap.size
              )
            )
        return mapped
      }
      // Computes positions in the viewport where the start or end of a
      // line should be hidden, trying to reuse existing line gaps when
      // appropriate to avoid unneccesary redraws.
      // Uses crude character-counting for the positioning and sizing,
      // since actual DOM coordinates aren't always available and
      // predictable. Relies on generous margins (see LG.Margin) to hide
      // the artifacts this might produce from the user.
      ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping
        let margin = wrapping
            ? 10000 /* LG.MarginWrap */
            : 2000 /* LG.Margin */,
          halfMargin = margin >> 1,
          doubleMargin = margin << 1
        // The non-wrapping logic won't work at all in predominantly right-to-left text.
        if (this.defaultTextDirection != Direction.LTR && !wrapping) return []
        let gaps = []
        let addGap = (from, to, line, structure) => {
          if (to - from < halfMargin) return
          let sel = this.state.selection.main,
            avoid = [sel.from]
          if (!sel.empty) avoid.push(sel.to)
          for (let pos of avoid) {
            if (pos > from && pos < to) {
              addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure)
              addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure)
              return
            }
          }
          let gap = find(
            current,
            (gap) =>
              gap.from >= line.from &&
              gap.to <= line.to &&
              Math.abs(gap.from - from) < halfMargin &&
              Math.abs(gap.to - to) < halfMargin &&
              !avoid.some((pos) => gap.from < pos && gap.to > pos)
          )
          if (!gap) {
            // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
            if (
              to < line.to &&
              mayMeasure &&
              wrapping &&
              mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)
            ) {
              let lineStart = mayMeasure.moveToLineBoundary(
                dist_EditorSelection.cursor(to),
                false,
                true
              ).head
              if (lineStart > from) to = lineStart
            }
            gap = new LineGap(from, to, this.gapSize(line, from, to, structure))
          }
          gaps.push(gap)
        }
        for (let line of this.viewportLines) {
          if (line.length < doubleMargin) continue
          let structure = lineStructure(line.from, line.to, this.stateDeco)
          if (structure.total < doubleMargin) continue
          let target = this.scrollTarget ? this.scrollTarget.range.head : null
          let viewFrom, viewTo
          if (wrapping) {
            let marginHeight =
              (margin / this.heightOracle.lineLength) *
              this.heightOracle.lineHeight
            let top, bot
            if (target != null) {
              let targetFrac = findFraction(structure, target)
              let spaceFrac =
                ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) /
                line.height
              top = targetFrac - spaceFrac
              bot = targetFrac + spaceFrac
            } else {
              top = (this.visibleTop - line.top - marginHeight) / line.height
              bot = (this.visibleBottom - line.top + marginHeight) / line.height
            }
            viewFrom = findPosition(structure, top)
            viewTo = findPosition(structure, bot)
          } else {
            let totalWidth = structure.total * this.heightOracle.charWidth
            let marginWidth = margin * this.heightOracle.charWidth
            let left, right
            if (target != null) {
              let targetFrac = findFraction(structure, target)
              let spaceFrac =
                ((this.pixelViewport.right - this.pixelViewport.left) / 2 +
                  marginWidth) /
                totalWidth
              left = targetFrac - spaceFrac
              right = targetFrac + spaceFrac
            } else {
              left = (this.pixelViewport.left - marginWidth) / totalWidth
              right = (this.pixelViewport.right + marginWidth) / totalWidth
            }
            viewFrom = findPosition(structure, left)
            viewTo = findPosition(structure, right)
          }
          if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure)
          if (viewTo < line.to) addGap(viewTo, line.to, line, structure)
        }
        return gaps
      }
      gapSize(line, from, to, structure) {
        let fraction =
          findFraction(structure, to) - findFraction(structure, from)
        if (this.heightOracle.lineWrapping) {
          return line.height * fraction
        } else {
          return structure.total * this.heightOracle.charWidth * fraction
        }
      }
      updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
          this.lineGaps = gaps
          this.lineGapDeco = Decoration.set(
            gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping))
          )
        }
      }
      computeVisibleRanges() {
        let deco = this.stateDeco
        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco)
        let ranges = []
        dist_RangeSet.spans(
          deco,
          this.viewport.from,
          this.viewport.to,
          {
            span(from, to) {
              ranges.push({ from, to })
            },
            point() {}
          },
          20
        )
        let changed =
          ranges.length != this.visibleRanges.length ||
          this.visibleRanges.some(
            (r, i) => r.from != ranges[i].from || r.to != ranges[i].to
          )
        this.visibleRanges = ranges
        return changed ? 4 /* UpdateFlag.Viewport */ : 0
      }
      lineBlockAt(pos) {
        return (
          (pos >= this.viewport.from &&
            pos <= this.viewport.to &&
            this.viewportLines.find((b) => b.from <= pos && b.to >= pos)) ||
          scaleBlock(
            this.heightMap.lineAt(
              pos,
              QueryType.ByPos,
              this.heightOracle,
              0,
              0
            ),
            this.scaler
          )
        )
      }
      lineBlockAtHeight(height) {
        return scaleBlock(
          this.heightMap.lineAt(
            this.scaler.fromDOM(height),
            QueryType.ByHeight,
            this.heightOracle,
            0,
            0
          ),
          this.scaler
        )
      }
      scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8)
        return block.from >= this.viewport.from ||
          this.viewportLines[0].top - scrollTop > 200
          ? block
          : this.viewportLines[0]
      }
      elementAtHeight(height) {
        return scaleBlock(
          this.heightMap.blockAt(
            this.scaler.fromDOM(height),
            this.heightOracle,
            0,
            0
          ),
          this.scaler
        )
      }
      get docHeight() {
        return this.scaler.toDOM(this.heightMap.height)
      }
      get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom
      }
    }
    class Viewport {
      constructor(from, to) {
        this.from = from
        this.to = to
      }
    }
    function lineStructure(from, to, stateDeco) {
      let ranges = [],
        pos = from,
        total = 0
      dist_RangeSet.spans(
        stateDeco,
        from,
        to,
        {
          span() {},
          point(from, to) {
            if (from > pos) {
              ranges.push({ from: pos, to: from })
              total += from - pos
            }
            pos = to
          }
        },
        20
      ) // We're only interested in collapsed ranges of a significant size
      if (pos < to) {
        ranges.push({ from: pos, to })
        total += to - pos
      }
      return { total, ranges }
    }
    function findPosition({ total, ranges }, ratio) {
      if (ratio <= 0) return ranges[0].from
      if (ratio >= 1) return ranges[ranges.length - 1].to
      let dist = Math.floor(total * ratio)
      for (let i = 0; ; i++) {
        let { from, to } = ranges[i],
          size = to - from
        if (dist <= size) return from + dist
        dist -= size
      }
    }
    function findFraction(structure, pos) {
      let counted = 0
      for (let { from, to } of structure.ranges) {
        if (pos <= to) {
          counted += pos - from
          break
        }
        counted += to - from
      }
      return counted / structure.total
    }
    function find(array, f) {
      for (let val of array) if (f(val)) return val
      return undefined
    }
    // Don't scale when the document height is within the range of what
    // the DOM can handle.
    const IdScaler = {
      toDOM(n) {
        return n
      },
      fromDOM(n) {
        return n
      },
      scale: 1
    }
    // When the height is too big (> VP.MaxDOMHeight), scale down the
    // regions outside the viewports so that the total height is
    // VP.MaxDOMHeight.
    class BigScaler {
      constructor(oracle, heightMap, viewports) {
        let vpHeight = 0,
          base = 0,
          domBase = 0
        this.viewports = viewports.map(({ from, to }) => {
          let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top
          let bottom = heightMap.lineAt(
            to,
            QueryType.ByPos,
            oracle,
            0,
            0
          ).bottom
          vpHeight += bottom - top
          return { from, to, top, bottom, domTop: 0, domBottom: 0 }
        })
        this.scale =
          (7000000 /* VP.MaxDOMHeight */ - vpHeight) /
          (heightMap.height - vpHeight)
        for (let obj of this.viewports) {
          obj.domTop = domBase + (obj.top - base) * this.scale
          domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top)
          base = obj.bottom
        }
      }
      toDOM(n) {
        for (let i = 0, base = 0, domBase = 0; ; i++) {
          let vp = i < this.viewports.length ? this.viewports[i] : null
          if (!vp || n < vp.top) return domBase + (n - base) * this.scale
          if (n <= vp.bottom) return vp.domTop + (n - vp.top)
          base = vp.bottom
          domBase = vp.domBottom
        }
      }
      fromDOM(n) {
        for (let i = 0, base = 0, domBase = 0; ; i++) {
          let vp = i < this.viewports.length ? this.viewports[i] : null
          if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale
          if (n <= vp.domBottom) return vp.top + (n - vp.domTop)
          base = vp.bottom
          domBase = vp.domBottom
        }
      }
    }
    function scaleBlock(block, scaler) {
      if (scaler.scale == 1) return block
      let bTop = scaler.toDOM(block.top),
        bBottom = scaler.toDOM(block.bottom)
      return new BlockInfo(
        block.from,
        block.length,
        bTop,
        bBottom - bTop,
        Array.isArray(block._content)
          ? block._content.map((b) => scaleBlock(b, scaler))
          : block._content
      )
    }

    const theme = /*@__PURE__*/ Facet.define({
      combine: (strs) => strs.join(' ')
    })
    const darkTheme = /*@__PURE__*/ Facet.define({
      combine: (values) => values.indexOf(true) > -1
    })
    const baseThemeID = /*@__PURE__*/ StyleModule.newName(),
      baseLightID = /*@__PURE__*/ StyleModule.newName(),
      baseDarkID = /*@__PURE__*/ StyleModule.newName()
    const lightDarkIDs = {
      '&light': '.' + baseLightID,
      '&dark': '.' + baseDarkID
    }
    function buildTheme(main, spec, scopes) {
      return new StyleModule(spec, {
        finish(sel) {
          return /&/.test(sel)
            ? sel.replace(/&\w*/, (m) => {
                if (m == '&') return main
                if (!scopes || !scopes[m])
                  throw new RangeError(`Unsupported selector: ${m}`)
                return scopes[m]
              })
            : main + ' ' + sel
        }
      })
    }
    const baseTheme$1 = /*@__PURE__*/ buildTheme(
      '.' + baseThemeID,
      {
        '&': {
          position: 'relative !important',
          boxSizing: 'border-box',
          '&.cm-focused': {
            // Provide a simple default outline to make sure a focused
            // editor is visually distinct. Can't leave the default behavior
            // because that will apply to the content element, which is
            // inside the scrollable container and doesn't include the
            // gutters. We also can't use an 'auto' outline, since those
            // are, for some reason, drawn behind the element content, which
            // will cause things like the active line background to cover
            // the outline (#297).
            outline: '1px dotted #212121'
          },
          display: 'flex !important',
          flexDirection: 'column'
        },
        '.cm-scroller': {
          display: 'flex !important',
          alignItems: 'flex-start !important',
          fontFamily: 'monospace',
          lineHeight: 1.4,
          height: '100%',
          overflowX: 'auto',
          position: 'relative',
          zIndex: 0
        },
        '.cm-content': {
          margin: 0,
          flexGrow: 2,
          flexShrink: 0,
          display: 'block',
          whiteSpace: 'pre',
          wordWrap: 'normal',
          boxSizing: 'border-box',
          minHeight: '100%',
          padding: '4px 0',
          outline: 'none',
          '&[contenteditable=true]': {
            WebkitUserModify: 'read-write-plaintext-only'
          }
        },
        '.cm-lineWrapping': {
          whiteSpace_fallback: 'pre-wrap',
          whiteSpace: 'break-spaces',
          wordBreak: 'break-word',
          overflowWrap: 'anywhere',
          flexShrink: 1
        },
        '&light .cm-content': { caretColor: 'black' },
        '&dark .cm-content': { caretColor: 'white' },
        '.cm-line': {
          display: 'block',
          padding: '0 2px 0 6px'
        },
        '.cm-layer': {
          position: 'absolute',
          left: 0,
          top: 0,
          contain: 'size style',
          '& > *': {
            position: 'absolute'
          }
        },
        '&light .cm-selectionBackground': {
          background: '#d9d9d9'
        },
        '&dark .cm-selectionBackground': {
          background: '#222'
        },
        '&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground':
          {
            background: '#d7d4f0'
          },
        '&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground':
          {
            background: '#233'
          },
        '.cm-cursorLayer': {
          pointerEvents: 'none'
        },
        '&.cm-focused > .cm-scroller > .cm-cursorLayer': {
          animation: 'steps(1) cm-blink 1.2s infinite'
        },
        // Two animations defined so that we can switch between them to
        // restart the animation without forcing another style
        // recomputation.
        '@keyframes cm-blink': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
        '@keyframes cm-blink2': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
        '.cm-cursor, .cm-dropCursor': {
          borderLeft: '1.2px solid black',
          marginLeft: '-0.6px',
          pointerEvents: 'none'
        },
        '.cm-cursor': {
          display: 'none'
        },
        '&dark .cm-cursor': {
          borderLeftColor: '#444'
        },
        '.cm-dropCursor': {
          position: 'absolute'
        },
        '&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor': {
          display: 'block'
        },
        '.cm-announced': {
          position: 'fixed',
          top: '-10000px'
        },
        '@media print': {
          '.cm-announced': { display: 'none' }
        },
        '&light .cm-activeLine': { backgroundColor: '#cceeff44' },
        '&dark .cm-activeLine': { backgroundColor: '#99eeff33' },
        '&light .cm-specialChar': { color: 'red' },
        '&dark .cm-specialChar': { color: '#f78' },
        '.cm-gutters': {
          flexShrink: 0,
          display: 'flex',
          height: '100%',
          boxSizing: 'border-box',
          insetInlineStart: 0,
          zIndex: 200
        },
        '&light .cm-gutters': {
          backgroundColor: '#f5f5f5',
          color: '#6c6c6c',
          borderRight: '1px solid #ddd'
        },
        '&dark .cm-gutters': {
          backgroundColor: '#333338',
          color: '#ccc'
        },
        '.cm-gutter': {
          display: 'flex !important',
          flexDirection: 'column',
          flexShrink: 0,
          boxSizing: 'border-box',
          minHeight: '100%',
          overflow: 'hidden'
        },
        '.cm-gutterElement': {
          boxSizing: 'border-box'
        },
        '.cm-lineNumbers .cm-gutterElement': {
          padding: '0 3px 0 5px',
          minWidth: '20px',
          textAlign: 'right',
          whiteSpace: 'nowrap'
        },
        '&light .cm-activeLineGutter': {
          backgroundColor: '#e2f2ff'
        },
        '&dark .cm-activeLineGutter': {
          backgroundColor: '#222227'
        },
        '.cm-panels': {
          boxSizing: 'border-box',
          position: 'sticky',
          left: 0,
          right: 0
        },
        '&light .cm-panels': {
          backgroundColor: '#f5f5f5',
          color: 'black'
        },
        '&light .cm-panels-top': {
          borderBottom: '1px solid #ddd'
        },
        '&light .cm-panels-bottom': {
          borderTop: '1px solid #ddd'
        },
        '&dark .cm-panels': {
          backgroundColor: '#333338',
          color: 'white'
        },
        '.cm-tab': {
          display: 'inline-block',
          overflow: 'hidden',
          verticalAlign: 'bottom'
        },
        '.cm-widgetBuffer': {
          verticalAlign: 'text-top',
          height: '1em',
          width: 0,
          display: 'inline'
        },
        '.cm-placeholder': {
          color: '#888',
          display: 'inline-block',
          verticalAlign: 'top'
        },
        '.cm-highlightSpace:before': {
          content: 'attr(data-display)',
          position: 'absolute',
          pointerEvents: 'none',
          color: '#888'
        },
        '.cm-highlightTab': {
          backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
          backgroundSize: 'auto 100%',
          backgroundPosition: 'right 90%',
          backgroundRepeat: 'no-repeat'
        },
        '.cm-trailingSpace': {
          backgroundColor: '#ff332255'
        },
        '.cm-button': {
          verticalAlign: 'middle',
          color: 'inherit',
          fontSize: '70%',
          padding: '.2em 1em',
          borderRadius: '1px'
        },
        '&light .cm-button': {
          backgroundImage: 'linear-gradient(#eff1f5, #d9d9df)',
          border: '1px solid #888',
          '&:active': {
            backgroundImage: 'linear-gradient(#b4b4b4, #d0d3d6)'
          }
        },
        '&dark .cm-button': {
          backgroundImage: 'linear-gradient(#393939, #111)',
          border: '1px solid #888',
          '&:active': {
            backgroundImage: 'linear-gradient(#111, #333)'
          }
        },
        '.cm-textfield': {
          verticalAlign: 'middle',
          color: 'inherit',
          fontSize: '70%',
          border: '1px solid silver',
          padding: '.2em .5em'
        },
        '&light .cm-textfield': {
          backgroundColor: 'white'
        },
        '&dark .cm-textfield': {
          border: '1px solid #555',
          backgroundColor: 'inherit'
        }
      },
      lightDarkIDs
    )

    const LineBreakPlaceholder = '\uffff'
    class DOMReader {
      constructor(points, state) {
        this.points = points
        this.text = ''
        this.lineSeparator = state.facet(EditorState.lineSeparator)
      }
      append(text) {
        this.text += text
      }
      lineBreak() {
        this.text += LineBreakPlaceholder
      }
      readRange(start, end) {
        if (!start) return this
        let parent = start.parentNode
        for (let cur = start; ; ) {
          this.findPointBefore(parent, cur)
          let oldLen = this.text.length
          this.readNode(cur)
          let next = cur.nextSibling
          if (next == end) break
          let view = ContentView.get(cur),
            nextView = ContentView.get(next)
          if (
            view && nextView
              ? view.breakAfter
              : (view ? view.breakAfter : isBlockElement(cur)) ||
                (isBlockElement(next) &&
                  (cur.nodeName != 'BR' || cur.cmIgnore) &&
                  this.text.length > oldLen)
          )
            this.lineBreak()
          cur = next
        }
        this.findPointBefore(parent, end)
        return this
      }
      readTextNode(node) {
        let text = node.nodeValue
        for (let point of this.points)
          if (point.node == node)
            point.pos = this.text.length + Math.min(point.offset, text.length)
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
          let nextBreak = -1,
            breakSize = 1,
            m
          if (this.lineSeparator) {
            nextBreak = text.indexOf(this.lineSeparator, off)
            breakSize = this.lineSeparator.length
          } else if ((m = re.exec(text))) {
            nextBreak = m.index
            breakSize = m[0].length
          }
          this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak))
          if (nextBreak < 0) break
          this.lineBreak()
          if (breakSize > 1)
            for (let point of this.points)
              if (point.node == node && point.pos > this.text.length)
                point.pos -= breakSize - 1
          off = nextBreak + breakSize
        }
      }
      readNode(node) {
        if (node.cmIgnore) return
        let view = ContentView.get(node)
        let fromView = view && view.overrideDOMText
        if (fromView != null) {
          this.findPointInside(node, fromView.length)
          for (let i = fromView.iter(); !i.next().done; ) {
            if (i.lineBreak) this.lineBreak()
            else this.append(i.value)
          }
        } else if (node.nodeType == 3) {
          this.readTextNode(node)
        } else if (node.nodeName == 'BR') {
          if (node.nextSibling) this.lineBreak()
        } else if (node.nodeType == 1) {
          this.readRange(node.firstChild, null)
        }
      }
      findPointBefore(node, next) {
        for (let point of this.points)
          if (point.node == node && node.childNodes[point.offset] == next)
            point.pos = this.text.length
      }
      findPointInside(node, length) {
        for (let point of this.points)
          if (
            node.nodeType == 3 ? point.node == node : node.contains(point.node)
          )
            point.pos =
              this.text.length +
              (isAtEnd(node, point.node, point.offset) ? length : 0)
      }
    }
    function isAtEnd(parent, node, offset) {
      for (;;) {
        if (!node || offset < maxOffset(node)) return false
        if (node == parent) return true
        offset = domIndex(node) + 1
        node = node.parentNode
      }
    }
    function isBlockElement(node) {
      return (
        node.nodeType == 1 &&
        /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(
          node.nodeName
        )
      )
    }
    class DOMPoint {
      constructor(node, offset) {
        this.node = node
        this.offset = offset
        this.pos = -1
      }
    }

    class DOMChange {
      constructor(view, start, end, typeOver) {
        this.typeOver = typeOver
        this.bounds = null
        this.text = ''
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView
        if (view.state.readOnly && start > -1) {
          // Ignore changes when the editor is read-only
          this.newSel = null
        } else if (
          start > -1 &&
          (this.bounds = view.docView.domBoundsAround(start, end, 0))
        ) {
          let selPoints = iHead || iAnchor ? [] : selectionPoints(view)
          let reader = new DOMReader(selPoints, view.state)
          reader.readRange(this.bounds.startDOM, this.bounds.endDOM)
          this.text = reader.text
          this.newSel = selectionFromPoints(selPoints, this.bounds.from)
        } else {
          let domSel = view.observer.selectionRange
          let head =
            (iHead &&
              iHead.node == domSel.focusNode &&
              iHead.offset == domSel.focusOffset) ||
            !contains(view.contentDOM, domSel.focusNode)
              ? view.state.selection.main.head
              : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset)
          let anchor =
            (iAnchor &&
              iAnchor.node == domSel.anchorNode &&
              iAnchor.offset == domSel.anchorOffset) ||
            !contains(view.contentDOM, domSel.anchorNode)
              ? view.state.selection.main.anchor
              : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset)
          this.newSel = dist_EditorSelection.single(anchor, head)
        }
      }
    }
    function applyDOMChange(view, domChange) {
      let change
      let { newSel } = domChange,
        sel = view.state.selection.main
      let lastKey =
        view.inputState.lastKeyTime > Date.now() - 100
          ? view.inputState.lastKeyCode
          : -1
      if (domChange.bounds) {
        let { from, to } = domChange.bounds
        let preferredPos = sel.from,
          preferredSide = null
        // Prefer anchoring to end when Backspace is pressed (or, on
        // Android, when something was deleted)
        if (
          lastKey === 8 ||
          (browser.android && domChange.text.length < to - from)
        ) {
          preferredPos = sel.to
          preferredSide = 'end'
        }
        let diff = findDiff(
          view.state.doc.sliceString(from, to, LineBreakPlaceholder),
          domChange.text,
          preferredPos - from,
          preferredSide
        )
        if (diff) {
          // Chrome inserts two newlines when pressing shift-enter at the
          // end of a line. DomChange drops one of those.
          if (
            browser.chrome &&
            lastKey == 13 &&
            diff.toB == diff.from + 2 &&
            domChange.text.slice(diff.from, diff.toB) ==
              LineBreakPlaceholder + LineBreakPlaceholder
          )
            diff.toB--
          change = {
            from: from + diff.from,
            to: from + diff.toA,
            insert: Text.of(
              domChange.text
                .slice(diff.from, diff.toB)
                .split(LineBreakPlaceholder)
            )
          }
        }
      } else if (
        newSel &&
        ((!view.hasFocus && view.state.facet(editable)) || newSel.main.eq(sel))
      ) {
        newSel = null
      }
      if (!change && !newSel) return false
      if (
        !change &&
        domChange.typeOver &&
        !sel.empty &&
        newSel &&
        newSel.main.empty
      ) {
        // Heuristic to notice typing over a selected character
        change = {
          from: sel.from,
          to: sel.to,
          insert: view.state.doc.slice(sel.from, sel.to)
        }
      } else if (
        change &&
        change.from >= sel.from &&
        change.to <= sel.to &&
        (change.from != sel.from || change.to != sel.to) &&
        sel.to - sel.from - (change.to - change.from) <= 4
      ) {
        // If the change is inside the selection and covers most of it,
        // assume it is a selection replace (with identical characters at
        // the start/end not included in the diff)
        change = {
          from: sel.from,
          to: sel.to,
          insert: view.state.doc
            .slice(sel.from, change.from)
            .append(change.insert)
            .append(view.state.doc.slice(change.to, sel.to))
        }
      } else if (
        (browser.mac || browser.android) &&
        change &&
        change.from == change.to &&
        change.from == sel.head - 1 &&
        /^\. ?$/.test(change.insert.toString()) &&
        view.contentDOM.getAttribute('autocorrect') == 'off'
      ) {
        // Detect insert-period-on-double-space Mac and Android behavior,
        // and transform it into a regular space insert.
        if (newSel && change.insert.length == 2)
          newSel = dist_EditorSelection.single(
            newSel.main.anchor - 1,
            newSel.main.head - 1
          )
        change = { from: sel.from, to: sel.to, insert: Text.of([' ']) }
      } else if (
        browser.chrome &&
        change &&
        change.from == change.to &&
        change.from == sel.head &&
        change.insert.toString() == '\n ' &&
        view.lineWrapping
      ) {
        // In Chrome, if you insert a space at the start of a wrapped
        // line, it will actually insert a newline and a space, causing a
        // bogus new line to be created in CodeMirror (#968)
        if (newSel)
          newSel = dist_EditorSelection.single(
            newSel.main.anchor - 1,
            newSel.main.head - 1
          )
        change = { from: sel.from, to: sel.to, insert: Text.of([' ']) }
      }
      if (change) {
        if (browser.ios && view.inputState.flushIOSKey()) return true
        // Android browsers don't fire reasonable key events for enter,
        // backspace, or delete. So this detects changes that look like
        // they're caused by those keys, and reinterprets them as key
        // events. (Some of these keys are also handled by beforeinput
        // events and the pendingAndroidKey mechanism, but that's not
        // reliable in all situations.)
        if (
          browser.android &&
          ((change.from == sel.from &&
            change.to == sel.to &&
            change.insert.length == 1 &&
            change.insert.lines == 2 &&
            dispatchKey(view.contentDOM, 'Enter', 13)) ||
            (((change.from == sel.from - 1 &&
              change.to == sel.to &&
              change.insert.length == 0) ||
              (lastKey == 8 &&
                change.insert.length < change.to - change.from &&
                change.to > sel.head)) &&
              dispatchKey(view.contentDOM, 'Backspace', 8)) ||
            (change.from == sel.from &&
              change.to == sel.to + 1 &&
              change.insert.length == 0 &&
              dispatchKey(view.contentDOM, 'Delete', 46)))
        )
          return true
        let text = change.insert.toString()
        if (view.inputState.composing >= 0) view.inputState.composing++
        let defaultTr
        let defaultInsert = () =>
          defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel))
        if (
          !view.state
            .facet(inputHandler)
            .some((h) => h(view, change.from, change.to, text, defaultInsert))
        )
          view.dispatch(defaultInsert())
        return true
      } else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false,
          userEvent = 'select'
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
          if (view.inputState.lastSelectionOrigin == 'select')
            scrollIntoView = true
          userEvent = view.inputState.lastSelectionOrigin
        }
        view.dispatch({ selection: newSel, scrollIntoView, userEvent })
        return true
      } else {
        return false
      }
    }
    function applyDefaultInsert(view, change, newSel) {
      let tr,
        startState = view.state,
        sel = startState.selection.main
      if (
        change.from >= sel.from &&
        change.to <= sel.to &&
        change.to - change.from >= (sel.to - sel.from) / 3 &&
        (!newSel ||
          (newSel.main.empty &&
            newSel.main.from == change.from + change.insert.length)) &&
        view.inputState.composing < 0
      ) {
        let before =
          sel.from < change.from
            ? startState.sliceDoc(sel.from, change.from)
            : ''
        let after =
          sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : ''
        tr = startState.replaceSelection(
          view.state.toText(
            before +
              change.insert.sliceString(0, undefined, view.state.lineBreak) +
              after
          )
        )
      } else {
        let changes = startState.changes(change)
        let mainSel =
          newSel && newSel.main.to <= changes.newLength
            ? newSel.main
            : undefined
        // Try to apply a composition change to all cursors
        if (
          startState.selection.ranges.length > 1 &&
          view.inputState.composing >= 0 &&
          change.to <= sel.to &&
          change.to >= sel.to - 10
        ) {
          let replaced = view.state.sliceDoc(change.from, change.to)
          let compositionRange,
            composition = newSel && findCompositionNode(view, newSel.main.head)
          if (composition) {
            let dLen = change.insert.length - (change.to - change.from)
            compositionRange = {
              from: composition.from,
              to: composition.to - dLen
            }
          } else {
            compositionRange = view.state.doc.lineAt(sel.head)
          }
          let offset = sel.to - change.to,
            size = sel.to - sel.from
          tr = startState.changeByRange((range) => {
            if (range.from == sel.from && range.to == sel.to)
              return { changes, range: mainSel || range.map(changes) }
            let to = range.to - offset,
              from = to - replaced.length
            if (
              range.to - range.from != size ||
              view.state.sliceDoc(from, to) != replaced ||
              // Unfortunately, there's no way to make multiple
              // changes in the same node work without aborting
              // composition, so cursors in the composition range are
              // ignored.
              (range.to >= compositionRange.from &&
                range.from <= compositionRange.to)
            )
              return { range }
            let rangeChanges = startState.changes({
                from,
                to,
                insert: change.insert
              }),
              selOff = range.to - sel.to
            return {
              changes: rangeChanges,
              range: !mainSel
                ? range.map(rangeChanges)
                : dist_EditorSelection.range(
                    Math.max(0, mainSel.anchor + selOff),
                    Math.max(0, mainSel.head + selOff)
                  )
            }
          })
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel)
          }
        }
      }
      let userEvent = 'input.type'
      if (
        view.composing ||
        (view.inputState.compositionPendingChange &&
          view.inputState.compositionEndedAt > Date.now() - 50)
      ) {
        view.inputState.compositionPendingChange = false
        userEvent += '.compose'
        if (view.inputState.compositionFirstChange) {
          userEvent += '.start'
          view.inputState.compositionFirstChange = false
        }
      }
      return startState.update(tr, { userEvent, scrollIntoView: true })
    }
    function findDiff(a, b, preferredPos, preferredSide) {
      let minLen = Math.min(a.length, b.length)
      let from = 0
      while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++
      if (from == minLen && a.length == b.length) return null
      let toA = a.length,
        toB = b.length
      while (
        toA > 0 &&
        toB > 0 &&
        a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)
      ) {
        toA--
        toB--
      }
      if (preferredSide == 'end') {
        let adjust = Math.max(0, from - Math.min(toA, toB))
        preferredPos -= toA + adjust - from
      }
      if (toA < from && a.length < b.length) {
        let move =
          preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0
        from -= move
        toB = from + (toB - toA)
        toA = from
      } else if (toB < from) {
        let move =
          preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0
        from -= move
        toA = from + (toA - toB)
        toB = from
      }
      return { from, toA, toB }
    }
    function selectionPoints(view) {
      let result = []
      if (view.root.activeElement != view.contentDOM) return result
      let { anchorNode, anchorOffset, focusNode, focusOffset } =
        view.observer.selectionRange
      if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset))
        if (focusNode != anchorNode || focusOffset != anchorOffset)
          result.push(new DOMPoint(focusNode, focusOffset))
      }
      return result
    }
    function selectionFromPoints(points, base) {
      if (points.length == 0) return null
      let anchor = points[0].pos,
        head = points.length == 2 ? points[1].pos : anchor
      return anchor > -1 && head > -1
        ? dist_EditorSelection.single(anchor + base, head + base)
        : null
    }

    const observeOptions = {
      childList: true,
      characterData: true,
      subtree: true,
      attributes: true,
      characterDataOldValue: true
    }
    // IE11 has very broken mutation observers, so we also listen to
    // DOMCharacterDataModified there
    const useCharData = browser.ie && browser.ie_version <= 11
    class DOMObserver {
      constructor(view) {
        this.view = view
        this.active = false
        // The known selection. Kept in our own object, as opposed to just
        // directly accessing the selection because:
        //  - Safari doesn't report the right selection in shadow DOM
        //  - Reading from the selection forces a DOM layout
        //  - This way, we can ignore selectionchange events if we have
        //    already seen the 'new' selection
        this.selectionRange = new DOMSelectionState()
        // Set when a selection change is detected, cleared on flush
        this.selectionChanged = false
        this.delayedFlush = -1
        this.resizeTimeout = -1
        this.queue = []
        this.delayedAndroidKey = null
        this.flushingAndroidKey = -1
        this.lastChange = 0
        this.scrollTargets = []
        this.intersection = null
        this.resizeScroll = null
        this.intersecting = false
        this.gapIntersection = null
        this.gaps = []
        // Timeout for scheduling check of the parents that need scroll handlers
        this.parentCheck = -1
        this.dom = view.contentDOM
        this.observer = new MutationObserver((mutations) => {
          for (let mut of mutations) this.queue.push(mut)
          // IE11 will sometimes (on typing over a selection or
          // backspacing out a single character text node) call the
          // observer callback before actually updating the DOM.
          //
          // Unrelatedly, iOS Safari will, when ending a composition,
          // sometimes first clear it, deliver the mutations, and then
          // reinsert the finished text. CodeMirror's handling of the
          // deletion will prevent the reinsertion from happening,
          // breaking composition.
          if (
            ((browser.ie && browser.ie_version <= 11) ||
              (browser.ios && view.composing)) &&
            mutations.some(
              (m) =>
                (m.type == 'childList' && m.removedNodes.length) ||
                (m.type == 'characterData' &&
                  m.oldValue.length > m.target.nodeValue.length)
            )
          )
            this.flushSoon()
          else this.flush()
        })
        if (useCharData)
          this.onCharData = (event) => {
            this.queue.push({
              target: event.target,
              type: 'characterData',
              oldValue: event.prevValue
            })
            this.flushSoon()
          }
        this.onSelectionChange = this.onSelectionChange.bind(this)
        this.onResize = this.onResize.bind(this)
        this.onPrint = this.onPrint.bind(this)
        this.onScroll = this.onScroll.bind(this)
        if (typeof ResizeObserver == 'function') {
          this.resizeScroll = new ResizeObserver(() => {
            var _a
            if (
              ((_a = this.view.docView) === null || _a === void 0
                ? void 0
                : _a.lastUpdate) <
              Date.now() - 75
            )
              this.onResize()
          })
          this.resizeScroll.observe(view.scrollDOM)
        }
        this.addWindowListeners((this.win = view.win))
        this.start()
        if (typeof IntersectionObserver == 'function') {
          this.intersection = new IntersectionObserver(
            (entries) => {
              if (this.parentCheck < 0)
                this.parentCheck = setTimeout(
                  this.listenForScroll.bind(this),
                  1000
                )
              if (
                entries.length > 0 &&
                entries[entries.length - 1].intersectionRatio > 0 !=
                  this.intersecting
              ) {
                this.intersecting = !this.intersecting
                if (this.intersecting != this.view.inView)
                  this.onScrollChanged(document.createEvent('Event'))
              }
            },
            { threshold: [0, 0.001] }
          )
          this.intersection.observe(this.dom)
          this.gapIntersection = new IntersectionObserver((entries) => {
            if (
              entries.length > 0 &&
              entries[entries.length - 1].intersectionRatio > 0
            )
              this.onScrollChanged(document.createEvent('Event'))
          }, {})
        }
        this.listenForScroll()
        this.readSelectionRange()
      }
      onScrollChanged(e) {
        this.view.inputState.runHandlers('scroll', e)
        if (this.intersecting) this.view.measure()
      }
      onScroll(e) {
        if (this.intersecting) this.flush(false)
        this.onScrollChanged(e)
      }
      onResize() {
        if (this.resizeTimeout < 0)
          this.resizeTimeout = setTimeout(() => {
            this.resizeTimeout = -1
            this.view.requestMeasure()
          }, 50)
      }
      onPrint() {
        this.view.viewState.printing = true
        this.view.measure()
        setTimeout(() => {
          this.view.viewState.printing = false
          this.view.requestMeasure()
        }, 500)
      }
      updateGaps(gaps) {
        if (
          this.gapIntersection &&
          (gaps.length != this.gaps.length ||
            this.gaps.some((g, i) => g != gaps[i]))
        ) {
          this.gapIntersection.disconnect()
          for (let gap of gaps) this.gapIntersection.observe(gap)
          this.gaps = gaps
        }
      }
      onSelectionChange(event) {
        let wasChanged = this.selectionChanged
        if (!this.readSelectionRange() || this.delayedAndroidKey) return
        let { view } = this,
          sel = this.selectionRange
        if (
          view.state.facet(editable)
            ? view.root.activeElement != this.dom
            : !hasSelection(view.dom, sel)
        )
          return
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode)
        if (context && context.ignoreEvent(event)) {
          if (!wasChanged) this.selectionChanged = false
          return
        }
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // Chrome Android has a similar issue when backspacing out a
        // selection (#645).
        if (
          ((browser.ie && browser.ie_version <= 11) ||
            (browser.android && browser.chrome)) &&
          !view.state.selection.main.empty &&
          // (Selection.isCollapsed isn't reliable on IE)
          sel.focusNode &&
          isEquivalentPosition(
            sel.focusNode,
            sel.focusOffset,
            sel.anchorNode,
            sel.anchorOffset
          )
        )
          this.flushSoon()
        else this.flush(false)
      }
      readSelectionRange() {
        let { view } = this
        // The Selection object is broken in shadow roots in Safari. See
        // https://github.com/codemirror/dev/issues/414
        let range =
          (browser.safari &&
            view.root.nodeType == 11 &&
            deepActiveElement(this.dom.ownerDocument) == this.dom &&
            safariSelectionRangeHack(this.view)) ||
          getSelection(view.root)
        if (!range || this.selectionRange.eq(range)) return false
        let local = hasSelection(this.dom, range)
        // Detect the situation where the browser has, on focus, moved the
        // selection to the start of the content element. Reset it to the
        // position from the editor state.
        if (
          local &&
          !this.selectionChanged &&
          view.inputState.lastFocusTime > Date.now() - 200 &&
          view.inputState.lastTouchTime < Date.now() - 300 &&
          atElementStart(this.dom, range)
        ) {
          this.view.inputState.lastFocusTime = 0
          view.docView.updateSelection()
          return false
        }
        this.selectionRange.setRange(range)
        if (local) this.selectionChanged = true
        return true
      }
      setSelectionRange(anchor, head) {
        this.selectionRange.set(
          anchor.node,
          anchor.offset,
          head.node,
          head.offset
        )
        this.selectionChanged = false
      }
      clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0)
      }
      listenForScroll() {
        this.parentCheck = -1
        let i = 0,
          changed = null
        for (let dom = this.dom; dom; ) {
          if (dom.nodeType == 1) {
            if (
              !changed &&
              i < this.scrollTargets.length &&
              this.scrollTargets[i] == dom
            )
              i++
            else if (!changed) changed = this.scrollTargets.slice(0, i)
            if (changed) changed.push(dom)
            dom = dom.assignedSlot || dom.parentNode
          } else if (dom.nodeType == 11) {
            // Shadow root
            dom = dom.host
          } else {
            break
          }
        }
        if (i < this.scrollTargets.length && !changed)
          changed = this.scrollTargets.slice(0, i)
        if (changed) {
          for (let dom of this.scrollTargets)
            dom.removeEventListener('scroll', this.onScroll)
          for (let dom of (this.scrollTargets = changed))
            dom.addEventListener('scroll', this.onScroll)
        }
      }
      ignore(f) {
        if (!this.active) return f()
        try {
          this.stop()
          return f()
        } finally {
          this.start()
          this.clear()
        }
      }
      start() {
        if (this.active) return
        this.observer.observe(this.dom, observeOptions)
        if (useCharData)
          this.dom.addEventListener('DOMCharacterDataModified', this.onCharData)
        this.active = true
      }
      stop() {
        if (!this.active) return
        this.active = false
        this.observer.disconnect()
        if (useCharData)
          this.dom.removeEventListener(
            'DOMCharacterDataModified',
            this.onCharData
          )
      }
      // Throw away any pending changes
      clear() {
        this.processRecords()
        this.queue.length = 0
        this.selectionChanged = false
      }
      // Chrome Android, especially in combination with GBoard, not only
      // doesn't reliably fire regular key events, but also often
      // surrounds the effect of enter or backspace with a bunch of
      // composition events that, when interrupted, cause text duplication
      // or other kinds of corruption. This hack makes the editor back off
      // from handling DOM changes for a moment when such a key is
      // detected (via beforeinput or keydown), and then tries to flush
      // them or, if that has no effect, dispatches the given key.
      delayAndroidKey(key, keyCode) {
        var _a
        if (!this.delayedAndroidKey) {
          let flush = () => {
            let key = this.delayedAndroidKey
            if (key) {
              this.clearDelayedAndroidKey()
              this.view.inputState.lastKeyCode = key.keyCode
              this.view.inputState.lastKeyTime = Date.now()
              let flushed = this.flush()
              if (!flushed && key.force)
                dispatchKey(this.dom, key.key, key.keyCode)
            }
          }
          this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush)
        }
        // Since backspace beforeinput is sometimes signalled spuriously,
        // Enter always takes precedence.
        if (!this.delayedAndroidKey || key == 'Enter')
          this.delayedAndroidKey = {
            key,
            keyCode,
            // Only run the key handler when no changes are detected if
            // this isn't coming right after another change, in which case
            // it is probably part of a weird chain of updates, and should
            // be ignored if it returns the DOM to its previous state.
            force:
              this.lastChange < Date.now() - 50 ||
              !!((_a = this.delayedAndroidKey) === null || _a === void 0
                ? void 0
                : _a.force)
          }
      }
      clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey)
        this.delayedAndroidKey = null
        this.flushingAndroidKey = -1
      }
      flushSoon() {
        if (this.delayedFlush < 0)
          this.delayedFlush = this.view.win.requestAnimationFrame(() => {
            this.delayedFlush = -1
            this.flush()
          })
      }
      forceFlush() {
        if (this.delayedFlush >= 0) {
          this.view.win.cancelAnimationFrame(this.delayedFlush)
          this.delayedFlush = -1
        }
        this.flush()
      }
      pendingRecords() {
        for (let mut of this.observer.takeRecords()) this.queue.push(mut)
        return this.queue
      }
      processRecords() {
        let records = this.pendingRecords()
        if (records.length) this.queue = []
        let from = -1,
          to = -1,
          typeOver = false
        for (let record of records) {
          let range = this.readMutation(record)
          if (!range) continue
          if (range.typeOver) typeOver = true
          if (from == -1) {
            ;({ from, to } = range)
          } else {
            from = Math.min(range.from, from)
            to = Math.max(range.to, to)
          }
        }
        return { from, to, typeOver }
      }
      readChange() {
        let { from, to, typeOver } = this.processRecords()
        let newSel =
          this.selectionChanged && hasSelection(this.dom, this.selectionRange)
        if (from < 0 && !newSel) return null
        if (from > -1) this.lastChange = Date.now()
        this.view.inputState.lastFocusTime = 0
        this.selectionChanged = false
        let change = new DOMChange(this.view, from, to, typeOver)
        this.view.docView.domChanged = {
          newSel: change.newSel ? change.newSel.main : null
        }
        return change
      }
      // Apply pending changes, if any
      flush(readSelection = true) {
        // Completely hold off flushing when pending keys are set—the code
        // managing those will make sure processRecords is called and the
        // view is resynchronized after
        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false
        if (readSelection) this.readSelectionRange()
        let domChange = this.readChange()
        if (!domChange) {
          this.view.requestMeasure()
          return false
        }
        let startState = this.view.state
        let handled = applyDOMChange(this.view, domChange)
        // The view wasn't updated
        if (this.view.state == startState) this.view.update([])
        return handled
      }
      readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target)
        if (!cView || cView.ignoreMutation(rec)) return null
        cView.markDirty(rec.type == 'attributes')
        if (rec.type == 'attributes') cView.flags |= 4 /* ViewFlag.AttrsDirty */
        if (rec.type == 'childList') {
          let childBefore = findChild(
            cView,
            rec.previousSibling || rec.target.previousSibling,
            -1
          )
          let childAfter = findChild(
            cView,
            rec.nextSibling || rec.target.nextSibling,
            1
          )
          return {
            from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
            to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
            typeOver: false
          }
        } else if (rec.type == 'characterData') {
          return {
            from: cView.posAtStart,
            to: cView.posAtEnd,
            typeOver: rec.target.nodeValue == rec.oldValue
          }
        } else {
          return null
        }
      }
      setWindow(win) {
        if (win != this.win) {
          this.removeWindowListeners(this.win)
          this.win = win
          this.addWindowListeners(this.win)
        }
      }
      addWindowListeners(win) {
        win.addEventListener('resize', this.onResize)
        win.addEventListener('beforeprint', this.onPrint)
        win.addEventListener('scroll', this.onScroll)
        win.document.addEventListener('selectionchange', this.onSelectionChange)
      }
      removeWindowListeners(win) {
        win.removeEventListener('scroll', this.onScroll)
        win.removeEventListener('resize', this.onResize)
        win.removeEventListener('beforeprint', this.onPrint)
        win.document.removeEventListener(
          'selectionchange',
          this.onSelectionChange
        )
      }
      destroy() {
        var _a, _b, _c
        this.stop()
        ;(_a = this.intersection) === null || _a === void 0
          ? void 0
          : _a.disconnect()
        ;(_b = this.gapIntersection) === null || _b === void 0
          ? void 0
          : _b.disconnect()
        ;(_c = this.resizeScroll) === null || _c === void 0
          ? void 0
          : _c.disconnect()
        for (let dom of this.scrollTargets)
          dom.removeEventListener('scroll', this.onScroll)
        this.removeWindowListeners(this.win)
        clearTimeout(this.parentCheck)
        clearTimeout(this.resizeTimeout)
        this.win.cancelAnimationFrame(this.delayedFlush)
        this.win.cancelAnimationFrame(this.flushingAndroidKey)
      }
    }
    function findChild(cView, dom, dir) {
      while (dom) {
        let curView = ContentView.get(dom)
        if (curView && curView.parent == cView) return curView
        let parent = dom.parentNode
        dom =
          parent != cView.dom
            ? parent
            : dir > 0
              ? dom.nextSibling
              : dom.previousSibling
      }
      return null
    }
    // Used to work around a Safari Selection/shadow DOM bug (#414)
    function safariSelectionRangeHack(view) {
      let found = null
      // Because Safari (at least in 2018-2021) doesn't provide regular
      // access to the selection inside a shadowroot, we have to perform a
      // ridiculous hack to get at it—using `execCommand` to trigger a
      // `beforeInput` event so that we can read the target range from the
      // event.
      function read(event) {
        event.preventDefault()
        event.stopImmediatePropagation()
        found = event.getTargetRanges()[0]
      }
      view.contentDOM.addEventListener('beforeinput', read, true)
      view.dom.ownerDocument.execCommand('indent')
      view.contentDOM.removeEventListener('beforeinput', read, true)
      if (!found) return null
      let anchorNode = found.startContainer,
        anchorOffset = found.startOffset
      let focusNode = found.endContainer,
        focusOffset = found.endOffset
      let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor)
      // Since such a range doesn't distinguish between anchor and head,
      // use a heuristic that flips it around if its end matches the
      // current anchor.
      if (
        isEquivalentPosition(
          curAnchor.node,
          curAnchor.offset,
          focusNode,
          focusOffset
        )
      )
        [anchorNode, anchorOffset, focusNode, focusOffset] = [
          focusNode,
          focusOffset,
          anchorNode,
          anchorOffset
        ]
      return { anchorNode, anchorOffset, focusNode, focusOffset }
    }

    // The editor's update state machine looks something like this:
    //
    //     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle
    //                                         ↑      ↓
    //                                         Updating (measure)
    //
    // The difference between 'Idle' and 'Idle (unchecked)' lies in
    // whether a layout check has been scheduled. A regular update through
    // the `update` method updates the DOM in a write-only fashion, and
    // relies on a check (scheduled with `requestAnimationFrame`) to make
    // sure everything is where it should be and the viewport covers the
    // visible code. That check continues to measure and then optionally
    // update until it reaches a coherent state.
    /**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/
    class EditorView {
      /**
    The current editor state.
    */
      get state() {
        return this.viewState.state
      }
      /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
      get viewport() {
        return this.viewState.viewport
      }
      /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
      get visibleRanges() {
        return this.viewState.visibleRanges
      }
      /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
      get inView() {
        return this.viewState.inView
      }
      /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
      get composing() {
        return this.inputState.composing > 0
      }
      /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
      get compositionStarted() {
        return this.inputState.composing >= 0
      }
      /**
    The document or shadow root that the view lives in.
    */
      get root() {
        return this._root
      }
      /**
    @internal
    */
      get win() {
        return this.dom.ownerDocument.defaultView || window
      }
      /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
      constructor(config = {}) {
        this.plugins = []
        this.pluginMap = new Map()
        this.editorAttrs = {}
        this.contentAttrs = {}
        this.bidiCache = []
        this.destroyed = false
        /**
        @internal
        */
        this.updateState = 2 /* UpdateState.Updating */
        /**
        @internal
        */
        this.measureScheduled = -1
        /**
        @internal
        */
        this.measureRequests = []
        this.contentDOM = document.createElement('div')
        this.scrollDOM = document.createElement('div')
        this.scrollDOM.tabIndex = -1
        this.scrollDOM.className = 'cm-scroller'
        this.scrollDOM.appendChild(this.contentDOM)
        this.announceDOM = document.createElement('div')
        this.announceDOM.className = 'cm-announced'
        this.announceDOM.setAttribute('aria-live', 'polite')
        this.dom = document.createElement('div')
        this.dom.appendChild(this.announceDOM)
        this.dom.appendChild(this.scrollDOM)
        let { dispatch } = config
        this.dispatchTransactions =
          config.dispatchTransactions ||
          (dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this)))) ||
          ((trs) => this.update(trs))
        this.dispatch = this.dispatch.bind(this)
        this._root = config.root || getRoot(config.parent) || document
        this.viewState = new ViewState(
          config.state || EditorState.create(config)
        )
        if (config.scrollTo && config.scrollTo.is(scrollIntoView))
          this.viewState.scrollTarget = config.scrollTo.value.clip(
            this.viewState.state
          )
        this.plugins = this.state
          .facet(viewPlugin)
          .map((spec) => new PluginInstance(spec))
        for (let plugin of this.plugins) plugin.update(this)
        this.observer = new DOMObserver(this)
        this.inputState = new InputState(this)
        this.inputState.ensureHandlers(this.plugins)
        this.docView = new DocView(this)
        this.mountStyles()
        this.updateAttrs()
        this.updateState = 0 /* UpdateState.Idle */
        this.requestMeasure()
        if (config.parent) config.parent.appendChild(this.dom)
      }
      dispatch(...input) {
        let trs =
          input.length == 1 && input[0] instanceof Transaction
            ? input
            : input.length == 1 && Array.isArray(input[0])
              ? input[0]
              : [this.state.update(...input)]
        this.dispatchTransactions(trs, this)
      }
      /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
      update(transactions) {
        if (this.updateState != 0 /* UpdateState.Idle */)
          throw new Error(
            'Calls to EditorView.update are not allowed while an update is in progress'
          )
        let redrawn = false,
          attrsChanged = false,
          update
        let state = this.state
        for (let tr of transactions) {
          if (tr.startState != state)
            throw new RangeError(
              "Trying to update state with a transaction that doesn't start from the previous state."
            )
          state = tr.state
        }
        if (this.destroyed) {
          this.viewState.state = state
          return
        }
        let focus = this.hasFocus,
          focusFlag = 0,
          dispatchFocus = null
        if (transactions.some((tr) => tr.annotation(isFocusChange))) {
          this.inputState.notifiedFocused = focus
          // If a focus-change transaction is being dispatched, set this update flag.
          focusFlag = 1 /* UpdateFlag.Focus */
        } else if (focus != this.inputState.notifiedFocused) {
          this.inputState.notifiedFocused = focus
          // Schedule a separate focus transaction if necessary, otherwise
          // add a flag to this update
          dispatchFocus = focusChangeTransaction(state, focus)
          if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */
        }
        // If there was a pending DOM change, eagerly read it and try to
        // apply it after the given transactions.
        let pendingKey = this.observer.delayedAndroidKey,
          domChange = null
        if (pendingKey) {
          this.observer.clearDelayedAndroidKey()
          domChange = this.observer.readChange()
          // Only try to apply DOM changes if the transactions didn't
          // change the doc or selection.
          if (
            (domChange && !this.state.doc.eq(state.doc)) ||
            !this.state.selection.eq(state.selection)
          )
            domChange = null
        } else {
          this.observer.clear()
        }
        // When the phrases change, redraw the editor
        if (
          state.facet(EditorState.phrases) !=
          this.state.facet(EditorState.phrases)
        )
          return this.setState(state)
        update = ViewUpdate.create(this, state, transactions)
        update.flags |= focusFlag
        let scrollTarget = this.viewState.scrollTarget
        try {
          this.updateState = 2 /* UpdateState.Updating */
          for (let tr of transactions) {
            if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes)
            if (tr.scrollIntoView) {
              let { main } = tr.state.selection
              scrollTarget = new ScrollTarget(
                main.empty
                  ? main
                  : dist_EditorSelection.cursor(
                      main.head,
                      main.head > main.anchor ? -1 : 1
                    )
              )
            }
            for (let e of tr.effects)
              if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state)
          }
          this.viewState.update(update, scrollTarget)
          this.bidiCache = CachedOrder.update(this.bidiCache, update.changes)
          if (!update.empty) {
            this.updatePlugins(update)
            this.inputState.update(update)
          }
          redrawn = this.docView.update(update)
          if (this.state.facet(styleModule) != this.styleModules)
            this.mountStyles()
          attrsChanged = this.updateAttrs()
          this.showAnnouncements(transactions)
          this.docView.updateSelection(
            redrawn,
            transactions.some((tr) => tr.isUserEvent('select.pointer'))
          )
        } finally {
          this.updateState = 0 /* UpdateState.Idle */
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
          this.viewState.mustMeasureContent = true
        if (
          redrawn ||
          attrsChanged ||
          scrollTarget ||
          this.viewState.mustEnforceCursorAssoc ||
          this.viewState.mustMeasureContent
        )
          this.requestMeasure()
        if (!update.empty)
          for (let listener of this.state.facet(updateListener)) {
            try {
              listener(update)
            } catch (e) {
              dist_logException(this.state, e, 'update listener')
            }
          }
        if (dispatchFocus || domChange)
          Promise.resolve().then(() => {
            if (dispatchFocus && this.state == dispatchFocus.startState)
              this.dispatch(dispatchFocus)
            if (domChange) {
              if (!applyDOMChange(this, domChange) && pendingKey.force)
                dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode)
            }
          })
      }
      /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
      setState(newState) {
        if (this.updateState != 0 /* UpdateState.Idle */)
          throw new Error(
            'Calls to EditorView.setState are not allowed while an update is in progress'
          )
        if (this.destroyed) {
          this.viewState.state = newState
          return
        }
        this.updateState = 2 /* UpdateState.Updating */
        let hadFocus = this.hasFocus
        try {
          for (let plugin of this.plugins) plugin.destroy(this)
          this.viewState = new ViewState(newState)
          this.plugins = newState
            .facet(viewPlugin)
            .map((spec) => new PluginInstance(spec))
          this.pluginMap.clear()
          for (let plugin of this.plugins) plugin.update(this)
          this.docView.destroy()
          this.docView = new DocView(this)
          this.inputState.ensureHandlers(this.plugins)
          this.mountStyles()
          this.updateAttrs()
          this.bidiCache = []
        } finally {
          this.updateState = 0 /* UpdateState.Idle */
        }
        if (hadFocus) this.focus()
        this.requestMeasure()
      }
      updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin),
          specs = update.state.facet(viewPlugin)
        if (prevSpecs != specs) {
          let newPlugins = []
          for (let spec of specs) {
            let found = prevSpecs.indexOf(spec)
            if (found < 0) {
              newPlugins.push(new PluginInstance(spec))
            } else {
              let plugin = this.plugins[found]
              plugin.mustUpdate = update
              newPlugins.push(plugin)
            }
          }
          for (let plugin of this.plugins)
            if (plugin.mustUpdate != update) plugin.destroy(this)
          this.plugins = newPlugins
          this.pluginMap.clear()
        } else {
          for (let p of this.plugins) p.mustUpdate = update
        }
        for (let i = 0; i < this.plugins.length; i++)
          this.plugins[i].update(this)
        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins)
      }
      /**
    @internal
    */
      measure(flush = true) {
        if (this.destroyed) return
        if (this.measureScheduled > -1)
          this.win.cancelAnimationFrame(this.measureScheduled)
        if (this.observer.delayedAndroidKey) {
          this.measureScheduled = -1
          this.requestMeasure()
          return
        }
        this.measureScheduled = 0 // Prevent requestMeasure calls from scheduling another animation frame
        if (flush) this.observer.forceFlush()
        let updated = null
        let sDOM = this.scrollDOM,
          scrollTop = sDOM.scrollTop * this.scaleY
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
          scrollAnchorHeight = -1
        this.viewState.scrollAnchorHeight = -1
        try {
          for (let i = 0; ; i++) {
            if (scrollAnchorHeight < 0) {
              if (isScrolledToBottom(sDOM)) {
                scrollAnchorPos = -1
                scrollAnchorHeight = this.viewState.heightMap.height
              } else {
                let block = this.viewState.scrollAnchorAt(scrollTop)
                scrollAnchorPos = block.from
                scrollAnchorHeight = block.top
              }
            }
            this.updateState = 1 /* UpdateState.Measuring */
            let changed = this.viewState.measure(this)
            if (
              !changed &&
              !this.measureRequests.length &&
              this.viewState.scrollTarget == null
            )
              break
            if (i > 5) {
              console.warn(
                this.measureRequests.length
                  ? 'Measure loop restarted more than 5 times'
                  : 'Viewport failed to stabilize'
              )
              break
            }
            let measuring = []
            // Only run measure requests in this cycle when the viewport didn't change
            if (!((changed & 4) /* UpdateFlag.Viewport */))
              [this.measureRequests, measuring] = [
                measuring,
                this.measureRequests
              ]
            let measured = measuring.map((m) => {
              try {
                return m.read(this)
              } catch (e) {
                dist_logException(this.state, e)
                return BadMeasure
              }
            })
            let update = ViewUpdate.create(this, this.state, []),
              redrawn = false
            update.flags |= changed
            if (!updated) updated = update
            else updated.flags |= changed
            this.updateState = 2 /* UpdateState.Updating */
            if (!update.empty) {
              this.updatePlugins(update)
              this.inputState.update(update)
              this.updateAttrs()
              redrawn = this.docView.update(update)
            }
            for (let i = 0; i < measuring.length; i++)
              if (measured[i] != BadMeasure) {
                try {
                  let m = measuring[i]
                  if (m.write) m.write(measured[i], this)
                } catch (e) {
                  dist_logException(this.state, e)
                }
              }
            if (redrawn) this.docView.updateSelection(true)
            if (!update.viewportChanged && this.measureRequests.length == 0) {
              if (this.viewState.editorHeight) {
                if (this.viewState.scrollTarget) {
                  this.docView.scrollIntoView(this.viewState.scrollTarget)
                  this.viewState.scrollTarget = null
                  scrollAnchorHeight = -1
                  continue
                } else {
                  let newAnchorHeight =
                    scrollAnchorPos < 0
                      ? this.viewState.heightMap.height
                      : this.viewState.lineBlockAt(scrollAnchorPos).top
                  let diff = newAnchorHeight - scrollAnchorHeight
                  if (diff > 1 || diff < -1) {
                    scrollTop = scrollTop + diff
                    sDOM.scrollTop = scrollTop / this.scaleY
                    scrollAnchorHeight = -1
                    continue
                  }
                }
              }
              break
            }
          }
        } finally {
          this.updateState = 0 /* UpdateState.Idle */
          this.measureScheduled = -1
        }
        if (updated && !updated.empty)
          for (let listener of this.state.facet(updateListener))
            listener(updated)
      }
      /**
    Get the CSS classes for the currently active editor themes.
    */
      get themeClasses() {
        return (
          baseThemeID +
          ' ' +
          (this.state.facet(darkTheme) ? baseDarkID : baseLightID) +
          ' ' +
          this.state.facet(theme)
        )
      }
      updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
          class:
            'cm-editor' +
            (this.hasFocus ? ' cm-focused ' : ' ') +
            this.themeClasses
        })
        let contentAttrs = {
          spellcheck: 'false',
          autocorrect: 'off',
          autocapitalize: 'off',
          translate: 'no',
          contenteditable: !this.state.facet(editable) ? 'false' : 'true',
          class: 'cm-content',
          style: `${browser.tabSize}: ${this.state.tabSize}`,
          role: 'textbox',
          'aria-multiline': 'true'
        }
        if (this.state.readOnly) contentAttrs['aria-readonly'] = 'true'
        attrsFromFacet(this, contentAttributes, contentAttrs)
        let changed = this.observer.ignore(() => {
          let changedContent = updateAttrs(
            this.contentDOM,
            this.contentAttrs,
            contentAttrs
          )
          let changedEditor = updateAttrs(
            this.dom,
            this.editorAttrs,
            editorAttrs
          )
          return changedContent || changedEditor
        })
        this.editorAttrs = editorAttrs
        this.contentAttrs = contentAttrs
        return changed
      }
      showAnnouncements(trs) {
        let first = true
        for (let tr of trs)
          for (let effect of tr.effects)
            if (effect.is(EditorView.announce)) {
              if (first) this.announceDOM.textContent = ''
              first = false
              let div = this.announceDOM.appendChild(
                document.createElement('div')
              )
              div.textContent = effect.value
            }
      }
      mountStyles() {
        this.styleModules = this.state.facet(styleModule)
        let nonce = this.state.facet(EditorView.cspNonce)
        StyleModule.mount(
          this.root,
          this.styleModules.concat(baseTheme$1).reverse(),
          nonce ? { nonce } : undefined
        )
      }
      readMeasured() {
        if (this.updateState == 2 /* UpdateState.Updating */)
          throw new Error(
            "Reading the editor layout isn't allowed during an update"
          )
        if (
          this.updateState == 0 /* UpdateState.Idle */ &&
          this.measureScheduled > -1
        )
          this.measure(false)
      }
      /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
      requestMeasure(request) {
        if (this.measureScheduled < 0)
          this.measureScheduled = this.win.requestAnimationFrame(() =>
            this.measure()
          )
        if (request) {
          if (this.measureRequests.indexOf(request) > -1) return
          if (request.key != null)
            for (let i = 0; i < this.measureRequests.length; i++) {
              if (this.measureRequests[i].key === request.key) {
                this.measureRequests[i] = request
                return
              }
            }
          this.measureRequests.push(request)
        }
      }
      /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
      plugin(plugin) {
        let known = this.pluginMap.get(plugin)
        if (known === undefined || (known && known.spec != plugin))
          this.pluginMap.set(
            plugin,
            (known = this.plugins.find((p) => p.spec == plugin) || null)
          )
        return known && known.update(this).value
      }
      /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
      get documentTop() {
        return (
          this.contentDOM.getBoundingClientRect().top +
          this.viewState.paddingTop
        )
      }
      /**
    Reports the padding above and below the document.
    */
      get documentPadding() {
        return {
          top: this.viewState.paddingTop,
          bottom: this.viewState.paddingBottom
        }
      }
      /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
      get scaleX() {
        return this.viewState.scaleX
      }
      /**
    Provide the CSS transformed scale along the Y axis.
    */
      get scaleY() {
        return this.viewState.scaleY
      }
      /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
      elementAtHeight(height) {
        this.readMeasured()
        return this.viewState.elementAtHeight(height)
      }
      /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
      lineBlockAtHeight(height) {
        this.readMeasured()
        return this.viewState.lineBlockAtHeight(height)
      }
      /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
      get viewportLineBlocks() {
        return this.viewState.viewportLines
      }
      /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
      lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos)
      }
      /**
    The editor's total content height.
    */
      get contentHeight() {
        return this.viewState.contentHeight
      }
      /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
      moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by))
      }
      /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
      moveByGroup(start, forward) {
        return skipAtoms(
          this,
          start,
          moveByChar(this, start, forward, (initial) =>
            byGroup(this, start.head, initial)
          )
        )
      }
      /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
      moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap)
      }
      /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
      moveVertically(start, forward, distance) {
        return skipAtoms(
          this,
          start,
          moveVertically(this, start, forward, distance)
        )
      }
      /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
      domAtPos(pos) {
        return this.docView.domAtPos(pos)
      }
      /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
      posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset)
      }
      posAtCoords(coords, precise = true) {
        this.readMeasured()
        return posAtCoords(this, coords, precise)
      }
      /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
      coordsAtPos(pos, side = 1) {
        this.readMeasured()
        let rect = this.docView.coordsAt(pos, side)
        if (!rect || rect.left == rect.right) return rect
        let line = this.state.doc.lineAt(pos),
          order = this.bidiSpans(line)
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)]
        return flattenRect(rect, (span.dir == Direction.LTR) == side > 0)
      }
      /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
      coordsForChar(pos) {
        this.readMeasured()
        return this.docView.coordsForChar(pos)
      }
      /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
      get defaultCharacterWidth() {
        return this.viewState.heightOracle.charWidth
      }
      /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
      get defaultLineHeight() {
        return this.viewState.heightOracle.lineHeight
      }
      /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
      get textDirection() {
        return this.viewState.defaultTextDirection
      }
      /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
      textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection)
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
          return this.textDirection
        this.readMeasured()
        return this.docView.textDirectionAt(pos)
      }
      /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
      get lineWrapping() {
        return this.viewState.heightOracle.lineWrapping
      }
      /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
      bidiSpans(line) {
        if (line.length > MaxBidiLine) return trivialOrder(line.length)
        let dir = this.textDirectionAt(line.from),
          isolates
        for (let entry of this.bidiCache) {
          if (
            entry.from == line.from &&
            entry.dir == dir &&
            (entry.fresh ||
              isolatesEq(
                entry.isolates,
                (isolates = getIsolatedRanges(this, line.from, line.to))
              ))
          )
            return entry.order
        }
        if (!isolates) isolates = getIsolatedRanges(this, line.from, line.to)
        let order = computeOrder(line.text, dir, isolates)
        this.bidiCache.push(
          new CachedOrder(line.from, line.to, dir, isolates, true, order)
        )
        return order
      }
      /**
    Check whether the editor has focus.
    */
      get hasFocus() {
        var _a
        // Safari return false for hasFocus when the context menu is open
        // or closing, which leads us to ignore selection changes from the
        // context menu because it looks like the editor isn't focused.
        // This kludges around that.
        return (
          (this.dom.ownerDocument.hasFocus() ||
            (browser.safari &&
              ((_a = this.inputState) === null || _a === void 0
                ? void 0
                : _a.lastContextMenu) >
                Date.now() - 3e4)) &&
          this.root.activeElement == this.contentDOM
        )
      }
      /**
    Put focus on the editor.
    */
      focus() {
        this.observer.ignore(() => {
          focusPreventScroll(this.contentDOM)
          this.docView.updateSelection()
        })
      }
      /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
      setRoot(root) {
        if (this._root != root) {
          this._root = root
          this.observer.setWindow(
            (root.nodeType == 9 ? root : root.ownerDocument).defaultView ||
              window
          )
          this.mountStyles()
        }
      }
      /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
      destroy() {
        for (let plugin of this.plugins) plugin.destroy(this)
        this.plugins = []
        this.inputState.destroy()
        this.docView.destroy()
        this.dom.remove()
        this.observer.destroy()
        if (this.measureScheduled > -1)
          this.win.cancelAnimationFrame(this.measureScheduled)
        this.destroyed = true
      }
      /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
      static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(
          new ScrollTarget(
            typeof pos == 'number' ? dist_EditorSelection.cursor(pos) : pos,
            options.y,
            options.x,
            options.yMargin,
            options.xMargin
          )
        )
      }
      /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
      scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM
        let ref = this.viewState.scrollAnchorAt(scrollTop)
        return scrollIntoView.of(
          new ScrollTarget(
            dist_EditorSelection.cursor(ref.from),
            'start',
            'start',
            ref.top - scrollTop,
            scrollLeft,
            true
          )
        )
      }
      /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
      static domEventHandlers(handlers) {
        return dist_ViewPlugin.define(() => ({}), { eventHandlers: handlers })
      }
      /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
      static domEventObservers(observers) {
        return dist_ViewPlugin.define(() => ({}), { eventObservers: observers })
      }
      /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
    added—need to be explicitly differentiated by adding an `&` to
    the selector for that element—for example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
      static theme(spec, options) {
        let prefix = StyleModule.newName()
        let result = [
          theme.of(prefix),
          styleModule.of(buildTheme(`.${prefix}`, spec))
        ]
        if (options && options.dark) result.push(darkTheme.of(true))
        return result
      }
      /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
      static baseTheme(spec) {
        return Prec.lowest(
          styleModule.of(buildTheme('.' + baseThemeID, spec, lightDarkIDs))
        )
      }
      /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
      static findFromDOM(dom) {
        var _a
        let content = dom.querySelector('.cm-content')
        let cView =
          (content && ContentView.get(content)) || ContentView.get(dom)
        return (
          ((_a =
            cView === null || cView === void 0 ? void 0 : cView.rootView) ===
            null || _a === void 0
            ? void 0
            : _a.view) || null
        )
      }
    }
    /**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/
    EditorView.styleModule = styleModule
    /**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.

The `insert` argument can be used to get the default transaction
that would be applied for this input. This can be useful when
dispatching the custom behavior as a separate transaction.
*/
    EditorView.inputHandler = inputHandler
    /**
This facet can be used to provide functions that create effects
to be dispatched when the editor's focus state changes.
*/
    EditorView.focusChangeEffect = focusChangeEffect
    /**
By default, the editor assumes all its content has the same
[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
value to make it read the text direction of every (rendered)
line separately.
*/
    EditorView.perLineTextDirection = perLineTextDirection
    /**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/
    EditorView.exceptionSink = exceptionSink
    /**
A facet that can be used to register a function to be called
every time the view updates.
*/
    EditorView.updateListener = updateListener
    /**
Facet that controls whether the editor content DOM is editable.
When its highest-precedence value is `false`, the element will
not have its `contenteditable` attribute set. (Note that this
doesn't affect API calls that change the editor content, even
when those are bound to keys or buttons. See the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
*/
    EditorView.editable = editable
    /**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/
    EditorView.mouseSelectionStyle = mouseSelectionStyle
    /**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/
    EditorView.dragMovesSelection = dragMovesSelection$1
    /**
Facet used to configure whether a given selecting click adds a
new range to the existing selection or replaces it entirely. The
default behavior is to check `event.metaKey` on macOS, and
`event.ctrlKey` elsewhere.
*/
    EditorView.clickAddsSelectionRange = clickAddsSelectionRange
    /**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. Decorations can be provided in two
ways—directly, or via a function that takes an editor view.

Only decoration sets provided directly are allowed to influence
the editor's vertical layout structure. The ones provided as
functions are called _after_ the new viewport has been computed,
and thus **must not** introduce block widgets or replacing
decorations that cover line breaks.

If you want decorated ranges to behave like atomic units for
cursor motion and deletion purposes, also provide the range set
containing the decorations to
[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
*/
    EditorView.decorations = decorations
    /**
Used to provide ranges that should be treated as atoms as far as
cursor motion is concerned. This causes methods like
[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
commands built on top of them) to skip across such regions when
a selection endpoint would enter them. This does _not_ prevent
direct programmatic [selection
updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
regions.
*/
    EditorView.atomicRanges = atomicRanges
    /**
When range decorations add a `unicode-bidi: isolate` style, they
should also include a
[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property
in their decoration spec, and be exposed through this facet, so
that the editor can compute the proper text order. (Other values
for `unicode-bidi`, except of course `normal`, are not
supported.)
*/
    EditorView.bidiIsolatedRanges = bidiIsolatedRanges
    /**
Facet that allows extensions to provide additional scroll
margins (space around the sides of the scrolling element that
should be considered invisible). This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/
    EditorView.scrollMargins = scrollMargins
    /**
This facet records whether a dark theme is active. The extension
returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
includes an instance of this when the `dark` option is set to
true.
*/
    EditorView.darkTheme = darkTheme
    /**
Provides a Content Security Policy nonce to use when creating
the style sheets for the editor. Holds the empty string when no
nonce has been provided.
*/
    EditorView.cspNonce = /*@__PURE__*/ Facet.define({
      combine: (values) => (values.length ? values[0] : '')
    })
    /**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/
    EditorView.contentAttributes = contentAttributes
    /**
Facet that provides DOM attributes for the editor's outer
element.
*/
    EditorView.editorAttributes = editorAttributes
    /**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/
    EditorView.lineWrapping = /*@__PURE__*/ EditorView.contentAttributes.of({
      class: 'cm-lineWrapping'
    })
    /**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/
    EditorView.announce = /*@__PURE__*/ StateEffect.define()
    // Maximum line length for which we compute accurate bidi info
    const MaxBidiLine = 4096
    const BadMeasure = {}
    class CachedOrder {
      constructor(from, to, dir, isolates, fresh, order) {
        this.from = from
        this.to = to
        this.dir = dir
        this.isolates = isolates
        this.fresh = fresh
        this.order = order
      }
      static update(cache, changes) {
        if (changes.empty && !cache.some((c) => c.fresh)) return cache
        let result = [],
          lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
          let entry = cache[i]
          if (
            entry.dir == lastDir &&
            !changes.touchesRange(entry.from, entry.to)
          )
            result.push(
              new CachedOrder(
                changes.mapPos(entry.from, 1),
                changes.mapPos(entry.to, -1),
                entry.dir,
                entry.isolates,
                false,
                entry.order
              )
            )
        }
        return result
      }
    }
    function attrsFromFacet(view, facet, base) {
      for (
        let sources = view.state.facet(facet), i = sources.length - 1;
        i >= 0;
        i--
      ) {
        let source = sources[i],
          value = typeof source == 'function' ? source(view) : source
        if (value) combineAttrs(value, base)
      }
      return base
    }

    const currentPlatform = browser.mac
      ? 'mac'
      : browser.windows
        ? 'win'
        : browser.linux
          ? 'linux'
          : 'key'
    function normalizeKeyName(name, platform) {
      const parts = name.split(/-(?!$)/)
      let result = parts[parts.length - 1]
      if (result == 'Space') result = ' '
      let alt, ctrl, shift, meta
      for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i]
        if (/^(cmd|meta|m)$/i.test(mod)) meta = true
        else if (/^a(lt)?$/i.test(mod)) alt = true
        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true
        else if (/^s(hift)?$/i.test(mod)) shift = true
        else if (/^mod$/i.test(mod)) {
          if (platform == 'mac') meta = true
          else ctrl = true
        } else throw new Error('Unrecognized modifier name: ' + mod)
      }
      if (alt) result = 'Alt-' + result
      if (ctrl) result = 'Ctrl-' + result
      if (meta) result = 'Meta-' + result
      if (shift) result = 'Shift-' + result
      return result
    }
    function modifiers(name, event, shift) {
      if (event.altKey) name = 'Alt-' + name
      if (event.ctrlKey) name = 'Ctrl-' + name
      if (event.metaKey) name = 'Meta-' + name
      if (shift !== false && event.shiftKey) name = 'Shift-' + name
      return name
    }
    const handleKeyEvents = /*@__PURE__*/ Prec.default(
      /*@__PURE__*/ EditorView.domEventHandlers({
        keydown(event, view) {
          return runHandlers(getKeymap(view.state), event, view, 'editor')
        }
      })
    )
    /**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/
    const dist_keymap = /*@__PURE__*/ Facet.define({ enables: handleKeyEvents })
    const Keymaps = /*@__PURE__*/ new WeakMap()
    // This is hidden behind an indirection, rather than directly computed
    // by the facet, to keep internal types out of the facet's type.
    function getKeymap(state) {
      let bindings = state.facet(dist_keymap)
      let map = Keymaps.get(bindings)
      if (!map)
        Keymaps.set(
          bindings,
          (map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])))
        )
      return map
    }
    /**
Run the key handlers registered for a given scope. The event
object should be a `"keydown"` event. Returns true if any of the
handlers handled it.
*/
    function runScopeHandlers(view, event, scope) {
      return runHandlers(getKeymap(view.state), event, view, scope)
    }
    let storedPrefix = null
    const PrefixTimeout = 4000
    function buildKeymap(bindings, platform = currentPlatform) {
      let bound = Object.create(null)
      let isPrefix = Object.create(null)
      let checkPrefix = (name, is) => {
        let current = isPrefix[name]
        if (current == null) isPrefix[name] = is
        else if (current != is)
          throw new Error(
            'Key binding ' +
              name +
              ' is used both as a regular binding and as a multi-stroke prefix'
          )
      }
      let add = (scope, key, command, preventDefault, stopPropagation) => {
        var _a, _b
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null))
        let parts = key
          .split(/ (?!$)/)
          .map((k) => normalizeKeyName(k, platform))
        for (let i = 1; i < parts.length; i++) {
          let prefix = parts.slice(0, i).join(' ')
          checkPrefix(prefix, true)
          if (!scopeObj[prefix])
            scopeObj[prefix] = {
              preventDefault: true,
              stopPropagation: false,
              run: [
                (view) => {
                  let ourObj = (storedPrefix = { view, prefix, scope })
                  setTimeout(() => {
                    if (storedPrefix == ourObj) storedPrefix = null
                  }, PrefixTimeout)
                  return true
                }
              ]
            }
        }
        let full = parts.join(' ')
        checkPrefix(full, false)
        let binding =
          scopeObj[full] ||
          (scopeObj[full] = {
            preventDefault: false,
            stopPropagation: false,
            run:
              ((_b =
                (_a = scopeObj._any) === null || _a === void 0
                  ? void 0
                  : _a.run) === null || _b === void 0
                ? void 0
                : _b.slice()) || []
          })
        if (command) binding.run.push(command)
        if (preventDefault) binding.preventDefault = true
        if (stopPropagation) binding.stopPropagation = true
      }
      for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(' ') : ['editor']
        if (b.any)
          for (let scope of scopes) {
            let scopeObj = bound[scope] || (bound[scope] = Object.create(null))
            if (!scopeObj._any)
              scopeObj._any = {
                preventDefault: false,
                stopPropagation: false,
                run: []
              }
            for (let key in scopeObj) scopeObj[key].run.push(b.any)
          }
        let name = b[platform] || b.key
        if (!name) continue
        for (let scope of scopes) {
          add(scope, name, b.run, b.preventDefault, b.stopPropagation)
          if (b.shift)
            add(
              scope,
              'Shift-' + name,
              b.shift,
              b.preventDefault,
              b.stopPropagation
            )
        }
      }
      return bound
    }
    function runHandlers(map, event, view, scope) {
      let name = keyName(event)
      let charCode = codePointAt(name, 0),
        isChar = codePointSize(charCode) == name.length && name != ' '
      let prefix = '',
        handled = false,
        prevented = false,
        stopPropagation = false
      if (
        storedPrefix &&
        storedPrefix.view == view &&
        storedPrefix.scope == scope
      ) {
        prefix = storedPrefix.prefix + ' '
        if (modifierCodes.indexOf(event.keyCode) < 0) {
          prevented = true
          storedPrefix = null
        }
      }
      let ran = new Set()
      let runFor = (binding) => {
        if (binding) {
          for (let cmd of binding.run)
            if (!ran.has(cmd)) {
              ran.add(cmd)
              if (cmd(view, event)) {
                if (binding.stopPropagation) stopPropagation = true
                return true
              }
            }
          if (binding.preventDefault) {
            if (binding.stopPropagation) stopPropagation = true
            prevented = true
          }
        }
        return false
      }
      let scopeObj = map[scope],
        baseName,
        shiftName
      if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
          handled = true
        } else if (
          isChar &&
          (event.altKey || event.metaKey || event.ctrlKey) &&
          // Ctrl-Alt may be used for AltGr on Windows
          !(browser.windows && event.ctrlKey && event.altKey) &&
          (baseName = base[event.keyCode]) &&
          baseName != name
        ) {
          if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
            handled = true
          } else if (
            event.shiftKey &&
            (shiftName = shift[event.keyCode]) != name &&
            shiftName != baseName &&
            runFor(scopeObj[prefix + modifiers(shiftName, event, false)])
          ) {
            handled = true
          }
        } else if (
          isChar &&
          event.shiftKey &&
          runFor(scopeObj[prefix + modifiers(name, event, true)])
        ) {
          handled = true
        }
        if (!handled && runFor(scopeObj._any)) handled = true
      }
      if (prevented) handled = true
      if (handled && stopPropagation) event.stopPropagation()
      return handled
    }

    /**
Implementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates
a rectangle at a given set of coordinates.
*/
    class RectangleMarker {
      /**
    Create a marker with the given class and dimensions. If `width`
    is null, the DOM element will get no width style.
    */
      constructor(
        className,
        /**
    The left position of the marker (in pixels, document-relative).
    */
        left,
        /**
    The top position of the marker.
    */
        top,
        /**
    The width of the marker, or null if it shouldn't get a width assigned.
    */
        width,
        /**
    The height of the marker.
    */
        height
      ) {
        this.className = className
        this.left = left
        this.top = top
        this.width = width
        this.height = height
      }
      draw() {
        let elt = document.createElement('div')
        elt.className = this.className
        this.adjust(elt)
        return elt
      }
      update(elt, prev) {
        if (prev.className != this.className) return false
        this.adjust(elt)
        return true
      }
      adjust(elt) {
        elt.style.left = this.left + 'px'
        elt.style.top = this.top + 'px'
        if (this.width != null) elt.style.width = this.width + 'px'
        elt.style.height = this.height + 'px'
      }
      eq(p) {
        return (
          this.left == p.left &&
          this.top == p.top &&
          this.width == p.width &&
          this.height == p.height &&
          this.className == p.className
        )
      }
      /**
    Create a set of rectangles for the given selection range,
    assigning them theclass`className`. Will create a single
    rectangle for empty ranges, and a set of selection-style
    rectangles covering the range's content (in a bidi-aware
    way) for non-empty ones.
    */
      static forRange(view, className, range) {
        if (range.empty) {
          let pos = view.coordsAtPos(range.head, range.assoc || 1)
          if (!pos) return []
          let base = getBase(view)
          return [
            new RectangleMarker(
              className,
              pos.left - base.left,
              pos.top - base.top,
              null,
              pos.bottom - pos.top
            )
          ]
        } else {
          return rectanglesForRange(view, className, range)
        }
      }
    }
    function getBase(view) {
      let rect = view.scrollDOM.getBoundingClientRect()
      let left =
        view.textDirection == Direction.LTR
          ? rect.left
          : rect.right - view.scrollDOM.clientWidth * view.scaleX
      return {
        left: left - view.scrollDOM.scrollLeft * view.scaleX,
        top: rect.top - view.scrollDOM.scrollTop * view.scaleY
      }
    }
    function wrappedLine(view, pos, inside) {
      let range = dist_EditorSelection.cursor(pos)
      return {
        from: Math.max(
          inside.from,
          view.moveToLineBoundary(range, false, true).from
        ),
        to: Math.min(
          inside.to,
          view.moveToLineBoundary(range, true, true).from
        ),
        type: BlockType.Text
      }
    }
    function rectanglesForRange(view, className, range) {
      if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return []
      let from = Math.max(range.from, view.viewport.from),
        to = Math.min(range.to, view.viewport.to)
      let ltr = view.textDirection == Direction.LTR
      let content = view.contentDOM,
        contentRect = content.getBoundingClientRect(),
        base = getBase(view)
      let lineElt = content.querySelector('.cm-line'),
        lineStyle = lineElt && window.getComputedStyle(lineElt)
      let leftSide =
        contentRect.left +
        (lineStyle
          ? parseInt(lineStyle.paddingLeft) +
            Math.min(0, parseInt(lineStyle.textIndent))
          : 0)
      let rightSide =
        contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0)
      let startBlock = blockAt(view, from),
        endBlock = blockAt(view, to)
      let visualStart = startBlock.type == BlockType.Text ? startBlock : null
      let visualEnd = endBlock.type == BlockType.Text ? endBlock : null
      if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
        visualStart = wrappedLine(view, from, visualStart)
      if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
        visualEnd = wrappedLine(view, to, visualEnd)
      if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
        return pieces(drawForLine(range.from, range.to, visualStart))
      } else {
        let top = visualStart
          ? drawForLine(range.from, null, visualStart)
          : drawForWidget(startBlock, false)
        let bottom = visualEnd
          ? drawForLine(null, range.to, visualEnd)
          : drawForWidget(endBlock, true)
        let between = []
        if (
          (visualStart || startBlock).to <
            (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
          (startBlock.widgetLineBreaks > 1 &&
            top.bottom + view.defaultLineHeight / 2 < bottom.top)
        )
          between.push(piece(leftSide, top.bottom, rightSide, bottom.top))
        else if (
          top.bottom < bottom.top &&
          view.elementAtHeight((top.bottom + bottom.top) / 2).type ==
            BlockType.Text
        )
          top.bottom = bottom.top = (top.bottom + bottom.top) / 2
        return pieces(top).concat(between).concat(pieces(bottom))
      }
      function piece(left, top, right, bottom) {
        return new RectangleMarker(
          className,
          left - base.left,
          top - base.top - 0.01 /* C.Epsilon */,
          right - left,
          bottom - top + 0.01 /* C.Epsilon */
        )
      }
      function pieces({ top, bottom, horizontal }) {
        let pieces = []
        for (let i = 0; i < horizontal.length; i += 2)
          pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom))
        return pieces
      }
      // Gets passed from/to in line-local positions
      function drawForLine(from, to, line) {
        let top = 1e9,
          bottom = -1e9,
          horizontal = []
        function addSpan(from, fromOpen, to, toOpen, dir) {
          // Passing 2/-2 is a kludge to force the view to return
          // coordinates on the proper side of block widgets, since
          // normalizing the side there, though appropriate for most
          // coordsAtPos queries, would break selection drawing.
          let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2)
          let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2)
          if (!fromCoords || !toCoords) return
          top = Math.min(fromCoords.top, toCoords.top, top)
          bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom)
          if (dir == Direction.LTR)
            horizontal.push(
              ltr && fromOpen ? leftSide : fromCoords.left,
              ltr && toOpen ? rightSide : toCoords.right
            )
          else
            horizontal.push(
              !ltr && toOpen ? leftSide : toCoords.left,
              !ltr && fromOpen ? rightSide : fromCoords.right
            )
        }
        let start = from !== null && from !== void 0 ? from : line.from,
          end = to !== null && to !== void 0 ? to : line.to
        // Split the range by visible range and document line
        for (let r of view.visibleRanges)
          if (r.to > start && r.from < end) {
            for (
              let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);
              ;

            ) {
              let docLine = view.state.doc.lineAt(pos)
              for (let span of view.bidiSpans(docLine)) {
                let spanFrom = span.from + docLine.from,
                  spanTo = span.to + docLine.from
                if (spanFrom >= endPos) break
                if (spanTo > pos)
                  addSpan(
                    Math.max(spanFrom, pos),
                    from == null && spanFrom <= start,
                    Math.min(spanTo, endPos),
                    to == null && spanTo >= end,
                    span.dir
                  )
              }
              pos = docLine.to + 1
              if (pos >= endPos) break
            }
          }
        if (horizontal.length == 0)
          addSpan(start, from == null, end, to == null, view.textDirection)
        return { top, bottom, horizontal }
      }
      function drawForWidget(block, top) {
        let y = contentRect.top + (top ? block.top : block.bottom)
        return { top: y, bottom: y, horizontal: [] }
      }
    }
    function sameMarker(a, b) {
      return a.constructor == b.constructor && a.eq(b)
    }
    class LayerView {
      constructor(view, layer) {
        this.view = view
        this.layer = layer
        this.drawn = []
        this.scaleX = 1
        this.scaleY = 1
        this.measureReq = {
          read: this.measure.bind(this),
          write: this.draw.bind(this)
        }
        this.dom = view.scrollDOM.appendChild(document.createElement('div'))
        this.dom.classList.add('cm-layer')
        if (layer.above) this.dom.classList.add('cm-layer-above')
        if (layer.class) this.dom.classList.add(layer.class)
        this.scale()
        this.dom.setAttribute('aria-hidden', 'true')
        this.setOrder(view.state)
        view.requestMeasure(this.measureReq)
        if (layer.mount) layer.mount(this.dom, view)
      }
      update(update) {
        if (
          update.startState.facet(layerOrder) != update.state.facet(layerOrder)
        )
          this.setOrder(update.state)
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
          this.scale()
          update.view.requestMeasure(this.measureReq)
        }
      }
      setOrder(state) {
        let pos = 0,
          order = state.facet(layerOrder)
        while (pos < order.length && order[pos] != this.layer) pos++
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos)
      }
      measure() {
        return this.layer.markers(this.view)
      }
      scale() {
        let { scaleX, scaleY } = this.view
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
          this.scaleX = scaleX
          this.scaleY = scaleY
          this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`
        }
      }
      draw(markers) {
        if (
          markers.length != this.drawn.length ||
          markers.some((p, i) => !sameMarker(p, this.drawn[i]))
        ) {
          let old = this.dom.firstChild,
            oldI = 0
          for (let marker of markers) {
            if (
              marker.update &&
              old &&
              marker.constructor &&
              this.drawn[oldI].constructor &&
              marker.update(old, this.drawn[oldI])
            ) {
              old = old.nextSibling
              oldI++
            } else {
              this.dom.insertBefore(marker.draw(), old)
            }
          }
          while (old) {
            let next = old.nextSibling
            old.remove()
            old = next
          }
          this.drawn = markers
        }
      }
      destroy() {
        if (this.layer.destroy) this.layer.destroy(this.dom, this.view)
        this.dom.remove()
      }
    }
    const layerOrder = /*@__PURE__*/ Facet.define()
    /**
Define a layer.
*/
    function dist_layer(config) {
      return [
        dist_ViewPlugin.define((v) => new LayerView(v, config)),
        layerOrder.of(config)
      ]
    }

    const CanHidePrimary = !browser.ios // FIXME test IE
    const selectionConfig = /*@__PURE__*/ Facet.define({
      combine(configs) {
        return combineConfig(
          configs,
          {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
          },
          {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
          }
        )
      }
    })
    /**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/
    function dist_drawSelection(config = {}) {
      return [
        selectionConfig.of(config),
        cursorLayer,
        selectionLayer,
        hideNativeSelection,
        nativeSelectionHidden.of(true)
      ]
    }
    /**
Retrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration
for this state. (Note that this will return a set of defaults even
if `drawSelection` isn't enabled.)
*/
    function getDrawSelectionConfig(state) {
      return state.facet(selectionConfig)
    }
    function configChanged(update) {
      return (
        update.startState.facet(selectionConfig) !=
        update.state.facet(selectionConfig)
      )
    }
    const cursorLayer = /*@__PURE__*/ dist_layer({
      above: true,
      markers(view) {
        let { state } = view,
          conf = state.facet(selectionConfig)
        let cursors = []
        for (let r of state.selection.ranges) {
          let prim = r == state.selection.main
          if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
            let className = prim
              ? 'cm-cursor cm-cursor-primary'
              : 'cm-cursor cm-cursor-secondary'
            let cursor = r.empty
              ? r
              : dist_EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1)
            for (let piece of RectangleMarker.forRange(view, className, cursor))
              cursors.push(piece)
          }
        }
        return cursors
      },
      update(update, dom) {
        if (update.transactions.some((tr) => tr.selection))
          dom.style.animationName =
            dom.style.animationName == 'cm-blink' ? 'cm-blink2' : 'cm-blink'
        let confChange = configChanged(update)
        if (confChange) setBlinkRate(update.state, dom)
        return update.docChanged || update.selectionSet || confChange
      },
      mount(dom, view) {
        setBlinkRate(view.state, dom)
      },
      class: 'cm-cursorLayer'
    })
    function setBlinkRate(state, dom) {
      dom.style.animationDuration =
        state.facet(selectionConfig).cursorBlinkRate + 'ms'
    }
    const selectionLayer = /*@__PURE__*/ dist_layer({
      above: false,
      markers(view) {
        return view.state.selection.ranges
          .map((r) =>
            r.empty
              ? []
              : RectangleMarker.forRange(view, 'cm-selectionBackground', r)
          )
          .reduce((a, b) => a.concat(b))
      },
      update(update, dom) {
        return (
          update.docChanged ||
          update.selectionSet ||
          update.viewportChanged ||
          configChanged(update)
        )
      },
      class: 'cm-selectionLayer'
    })
    const themeSpec = {
      '.cm-line': {
        '& ::selection': { backgroundColor: 'transparent !important' },
        '&::selection': { backgroundColor: 'transparent !important' }
      }
    }
    if (CanHidePrimary) {
      themeSpec['.cm-line'].caretColor = 'transparent !important'
      themeSpec['.cm-content'] = { caretColor: 'transparent !important' }
    }
    const hideNativeSelection = /*@__PURE__*/ Prec.highest(
      /*@__PURE__*/ EditorView.theme(themeSpec)
    )

    const setDropCursorPos = /*@__PURE__*/ StateEffect.define({
      map(pos, mapping) {
        return pos == null ? null : mapping.mapPos(pos)
      }
    })
    const dropCursorPos = /*@__PURE__*/ StateField.define({
      create() {
        return null
      },
      update(pos, tr) {
        if (pos != null) pos = tr.changes.mapPos(pos)
        return tr.effects.reduce(
          (pos, e) => (e.is(setDropCursorPos) ? e.value : pos),
          pos
        )
      }
    })
    const drawDropCursor = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.view = view
          this.cursor = null
          this.measureReq = {
            read: this.readPos.bind(this),
            write: this.drawCursor.bind(this)
          }
        }
        update(update) {
          var _a
          let cursorPos = update.state.field(dropCursorPos)
          if (cursorPos == null) {
            if (this.cursor != null) {
              ;(_a = this.cursor) === null || _a === void 0
                ? void 0
                : _a.remove()
              this.cursor = null
            }
          } else {
            if (!this.cursor) {
              this.cursor = this.view.scrollDOM.appendChild(
                document.createElement('div')
              )
              this.cursor.className = 'cm-dropCursor'
            }
            if (
              update.startState.field(dropCursorPos) != cursorPos ||
              update.docChanged ||
              update.geometryChanged
            )
              this.view.requestMeasure(this.measureReq)
          }
        }
        readPos() {
          let { view } = this
          let pos = view.state.field(dropCursorPos)
          let rect = pos != null && view.coordsAtPos(pos)
          if (!rect) return null
          let outer = view.scrollDOM.getBoundingClientRect()
          return {
            left:
              rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
            height: rect.bottom - rect.top
          }
        }
        drawCursor(pos) {
          if (this.cursor) {
            let { scaleX, scaleY } = this.view
            if (pos) {
              this.cursor.style.left = pos.left / scaleX + 'px'
              this.cursor.style.top = pos.top / scaleY + 'px'
              this.cursor.style.height = pos.height / scaleY + 'px'
            } else {
              this.cursor.style.left = '-100000px'
            }
          }
        }
        destroy() {
          if (this.cursor) this.cursor.remove()
        }
        setDropPos(pos) {
          if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) })
        }
      },
      {
        eventObservers: {
          dragover(event) {
            this.setDropPos(
              this.view.posAtCoords({ x: event.clientX, y: event.clientY })
            )
          },
          dragleave(event) {
            if (
              event.target == this.view.contentDOM ||
              !this.view.contentDOM.contains(event.relatedTarget)
            )
              this.setDropPos(null)
          },
          dragend() {
            this.setDropPos(null)
          },
          drop() {
            this.setDropPos(null)
          }
        }
      }
    )
    /**
Draws a cursor at the current drop position when something is
dragged over the editor.
*/
    function dropCursor() {
      return [dropCursorPos, drawDropCursor]
    }

    function iterMatches(doc, re, from, to, f) {
      re.lastIndex = 0
      for (
        let cursor = doc.iterRange(from, to), pos = from, m;
        !cursor.next().done;
        pos += cursor.value.length
      ) {
        if (!cursor.lineBreak)
          while ((m = re.exec(cursor.value))) f(pos + m.index, m)
      }
    }
    function matchRanges(view, maxLength) {
      let visible = view.visibleRanges
      if (
        visible.length == 1 &&
        visible[0].from == view.viewport.from &&
        visible[0].to == view.viewport.to
      )
        return visible
      let result = []
      for (let { from, to } of visible) {
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength)
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength)
        if (result.length && result[result.length - 1].to >= from)
          result[result.length - 1].to = to
        else result.push({ from, to })
      }
      return result
    }
    /**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/
    class MatchDecorator {
      /**
    Create a decorator.
    */
      constructor(config) {
        const {
          regexp,
          decoration,
          decorate,
          boundary,
          maxLength = 1000
        } = config
        if (!regexp.global)
          throw new RangeError(
            "The regular expression given to MatchDecorator should have its 'g' flag set"
          )
        this.regexp = regexp
        if (decorate) {
          this.addMatch = (match, view, from, add) =>
            decorate(add, from, from + match[0].length, match, view)
        } else if (typeof decoration == 'function') {
          this.addMatch = (match, view, from, add) => {
            let deco = decoration(match, view, from)
            if (deco) add(from, from + match[0].length, deco)
          }
        } else if (decoration) {
          this.addMatch = (match, _view, from, add) =>
            add(from, from + match[0].length, decoration)
        } else {
          throw new RangeError(
            "Either 'decorate' or 'decoration' should be provided to MatchDecorator"
          )
        }
        this.boundary = boundary
        this.maxLength = maxLength
      }
      /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
      createDeco(view) {
        let build = new RangeSetBuilder(),
          add = build.add.bind(build)
        for (let { from, to } of matchRanges(view, this.maxLength))
          iterMatches(view.state.doc, this.regexp, from, to, (from, m) =>
            this.addMatch(m, view, from, add)
          )
        return build.finish()
      }
      /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
      updateDeco(update, deco) {
        let changeFrom = 1e9,
          changeTo = -1
        if (update.docChanged)
          update.changes.iterChanges((_f, _t, from, to) => {
            if (
              to > update.view.viewport.from &&
              from < update.view.viewport.to
            ) {
              changeFrom = Math.min(from, changeFrom)
              changeTo = Math.max(to, changeTo)
            }
          })
        if (update.viewportChanged || changeTo - changeFrom > 1000)
          return this.createDeco(update.view)
        if (changeTo > -1)
          return this.updateRange(
            update.view,
            deco.map(update.changes),
            changeFrom,
            changeTo
          )
        return deco
      }
      updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
          let from = Math.max(r.from, updateFrom),
            to = Math.min(r.to, updateTo)
          if (to > from) {
            let fromLine = view.state.doc.lineAt(from),
              toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine
            let start = Math.max(r.from, fromLine.from),
              end = Math.min(r.to, toLine.to)
            if (this.boundary) {
              for (; from > fromLine.from; from--)
                if (
                  this.boundary.test(fromLine.text[from - 1 - fromLine.from])
                ) {
                  start = from
                  break
                }
              for (; to < toLine.to; to++)
                if (this.boundary.test(toLine.text[to - toLine.from])) {
                  end = to
                  break
                }
            }
            let ranges = [],
              m
            let add = (from, to, deco) => ranges.push(deco.range(from, to))
            if (fromLine == toLine) {
              this.regexp.lastIndex = start - fromLine.from
              while (
                (m = this.regexp.exec(fromLine.text)) &&
                m.index < end - fromLine.from
              )
                this.addMatch(m, view, m.index + fromLine.from, add)
            } else {
              iterMatches(view.state.doc, this.regexp, start, end, (from, m) =>
                this.addMatch(m, view, from, add)
              )
            }
            deco = deco.update({
              filterFrom: start,
              filterTo: end,
              filter: (from, to) => from < start || to > end,
              add: ranges
            })
          }
        }
        return deco
      }
    }

    const UnicodeRegexpSupport = /x/.unicode != null ? 'gu' : 'g'
    const Specials = /*@__PURE__*/ new RegExp(
      '[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]',
      UnicodeRegexpSupport
    )
    const Names = {
      0: 'null',
      7: 'bell',
      8: 'backspace',
      10: 'newline',
      11: 'vertical tab',
      13: 'carriage return',
      27: 'escape',
      8203: 'zero width space',
      8204: 'zero width non-joiner',
      8205: 'zero width joiner',
      8206: 'left-to-right mark',
      8207: 'right-to-left mark',
      8232: 'line separator',
      8237: 'left-to-right override',
      8238: 'right-to-left override',
      8294: 'left-to-right isolate',
      8295: 'right-to-left isolate',
      8297: 'pop directional isolate',
      8233: 'paragraph separator',
      65279: 'zero width no-break space',
      65532: 'object replacement'
    }
    let _supportsTabSize = null
    function supportsTabSize() {
      var _a
      if (
        _supportsTabSize == null &&
        typeof document != 'undefined' &&
        document.body
      ) {
        let styles = document.body.style
        _supportsTabSize =
          ((_a = styles.tabSize) !== null && _a !== void 0
            ? _a
            : styles.MozTabSize) != null
      }
      return _supportsTabSize || false
    }
    const specialCharConfig = /*@__PURE__*/ Facet.define({
      combine(configs) {
        let config = combineConfig(configs, {
          render: null,
          specialChars: Specials,
          addSpecialChars: null
        })
        if ((config.replaceTabs = !supportsTabSize()))
          config.specialChars = new RegExp(
            '\t|' + config.specialChars.source,
            UnicodeRegexpSupport
          )
        if (config.addSpecialChars)
          config.specialChars = new RegExp(
            config.specialChars.source + '|' + config.addSpecialChars.source,
            UnicodeRegexpSupport
          )
        return config
      }
    })
    /**
Returns an extension that installs highlighting of special
characters.
*/
    function dist_highlightSpecialChars(
      /**
Configuration options.
*/
      config = {}
    ) {
      return [specialCharConfig.of(config), specialCharPlugin()]
    }
    let _plugin = null
    function specialCharPlugin() {
      return (
        _plugin ||
        (_plugin = dist_ViewPlugin.fromClass(
          class {
            constructor(view) {
              this.view = view
              this.decorations = Decoration.none
              this.decorationCache = Object.create(null)
              this.decorator = this.makeDecorator(
                view.state.facet(specialCharConfig)
              )
              this.decorations = this.decorator.createDeco(view)
            }
            makeDecorator(conf) {
              return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                  let { doc } = view.state
                  let code = codePointAt(m[0], 0)
                  if (code == 9) {
                    let line = doc.lineAt(pos)
                    let size = view.state.tabSize,
                      col = countColumn(line.text, size, pos - line.from)
                    return Decoration.replace({
                      widget: new TabWidget(
                        ((size - (col % size)) *
                          this.view.defaultCharacterWidth) /
                          this.view.scaleX
                      )
                    })
                  }
                  return (
                    this.decorationCache[code] ||
                    (this.decorationCache[code] = Decoration.replace({
                      widget: new SpecialCharWidget(conf, code)
                    }))
                  )
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
              })
            }
            update(update) {
              let conf = update.state.facet(specialCharConfig)
              if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf)
                this.decorations = this.decorator.createDeco(update.view)
              } else {
                this.decorations = this.decorator.updateDeco(
                  update,
                  this.decorations
                )
              }
            }
          },
          {
            decorations: (v) => v.decorations
          }
        ))
      )
    }
    const DefaultPlaceholder = '\u2022'
    // Assigns placeholder characters from the Control Pictures block to
    // ASCII control characters
    function placeholder$1(code) {
      if (code >= 32) return DefaultPlaceholder
      if (code == 10) return '\u2424'
      return String.fromCharCode(9216 + code)
    }
    class SpecialCharWidget extends WidgetType {
      constructor(options, code) {
        super()
        this.options = options
        this.code = code
      }
      eq(other) {
        return other.code == this.code
      }
      toDOM(view) {
        let ph = placeholder$1(this.code)
        let desc =
          view.state.phrase('Control character') +
          ' ' +
          (Names[this.code] || '0x' + this.code.toString(16))
        let custom =
          this.options.render && this.options.render(this.code, desc, ph)
        if (custom) return custom
        let span = document.createElement('span')
        span.textContent = ph
        span.title = desc
        span.setAttribute('aria-label', desc)
        span.className = 'cm-specialChar'
        return span
      }
      ignoreEvent() {
        return false
      }
    }
    class TabWidget extends WidgetType {
      constructor(width) {
        super()
        this.width = width
      }
      eq(other) {
        return other.width == this.width
      }
      toDOM() {
        let span = document.createElement('span')
        span.textContent = '\t'
        span.className = 'cm-tab'
        span.style.width = this.width + 'px'
        return span
      }
      ignoreEvent() {
        return false
      }
    }

    const dist_plugin =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      dist_ViewPlugin.fromClass(
        class {
          constructor() {
            this.height = 1000
            this.attrs = { style: 'padding-bottom: 1000px' }
          }
          update(update) {
            let { view } = update
            let height =
              view.viewState.editorHeight * view.scaleY -
              view.defaultLineHeight -
              view.documentPadding.top -
              0.5
            if (height >= 0 && height != this.height) {
              this.height = height
              this.attrs = { style: `padding-bottom: ${height}px` }
            }
          }
        }
      )
    /**
Returns an extension that makes sure the content has a bottom
margin equivalent to the height of the editor, minus one line
height, so that every line in the document can be scrolled to the
top of the editor.

This is only meaningful when the editor is scrollable, and should
not be enabled in editors that take the size of their content.
*/
    function scrollPastEnd() {
      return [
        dist_plugin,
        contentAttributes.of((view) => {
          var _a
          return (
            ((_a = view.plugin(dist_plugin)) === null || _a === void 0
              ? void 0
              : _a.attrs) || null
          )
        })
      ]
    }

    /**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/
    function highlightActiveLine() {
      return activeLineHighlighter
    }
    const lineDeco = /*@__PURE__*/ Decoration.line({ class: 'cm-activeLine' })
    const activeLineHighlighter = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.decorations = this.getDeco(view)
        }
        update(update) {
          if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view)
        }
        getDeco(view) {
          let lastLineStart = -1,
            deco = []
          for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head)
            if (line.from > lastLineStart) {
              deco.push(lineDeco.range(line.from))
              lastLineStart = line.from
            }
          }
          return Decoration.set(deco)
        }
      },
      {
        decorations: (v) => v.decorations
      }
    )

    class Placeholder
      extends /* unused pure expression or super */ (null && WidgetType)
    {
      constructor(content) {
        super()
        this.content = content
      }
      toDOM() {
        let wrap = document.createElement('span')
        wrap.className = 'cm-placeholder'
        wrap.style.pointerEvents = 'none'
        wrap.appendChild(
          typeof this.content == 'string'
            ? document.createTextNode(this.content)
            : this.content
        )
        if (typeof this.content == 'string')
          wrap.setAttribute('aria-label', 'placeholder ' + this.content)
        else wrap.setAttribute('aria-hidden', 'true')
        return wrap
      }
      coordsAt(dom) {
        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : []
        if (!rects.length) return null
        let style = window.getComputedStyle(dom.parentNode)
        let rect = flattenRect(rects[0], style.direction != 'rtl')
        let lineHeight = parseInt(style.lineHeight)
        if (rect.bottom - rect.top > lineHeight * 1.5)
          return {
            left: rect.left,
            right: rect.right,
            top: rect.top,
            bottom: rect.top + lineHeight
          }
        return rect
      }
      ignoreEvent() {
        return false
      }
    }
    /**
Extension that enables a placeholder—a piece of example content
to show when the editor is empty.
*/
    function placeholder(content) {
      return dist_ViewPlugin.fromClass(
        class {
          constructor(view) {
            this.view = view
            this.placeholder = content
              ? Decoration.set([
                  Decoration.widget({
                    widget: new Placeholder(content),
                    side: 1
                  }).range(0)
                ])
              : Decoration.none
          }
          get decorations() {
            return this.view.state.doc.length
              ? Decoration.none
              : this.placeholder
          }
        },
        { decorations: (v) => v.decorations }
      )
    }

    // Don't compute precise column positions for line offsets above this
    // (since it could get expensive). Assume offset==column for them.
    const MaxOff = 2000
    function rectangleFor(state, a, b) {
      let startLine = Math.min(a.line, b.line),
        endLine = Math.max(a.line, b.line)
      let ranges = []
      if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off),
          endOff = Math.max(a.off, b.off)
        for (let i = startLine; i <= endLine; i++) {
          let line = state.doc.line(i)
          if (line.length <= endOff)
            ranges.push(
              dist_EditorSelection.range(line.from + startOff, line.to + endOff)
            )
        }
      } else {
        let startCol = Math.min(a.col, b.col),
          endCol = Math.max(a.col, b.col)
        for (let i = startLine; i <= endLine; i++) {
          let line = state.doc.line(i)
          let start = findColumn(line.text, startCol, state.tabSize, true)
          if (start < 0) {
            ranges.push(dist_EditorSelection.cursor(line.to))
          } else {
            let end = findColumn(line.text, endCol, state.tabSize)
            ranges.push(
              dist_EditorSelection.range(line.from + start, line.from + end)
            )
          }
        }
      }
      return ranges
    }
    function absoluteColumn(view, x) {
      let ref = view.coordsAtPos(view.viewport.from)
      return ref
        ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth))
        : -1
    }
    function getPos(view, event) {
      let offset = view.posAtCoords(
        { x: event.clientX, y: event.clientY },
        false
      )
      let line = view.state.doc.lineAt(offset),
        off = offset - line.from
      let col =
        off > MaxOff
          ? -1
          : off == line.length
            ? absoluteColumn(view, event.clientX)
            : countColumn(line.text, view.state.tabSize, offset - line.from)
      return { line: line.number, col, off }
    }
    function rectangleSelectionStyle(view, event) {
      let start = getPos(view, event),
        startSel = view.state.selection
      if (!start) return null
      return {
        update(update) {
          if (update.docChanged) {
            let newStart = update.changes.mapPos(
              update.startState.doc.line(start.line).from
            )
            let newLine = update.state.doc.lineAt(newStart)
            start = {
              line: newLine.number,
              col: start.col,
              off: Math.min(start.off, newLine.length)
            }
            startSel = startSel.map(update.changes)
          }
        },
        get(event, _extend, multiple) {
          let cur = getPos(view, event)
          if (!cur) return startSel
          let ranges = rectangleFor(view.state, start, cur)
          if (!ranges.length) return startSel
          if (multiple)
            return dist_EditorSelection.create(ranges.concat(startSel.ranges))
          else return dist_EditorSelection.create(ranges)
        }
      }
    }
    /**
Create an extension that enables rectangular selections. By
default, it will react to left mouse drag with the Alt key held
down. When such a selection occurs, the text within the rectangle
that was dragged over will be selected, as one selection
[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
*/
    function rectangularSelection(options) {
      let filter =
        (options === null || options === void 0
          ? void 0
          : options.eventFilter) || ((e) => e.altKey && e.button == 0)
      return EditorView.mouseSelectionStyle.of((view, event) =>
        filter(event) ? rectangleSelectionStyle(view, event) : null
      )
    }
    const keys = {
      Alt: [18, (e) => !!e.altKey],
      Control: [17, (e) => !!e.ctrlKey],
      Shift: [16, (e) => !!e.shiftKey],
      Meta: [91, (e) => !!e.metaKey]
    }
    const showCrosshair = { style: 'cursor: crosshair' }
    /**
Returns an extension that turns the pointer cursor into a
crosshair when a given modifier key, defaulting to Alt, is held
down. Can serve as a visual hint that rectangular selection is
going to happen when paired with
[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).
*/
    function crosshairCursor(options = {}) {
      let [code, getter] = keys[options.key || 'Alt']
      let plugin = dist_ViewPlugin.fromClass(
        class {
          constructor(view) {
            this.view = view
            this.isDown = false
          }
          set(isDown) {
            if (this.isDown != isDown) {
              this.isDown = isDown
              this.view.update([])
            }
          }
        },
        {
          eventObservers: {
            keydown(e) {
              this.set(e.keyCode == code || getter(e))
            },
            keyup(e) {
              if (e.keyCode == code || !getter(e)) this.set(false)
            },
            mousemove(e) {
              this.set(getter(e))
            }
          }
        }
      )
      return [
        plugin,
        EditorView.contentAttributes.of((view) => {
          var _a
          return (
            (_a = view.plugin(plugin)) === null || _a === void 0
              ? void 0
              : _a.isDown
          )
            ? showCrosshair
            : null
        })
      ]
    }

    const Outside = '-10000px'
    class TooltipViewManager {
      constructor(view, facet, createTooltipView) {
        this.facet = facet
        this.createTooltipView = createTooltipView
        this.input = view.state.facet(facet)
        this.tooltips = this.input.filter((t) => t)
        this.tooltipViews = this.tooltips.map(createTooltipView)
      }
      update(update, above) {
        var _a
        let input = update.state.facet(this.facet)
        let tooltips = input.filter((x) => x)
        if (input === this.input) {
          for (let t of this.tooltipViews) if (t.update) t.update(update)
          return false
        }
        let tooltipViews = [],
          newAbove = above ? [] : null
        for (let i = 0; i < tooltips.length; i++) {
          let tip = tooltips[i],
            known = -1
          if (!tip) continue
          for (let i = 0; i < this.tooltips.length; i++) {
            let other = this.tooltips[i]
            if (other && other.create == tip.create) known = i
          }
          if (known < 0) {
            tooltipViews[i] = this.createTooltipView(tip)
            if (newAbove) newAbove[i] = !!tip.above
          } else {
            let tooltipView = (tooltipViews[i] = this.tooltipViews[known])
            if (newAbove) newAbove[i] = above[known]
            if (tooltipView.update) tooltipView.update(update)
          }
        }
        for (let t of this.tooltipViews)
          if (tooltipViews.indexOf(t) < 0) {
            t.dom.remove()
            ;(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t)
          }
        if (above) {
          newAbove.forEach((val, i) => (above[i] = val))
          above.length = newAbove.length
        }
        this.input = input
        this.tooltips = tooltips
        this.tooltipViews = tooltipViews
        return true
      }
    }
    /**
Creates an extension that configures tooltip behavior.
*/
    function tooltips(config = {}) {
      return tooltipConfig.of(config)
    }
    function windowSpace(view) {
      let { win } = view
      return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth }
    }
    const tooltipConfig = /*@__PURE__*/ Facet.define({
      combine: (values) => {
        var _a, _b, _c
        return {
          position: browser.ios
            ? 'absolute'
            : ((_a = values.find((conf) => conf.position)) === null ||
              _a === void 0
                ? void 0
                : _a.position) || 'fixed',
          parent:
            ((_b = values.find((conf) => conf.parent)) === null || _b === void 0
              ? void 0
              : _b.parent) || null,
          tooltipSpace:
            ((_c = values.find((conf) => conf.tooltipSpace)) === null ||
            _c === void 0
              ? void 0
              : _c.tooltipSpace) || windowSpace
        }
      }
    })
    const knownHeight = /*@__PURE__*/ new WeakMap()
    const tooltipPlugin = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.view = view
          this.above = []
          this.inView = true
          this.madeAbsolute = false
          this.lastTransaction = 0
          this.measureTimeout = -1
          let config = view.state.facet(tooltipConfig)
          this.position = config.position
          this.parent = config.parent
          this.classes = view.themeClasses
          this.createContainer()
          this.measureReq = {
            read: this.readMeasure.bind(this),
            write: this.writeMeasure.bind(this),
            key: this
          }
          this.manager = new TooltipViewManager(view, showTooltip, (t) =>
            this.createTooltip(t)
          )
          this.intersectionObserver =
            typeof IntersectionObserver == 'function'
              ? new IntersectionObserver(
                  (entries) => {
                    if (
                      Date.now() > this.lastTransaction - 50 &&
                      entries.length > 0 &&
                      entries[entries.length - 1].intersectionRatio < 1
                    )
                      this.measureSoon()
                  },
                  { threshold: [1] }
                )
              : null
          this.observeIntersection()
          view.win.addEventListener(
            'resize',
            (this.measureSoon = this.measureSoon.bind(this))
          )
          this.maybeMeasure()
        }
        createContainer() {
          if (this.parent) {
            this.container = document.createElement('div')
            this.container.style.position = 'relative'
            this.container.className = this.view.themeClasses
            this.parent.appendChild(this.container)
          } else {
            this.container = this.view.dom
          }
        }
        observeIntersection() {
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect()
            for (let tooltip of this.manager.tooltipViews)
              this.intersectionObserver.observe(tooltip.dom)
          }
        }
        measureSoon() {
          if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
              this.measureTimeout = -1
              this.maybeMeasure()
            }, 50)
        }
        update(update) {
          if (update.transactions.length) this.lastTransaction = Date.now()
          let updated = this.manager.update(update, this.above)
          if (updated) this.observeIntersection()
          let shouldMeasure = updated || update.geometryChanged
          let newConfig = update.state.facet(tooltipConfig)
          if (newConfig.position != this.position && !this.madeAbsolute) {
            this.position = newConfig.position
            for (let t of this.manager.tooltipViews)
              t.dom.style.position = this.position
            shouldMeasure = true
          }
          if (newConfig.parent != this.parent) {
            if (this.parent) this.container.remove()
            this.parent = newConfig.parent
            this.createContainer()
            for (let t of this.manager.tooltipViews)
              this.container.appendChild(t.dom)
            shouldMeasure = true
          } else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses
          }
          if (shouldMeasure) this.maybeMeasure()
        }
        createTooltip(tooltip) {
          let tooltipView = tooltip.create(this.view)
          tooltipView.dom.classList.add('cm-tooltip')
          if (
            tooltip.arrow &&
            !tooltipView.dom.querySelector('.cm-tooltip > .cm-tooltip-arrow')
          ) {
            let arrow = document.createElement('div')
            arrow.className = 'cm-tooltip-arrow'
            tooltipView.dom.appendChild(arrow)
          }
          tooltipView.dom.style.position = this.position
          tooltipView.dom.style.top = Outside
          tooltipView.dom.style.left = '0px'
          this.container.appendChild(tooltipView.dom)
          if (tooltipView.mount) tooltipView.mount(this.view)
          return tooltipView
        }
        destroy() {
          var _a, _b
          this.view.win.removeEventListener('resize', this.measureSoon)
          for (let tooltipView of this.manager.tooltipViews) {
            tooltipView.dom.remove()
            ;(_a = tooltipView.destroy) === null || _a === void 0
              ? void 0
              : _a.call(tooltipView)
          }
          if (this.parent) this.container.remove()
          ;(_b = this.intersectionObserver) === null || _b === void 0
            ? void 0
            : _b.disconnect()
          clearTimeout(this.measureTimeout)
        }
        readMeasure() {
          let editor = this.view.dom.getBoundingClientRect()
          let scaleX = 1,
            scaleY = 1,
            makeAbsolute = false
          if (this.position == 'fixed' && this.manager.tooltipViews.length) {
            let { dom } = this.manager.tooltipViews[0]
            if (browser.gecko) {
              // Firefox sets the element's `offsetParent` to the
              // transformed element when a transform interferes with fixed
              // positioning.
              makeAbsolute =
                dom.offsetParent != this.container.ownerDocument.body
            } else {
              // On other browsers, we have to awkwardly try and use other
              // information to detect a transform.
              if (this.view.scaleX != 1 || this.view.scaleY != 1) {
                makeAbsolute = true
              } else if (dom.style.top == Outside && dom.style.left == '0px') {
                let rect = dom.getBoundingClientRect()
                makeAbsolute =
                  Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1
              }
            }
          }
          if (makeAbsolute || this.position == 'absolute') {
            if (this.parent) {
              let rect = this.parent.getBoundingClientRect()
              if (rect.width && rect.height) {
                scaleX = rect.width / this.parent.offsetWidth
                scaleY = rect.height / this.parent.offsetHeight
              }
            } else {
              ;({ scaleX, scaleY } = this.view.viewState)
            }
          }
          return {
            editor,
            parent: this.parent
              ? this.container.getBoundingClientRect()
              : editor,
            pos: this.manager.tooltips.map((t, i) => {
              let tv = this.manager.tooltipViews[i]
              return tv.getCoords
                ? tv.getCoords(t.pos)
                : this.view.coordsAtPos(t.pos)
            }),
            size: this.manager.tooltipViews.map(({ dom }) =>
              dom.getBoundingClientRect()
            ),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
            scaleX,
            scaleY,
            makeAbsolute
          }
        }
        writeMeasure(measured) {
          var _a
          if (measured.makeAbsolute) {
            this.madeAbsolute = true
            this.position = 'absolute'
            for (let t of this.manager.tooltipViews)
              t.dom.style.position = 'absolute'
          }
          let { editor, space, scaleX, scaleY } = measured
          let others = []
          for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i],
              tView = this.manager.tooltipViews[i],
              { dom } = tView
            let pos = measured.pos[i],
              size = measured.size[i]
            // Hide tooltips that are outside of the editor.
            if (
              !pos ||
              pos.bottom <= Math.max(editor.top, space.top) ||
              pos.top >= Math.min(editor.bottom, space.bottom) ||
              pos.right < Math.max(editor.left, space.left) - 0.1 ||
              pos.left > Math.min(editor.right, space.right) + 0.1
            ) {
              dom.style.top = Outside
              continue
            }
            let arrow = tooltip.arrow
              ? tView.dom.querySelector('.cm-tooltip-arrow')
              : null
            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0
            let width = size.right - size.left,
              height =
                (_a = knownHeight.get(tView)) !== null && _a !== void 0
                  ? _a
                  : size.bottom - size.top
            let offset = tView.offset || noOffset,
              ltr = this.view.textDirection == Direction.LTR
            let left =
              size.width > space.right - space.left
                ? ltr
                  ? space.left
                  : space.right - size.width
                : ltr
                  ? Math.min(
                      pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x,
                      space.right - width
                    )
                  : Math.max(
                      space.left,
                      pos.left -
                        width +
                        (arrow ? 14 /* Arrow.Offset */ : 0) -
                        offset.x
                    )
            let above = this.above[i]
            if (
              !tooltip.strictSide &&
              (above
                ? pos.top - (size.bottom - size.top) - offset.y < space.top
                : pos.bottom + (size.bottom - size.top) + offset.y >
                  space.bottom) &&
              above == space.bottom - pos.bottom > pos.top - space.top
            )
              above = this.above[i] = !above
            let spaceVert =
              (above ? pos.top - space.top : space.bottom - pos.bottom) -
              arrowHeight
            if (spaceVert < height && tView.resize !== false) {
              if (spaceVert < this.view.defaultLineHeight) {
                dom.style.top = Outside
                continue
              }
              knownHeight.set(tView, height)
              dom.style.height = (height = spaceVert) / scaleY + 'px'
            } else if (dom.style.height) {
              dom.style.height = ''
            }
            let top = above
              ? pos.top - height - arrowHeight - offset.y
              : pos.bottom + arrowHeight + offset.y
            let right = left + width
            if (tView.overlap !== true)
              for (let r of others)
                if (
                  r.left < right &&
                  r.right > left &&
                  r.top < top + height &&
                  r.bottom > top
                )
                  top = above
                    ? r.top - height - 2 - arrowHeight
                    : r.bottom + arrowHeight + 2
            if (this.position == 'absolute') {
              dom.style.top = (top - measured.parent.top) / scaleY + 'px'
              dom.style.left = (left - measured.parent.left) / scaleX + 'px'
            } else {
              dom.style.top = top / scaleY + 'px'
              dom.style.left = left / scaleX + 'px'
            }
            if (arrow) {
              let arrowLeft =
                pos.left +
                (ltr ? offset.x : -offset.x) -
                (left + 14 /* Arrow.Offset */ - 7) /* Arrow.Size */
              arrow.style.left = arrowLeft / scaleX + 'px'
            }
            if (tView.overlap !== true)
              others.push({ left, top, right, bottom: top + height })
            dom.classList.toggle('cm-tooltip-above', above)
            dom.classList.toggle('cm-tooltip-below', !above)
            if (tView.positioned) tView.positioned(measured.space)
          }
        }
        maybeMeasure() {
          if (this.manager.tooltips.length) {
            if (this.view.inView) this.view.requestMeasure(this.measureReq)
            if (this.inView != this.view.inView) {
              this.inView = this.view.inView
              if (!this.inView)
                for (let tv of this.manager.tooltipViews)
                  tv.dom.style.top = Outside
            }
          }
        }
      },
      {
        eventObservers: {
          scroll() {
            this.maybeMeasure()
          }
        }
      }
    )
    const baseTheme = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-tooltip': {
        zIndex: 100,
        boxSizing: 'border-box'
      },
      '&light .cm-tooltip': {
        border: '1px solid #bbb',
        backgroundColor: '#f5f5f5'
      },
      '&light .cm-tooltip-section:not(:first-child)': {
        borderTop: '1px solid #bbb'
      },
      '&dark .cm-tooltip': {
        backgroundColor: '#333338',
        color: 'white'
      },
      '.cm-tooltip-arrow': {
        height: `${7 /* Arrow.Size */}px`,
        width: `${7 /* Arrow.Size */ * 2}px`,
        position: 'absolute',
        zIndex: -1,
        overflow: 'hidden',
        '&:before, &:after': {
          content: "''",
          position: 'absolute',
          width: 0,
          height: 0,
          borderLeft: `${7 /* Arrow.Size */}px solid transparent`,
          borderRight: `${7 /* Arrow.Size */}px solid transparent`
        },
        '.cm-tooltip-above &': {
          bottom: `-${7 /* Arrow.Size */}px`,
          '&:before': {
            borderTop: `${7 /* Arrow.Size */}px solid #bbb`
          },
          '&:after': {
            borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,
            bottom: '1px'
          }
        },
        '.cm-tooltip-below &': {
          top: `-${7 /* Arrow.Size */}px`,
          '&:before': {
            borderBottom: `${7 /* Arrow.Size */}px solid #bbb`
          },
          '&:after': {
            borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,
            top: '1px'
          }
        }
      },
      '&dark .cm-tooltip .cm-tooltip-arrow': {
        '&:before': {
          borderTopColor: '#333338',
          borderBottomColor: '#333338'
        },
        '&:after': {
          borderTopColor: 'transparent',
          borderBottomColor: 'transparent'
        }
      }
    })
    const noOffset = { x: 0, y: 0 }
    /**
Facet to which an extension can add a value to show a tooltip.
*/
    const showTooltip = /*@__PURE__*/ Facet.define({
      enables: [tooltipPlugin, baseTheme]
    })
    const showHoverTooltip = /*@__PURE__*/ Facet.define()
    class HoverTooltipHost {
      // Needs to be static so that host tooltip instances always match
      static create(view) {
        return new HoverTooltipHost(view)
      }
      constructor(view) {
        this.view = view
        this.mounted = false
        this.dom = document.createElement('div')
        this.dom.classList.add('cm-tooltip-hover')
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t) =>
          this.createHostedView(t)
        )
      }
      createHostedView(tooltip) {
        let hostedView = tooltip.create(this.view)
        hostedView.dom.classList.add('cm-tooltip-section')
        this.dom.appendChild(hostedView.dom)
        if (this.mounted && hostedView.mount) hostedView.mount(this.view)
        return hostedView
      }
      mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
          if (hostedView.mount) hostedView.mount(view)
        }
        this.mounted = true
      }
      positioned(space) {
        for (let hostedView of this.manager.tooltipViews) {
          if (hostedView.positioned) hostedView.positioned(space)
        }
      }
      update(update) {
        this.manager.update(update)
      }
      destroy() {
        var _a
        for (let t of this.manager.tooltipViews)
          (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t)
      }
      passProp(name) {
        let value = undefined
        for (let view of this.manager.tooltipViews) {
          let given = view[name]
          if (given !== undefined) {
            if (value === undefined) value = given
            else if (value !== given) return undefined
          }
        }
        return value
      }
      get offset() {
        return this.passProp('offset')
      }
      get getCoords() {
        return this.passProp('getCoords')
      }
      get overlap() {
        return this.passProp('overlap')
      }
      get resize() {
        return this.passProp('resize')
      }
    }
    const showHoverTooltipHost = /*@__PURE__*/ showTooltip.compute(
      [showHoverTooltip],
      (state) => {
        let tooltips = state.facet(showHoverTooltip).filter((t) => t)
        if (tooltips.length === 0) return null
        return {
          pos: Math.min(...tooltips.map((t) => t.pos)),
          end: Math.max(
            ...tooltips.map((t) => {
              var _a
              return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos
            })
          ),
          create: HoverTooltipHost.create,
          above: tooltips[0].above,
          arrow: tooltips.some((t) => t.arrow)
        }
      }
    )
    class HoverPlugin {
      constructor(view, source, field, setHover, hoverTime) {
        this.view = view
        this.source = source
        this.field = field
        this.setHover = setHover
        this.hoverTime = hoverTime
        this.hoverTimeout = -1
        this.restartTimeout = -1
        this.pending = null
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 }
        this.checkHover = this.checkHover.bind(this)
        view.dom.addEventListener(
          'mouseleave',
          (this.mouseleave = this.mouseleave.bind(this))
        )
        view.dom.addEventListener(
          'mousemove',
          (this.mousemove = this.mousemove.bind(this))
        )
      }
      update() {
        if (this.pending) {
          this.pending = null
          clearTimeout(this.restartTimeout)
          this.restartTimeout = setTimeout(() => this.startHover(), 20)
        }
      }
      get active() {
        return this.view.state.field(this.field)
      }
      checkHover() {
        this.hoverTimeout = -1
        if (this.active) return
        let hovered = Date.now() - this.lastMove.time
        if (hovered < this.hoverTime)
          this.hoverTimeout = setTimeout(
            this.checkHover,
            this.hoverTime - hovered
          )
        else this.startHover()
      }
      startHover() {
        clearTimeout(this.restartTimeout)
        let { view, lastMove } = this
        let desc = view.docView.nearest(lastMove.target)
        if (!desc) return
        let pos,
          side = 1
        if (desc instanceof WidgetView) {
          pos = desc.posAtStart
        } else {
          pos = view.posAtCoords(lastMove)
          if (pos == null) return
          let posCoords = view.coordsAtPos(pos)
          if (
            !posCoords ||
            lastMove.y < posCoords.top ||
            lastMove.y > posCoords.bottom ||
            lastMove.x < posCoords.left - view.defaultCharacterWidth ||
            lastMove.x > posCoords.right + view.defaultCharacterWidth
          )
            return
          let bidi = view
            .bidiSpans(view.state.doc.lineAt(pos))
            .find((s) => s.from <= pos && s.to >= pos)
          let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1
          side = lastMove.x < posCoords.left ? -rtl : rtl
        }
        let open = this.source(view, pos, side)
        if (open === null || open === void 0 ? void 0 : open.then) {
          let pending = (this.pending = { pos })
          open.then(
            (result) => {
              if (this.pending == pending) {
                this.pending = null
                if (result) view.dispatch({ effects: this.setHover.of(result) })
              }
            },
            (e) => dist_logException(view.state, e, 'hover tooltip')
          )
        } else if (open) {
          view.dispatch({ effects: this.setHover.of(open) })
        }
      }
      get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin)
        let index = plugin
          ? plugin.manager.tooltips.findIndex(
              (t) => t.create == HoverTooltipHost.create
            )
          : -1
        return index > -1 ? plugin.manager.tooltipViews[index] : null
      }
      mousemove(event) {
        var _a
        this.lastMove = {
          x: event.clientX,
          y: event.clientY,
          target: event.target,
          time: Date.now()
        }
        if (this.hoverTimeout < 0)
          this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime)
        let { active, tooltip } = this
        if (
          (active && tooltip && !isInTooltip(tooltip.dom, event)) ||
          this.pending
        ) {
          let { pos } = active || this.pending,
            end =
              (_a =
                active === null || active === void 0 ? void 0 : active.end) !==
                null && _a !== void 0
                ? _a
                : pos
          if (
            pos == end
              ? this.view.posAtCoords(this.lastMove) != pos
              : !isOverRange(this.view, pos, end, event.clientX, event.clientY)
          ) {
            this.view.dispatch({ effects: this.setHover.of(null) })
            this.pending = null
          }
        }
      }
      mouseleave(event) {
        clearTimeout(this.hoverTimeout)
        this.hoverTimeout = -1
        let { active } = this
        if (active) {
          let { tooltip } = this
          let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget)
          if (!inTooltip)
            this.view.dispatch({ effects: this.setHover.of(null) })
          else this.watchTooltipLeave(tooltip.dom)
        }
      }
      watchTooltipLeave(tooltip) {
        let watch = (event) => {
          tooltip.removeEventListener('mouseleave', watch)
          if (this.active && !this.view.dom.contains(event.relatedTarget))
            this.view.dispatch({ effects: this.setHover.of(null) })
        }
        tooltip.addEventListener('mouseleave', watch)
      }
      destroy() {
        clearTimeout(this.hoverTimeout)
        this.view.dom.removeEventListener('mouseleave', this.mouseleave)
        this.view.dom.removeEventListener('mousemove', this.mousemove)
      }
    }
    const tooltipMargin = 4
    function isInTooltip(tooltip, event) {
      let rect = tooltip.getBoundingClientRect()
      return (
        event.clientX >= rect.left - tooltipMargin &&
        event.clientX <= rect.right + tooltipMargin &&
        event.clientY >= rect.top - tooltipMargin &&
        event.clientY <= rect.bottom + tooltipMargin
      )
    }
    function isOverRange(view, from, to, x, y, margin) {
      let rect = view.scrollDOM.getBoundingClientRect()
      let docBottom =
        view.documentTop + view.documentPadding.top + view.contentHeight
      if (
        rect.left > x ||
        rect.right < x ||
        rect.top > y ||
        Math.min(rect.bottom, docBottom) < y
      )
        return false
      let pos = view.posAtCoords({ x, y }, false)
      return pos >= from && pos <= to
    }
    /**
Set up a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos`, return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer is—it will be -1 if the
pointer is before the position, 1 if after the position.

Note that all hover tooltips are hosted within a single tooltip
container element. This allows multiple tooltips over the same
range to be "merged" together without overlapping.
*/
    function hoverTooltip(source, options = {}) {
      let setHover = StateEffect.define()
      let hoverState = StateField.define({
        create() {
          return null
        },
        update(value, tr) {
          if (
            value &&
            ((options.hideOnChange && (tr.docChanged || tr.selection)) ||
              (options.hideOn && options.hideOn(tr, value)))
          )
            return null
          if (value && tr.docChanged) {
            let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel)
            if (newPos == null) return null
            let copy = Object.assign(Object.create(null), value)
            copy.pos = newPos
            if (value.end != null) copy.end = tr.changes.mapPos(value.end)
            value = copy
          }
          for (let effect of tr.effects) {
            if (effect.is(setHover)) value = effect.value
            if (effect.is(closeHoverTooltipEffect)) value = null
          }
          return value
        },
        provide: (f) => showHoverTooltip.from(f)
      })
      return [
        hoverState,
        dist_ViewPlugin.define(
          (view) =>
            new HoverPlugin(
              view,
              source,
              hoverState,
              setHover,
              options.hoverTime || 300 /* Hover.Time */
            )
        ),
        showHoverTooltipHost
      ]
    }
    /**
Get the active tooltip view for a given tooltip, if available.
*/
    function getTooltip(view, tooltip) {
      let plugin = view.plugin(tooltipPlugin)
      if (!plugin) return null
      let found = plugin.manager.tooltips.indexOf(tooltip)
      return found < 0 ? null : plugin.manager.tooltipViews[found]
    }
    /**
Returns true if any hover tooltips are currently active.
*/
    function hasHoverTooltips(state) {
      return state.facet(showHoverTooltip).some((x) => x)
    }
    const closeHoverTooltipEffect = /*@__PURE__*/ StateEffect.define()
    /**
Transaction effect that closes all hover tooltips.
*/
    const closeHoverTooltips =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      closeHoverTooltipEffect.of(null)
    /**
Tell the tooltip extension to recompute the position of the active
tooltips. This can be useful when something happens (such as a
re-positioning or CSS change affecting the editor) that could
invalidate the existing tooltip positions.
*/
    function repositionTooltips(view) {
      let plugin = view.plugin(tooltipPlugin)
      if (plugin) plugin.maybeMeasure()
    }

    const panelConfig = /*@__PURE__*/ Facet.define({
      combine(configs) {
        let topContainer, bottomContainer
        for (let c of configs) {
          topContainer = topContainer || c.topContainer
          bottomContainer = bottomContainer || c.bottomContainer
        }
        return { topContainer, bottomContainer }
      }
    })
    /**
Configures the panel-managing extension.
*/
    function panels(config) {
      return config ? [panelConfig.of(config)] : []
    }
    /**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/
    function getPanel(view, panel) {
      let plugin = view.plugin(panelPlugin)
      let index = plugin ? plugin.specs.indexOf(panel) : -1
      return index > -1 ? plugin.panels[index] : null
    }
    const panelPlugin = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.input = view.state.facet(showPanel)
          this.specs = this.input.filter((s) => s)
          this.panels = this.specs.map((spec) => spec(view))
          let conf = view.state.facet(panelConfig)
          this.top = new PanelGroup(view, true, conf.topContainer)
          this.bottom = new PanelGroup(view, false, conf.bottomContainer)
          this.top.sync(this.panels.filter((p) => p.top))
          this.bottom.sync(this.panels.filter((p) => !p.top))
          for (let p of this.panels) {
            p.dom.classList.add('cm-panel')
            if (p.mount) p.mount()
          }
        }
        update(update) {
          let conf = update.state.facet(panelConfig)
          if (this.top.container != conf.topContainer) {
            this.top.sync([])
            this.top = new PanelGroup(update.view, true, conf.topContainer)
          }
          if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([])
            this.bottom = new PanelGroup(
              update.view,
              false,
              conf.bottomContainer
            )
          }
          this.top.syncClasses()
          this.bottom.syncClasses()
          let input = update.state.facet(showPanel)
          if (input != this.input) {
            let specs = input.filter((x) => x)
            let panels = [],
              top = [],
              bottom = [],
              mount = []
            for (let spec of specs) {
              let known = this.specs.indexOf(spec),
                panel
              if (known < 0) {
                panel = spec(update.view)
                mount.push(panel)
              } else {
                panel = this.panels[known]
                if (panel.update) panel.update(update)
              }
              panels.push(panel)
              ;(panel.top ? top : bottom).push(panel)
            }
            this.specs = specs
            this.panels = panels
            this.top.sync(top)
            this.bottom.sync(bottom)
            for (let p of mount) {
              p.dom.classList.add('cm-panel')
              if (p.mount) p.mount()
            }
          } else {
            for (let p of this.panels) if (p.update) p.update(update)
          }
        }
        destroy() {
          this.top.sync([])
          this.bottom.sync([])
        }
      },
      {
        provide: (plugin) =>
          EditorView.scrollMargins.of((view) => {
            let value = view.plugin(plugin)
            return (
              value && {
                top: value.top.scrollMargin(),
                bottom: value.bottom.scrollMargin()
              }
            )
          })
      }
    )
    class PanelGroup {
      constructor(view, top, container) {
        this.view = view
        this.top = top
        this.container = container
        this.dom = undefined
        this.classes = ''
        this.panels = []
        this.syncClasses()
      }
      sync(panels) {
        for (let p of this.panels)
          if (p.destroy && panels.indexOf(p) < 0) p.destroy()
        this.panels = panels
        this.syncDOM()
      }
      syncDOM() {
        if (this.panels.length == 0) {
          if (this.dom) {
            this.dom.remove()
            this.dom = undefined
          }
          return
        }
        if (!this.dom) {
          this.dom = document.createElement('div')
          this.dom.className = this.top
            ? 'cm-panels cm-panels-top'
            : 'cm-panels cm-panels-bottom'
          this.dom.style[this.top ? 'top' : 'bottom'] = '0'
          let parent = this.container || this.view.dom
          parent.insertBefore(this.dom, this.top ? parent.firstChild : null)
        }
        let curDOM = this.dom.firstChild
        for (let panel of this.panels) {
          if (panel.dom.parentNode == this.dom) {
            while (curDOM != panel.dom) curDOM = rm(curDOM)
            curDOM = curDOM.nextSibling
          } else {
            this.dom.insertBefore(panel.dom, curDOM)
          }
        }
        while (curDOM) curDOM = rm(curDOM)
      }
      scrollMargin() {
        return !this.dom || this.container
          ? 0
          : Math.max(
              0,
              this.top
                ? this.dom.getBoundingClientRect().bottom -
                    Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
                : Math.min(
                    innerHeight,
                    this.view.scrollDOM.getBoundingClientRect().bottom
                  ) - this.dom.getBoundingClientRect().top
            )
      }
      syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses) return
        for (let cls of this.classes.split(' '))
          if (cls) this.container.classList.remove(cls)
        for (let cls of (this.classes = this.view.themeClasses).split(' '))
          if (cls) this.container.classList.add(cls)
      }
    }
    function rm(node) {
      let next = node.nextSibling
      node.remove()
      return next
    }
    /**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/
    const showPanel = /*@__PURE__*/ Facet.define({
      enables: panelPlugin
    })

    /**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
    class GutterMarker extends RangeValue {
      /**
    @internal
    */
      compare(other) {
        return (
          this == other ||
          (this.constructor == other.constructor && this.eq(other))
        )
      }
      /**
    Compare this marker to another marker of the same type.
    */
      eq(other) {
        return false
      }
      /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
      destroy(dom) {}
    }
    GutterMarker.prototype.elementClass = ''
    GutterMarker.prototype.toDOM = undefined
    GutterMarker.prototype.mapMode = MapMode.TrackBefore
    GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1
    GutterMarker.prototype.point = true
    /**
Facet used to add a class to all gutter elements for a given line.
Markers given to this facet should _only_ define an
[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a
[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear
in all gutters for the line).
*/
    const gutterLineClass = /*@__PURE__*/ Facet.define()
    const dist_defaults = {
      class: '',
      renderEmptyElements: false,
      elementStyle: '',
      markers: () => dist_RangeSet.empty,
      lineMarker: () => null,
      widgetMarker: () => null,
      lineMarkerChange: null,
      initialSpacer: null,
      updateSpacer: null,
      domEventHandlers: {}
    }
    const activeGutters = /*@__PURE__*/ Facet.define()
    /**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/
    function gutter(config) {
      return [
        gutters(),
        activeGutters.of(
          Object.assign(Object.assign({}, dist_defaults), config)
        )
      ]
    }
    const unfixGutters = /*@__PURE__*/ Facet.define({
      combine: (values) => values.some((x) => x)
    })
    /**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/
    function gutters(config) {
      let result = [gutterView]
      if (config && config.fixed === false) result.push(unfixGutters.of(true))
      return result
    }
    const gutterView = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.view = view
          this.prevViewport = view.viewport
          this.dom = document.createElement('div')
          this.dom.className = 'cm-gutters'
          this.dom.setAttribute('aria-hidden', 'true')
          this.dom.style.minHeight =
            this.view.contentHeight / this.view.scaleY + 'px'
          this.gutters = view.state
            .facet(activeGutters)
            .map((conf) => new SingleGutterView(view, conf))
          for (let gutter of this.gutters) this.dom.appendChild(gutter.dom)
          this.fixed = !view.state.facet(unfixGutters)
          if (this.fixed) {
            // FIXME IE11 fallback, which doesn't support position: sticky,
            // by using position: relative + event handlers that realign the
            // gutter (or just force fixed=false on IE11?)
            this.dom.style.position = 'sticky'
          }
          this.syncGutters(false)
          view.scrollDOM.insertBefore(this.dom, view.contentDOM)
        }
        update(update) {
          if (this.updateGutters(update)) {
            // Detach during sync when the viewport changed significantly
            // (such as during scrolling), since for large updates that is
            // faster.
            let vpA = this.prevViewport,
              vpB = update.view.viewport
            let vpOverlap =
              Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from)
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8)
          }
          if (update.geometryChanged)
            this.dom.style.minHeight = this.view.contentHeight + 'px'
          if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed
            this.dom.style.position = this.fixed ? 'sticky' : ''
          }
          this.prevViewport = update.view.viewport
        }
        syncGutters(detach) {
          let after = this.dom.nextSibling
          if (detach) this.dom.remove()
          let lineClasses = dist_RangeSet.iter(
            this.view.state.facet(gutterLineClass),
            this.view.viewport.from
          )
          let classSet = []
          let contexts = this.gutters.map(
            (gutter) =>
              new UpdateContext(
                gutter,
                this.view.viewport,
                -this.view.documentPadding.top
              )
          )
          for (let line of this.view.viewportLineBlocks) {
            if (classSet.length) classSet = []
            if (Array.isArray(line.type)) {
              let first = true
              for (let b of line.type) {
                if (b.type == BlockType.Text && first) {
                  advanceCursor(lineClasses, classSet, b.from)
                  for (let cx of contexts) cx.line(this.view, b, classSet)
                  first = false
                } else if (b.widget) {
                  for (let cx of contexts) cx.widget(this.view, b)
                }
              }
            } else if (line.type == BlockType.Text) {
              advanceCursor(lineClasses, classSet, line.from)
              for (let cx of contexts) cx.line(this.view, line, classSet)
            } else if (line.widget) {
              for (let cx of contexts) cx.widget(this.view, line)
            }
          }
          for (let cx of contexts) cx.finish()
          if (detach) this.view.scrollDOM.insertBefore(this.dom, after)
        }
        updateGutters(update) {
          let prev = update.startState.facet(activeGutters),
            cur = update.state.facet(activeGutters)
          let change =
            update.docChanged ||
            update.heightChanged ||
            update.viewportChanged ||
            !dist_RangeSet.eq(
              update.startState.facet(gutterLineClass),
              update.state.facet(gutterLineClass),
              update.view.viewport.from,
              update.view.viewport.to
            )
          if (prev == cur) {
            for (let gutter of this.gutters)
              if (gutter.update(update)) change = true
          } else {
            change = true
            let gutters = []
            for (let conf of cur) {
              let known = prev.indexOf(conf)
              if (known < 0) {
                gutters.push(new SingleGutterView(this.view, conf))
              } else {
                this.gutters[known].update(update)
                gutters.push(this.gutters[known])
              }
            }
            for (let g of this.gutters) {
              g.dom.remove()
              if (gutters.indexOf(g) < 0) g.destroy()
            }
            for (let g of gutters) this.dom.appendChild(g.dom)
            this.gutters = gutters
          }
          return change
        }
        destroy() {
          for (let view of this.gutters) view.destroy()
          this.dom.remove()
        }
      },
      {
        provide: (plugin) =>
          EditorView.scrollMargins.of((view) => {
            let value = view.plugin(plugin)
            if (!value || value.gutters.length == 0 || !value.fixed) return null
            return view.textDirection == Direction.LTR
              ? { left: value.dom.offsetWidth * view.scaleX }
              : { right: value.dom.offsetWidth * view.scaleX }
          })
      }
    )
    function dist_asArray(val) {
      return Array.isArray(val) ? val : [val]
    }
    function advanceCursor(cursor, collect, pos) {
      while (cursor.value && cursor.from <= pos) {
        if (cursor.from == pos) collect.push(cursor.value)
        cursor.next()
      }
    }
    class UpdateContext {
      constructor(gutter, viewport, height) {
        this.gutter = gutter
        this.height = height
        this.i = 0
        this.cursor = dist_RangeSet.iter(gutter.markers, viewport.from)
      }
      addElement(view, block, markers) {
        let { gutter } = this,
          above = (block.top - this.height) / view.scaleY,
          height = block.height / view.scaleY
        if (this.i == gutter.elements.length) {
          let newElt = new GutterElement(view, height, above, markers)
          gutter.elements.push(newElt)
          gutter.dom.appendChild(newElt.dom)
        } else {
          gutter.elements[this.i].update(view, height, above, markers)
        }
        this.height = block.bottom
        this.i++
      }
      line(view, line, extraMarkers) {
        let localMarkers = []
        advanceCursor(this.cursor, localMarkers, line.from)
        if (extraMarkers.length)
          localMarkers = localMarkers.concat(extraMarkers)
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers)
        if (forLine) localMarkers.unshift(forLine)
        let gutter = this.gutter
        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
          return
        this.addElement(view, line, localMarkers)
      }
      widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block)
        if (marker) this.addElement(view, block, [marker])
      }
      finish() {
        let gutter = this.gutter
        while (gutter.elements.length > this.i) {
          let last = gutter.elements.pop()
          gutter.dom.removeChild(last.dom)
          last.destroy()
        }
      }
    }
    class SingleGutterView {
      constructor(view, config) {
        this.view = view
        this.config = config
        this.elements = []
        this.spacer = null
        this.dom = document.createElement('div')
        this.dom.className =
          'cm-gutter' + (this.config.class ? ' ' + this.config.class : '')
        for (let prop in config.domEventHandlers) {
          this.dom.addEventListener(prop, (event) => {
            let target = event.target,
              y
            if (target != this.dom && this.dom.contains(target)) {
              while (target.parentNode != this.dom) target = target.parentNode
              let rect = target.getBoundingClientRect()
              y = (rect.top + rect.bottom) / 2
            } else {
              y = event.clientY
            }
            let line = view.lineBlockAtHeight(y - view.documentTop)
            if (config.domEventHandlers[prop](view, line, event))
              event.preventDefault()
          })
        }
        this.markers = dist_asArray(config.markers(view))
        if (config.initialSpacer) {
          this.spacer = new GutterElement(view, 0, 0, [
            config.initialSpacer(view)
          ])
          this.dom.appendChild(this.spacer.dom)
          this.spacer.dom.style.cssText +=
            'visibility: hidden; pointer-events: none'
        }
      }
      update(update) {
        let prevMarkers = this.markers
        this.markers = dist_asArray(this.config.markers(update.view))
        if (this.spacer && this.config.updateSpacer) {
          let updated = this.config.updateSpacer(this.spacer.markers[0], update)
          if (updated != this.spacer.markers[0])
            this.spacer.update(update.view, 0, 0, [updated])
        }
        let vp = update.view.viewport
        return (
          !dist_RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||
          (this.config.lineMarkerChange
            ? this.config.lineMarkerChange(update)
            : false)
        )
      }
      destroy() {
        for (let elt of this.elements) elt.destroy()
      }
    }
    class GutterElement {
      constructor(view, height, above, markers) {
        this.height = -1
        this.above = 0
        this.markers = []
        this.dom = document.createElement('div')
        this.dom.className = 'cm-gutterElement'
        this.update(view, height, above, markers)
      }
      update(view, height, above, markers) {
        if (this.height != height) {
          this.height = height
          this.dom.style.height = height + 'px'
        }
        if (this.above != above)
          this.dom.style.marginTop = (this.above = above) ? above + 'px' : ''
        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers)
      }
      setMarkers(view, markers) {
        let cls = 'cm-gutterElement',
          domPos = this.dom.firstChild
        for (let iNew = 0, iOld = 0; ; ) {
          let skipTo = iOld,
            marker = iNew < markers.length ? markers[iNew++] : null,
            matched = false
          if (marker) {
            let c = marker.elementClass
            if (c) cls += ' ' + c
            for (let i = iOld; i < this.markers.length; i++)
              if (this.markers[i].compare(marker)) {
                skipTo = i
                matched = true
                break
              }
          } else {
            skipTo = this.markers.length
          }
          while (iOld < skipTo) {
            let next = this.markers[iOld++]
            if (next.toDOM) {
              next.destroy(domPos)
              let after = domPos.nextSibling
              domPos.remove()
              domPos = after
            }
          }
          if (!marker) break
          if (marker.toDOM) {
            if (matched) domPos = domPos.nextSibling
            else this.dom.insertBefore(marker.toDOM(view), domPos)
          }
          if (matched) iOld++
        }
        this.dom.className = cls
        this.markers = markers
      }
      destroy() {
        this.setMarkers(null, []) // First argument not used unless creating markers
      }
    }
    function sameMarkers(a, b) {
      if (a.length != b.length) return false
      for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false
      return true
    }
    /**
Facet used to provide markers to the line number gutter.
*/
    const lineNumberMarkers = /*@__PURE__*/ Facet.define()
    const lineNumberConfig = /*@__PURE__*/ Facet.define({
      combine(values) {
        return combineConfig(
          values,
          { formatNumber: String, domEventHandlers: {} },
          {
            domEventHandlers(a, b) {
              let result = Object.assign({}, a)
              for (let event in b) {
                let exists = result[event],
                  add = b[event]
                result[event] = exists
                  ? (view, line, event) =>
                      exists(view, line, event) || add(view, line, event)
                  : add
              }
              return result
            }
          }
        )
      }
    })
    class NumberMarker extends GutterMarker {
      constructor(number) {
        super()
        this.number = number
      }
      eq(other) {
        return this.number == other.number
      }
      toDOM() {
        return document.createTextNode(this.number)
      }
    }
    function formatNumber(view, number) {
      return view.state.facet(lineNumberConfig).formatNumber(number, view.state)
    }
    const lineNumberGutter = /*@__PURE__*/ activeGutters.compute(
      [lineNumberConfig],
      (state) => ({
        class: 'cm-lineNumbers',
        renderEmptyElements: false,
        markers(view) {
          return view.state.facet(lineNumberMarkers)
        },
        lineMarker(view, line, others) {
          if (others.some((m) => m.toDOM)) return null
          return new NumberMarker(
            formatNumber(view, view.state.doc.lineAt(line.from).number)
          )
        },
        widgetMarker: () => null,
        lineMarkerChange: (update) =>
          update.startState.facet(lineNumberConfig) !=
          update.state.facet(lineNumberConfig),
        initialSpacer(view) {
          return new NumberMarker(
            formatNumber(view, maxLineNumber(view.state.doc.lines))
          )
        },
        updateSpacer(spacer, update) {
          let max = formatNumber(
            update.view,
            maxLineNumber(update.view.state.doc.lines)
          )
          return max == spacer.number ? spacer : new NumberMarker(max)
        },
        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
      })
    )
    /**
Create a line number gutter extension.
*/
    function lineNumbers(config = {}) {
      return [lineNumberConfig.of(config), gutters(), lineNumberGutter]
    }
    function maxLineNumber(lines) {
      let last = 9
      while (last < lines) last = last * 10 + 9
      return last
    }
    const activeLineGutterMarker =
      /*@__PURE__*/ new (class extends GutterMarker {
        constructor() {
          super(...arguments)
          this.elementClass = 'cm-activeLineGutter'
        }
      })()
    const activeLineGutterHighlighter = /*@__PURE__*/ gutterLineClass.compute(
      ['selection'],
      (state) => {
        let marks = [],
          last = -1
        for (let range of state.selection.ranges) {
          let linePos = state.doc.lineAt(range.head).from
          if (linePos > last) {
            last = linePos
            marks.push(activeLineGutterMarker.range(linePos))
          }
        }
        return dist_RangeSet.of(marks)
      }
    )
    /**
Returns an extension that adds a `cm-activeLineGutter` class to
all gutter elements on the [active
line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
*/
    function highlightActiveLineGutter() {
      return activeLineGutterHighlighter
    }

    const WhitespaceDeco = /*@__PURE__*/ new Map()
    function getWhitespaceDeco(space) {
      let deco = WhitespaceDeco.get(space)
      if (!deco)
        WhitespaceDeco.set(
          space,
          (deco = Decoration.mark({
            attributes:
              space === '\t'
                ? {
                    class: 'cm-highlightTab'
                  }
                : {
                    class: 'cm-highlightSpace',
                    'data-display': space.replace(/ /g, '·')
                  }
          }))
        )
      return deco
    }
    function matcher(decorator) {
      return dist_ViewPlugin.define(
        (view) => ({
          decorations: decorator.createDeco(view),
          update(u) {
            this.decorations = decorator.updateDeco(u, this.decorations)
          }
        }),
        {
          decorations: (v) => v.decorations
        }
      )
    }
    const whitespaceHighlighter = /*@__PURE__*/ matcher(
      /*@__PURE__*/ new MatchDecorator({
        regexp: /\t| +/g,
        decoration: (match) => getWhitespaceDeco(match[0]),
        boundary: /\S/
      })
    )
    /**
Returns an extension that highlights whitespace, adding a
`cm-highlightSpace` class to stretches of spaces, and a
`cm-highlightTab` class to individual tab characters. By default,
the former are shown as faint dots, and the latter as arrows.
*/
    function highlightWhitespace() {
      return whitespaceHighlighter
    }
    const trailingHighlighter = /*@__PURE__*/ matcher(
      /*@__PURE__*/ new MatchDecorator({
        regexp: /\s+$/g,
        decoration: /*@__PURE__*/ Decoration.mark({
          class: 'cm-trailingSpace'
        }),
        boundary: /\S/
      })
    )
    /**
Returns an extension that adds a `cm-trailingSpace` class to all
trailing whitespace.
*/
    function highlightTrailingWhitespace() {
      return trailingHighlighter
    }

    /**
@internal
*/
    const __test = {
      HeightMap,
      HeightOracle,
      MeasuredHeights,
      QueryType,
      ChangedRange,
      computeOrder,
      moveVisually
    } // CONCATENATED MODULE: ./node_modules/@lezer/common/dist/index.js

    /**
The default maximum length of a `TreeBuffer` node.
*/
    const DefaultBufferLength = 1024
    let nextPropID = 0
    class dist_Range {
      constructor(from, to) {
        this.from = from
        this.to = to
      }
    }
    /**
Each [node type](#common.NodeType) or [individual tree](#common.Tree)
can have metadata associated with it in props. Instances of this
class represent prop names.
*/
    class dist_NodeProp {
      /**
    Create a new node prop type.
    */
      constructor(config = {}) {
        this.id = nextPropID++
        this.perNode = !!config.perNode
        this.deserialize =
          config.deserialize ||
          (() => {
            throw new Error(
              "This node type doesn't define a deserialize function"
            )
          })
      }
      /**
    This is meant to be used with
    [`NodeSet.extend`](#common.NodeSet.extend) or
    [`LRParser.configure`](#lr.ParserConfig.props) to compute
    prop values for each node type in the set. Takes a [match
    object](#common.NodeType^match) or function that returns undefined
    if the node type doesn't get this prop, and the prop's value if
    it does.
    */
      add(match) {
        if (this.perNode)
          throw new RangeError("Can't add per-node props to node types")
        if (typeof match != 'function') match = dist_NodeType.match(match)
        return (type) => {
          let result = match(type)
          return result === undefined ? null : [this, result]
        }
      }
    }
    /**
Prop that is used to describe matching delimiters. For opening
delimiters, this holds an array of node names (written as a
space-separated string when declaring this prop in a grammar)
for the node types of closing delimiters that match it.
*/
    dist_NodeProp.closedBy = new dist_NodeProp({
      deserialize: (str) => str.split(' ')
    })
    /**
The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
attached to closing delimiters, holding an array of node names
of types of matching opening delimiters.
*/
    dist_NodeProp.openedBy = new dist_NodeProp({
      deserialize: (str) => str.split(' ')
    })
    /**
Used to assign node types to groups (for example, all node
types that represent an expression could be tagged with an
`"Expression"` group).
*/
    dist_NodeProp.group = new dist_NodeProp({
      deserialize: (str) => str.split(' ')
    })
    /**
The hash of the [context](#lr.ContextTracker.constructor)
that the node was parsed in, if any. Used to limit reuse of
contextual nodes.
*/
    dist_NodeProp.contextHash = new dist_NodeProp({ perNode: true })
    /**
The distance beyond the end of the node that the tokenizer
looked ahead for any of the tokens inside the node. (The LR
parser only stores this when it is larger than 25, for
efficiency reasons.)
*/
    dist_NodeProp.lookAhead = new dist_NodeProp({ perNode: true })
    /**
This per-node prop is used to replace a given node, or part of a
node, with another tree. This is useful to include trees from
different languages in mixed-language parsers.
*/
    dist_NodeProp.mounted = new dist_NodeProp({ perNode: true })
    /**
A mounted tree, which can be [stored](#common.NodeProp^mounted) on
a tree node to indicate that parts of its content are
represented by another tree.
*/
    class MountedTree {
      constructor(
        /**
    The inner tree.
    */
        tree,
        /**
    If this is null, this tree replaces the entire node (it will
    be included in the regular iteration instead of its host
    node). If not, only the given ranges are considered to be
    covered by this tree. This is used for trees that are mixed in
    a way that isn't strictly hierarchical. Such mounted trees are
    only entered by [`resolveInner`](#common.Tree.resolveInner)
    and [`enter`](#common.SyntaxNode.enter).
    */
        overlay,
        /**
    The parser used to create this subtree.
    */
        parser
      ) {
        this.tree = tree
        this.overlay = overlay
        this.parser = parser
      }
      /**
    @internal
    */
      static get(tree) {
        return tree && tree.props && tree.props[dist_NodeProp.mounted.id]
      }
    }
    const noProps = Object.create(null)
    /**
Each node in a syntax tree has a node type associated with it.
*/
    class dist_NodeType {
      /**
    @internal
    */
      constructor(
        /**
    The name of the node type. Not necessarily unique, but if the
    grammar was written properly, different node types with the
    same name within a node set should play the same semantic
    role.
    */
        name,
        /**
    @internal
    */
        props,
        /**
    The id of this node in its set. Corresponds to the term ids
    used in the parser.
    */
        id,
        /**
    @internal
    */
        flags = 0
      ) {
        this.name = name
        this.props = props
        this.id = id
        this.flags = flags
      }
      /**
    Define a node type.
    */
      static define(spec) {
        let props =
          spec.props && spec.props.length ? Object.create(null) : noProps
        let flags =
          (spec.top ? 1 /* NodeFlag.Top */ : 0) |
          (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |
          (spec.error ? 4 /* NodeFlag.Error */ : 0) |
          (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0)
        let type = new dist_NodeType(spec.name || '', props, spec.id, flags)
        if (spec.props)
          for (let src of spec.props) {
            if (!Array.isArray(src)) src = src(type)
            if (src) {
              if (src[0].perNode)
                throw new RangeError(
                  "Can't store a per-node prop on a node type"
                )
              props[src[0].id] = src[1]
            }
          }
        return type
      }
      /**
    Retrieves a node prop for this type. Will return `undefined` if
    the prop isn't present on this node.
    */
      prop(prop) {
        return this.props[prop.id]
      }
      /**
    True when this is the top node of a grammar.
    */
      get isTop() {
        return (this.flags & 1) /* NodeFlag.Top */ > 0
      }
      /**
    True when this node is produced by a skip rule.
    */
      get isSkipped() {
        return (this.flags & 2) /* NodeFlag.Skipped */ > 0
      }
      /**
    Indicates whether this is an error node.
    */
      get isError() {
        return (this.flags & 4) /* NodeFlag.Error */ > 0
      }
      /**
    When true, this node type doesn't correspond to a user-declared
    named node, for example because it is used to cache repetition.
    */
      get isAnonymous() {
        return (this.flags & 8) /* NodeFlag.Anonymous */ > 0
      }
      /**
    Returns true when this node's name or one of its
    [groups](#common.NodeProp^group) matches the given string.
    */
      is(name) {
        if (typeof name == 'string') {
          if (this.name == name) return true
          let group = this.prop(dist_NodeProp.group)
          return group ? group.indexOf(name) > -1 : false
        }
        return this.id == name
      }
      /**
    Create a function from node types to arbitrary values by
    specifying an object whose property names are node or
    [group](#common.NodeProp^group) names. Often useful with
    [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    names, separated by spaces, in a single property name to map
    multiple node names to a single value.
    */
      static match(map) {
        let direct = Object.create(null)
        for (let prop in map)
          for (let name of prop.split(' ')) direct[name] = map[prop]
        return (node) => {
          for (
            let groups = node.prop(dist_NodeProp.group), i = -1;
            i < (groups ? groups.length : 0);
            i++
          ) {
            let found = direct[i < 0 ? node.name : groups[i]]
            if (found) return found
          }
        }
      }
    }
    /**
An empty dummy node type to use when no actual type is available.
*/
    dist_NodeType.none = new dist_NodeType(
      '',
      Object.create(null),
      0,
      8 /* NodeFlag.Anonymous */
    )
    /**
A node set holds a collection of node types. It is used to
compactly represent trees by storing their type ids, rather than a
full pointer to the type object, in a numeric array. Each parser
[has](#lr.LRParser.nodeSet) a node set, and [tree
buffers](#common.TreeBuffer) can only store collections of nodes
from the same set. A set can have a maximum of 2**16 (65536) node
types in it, so that the ids fit into 16-bit typed array slots.
*/
    class NodeSet {
      /**
    Create a set with the given types. The `id` property of each
    type should correspond to its position within the array.
    */
      constructor(
        /**
    The node types in this set, by id.
    */
        types
      ) {
        this.types = types
        for (let i = 0; i < types.length; i++)
          if (types[i].id != i)
            throw new RangeError(
              'Node type ids should correspond to array positions when creating a node set'
            )
      }
      /**
    Create a copy of this set with some node properties added. The
    arguments to this method can be created with
    [`NodeProp.add`](#common.NodeProp.add).
    */
      extend(...props) {
        let newTypes = []
        for (let type of this.types) {
          let newProps = null
          for (let source of props) {
            let add = source(type)
            if (add) {
              if (!newProps) newProps = Object.assign({}, type.props)
              newProps[add[0].id] = add[1]
            }
          }
          newTypes.push(
            newProps
              ? new dist_NodeType(type.name, newProps, type.id, type.flags)
              : type
          )
        }
        return new NodeSet(newTypes)
      }
    }
    const CachedNode = new WeakMap(),
      CachedInnerNode = new WeakMap()
    /**
Options that control iteration. Can be combined with the `|`
operator to enable multiple ones.
*/
    var IterMode
    ;(function (IterMode) {
      /**
    When enabled, iteration will only visit [`Tree`](#common.Tree)
    objects, not nodes packed into
    [`TreeBuffer`](#common.TreeBuffer)s.
    */
      IterMode[(IterMode['ExcludeBuffers'] = 1)] = 'ExcludeBuffers'
      /**
    Enable this to make iteration include anonymous nodes (such as
    the nodes that wrap repeated grammar constructs into a balanced
    tree).
    */
      IterMode[(IterMode['IncludeAnonymous'] = 2)] = 'IncludeAnonymous'
      /**
    By default, regular [mounted](#common.NodeProp^mounted) nodes
    replace their base node in iteration. Enable this to ignore them
    instead.
    */
      IterMode[(IterMode['IgnoreMounts'] = 4)] = 'IgnoreMounts'
      /**
    This option only applies in
    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
    library to not enter mounted overlays if one covers the given
    position.
    */
      IterMode[(IterMode['IgnoreOverlays'] = 8)] = 'IgnoreOverlays'
    })(IterMode || (IterMode = {}))
    /**
A piece of syntax tree. There are two ways to approach these
trees: the way they are actually stored in memory, and the
convenient way.

Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
objects. By packing detail information into `TreeBuffer` leaf
nodes, the representation is made a lot more memory-efficient.

However, when you want to actually work with tree nodes, this
representation is very awkward, so most client code will want to
use the [`TreeCursor`](#common.TreeCursor) or
[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
a view on some part of this data structure, and can be used to
move around to adjacent nodes.
*/
    class dist_Tree {
      /**
    Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    */
      constructor(
        /**
    The type of the top node.
    */
        type,
        /**
    This node's child nodes.
    */
        children,
        /**
    The positions (offsets relative to the start of this tree) of
    the children.
    */
        positions,
        /**
    The total length of this tree
    */
        length,
        /**
    Per-node [node props](#common.NodeProp) to associate with this node.
    */
        props
      ) {
        this.type = type
        this.children = children
        this.positions = positions
        this.length = length
        /**
        @internal
        */
        this.props = null
        if (props && props.length) {
          this.props = Object.create(null)
          for (let [prop, value] of props)
            this.props[typeof prop == 'number' ? prop : prop.id] = value
        }
      }
      /**
    @internal
    */
      toString() {
        let mounted = MountedTree.get(this)
        if (mounted && !mounted.overlay) return mounted.tree.toString()
        let children = ''
        for (let ch of this.children) {
          let str = ch.toString()
          if (str) {
            if (children) children += ','
            children += str
          }
        }
        return !this.type.name
          ? children
          : (/\W/.test(this.type.name) && !this.type.isError
              ? JSON.stringify(this.type.name)
              : this.type.name) + (children.length ? '(' + children + ')' : '')
      }
      /**
    Get a [tree cursor](#common.TreeCursor) positioned at the top of
    the tree. Mode can be used to [control](#common.IterMode) which
    nodes the cursor visits.
    */
      cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode)
      }
      /**
    Get a [tree cursor](#common.TreeCursor) pointing into this tree
    at the given position and side (see
    [`moveTo`](#common.TreeCursor.moveTo).
    */
      cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode
        let cursor = new TreeCursor(scope)
        cursor.moveTo(pos, side)
        CachedNode.set(this, cursor._tree)
        return cursor
      }
      /**
    Get a [syntax node](#common.SyntaxNode) object for the top of the
    tree.
    */
      get topNode() {
        return new TreeNode(this, 0, 0, null)
      }
      /**
    Get the [syntax node](#common.SyntaxNode) at the given position.
    If `side` is -1, this will move into nodes that end at the
    position. If 1, it'll move into nodes that start at the
    position. With 0, it'll only enter nodes that cover the position
    from both sides.
    
    Note that this will not enter
    [overlays](#common.MountedTree.overlay), and you often want
    [`resolveInner`](#common.Tree.resolveInner) instead.
    */
      resolve(pos, side = 0) {
        let node = resolveNode(
          CachedNode.get(this) || this.topNode,
          pos,
          side,
          false
        )
        CachedNode.set(this, node)
        return node
      }
      /**
    Like [`resolve`](#common.Tree.resolve), but will enter
    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    pointing into the innermost overlaid tree at the given position
    (with parent links going through all parent structure, including
    the host trees).
    */
      resolveInner(pos, side = 0) {
        let node = resolveNode(
          CachedInnerNode.get(this) || this.topNode,
          pos,
          side,
          true
        )
        CachedInnerNode.set(this, node)
        return node
      }
      /**
    In some situations, it can be useful to iterate through all
    nodes around a position, including those in overlays that don't
    directly cover the position. This method gives you an iterator
    that will produce all nodes, from small to big, around the given
    position.
    */
      resolveStack(pos, side = 0) {
        return stackIterator(this, pos, side)
      }
      /**
    Iterate over the tree and its children, calling `enter` for any
    node that touches the `from`/`to` region (if given) before
    running over such a node's children, and `leave` (if given) when
    leaving the node. When `enter` returns `false`, that node will
    not have its children iterated over (or `leave` called).
    */
      iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec
        let mode = spec.mode || 0,
          anon = (mode & IterMode.IncludeAnonymous) > 0
        for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
          let entered = false
          if (
            c.from <= to &&
            c.to >= from &&
            ((!anon && c.type.isAnonymous) || enter(c) !== false)
          ) {
            if (c.firstChild()) continue
            entered = true
          }
          for (;;) {
            if (entered && leave && (anon || !c.type.isAnonymous)) leave(c)
            if (c.nextSibling()) break
            if (!c.parent()) return
            entered = true
          }
        }
      }
      /**
    Get the value of the given [node prop](#common.NodeProp) for this
    node. Works with both per-node and per-type props.
    */
      prop(prop) {
        return !prop.perNode
          ? this.type.prop(prop)
          : this.props
            ? this.props[prop.id]
            : undefined
      }
      /**
    Returns the node's [per-node props](#common.NodeProp.perNode) in a
    format that can be passed to the [`Tree`](#common.Tree)
    constructor.
    */
      get propValues() {
        let result = []
        if (this.props)
          for (let id in this.props) result.push([+id, this.props[id]])
        return result
      }
      /**
    Balance the direct children of this tree, producing a copy of
    which may have children grouped into subtrees with type
    [`NodeType.none`](#common.NodeType^none).
    */
      balance(config = {}) {
        return this.children.length <= 8 /* Balance.BranchFactor */
          ? this
          : balanceRange(
              dist_NodeType.none,
              this.children,
              this.positions,
              0,
              this.children.length,
              0,
              this.length,
              (children, positions, length) =>
                new dist_Tree(
                  this.type,
                  children,
                  positions,
                  length,
                  this.propValues
                ),
              config.makeTree ||
                ((children, positions, length) =>
                  new dist_Tree(
                    dist_NodeType.none,
                    children,
                    positions,
                    length
                  ))
            )
      }
      /**
    Build a tree from a postfix-ordered buffer of node information,
    or a cursor over such a buffer.
    */
      static build(data) {
        return buildTree(data)
      }
    }
    /**
The empty tree
*/
    dist_Tree.empty = new dist_Tree(dist_NodeType.none, [], [], 0)
    class FlatBufferCursor {
      constructor(buffer, index) {
        this.buffer = buffer
        this.index = index
      }
      get id() {
        return this.buffer[this.index - 4]
      }
      get start() {
        return this.buffer[this.index - 3]
      }
      get end() {
        return this.buffer[this.index - 2]
      }
      get size() {
        return this.buffer[this.index - 1]
      }
      get pos() {
        return this.index
      }
      next() {
        this.index -= 4
      }
      fork() {
        return new FlatBufferCursor(this.buffer, this.index)
      }
    }
    /**
Tree buffers contain (type, start, end, endIndex) quads for each
node. In such a buffer, nodes are stored in prefix order (parents
before children, with the endIndex of the parent indicating which
children belong to it).
*/
    class TreeBuffer {
      /**
    Create a tree buffer.
    */
      constructor(
        /**
    The buffer's content.
    */
        buffer,
        /**
    The total length of the group of nodes in the buffer.
    */
        length,
        /**
    The node set used in this buffer.
    */
        set
      ) {
        this.buffer = buffer
        this.length = length
        this.set = set
      }
      /**
    @internal
    */
      get type() {
        return dist_NodeType.none
      }
      /**
    @internal
    */
      toString() {
        let result = []
        for (let index = 0; index < this.buffer.length; ) {
          result.push(this.childString(index))
          index = this.buffer[index + 3]
        }
        return result.join(',')
      }
      /**
    @internal
    */
      childString(index) {
        let id = this.buffer[index],
          endIndex = this.buffer[index + 3]
        let type = this.set.types[id],
          result = type.name
        if (/\W/.test(result) && !type.isError) result = JSON.stringify(result)
        index += 4
        if (endIndex == index) return result
        let children = []
        while (index < endIndex) {
          children.push(this.childString(index))
          index = this.buffer[index + 3]
        }
        return result + '(' + children.join(',') + ')'
      }
      /**
    @internal
    */
      findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this,
          pick = -1
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
          if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
            pick = i
            if (dir > 0) break
          }
        }
        return pick
      }
      /**
    @internal
    */
      slice(startI, endI, from) {
        let b = this.buffer
        let copy = new Uint16Array(endI - startI),
          len = 0
        for (let i = startI, j = 0; i < endI; ) {
          copy[j++] = b[i++]
          copy[j++] = b[i++] - from
          let to = (copy[j++] = b[i++] - from)
          copy[j++] = b[i++] - startI
          len = Math.max(len, to)
        }
        return new TreeBuffer(copy, len, this.set)
      }
    }
    function checkSide(side, pos, from, to) {
      switch (side) {
        case -2 /* Side.Before */:
          return from < pos
        case -1 /* Side.AtOrBefore */:
          return to >= pos && from < pos
        case 0 /* Side.Around */:
          return from < pos && to > pos
        case 1 /* Side.AtOrAfter */:
          return from <= pos && to > pos
        case 2 /* Side.After */:
          return to > pos
        case 4 /* Side.DontCare */:
          return true
      }
    }
    function resolveNode(node, pos, side, overlays) {
      var _a
      // Move up to a node that actually holds the position, if possible
      while (
        node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)
      ) {
        let parent =
          !overlays && node instanceof TreeNode && node.index < 0
            ? null
            : node.parent
        if (!parent) return node
        node = parent
      }
      let mode = overlays ? 0 : IterMode.IgnoreOverlays
      // Must go up out of overlays when those do not overlap with pos
      if (overlays)
        for (
          let scan = node, parent = scan.parent;
          parent;
          scan = parent, parent = scan.parent
        ) {
          if (
            scan instanceof TreeNode &&
            scan.index < 0 &&
            ((_a = parent.enter(pos, side, mode)) === null || _a === void 0
              ? void 0
              : _a.from) != scan.from
          )
            node = parent
        }
      for (;;) {
        let inner = node.enter(pos, side, mode)
        if (!inner) return node
        node = inner
      }
    }
    class BaseNode {
      cursor(mode = 0) {
        return new TreeCursor(this, mode)
      }
      getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after)
        return r.length ? r[0] : null
      }
      getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after)
      }
      resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false)
      }
      resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true)
      }
      matchContext(context) {
        return matchNodeContext(this, context)
      }
      enterUnfinishedNodesBefore(pos) {
        let scan = this.childBefore(pos),
          node = this
        while (scan) {
          let last = scan.lastChild
          if (!last || last.to != scan.to) break
          if (last.type.isError && last.from == last.to) {
            node = scan
            scan = last.prevSibling
          } else {
            scan = last
          }
        }
        return node
      }
      get node() {
        return this
      }
      get next() {
        return this.parent
      }
    }
    class TreeNode extends BaseNode {
      constructor(
        _tree,
        from,
        // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
        index,
        _parent
      ) {
        super()
        this._tree = _tree
        this.from = from
        this.index = index
        this._parent = _parent
      }
      get type() {
        return this._tree.type
      }
      get name() {
        return this._tree.type.name
      }
      get to() {
        return this.from + this._tree.length
      }
      nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this; ; ) {
          for (
            let { children, positions } = parent._tree,
              e = dir > 0 ? children.length : -1;
            i != e;
            i += dir
          ) {
            let next = children[i],
              start = positions[i] + parent.from
            if (!checkSide(side, pos, start, start + next.length)) continue
            if (next instanceof TreeBuffer) {
              if (mode & IterMode.ExcludeBuffers) continue
              let index = next.findChild(
                0,
                next.buffer.length,
                dir,
                pos - start,
                side
              )
              if (index > -1)
                return new BufferNode(
                  new BufferContext(parent, next, i, start),
                  null,
                  index
                )
            } else if (
              mode & IterMode.IncludeAnonymous ||
              !next.type.isAnonymous ||
              hasChild(next)
            ) {
              let mounted
              if (
                !(mode & IterMode.IgnoreMounts) &&
                (mounted = MountedTree.get(next)) &&
                !mounted.overlay
              )
                return new TreeNode(mounted.tree, start, i, parent)
              let inner = new TreeNode(next, start, i, parent)
              return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous
                ? inner
                : inner.nextChild(
                    dir < 0 ? next.children.length - 1 : 0,
                    dir,
                    pos,
                    side
                  )
            }
          }
          if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
            return null
          if (parent.index >= 0) i = parent.index + dir
          else i = dir < 0 ? -1 : parent._parent._tree.children.length
          parent = parent._parent
          if (!parent) return null
        }
      }
      get firstChild() {
        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */)
      }
      get lastChild() {
        return this.nextChild(
          this._tree.children.length - 1,
          -1,
          0,
          4 /* Side.DontCare */
        )
      }
      childAfter(pos) {
        return this.nextChild(0, 1, pos, 2 /* Side.After */)
      }
      childBefore(pos) {
        return this.nextChild(
          this._tree.children.length - 1,
          -1,
          pos,
          -2 /* Side.Before */
        )
      }
      enter(pos, side, mode = 0) {
        let mounted
        if (
          !(mode & IterMode.IgnoreOverlays) &&
          (mounted = MountedTree.get(this._tree)) &&
          mounted.overlay
        ) {
          let rPos = pos - this.from
          for (let { from, to } of mounted.overlay) {
            if (
              (side > 0 ? from <= rPos : from < rPos) &&
              (side < 0 ? to >= rPos : to > rPos)
            )
              return new TreeNode(
                mounted.tree,
                mounted.overlay[0].from + this.from,
                -1,
                this
              )
          }
        }
        return this.nextChild(0, 1, pos, side, mode)
      }
      nextSignificantParent() {
        let val = this
        while (val.type.isAnonymous && val._parent) val = val._parent
        return val
      }
      get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null
      }
      get nextSibling() {
        return this._parent && this.index >= 0
          ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */)
          : null
      }
      get prevSibling() {
        return this._parent && this.index >= 0
          ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */)
          : null
      }
      get tree() {
        return this._tree
      }
      toTree() {
        return this._tree
      }
      /**
    @internal
    */
      toString() {
        return this._tree.toString()
      }
    }
    function getChildren(node, type, before, after) {
      let cur = node.cursor(),
        result = []
      if (!cur.firstChild()) return result
      if (before != null)
        while (!cur.type.is(before)) if (!cur.nextSibling()) return result
      for (;;) {
        if (after != null && cur.type.is(after)) return result
        if (cur.type.is(type)) result.push(cur.node)
        if (!cur.nextSibling()) return after == null ? result : []
      }
    }
    function matchNodeContext(node, context, i = context.length - 1) {
      for (let p = node.parent; i >= 0; p = p.parent) {
        if (!p) return false
        if (!p.type.isAnonymous) {
          if (context[i] && context[i] != p.name) return false
          i--
        }
      }
      return true
    }
    class BufferContext {
      constructor(parent, buffer, index, start) {
        this.parent = parent
        this.buffer = buffer
        this.index = index
        this.start = start
      }
    }
    class BufferNode extends BaseNode {
      get name() {
        return this.type.name
      }
      get from() {
        return this.context.start + this.context.buffer.buffer[this.index + 1]
      }
      get to() {
        return this.context.start + this.context.buffer.buffer[this.index + 2]
      }
      constructor(context, _parent, index) {
        super()
        this.context = context
        this._parent = _parent
        this.index = index
        this.type = context.buffer.set.types[context.buffer.buffer[index]]
      }
      child(dir, pos, side) {
        let { buffer } = this.context
        let index = buffer.findChild(
          this.index + 4,
          buffer.buffer[this.index + 3],
          dir,
          pos - this.context.start,
          side
        )
        return index < 0 ? null : new BufferNode(this.context, this, index)
      }
      get firstChild() {
        return this.child(1, 0, 4 /* Side.DontCare */)
      }
      get lastChild() {
        return this.child(-1, 0, 4 /* Side.DontCare */)
      }
      childAfter(pos) {
        return this.child(1, pos, 2 /* Side.After */)
      }
      childBefore(pos) {
        return this.child(-1, pos, -2 /* Side.Before */)
      }
      enter(pos, side, mode = 0) {
        if (mode & IterMode.ExcludeBuffers) return null
        let { buffer } = this.context
        let index = buffer.findChild(
          this.index + 4,
          buffer.buffer[this.index + 3],
          side > 0 ? 1 : -1,
          pos - this.context.start,
          side
        )
        return index < 0 ? null : new BufferNode(this.context, this, index)
      }
      get parent() {
        return this._parent || this.context.parent.nextSignificantParent()
      }
      externalSibling(dir) {
        return this._parent
          ? null
          : this.context.parent.nextChild(
              this.context.index + dir,
              dir,
              0,
              4 /* Side.DontCare */
            )
      }
      get nextSibling() {
        let { buffer } = this.context
        let after = buffer.buffer[this.index + 3]
        if (
          after <
          (this._parent
            ? buffer.buffer[this._parent.index + 3]
            : buffer.buffer.length)
        )
          return new BufferNode(this.context, this._parent, after)
        return this.externalSibling(1)
      }
      get prevSibling() {
        let { buffer } = this.context
        let parentStart = this._parent ? this._parent.index + 4 : 0
        if (this.index == parentStart) return this.externalSibling(-1)
        return new BufferNode(
          this.context,
          this._parent,
          buffer.findChild(
            parentStart,
            this.index,
            -1,
            0,
            4 /* Side.DontCare */
          )
        )
      }
      get tree() {
        return null
      }
      toTree() {
        let children = [],
          positions = []
        let { buffer } = this.context
        let startI = this.index + 4,
          endI = buffer.buffer[this.index + 3]
        if (endI > startI) {
          let from = buffer.buffer[this.index + 1]
          children.push(buffer.slice(startI, endI, from))
          positions.push(0)
        }
        return new dist_Tree(
          this.type,
          children,
          positions,
          this.to - this.from
        )
      }
      /**
    @internal
    */
      toString() {
        return this.context.buffer.childString(this.index)
      }
    }
    function iterStack(heads) {
      if (!heads.length) return null
      let pick = 0,
        picked = heads[0]
      for (let i = 1; i < heads.length; i++) {
        let node = heads[i]
        if (node.from > picked.from || node.to < picked.to) {
          picked = node
          pick = i
        }
      }
      let next =
        picked instanceof TreeNode && picked.index < 0 ? null : picked.parent
      let newHeads = heads.slice()
      if (next) newHeads[pick] = next
      else newHeads.splice(pick, 1)
      return new StackIterator(newHeads, picked)
    }
    class StackIterator {
      constructor(heads, node) {
        this.heads = heads
        this.node = node
      }
      get next() {
        return iterStack(this.heads)
      }
    }
    function stackIterator(tree, pos, side) {
      let inner = tree.resolveInner(pos, side),
        layers = null
      for (
        let scan = inner instanceof TreeNode ? inner : inner.context.parent;
        scan;
        scan = scan.parent
      ) {
        if (scan.index < 0) {
          // This is an overlay root
          let parent = scan.parent
          ;(layers || (layers = [inner])).push(parent.resolve(pos, side))
          scan = parent
        } else {
          let mount = MountedTree.get(scan.tree)
          // Relevant overlay branching off
          if (
            mount &&
            mount.overlay &&
            mount.overlay[0].from <= pos &&
            mount.overlay[mount.overlay.length - 1].to >= pos
          ) {
            let root = new TreeNode(
              mount.tree,
              mount.overlay[0].from + scan.from,
              -1,
              scan
            )
            ;(layers || (layers = [inner])).push(
              resolveNode(root, pos, side, false)
            )
          }
        }
      }
      return layers ? iterStack(layers) : inner
    }
    /**
A tree cursor object focuses on a given node in a syntax tree, and
allows you to move to adjacent nodes.
*/
    class TreeCursor {
      /**
    Shorthand for `.type.name`.
    */
      get name() {
        return this.type.name
      }
      /**
    @internal
    */
      constructor(
        node,
        /**
    @internal
    */
        mode = 0
      ) {
        this.mode = mode
        /**
        @internal
        */
        this.buffer = null
        this.stack = []
        /**
        @internal
        */
        this.index = 0
        this.bufferNode = null
        if (node instanceof TreeNode) {
          this.yieldNode(node)
        } else {
          this._tree = node.context.parent
          this.buffer = node.context
          for (let n = node._parent; n; n = n._parent)
            this.stack.unshift(n.index)
          this.bufferNode = node
          this.yieldBuf(node.index)
        }
      }
      yieldNode(node) {
        if (!node) return false
        this._tree = node
        this.type = node.type
        this.from = node.from
        this.to = node.to
        return true
      }
      yieldBuf(index, type) {
        this.index = index
        let { start, buffer } = this.buffer
        this.type = type || buffer.set.types[buffer.buffer[index]]
        this.from = start + buffer.buffer[index + 1]
        this.to = start + buffer.buffer[index + 2]
        return true
      }
      /**
    @internal
    */
      yield(node) {
        if (!node) return false
        if (node instanceof TreeNode) {
          this.buffer = null
          return this.yieldNode(node)
        }
        this.buffer = node.context
        return this.yieldBuf(node.index, node.type)
      }
      /**
    @internal
    */
      toString() {
        return this.buffer
          ? this.buffer.buffer.childString(this.index)
          : this._tree.toString()
      }
      /**
    @internal
    */
      enterChild(dir, pos, side) {
        if (!this.buffer)
          return this.yield(
            this._tree.nextChild(
              dir < 0 ? this._tree._tree.children.length - 1 : 0,
              dir,
              pos,
              side,
              this.mode
            )
          )
        let { buffer } = this.buffer
        let index = buffer.findChild(
          this.index + 4,
          buffer.buffer[this.index + 3],
          dir,
          pos - this.buffer.start,
          side
        )
        if (index < 0) return false
        this.stack.push(this.index)
        return this.yieldBuf(index)
      }
      /**
    Move the cursor to this node's first child. When this returns
    false, the node has no child, and the cursor has not been moved.
    */
      firstChild() {
        return this.enterChild(1, 0, 4 /* Side.DontCare */)
      }
      /**
    Move the cursor to this node's last child.
    */
      lastChild() {
        return this.enterChild(-1, 0, 4 /* Side.DontCare */)
      }
      /**
    Move the cursor to the first child that ends after `pos`.
    */
      childAfter(pos) {
        return this.enterChild(1, pos, 2 /* Side.After */)
      }
      /**
    Move to the last child that starts before `pos`.
    */
      childBefore(pos) {
        return this.enterChild(-1, pos, -2 /* Side.Before */)
      }
      /**
    Move the cursor to the child around `pos`. If side is -1 the
    child may end at that position, when 1 it may start there. This
    will also enter [overlaid](#common.MountedTree.overlay)
    [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    set to false.
    */
      enter(pos, side, mode = this.mode) {
        if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode))
        return mode & IterMode.ExcludeBuffers
          ? false
          : this.enterChild(1, pos, side)
      }
      /**
    Move to the node's parent node, if this isn't the top node.
    */
      parent() {
        if (!this.buffer)
          return this.yieldNode(
            this.mode & IterMode.IncludeAnonymous
              ? this._tree._parent
              : this._tree.parent
          )
        if (this.stack.length) return this.yieldBuf(this.stack.pop())
        let parent =
          this.mode & IterMode.IncludeAnonymous
            ? this.buffer.parent
            : this.buffer.parent.nextSignificantParent()
        this.buffer = null
        return this.yieldNode(parent)
      }
      /**
    @internal
    */
      sibling(dir) {
        if (!this.buffer)
          return !this._tree._parent
            ? false
            : this.yield(
                this._tree.index < 0
                  ? null
                  : this._tree._parent.nextChild(
                      this._tree.index + dir,
                      dir,
                      0,
                      4 /* Side.DontCare */,
                      this.mode
                    )
              )
        let { buffer } = this.buffer,
          d = this.stack.length - 1
        if (dir < 0) {
          let parentStart = d < 0 ? 0 : this.stack[d] + 4
          if (this.index != parentStart)
            return this.yieldBuf(
              buffer.findChild(
                parentStart,
                this.index,
                -1,
                0,
                4 /* Side.DontCare */
              )
            )
        } else {
          let after = buffer.buffer[this.index + 3]
          if (
            after <
            (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])
          )
            return this.yieldBuf(after)
        }
        return d < 0
          ? this.yield(
              this.buffer.parent.nextChild(
                this.buffer.index + dir,
                dir,
                0,
                4 /* Side.DontCare */,
                this.mode
              )
            )
          : false
      }
      /**
    Move to this node's next sibling, if any.
    */
      nextSibling() {
        return this.sibling(1)
      }
      /**
    Move to this node's previous sibling, if any.
    */
      prevSibling() {
        return this.sibling(-1)
      }
      atLastNode(dir) {
        let index,
          parent,
          { buffer } = this
        if (buffer) {
          if (dir > 0) {
            if (this.index < buffer.buffer.buffer.length) return false
          } else {
            for (let i = 0; i < this.index; i++)
              if (buffer.buffer.buffer[i + 3] < this.index) return false
          }
          ;({ index, parent } = buffer)
        } else {
          ;({ index, _parent: parent } = this._tree)
        }
        for (; parent; { index, _parent: parent } = parent) {
          if (index > -1)
            for (
              let i = index + dir,
                e = dir < 0 ? -1 : parent._tree.children.length;
              i != e;
              i += dir
            ) {
              let child = parent._tree.children[i]
              if (
                this.mode & IterMode.IncludeAnonymous ||
                child instanceof TreeBuffer ||
                !child.type.isAnonymous ||
                hasChild(child)
              )
                return false
            }
        }
        return true
      }
      move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */)) return true
        for (;;) {
          if (this.sibling(dir)) return true
          if (this.atLastNode(dir) || !this.parent()) return false
        }
      }
      /**
    Move to the next node in a
    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
    traversal, going from a node to its first child or, if the
    current node is empty or `enter` is false, its next sibling or
    the next sibling of the first parent node that has one.
    */
      next(enter = true) {
        return this.move(1, enter)
      }
      /**
    Move to the next node in a last-to-first pre-order traveral. A
    node is followed by its last child or, if it has none, its
    previous sibling or the previous sibling of the first parent
    node that has one.
    */
      prev(enter = true) {
        return this.move(-1, enter)
      }
      /**
    Move the cursor to the innermost node that covers `pos`. If
    `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    it will enter nodes that start at `pos`.
    */
      moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (
          this.from == this.to ||
          (side < 1 ? this.from >= pos : this.from > pos) ||
          (side > -1 ? this.to <= pos : this.to < pos)
        )
          if (!this.parent()) break
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) {}
        return this
      }
      /**
    Get a [syntax node](#common.SyntaxNode) at the cursor's current
    position.
    */
      get node() {
        if (!this.buffer) return this._tree
        let cache = this.bufferNode,
          result = null,
          depth = 0
        if (cache && cache.context == this.buffer) {
          scan: for (let index = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache; c; c = c._parent)
              if (c.index == index) {
                if (index == this.index) return c
                result = c
                depth = d + 1
                break scan
              }
            index = this.stack[--d]
          }
        }
        for (let i = depth; i < this.stack.length; i++)
          result = new BufferNode(this.buffer, result, this.stack[i])
        return (this.bufferNode = new BufferNode(
          this.buffer,
          result,
          this.index
        ))
      }
      /**
    Get the [tree](#common.Tree) that represents the current node, if
    any. Will return null when the node is in a [tree
    buffer](#common.TreeBuffer).
    */
      get tree() {
        return this.buffer ? null : this._tree._tree
      }
      /**
    Iterate over the current node and all its descendants, calling
    `enter` when entering a node and `leave`, if given, when leaving
    one. When `enter` returns `false`, any children of that node are
    skipped, and `leave` isn't called for it.
    */
      iterate(enter, leave) {
        for (let depth = 0; ; ) {
          let mustLeave = false
          if (this.type.isAnonymous || enter(this) !== false) {
            if (this.firstChild()) {
              depth++
              continue
            }
            if (!this.type.isAnonymous) mustLeave = true
          }
          for (;;) {
            if (mustLeave && leave) leave(this)
            mustLeave = this.type.isAnonymous
            if (this.nextSibling()) break
            if (!depth) return
            this.parent()
            depth--
            mustLeave = true
          }
        }
      }
      /**
    Test whether the current node matches a given context—a sequence
    of direct parent node names. Empty strings in the context array
    are treated as wildcards.
    */
      matchContext(context) {
        if (!this.buffer) return matchNodeContext(this.node, context)
        let { buffer } = this.buffer,
          { types } = buffer.set
        for (
          let i = context.length - 1, d = this.stack.length - 1;
          i >= 0;
          d--
        ) {
          if (d < 0) return matchNodeContext(this.node, context, i)
          let type = types[buffer.buffer[this.stack[d]]]
          if (!type.isAnonymous) {
            if (context[i] && context[i] != type.name) return false
            i--
          }
        }
        return true
      }
    }
    function hasChild(tree) {
      return tree.children.some(
        (ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch)
      )
    }
    function buildTree(data) {
      var _a
      let {
        buffer,
        nodeSet,
        maxBufferLength = DefaultBufferLength,
        reused = [],
        minRepeatType = nodeSet.types.length
      } = data
      let cursor = Array.isArray(buffer)
        ? new FlatBufferCursor(buffer, buffer.length)
        : buffer
      let types = nodeSet.types
      let contextHash = 0,
        lookAhead = 0
      function takeNode(
        parentStart,
        minPos,
        children,
        positions,
        inRepeat,
        depth
      ) {
        let { id, start, end, size } = cursor
        let lookAheadAtStart = lookAhead
        while (size < 0) {
          cursor.next()
          if (size == -1 /* SpecialRecord.Reuse */) {
            let node = reused[id]
            children.push(node)
            positions.push(start - parentStart)
            return
          } else if (size == -3 /* SpecialRecord.ContextChange */) {
            // Context change
            contextHash = id
            return
          } else if (size == -4 /* SpecialRecord.LookAhead */) {
            lookAhead = id
            return
          } else {
            throw new RangeError(`Unrecognized record size: ${size}`)
          }
        }
        let type = types[id],
          node,
          buffer
        let startPos = start - parentStart
        if (
          end - start <= maxBufferLength &&
          (buffer = findBufferSize(cursor.pos - minPos, inRepeat))
        ) {
          // Small enough for a buffer, and no reused nodes inside
          let data = new Uint16Array(buffer.size - buffer.skip)
          let endPos = cursor.pos - buffer.size,
            index = data.length
          while (cursor.pos > endPos)
            index = copyToBuffer(buffer.start, data, index)
          node = new TreeBuffer(data, end - buffer.start, nodeSet)
          startPos = buffer.start - parentStart
        } else {
          // Make it a node
          let endPos = cursor.pos - size
          cursor.next()
          let localChildren = [],
            localPositions = []
          let localInRepeat = id >= minRepeatType ? id : -1
          let lastGroup = 0,
            lastEnd = end
          while (cursor.pos > endPos) {
            if (
              localInRepeat >= 0 &&
              cursor.id == localInRepeat &&
              cursor.size >= 0
            ) {
              if (cursor.end <= lastEnd - maxBufferLength) {
                makeRepeatLeaf(
                  localChildren,
                  localPositions,
                  start,
                  lastGroup,
                  cursor.end,
                  lastEnd,
                  localInRepeat,
                  lookAheadAtStart
                )
                lastGroup = localChildren.length
                lastEnd = cursor.end
              }
              cursor.next()
            } else if (depth > 2500 /* CutOff.Depth */) {
              takeFlatNode(start, endPos, localChildren, localPositions)
            } else {
              takeNode(
                start,
                endPos,
                localChildren,
                localPositions,
                localInRepeat,
                depth + 1
              )
            }
          }
          if (
            localInRepeat >= 0 &&
            lastGroup > 0 &&
            lastGroup < localChildren.length
          )
            makeRepeatLeaf(
              localChildren,
              localPositions,
              start,
              lastGroup,
              start,
              lastEnd,
              localInRepeat,
              lookAheadAtStart
            )
          localChildren.reverse()
          localPositions.reverse()
          if (localInRepeat > -1 && lastGroup > 0) {
            let make = makeBalanced(type)
            node = balanceRange(
              type,
              localChildren,
              localPositions,
              0,
              localChildren.length,
              0,
              end - start,
              make,
              make
            )
          } else {
            node = makeTree(
              type,
              localChildren,
              localPositions,
              end - start,
              lookAheadAtStart - end
            )
          }
        }
        children.push(node)
        positions.push(startPos)
      }
      function takeFlatNode(parentStart, minPos, children, positions) {
        let nodes = [] // Temporary, inverted array of leaf nodes found, with absolute positions
        let nodeCount = 0,
          stopAt = -1
        while (cursor.pos > minPos) {
          let { id, start, end, size } = cursor
          if (size > 4) {
            // Not a leaf
            cursor.next()
          } else if (stopAt > -1 && start < stopAt) {
            break
          } else {
            if (stopAt < 0) stopAt = end - maxBufferLength
            nodes.push(id, start, end)
            nodeCount++
            cursor.next()
          }
        }
        if (nodeCount) {
          let buffer = new Uint16Array(nodeCount * 4)
          let start = nodes[nodes.length - 2]
          for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
            buffer[j++] = nodes[i]
            buffer[j++] = nodes[i + 1] - start
            buffer[j++] = nodes[i + 2] - start
            buffer[j++] = j
          }
          children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet))
          positions.push(start - parentStart)
        }
      }
      function makeBalanced(type) {
        return (children, positions, length) => {
          let lookAhead = 0,
            lastI = children.length - 1,
            last,
            lookAheadProp
          if (lastI >= 0 && (last = children[lastI]) instanceof dist_Tree) {
            if (!lastI && last.type == type && last.length == length)
              return last
            if ((lookAheadProp = last.prop(dist_NodeProp.lookAhead)))
              lookAhead = positions[lastI] + last.length + lookAheadProp
          }
          return makeTree(type, children, positions, length, lookAhead)
        }
      }
      function makeRepeatLeaf(
        children,
        positions,
        base,
        i,
        from,
        to,
        type,
        lookAhead
      ) {
        let localChildren = [],
          localPositions = []
        while (children.length > i) {
          localChildren.push(children.pop())
          localPositions.push(positions.pop() + base - from)
        }
        children.push(
          makeTree(
            nodeSet.types[type],
            localChildren,
            localPositions,
            to - from,
            lookAhead - to
          )
        )
        positions.push(from - base)
      }
      function makeTree(
        type,
        children,
        positions,
        length,
        lookAhead = 0,
        props
      ) {
        if (contextHash) {
          let pair = [dist_NodeProp.contextHash, contextHash]
          props = props ? [pair].concat(props) : [pair]
        }
        if (lookAhead > 25) {
          let pair = [dist_NodeProp.lookAhead, lookAhead]
          props = props ? [pair].concat(props) : [pair]
        }
        return new dist_Tree(type, children, positions, length, props)
      }
      function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork()
        let size = 0,
          start = 0,
          skip = 0,
          minStart = fork.end - maxBufferLength
        let result = { size: 0, start: 0, skip: 0 }
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize = fork.size
          // Pretend nested repeat nodes of the same type don't exist
          if (fork.id == inRepeat && nodeSize >= 0) {
            // Except that we store the current state as a valid return
            // value.
            result.size = size
            result.start = start
            result.skip = skip
            skip += 4
            size += 4
            fork.next()
            continue
          }
          let startPos = fork.pos - nodeSize
          if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break
          let localSkipped = fork.id >= minRepeatType ? 4 : 0
          let nodeStart = fork.start
          fork.next()
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3 /* SpecialRecord.ContextChange */)
                localSkipped += 4
              else break scan
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4
            }
            fork.next()
          }
          start = nodeStart
          size += nodeSize
          skip += localSkipped
        }
        if (inRepeat < 0 || size == maxSize) {
          result.size = size
          result.start = start
          result.skip = skip
        }
        return result.size > 4 ? result : undefined
      }
      function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor
        cursor.next()
        if (size >= 0 && id < minRepeatType) {
          let startIndex = index
          if (size > 4) {
            let endPos = cursor.pos - (size - 4)
            while (cursor.pos > endPos)
              index = copyToBuffer(bufferStart, buffer, index)
          }
          buffer[--index] = startIndex
          buffer[--index] = end - bufferStart
          buffer[--index] = start - bufferStart
          buffer[--index] = id
        } else if (size == -3 /* SpecialRecord.ContextChange */) {
          contextHash = id
        } else if (size == -4 /* SpecialRecord.LookAhead */) {
          lookAhead = id
        }
        return index
      }
      let children = [],
        positions = []
      while (cursor.pos > 0)
        takeNode(
          data.start || 0,
          data.bufferStart || 0,
          children,
          positions,
          -1,
          0
        )
      let length =
        (_a = data.length) !== null && _a !== void 0
          ? _a
          : children.length
            ? positions[0] + children[0].length
            : 0
      return new dist_Tree(
        types[data.topID],
        children.reverse(),
        positions.reverse(),
        length
      )
    }
    const nodeSizeCache = new WeakMap()
    function nodeSize(balanceType, node) {
      if (
        !balanceType.isAnonymous ||
        node instanceof TreeBuffer ||
        node.type != balanceType
      )
        return 1
      let size = nodeSizeCache.get(node)
      if (size == null) {
        size = 1
        for (let child of node.children) {
          if (child.type != balanceType || !(child instanceof dist_Tree)) {
            size = 1
            break
          }
          size += nodeSize(balanceType, child)
        }
        nodeSizeCache.set(node, size)
      }
      return size
    }
    function balanceRange(
      // The type the balanced tree's inner nodes.
      balanceType,
      // The direct children and their positions
      children,
      positions,
      // The index range in children/positions to use
      from,
      to,
      // The start position of the nodes, relative to their parent.
      start,
      // Length of the outer node
      length,
      // Function to build the top node of the balanced tree
      mkTop,
      // Function to build internal nodes for the balanced tree
      mkTree
    ) {
      let total = 0
      for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i])
      let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */)
      let localChildren = [],
        localPositions = []
      function divide(children, positions, from, to, offset) {
        for (let i = from; i < to; ) {
          let groupFrom = i,
            groupStart = positions[i],
            groupSize = nodeSize(balanceType, children[i])
          i++
          for (; i < to; i++) {
            let nextSize = nodeSize(balanceType, children[i])
            if (groupSize + nextSize >= maxChild) break
            groupSize += nextSize
          }
          if (i == groupFrom + 1) {
            if (groupSize > maxChild) {
              let only = children[groupFrom] // Only trees can have a size > 1
              divide(
                only.children,
                only.positions,
                0,
                only.children.length,
                positions[groupFrom] + offset
              )
              continue
            }
            localChildren.push(children[groupFrom])
          } else {
            let length = positions[i - 1] + children[i - 1].length - groupStart
            localChildren.push(
              balanceRange(
                balanceType,
                children,
                positions,
                groupFrom,
                i,
                groupStart,
                length,
                null,
                mkTree
              )
            )
          }
          localPositions.push(groupStart + offset - start)
        }
      }
      divide(children, positions, from, to, 0)
      return (mkTop || mkTree)(localChildren, localPositions, length)
    }
    /**
Provides a way to associate values with pieces of trees. As long
as that part of the tree is reused, the associated values can be
retrieved from an updated tree.
*/
    class NodeWeakMap {
      constructor() {
        this.map = new WeakMap()
      }
      setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer)
        if (!inner) this.map.set(buffer, (inner = new Map()))
        inner.set(index, value)
      }
      getBuffer(buffer, index) {
        let inner = this.map.get(buffer)
        return inner && inner.get(index)
      }
      /**
    Set the value for this syntax node.
    */
      set(node, value) {
        if (node instanceof BufferNode)
          this.setBuffer(node.context.buffer, node.index, value)
        else if (node instanceof TreeNode) this.map.set(node.tree, value)
      }
      /**
    Retrieve value for this syntax node, if it exists in the map.
    */
      get(node) {
        return node instanceof BufferNode
          ? this.getBuffer(node.context.buffer, node.index)
          : node instanceof TreeNode
            ? this.map.get(node.tree)
            : undefined
      }
      /**
    Set the value for the node that a cursor currently points to.
    */
      cursorSet(cursor, value) {
        if (cursor.buffer)
          this.setBuffer(cursor.buffer.buffer, cursor.index, value)
        else this.map.set(cursor.tree, value)
      }
      /**
    Retrieve the value for the node that a cursor currently points
    to.
    */
      cursorGet(cursor) {
        return cursor.buffer
          ? this.getBuffer(cursor.buffer.buffer, cursor.index)
          : this.map.get(cursor.tree)
      }
    }

    /**
Tree fragments are used during [incremental
parsing](#common.Parser.startParse) to track parts of old trees
that can be reused in a new parse. An array of fragments is used
to track regions of an old tree whose nodes might be reused in new
parses. Use the static
[`applyChanges`](#common.TreeFragment^applyChanges) method to
update fragments for document changes.
*/
    class TreeFragment {
      /**
    Construct a tree fragment. You'll usually want to use
    [`addTree`](#common.TreeFragment^addTree) and
    [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    calling this directly.
    */
      constructor(
        /**
    The start of the unchanged range pointed to by this fragment.
    This refers to an offset in the _updated_ document (as opposed
    to the original tree).
    */
        from,
        /**
    The end of the unchanged range.
    */
        to,
        /**
    The tree that this fragment is based on.
    */
        tree,
        /**
    The offset between the fragment's tree and the document that
    this fragment can be used against. Add this when going from
    document to tree positions, subtract it to go from tree to
    document positions.
    */
        offset,
        openStart = false,
        openEnd = false
      ) {
        this.from = from
        this.to = to
        this.tree = tree
        this.offset = offset
        this.open =
          (openStart ? 1 /* Open.Start */ : 0) |
          (openEnd ? 2 /* Open.End */ : 0)
      }
      /**
    Whether the start of the fragment represents the start of a
    parse, or the end of a change. (In the second case, it may not
    be safe to reuse some nodes at the start, depending on the
    parsing algorithm.)
    */
      get openStart() {
        return (this.open & 1) /* Open.Start */ > 0
      }
      /**
    Whether the end of the fragment represents the end of a
    full-document parse, or the start of a change.
    */
      get openEnd() {
        return (this.open & 2) /* Open.End */ > 0
      }
      /**
    Create a set of fragments from a freshly parsed tree, or update
    an existing set of fragments by replacing the ones that overlap
    with a tree with content from the new tree. When `partial` is
    true, the parse is treated as incomplete, and the resulting
    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    true.
    */
      static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)]
        for (let f of fragments) if (f.to > tree.length) result.push(f)
        return result
      }
      /**
    Apply a set of edits to an array of fragments, removing or
    splitting fragments as necessary to remove edited ranges, and
    adjusting offsets for fragments that moved.
    */
      static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length) return fragments
        let result = []
        let fI = 1,
          nextF = fragments.length ? fragments[0] : null
        for (let cI = 0, pos = 0, off = 0; ; cI++) {
          let nextC = cI < changes.length ? changes[cI] : null
          let nextPos = nextC ? nextC.fromA : 1e9
          if (nextPos - pos >= minGap)
            while (nextF && nextF.from < nextPos) {
              let cut = nextF
              if (pos >= cut.from || nextPos <= cut.to || off) {
                let fFrom = Math.max(cut.from, pos) - off,
                  fTo = Math.min(cut.to, nextPos) - off
                cut =
                  fFrom >= fTo
                    ? null
                    : new TreeFragment(
                        fFrom,
                        fTo,
                        cut.tree,
                        cut.offset + off,
                        cI > 0,
                        !!nextC
                      )
              }
              if (cut) result.push(cut)
              if (nextF.to > nextPos) break
              nextF = fI < fragments.length ? fragments[fI++] : null
            }
          if (!nextC) break
          pos = nextC.toA
          off = nextC.toA - nextC.toB
        }
        return result
      }
    }
    /**
A superclass that parsers should extend.
*/
    class dist_Parser {
      /**
    Start a parse, returning a [partial parse](#common.PartialParse)
    object. [`fragments`](#common.TreeFragment) can be passed in to
    make the parse incremental.
    
    By default, the entire input is parsed. You can pass `ranges`,
    which should be a sorted array of non-empty, non-overlapping
    ranges, to parse only those ranges. The tree returned in that
    case will start at `ranges[0].from`.
    */
      startParse(input, fragments, ranges) {
        if (typeof input == 'string') input = new StringInput(input)
        ranges = !ranges
          ? [new dist_Range(0, input.length)]
          : ranges.length
            ? ranges.map((r) => new dist_Range(r.from, r.to))
            : [new dist_Range(0, 0)]
        return this.createParse(input, fragments || [], ranges)
      }
      /**
    Run a full parse, returning the resulting tree.
    */
      parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges)
        for (;;) {
          let done = parse.advance()
          if (done) return done
        }
      }
    }
    class StringInput {
      constructor(string) {
        this.string = string
      }
      get length() {
        return this.string.length
      }
      chunk(from) {
        return this.string.slice(from)
      }
      get lineChunks() {
        return false
      }
      read(from, to) {
        return this.string.slice(from, to)
      }
    }

    /**
Create a parse wrapper that, after the inner parse completes,
scans its tree for mixed language regions with the `nest`
function, runs the resulting [inner parses](#common.NestedParse),
and then [mounts](#common.NodeProp^mounted) their results onto the
tree.
*/
    function parseMixed(nest) {
      return (parse, input, fragments, ranges) =>
        new MixedParse(parse, nest, input, fragments, ranges)
    }
    class InnerParse {
      constructor(parser, parse, overlay, target, from) {
        this.parser = parser
        this.parse = parse
        this.overlay = overlay
        this.target = target
        this.from = from
      }
    }
    function checkRanges(ranges) {
      if (!ranges.length || ranges.some((r) => r.from >= r.to))
        throw new RangeError(
          'Invalid inner parse ranges given: ' + JSON.stringify(ranges)
        )
    }
    class ActiveOverlay {
      constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser
        this.predicate = predicate
        this.mounts = mounts
        this.index = index
        this.start = start
        this.target = target
        this.prev = prev
        this.depth = 0
        this.ranges = []
      }
    }
    const stoppedInner = new dist_NodeProp({ perNode: true })
    class MixedParse {
      constructor(base, nest, input, fragments, ranges) {
        this.nest = nest
        this.input = input
        this.fragments = fragments
        this.ranges = ranges
        this.inner = []
        this.innerDone = 0
        this.baseTree = null
        this.stoppedAt = null
        this.baseParse = base
      }
      advance() {
        if (this.baseParse) {
          let done = this.baseParse.advance()
          if (!done) return null
          this.baseParse = null
          this.baseTree = done
          this.startInner()
          if (this.stoppedAt != null)
            for (let inner of this.inner) inner.parse.stopAt(this.stoppedAt)
        }
        if (this.innerDone == this.inner.length) {
          let result = this.baseTree
          if (this.stoppedAt != null)
            result = new dist_Tree(
              result.type,
              result.children,
              result.positions,
              result.length,
              result.propValues.concat([[stoppedInner, this.stoppedAt]])
            )
          return result
        }
        let inner = this.inner[this.innerDone],
          done = inner.parse.advance()
        if (done) {
          this.innerDone++
          // This is a somewhat dodgy but super helpful hack where we
          // patch up nodes created by the inner parse (and thus
          // presumably not aliased anywhere else) to hold the information
          // about the inner parse.
          let props = Object.assign(Object.create(null), inner.target.props)
          props[dist_NodeProp.mounted.id] = new MountedTree(
            done,
            inner.overlay,
            inner.parser
          )
          inner.target.props = props
        }
        return null
      }
      get parsedPos() {
        if (this.baseParse) return 0
        let pos = this.input.length
        for (let i = this.innerDone; i < this.inner.length; i++) {
          if (this.inner[i].from < pos)
            pos = Math.min(pos, this.inner[i].parse.parsedPos)
        }
        return pos
      }
      stopAt(pos) {
        this.stoppedAt = pos
        if (this.baseParse) this.baseParse.stopAt(pos)
        else
          for (let i = this.innerDone; i < this.inner.length; i++)
            this.inner[i].parse.stopAt(pos)
      }
      startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments)
        let overlay = null
        let covered = null
        let cursor = new TreeCursor(
          new TreeNode(this.baseTree, this.ranges[0].from, 0, null),
          IterMode.IncludeAnonymous | IterMode.IgnoreMounts
        )
        scan: for (let nest, isCovered; ; ) {
          let enter = true,
            range
          if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {
            enter = false
          } else if (fragmentCursor.hasNode(cursor)) {
            if (overlay) {
              let match = overlay.mounts.find(
                (m) =>
                  m.frag.from <= cursor.from &&
                  m.frag.to >= cursor.to &&
                  m.mount.overlay
              )
              if (match)
                for (let r of match.mount.overlay) {
                  let from = r.from + match.pos,
                    to = r.to + match.pos
                  if (
                    from >= cursor.from &&
                    to <= cursor.to &&
                    !overlay.ranges.some((r) => r.from < to && r.to > from)
                  )
                    overlay.ranges.push({ from, to })
                }
            }
            enter = false
          } else if (
            covered &&
            (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))
          ) {
            enter = isCovered != 2 /* Cover.Full */
          } else if (
            !cursor.type.isAnonymous &&
            (nest = this.nest(cursor, this.input)) &&
            (cursor.from < cursor.to || !nest.overlay)
          ) {
            if (!cursor.tree) materialize(cursor)
            let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser)
            if (typeof nest.overlay == 'function') {
              overlay = new ActiveOverlay(
                nest.parser,
                nest.overlay,
                oldMounts,
                this.inner.length,
                cursor.from,
                cursor.tree,
                overlay
              )
            } else {
              let ranges = punchRanges(
                this.ranges,
                nest.overlay ||
                  (cursor.from < cursor.to
                    ? [new dist_Range(cursor.from, cursor.to)]
                    : [])
              )
              if (ranges.length) checkRanges(ranges)
              if (ranges.length || !nest.overlay)
                this.inner.push(
                  new InnerParse(
                    nest.parser,
                    ranges.length
                      ? nest.parser.startParse(
                          this.input,
                          enterFragments(oldMounts, ranges),
                          ranges
                        )
                      : nest.parser.startParse(''),
                    nest.overlay
                      ? nest.overlay.map(
                          (r) =>
                            new dist_Range(
                              r.from - cursor.from,
                              r.to - cursor.from
                            )
                        )
                      : null,
                    cursor.tree,
                    ranges.length ? ranges[0].from : cursor.from
                  )
                )
              if (!nest.overlay) enter = false
              else if (ranges.length)
                covered = { ranges, depth: 0, prev: covered }
            }
          } else if (overlay && (range = overlay.predicate(cursor))) {
            if (range === true) range = new dist_Range(cursor.from, cursor.to)
            if (range.from < range.to) overlay.ranges.push(range)
          }
          if (enter && cursor.firstChild()) {
            if (overlay) overlay.depth++
            if (covered) covered.depth++
          } else {
            for (;;) {
              if (cursor.nextSibling()) break
              if (!cursor.parent()) break scan
              if (overlay && !--overlay.depth) {
                let ranges = punchRanges(this.ranges, overlay.ranges)
                if (ranges.length) {
                  checkRanges(ranges)
                  this.inner.splice(
                    overlay.index,
                    0,
                    new InnerParse(
                      overlay.parser,
                      overlay.parser.startParse(
                        this.input,
                        enterFragments(overlay.mounts, ranges),
                        ranges
                      ),
                      overlay.ranges.map(
                        (r) =>
                          new dist_Range(
                            r.from - overlay.start,
                            r.to - overlay.start
                          )
                      ),
                      overlay.target,
                      ranges[0].from
                    )
                  )
                }
                overlay = overlay.prev
              }
              if (covered && !--covered.depth) covered = covered.prev
            }
          }
        }
      }
    }
    function checkCover(covered, from, to) {
      for (let range of covered) {
        if (range.from >= to) break
        if (range.to > from)
          return range.from <= from && range.to >= to
            ? 2 /* Cover.Full */
            : 1 /* Cover.Partial */
      }
      return 0 /* Cover.None */
    }
    // Take a piece of buffer and convert it into a stand-alone
    // TreeBuffer.
    function sliceBuf(buf, startI, endI, nodes, positions, off) {
      if (startI < endI) {
        let from = buf.buffer[startI + 1]
        nodes.push(buf.slice(startI, endI, from))
        positions.push(from - off)
      }
    }
    // This function takes a node that's in a buffer, and converts it, and
    // its parent buffer nodes, into a Tree. This is again acting on the
    // assumption that the trees and buffers have been constructed by the
    // parse that was ran via the mix parser, and thus aren't shared with
    // any other code, making violations of the immutability safe.
    function materialize(cursor) {
      let { node } = cursor,
        stack = []
      let buffer = node.context.buffer
      // Scan up to the nearest tree
      do {
        stack.push(cursor.index)
        cursor.parent()
      } while (!cursor.tree)
      // Find the index of the buffer in that tree
      let base = cursor.tree,
        i = base.children.indexOf(buffer)
      let buf = base.children[i],
        b = buf.buffer,
        newStack = [i]
      // Split a level in the buffer, putting the nodes before and after
      // the child that contains `node` into new buffers.
      function split(startI, endI, type, innerOffset, length, stackPos) {
        let targetI = stack[stackPos]
        let children = [],
          positions = []
        sliceBuf(buf, startI, targetI, children, positions, innerOffset)
        let from = b[targetI + 1],
          to = b[targetI + 2]
        newStack.push(children.length)
        let child = stackPos
          ? split(
              targetI + 4,
              b[targetI + 3],
              buf.set.types[b[targetI]],
              from,
              to - from,
              stackPos - 1
            )
          : node.toTree()
        children.push(child)
        positions.push(from - innerOffset)
        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset)
        return new dist_Tree(type, children, positions, length)
      }
      base.children[i] = split(
        0,
        b.length,
        dist_NodeType.none,
        0,
        buf.length,
        stack.length - 1
      )
      // Move the cursor back to the target node
      for (let index of newStack) {
        let tree = cursor.tree.children[index],
          pos = cursor.tree.positions[index]
        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree))
      }
    }
    class StructureCursor {
      constructor(root, offset) {
        this.offset = offset
        this.done = false
        this.cursor = root.cursor(
          IterMode.IncludeAnonymous | IterMode.IgnoreMounts
        )
      }
      // Move to the first node (in pre-order) that starts at or after `pos`.
      moveTo(pos) {
        let { cursor } = this,
          p = pos - this.offset
        while (!this.done && cursor.from < p) {
          if (
            cursor.to >= pos &&
            cursor.enter(
              p,
              1,
              IterMode.IgnoreOverlays | IterMode.ExcludeBuffers
            )
          );
          else if (!cursor.next(false)) this.done = true
        }
      }
      hasNode(cursor) {
        this.moveTo(cursor.from)
        if (
          !this.done &&
          this.cursor.from + this.offset == cursor.from &&
          this.cursor.tree
        ) {
          for (let tree = this.cursor.tree; ; ) {
            if (tree == cursor.tree) return true
            if (
              tree.children.length &&
              tree.positions[0] == 0 &&
              tree.children[0] instanceof dist_Tree
            )
              tree = tree.children[0]
            else break
          }
        }
        return false
      }
    }
    class FragmentCursor {
      constructor(fragments) {
        var _a
        this.fragments = fragments
        this.curTo = 0
        this.fragI = 0
        if (fragments.length) {
          let first = (this.curFrag = fragments[0])
          this.curTo =
            (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0
              ? _a
              : first.to
          this.inner = new StructureCursor(first.tree, -first.offset)
        } else {
          this.curFrag = this.inner = null
        }
      }
      hasNode(node) {
        while (this.curFrag && node.from >= this.curTo) this.nextFrag()
        return (
          this.curFrag &&
          this.curFrag.from <= node.from &&
          this.curTo >= node.to &&
          this.inner.hasNode(node)
        )
      }
      nextFrag() {
        var _a
        this.fragI++
        if (this.fragI == this.fragments.length) {
          this.curFrag = this.inner = null
        } else {
          let frag = (this.curFrag = this.fragments[this.fragI])
          this.curTo =
            (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0
              ? _a
              : frag.to
          this.inner = new StructureCursor(frag.tree, -frag.offset)
        }
      }
      findMounts(pos, parser) {
        var _a
        let result = []
        if (this.inner) {
          this.inner.cursor.moveTo(pos, 1)
          for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
            let mount =
              (_a = pos.tree) === null || _a === void 0
                ? void 0
                : _a.prop(dist_NodeProp.mounted)
            if (mount && mount.parser == parser) {
              for (let i = this.fragI; i < this.fragments.length; i++) {
                let frag = this.fragments[i]
                if (frag.from >= pos.to) break
                if (frag.tree == this.curFrag.tree)
                  result.push({
                    frag,
                    pos: pos.from - frag.offset,
                    mount
                  })
              }
            }
          }
        }
        return result
      }
    }
    function punchRanges(outer, ranges) {
      let copy = null,
        current = ranges
      for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to,
          gapTo = outer[i].from
        for (; j < current.length; j++) {
          let r = current[j]
          if (r.from >= gapTo) break
          if (r.to <= gapFrom) continue
          if (!copy) current = copy = ranges.slice()
          if (r.from < gapFrom) {
            copy[j] = new dist_Range(r.from, gapFrom)
            if (r.to > gapTo) copy.splice(j + 1, 0, new dist_Range(gapTo, r.to))
          } else if (r.to > gapTo) {
            copy[j--] = new dist_Range(gapTo, r.to)
          } else {
            copy.splice(j--, 1)
          }
        }
      }
      return current
    }
    function findCoverChanges(a, b, from, to) {
      let iA = 0,
        iB = 0,
        inA = false,
        inB = false,
        pos = -1e9
      let result = []
      for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from
        if (inA != inB) {
          let start = Math.max(pos, from),
            end = Math.min(nextA, nextB, to)
          if (start < end) result.push(new dist_Range(start, end))
        }
        pos = Math.min(nextA, nextB)
        if (pos == 1e9) break
        if (nextA == pos) {
          if (!inA) inA = true
          else {
            inA = false
            iA++
          }
        }
        if (nextB == pos) {
          if (!inB) inB = true
          else {
            inB = false
            iB++
          }
        }
      }
      return result
    }
    // Given a number of fragments for the outer tree, and a set of ranges
    // to parse, find fragments for inner trees mounted around those
    // ranges, if any.
    function enterFragments(mounts, ranges) {
      let result = []
      for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),
          endPos = startPos + mount.tree.length
        let from = Math.max(frag.from, startPos),
          to = Math.min(frag.to, endPos)
        if (mount.overlay) {
          let overlay = mount.overlay.map(
            (r) => new dist_Range(r.from + pos, r.to + pos)
          )
          let changes = findCoverChanges(ranges, overlay, from, to)
          for (let i = 0, pos = from; ; i++) {
            let last = i == changes.length,
              end = last ? to : changes[i].from
            if (end > pos)
              result.push(
                new TreeFragment(
                  pos,
                  end,
                  mount.tree,
                  -startPos,
                  frag.from >= pos || frag.openStart,
                  frag.to <= end || frag.openEnd
                )
              )
            if (last) break
            pos = changes[i].to
          }
        } else {
          result.push(
            new TreeFragment(
              from,
              to,
              mount.tree,
              -startPos,
              frag.from >= startPos || frag.openStart,
              frag.to <= endPos || frag.openEnd
            )
          )
        }
      }
      return result
    } // CONCATENATED MODULE: ./node_modules/@lezer/highlight/dist/index.js

    let nextTagID = 0
    /**
Highlighting tags are markers that denote a highlighting category.
They are [associated](#highlight.styleTags) with parts of a syntax
tree by a language mode, and then mapped to an actual CSS style by
a [highlighter](#highlight.Highlighter).

Because syntax tree node types and highlight styles have to be
able to talk the same language, CodeMirror uses a mostly _closed_
[vocabulary](#highlight.tags) of syntax tags (as opposed to
traditional open string-based systems, which make it hard for
highlighting themes to cover all the tokens produced by the
various languages).

It _is_ possible to [define](#highlight.Tag^define) your own
highlighting tags for system-internal use (where you control both
the language package and the highlighter), but such tags will not
be picked up by regular highlighters (though you can derive them
from standard tags to allow highlighters to fall back to those).
*/
    class Tag {
      /**
    @internal
    */
      constructor(
        /**
    The set of this tag and all its parent tags, starting with
    this one itself and sorted in order of decreasing specificity.
    */
        set,
        /**
    The base unmodified tag that this one is based on, if it's
    modified @internal
    */
        base,
        /**
    The modifiers applied to this.base @internal
    */
        modified
      ) {
        this.set = set
        this.base = base
        this.modified = modified
        /**
        @internal
        */
        this.id = nextTagID++
      }
      /**
    Define a new tag. If `parent` is given, the tag is treated as a
    sub-tag of that parent, and
    [highlighters](#highlight.tagHighlighter) that don't mention
    this tag will try to fall back to the parent tag (or grandparent
    tag, etc).
    */
      static define(parent) {
        if (parent === null || parent === void 0 ? void 0 : parent.base)
          throw new Error('Can not derive from a modified tag')
        let tag = new Tag([], null, [])
        tag.set.push(tag)
        if (parent) for (let t of parent.set) tag.set.push(t)
        return tag
      }
      /**
    Define a tag _modifier_, which is a function that, given a tag,
    will return a tag that is a subtag of the original. Applying the
    same modifier to a twice tag will return the same value (`m1(t1)
    == m1(t1)`) and applying multiple modifiers will, regardless or
    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    
    When multiple modifiers are applied to a given base tag, each
    smaller set of modifiers is registered as a parent, so that for
    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    `m1(m3(t1)`, and so on.
    */
      static defineModifier() {
        let mod = new Modifier()
        return (tag) => {
          if (tag.modified.indexOf(mod) > -1) return tag
          return Modifier.get(
            tag.base || tag,
            tag.modified.concat(mod).sort((a, b) => a.id - b.id)
          )
        }
      }
    }
    let nextModifierID = 0
    class Modifier {
      constructor() {
        this.instances = []
        this.id = nextModifierID++
      }
      static get(base, mods) {
        if (!mods.length) return base
        let exists = mods[0].instances.find(
          (t) => t.base == base && dist_sameArray(mods, t.modified)
        )
        if (exists) return exists
        let set = [],
          tag = new Tag(set, base, mods)
        for (let m of mods) m.instances.push(tag)
        let configs = powerSet(mods)
        for (let parent of base.set)
          if (!parent.modified.length)
            for (let config of configs) set.push(Modifier.get(parent, config))
        return tag
      }
    }
    function dist_sameArray(a, b) {
      return a.length == b.length && a.every((x, i) => x == b[i])
    }
    function powerSet(array) {
      let sets = [[]]
      for (let i = 0; i < array.length; i++) {
        for (let j = 0, e = sets.length; j < e; j++) {
          sets.push(sets[j].concat(array[i]))
        }
      }
      return sets.sort((a, b) => b.length - a.length)
    }
    /**
This function is used to add a set of tags to a language syntax
via [`NodeSet.extend`](#common.NodeSet.extend) or
[`LRParser.configure`](#lr.LRParser.configure).

The argument object maps node selectors to [highlighting
tags](#highlight.Tag) or arrays of tags.

Node selectors may hold one or more (space-separated) node paths.
Such a path can be a [node name](#common.NodeType.name), or
multiple node names (or `*` wildcards) separated by slash
characters, as in `"Block/Declaration/VariableName"`. Such a path
matches the final node but only if its direct parent nodes are the
other nodes mentioned. A `*` in such a path matches any parent,
but only a single level—wildcards that match multiple parents
aren't supported, both for efficiency reasons and because Lezer
trees make it rather hard to reason about what they would match.)

A path can be ended with `/...` to indicate that the tag assigned
to the node should also apply to all child nodes, even if they
match their own style (by default, only the innermost style is
used).

When a path ends in `!`, as in `Attribute!`, no further matching
happens for the node's child nodes, and the entire node gets the
given style.

In this notation, node names that contain `/`, `!`, `*`, or `...`
must be quoted as JSON strings.

For example:

```javascript
parser.withProps(
  styleTags({
    // Style Number and BigNumber nodes
    "Number BigNumber": tags.number,
    // Style Escape nodes whose parent is String
    "String/Escape": tags.escape,
    // Style anything inside Attributes nodes
    "Attributes!": tags.meta,
    // Add a style to all content inside Italic nodes
    "Italic/...": tags.emphasis,
    // Style InvalidString nodes as both `string` and `invalid`
    "InvalidString": [tags.string, tags.invalid],
    // Style the node named "/" as punctuation
    '"/"': tags.punctuation
  })
)
```
*/
    function styleTags(spec) {
      let byName = Object.create(null)
      for (let prop in spec) {
        let tags = spec[prop]
        if (!Array.isArray(tags)) tags = [tags]
        for (let part of prop.split(' '))
          if (part) {
            let pieces = [],
              mode = 2 /* Mode.Normal */,
              rest = part
            for (let pos = 0; ; ) {
              if (rest == '...' && pos > 0 && pos + 3 == part.length) {
                mode = 1 /* Mode.Inherit */
                break
              }
              let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest)
              if (!m) throw new RangeError('Invalid path: ' + part)
              pieces.push(
                m[0] == '*' ? '' : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]
              )
              pos += m[0].length
              if (pos == part.length) break
              let next = part[pos++]
              if (pos == part.length && next == '!') {
                mode = 0 /* Mode.Opaque */
                break
              }
              if (next != '/') throw new RangeError('Invalid path: ' + part)
              rest = part.slice(pos)
            }
            let last = pieces.length - 1,
              inner = pieces[last]
            if (!inner) throw new RangeError('Invalid path: ' + part)
            let rule = new Rule(
              tags,
              mode,
              last > 0 ? pieces.slice(0, last) : null
            )
            byName[inner] = rule.sort(byName[inner])
          }
      }
      return ruleNodeProp.add(byName)
    }
    const ruleNodeProp = new dist_NodeProp()
    class Rule {
      constructor(tags, mode, context, next) {
        this.tags = tags
        this.mode = mode
        this.context = context
        this.next = next
      }
      get opaque() {
        return this.mode == 0 /* Mode.Opaque */
      }
      get inherit() {
        return this.mode == 1 /* Mode.Inherit */
      }
      sort(other) {
        if (!other || other.depth < this.depth) {
          this.next = other
          return this
        }
        other.next = this.sort(other.next)
        return other
      }
      get depth() {
        return this.context ? this.context.length : 0
      }
    }
    Rule.empty = new Rule([], 2 /* Mode.Normal */, null)
    /**
Define a [highlighter](#highlight.Highlighter) from an array of
tag/class pairs. Classes associated with more specific tags will
take precedence.
*/
    function tagHighlighter(tags, options) {
      let map = Object.create(null)
      for (let style of tags) {
        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class
        else for (let tag of style.tag) map[tag.id] = style.class
      }
      let { scope, all = null } = options || {}
      return {
        style: (tags) => {
          let cls = all
          for (let tag of tags) {
            for (let sub of tag.set) {
              let tagClass = map[sub.id]
              if (tagClass) {
                cls = cls ? cls + ' ' + tagClass : tagClass
                break
              }
            }
          }
          return cls
        },
        scope
      }
    }
    function highlightTags(highlighters, tags) {
      let result = null
      for (let highlighter of highlighters) {
        let value = highlighter.style(tags)
        if (value) result = result ? result + ' ' + value : value
      }
      return result
    }
    /**
Highlight the given [tree](#common.Tree) with the given
[highlighter](#highlight.Highlighter). Often, the higher-level
[`highlightCode`](#highlight.highlightCode) function is easier to
use.
*/
    function highlightTree(
      tree,
      highlighter,
      /**
Assign styling to a region of the text. Will be called, in order
of position, for any ranges where more than zero classes apply.
`classes` is a space separated string of CSS classes.
*/
      putStyle,
      /**
The start of the range to highlight.
*/
      from = 0,
      /**
The end of the range.
*/
      to = tree.length
    ) {
      let builder = new HighlightBuilder(
        from,
        Array.isArray(highlighter) ? highlighter : [highlighter],
        putStyle
      )
      builder.highlightRange(tree.cursor(), from, to, '', builder.highlighters)
      builder.flush(to)
    }
    /**
Highlight the given tree with the given highlighter, calling
`putText` for every piece of text, either with a set of classes or
with the empty string when unstyled, and `putBreak` for every line
break.
*/
    function highlightCode(
      code,
      tree,
      highlighter,
      putText,
      putBreak,
      from = 0,
      to = code.length
    ) {
      let pos = from
      function writeTo(p, classes) {
        if (p <= pos) return
        for (let text = code.slice(pos, p), i = 0; ; ) {
          let nextBreak = text.indexOf('\n', i)
          let upto = nextBreak < 0 ? text.length : nextBreak
          if (upto > i) putText(text.slice(i, upto), classes)
          if (nextBreak < 0) break
          putBreak()
          i = nextBreak + 1
        }
        pos = p
      }
      highlightTree(
        tree,
        highlighter,
        (from, to, classes) => {
          writeTo(from, '')
          writeTo(to, classes)
        },
        from,
        to
      )
      writeTo(to, '')
    }
    class HighlightBuilder {
      constructor(at, highlighters, span) {
        this.at = at
        this.highlighters = highlighters
        this.span = span
        this.class = ''
      }
      startSpan(at, cls) {
        if (cls != this.class) {
          this.flush(at)
          if (at > this.at) this.at = at
          this.class = cls
        }
      }
      flush(to) {
        if (to > this.at && this.class) this.span(this.at, to, this.class)
      }
      highlightRange(cursor, from, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor
        if (start >= to || end <= from) return
        if (type.isTop)
          highlighters = this.highlighters.filter(
            (h) => !h.scope || h.scope(type)
          )
        let cls = inheritedClass
        let rule = getStyleTags(cursor) || Rule.empty
        let tagCls = highlightTags(highlighters, rule.tags)
        if (tagCls) {
          if (cls) cls += ' '
          cls += tagCls
          if (rule.mode == 1 /* Mode.Inherit */)
            inheritedClass += (inheritedClass ? ' ' : '') + tagCls
        }
        this.startSpan(Math.max(from, start), cls)
        if (rule.opaque) return
        let mounted = cursor.tree && cursor.tree.prop(dist_NodeProp.mounted)
        if (mounted && mounted.overlay) {
          let inner = cursor.node.enter(mounted.overlay[0].from + start, 1)
          let innerHighlighters = this.highlighters.filter(
            (h) => !h.scope || h.scope(mounted.tree.type)
          )
          let hasChild = cursor.firstChild()
          for (let i = 0, pos = start; ; i++) {
            let next = i < mounted.overlay.length ? mounted.overlay[i] : null
            let nextPos = next ? next.from + start : end
            let rangeFrom = Math.max(from, pos),
              rangeTo = Math.min(to, nextPos)
            if (rangeFrom < rangeTo && hasChild) {
              while (cursor.from < rangeTo) {
                this.highlightRange(
                  cursor,
                  rangeFrom,
                  rangeTo,
                  inheritedClass,
                  highlighters
                )
                this.startSpan(Math.min(rangeTo, cursor.to), cls)
                if (cursor.to >= nextPos || !cursor.nextSibling()) break
              }
            }
            if (!next || nextPos > to) break
            pos = next.to + start
            if (pos > from) {
              this.highlightRange(
                inner.cursor(),
                Math.max(from, next.from + start),
                Math.min(to, pos),
                '',
                innerHighlighters
              )
              this.startSpan(Math.min(to, pos), cls)
            }
          }
          if (hasChild) cursor.parent()
        } else if (cursor.firstChild()) {
          if (mounted) inheritedClass = ''
          do {
            if (cursor.to <= from) continue
            if (cursor.from >= to) break
            this.highlightRange(cursor, from, to, inheritedClass, highlighters)
            this.startSpan(Math.min(to, cursor.to), cls)
          } while (cursor.nextSibling())
          cursor.parent()
        }
      }
    }
    /**
Match a syntax node's [highlight rules](#highlight.styleTags). If
there's a match, return its set of tags, and whether it is
opaque (uses a `!`) or applies to all child nodes (`/...`).
*/
    function getStyleTags(node) {
      let rule = node.type.prop(ruleNodeProp)
      while (rule && rule.context && !node.matchContext(rule.context))
        rule = rule.next
      return rule || null
    }
    const t = Tag.define
    const comment = t(),
      dist_name = t(),
      typeName = t(dist_name),
      propertyName = t(dist_name),
      literal = t(),
      string = t(literal),
      number = t(literal),
      content = t(),
      heading = t(content),
      keyword = t(),
      operator = t(),
      punctuation = t(),
      bracket = t(punctuation),
      meta = t()
    /**
The default set of highlighting [tags](#highlight.Tag).

This collection is heavily biased towards programming languages,
and necessarily incomplete. A full ontology of syntactic
constructs would fill a stack of books, and be impractical to
write themes for. So try to make do with this set. If all else
fails, [open an
issue](https://github.com/codemirror/codemirror.next) to propose a
new tag, or [define](#highlight.Tag^define) a local custom tag for
your use case.

Note that it is not obligatory to always attach the most specific
tag possible to an element—if your grammar can't easily
distinguish a certain type of element (such as a local variable),
it is okay to style it as its more general variant (a variable).

For tags that extend some parent tag, the documentation links to
the parent.
*/
    const tags = {
      /**
    A comment.
    */
      comment,
      /**
    A line [comment](#highlight.tags.comment).
    */
      lineComment: t(comment),
      /**
    A block [comment](#highlight.tags.comment).
    */
      blockComment: t(comment),
      /**
    A documentation [comment](#highlight.tags.comment).
    */
      docComment: t(comment),
      /**
    Any kind of identifier.
    */
      name: dist_name,
      /**
    The [name](#highlight.tags.name) of a variable.
    */
      variableName: t(dist_name),
      /**
    A type [name](#highlight.tags.name).
    */
      typeName: typeName,
      /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
      tagName: t(typeName),
      /**
    A property or field [name](#highlight.tags.name).
    */
      propertyName: propertyName,
      /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
      attributeName: t(propertyName),
      /**
    The [name](#highlight.tags.name) of a class.
    */
      className: t(dist_name),
      /**
    A label [name](#highlight.tags.name).
    */
      labelName: t(dist_name),
      /**
    A namespace [name](#highlight.tags.name).
    */
      namespace: t(dist_name),
      /**
    The [name](#highlight.tags.name) of a macro.
    */
      macroName: t(dist_name),
      /**
    A literal value.
    */
      literal,
      /**
    A string [literal](#highlight.tags.literal).
    */
      string,
      /**
    A documentation [string](#highlight.tags.string).
    */
      docString: t(string),
      /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
      character: t(string),
      /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
      attributeValue: t(string),
      /**
    A number [literal](#highlight.tags.literal).
    */
      number,
      /**
    An integer [number](#highlight.tags.number) literal.
    */
      integer: t(number),
      /**
    A floating-point [number](#highlight.tags.number) literal.
    */
      float: t(number),
      /**
    A boolean [literal](#highlight.tags.literal).
    */
      bool: t(literal),
      /**
    Regular expression [literal](#highlight.tags.literal).
    */
      regexp: t(literal),
      /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
      escape: t(literal),
      /**
    A color [literal](#highlight.tags.literal).
    */
      color: t(literal),
      /**
    A URL [literal](#highlight.tags.literal).
    */
      url: t(literal),
      /**
    A language keyword.
    */
      keyword,
      /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
      self: t(keyword),
      /**
    The [keyword](#highlight.tags.keyword) for null.
    */
      null: t(keyword),
      /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
      atom: t(keyword),
      /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
      unit: t(keyword),
      /**
    A modifier [keyword](#highlight.tags.keyword).
    */
      modifier: t(keyword),
      /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
      operatorKeyword: t(keyword),
      /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
      controlKeyword: t(keyword),
      /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
      definitionKeyword: t(keyword),
      /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
      moduleKeyword: t(keyword),
      /**
    An operator.
    */
      operator,
      /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
      derefOperator: t(operator),
      /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
      arithmeticOperator: t(operator),
      /**
    Logical [operator](#highlight.tags.operator).
    */
      logicOperator: t(operator),
      /**
    Bit [operator](#highlight.tags.operator).
    */
      bitwiseOperator: t(operator),
      /**
    Comparison [operator](#highlight.tags.operator).
    */
      compareOperator: t(operator),
      /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
      updateOperator: t(operator),
      /**
    [Operator](#highlight.tags.operator) that defines something.
    */
      definitionOperator: t(operator),
      /**
    Type-related [operator](#highlight.tags.operator).
    */
      typeOperator: t(operator),
      /**
    Control-flow [operator](#highlight.tags.operator).
    */
      controlOperator: t(operator),
      /**
    Program or markup punctuation.
    */
      punctuation,
      /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
      separator: t(punctuation),
      /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
      bracket,
      /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
      angleBracket: t(bracket),
      /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
      squareBracket: t(bracket),
      /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
      paren: t(bracket),
      /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
      brace: t(bracket),
      /**
    Content, for example plain text in XML or markup documents.
    */
      content,
      /**
    [Content](#highlight.tags.content) that represents a heading.
    */
      heading,
      /**
    A level 1 [heading](#highlight.tags.heading).
    */
      heading1: t(heading),
      /**
    A level 2 [heading](#highlight.tags.heading).
    */
      heading2: t(heading),
      /**
    A level 3 [heading](#highlight.tags.heading).
    */
      heading3: t(heading),
      /**
    A level 4 [heading](#highlight.tags.heading).
    */
      heading4: t(heading),
      /**
    A level 5 [heading](#highlight.tags.heading).
    */
      heading5: t(heading),
      /**
    A level 6 [heading](#highlight.tags.heading).
    */
      heading6: t(heading),
      /**
    A prose separator (such as a horizontal rule).
    */
      contentSeparator: t(content),
      /**
    [Content](#highlight.tags.content) that represents a list.
    */
      list: t(content),
      /**
    [Content](#highlight.tags.content) that represents a quote.
    */
      quote: t(content),
      /**
    [Content](#highlight.tags.content) that is emphasized.
    */
      emphasis: t(content),
      /**
    [Content](#highlight.tags.content) that is styled strong.
    */
      strong: t(content),
      /**
    [Content](#highlight.tags.content) that is part of a link.
    */
      link: t(content),
      /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
      monospace: t(content),
      /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
      strikethrough: t(content),
      /**
    Inserted text in a change-tracking format.
    */
      inserted: t(),
      /**
    Deleted text.
    */
      deleted: t(),
      /**
    Changed text.
    */
      changed: t(),
      /**
    An invalid or unsyntactic element.
    */
      invalid: t(),
      /**
    Metadata or meta-instruction.
    */
      meta,
      /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
      documentMeta: t(meta),
      /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
      annotation: t(meta),
      /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
      processingInstruction: t(meta),
      /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
      definition: Tag.defineModifier(),
      /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
      constant: Tag.defineModifier(),
      /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
      function: Tag.defineModifier(),
      /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
      standard: Tag.defineModifier(),
      /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
      local: Tag.defineModifier(),
      /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
      special: Tag.defineModifier()
    }
    /**
This is a highlighter that adds stable, predictable classes to
tokens, for styling with external CSS.

The following tags are mapped to their name prefixed with `"tok-"`
(for example `"tok-comment"`):

* [`link`](#highlight.tags.link)
* [`heading`](#highlight.tags.heading)
* [`emphasis`](#highlight.tags.emphasis)
* [`strong`](#highlight.tags.strong)
* [`keyword`](#highlight.tags.keyword)
* [`atom`](#highlight.tags.atom)
* [`bool`](#highlight.tags.bool)
* [`url`](#highlight.tags.url)
* [`labelName`](#highlight.tags.labelName)
* [`inserted`](#highlight.tags.inserted)
* [`deleted`](#highlight.tags.deleted)
* [`literal`](#highlight.tags.literal)
* [`string`](#highlight.tags.string)
* [`number`](#highlight.tags.number)
* [`variableName`](#highlight.tags.variableName)
* [`typeName`](#highlight.tags.typeName)
* [`namespace`](#highlight.tags.namespace)
* [`className`](#highlight.tags.className)
* [`macroName`](#highlight.tags.macroName)
* [`propertyName`](#highlight.tags.propertyName)
* [`operator`](#highlight.tags.operator)
* [`comment`](#highlight.tags.comment)
* [`meta`](#highlight.tags.meta)
* [`punctuation`](#highlight.tags.punctuation)
* [`invalid`](#highlight.tags.invalid)

In addition, these mappings are provided:

* [`regexp`](#highlight.tags.regexp),
  [`escape`](#highlight.tags.escape), and
  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
  are mapped to `"tok-string2"`
* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName2"`
* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-local"`
* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-definition"`
* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
  to `"tok-propertyName tok-definition"`
*/
    const classHighlighter = tagHighlighter([
      { tag: tags.link, class: 'tok-link' },
      { tag: tags.heading, class: 'tok-heading' },
      { tag: tags.emphasis, class: 'tok-emphasis' },
      { tag: tags.strong, class: 'tok-strong' },
      { tag: tags.keyword, class: 'tok-keyword' },
      { tag: tags.atom, class: 'tok-atom' },
      { tag: tags.bool, class: 'tok-bool' },
      { tag: tags.url, class: 'tok-url' },
      { tag: tags.labelName, class: 'tok-labelName' },
      { tag: tags.inserted, class: 'tok-inserted' },
      { tag: tags.deleted, class: 'tok-deleted' },
      { tag: tags.literal, class: 'tok-literal' },
      { tag: tags.string, class: 'tok-string' },
      { tag: tags.number, class: 'tok-number' },
      {
        tag: [tags.regexp, tags.escape, tags.special(tags.string)],
        class: 'tok-string2'
      },
      { tag: tags.variableName, class: 'tok-variableName' },
      {
        tag: tags.local(tags.variableName),
        class: 'tok-variableName tok-local'
      },
      {
        tag: tags.definition(tags.variableName),
        class: 'tok-variableName tok-definition'
      },
      { tag: tags.special(tags.variableName), class: 'tok-variableName2' },
      {
        tag: tags.definition(tags.propertyName),
        class: 'tok-propertyName tok-definition'
      },
      { tag: tags.typeName, class: 'tok-typeName' },
      { tag: tags.namespace, class: 'tok-namespace' },
      { tag: tags.className, class: 'tok-className' },
      { tag: tags.macroName, class: 'tok-macroName' },
      { tag: tags.propertyName, class: 'tok-propertyName' },
      { tag: tags.operator, class: 'tok-operator' },
      { tag: tags.comment, class: 'tok-comment' },
      { tag: tags.meta, class: 'tok-meta' },
      { tag: tags.invalid, class: 'tok-invalid' },
      { tag: tags.punctuation, class: 'tok-punctuation' }
    ]) // CONCATENATED MODULE: ./node_modules/@codemirror/language/dist/index.js

    var _a
    /**
Node prop stored in a parser's top syntax node to provide the
facet that stores language-specific data for that language.
*/
    const languageDataProp = /*@__PURE__*/ new dist_NodeProp()
    /**
Helper function to define a facet (to be added to the top syntax
node(s) for a language via
[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
used to associate language data with the language. You
probably only need this when subclassing
[`Language`](https://codemirror.net/6/docs/ref/#language.Language).
*/
    function defineLanguageFacet(baseData) {
      return Facet.define({
        combine: baseData ? (values) => values.concat(baseData) : undefined
      })
    }
    /**
Syntax node prop used to register sublanguages. Should be added to
the top level node type for the language.
*/
    const sublanguageProp = /*@__PURE__*/ new dist_NodeProp()
    /**
A language object manages parsing and per-language
[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
managed as a [Lezer](https://lezer.codemirror.net) tree. The class
can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)
subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or
via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass
for stream parsers.
*/
    class Language {
      /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
      constructor(
        /**
    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet
    used for this language.
    */
        data,
        parser,
        extraExtensions = [],
        /**
    A language name.
    */
        name = ''
      ) {
        this.data = data
        this.name = name
        // Kludge to define EditorState.tree as a debugging helper,
        // without the EditorState package actually knowing about
        // languages and lezer trees.
        if (!EditorState.prototype.hasOwnProperty('tree'))
          Object.defineProperty(EditorState.prototype, 'tree', {
            get() {
              return dist_syntaxTree(this)
            }
          })
        this.parser = parser
        this.extension = [
          language.of(this),
          EditorState.languageData.of((state, pos, side) => {
            let top = topNodeAt(state, pos, side),
              data = top.type.prop(languageDataProp)
            if (!data) return []
            let base = state.facet(data),
              sub = top.type.prop(sublanguageProp)
            if (sub) {
              let innerNode = top.resolve(pos - top.from, side)
              for (let sublang of sub)
                if (sublang.test(innerNode, state)) {
                  let data = state.facet(sublang.facet)
                  return sublang.type == 'replace' ? data : data.concat(base)
                }
            }
            return base
          })
        ].concat(extraExtensions)
      }
      /**
    Query whether this language is active at the given position.
    */
      isActiveAt(state, pos, side = -1) {
        return (
          topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data
        )
      }
      /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
      findRegions(state) {
        let lang = state.facet(language)
        if (
          (lang === null || lang === void 0 ? void 0 : lang.data) == this.data
        )
          return [{ from: 0, to: state.doc.length }]
        if (!lang || !lang.allowsNesting) return []
        let result = []
        let explore = (tree, from) => {
          if (tree.prop(languageDataProp) == this.data) {
            result.push({ from, to: from + tree.length })
            return
          }
          let mount = tree.prop(dist_NodeProp.mounted)
          if (mount) {
            if (mount.tree.prop(languageDataProp) == this.data) {
              if (mount.overlay)
                for (let r of mount.overlay)
                  result.push({ from: r.from + from, to: r.to + from })
              else result.push({ from: from, to: from + tree.length })
              return
            } else if (mount.overlay) {
              let size = result.length
              explore(mount.tree, mount.overlay[0].from + from)
              if (result.length > size) return
            }
          }
          for (let i = 0; i < tree.children.length; i++) {
            let ch = tree.children[i]
            if (ch instanceof dist_Tree) explore(ch, tree.positions[i] + from)
          }
        }
        explore(dist_syntaxTree(state), 0)
        return result
      }
      /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
      get allowsNesting() {
        return true
      }
    }
    /**
@internal
*/
    Language.setState = /*@__PURE__*/ StateEffect.define()
    function topNodeAt(state, pos, side) {
      let topLang = state.facet(language),
        tree = dist_syntaxTree(state).topNode
      if (!topLang || topLang.allowsNesting) {
        for (
          let node = tree;
          node;
          node = node.enter(pos, side, IterMode.ExcludeBuffers)
        )
          if (node.type.isTop) tree = node
      }
      return tree
    }
    /**
A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
parsers.
*/
    class LRLanguage extends Language {
      constructor(data, parser, name) {
        super(data, parser, [], name)
        this.parser = parser
      }
      /**
    Define a language from a parser.
    */
      static define(spec) {
        let data = defineLanguageFacet(spec.languageData)
        return new LRLanguage(
          data,
          spec.parser.configure({
            props: [
              languageDataProp.add((type) => (type.isTop ? data : undefined))
            ]
          }),
          spec.name
        )
      }
      /**
    Create a new instance of this language with a reconfigured
    version of its parser and optionally a new name.
    */
      configure(options, name) {
        return new LRLanguage(
          this.data,
          this.parser.configure(options),
          name || this.name
        )
      }
      get allowsNesting() {
        return this.parser.hasWrappers()
      }
    }
    /**
Get the syntax tree for a state, which is the current (possibly
incomplete) parse tree of the active
[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no
language available.
*/
    function dist_syntaxTree(state) {
      let field = state.field(Language.state, false)
      return field ? field.tree : dist_Tree.empty
    }
    /**
Try to get a parse tree that spans at least up to `upto`. The
method will do at most `timeout` milliseconds of work to parse
up to that point if the tree isn't already available.
*/
    function ensureSyntaxTree(state, upto, timeout = 50) {
      var _a
      let parse =
        (_a = state.field(Language.state, false)) === null || _a === void 0
          ? void 0
          : _a.context
      if (!parse) return null
      let oldVieport = parse.viewport
      parse.updateViewport({ from: 0, to: upto })
      let result =
        parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null
      parse.updateViewport(oldVieport)
      return result
    }
    /**
Queries whether there is a full syntax tree available up to the
given document position. If there isn't, the background parse
process _might_ still be working and update the tree further, but
there is no guarantee of that—the parser will [stop
working](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a
certain amount of time or has moved beyond the visible viewport.
Always returns false if no language has been enabled.
*/
    function syntaxTreeAvailable(state, upto = state.doc.length) {
      var _a
      return (
        ((_a = state.field(Language.state, false)) === null || _a === void 0
          ? void 0
          : _a.context.isDone(upto)) || false
      )
    }
    /**
Move parsing forward, and update the editor state afterwards to
reflect the new tree. Will work for at most `timeout`
milliseconds. Returns true if the parser managed get to the given
position in that time.
*/
    function forceParsing(view, upto = view.viewport.to, timeout = 100) {
      let success = ensureSyntaxTree(view.state, upto, timeout)
      if (success != dist_syntaxTree(view.state)) view.dispatch({})
      return !!success
    }
    /**
Tells you whether the language parser is planning to do more
parsing work (in a `requestIdleCallback` pseudo-thread) or has
stopped running, either because it parsed the entire document,
because it spent too much time and was cut off, or because there
is no language parser enabled.
*/
    function syntaxParserRunning(view) {
      var _a
      return (
        ((_a = view.plugin(parseWorker)) === null || _a === void 0
          ? void 0
          : _a.isWorking()) || false
      )
    }
    /**
Lezer-style
[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)
object for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.
*/
    class DocInput {
      /**
    Create an input object for the given document.
    */
      constructor(doc) {
        this.doc = doc
        this.cursorPos = 0
        this.string = ''
        this.cursor = doc.iter()
      }
      get length() {
        return this.doc.length
      }
      syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value
        this.cursorPos = pos + this.string.length
        return this.cursorPos - this.string.length
      }
      chunk(pos) {
        this.syncTo(pos)
        return this.string
      }
      get lineChunks() {
        return true
      }
      read(from, to) {
        let stringStart = this.cursorPos - this.string.length
        if (from < stringStart || to >= this.cursorPos)
          return this.doc.sliceString(from, to)
        else return this.string.slice(from - stringStart, to - stringStart)
      }
    }
    let currentContext = null
    /**
A parse context provided to parsers working on the editor content.
*/
    class ParseContext {
      constructor(
        parser,
        /**
    The current editor state.
    */
        state,
        /**
    Tree fragments that can be reused by incremental re-parses.
    */
        fragments = [],
        /**
    @internal
    */
        tree,
        /**
    @internal
    */
        treeLen,
        /**
    The current editor viewport (or some overapproximation
    thereof). Intended to be used for opportunistically avoiding
    work (in which case
    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
    should be called to make sure the parser is restarted when the
    skipped region becomes visible).
    */
        viewport,
        /**
    @internal
    */
        skipped,
        /**
    This is where skipping parsers can register a promise that,
    when resolved, will schedule a new parse. It is cleared when
    the parse worker picks up the promise. @internal
    */
        scheduleOn
      ) {
        this.parser = parser
        this.state = state
        this.fragments = fragments
        this.tree = tree
        this.treeLen = treeLen
        this.viewport = viewport
        this.skipped = skipped
        this.scheduleOn = scheduleOn
        this.parse = null
        /**
        @internal
        */
        this.tempSkipped = []
      }
      /**
    @internal
    */
      static create(parser, state, viewport) {
        return new ParseContext(
          parser,
          state,
          [],
          dist_Tree.empty,
          0,
          viewport,
          [],
          null
        )
      }
      startParse() {
        return this.parser.startParse(
          new DocInput(this.state.doc),
          this.fragments
        )
      }
      /**
    @internal
    */
      work(until, upto) {
        if (upto != null && upto >= this.state.doc.length) upto = undefined
        if (
          this.tree != dist_Tree.empty &&
          this.isDone(
            upto !== null && upto !== void 0 ? upto : this.state.doc.length
          )
        ) {
          this.takeTree()
          return true
        }
        return this.withContext(() => {
          var _a
          if (typeof until == 'number') {
            let endTime = Date.now() + until
            until = () => Date.now() > endTime
          }
          if (!this.parse) this.parse = this.startParse()
          if (
            upto != null &&
            (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
            upto < this.state.doc.length
          )
            this.parse.stopAt(upto)
          for (;;) {
            let done = this.parse.advance()
            if (done) {
              this.fragments = this.withoutTempSkipped(
                TreeFragment.addTree(
                  done,
                  this.fragments,
                  this.parse.stoppedAt != null
                )
              )
              this.treeLen =
                (_a = this.parse.stoppedAt) !== null && _a !== void 0
                  ? _a
                  : this.state.doc.length
              this.tree = done
              this.parse = null
              if (
                this.treeLen <
                (upto !== null && upto !== void 0
                  ? upto
                  : this.state.doc.length)
              )
                this.parse = this.startParse()
              else return true
            }
            if (until()) return false
          }
        })
      }
      /**
    @internal
    */
      takeTree() {
        let pos, tree
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
          if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
            this.parse.stopAt(pos)
          this.withContext(() => {
            while (!(tree = this.parse.advance())) {}
          })
          this.treeLen = pos
          this.tree = tree
          this.fragments = this.withoutTempSkipped(
            TreeFragment.addTree(this.tree, this.fragments, true)
          )
          this.parse = null
        }
      }
      withContext(f) {
        let prev = currentContext
        currentContext = this
        try {
          return f()
        } finally {
          currentContext = prev
        }
      }
      withoutTempSkipped(fragments) {
        for (let r; (r = this.tempSkipped.pop()); )
          fragments = cutFragments(fragments, r.from, r.to)
        return fragments
      }
      /**
    @internal
    */
      changes(changes, newState) {
        let { fragments, tree, treeLen, viewport, skipped } = this
        this.takeTree()
        if (!changes.empty) {
          let ranges = []
          changes.iterChangedRanges((fromA, toA, fromB, toB) =>
            ranges.push({ fromA, toA, fromB, toB })
          )
          fragments = TreeFragment.applyChanges(fragments, ranges)
          tree = dist_Tree.empty
          treeLen = 0
          viewport = {
            from: changes.mapPos(viewport.from, -1),
            to: changes.mapPos(viewport.to, 1)
          }
          if (this.skipped.length) {
            skipped = []
            for (let r of this.skipped) {
              let from = changes.mapPos(r.from, 1),
                to = changes.mapPos(r.to, -1)
              if (from < to) skipped.push({ from, to })
            }
          }
        }
        return new ParseContext(
          this.parser,
          newState,
          fragments,
          tree,
          treeLen,
          viewport,
          skipped,
          this.scheduleOn
        )
      }
      /**
    @internal
    */
      updateViewport(viewport) {
        if (
          this.viewport.from == viewport.from &&
          this.viewport.to == viewport.to
        )
          return false
        this.viewport = viewport
        let startLen = this.skipped.length
        for (let i = 0; i < this.skipped.length; i++) {
          let { from, to } = this.skipped[i]
          if (from < viewport.to && to > viewport.from) {
            this.fragments = cutFragments(this.fragments, from, to)
            this.skipped.splice(i--, 1)
          }
        }
        if (this.skipped.length >= startLen) return false
        this.reset()
        return true
      }
      /**
    @internal
    */
      reset() {
        if (this.parse) {
          this.takeTree()
          this.parse = null
        }
      }
      /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
      skipUntilInView(from, to) {
        this.skipped.push({ from, to })
      }
      /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
      static getSkippingParser(until) {
        return new (class extends dist_Parser {
          createParse(input, fragments, ranges) {
            let from = ranges[0].from,
              to = ranges[ranges.length - 1].to
            let parser = {
              parsedPos: from,
              advance() {
                let cx = currentContext
                if (cx) {
                  for (let r of ranges) cx.tempSkipped.push(r)
                  if (until)
                    cx.scheduleOn = cx.scheduleOn
                      ? Promise.all([cx.scheduleOn, until])
                      : until
                }
                this.parsedPos = to
                return new dist_Tree(dist_NodeType.none, [], [], to - from)
              },
              stoppedAt: null,
              stopAt() {}
            }
            return parser
          }
        })()
      }
      /**
    @internal
    */
      isDone(upto) {
        upto = Math.min(upto, this.state.doc.length)
        let frags = this.fragments
        return (
          this.treeLen >= upto &&
          frags.length &&
          frags[0].from == 0 &&
          frags[0].to >= upto
        )
      }
      /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
      static get() {
        return currentContext
      }
    }
    function cutFragments(fragments, from, to) {
      return TreeFragment.applyChanges(fragments, [
        { fromA: from, toA: to, fromB: from, toB: to }
      ])
    }
    class LanguageState {
      constructor(
        // A mutable parse state that is used to preserve work done during
        // the lifetime of a state when moving to the next state.
        context
      ) {
        this.context = context
        this.tree = context.tree
      }
      apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree) return this
        let newCx = this.context.changes(tr.changes, tr.state)
        // If the previous parse wasn't done, go forward only up to its
        // end position or the end of the viewport, to avoid slowing down
        // state updates with parse work beyond the viewport.
        let upto =
          this.context.treeLen == tr.startState.doc.length
            ? undefined
            : Math.max(
                tr.changes.mapPos(this.context.treeLen),
                newCx.viewport.to
              )
        if (!newCx.work(20 /* Work.Apply */, upto)) newCx.takeTree()
        return new LanguageState(newCx)
      }
      static init(state) {
        let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length)
        let parseState = ParseContext.create(
          state.facet(language).parser,
          state,
          { from: 0, to: vpTo }
        )
        if (!parseState.work(20 /* Work.Apply */, vpTo)) parseState.takeTree()
        return new LanguageState(parseState)
      }
    }
    Language.state = /*@__PURE__*/ StateField.define({
      create: LanguageState.init,
      update(value, tr) {
        for (let e of tr.effects) if (e.is(Language.setState)) return e.value
        if (tr.startState.facet(language) != tr.state.facet(language))
          return LanguageState.init(tr.state)
        return value.apply(tr)
      }
    })
    let requestIdle = (callback) => {
      let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */)
      return () => clearTimeout(timeout)
    }
    if (typeof requestIdleCallback != 'undefined')
      requestIdle = (callback) => {
        let idle = -1,
          timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, {
              timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */
            })
          }, 100 /* Work.MinPause */)
        return () =>
          idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle)
      }
    const isInputPending =
      typeof navigator != 'undefined' &&
      ((_a = navigator.scheduling) === null || _a === void 0
        ? void 0
        : _a.isInputPending)
        ? () => navigator.scheduling.isInputPending()
        : null
    const parseWorker = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class ParseWorker {
        constructor(view) {
          this.view = view
          this.working = null
          this.workScheduled = 0
          // End of the current time chunk
          this.chunkEnd = -1
          // Milliseconds of budget left for this chunk
          this.chunkBudget = -1
          this.work = this.work.bind(this)
          this.scheduleWork()
        }
        update(update) {
          let cx = this.view.state.field(Language.state).context
          if (
            cx.updateViewport(update.view.viewport) ||
            this.view.viewport.to > cx.treeLen
          )
            this.scheduleWork()
          if (update.docChanged || update.selectionSet) {
            if (this.view.hasFocus)
              this.chunkBudget += 50 /* Work.ChangeBonus */
            this.scheduleWork()
          }
          this.checkAsyncSchedule(cx)
        }
        scheduleWork() {
          if (this.working) return
          let { state } = this.view,
            field = state.field(Language.state)
          if (
            field.tree != field.context.tree ||
            !field.context.isDone(state.doc.length)
          )
            this.working = requestIdle(this.work)
        }
        work(deadline) {
          this.working = null
          let now = Date.now()
          if (
            this.chunkEnd < now &&
            (this.chunkEnd < 0 || this.view.hasFocus)
          ) {
            // Start a new chunk
            this.chunkEnd = now + 30000 /* Work.ChunkTime */
            this.chunkBudget = 3000 /* Work.ChunkBudget */
          }
          if (this.chunkBudget <= 0) return // No more budget
          let {
              state,
              viewport: { to: vpTo }
            } = this.view,
            field = state.field(Language.state)
          if (
            field.tree == field.context.tree &&
            field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */)
          )
            return
          let endTime =
            Date.now() +
            Math.min(
              this.chunkBudget,
              100 /* Work.Slice */,
              deadline && !isInputPending
                ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5)
                : 1e9
            )
          let viewportFirst =
            field.context.treeLen < vpTo && state.doc.length > vpTo + 1000
          let done = field.context.work(
            () => {
              return (
                (isInputPending && isInputPending()) || Date.now() > endTime
              )
            },
            vpTo + (viewportFirst ? 0 : 100000) /* Work.MaxParseAhead */
          )
          this.chunkBudget -= Date.now() - now
          if (done || this.chunkBudget <= 0) {
            field.context.takeTree()
            this.view.dispatch({
              effects: Language.setState.of(new LanguageState(field.context))
            })
          }
          if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork()
          this.checkAsyncSchedule(field.context)
        }
        checkAsyncSchedule(cx) {
          if (cx.scheduleOn) {
            this.workScheduled++
            cx.scheduleOn
              .then(() => this.scheduleWork())
              .catch((err) => dist_logException(this.view.state, err))
              .then(() => this.workScheduled--)
            cx.scheduleOn = null
          }
        }
        destroy() {
          if (this.working) this.working()
        }
        isWorking() {
          return !!(this.working || this.workScheduled > 0)
        }
      },
      {
        eventHandlers: {
          focus() {
            this.scheduleWork()
          }
        }
      }
    )
    /**
The facet used to associate a language with an editor state. Used
by `Language` object's `extension` property (so you don't need to
manually wrap your languages in this). Can be used to access the
current language on a state.
*/
    const language = /*@__PURE__*/ Facet.define({
      combine(languages) {
        return languages.length ? languages[0] : null
      },
      enables: (language) => [
        Language.state,
        parseWorker,
        EditorView.contentAttributes.compute([language], (state) => {
          let lang = state.facet(language)
          return lang && lang.name ? { 'data-language': lang.name } : {}
        })
      ]
    })
    /**
This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an
optional set of supporting extensions. Language packages are
encouraged to export a function that optionally takes a
configuration object and returns a `LanguageSupport` instance, as
the main way for client code to use the package.
*/
    class LanguageSupport {
      /**
    Create a language support object.
    */
      constructor(
        /**
    The language object.
    */
        language,
        /**
    An optional set of supporting extensions. When nesting a
    language in another language, the outer language is encouraged
    to include the supporting extensions for its inner languages
    in its own set of support extensions.
    */
        support = []
      ) {
        this.language = language
        this.support = support
        this.extension = [language, support]
      }
    }
    /**
Language descriptions are used to store metadata about languages
and to dynamically load them. Their main role is finding the
appropriate language for a filename or dynamically loading nested
parsers.
*/
    class LanguageDescription {
      constructor(
        /**
    The name of this language.
    */
        name,
        /**
    Alternative names for the mode (lowercased, includes `this.name`).
    */
        alias,
        /**
    File extensions associated with this language.
    */
        extensions,
        /**
    Optional filename pattern that should be associated with this
    language.
    */
        filename,
        loadFunc,
        /**
    If the language has been loaded, this will hold its value.
    */
        support = undefined
      ) {
        this.name = name
        this.alias = alias
        this.extensions = extensions
        this.filename = filename
        this.loadFunc = loadFunc
        this.support = support
        this.loading = null
      }
      /**
    Start loading the the language. Will return a promise that
    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
    object when the language successfully loads.
    */
      load() {
        return (
          this.loading ||
          (this.loading = this.loadFunc().then(
            (support) => (this.support = support),
            (err) => {
              this.loading = null
              throw err
            }
          ))
        )
      }
      /**
    Create a language description.
    */
      static of(spec) {
        let { load, support } = spec
        if (!load) {
          if (!support)
            throw new RangeError(
              "Must pass either 'load' or 'support' to LanguageDescription.of"
            )
          load = () => Promise.resolve(support)
        }
        return new LanguageDescription(
          spec.name,
          (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()),
          spec.extensions || [],
          spec.filename,
          load,
          support
        )
      }
      /**
    Look for a language in the given array of descriptions that
    matches the filename. Will first match
    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
    and return the first language that matches.
    */
      static matchFilename(descs, filename) {
        for (let d of descs)
          if (d.filename && d.filename.test(filename)) return d
        let ext = /\.([^.]+)$/.exec(filename)
        if (ext)
          for (let d of descs) if (d.extensions.indexOf(ext[1]) > -1) return d
        return null
      }
      /**
    Look for a language whose name or alias matches the the given
    name (case-insensitively). If `fuzzy` is true, and no direct
    matchs is found, this'll also search for a language whose name
    or alias occurs in the string (for names shorter than three
    characters, only when surrounded by non-word characters).
    */
      static matchLanguageName(descs, name, fuzzy = true) {
        name = name.toLowerCase()
        for (let d of descs) if (d.alias.some((a) => a == name)) return d
        if (fuzzy)
          for (let d of descs)
            for (let a of d.alias) {
              let found = name.indexOf(a)
              if (
                found > -1 &&
                (a.length > 2 ||
                  (!/\w/.test(name[found - 1]) &&
                    !/\w/.test(name[found + a.length])))
              )
                return d
            }
        return null
      }
    }

    /**
Facet that defines a way to provide a function that computes the
appropriate indentation depth, as a column number (see
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given
line. A return value of `null` indicates no indentation can be
determined, and the line should inherit the indentation of the one
above it. A return value of `undefined` defers to the next indent
service.
*/
    const indentService = /*@__PURE__*/ Facet.define()
    /**
Facet for overriding the unit by which indentation happens. Should
be a string consisting either entirely of the same whitespace
character. When not set, this defaults to 2 spaces.
*/
    const indentUnit = /*@__PURE__*/ Facet.define({
      combine: (values) => {
        if (!values.length) return '  '
        let unit = values[0]
        if (
          !unit ||
          /\S/.test(unit) ||
          Array.from(unit).some((e) => e != unit[0])
        )
          throw new Error('Invalid indent unit: ' + JSON.stringify(values[0]))
        return unit
      }
    })
    /**
Return the _column width_ of an indent unit in the state.
Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
contains tabs.
*/
    function getIndentUnit(state) {
      let unit = state.facet(indentUnit)
      return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length
    }
    /**
Create an indentation string that covers columns 0 to `cols`.
Will use tabs for as much of the columns as possible when the
[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
tabs.
*/
    function indentString(state, cols) {
      let result = '',
        ts = state.tabSize,
        ch = state.facet(indentUnit)[0]
      if (ch == '\t') {
        while (cols >= ts) {
          result += '\t'
          cols -= ts
        }
        ch = ' '
      }
      for (let i = 0; i < cols; i++) result += ch
      return result
    }
    /**
Get the indentation, as a column number, at the given position.
Will first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)
that are registered, and if none of those return an indentation,
this will check the syntax tree for the [indent node
prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a
number when an indentation could be determined, and null
otherwise.
*/
    function getIndentation(context, pos) {
      if (context instanceof EditorState) context = new IndentContext(context)
      for (let service of context.state.facet(indentService)) {
        let result = service(context, pos)
        if (result !== undefined) return result
      }
      let tree = dist_syntaxTree(context.state)
      return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null
    }
    /**
Create a change set that auto-indents all lines touched by the
given document range.
*/
    function indentRange(state, from, to) {
      let updated = Object.create(null)
      let context = new IndentContext(state, {
        overrideIndentation: (start) => {
          var _a
          return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1
        }
      })
      let changes = []
      for (let pos = from; pos <= to; ) {
        let line = state.doc.lineAt(pos)
        pos = line.to + 1
        let indent = getIndentation(context, line.from)
        if (indent == null) continue
        if (!/\S/.test(line.text)) indent = 0
        let cur = /^\s*/.exec(line.text)[0]
        let norm = indentString(state, indent)
        if (cur != norm) {
          updated[line.from] = indent
          changes.push({
            from: line.from,
            to: line.from + cur.length,
            insert: norm
          })
        }
      }
      return state.changes(changes)
    }
    /**
Indentation contexts are used when calling [indentation
services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
useful in indentation logic, and can selectively override the
indentation reported for some lines.
*/
    class IndentContext {
      /**
    Create an indent context.
    */
      constructor(
        /**
    The editor state.
    */
        state,
        /**
    @internal
    */
        options = {}
      ) {
        this.state = state
        this.options = options
        this.unit = getIndentUnit(state)
      }
      /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
      lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos)
        let { simulateBreak, simulateDoubleBreak } = this.options
        if (
          simulateBreak != null &&
          simulateBreak >= line.from &&
          simulateBreak <= line.to
        ) {
          if (simulateDoubleBreak && simulateBreak == pos)
            return { text: '', from: pos }
          else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
            return {
              text: line.text.slice(simulateBreak - line.from),
              from: simulateBreak
            }
          else
            return {
              text: line.text.slice(0, simulateBreak - line.from),
              from: line.from
            }
        }
        return line
      }
      /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
      textAfterPos(pos, bias = 1) {
        if (
          this.options.simulateDoubleBreak &&
          pos == this.options.simulateBreak
        )
          return ''
        let { text, from } = this.lineAt(pos, bias)
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from))
      }
      /**
    Find the column for the given position.
    */
      column(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias)
        let result = this.countColumn(text, pos - from)
        let override = this.options.overrideIndentation
          ? this.options.overrideIndentation(from)
          : -1
        if (override > -1)
          result += override - this.countColumn(text, text.search(/\S|$/))
        return result
      }
      /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
      countColumn(line, pos = line.length) {
        return countColumn(line, this.state.tabSize, pos)
      }
      /**
    Find the indentation column of the line at the given point.
    */
      lineIndent(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias)
        let override = this.options.overrideIndentation
        if (override) {
          let overriden = override(from)
          if (overriden > -1) return overriden
        }
        return this.countColumn(text, text.search(/\S|$/))
      }
      /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
      get simulatedBreak() {
        return this.options.simulateBreak || null
      }
    }
    /**
A syntax tree node prop used to associate indentation strategies
with node types. Such a strategy is a function from an indentation
context to a column number (see also
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null
indicates that no definitive indentation can be determined.
*/
    const indentNodeProp = /*@__PURE__*/ new dist_NodeProp()
    // Compute the indentation for a given position from the syntax tree.
    function syntaxIndentation(cx, ast, pos) {
      let stack = ast.resolveStack(pos)
      let inner = stack.node.enterUnfinishedNodesBefore(pos)
      if (inner != stack.node) {
        let add = []
        for (let cur = inner; cur != stack.node; cur = cur.parent) add.push(cur)
        for (let i = add.length - 1; i >= 0; i--)
          stack = { node: add[i], next: stack }
      }
      return indentFor(stack, cx, pos)
    }
    function indentFor(stack, cx, pos) {
      for (let cur = stack; cur; cur = cur.next) {
        let strategy = indentStrategy(cur.node)
        if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur))
      }
      return 0
    }
    function ignoreClosed(cx) {
      return (
        cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak
      )
    }
    function indentStrategy(tree) {
      let strategy = tree.type.prop(indentNodeProp)
      if (strategy) return strategy
      let first = tree.firstChild,
        close
      if (first && (close = first.type.prop(dist_NodeProp.closedBy))) {
        let last = tree.lastChild,
          closed = last && close.indexOf(last.name) > -1
        return (cx) =>
          delimitedStrategy(
            cx,
            true,
            1,
            undefined,
            closed && !ignoreClosed(cx) ? last.from : undefined
          )
      }
      return tree.parent == null ? topIndent : null
    }
    function topIndent() {
      return 0
    }
    /**
Objects of this type provide context information and helper
methods to indentation functions registered on syntax nodes.
*/
    class TreeIndentContext extends IndentContext {
      constructor(
        base,
        /**
    The position at which indentation is being computed.
    */
        pos,
        /**
    @internal
    */
        context
      ) {
        super(base.state, base.options)
        this.base = base
        this.pos = pos
        this.context = context
      }
      /**
    The syntax tree node to which the indentation strategy
    applies.
    */
      get node() {
        return this.context.node
      }
      /**
    @internal
    */
      static create(base, pos, context) {
        return new TreeIndentContext(base, pos, context)
      }
      /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
      get textAfter() {
        return this.textAfterPos(this.pos)
      }
      /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
      get baseIndent() {
        return this.baseIndentFor(this.node)
      }
      /**
    Get the indentation for the reference line of the given node
    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
    */
      baseIndentFor(node) {
        let line = this.state.doc.lineAt(node.from)
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
          let atBreak = node.resolve(line.from)
          while (atBreak.parent && atBreak.parent.from == atBreak.from)
            atBreak = atBreak.parent
          if (isParent(atBreak, node)) break
          line = this.state.doc.lineAt(atBreak.from)
        }
        return this.lineIndent(line.from)
      }
      /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
      continue() {
        return indentFor(this.context.next, this.base, this.pos)
      }
    }
    function isParent(parent, of) {
      for (let cur = of; cur; cur = cur.parent) if (parent == cur) return true
      return false
    }
    // Check whether a delimited node is aligned (meaning there are
    // non-skipped nodes on the same line as the opening delimiter). And
    // if so, return the opening token.
    function bracketedAligned(context) {
      let tree = context.node
      let openToken = tree.childAfter(tree.from),
        last = tree.lastChild
      if (!openToken) return null
      let sim = context.options.simulateBreak
      let openLine = context.state.doc.lineAt(openToken.from)
      let lineEnd =
        sim == null || sim <= openLine.from
          ? openLine.to
          : Math.min(openLine.to, sim)
      for (let pos = openToken.to; ; ) {
        let next = tree.childAfter(pos)
        if (!next || next == last) return null
        if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null
        pos = next.to
      }
    }
    /**
An indentation strategy for delimited (usually bracketed) nodes.
Will, by default, indent one unit more than the parent's base
indent unless the line starts with a closing token. When `align`
is true and there are non-skipped nodes on the node's opening
line, the content of the node will be aligned with the end of the
opening node, like this:

    foo(bar,
        baz)
*/
    function delimitedIndent({ closing, align = true, units = 1 }) {
      return (context) => delimitedStrategy(context, align, units, closing)
    }
    function delimitedStrategy(context, align, units, closing, closedAt) {
      let after = context.textAfter,
        space = after.match(/^\s*/)[0].length
      let closed =
        (closing && after.slice(space, space + closing.length) == closing) ||
        closedAt == context.pos + space
      let aligned = align ? bracketedAligned(context) : null
      if (aligned)
        return closed
          ? context.column(aligned.from)
          : context.column(aligned.to)
      return context.baseIndent + (closed ? 0 : context.unit * units)
    }
    /**
An indentation strategy that aligns a node's content to its base
indentation.
*/
    const flatIndent = (context) => context.baseIndent
    /**
Creates an indentation strategy that, by default, indents
continued lines one unit more than the node's base indentation.
You can provide `except` to prevent indentation of lines that
match a pattern (for example `/^else\b/` in `if`/`else`
constructs), and you can change the amount of units used with the
`units` option.
*/
    function continuedIndent({ except, units = 1 } = {}) {
      return (context) => {
        let matchExcept = except && except.test(context.textAfter)
        return context.baseIndent + (matchExcept ? 0 : units * context.unit)
      }
    }
    const DontIndentBeyond = 200
    /**
Enables reindentation on input. When a language defines an
`indentOnInput` field in its [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
expression, the line at the cursor will be reindented whenever new
text is typed and the input from the start of the line up to the
cursor matches that regexp.

To avoid unneccesary reindents, it is recommended to start the
regexp with `^` (usually followed by `\s*`), and end it with `$`.
For example, `/^\s*\}$/` will reindent when a closing brace is
added at the start of a line.
*/
    function indentOnInput() {
      return EditorState.transactionFilter.of((tr) => {
        if (
          !tr.docChanged ||
          (!tr.isUserEvent('input.type') && !tr.isUserEvent('input.complete'))
        )
          return tr
        let rules = tr.startState.languageDataAt(
          'indentOnInput',
          tr.startState.selection.main.head
        )
        if (!rules.length) return tr
        let doc = tr.newDoc,
          { head } = tr.newSelection.main,
          line = doc.lineAt(head)
        if (head > line.from + DontIndentBeyond) return tr
        let lineStart = doc.sliceString(line.from, head)
        if (!rules.some((r) => r.test(lineStart))) return tr
        let { state } = tr,
          last = -1,
          changes = []
        for (let { head } of state.selection.ranges) {
          let line = state.doc.lineAt(head)
          if (line.from == last) continue
          last = line.from
          let indent = getIndentation(state, line.from)
          if (indent == null) continue
          let cur = /^\s*/.exec(line.text)[0]
          let norm = indentString(state, indent)
          if (cur != norm)
            changes.push({
              from: line.from,
              to: line.from + cur.length,
              insert: norm
            })
        }
        return changes.length ? [tr, { changes, sequential: true }] : tr
      })
    }

    /**
A facet that registers a code folding service. When called with
the extent of a line, such a function should return a foldable
range that starts on that line (but continues beyond it), if one
can be found.
*/
    const foldService = /*@__PURE__*/ Facet.define()
    /**
This node prop is used to associate folding information with
syntax node types. Given a syntax node, it should check whether
that tree is foldable and return the range that can be collapsed
when it is.
*/
    const foldNodeProp = /*@__PURE__*/ new dist_NodeProp()
    /**
[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
the first and the last child of a syntax node. Useful for nodes
that start and end with delimiters.
*/
    function foldInside(node) {
      let first = node.firstChild,
        last = node.lastChild
      return first && first.to < last.from
        ? { from: first.to, to: last.type.isError ? node.to : last.from }
        : null
    }
    function syntaxFolding(state, start, end) {
      let tree = dist_syntaxTree(state)
      if (tree.length < end) return null
      let stack = tree.resolveStack(end, 1)
      let found = null
      for (let iter = stack; iter; iter = iter.next) {
        let cur = iter.node
        if (cur.to <= end || cur.from > end) continue
        if (found && cur.from < start) break
        let prop = cur.type.prop(foldNodeProp)
        if (
          prop &&
          (cur.to < tree.length - 50 ||
            tree.length == state.doc.length ||
            !isUnfinished(cur))
        ) {
          let value = prop(cur, state)
          if (
            value &&
            value.from <= end &&
            value.from >= start &&
            value.to > end
          )
            found = value
        }
      }
      return found
    }
    function isUnfinished(node) {
      let ch = node.lastChild
      return ch && ch.to == node.to && ch.type.isError
    }
    /**
Check whether the given line is foldable. First asks any fold
services registered through
[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
a result, tries to query the [fold node
prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
of the line.
*/
    function foldable(state, lineStart, lineEnd) {
      for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd)
        if (result) return result
      }
      return syntaxFolding(state, lineStart, lineEnd)
    }
    function mapRange(range, mapping) {
      let from = mapping.mapPos(range.from, 1),
        to = mapping.mapPos(range.to, -1)
      return from >= to ? undefined : { from, to }
    }
    /**
State effect that can be attached to a transaction to fold the
given range. (You probably only need this in exceptional
circumstances—usually you'll just want to let
[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold
gutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)
*/
    const foldEffect = /*@__PURE__*/ StateEffect.define({ map: mapRange })
    /**
State effect that unfolds the given range (if it was folded).
*/
    const unfoldEffect = /*@__PURE__*/ StateEffect.define({ map: mapRange })
    function selectedLines(view) {
      let lines = []
      for (let { head } of view.state.selection.ranges) {
        if (lines.some((l) => l.from <= head && l.to >= head)) continue
        lines.push(view.lineBlockAt(head))
      }
      return lines
    }
    /**
The state field that stores the folded ranges (as a [decoration
set](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to
[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and
[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold
state.
*/
    const foldState = /*@__PURE__*/ StateField.define({
      create() {
        return Decoration.none
      },
      update(folded, tr) {
        folded = folded.map(tr.changes)
        for (let e of tr.effects) {
          if (
            e.is(foldEffect) &&
            !foldExists(folded, e.value.from, e.value.to)
          ) {
            let { preparePlaceholder } = tr.state.facet(foldConfig)
            let widget = !preparePlaceholder
              ? foldWidget
              : Decoration.replace({
                  widget: new PreparedFoldWidget(
                    preparePlaceholder(tr.state, e.value)
                  )
                })
            folded = folded.update({
              add: [widget.range(e.value.from, e.value.to)]
            })
          } else if (e.is(unfoldEffect)) {
            folded = folded.update({
              filter: (from, to) => e.value.from != from || e.value.to != to,
              filterFrom: e.value.from,
              filterTo: e.value.to
            })
          }
        }
        // Clear folded ranges that cover the selection head
        if (tr.selection) {
          let onSelection = false,
            { head } = tr.selection.main
          folded.between(head, head, (a, b) => {
            if (a < head && b > head) onSelection = true
          })
          if (onSelection)
            folded = folded.update({
              filterFrom: head,
              filterTo: head,
              filter: (a, b) => b <= head || a >= head
            })
        }
        return folded
      },
      provide: (f) => EditorView.decorations.from(f),
      toJSON(folded, state) {
        let ranges = []
        folded.between(0, state.doc.length, (from, to) => {
          ranges.push(from, to)
        })
        return ranges
      },
      fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
          throw new RangeError('Invalid JSON for fold state')
        let ranges = []
        for (let i = 0; i < value.length; ) {
          let from = value[i++],
            to = value[i++]
          if (typeof from != 'number' || typeof to != 'number')
            throw new RangeError('Invalid JSON for fold state')
          ranges.push(foldWidget.range(from, to))
        }
        return Decoration.set(ranges, true)
      }
    })
    /**
Get a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges
in the given state.
*/
    function foldedRanges(state) {
      return state.field(foldState, false) || RangeSet.empty
    }
    function findFold(state, from, to) {
      var _a
      let found = null
      ;(_a = state.field(foldState, false)) === null || _a === void 0
        ? void 0
        : _a.between(from, to, (from, to) => {
            if (!found || found.from > from) found = { from, to }
          })
      return found
    }
    function foldExists(folded, from, to) {
      let found = false
      folded.between(from, from, (a, b) => {
        if (a == from && b == to) found = true
      })
      return found
    }
    function maybeEnable(state, other) {
      return state.field(foldState, false)
        ? other
        : other.concat(StateEffect.appendConfig.of(codeFolding()))
    }
    /**
Fold the lines that are selected, if possible.
*/
    const foldCode = (view) => {
      for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to)
        if (range) {
          view.dispatch({
            effects: maybeEnable(view.state, [
              foldEffect.of(range),
              announceFold(view, range)
            ])
          })
          return true
        }
      }
      return false
    }
    /**
Unfold folded ranges on selected lines.
*/
    const unfoldCode = (view) => {
      if (!view.state.field(foldState, false)) return false
      let effects = []
      for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to)
        if (folded)
          effects.push(
            unfoldEffect.of(folded),
            announceFold(view, folded, false)
          )
      }
      if (effects.length) view.dispatch({ effects })
      return effects.length > 0
    }
    function announceFold(view, range, fold = true) {
      let lineFrom = view.state.doc.lineAt(range.from).number,
        lineTo = view.state.doc.lineAt(range.to).number
      return EditorView.announce.of(
        `${view.state.phrase(
          fold ? 'Folded lines' : 'Unfolded lines'
        )} ${lineFrom} ${view.state.phrase('to')} ${lineTo}.`
      )
    }
    /**
Fold all top-level foldable ranges. Note that, in most cases,
folding information will depend on the [syntax
tree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work
reliably when the document hasn't been fully parsed (either
because the editor state was only just initialized, or because the
document is so big that the parser decided not to parse it
entirely).
*/
    const foldAll = (view) => {
      let { state } = view,
        effects = []
      for (let pos = 0; pos < state.doc.length; ) {
        let line = view.lineBlockAt(pos),
          range = foldable(state, line.from, line.to)
        if (range) effects.push(foldEffect.of(range))
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1
      }
      if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) })
      return !!effects.length
    }
    /**
Unfold all folded code.
*/
    const unfoldAll = (view) => {
      let field = view.state.field(foldState, false)
      if (!field || !field.size) return false
      let effects = []
      field.between(0, view.state.doc.length, (from, to) => {
        effects.push(unfoldEffect.of({ from, to }))
      })
      view.dispatch({ effects })
      return true
    }
    // Find the foldable region containing the given line, if one exists
    function foldableContainer(view, lineBlock) {
      // Look backwards through line blocks until we find a foldable region that
      // intersects with the line
      for (let line = lineBlock; ; ) {
        let foldableRegion = foldable(view.state, line.from, line.to)
        if (foldableRegion && foldableRegion.to > lineBlock.from)
          return foldableRegion
        if (!line.from) return null
        line = view.lineBlockAt(line.from - 1)
      }
    }
    /**
Toggle folding at cursors. Unfolds if there is an existing fold
starting in that line, tries to find a foldable range around it
otherwise.
*/
    const toggleFold = (view) => {
      let effects = []
      for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to)
        if (folded) {
          effects.push(
            unfoldEffect.of(folded),
            announceFold(view, folded, false)
          )
        } else {
          let foldRange = foldableContainer(view, line)
          if (foldRange)
            effects.push(
              foldEffect.of(foldRange),
              announceFold(view, foldRange)
            )
        }
      }
      if (effects.length > 0)
        view.dispatch({ effects: maybeEnable(view.state, effects) })
      return !!effects.length
    }
    /**
Default fold-related key bindings.

 - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).
 - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).
 - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).
 - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).
*/
    const foldKeymap = [
      { key: 'Ctrl-Shift-[', mac: 'Cmd-Alt-[', run: foldCode },
      { key: 'Ctrl-Shift-]', mac: 'Cmd-Alt-]', run: unfoldCode },
      { key: 'Ctrl-Alt-[', run: foldAll },
      { key: 'Ctrl-Alt-]', run: unfoldAll }
    ]
    const defaultConfig = {
      placeholderDOM: null,
      preparePlaceholder: null,
      placeholderText: '…'
    }
    const foldConfig = /*@__PURE__*/ Facet.define({
      combine(values) {
        return combineConfig(values, defaultConfig)
      }
    })
    /**
Create an extension that configures code folding.
*/
    function codeFolding(config) {
      let result = [foldState, dist_baseTheme$1]
      if (config) result.push(foldConfig.of(config))
      return result
    }
    function widgetToDOM(view, prepared) {
      let { state } = view,
        conf = state.facet(foldConfig)
      let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target))
        let folded = findFold(view.state, line.from, line.to)
        if (folded) view.dispatch({ effects: unfoldEffect.of(folded) })
        event.preventDefault()
      }
      if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick, prepared)
      let element = document.createElement('span')
      element.textContent = conf.placeholderText
      element.setAttribute('aria-label', state.phrase('folded code'))
      element.title = state.phrase('unfold')
      element.className = 'cm-foldPlaceholder'
      element.onclick = onclick
      return element
    }
    const foldWidget = /*@__PURE__*/ Decoration.replace({
      widget: /*@__PURE__*/ new (class extends WidgetType {
        toDOM(view) {
          return widgetToDOM(view, null)
        }
      })()
    })
    class PreparedFoldWidget extends WidgetType {
      constructor(value) {
        super()
        this.value = value
      }
      eq(other) {
        return this.value == other.value
      }
      toDOM(view) {
        return widgetToDOM(view, this.value)
      }
    }
    const foldGutterDefaults = {
      openText: '⌄',
      closedText: '›',
      markerDOM: null,
      domEventHandlers: {},
      foldingChanged: () => false
    }
    class FoldMarker extends GutterMarker {
      constructor(config, open) {
        super()
        this.config = config
        this.open = open
      }
      eq(other) {
        return this.config == other.config && this.open == other.open
      }
      toDOM(view) {
        if (this.config.markerDOM) return this.config.markerDOM(this.open)
        let span = document.createElement('span')
        span.textContent = this.open
          ? this.config.openText
          : this.config.closedText
        span.title = view.state.phrase(this.open ? 'Fold line' : 'Unfold line')
        return span
      }
    }
    /**
Create an extension that registers a fold gutter, which shows a
fold status indicator before foldable lines (which can be clicked
to fold or unfold the line).
*/
    function foldGutter(config = {}) {
      let fullConfig = Object.assign(
        Object.assign({}, foldGutterDefaults),
        config
      )
      let canFold = new FoldMarker(fullConfig, true),
        canUnfold = new FoldMarker(fullConfig, false)
      let markers = dist_ViewPlugin.fromClass(
        class {
          constructor(view) {
            this.from = view.viewport.from
            this.markers = this.buildMarkers(view)
          }
          update(update) {
            if (
              update.docChanged ||
              update.viewportChanged ||
              update.startState.facet(language) !=
                update.state.facet(language) ||
              update.startState.field(foldState, false) !=
                update.state.field(foldState, false) ||
              dist_syntaxTree(update.startState) !=
                dist_syntaxTree(update.state) ||
              fullConfig.foldingChanged(update)
            )
              this.markers = this.buildMarkers(update.view)
          }
          buildMarkers(view) {
            let builder = new RangeSetBuilder()
            for (let line of view.viewportLineBlocks) {
              let mark = findFold(view.state, line.from, line.to)
                ? canUnfold
                : foldable(view.state, line.from, line.to)
                  ? canFold
                  : null
              if (mark) builder.add(line.from, line.from, mark)
            }
            return builder.finish()
          }
        }
      )
      let { domEventHandlers } = fullConfig
      return [
        markers,
        gutter({
          class: 'cm-foldGutter',
          markers(view) {
            var _a
            return (
              ((_a = view.plugin(markers)) === null || _a === void 0
                ? void 0
                : _a.markers) || dist_RangeSet.empty
            )
          },
          initialSpacer() {
            return new FoldMarker(fullConfig, false)
          },
          domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {
            click: (view, line, event) => {
              if (
                domEventHandlers.click &&
                domEventHandlers.click(view, line, event)
              )
                return true
              let folded = findFold(view.state, line.from, line.to)
              if (folded) {
                view.dispatch({ effects: unfoldEffect.of(folded) })
                return true
              }
              let range = foldable(view.state, line.from, line.to)
              if (range) {
                view.dispatch({ effects: foldEffect.of(range) })
                return true
              }
              return false
            }
          })
        }),
        codeFolding()
      ]
    }
    const dist_baseTheme$1 = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-foldPlaceholder': {
        backgroundColor: '#eee',
        border: '1px solid #ddd',
        color: '#888',
        borderRadius: '.2em',
        margin: '0 1px',
        padding: '0 1px',
        cursor: 'pointer'
      },
      '.cm-foldGutter span': {
        padding: '0 1px',
        cursor: 'pointer'
      }
    })

    /**
A highlight style associates CSS styles with higlighting
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).
*/
    class HighlightStyle {
      constructor(
        /**
    The tag styles used to create this highlight style.
    */
        specs,
        options
      ) {
        this.specs = specs
        let modSpec
        function def(spec) {
          let cls = StyleModule.newName()
          ;(modSpec || (modSpec = Object.create(null)))['.' + cls] = spec
          return cls
        }
        const all =
          typeof options.all == 'string'
            ? options.all
            : options.all
              ? def(options.all)
              : undefined
        const scopeOpt = options.scope
        this.scope =
          scopeOpt instanceof Language
            ? (type) => type.prop(languageDataProp) == scopeOpt.data
            : scopeOpt
              ? (type) => type == scopeOpt
              : undefined
        this.style = tagHighlighter(
          specs.map((style) => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
          })),
          {
            all
          }
        ).style
        this.module = modSpec ? new StyleModule(modSpec) : null
        this.themeType = options.themeType
      }
      /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
      static define(specs, options) {
        return new HighlightStyle(specs, options || {})
      }
    }
    const highlighterFacet = /*@__PURE__*/ Facet.define()
    const fallbackHighlighter = /*@__PURE__*/ Facet.define({
      combine(values) {
        return values.length ? [values[0]] : null
      }
    })
    function getHighlighters(state) {
      let main = state.facet(highlighterFacet)
      return main.length ? main : state.facet(fallbackHighlighter)
    }
    /**
Wrap a highlighter in an editor extension that uses it to apply
syntax highlighting to the editor content.

When multiple (non-fallback) styles are provided, the styling
applied is the union of the classes they emit.
*/
    function dist_syntaxHighlighting(highlighter, options) {
      let ext = [treeHighlighter],
        themeType
      if (highlighter instanceof HighlightStyle) {
        if (highlighter.module)
          ext.push(EditorView.styleModule.of(highlighter.module))
        themeType = highlighter.themeType
      }
      if (options === null || options === void 0 ? void 0 : options.fallback)
        ext.push(fallbackHighlighter.of(highlighter))
      else if (themeType)
        ext.push(
          highlighterFacet.computeN([EditorView.darkTheme], (state) => {
            return state.facet(EditorView.darkTheme) == (themeType == 'dark')
              ? [highlighter]
              : []
          })
        )
      else ext.push(highlighterFacet.of(highlighter))
      return ext
    }
    /**
Returns the CSS classes (if any) that the highlighters active in
the state would assign to the given style
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and
(optional) language
[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).
*/
    function highlightingFor(state, tags, scope) {
      let highlighters = getHighlighters(state)
      let result = null
      if (highlighters)
        for (let highlighter of highlighters) {
          if (!highlighter.scope || (scope && highlighter.scope(scope))) {
            let cls = highlighter.style(tags)
            if (cls) result = result ? result + ' ' + cls : cls
          }
        }
      return result
    }
    class TreeHighlighter {
      constructor(view) {
        this.markCache = Object.create(null)
        this.tree = dist_syntaxTree(view.state)
        this.decorations = this.buildDeco(view, getHighlighters(view.state))
      }
      update(update) {
        let tree = dist_syntaxTree(update.state),
          highlighters = getHighlighters(update.state)
        let styleChange = highlighters != getHighlighters(update.startState)
        if (
          tree.length < update.view.viewport.to &&
          !styleChange &&
          tree.type == this.tree.type
        ) {
          this.decorations = this.decorations.map(update.changes)
        } else if (tree != this.tree || update.viewportChanged || styleChange) {
          this.tree = tree
          this.decorations = this.buildDeco(update.view, highlighters)
        }
      }
      buildDeco(view, highlighters) {
        if (!highlighters || !this.tree.length) return Decoration.none
        let builder = new RangeSetBuilder()
        for (let { from, to } of view.visibleRanges) {
          highlightTree(
            this.tree,
            highlighters,
            (from, to, style) => {
              builder.add(
                from,
                to,
                this.markCache[style] ||
                  (this.markCache[style] = Decoration.mark({ class: style }))
              )
            },
            from,
            to
          )
        }
        return builder.finish()
      }
    }
    const treeHighlighter = /*@__PURE__*/ Prec.high(
      /*@__PURE__*/ dist_ViewPlugin.fromClass(TreeHighlighter, {
        decorations: (v) => v.decorations
      })
    )
    /**
A default highlight style (works well with light themes).
*/
    const dist_defaultHighlightStyle = /*@__PURE__*/ HighlightStyle.define([
      { tag: tags.meta, color: '#404740' },
      { tag: tags.link, textDecoration: 'underline' },
      { tag: tags.heading, textDecoration: 'underline', fontWeight: 'bold' },
      { tag: tags.emphasis, fontStyle: 'italic' },
      { tag: tags.strong, fontWeight: 'bold' },
      { tag: tags.strikethrough, textDecoration: 'line-through' },
      { tag: tags.keyword, color: '#708' },
      {
        tag: [
          tags.atom,
          tags.bool,
          tags.url,
          tags.contentSeparator,
          tags.labelName
        ],
        color: '#219'
      },
      { tag: [tags.literal, tags.inserted], color: '#164' },
      { tag: [tags.string, tags.deleted], color: '#a11' },
      {
        tag: [
          tags.regexp,
          tags.escape,
          /*@__PURE__*/ tags.special(tags.string)
        ],
        color: '#e40'
      },
      { tag: /*@__PURE__*/ tags.definition(tags.variableName), color: '#00f' },
      { tag: /*@__PURE__*/ tags.local(tags.variableName), color: '#30a' },
      { tag: [tags.typeName, tags.namespace], color: '#085' },
      { tag: tags.className, color: '#167' },
      {
        tag: [/*@__PURE__*/ tags.special(tags.variableName), tags.macroName],
        color: '#256'
      },
      { tag: /*@__PURE__*/ tags.definition(tags.propertyName), color: '#00c' },
      { tag: tags.comment, color: '#940' },
      { tag: tags.invalid, color: '#f00' }
    ])

    const dist_baseTheme = /*@__PURE__*/ EditorView.baseTheme({
      '&.cm-focused .cm-matchingBracket': { backgroundColor: '#328c8252' },
      '&.cm-focused .cm-nonmatchingBracket': { backgroundColor: '#bb555544' }
    })
    const DefaultScanDist = 10000,
      DefaultBrackets = '()[]{}'
    const bracketMatchingConfig = /*@__PURE__*/ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          afterCursor: true,
          brackets: DefaultBrackets,
          maxScanDistance: DefaultScanDist,
          renderMatch: defaultRenderMatch
        })
      }
    })
    const matchingMark = /*@__PURE__*/ Decoration.mark({
        class: 'cm-matchingBracket'
      }),
      nonmatchingMark = /*@__PURE__*/ Decoration.mark({
        class: 'cm-nonmatchingBracket'
      })
    function defaultRenderMatch(match) {
      let decorations = []
      let mark = match.matched ? matchingMark : nonmatchingMark
      decorations.push(mark.range(match.start.from, match.start.to))
      if (match.end) decorations.push(mark.range(match.end.from, match.end.to))
      return decorations
    }
    const bracketMatchingState = /*@__PURE__*/ StateField.define({
      create() {
        return Decoration.none
      },
      update(deco, tr) {
        if (!tr.docChanged && !tr.selection) return deco
        let decorations = []
        let config = tr.state.facet(bracketMatchingConfig)
        for (let range of tr.state.selection.ranges) {
          if (!range.empty) continue
          let match =
            matchBrackets(tr.state, range.head, -1, config) ||
            (range.head > 0 &&
              matchBrackets(tr.state, range.head - 1, 1, config)) ||
            (config.afterCursor &&
              (matchBrackets(tr.state, range.head, 1, config) ||
                (range.head < tr.state.doc.length &&
                  matchBrackets(tr.state, range.head + 1, -1, config))))
          if (match)
            decorations = decorations.concat(
              config.renderMatch(match, tr.state)
            )
        }
        return Decoration.set(decorations, true)
      },
      provide: (f) => EditorView.decorations.from(f)
    })
    const bracketMatchingUnique = [bracketMatchingState, dist_baseTheme]
    /**
Create an extension that enables bracket matching. Whenever the
cursor is next to a bracket, that bracket and the one it matches
are highlighted. Or, when no matching bracket is found, another
highlighting style is used to indicate this.
*/
    function bracketMatching(config = {}) {
      return [bracketMatchingConfig.of(config), bracketMatchingUnique]
    }
    /**
When larger syntax nodes, such as HTML tags, are marked as
opening/closing, it can be a bit messy to treat the whole node as
a matchable bracket. This node prop allows you to define, for such
a node, a ‘handle’—the part of the node that is highlighted, and
that the cursor must be on to activate highlighting in the first
place.
*/
    const bracketMatchingHandle = /*@__PURE__*/ new dist_NodeProp()
    function matchingNodes(node, dir, brackets) {
      let byProp = node.prop(
        dir < 0 ? dist_NodeProp.openedBy : dist_NodeProp.closedBy
      )
      if (byProp) return byProp
      if (node.name.length == 1) {
        let index = brackets.indexOf(node.name)
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
          return [brackets[index + dir]]
      }
      return null
    }
    function findHandle(node) {
      let hasHandle = node.type.prop(bracketMatchingHandle)
      return hasHandle ? hasHandle(node.node) : node
    }
    /**
Find the matching bracket for the token at `pos`, scanning
direction `dir`. Only the `brackets` and `maxScanDistance`
properties are used from `config`, if given. Returns null if no
bracket was found at `pos`, or a match result otherwise.
*/
    function matchBrackets(state, pos, dir, config = {}) {
      let maxScanDistance = config.maxScanDistance || DefaultScanDist,
        brackets = config.brackets || DefaultBrackets
      let tree = dist_syntaxTree(state),
        node = tree.resolveInner(pos, dir)
      for (let cur = node; cur; cur = cur.parent) {
        let matches = matchingNodes(cur.type, dir, brackets)
        if (matches && cur.from < cur.to) {
          let handle = findHandle(cur)
          if (
            handle &&
            (dir > 0
              ? pos >= handle.from && pos < handle.to
              : pos > handle.from && pos <= handle.to)
          )
            return matchMarkedBrackets(
              state,
              pos,
              dir,
              cur,
              handle,
              matches,
              brackets
            )
        }
      }
      return matchPlainBrackets(
        state,
        pos,
        dir,
        tree,
        node.type,
        maxScanDistance,
        brackets
      )
    }
    function matchMarkedBrackets(
      _state,
      _pos,
      dir,
      token,
      handle,
      matching,
      brackets
    ) {
      let parent = token.parent,
        firstToken = { from: handle.from, to: handle.to }
      let depth = 0,
        cursor = parent === null || parent === void 0 ? void 0 : parent.cursor()
      if (
        cursor &&
        (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))
      )
        do {
          if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
            if (
              depth == 0 &&
              matching.indexOf(cursor.type.name) > -1 &&
              cursor.from < cursor.to
            ) {
              let endHandle = findHandle(cursor)
              return {
                start: firstToken,
                end: endHandle
                  ? { from: endHandle.from, to: endHandle.to }
                  : undefined,
                matched: true
              }
            } else if (matchingNodes(cursor.type, dir, brackets)) {
              depth++
            } else if (matchingNodes(cursor.type, -dir, brackets)) {
              if (depth == 0) {
                let endHandle = findHandle(cursor)
                return {
                  start: firstToken,
                  end:
                    endHandle && endHandle.from < endHandle.to
                      ? { from: endHandle.from, to: endHandle.to }
                      : undefined,
                  matched: false
                }
              }
              depth--
            }
          }
        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling())
      return { start: firstToken, matched: false }
    }
    function matchPlainBrackets(
      state,
      pos,
      dir,
      tree,
      tokenType,
      maxScanDistance,
      brackets
    ) {
      let startCh =
        dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1)
      let bracket = brackets.indexOf(startCh)
      if (bracket < 0 || (bracket % 2 == 0) != dir > 0) return null
      let startToken = {
        from: dir < 0 ? pos - 1 : pos,
        to: dir > 0 ? pos + 1 : pos
      }
      let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),
        depth = 0
      for (
        let distance = 0;
        !iter.next().done && distance <= maxScanDistance;

      ) {
        let text = iter.value
        if (dir < 0) distance += text.length
        let basePos = pos + distance * dir
        for (
          let pos = dir > 0 ? 0 : text.length - 1,
            end = dir > 0 ? text.length : -1;
          pos != end;
          pos += dir
        ) {
          let found = brackets.indexOf(text[pos])
          if (
            found < 0 ||
            tree.resolveInner(basePos + pos, 1).type != tokenType
          )
            continue
          if ((found % 2 == 0) == dir > 0) {
            depth++
          } else if (depth == 1) {
            // Closing
            return {
              start: startToken,
              end: { from: basePos + pos, to: basePos + pos + 1 },
              matched: found >> 1 == bracket >> 1
            }
          } else {
            depth--
          }
        }
        if (dir > 0) distance += text.length
      }
      return iter.done ? { start: startToken, matched: false } : null
    }

    // Counts the column offset in a string, taking tabs into account.
    // Used mostly to find indentation.
    function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
      if (end == null) {
        end = string.search(/[^\s\u00a0]/)
        if (end == -1) end = string.length
      }
      let n = startValue
      for (let i = startIndex; i < end; i++) {
        if (string.charCodeAt(i) == 9) n += tabSize - (n % tabSize)
        else n++
      }
      return n
    }
    /**
Encapsulates a single line of input. Given to stream syntax code,
which uses it to tokenize the content.
*/
    class StringStream {
      /**
    Create a stream.
    */
      constructor(
        /**
    The line.
    */
        string,
        tabSize,
        /**
    The current indent unit size.
    */
        indentUnit,
        overrideIndent
      ) {
        this.string = string
        this.tabSize = tabSize
        this.indentUnit = indentUnit
        this.overrideIndent = overrideIndent
        /**
        The current position on the line.
        */
        this.pos = 0
        /**
        The start position of the current token.
        */
        this.start = 0
        this.lastColumnPos = 0
        this.lastColumnValue = 0
      }
      /**
    True if we are at the end of the line.
    */
      eol() {
        return this.pos >= this.string.length
      }
      /**
    True if we are at the start of the line.
    */
      sol() {
        return this.pos == 0
      }
      /**
    Get the next code unit after the current position, or undefined
    if we're at the end of the line.
    */
      peek() {
        return this.string.charAt(this.pos) || undefined
      }
      /**
    Read the next code unit and advance `this.pos`.
    */
      next() {
        if (this.pos < this.string.length) return this.string.charAt(this.pos++)
      }
      /**
    Match the next character against the given string, regular
    expression, or predicate. Consume and return it if it matches.
    */
      eat(match) {
        let ch = this.string.charAt(this.pos)
        let ok
        if (typeof match == 'string') ok = ch == match
        else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch))
        if (ok) {
          ++this.pos
          return ch
        }
      }
      /**
    Continue matching characters that match the given string,
    regular expression, or predicate function. Return true if any
    characters were consumed.
    */
      eatWhile(match) {
        let start = this.pos
        while (this.eat(match)) {}
        return this.pos > start
      }
      /**
    Consume whitespace ahead of `this.pos`. Return true if any was
    found.
    */
      eatSpace() {
        let start = this.pos
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos
        return this.pos > start
      }
      /**
    Move to the end of the line.
    */
      skipToEnd() {
        this.pos = this.string.length
      }
      /**
    Move to directly before the given character, if found on the
    current line.
    */
      skipTo(ch) {
        let found = this.string.indexOf(ch, this.pos)
        if (found > -1) {
          this.pos = found
          return true
        }
      }
      /**
    Move back `n` characters.
    */
      backUp(n) {
        this.pos -= n
      }
      /**
    Get the column position at `this.pos`.
    */
      column() {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countCol(
            this.string,
            this.start,
            this.tabSize,
            this.lastColumnPos,
            this.lastColumnValue
          )
          this.lastColumnPos = this.start
        }
        return this.lastColumnValue
      }
      /**
    Get the indentation column of the current line.
    */
      indentation() {
        var _a
        return (_a = this.overrideIndent) !== null && _a !== void 0
          ? _a
          : countCol(this.string, null, this.tabSize)
      }
      /**
    Match the input against the given string or regular expression
    (which should start with a `^`). Return true or the regexp match
    if it matches.
    
    Unless `consume` is set to `false`, this will move `this.pos`
    past the matched text.
    
    When matching a string `caseInsensitive` can be set to true to
    make the match case-insensitive.
    */
      match(pattern, consume, caseInsensitive) {
        if (typeof pattern == 'string') {
          let cased = (str) => (caseInsensitive ? str.toLowerCase() : str)
          let substr = this.string.substr(this.pos, pattern.length)
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) this.pos += pattern.length
            return true
          } else return null
        } else {
          let match = this.string.slice(this.pos).match(pattern)
          if (match && match.index > 0) return null
          if (match && consume !== false) this.pos += match[0].length
          return match
        }
      }
      /**
    Get the current token.
    */
      current() {
        return this.string.slice(this.start, this.pos)
      }
    }

    function fullParser(spec) {
      return {
        name: spec.name || '',
        token: spec.token,
        blankLine: spec.blankLine || (() => {}),
        startState: spec.startState || (() => true),
        copyState: spec.copyState || defaultCopyState,
        indent: spec.indent || (() => null),
        languageData: spec.languageData || {},
        tokenTable: spec.tokenTable || noTokens
      }
    }
    function defaultCopyState(state) {
      if (typeof state != 'object') return state
      let newState = {}
      for (let prop in state) {
        let val = state[prop]
        newState[prop] = val instanceof Array ? val.slice() : val
      }
      return newState
    }
    const IndentedFrom = /*@__PURE__*/ new WeakMap()
    /**
A [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror
5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).
*/
    class StreamLanguage
      extends /* unused pure expression or super */ (null && Language)
    {
      constructor(parser) {
        let data = defineLanguageFacet(parser.languageData)
        let p = fullParser(parser),
          self
        let impl = new (class extends Parser {
          createParse(input, fragments, ranges) {
            return new Parse(self, input, fragments, ranges)
          }
        })()
        super(
          data,
          impl,
          [indentService.of((cx, pos) => this.getIndent(cx, pos))],
          parser.name
        )
        this.topNode = docID(data)
        self = this
        this.streamParser = p
        this.stateAfter = new NodeProp({ perNode: true })
        this.tokenTable = parser.tokenTable
          ? new TokenTable(p.tokenTable)
          : defaultTokenTable
      }
      /**
    Define a stream language.
    */
      static define(spec) {
        return new StreamLanguage(spec)
      }
      getIndent(cx, pos) {
        let tree = dist_syntaxTree(cx.state),
          at = tree.resolve(pos)
        while (at && at.type != this.topNode) at = at.parent
        if (!at) return null
        let from = undefined
        let { overrideIndentation } = cx.options
        if (overrideIndentation) {
          from = IndentedFrom.get(cx.state)
          if (from != null && from < pos - 1e4) from = undefined
        }
        let start = findState(
            this,
            tree,
            0,
            at.from,
            from !== null && from !== void 0 ? from : pos
          ),
          statePos,
          state
        if (start) {
          state = start.state
          statePos = start.pos + 1
        } else {
          state = this.streamParser.startState(cx.unit)
          statePos = 0
        }
        if (pos - statePos > 10000 /* C.MaxIndentScanDist */) return null
        while (statePos < pos) {
          let line = cx.state.doc.lineAt(statePos),
            end = Math.min(pos, line.to)
          if (line.length) {
            let indentation = overrideIndentation
              ? overrideIndentation(line.from)
              : -1
            let stream = new StringStream(
              line.text,
              cx.state.tabSize,
              cx.unit,
              indentation < 0 ? undefined : indentation
            )
            while (stream.pos < end - line.from)
              readToken(this.streamParser.token, stream, state)
          } else {
            this.streamParser.blankLine(state, cx.unit)
          }
          if (end == pos) break
          statePos = line.to + 1
        }
        let line = cx.lineAt(pos)
        if (overrideIndentation && from == null)
          IndentedFrom.set(cx.state, line.from)
        return this.streamParser.indent(
          state,
          /^\s*(.*)/.exec(line.text)[1],
          cx
        )
      }
      get allowsNesting() {
        return false
      }
    }
    function findState(lang, tree, off, startPos, before) {
      let state =
        off >= startPos &&
        off + tree.length <= before &&
        tree.prop(lang.stateAfter)
      if (state)
        return {
          state: lang.streamParser.copyState(state),
          pos: off + tree.length
        }
      for (let i = tree.children.length - 1; i >= 0; i--) {
        let child = tree.children[i],
          pos = off + tree.positions[i]
        let found =
          child instanceof Tree &&
          pos < before &&
          findState(lang, child, pos, startPos, before)
        if (found) return found
      }
      return null
    }
    function cutTree(lang, tree, from, to, inside) {
      if (inside && from <= 0 && to >= tree.length) return tree
      if (!inside && tree.type == lang.topNode) inside = true
      for (let i = tree.children.length - 1; i >= 0; i--) {
        let pos = tree.positions[i],
          child = tree.children[i],
          inner
        if (pos < to && child instanceof Tree) {
          if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
            break
          return !inside
            ? inner
            : new Tree(
                tree.type,
                tree.children.slice(0, i).concat(inner),
                tree.positions.slice(0, i + 1),
                pos + inner.length
              )
        }
      }
      return null
    }
    function findStartInFragments(lang, fragments, startPos, editorState) {
      for (let f of fragments) {
        let from = f.from + (f.openStart ? 25 : 0),
          to = f.to - (f.openEnd ? 25 : 0)
        let found =
            from <= startPos &&
            to > startPos &&
            findState(lang, f.tree, 0 - f.offset, startPos, to),
          tree
        if (
          found &&
          (tree = cutTree(
            lang,
            f.tree,
            startPos + f.offset,
            found.pos + f.offset,
            false
          ))
        )
          return { state: found.state, tree }
      }
      return {
        state: lang.streamParser.startState(
          editorState ? getIndentUnit(editorState) : 4
        ),
        tree: Tree.empty
      }
    }
    class Parse {
      constructor(lang, input, fragments, ranges) {
        this.lang = lang
        this.input = input
        this.fragments = fragments
        this.ranges = ranges
        this.stoppedAt = null
        this.chunks = []
        this.chunkPos = []
        this.chunk = []
        this.chunkReused = undefined
        this.rangeIndex = 0
        this.to = ranges[ranges.length - 1].to
        let context = ParseContext.get(),
          from = ranges[0].from
        let { state, tree } = findStartInFragments(
          lang,
          fragments,
          from,
          context === null || context === void 0 ? void 0 : context.state
        )
        this.state = state
        this.parsedPos = this.chunkStart = from + tree.length
        for (let i = 0; i < tree.children.length; i++) {
          this.chunks.push(tree.children[i])
          this.chunkPos.push(tree.positions[i])
        }
        if (
          context &&
          this.parsedPos <
            context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */
        ) {
          this.state = this.lang.streamParser.startState(
            getIndentUnit(context.state)
          )
          context.skipUntilInView(this.parsedPos, context.viewport.from)
          this.parsedPos = context.viewport.from
        }
        this.moveRangeIndex()
      }
      advance() {
        let context = ParseContext.get()
        let parseEnd =
          this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt)
        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */)
        if (context) end = Math.min(end, context.viewport.to)
        while (this.parsedPos < end) this.parseLine(context)
        if (this.chunkStart < this.parsedPos) this.finishChunk()
        if (this.parsedPos >= parseEnd) return this.finish()
        if (context && this.parsedPos >= context.viewport.to) {
          context.skipUntilInView(this.parsedPos, parseEnd)
          return this.finish()
        }
        return null
      }
      stopAt(pos) {
        this.stoppedAt = pos
      }
      lineAfter(pos) {
        let chunk = this.input.chunk(pos)
        if (!this.input.lineChunks) {
          let eol = chunk.indexOf('\n')
          if (eol > -1) chunk = chunk.slice(0, eol)
        } else if (chunk == '\n') {
          chunk = ''
        }
        return pos + chunk.length <= this.to
          ? chunk
          : chunk.slice(0, this.to - pos)
      }
      nextLine() {
        let from = this.parsedPos,
          line = this.lineAfter(from),
          end = from + line.length
        for (let index = this.rangeIndex; ; ) {
          let rangeEnd = this.ranges[index].to
          if (rangeEnd >= end) break
          line = line.slice(0, rangeEnd - (end - line.length))
          index++
          if (index == this.ranges.length) break
          let rangeStart = this.ranges[index].from
          let after = this.lineAfter(rangeStart)
          line += after
          end = rangeStart + after.length
        }
        return { line, end }
      }
      skipGapsTo(pos, offset, side) {
        for (;;) {
          let end = this.ranges[this.rangeIndex].to,
            offPos = pos + offset
          if (side > 0 ? end > offPos : end >= offPos) break
          let start = this.ranges[++this.rangeIndex].from
          offset += start - end
        }
        return offset
      }
      moveRangeIndex() {
        while (this.ranges[this.rangeIndex].to < this.parsedPos)
          this.rangeIndex++
      }
      emitToken(id, from, to, size, offset) {
        if (this.ranges.length > 1) {
          offset = this.skipGapsTo(from, offset, 1)
          from += offset
          let len0 = this.chunk.length
          offset = this.skipGapsTo(to, offset, -1)
          to += offset
          size += this.chunk.length - len0
        }
        this.chunk.push(id, from, to, size)
        return offset
      }
      parseLine(context) {
        let { line, end } = this.nextLine(),
          offset = 0,
          { streamParser } = this.lang
        let stream = new StringStream(
          line,
          context ? context.state.tabSize : 4,
          context ? getIndentUnit(context.state) : 2
        )
        if (stream.eol()) {
          streamParser.blankLine(this.state, stream.indentUnit)
        } else {
          while (!stream.eol()) {
            let token = readToken(streamParser.token, stream, this.state)
            if (token)
              offset = this.emitToken(
                this.lang.tokenTable.resolve(token),
                this.parsedPos + stream.start,
                this.parsedPos + stream.pos,
                4,
                offset
              )
            if (stream.start > 10000 /* C.MaxLineLength */) break
          }
        }
        this.parsedPos = end
        this.moveRangeIndex()
        if (this.parsedPos < this.to) this.parsedPos++
      }
      finishChunk() {
        let tree = Tree.build({
          buffer: this.chunk,
          start: this.chunkStart,
          length: this.parsedPos - this.chunkStart,
          nodeSet,
          topID: 0,
          maxBufferLength: 2048 /* C.ChunkSize */,
          reused: this.chunkReused
        })
        tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [
          [this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]
        ])
        this.chunks.push(tree)
        this.chunkPos.push(this.chunkStart - this.ranges[0].from)
        this.chunk = []
        this.chunkReused = undefined
        this.chunkStart = this.parsedPos
      }
      finish() {
        return new Tree(
          this.lang.topNode,
          this.chunks,
          this.chunkPos,
          this.parsedPos - this.ranges[0].from
        ).balance()
      }
    }
    function readToken(token, stream, state) {
      stream.start = stream.pos
      for (let i = 0; i < 10; i++) {
        let result = token(stream, state)
        if (stream.pos > stream.start) return result
      }
      throw new Error('Stream parser failed to advance stream.')
    }
    const noTokens = /*@__PURE__*/ Object.create(null)
    const typeArray = [dist_NodeType.none]
    const nodeSet = /*@__PURE__*/ new NodeSet(typeArray)
    const warned = []
    // Cache of node types by name and tags
    const byTag = /*@__PURE__*/ Object.create(null)
    const defaultTable = /*@__PURE__*/ Object.create(null)
    for (let [legacyName, name] of [
      ['variable', 'variableName'],
      ['variable-2', 'variableName.special'],
      ['string-2', 'string.special'],
      ['def', 'variableName.definition'],
      ['tag', 'tagName'],
      ['attribute', 'attributeName'],
      ['type', 'typeName'],
      ['builtin', 'variableName.standard'],
      ['qualifier', 'modifier'],
      ['error', 'invalid'],
      ['header', 'heading'],
      ['property', 'propertyName']
    ])
      defaultTable[legacyName] = /*@__PURE__*/ createTokenType(noTokens, name)
    class TokenTable {
      constructor(extra) {
        this.extra = extra
        this.table = Object.assign(Object.create(null), defaultTable)
      }
      resolve(tag) {
        return !tag
          ? 0
          : this.table[tag] ||
              (this.table[tag] = createTokenType(this.extra, tag))
      }
    }
    const defaultTokenTable = /*@__PURE__*/ new TokenTable(noTokens)
    function warnForPart(part, msg) {
      if (warned.indexOf(part) > -1) return
      warned.push(part)
      console.warn(msg)
    }
    function createTokenType(extra, tagStr) {
      let tags$1 = []
      for (let name of tagStr.split(' ')) {
        let found = []
        for (let part of name.split('.')) {
          let value = extra[part] || tags[part]
          if (!value) {
            warnForPart(part, `Unknown highlighting tag ${part}`)
          } else if (typeof value == 'function') {
            if (!found.length)
              warnForPart(part, `Modifier ${part} used at start of tag`)
            else found = found.map(value)
          } else {
            if (found.length) warnForPart(part, `Tag ${part} used as modifier`)
            else found = Array.isArray(value) ? value : [value]
          }
        }
        for (let tag of found) tags$1.push(tag)
      }
      if (!tags$1.length) return 0
      let name = tagStr.replace(/ /g, '_'),
        key = name + ' ' + tags$1.map((t) => t.id)
      let known = byTag[key]
      if (known) return known.id
      let type = (byTag[key] = dist_NodeType.define({
        id: typeArray.length,
        name,
        props: [styleTags({ [name]: tags$1 })]
      }))
      typeArray.push(type)
      return type.id
    }
    function docID(data) {
      let type = NodeType.define({
        id: typeArray.length,
        name: 'Document',
        props: [languageDataProp.add(() => data)],
        top: true
      })
      typeArray.push(type)
      return type
    } // CONCATENATED MODULE: ./node_modules/@codemirror/commands/dist/index.js

    /**
Comment or uncomment the current selection. Will use line comments
if available, otherwise falling back to block comments.
*/
    const toggleComment = (target) => {
      let { state } = target,
        line = state.doc.lineAt(state.selection.main.from),
        config = dist_getConfig(target.state, line.from)
      return config.line
        ? toggleLineComment(target)
        : config.block
          ? toggleBlockCommentByLine(target)
          : false
    }
    function command(f, option) {
      return ({ state, dispatch }) => {
        if (state.readOnly) return false
        let tr = f(option, state)
        if (!tr) return false
        dispatch(state.update(tr))
        return true
      }
    }
    /**
Comment or uncomment the current selection using line comments.
The line comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
    const toggleLineComment = /*@__PURE__*/ command(
      changeLineComment,
      0 /* CommentOption.Toggle */
    )
    /**
Comment the current selection using line comments.
*/
    const lineComment =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      command(changeLineComment, 1 /* CommentOption.Comment */)
    /**
Uncomment the current selection using line comments.
*/
    const lineUncomment =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      command(changeLineComment, 2 /* CommentOption.Uncomment */)
    /**
Comment or uncomment the current selection using block comments.
The block comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
    const toggleBlockComment = /*@__PURE__*/ command(
      changeBlockComment,
      0 /* CommentOption.Toggle */
    )
    /**
Comment the current selection using block comments.
*/
    const blockComment =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      command(changeBlockComment, 1 /* CommentOption.Comment */)
    /**
Uncomment the current selection using block comments.
*/
    const blockUncomment =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      command(changeBlockComment, 2 /* CommentOption.Uncomment */)
    /**
Comment or uncomment the lines around the current selection using
block comments.
*/
    const toggleBlockCommentByLine = /*@__PURE__*/ command(
      (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
      0 /* CommentOption.Toggle */
    )
    function dist_getConfig(state, pos) {
      let data = state.languageDataAt('commentTokens', pos)
      return data.length ? data[0] : {}
    }
    const SearchMargin = 50
    /**
Determines if the given range is block-commented in the given
state.
*/
    function findBlockComment(state, { open, close }, from, to) {
      let textBefore = state.sliceDoc(from - SearchMargin, from)
      let textAfter = state.sliceDoc(to, to + SearchMargin)
      let spaceBefore = /\s*$/.exec(textBefore)[0].length,
        spaceAfter = /^\s*/.exec(textAfter)[0].length
      let beforeOff = textBefore.length - spaceBefore
      if (
        textBefore.slice(beforeOff - open.length, beforeOff) == open &&
        textAfter.slice(spaceAfter, spaceAfter + close.length) == close
      ) {
        return {
          open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
          close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
        }
      }
      let startText, endText
      if (to - from <= 2 * SearchMargin) {
        startText = endText = state.sliceDoc(from, to)
      } else {
        startText = state.sliceDoc(from, from + SearchMargin)
        endText = state.sliceDoc(to - SearchMargin, to)
      }
      let startSpace = /^\s*/.exec(startText)[0].length,
        endSpace = /\s*$/.exec(endText)[0].length
      let endOff = endText.length - endSpace - close.length
      if (
        startText.slice(startSpace, startSpace + open.length) == open &&
        endText.slice(endOff, endOff + close.length) == close
      ) {
        return {
          open: {
            pos: from + startSpace + open.length,
            margin: /\s/.test(startText.charAt(startSpace + open.length))
              ? 1
              : 0
          },
          close: {
            pos: to - endSpace - close.length,
            margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
          }
        }
      }
      return null
    }
    function selectedLineRanges(state) {
      let ranges = []
      for (let r of state.selection.ranges) {
        let fromLine = state.doc.lineAt(r.from)
        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to)
        let last = ranges.length - 1
        if (last >= 0 && ranges[last].to > fromLine.from)
          ranges[last].to = toLine.to
        else
          ranges.push({
            from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length,
            to: toLine.to
          })
      }
      return ranges
    }
    // Performs toggle, comment and uncomment of block comments in
    // languages that support them.
    function changeBlockComment(
      option,
      state,
      ranges = state.selection.ranges
    ) {
      let tokens = ranges.map((r) => dist_getConfig(state, r.from).block)
      if (!tokens.every((c) => c)) return null
      let comments = ranges.map((r, i) =>
        findBlockComment(state, tokens[i], r.from, r.to)
      )
      if (
        option != 2 /* CommentOption.Uncomment */ &&
        !comments.every((c) => c)
      ) {
        return {
          changes: state.changes(
            ranges.map((range, i) => {
              if (comments[i]) return []
              return [
                { from: range.from, insert: tokens[i].open + ' ' },
                { from: range.to, insert: ' ' + tokens[i].close }
              ]
            })
          )
        }
      } else if (
        option != 1 /* CommentOption.Comment */ &&
        comments.some((c) => c)
      ) {
        let changes = []
        for (let i = 0, comment; i < comments.length; i++)
          if ((comment = comments[i])) {
            let token = tokens[i],
              { open, close } = comment
            changes.push(
              {
                from: open.pos - token.open.length,
                to: open.pos + open.margin
              },
              {
                from: close.pos - close.margin,
                to: close.pos + token.close.length
              }
            )
          }
        return { changes }
      }
      return null
    }
    // Performs toggle, comment and uncomment of line comments.
    function changeLineComment(option, state, ranges = state.selection.ranges) {
      let lines = []
      let prevLine = -1
      for (let { from, to } of ranges) {
        let startI = lines.length,
          minIndent = 1e9
        let token = dist_getConfig(state, from).line
        if (!token) continue
        for (let pos = from; pos <= to; ) {
          let line = state.doc.lineAt(pos)
          if (line.from > prevLine && (from == to || to > line.from)) {
            prevLine = line.from
            let indent = /^\s*/.exec(line.text)[0].length
            let empty = indent == line.length
            let comment =
              line.text.slice(indent, indent + token.length) == token
                ? indent
                : -1
            if (indent < line.text.length && indent < minIndent)
              minIndent = indent
            lines.push({ line, comment, token, indent, empty, single: false })
          }
          pos = line.to + 1
        }
        if (minIndent < 1e9)
          for (let i = startI; i < lines.length; i++)
            if (lines[i].indent < lines[i].line.text.length)
              lines[i].indent = minIndent
        if (lines.length == startI + 1) lines[startI].single = true
      }
      if (
        option != 2 /* CommentOption.Uncomment */ &&
        lines.some((l) => l.comment < 0 && (!l.empty || l.single))
      ) {
        let changes = []
        for (let { line, token, indent, empty, single } of lines)
          if (single || !empty)
            changes.push({ from: line.from + indent, insert: token + ' ' })
        let changeSet = state.changes(changes)
        return {
          changes: changeSet,
          selection: state.selection.map(changeSet, 1)
        }
      } else if (
        option != 1 /* CommentOption.Comment */ &&
        lines.some((l) => l.comment >= 0)
      ) {
        let changes = []
        for (let { line, comment, token } of lines)
          if (comment >= 0) {
            let from = line.from + comment,
              to = from + token.length
            if (line.text[to - line.from] == ' ') to++
            changes.push({ from, to })
          }
        return { changes }
      }
      return null
    }

    const fromHistory = /*@__PURE__*/ Annotation.define()
    /**
Transaction annotation that will prevent that transaction from
being combined with other transactions in the undo history. Given
`"before"`, it'll prevent merging with previous transactions. With
`"after"`, subsequent transactions won't be combined with this
one. With `"full"`, the transaction is isolated on both sides.
*/
    const isolateHistory = /*@__PURE__*/ Annotation.define()
    /**
This facet provides a way to register functions that, given a
transaction, provide a set of effects that the history should
store when inverting the transaction. This can be used to
integrate some kinds of effects in the history, so that they can
be undone (and redone again).
*/
    const invertedEffects = /*@__PURE__*/ Facet.define()
    const historyConfig = /*@__PURE__*/ Facet.define({
      combine(configs) {
        return combineConfig(
          configs,
          {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (_t, isAdjacent) => isAdjacent
          },
          {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
          }
        )
      }
    })
    const historyField_ = /*@__PURE__*/ StateField.define({
      create() {
        return HistoryState.empty
      },
      update(state, tr) {
        let config = tr.state.facet(historyConfig)
        let fromHist = tr.annotation(fromHistory)
        if (fromHist) {
          let item = HistEvent.fromTransaction(tr, fromHist.selection),
            from = fromHist.side
          let other =
            from == 0 /* BranchName.Done */ ? state.undone : state.done
          if (item)
            other = updateBranch(other, other.length, config.minDepth, item)
          else other = addSelection(other, tr.startState.selection)
          return new HistoryState(
            from == 0 /* BranchName.Done */ ? fromHist.rest : other,
            from == 0 /* BranchName.Done */ ? other : fromHist.rest
          )
        }
        let isolate = tr.annotation(isolateHistory)
        if (isolate == 'full' || isolate == 'before') state = state.isolate()
        if (tr.annotation(Transaction.addToHistory) === false)
          return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state
        let event = HistEvent.fromTransaction(tr)
        let time = tr.annotation(Transaction.time),
          userEvent = tr.annotation(Transaction.userEvent)
        if (event) state = state.addChanges(event, time, userEvent, config, tr)
        else if (tr.selection)
          state = state.addSelection(
            tr.startState.selection,
            time,
            userEvent,
            config.newGroupDelay
          )
        if (isolate == 'full' || isolate == 'after') state = state.isolate()
        return state
      },
      toJSON(value) {
        return {
          done: value.done.map((e) => e.toJSON()),
          undone: value.undone.map((e) => e.toJSON())
        }
      },
      fromJSON(json) {
        return new HistoryState(
          json.done.map(HistEvent.fromJSON),
          json.undone.map(HistEvent.fromJSON)
        )
      }
    })
    /**
Create a history extension with the given configuration.
*/
    function dist_history(config = {}) {
      return [
        historyField_,
        historyConfig.of(config),
        EditorView.domEventHandlers({
          beforeinput(e, view) {
            let command =
              e.inputType == 'historyUndo'
                ? undo
                : e.inputType == 'historyRedo'
                  ? redo
                  : null
            if (!command) return false
            e.preventDefault()
            return command(view)
          }
        })
      ]
    }
    /**
The state field used to store the history data. Should probably
only be used when you want to
[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or
[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way
that preserves history.
*/
    const historyField =
      /* unused pure expression or super */ null && historyField_
    function cmd(side, selection) {
      return function ({ state, dispatch }) {
        if (!selection && state.readOnly) return false
        let historyState = state.field(historyField_, false)
        if (!historyState) return false
        let tr = historyState.pop(side, state, selection)
        if (!tr) return false
        dispatch(tr)
        return true
      }
    }
    /**
Undo a single group of history events. Returns false if no group
was available.
*/
    const undo = /*@__PURE__*/ cmd(0 /* BranchName.Done */, false)
    /**
Redo a group of history events. Returns false if no group was
available.
*/
    const redo = /*@__PURE__*/ cmd(1 /* BranchName.Undone */, false)
    /**
Undo a change or selection change.
*/
    const undoSelection = /*@__PURE__*/ cmd(0 /* BranchName.Done */, true)
    /**
Redo a change or selection change.
*/
    const redoSelection = /*@__PURE__*/ cmd(1 /* BranchName.Undone */, true)
    function depth(side) {
      return function (state) {
        let histState = state.field(historyField_, false)
        if (!histState) return 0
        let branch =
          side == 0 /* BranchName.Done */ ? histState.done : histState.undone
        return branch.length - (branch.length && !branch[0].changes ? 1 : 0)
      }
    }
    /**
The amount of undoable change events available in a given state.
*/
    const undoDepth =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      depth(0 /* BranchName.Done */)
    /**
The amount of redoable change events available in a given state.
*/
    const redoDepth =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      depth(1 /* BranchName.Undone */)
    // History events store groups of changes or effects that need to be
    // undone/redone together.
    class HistEvent {
      constructor(
        // The changes in this event. Normal events hold at least one
        // change or effect. But it may be necessary to store selection
        // events before the first change, in which case a special type of
        // instance is created which doesn't hold any changes, with
        // changes == startSelection == undefined
        changes,
        // The effects associated with this event
        effects,
        // Accumulated mapping (from addToHistory==false) that should be
        // applied to events below this one.
        mapped,
        // The selection before this event
        startSelection,
        // Stores selection changes after this event, to be used for
        // selection undo/redo.
        selectionsAfter
      ) {
        this.changes = changes
        this.effects = effects
        this.mapped = mapped
        this.startSelection = startSelection
        this.selectionsAfter = selectionsAfter
      }
      setSelAfter(after) {
        return new HistEvent(
          this.changes,
          this.effects,
          this.mapped,
          this.startSelection,
          after
        )
      }
      toJSON() {
        var _a, _b, _c
        return {
          changes:
            (_a = this.changes) === null || _a === void 0
              ? void 0
              : _a.toJSON(),
          mapped:
            (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
          startSelection:
            (_c = this.startSelection) === null || _c === void 0
              ? void 0
              : _c.toJSON(),
          selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
        }
      }
      static fromJSON(json) {
        return new HistEvent(
          json.changes && ChangeSet.fromJSON(json.changes),
          [],
          json.mapped && ChangeDesc.fromJSON(json.mapped),
          json.startSelection &&
            dist_EditorSelection.fromJSON(json.startSelection),
          json.selectionsAfter.map(dist_EditorSelection.fromJSON)
        )
      }
      // This does not check `addToHistory` and such, it assumes the
      // transaction needs to be converted to an item. Returns null when
      // there are no changes or effects in the transaction.
      static fromTransaction(tr, selection) {
        let effects = dist_none
        for (let invert of tr.startState.facet(invertedEffects)) {
          let result = invert(tr)
          if (result.length) effects = effects.concat(result)
        }
        if (!effects.length && tr.changes.empty) return null
        return new HistEvent(
          tr.changes.invert(tr.startState.doc),
          effects,
          undefined,
          selection || tr.startState.selection,
          dist_none
        )
      }
      static selection(selections) {
        return new HistEvent(
          undefined,
          dist_none,
          undefined,
          undefined,
          selections
        )
      }
    }
    function updateBranch(branch, to, maxLen, newEvent) {
      let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0
      let newBranch = branch.slice(start, to)
      newBranch.push(newEvent)
      return newBranch
    }
    function isAdjacent(a, b) {
      let ranges = [],
        isAdjacent = false
      a.iterChangedRanges((f, t) => ranges.push(f, t))
      b.iterChangedRanges((_f, _t, f, t) => {
        for (let i = 0; i < ranges.length; ) {
          let from = ranges[i++],
            to = ranges[i++]
          if (t >= from && f <= to) isAdjacent = true
        }
      })
      return isAdjacent
    }
    function eqSelectionShape(a, b) {
      return (
        a.ranges.length == b.ranges.length &&
        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0
      )
    }
    function conc(a, b) {
      return !a.length ? b : !b.length ? a : a.concat(b)
    }
    const dist_none = []
    const MaxSelectionsPerEvent = 200
    function addSelection(branch, selection) {
      if (!branch.length) {
        return [HistEvent.selection([selection])]
      } else {
        let lastEvent = branch[branch.length - 1]
        let sels = lastEvent.selectionsAfter.slice(
          Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent)
        )
        if (sels.length && sels[sels.length - 1].eq(selection)) return branch
        sels.push(selection)
        return updateBranch(
          branch,
          branch.length - 1,
          1e9,
          lastEvent.setSelAfter(sels)
        )
      }
    }
    // Assumes the top item has one or more selectionAfter values
    function popSelection(branch) {
      let last = branch[branch.length - 1]
      let newBranch = branch.slice()
      newBranch[branch.length - 1] = last.setSelAfter(
        last.selectionsAfter.slice(0, last.selectionsAfter.length - 1)
      )
      return newBranch
    }
    // Add a mapping to the top event in the given branch. If this maps
    // away all the changes and effects in that item, drop it and
    // propagate the mapping to the next item.
    function addMappingToBranch(branch, mapping) {
      if (!branch.length) return branch
      let length = branch.length,
        selections = dist_none
      while (length) {
        let event = mapEvent(branch[length - 1], mapping, selections)
        if ((event.changes && !event.changes.empty) || event.effects.length) {
          // Event survived mapping
          let result = branch.slice(0, length)
          result[length - 1] = event
          return result
        } else {
          // Drop this event, since there's no changes or effects left
          mapping = event.mapped
          length--
          selections = event.selectionsAfter
        }
      }
      return selections.length ? [HistEvent.selection(selections)] : dist_none
    }
    function mapEvent(event, mapping, extraSelections) {
      let selections = conc(
        event.selectionsAfter.length
          ? event.selectionsAfter.map((s) => s.map(mapping))
          : dist_none,
        extraSelections
      )
      // Change-less events don't store mappings (they are always the last event in a branch)
      if (!event.changes) return HistEvent.selection(selections)
      let mappedChanges = event.changes.map(mapping),
        before = mapping.mapDesc(event.changes, true)
      let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before
      return new HistEvent(
        mappedChanges,
        StateEffect.mapEffects(event.effects, mapping),
        fullMapping,
        event.startSelection.map(before),
        selections
      )
    }
    const joinableUserEvent = /^(input\.type|delete)($|\.)/
    class HistoryState {
      constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
        this.done = done
        this.undone = undone
        this.prevTime = prevTime
        this.prevUserEvent = prevUserEvent
      }
      isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this
      }
      addChanges(event, time, userEvent, config, tr) {
        let done = this.done,
          lastEvent = done[done.length - 1]
        if (
          lastEvent &&
          lastEvent.changes &&
          !lastEvent.changes.empty &&
          event.changes &&
          (!userEvent || joinableUserEvent.test(userEvent)) &&
          ((!lastEvent.selectionsAfter.length &&
            time - this.prevTime < config.newGroupDelay &&
            config.joinToEvent(
              tr,
              isAdjacent(lastEvent.changes, event.changes)
            )) ||
            // For compose (but not compose.start) events, always join with previous event
            userEvent == 'input.type.compose')
        ) {
          done = updateBranch(
            done,
            done.length - 1,
            config.minDepth,
            new HistEvent(
              event.changes.compose(lastEvent.changes),
              conc(event.effects, lastEvent.effects),
              lastEvent.mapped,
              lastEvent.startSelection,
              dist_none
            )
          )
        } else {
          done = updateBranch(done, done.length, config.minDepth, event)
        }
        return new HistoryState(done, dist_none, time, userEvent)
      }
      addSelection(selection, time, userEvent, newGroupDelay) {
        let last = this.done.length
          ? this.done[this.done.length - 1].selectionsAfter
          : dist_none
        if (
          last.length > 0 &&
          time - this.prevTime < newGroupDelay &&
          userEvent == this.prevUserEvent &&
          userEvent &&
          /^select($|\.)/.test(userEvent) &&
          eqSelectionShape(last[last.length - 1], selection)
        )
          return this
        return new HistoryState(
          addSelection(this.done, selection),
          this.undone,
          time,
          userEvent
        )
      }
      addMapping(mapping) {
        return new HistoryState(
          addMappingToBranch(this.done, mapping),
          addMappingToBranch(this.undone, mapping),
          this.prevTime,
          this.prevUserEvent
        )
      }
      pop(side, state, onlySelection) {
        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone
        if (branch.length == 0) return null
        let event = branch[branch.length - 1],
          selection = event.selectionsAfter[0] || state.selection
        if (onlySelection && event.selectionsAfter.length) {
          return state.update({
            selection: event.selectionsAfter[event.selectionsAfter.length - 1],
            annotations: fromHistory.of({
              side,
              rest: popSelection(branch),
              selection
            }),
            userEvent:
              side == 0 /* BranchName.Done */ ? 'select.undo' : 'select.redo',
            scrollIntoView: true
          })
        } else if (!event.changes) {
          return null
        } else {
          let rest =
            branch.length == 1 ? dist_none : branch.slice(0, branch.length - 1)
          if (event.mapped) rest = addMappingToBranch(rest, event.mapped)
          return state.update({
            changes: event.changes,
            selection: event.startSelection,
            effects: event.effects,
            annotations: fromHistory.of({ side, rest, selection }),
            filter: false,
            userEvent: side == 0 /* BranchName.Done */ ? 'undo' : 'redo',
            scrollIntoView: true
          })
        }
      }
    }
    HistoryState.empty = /*@__PURE__*/ new HistoryState(dist_none, dist_none)
    /**
Default key bindings for the undo history.

- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).
- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).
- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).
- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).
*/
    const dist_historyKeymap = [
      { key: 'Mod-z', run: undo, preventDefault: true },
      { key: 'Mod-y', mac: 'Mod-Shift-z', run: redo, preventDefault: true },
      { linux: 'Ctrl-Shift-z', run: redo, preventDefault: true },
      { key: 'Mod-u', run: undoSelection, preventDefault: true },
      {
        key: 'Alt-u',
        mac: 'Mod-Shift-u',
        run: redoSelection,
        preventDefault: true
      }
    ]

    function updateSel(sel, by) {
      return dist_EditorSelection.create(sel.ranges.map(by), sel.mainIndex)
    }
    function setSel(state, selection) {
      return state.update({
        selection,
        scrollIntoView: true,
        userEvent: 'select'
      })
    }
    function moveSel({ state, dispatch }, how) {
      let selection = updateSel(state.selection, how)
      if (selection.eq(state.selection)) return false
      dispatch(setSel(state, selection))
      return true
    }
    function rangeEnd(range, forward) {
      return dist_EditorSelection.cursor(forward ? range.to : range.from)
    }
    function cursorByChar(view, forward) {
      return moveSel(view, (range) =>
        range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward)
      )
    }
    function ltrAtCursor(view) {
      return (
        view.textDirectionAt(view.state.selection.main.head) == Direction.LTR
      )
    }
    /**
Move the selection one character to the left (which is backward in
left-to-right text, forward in right-to-left text).
*/
    const cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view))
    /**
Move the selection one character to the right.
*/
    const cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view))
    /**
Move the selection one character forward.
*/
    const cursorCharForward = (view) => cursorByChar(view, true)
    /**
Move the selection one character backward.
*/
    const cursorCharBackward = (view) => cursorByChar(view, false)
    function cursorByGroup(view, forward) {
      return moveSel(view, (range) =>
        range.empty
          ? view.moveByGroup(range, forward)
          : rangeEnd(range, forward)
      )
    }
    /**
Move the selection to the left across one group of word or
non-word (but also non-space) characters.
*/
    const cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view))
    /**
Move the selection one group to the right.
*/
    const cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view))
    /**
Move the selection one group forward.
*/
    const cursorGroupForward = (view) => cursorByGroup(view, true)
    /**
Move the selection one group backward.
*/
    const cursorGroupBackward = (view) => cursorByGroup(view, false)
    const segmenter =
      typeof Intl != 'undefined' && Intl.Segmenter
        ? /*@__PURE__*/ new Intl.Segmenter(undefined, { granularity: 'word' })
        : null
    function moveBySubword(view, range, forward) {
      let categorize = view.state.charCategorizer(range.from)
      let cat = CharCategory.Space,
        pos = range.from,
        steps = 0
      let done = false,
        sawUpper = false,
        sawLower = false
      let step = (next) => {
        if (done) return false
        pos += forward ? next.length : -next.length
        let nextCat = categorize(next),
          ahead
        if (
          nextCat == CharCategory.Word &&
          next.charCodeAt(0) < 128 &&
          /[\W_]/.test(next)
        )
          nextCat = -1 // Treat word punctuation specially
        if (cat == CharCategory.Space) cat = nextCat
        if (cat != nextCat) return false
        if (cat == CharCategory.Word) {
          if (next.toLowerCase() == next) {
            if (!forward && sawUpper) return false
            sawLower = true
          } else if (sawLower) {
            if (forward) return false
            done = true
          } else {
            if (
              sawUpper &&
              forward &&
              categorize((ahead = view.state.sliceDoc(pos, pos + 1))) ==
                CharCategory.Word &&
              ahead.toLowerCase() == ahead
            )
              return false
            sawUpper = true
          }
        }
        steps++
        return true
      }
      let end = view.moveByChar(range, forward, (start) => {
        step(start)
        return step
      })
      if (
        segmenter &&
        cat == CharCategory.Word &&
        end.from == range.from + steps * (forward ? 1 : -1)
      ) {
        let from = Math.min(range.head, end.head),
          to = Math.max(range.head, end.head)
        let skipped = view.state.sliceDoc(from, to)
        if (skipped.length > 1 && /[\u4E00-\uffff]/.test(skipped)) {
          let segments = Array.from(segmenter.segment(skipped))
          if (segments.length > 1) {
            if (forward)
              return EditorSelection.cursor(range.head + segments[1].index, -1)
            return EditorSelection.cursor(
              end.head + segments[segments.length - 1].index,
              1
            )
          }
        }
      }
      return end
    }
    function cursorBySubword(view, forward) {
      return moveSel(view, (range) =>
        range.empty
          ? moveBySubword(view, range, forward)
          : rangeEnd(range, forward)
      )
    }
    /**
Move the selection one group or camel-case subword forward.
*/
    const cursorSubwordForward = (view) => cursorBySubword(view, true)
    /**
Move the selection one group or camel-case subword backward.
*/
    const cursorSubwordBackward = (view) => cursorBySubword(view, false)
    function interestingNode(state, node, bracketProp) {
      if (node.type.prop(bracketProp)) return true
      let len = node.to - node.from
      return (
        (len &&
          (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to)))) ||
        node.firstChild
      )
    }
    function moveBySyntax(state, start, forward) {
      let pos = dist_syntaxTree(state).resolveInner(start.head)
      let bracketProp = forward
        ? dist_NodeProp.closedBy
        : dist_NodeProp.openedBy
      // Scan forward through child nodes to see if there's an interesting
      // node ahead.
      for (let at = start.head; ; ) {
        let next = forward ? pos.childAfter(at) : pos.childBefore(at)
        if (!next) break
        if (interestingNode(state, next, bracketProp)) pos = next
        else at = forward ? next.to : next.from
      }
      let bracket = pos.type.prop(bracketProp),
        match,
        newPos
      if (
        bracket &&
        (match = forward
          ? matchBrackets(state, pos.from, 1)
          : matchBrackets(state, pos.to, -1)) &&
        match.matched
      )
        newPos = forward ? match.end.to : match.end.from
      else newPos = forward ? pos.to : pos.from
      return dist_EditorSelection.cursor(newPos, forward ? -1 : 1)
    }
    /**
Move the cursor over the next syntactic element to the left.
*/
    const cursorSyntaxLeft = (view) =>
      moveSel(view, (range) =>
        moveBySyntax(view.state, range, !ltrAtCursor(view))
      )
    /**
Move the cursor over the next syntactic element to the right.
*/
    const cursorSyntaxRight = (view) =>
      moveSel(view, (range) =>
        moveBySyntax(view.state, range, ltrAtCursor(view))
      )
    function cursorByLine(view, forward) {
      return moveSel(view, (range) => {
        if (!range.empty) return rangeEnd(range, forward)
        let moved = view.moveVertically(range, forward)
        return moved.head != range.head
          ? moved
          : view.moveToLineBoundary(range, forward)
      })
    }
    /**
Move the selection one line up.
*/
    const cursorLineUp = (view) => cursorByLine(view, false)
    /**
Move the selection one line down.
*/
    const cursorLineDown = (view) => cursorByLine(view, true)
    function pageInfo(view) {
      let selfScroll =
        view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2
      let marginTop = 0,
        marginBottom = 0,
        height
      if (selfScroll) {
        for (let source of view.state.facet(EditorView.scrollMargins)) {
          let margins = source(view)
          if (margins === null || margins === void 0 ? void 0 : margins.top)
            marginTop = Math.max(
              margins === null || margins === void 0 ? void 0 : margins.top,
              marginTop
            )
          if (margins === null || margins === void 0 ? void 0 : margins.bottom)
            marginBottom = Math.max(
              margins === null || margins === void 0 ? void 0 : margins.bottom,
              marginBottom
            )
        }
        height = view.scrollDOM.clientHeight - marginTop - marginBottom
      } else {
        height = (view.dom.ownerDocument.defaultView || window).innerHeight
      }
      return {
        marginTop,
        marginBottom,
        selfScroll,
        height: Math.max(view.defaultLineHeight, height - 5)
      }
    }
    function cursorByPage(view, forward) {
      let page = pageInfo(view)
      let { state } = view,
        selection = updateSel(state.selection, (range) => {
          return range.empty
            ? view.moveVertically(range, forward, page.height)
            : rangeEnd(range, forward)
        })
      if (selection.eq(state.selection)) return false
      let effect
      if (page.selfScroll) {
        let startPos = view.coordsAtPos(state.selection.main.head)
        let scrollRect = view.scrollDOM.getBoundingClientRect()
        let scrollTop = scrollRect.top + page.marginTop,
          scrollBottom = scrollRect.bottom - page.marginBottom
        if (
          startPos &&
          startPos.top > scrollTop &&
          startPos.bottom < scrollBottom
        )
          effect = EditorView.scrollIntoView(selection.main.head, {
            y: 'start',
            yMargin: startPos.top - scrollTop
          })
      }
      view.dispatch(setSel(state, selection), { effects: effect })
      return true
    }
    /**
Move the selection one page up.
*/
    const cursorPageUp = (view) => cursorByPage(view, false)
    /**
Move the selection one page down.
*/
    const cursorPageDown = (view) => cursorByPage(view, true)
    function moveByLineBoundary(view, start, forward) {
      let line = view.lineBlockAt(start.head),
        moved = view.moveToLineBoundary(start, forward)
      if (
        moved.head == start.head &&
        moved.head != (forward ? line.to : line.from)
      )
        moved = view.moveToLineBoundary(start, forward, false)
      if (!forward && moved.head == line.from && line.length) {
        let space = /^\s*/.exec(
          view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to))
        )[0].length
        if (space && start.head != line.from + space)
          moved = dist_EditorSelection.cursor(line.from + space)
      }
      return moved
    }
    /**
Move the selection to the next line wrap point, or to the end of
the line if there isn't one left on this line.
*/
    const cursorLineBoundaryForward = (view) =>
      moveSel(view, (range) => moveByLineBoundary(view, range, true))
    /**
Move the selection to previous line wrap point, or failing that to
the start of the line. If the line is indented, and the cursor
isn't already at the end of the indentation, this will move to the
end of the indentation instead of the start of the line.
*/
    const cursorLineBoundaryBackward = (view) =>
      moveSel(view, (range) => moveByLineBoundary(view, range, false))
    /**
Move the selection one line wrap point to the left.
*/
    const cursorLineBoundaryLeft = (view) =>
      moveSel(view, (range) =>
        moveByLineBoundary(view, range, !ltrAtCursor(view))
      )
    /**
Move the selection one line wrap point to the right.
*/
    const cursorLineBoundaryRight = (view) =>
      moveSel(view, (range) =>
        moveByLineBoundary(view, range, ltrAtCursor(view))
      )
    /**
Move the selection to the start of the line.
*/
    const cursorLineStart = (view) =>
      moveSel(view, (range) =>
        dist_EditorSelection.cursor(view.lineBlockAt(range.head).from, 1)
      )
    /**
Move the selection to the end of the line.
*/
    const cursorLineEnd = (view) =>
      moveSel(view, (range) =>
        dist_EditorSelection.cursor(view.lineBlockAt(range.head).to, -1)
      )
    function toMatchingBracket(state, dispatch, extend) {
      let found = false,
        selection = updateSel(state.selection, (range) => {
          let matching =
            matchBrackets(state, range.head, -1) ||
            matchBrackets(state, range.head, 1) ||
            (range.head > 0 && matchBrackets(state, range.head - 1, 1)) ||
            (range.head < state.doc.length &&
              matchBrackets(state, range.head + 1, -1))
          if (!matching || !matching.end) return range
          found = true
          let head =
            matching.start.from == range.head
              ? matching.end.to
              : matching.end.from
          return extend
            ? dist_EditorSelection.range(range.anchor, head)
            : dist_EditorSelection.cursor(head)
        })
      if (!found) return false
      dispatch(setSel(state, selection))
      return true
    }
    /**
Move the selection to the bracket matching the one it is currently
on, if any.
*/
    const cursorMatchingBracket = ({ state, dispatch }) =>
      toMatchingBracket(state, dispatch, false)
    /**
Extend the selection to the bracket matching the one the selection
head is currently on, if any.
*/
    const selectMatchingBracket = ({ state, dispatch }) =>
      toMatchingBracket(state, dispatch, true)
    function extendSel(view, how) {
      let selection = updateSel(view.state.selection, (range) => {
        let head = how(range)
        return dist_EditorSelection.range(
          range.anchor,
          head.head,
          head.goalColumn,
          head.bidiLevel || undefined
        )
      })
      if (selection.eq(view.state.selection)) return false
      view.dispatch(setSel(view.state, selection))
      return true
    }
    function selectByChar(view, forward) {
      return extendSel(view, (range) => view.moveByChar(range, forward))
    }
    /**
Move the selection head one character to the left, while leaving
the anchor in place.
*/
    const selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view))
    /**
Move the selection head one character to the right.
*/
    const selectCharRight = (view) => selectByChar(view, ltrAtCursor(view))
    /**
Move the selection head one character forward.
*/
    const selectCharForward = (view) => selectByChar(view, true)
    /**
Move the selection head one character backward.
*/
    const selectCharBackward = (view) => selectByChar(view, false)
    function selectByGroup(view, forward) {
      return extendSel(view, (range) => view.moveByGroup(range, forward))
    }
    /**
Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
the left.
*/
    const selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view))
    /**
Move the selection head one group to the right.
*/
    const selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view))
    /**
Move the selection head one group forward.
*/
    const selectGroupForward = (view) => selectByGroup(view, true)
    /**
Move the selection head one group backward.
*/
    const selectGroupBackward = (view) => selectByGroup(view, false)
    function selectBySubword(view, forward) {
      return extendSel(view, (range) => moveBySubword(view, range, forward))
    }
    /**
Move the selection head one group or camel-case subword forward.
*/
    const selectSubwordForward = (view) => selectBySubword(view, true)
    /**
Move the selection head one group or subword backward.
*/
    const selectSubwordBackward = (view) => selectBySubword(view, false)
    /**
Move the selection head over the next syntactic element to the left.
*/
    const selectSyntaxLeft = (view) =>
      extendSel(view, (range) =>
        moveBySyntax(view.state, range, !ltrAtCursor(view))
      )
    /**
Move the selection head over the next syntactic element to the right.
*/
    const selectSyntaxRight = (view) =>
      extendSel(view, (range) =>
        moveBySyntax(view.state, range, ltrAtCursor(view))
      )
    function selectByLine(view, forward) {
      return extendSel(view, (range) => view.moveVertically(range, forward))
    }
    /**
Move the selection head one line up.
*/
    const selectLineUp = (view) => selectByLine(view, false)
    /**
Move the selection head one line down.
*/
    const selectLineDown = (view) => selectByLine(view, true)
    function selectByPage(view, forward) {
      return extendSel(view, (range) =>
        view.moveVertically(range, forward, pageInfo(view).height)
      )
    }
    /**
Move the selection head one page up.
*/
    const selectPageUp = (view) => selectByPage(view, false)
    /**
Move the selection head one page down.
*/
    const selectPageDown = (view) => selectByPage(view, true)
    /**
Move the selection head to the next line boundary.
*/
    const selectLineBoundaryForward = (view) =>
      extendSel(view, (range) => moveByLineBoundary(view, range, true))
    /**
Move the selection head to the previous line boundary.
*/
    const selectLineBoundaryBackward = (view) =>
      extendSel(view, (range) => moveByLineBoundary(view, range, false))
    /**
Move the selection head one line boundary to the left.
*/
    const selectLineBoundaryLeft = (view) =>
      extendSel(view, (range) =>
        moveByLineBoundary(view, range, !ltrAtCursor(view))
      )
    /**
Move the selection head one line boundary to the right.
*/
    const selectLineBoundaryRight = (view) =>
      extendSel(view, (range) =>
        moveByLineBoundary(view, range, ltrAtCursor(view))
      )
    /**
Move the selection head to the start of the line.
*/
    const selectLineStart = (view) =>
      extendSel(view, (range) =>
        dist_EditorSelection.cursor(view.lineBlockAt(range.head).from)
      )
    /**
Move the selection head to the end of the line.
*/
    const selectLineEnd = (view) =>
      extendSel(view, (range) =>
        dist_EditorSelection.cursor(view.lineBlockAt(range.head).to)
      )
    /**
Move the selection to the start of the document.
*/
    const cursorDocStart = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: 0 }))
      return true
    }
    /**
Move the selection to the end of the document.
*/
    const cursorDocEnd = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.doc.length }))
      return true
    }
    /**
Move the selection head to the start of the document.
*/
    const selectDocStart = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }))
      return true
    }
    /**
Move the selection head to the end of the document.
*/
    const selectDocEnd = ({ state, dispatch }) => {
      dispatch(
        setSel(state, {
          anchor: state.selection.main.anchor,
          head: state.doc.length
        })
      )
      return true
    }
    /**
Select the entire document.
*/
    const selectAll = ({ state, dispatch }) => {
      dispatch(
        state.update({
          selection: { anchor: 0, head: state.doc.length },
          userEvent: 'select'
        })
      )
      return true
    }
    /**
Expand the selection to cover entire lines.
*/
    const selectLine = ({ state, dispatch }) => {
      let ranges = selectedLineBlocks(state).map(({ from, to }) =>
        dist_EditorSelection.range(from, Math.min(to + 1, state.doc.length))
      )
      dispatch(
        state.update({
          selection: dist_EditorSelection.create(ranges),
          userEvent: 'select'
        })
      )
      return true
    }
    /**
Select the next syntactic construct that is larger than the
selection. Note that this will only work insofar as the language
[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
syntax tree.
*/
    const selectParentSyntax = ({ state, dispatch }) => {
      let selection = updateSel(state.selection, (range) => {
        var _a
        let stack = dist_syntaxTree(state).resolveStack(range.from, 1)
        for (let cur = stack; cur; cur = cur.next) {
          let { node } = cur
          if (
            ((node.from < range.from && node.to >= range.to) ||
              (node.to > range.to && node.from <= range.from)) &&
            ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)
          )
            return dist_EditorSelection.range(node.to, node.from)
        }
        return range
      })
      dispatch(setSel(state, selection))
      return true
    }
    /**
Simplify the current selection. When multiple ranges are selected,
reduce it to its main range. Otherwise, if the selection is
non-empty, convert it to a cursor selection.
*/
    const simplifySelection = ({ state, dispatch }) => {
      let cur = state.selection,
        selection = null
      if (cur.ranges.length > 1)
        selection = dist_EditorSelection.create([cur.main])
      else if (!cur.main.empty)
        selection = dist_EditorSelection.create([
          dist_EditorSelection.cursor(cur.main.head)
        ])
      if (!selection) return false
      dispatch(setSel(state, selection))
      return true
    }
    function deleteBy(target, by) {
      if (target.state.readOnly) return false
      let event = 'delete.selection',
        { state } = target
      let changes = state.changeByRange((range) => {
        let { from, to } = range
        if (from == to) {
          let towards = by(range)
          if (towards < from) {
            event = 'delete.backward'
            towards = skipAtomic(target, towards, false)
          } else if (towards > from) {
            event = 'delete.forward'
            towards = skipAtomic(target, towards, true)
          }
          from = Math.min(from, towards)
          to = Math.max(to, towards)
        } else {
          from = skipAtomic(target, from, false)
          to = skipAtomic(target, to, true)
        }
        return from == to
          ? { range }
          : {
              changes: { from, to },
              range: dist_EditorSelection.cursor(
                from,
                from < range.head ? -1 : 1
              )
            }
      })
      if (changes.changes.empty) return false
      target.dispatch(
        state.update(changes, {
          scrollIntoView: true,
          userEvent: event,
          effects:
            event == 'delete.selection'
              ? EditorView.announce.of(state.phrase('Selection deleted'))
              : undefined
        })
      )
      return true
    }
    function skipAtomic(target, pos, forward) {
      if (target instanceof EditorView)
        for (let ranges of target.state
          .facet(EditorView.atomicRanges)
          .map((f) => f(target)))
          ranges.between(pos, pos, (from, to) => {
            if (from < pos && to > pos) pos = forward ? to : from
          })
      return pos
    }
    const deleteByChar = (target, forward) =>
      deleteBy(target, (range) => {
        let pos = range.from,
          { state } = target,
          line = state.doc.lineAt(pos),
          before,
          targetPos
        if (
          !forward &&
          pos > line.from &&
          pos < line.from + 200 &&
          !/[^ \t]/.test((before = line.text.slice(0, pos - line.from)))
        ) {
          if (before[before.length - 1] == '\t') return pos - 1
          let col = countColumn(before, state.tabSize),
            drop = col % getIndentUnit(state) || getIndentUnit(state)
          for (let i = 0; i < drop && before[before.length - 1 - i] == ' '; i++)
            pos--
          targetPos = pos
        } else {
          targetPos =
            findClusterBreak(line.text, pos - line.from, forward, forward) +
            line.from
          if (
            targetPos == pos &&
            line.number != (forward ? state.doc.lines : 1)
          )
            targetPos += forward ? 1 : -1
          else if (
            !forward &&
            /[\ufe00-\ufe0f]/.test(
              line.text.slice(targetPos - line.from, pos - line.from)
            )
          )
            targetPos =
              findClusterBreak(line.text, targetPos - line.from, false, false) +
              line.from
        }
        return targetPos
      })
    /**
Delete the selection, or, for cursor selections, the character
before the cursor.
*/
    const deleteCharBackward = (view) => deleteByChar(view, false)
    /**
Delete the selection or the character after the cursor.
*/
    const deleteCharForward = (view) => deleteByChar(view, true)
    const deleteByGroup = (target, forward) =>
      deleteBy(target, (range) => {
        let pos = range.head,
          { state } = target,
          line = state.doc.lineAt(pos)
        let categorize = state.charCategorizer(pos)
        for (let cat = null; ; ) {
          if (pos == (forward ? line.to : line.from)) {
            if (
              pos == range.head &&
              line.number != (forward ? state.doc.lines : 1)
            )
              pos += forward ? 1 : -1
            break
          }
          let next =
            findClusterBreak(line.text, pos - line.from, forward) + line.from
          let nextChar = line.text.slice(
            Math.min(pos, next) - line.from,
            Math.max(pos, next) - line.from
          )
          let nextCat = categorize(nextChar)
          if (cat != null && nextCat != cat) break
          if (nextChar != ' ' || pos != range.head) cat = nextCat
          pos = next
        }
        return pos
      })
    /**
Delete the selection or backward until the end of the next
[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
whitespace when they consist of a single space.
*/
    const deleteGroupBackward = (target) => deleteByGroup(target, false)
    /**
Delete the selection or forward until the end of the next group.
*/
    const deleteGroupForward = (target) => deleteByGroup(target, true)
    /**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line. If the cursor is directly at the end of the
line, delete the line break after it.
*/
    const deleteToLineEnd = (view) =>
      deleteBy(view, (range) => {
        let lineEnd = view.lineBlockAt(range.head).to
        return range.head < lineEnd
          ? lineEnd
          : Math.min(view.state.doc.length, range.head + 1)
      })
    /**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line. If the cursor is directly at the start of the
line, delete the line break before it.
*/
    const deleteToLineStart = (view) =>
      deleteBy(view, (range) => {
        let lineStart = view.lineBlockAt(range.head).from
        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1)
      })
    /**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line or the next line wrap before the cursor.
*/
    const deleteLineBoundaryBackward = (view) =>
      deleteBy(view, (range) => {
        let lineStart = view.moveToLineBoundary(range, false).head
        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1)
      })
    /**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line or the next line wrap after the cursor.
*/
    const deleteLineBoundaryForward = (view) =>
      deleteBy(view, (range) => {
        let lineStart = view.moveToLineBoundary(range, true).head
        return range.head < lineStart
          ? lineStart
          : Math.min(view.state.doc.length, range.head + 1)
      })
    /**
Delete all whitespace directly before a line end from the
document.
*/
    const deleteTrailingWhitespace = ({ state, dispatch }) => {
      if (state.readOnly) return false
      let changes = []
      for (let pos = 0, prev = '', iter = state.doc.iter(); ; ) {
        iter.next()
        if (iter.lineBreak || iter.done) {
          let trailing = prev.search(/\s+$/)
          if (trailing > -1)
            changes.push({ from: pos - (prev.length - trailing), to: pos })
          if (iter.done) break
          prev = ''
        } else {
          prev = iter.value
        }
        pos += iter.value.length
      }
      if (!changes.length) return false
      dispatch(state.update({ changes, userEvent: 'delete' }))
      return true
    }
    /**
Replace each selection range with a line break, leaving the cursor
on the line before the break.
*/
    const splitLine = ({ state, dispatch }) => {
      if (state.readOnly) return false
      let changes = state.changeByRange((range) => {
        return {
          changes: {
            from: range.from,
            to: range.to,
            insert: Text.of(['', ''])
          },
          range: dist_EditorSelection.cursor(range.from)
        }
      })
      dispatch(
        state.update(changes, { scrollIntoView: true, userEvent: 'input' })
      )
      return true
    }
    /**
Flip the characters before and after the cursor(s).
*/
    const transposeChars = ({ state, dispatch }) => {
      if (state.readOnly) return false
      let changes = state.changeByRange((range) => {
        if (!range.empty || range.from == 0 || range.from == state.doc.length)
          return { range }
        let pos = range.from,
          line = state.doc.lineAt(pos)
        let from =
          pos == line.from
            ? pos - 1
            : findClusterBreak(line.text, pos - line.from, false) + line.from
        let to =
          pos == line.to
            ? pos + 1
            : findClusterBreak(line.text, pos - line.from, true) + line.from
        return {
          changes: {
            from,
            to,
            insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))
          },
          range: dist_EditorSelection.cursor(to)
        }
      })
      if (changes.changes.empty) return false
      dispatch(
        state.update(changes, {
          scrollIntoView: true,
          userEvent: 'move.character'
        })
      )
      return true
    }
    function selectedLineBlocks(state) {
      let blocks = [],
        upto = -1
      for (let range of state.selection.ranges) {
        let startLine = state.doc.lineAt(range.from),
          endLine = state.doc.lineAt(range.to)
        if (!range.empty && range.to == endLine.from)
          endLine = state.doc.lineAt(range.to - 1)
        if (upto >= startLine.number) {
          let prev = blocks[blocks.length - 1]
          prev.to = endLine.to
          prev.ranges.push(range)
        } else {
          blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] })
        }
        upto = endLine.number + 1
      }
      return blocks
    }
    function moveLine(state, dispatch, forward) {
      if (state.readOnly) return false
      let changes = [],
        ranges = []
      for (let block of selectedLineBlocks(state)) {
        if (forward ? block.to == state.doc.length : block.from == 0) continue
        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1)
        let size = nextLine.length + 1
        if (forward) {
          changes.push(
            { from: block.to, to: nextLine.to },
            { from: block.from, insert: nextLine.text + state.lineBreak }
          )
          for (let r of block.ranges)
            ranges.push(
              dist_EditorSelection.range(
                Math.min(state.doc.length, r.anchor + size),
                Math.min(state.doc.length, r.head + size)
              )
            )
        } else {
          changes.push(
            { from: nextLine.from, to: block.from },
            { from: block.to, insert: state.lineBreak + nextLine.text }
          )
          for (let r of block.ranges)
            ranges.push(
              dist_EditorSelection.range(r.anchor - size, r.head - size)
            )
        }
      }
      if (!changes.length) return false
      dispatch(
        state.update({
          changes,
          scrollIntoView: true,
          selection: dist_EditorSelection.create(
            ranges,
            state.selection.mainIndex
          ),
          userEvent: 'move.line'
        })
      )
      return true
    }
    /**
Move the selected lines up one line.
*/
    const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false)
    /**
Move the selected lines down one line.
*/
    const moveLineDown = ({ state, dispatch }) =>
      moveLine(state, dispatch, true)
    function copyLine(state, dispatch, forward) {
      if (state.readOnly) return false
      let changes = []
      for (let block of selectedLineBlocks(state)) {
        if (forward)
          changes.push({
            from: block.from,
            insert: state.doc.slice(block.from, block.to) + state.lineBreak
          })
        else
          changes.push({
            from: block.to,
            insert: state.lineBreak + state.doc.slice(block.from, block.to)
          })
      }
      dispatch(
        state.update({
          changes,
          scrollIntoView: true,
          userEvent: 'input.copyline'
        })
      )
      return true
    }
    /**
Create a copy of the selected lines. Keep the selection in the top copy.
*/
    const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false)
    /**
Create a copy of the selected lines. Keep the selection in the bottom copy.
*/
    const copyLineDown = ({ state, dispatch }) =>
      copyLine(state, dispatch, true)
    /**
Delete selected lines.
*/
    const deleteLine = (view) => {
      if (view.state.readOnly) return false
      let { state } = view,
        changes = state.changes(
          selectedLineBlocks(state).map(({ from, to }) => {
            if (from > 0) from--
            else if (to < state.doc.length) to++
            return { from, to }
          })
        )
      let selection = updateSel(state.selection, (range) =>
        view.moveVertically(range, true)
      ).map(changes)
      view.dispatch({
        changes,
        selection,
        scrollIntoView: true,
        userEvent: 'delete.line'
      })
      return true
    }
    /**
Replace the selection with a newline.
*/
    const insertNewline = ({ state, dispatch }) => {
      dispatch(
        state.update(state.replaceSelection(state.lineBreak), {
          scrollIntoView: true,
          userEvent: 'input'
        })
      )
      return true
    }
    function isBetweenBrackets(state, pos) {
      if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
        return { from: pos, to: pos }
      let context = dist_syntaxTree(state).resolveInner(pos)
      let before = context.childBefore(pos),
        after = context.childAfter(pos),
        closedBy
      if (
        before &&
        after &&
        before.to <= pos &&
        after.from >= pos &&
        (closedBy = before.type.prop(dist_NodeProp.closedBy)) &&
        closedBy.indexOf(after.name) > -1 &&
        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&
        !/\S/.test(state.sliceDoc(before.to, after.from))
      )
        return { from: before.to, to: after.from }
      return null
    }
    /**
Replace the selection with a newline and indent the newly created
line(s). If the current line consists only of whitespace, this
will also delete that whitespace. When the cursor is between
matching brackets, an additional newline will be inserted after
the cursor.
*/
    const insertNewlineAndIndent = /*@__PURE__*/ newlineAndIndent(false)
    /**
Create a blank, indented line below the current line.
*/
    const insertBlankLine = /*@__PURE__*/ newlineAndIndent(true)
    function newlineAndIndent(atEof) {
      return ({ state, dispatch }) => {
        if (state.readOnly) return false
        let changes = state.changeByRange((range) => {
          let { from, to } = range,
            line = state.doc.lineAt(from)
          let explode = !atEof && from == to && isBetweenBrackets(state, from)
          if (atEof)
            from = to = (to <= line.to ? line : state.doc.lineAt(to)).to
          let cx = new IndentContext(state, {
            simulateBreak: from,
            simulateDoubleBreak: !!explode
          })
          let indent = getIndentation(cx, from)
          if (indent == null)
            indent = countColumn(
              /^\s*/.exec(state.doc.lineAt(from).text)[0],
              state.tabSize
            )
          while (to < line.to && /\s/.test(line.text[to - line.from])) to++
          if (explode) ({ from, to } = explode)
          else if (
            from > line.from &&
            from < line.from + 100 &&
            !/\S/.test(line.text.slice(0, from))
          )
            from = line.from
          let insert = ['', indentString(state, indent)]
          if (explode)
            insert.push(indentString(state, cx.lineIndent(line.from, -1)))
          return {
            changes: { from, to, insert: Text.of(insert) },
            range: dist_EditorSelection.cursor(from + 1 + insert[1].length)
          }
        })
        dispatch(
          state.update(changes, { scrollIntoView: true, userEvent: 'input' })
        )
        return true
      }
    }
    function changeBySelectedLine(state, f) {
      let atLine = -1
      return state.changeByRange((range) => {
        let changes = []
        for (let pos = range.from; pos <= range.to; ) {
          let line = state.doc.lineAt(pos)
          if (line.number > atLine && (range.empty || range.to > line.from)) {
            f(line, changes, range)
            atLine = line.number
          }
          pos = line.to + 1
        }
        let changeSet = state.changes(changes)
        return {
          changes,
          range: dist_EditorSelection.range(
            changeSet.mapPos(range.anchor, 1),
            changeSet.mapPos(range.head, 1)
          )
        }
      })
    }
    /**
Auto-indent the selected lines. This uses the [indentation service
facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
information.
*/
    const indentSelection = ({ state, dispatch }) => {
      if (state.readOnly) return false
      let updated = Object.create(null)
      let context = new IndentContext(state, {
        overrideIndentation: (start) => {
          let found = updated[start]
          return found == null ? -1 : found
        }
      })
      let changes = changeBySelectedLine(state, (line, changes, range) => {
        let indent = getIndentation(context, line.from)
        if (indent == null) return
        if (!/\S/.test(line.text)) indent = 0
        let cur = /^\s*/.exec(line.text)[0]
        let norm = indentString(state, indent)
        if (cur != norm || range.from < line.from + cur.length) {
          updated[line.from] = indent
          changes.push({
            from: line.from,
            to: line.from + cur.length,
            insert: norm
          })
        }
      })
      if (!changes.changes.empty)
        dispatch(state.update(changes, { userEvent: 'indent' }))
      return true
    }
    /**
Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
lines.
*/
    const indentMore = ({ state, dispatch }) => {
      if (state.readOnly) return false
      dispatch(
        state.update(
          changeBySelectedLine(state, (line, changes) => {
            changes.push({ from: line.from, insert: state.facet(indentUnit) })
          }),
          { userEvent: 'input.indent' }
        )
      )
      return true
    }
    /**
Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
selected lines.
*/
    const indentLess = ({ state, dispatch }) => {
      if (state.readOnly) return false
      dispatch(
        state.update(
          changeBySelectedLine(state, (line, changes) => {
            let space = /^\s*/.exec(line.text)[0]
            if (!space) return
            let col = countColumn(space, state.tabSize),
              keep = 0
            let insert = indentString(
              state,
              Math.max(0, col - getIndentUnit(state))
            )
            while (
              keep < space.length &&
              keep < insert.length &&
              space.charCodeAt(keep) == insert.charCodeAt(keep)
            )
              keep++
            changes.push({
              from: line.from + keep,
              to: line.from + space.length,
              insert: insert.slice(keep)
            })
          }),
          { userEvent: 'delete.dedent' }
        )
      )
      return true
    }
    /**
Insert a tab character at the cursor or, if something is selected,
use [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire
selection.
*/
    const insertTab = ({ state, dispatch }) => {
      if (state.selection.ranges.some((r) => !r.empty))
        return indentMore({ state, dispatch })
      dispatch(
        state.update(state.replaceSelection('\t'), {
          scrollIntoView: true,
          userEvent: 'input'
        })
      )
      return true
    }
    /**
Array of key bindings containing the Emacs-style bindings that are
available on macOS by default.

 - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
 - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
 - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
 - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
 - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
*/
    const emacsStyleKeymap = [
      {
        key: 'Ctrl-b',
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: true
      },
      { key: 'Ctrl-f', run: cursorCharRight, shift: selectCharRight },
      { key: 'Ctrl-p', run: cursorLineUp, shift: selectLineUp },
      { key: 'Ctrl-n', run: cursorLineDown, shift: selectLineDown },
      { key: 'Ctrl-a', run: cursorLineStart, shift: selectLineStart },
      { key: 'Ctrl-e', run: cursorLineEnd, shift: selectLineEnd },
      { key: 'Ctrl-d', run: deleteCharForward },
      { key: 'Ctrl-h', run: deleteCharBackward },
      { key: 'Ctrl-k', run: deleteToLineEnd },
      { key: 'Ctrl-Alt-h', run: deleteGroupBackward },
      { key: 'Ctrl-o', run: splitLine },
      { key: 'Ctrl-t', run: transposeChars },
      { key: 'Ctrl-v', run: cursorPageDown }
    ]
    /**
An array of key bindings closely sticking to platform-standard or
widely used bindings. (This includes the bindings from
[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
property changed to `mac`.)

 - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
 - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
 - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
 - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
 - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
 - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
 - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
 - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).
 - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).
*/
    const standardKeymap = /*@__PURE__*/ [
      {
        key: 'ArrowLeft',
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: true
      },
      {
        key: 'Mod-ArrowLeft',
        mac: 'Alt-ArrowLeft',
        run: cursorGroupLeft,
        shift: selectGroupLeft,
        preventDefault: true
      },
      {
        mac: 'Cmd-ArrowLeft',
        run: cursorLineBoundaryLeft,
        shift: selectLineBoundaryLeft,
        preventDefault: true
      },
      {
        key: 'ArrowRight',
        run: cursorCharRight,
        shift: selectCharRight,
        preventDefault: true
      },
      {
        key: 'Mod-ArrowRight',
        mac: 'Alt-ArrowRight',
        run: cursorGroupRight,
        shift: selectGroupRight,
        preventDefault: true
      },
      {
        mac: 'Cmd-ArrowRight',
        run: cursorLineBoundaryRight,
        shift: selectLineBoundaryRight,
        preventDefault: true
      },
      {
        key: 'ArrowUp',
        run: cursorLineUp,
        shift: selectLineUp,
        preventDefault: true
      },
      { mac: 'Cmd-ArrowUp', run: cursorDocStart, shift: selectDocStart },
      { mac: 'Ctrl-ArrowUp', run: cursorPageUp, shift: selectPageUp },
      {
        key: 'ArrowDown',
        run: cursorLineDown,
        shift: selectLineDown,
        preventDefault: true
      },
      { mac: 'Cmd-ArrowDown', run: cursorDocEnd, shift: selectDocEnd },
      { mac: 'Ctrl-ArrowDown', run: cursorPageDown, shift: selectPageDown },
      { key: 'PageUp', run: cursorPageUp, shift: selectPageUp },
      { key: 'PageDown', run: cursorPageDown, shift: selectPageDown },
      {
        key: 'Home',
        run: cursorLineBoundaryBackward,
        shift: selectLineBoundaryBackward,
        preventDefault: true
      },
      { key: 'Mod-Home', run: cursorDocStart, shift: selectDocStart },
      {
        key: 'End',
        run: cursorLineBoundaryForward,
        shift: selectLineBoundaryForward,
        preventDefault: true
      },
      { key: 'Mod-End', run: cursorDocEnd, shift: selectDocEnd },
      { key: 'Enter', run: insertNewlineAndIndent },
      { key: 'Mod-a', run: selectAll },
      { key: 'Backspace', run: deleteCharBackward, shift: deleteCharBackward },
      { key: 'Delete', run: deleteCharForward },
      { key: 'Mod-Backspace', mac: 'Alt-Backspace', run: deleteGroupBackward },
      { key: 'Mod-Delete', mac: 'Alt-Delete', run: deleteGroupForward },
      { mac: 'Mod-Backspace', run: deleteLineBoundaryBackward },
      { mac: 'Mod-Delete', run: deleteLineBoundaryForward }
    ].concat(
      /*@__PURE__*/ emacsStyleKeymap.map((b) => ({
        mac: b.key,
        run: b.run,
        shift: b.shift
      }))
    )
    /**
The default keymap. Includes all bindings from
[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
- Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
- Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).
- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).
*/
    const dist_defaultKeymap = /*@__PURE__*/ [
      {
        key: 'Alt-ArrowLeft',
        mac: 'Ctrl-ArrowLeft',
        run: cursorSyntaxLeft,
        shift: selectSyntaxLeft
      },
      {
        key: 'Alt-ArrowRight',
        mac: 'Ctrl-ArrowRight',
        run: cursorSyntaxRight,
        shift: selectSyntaxRight
      },
      { key: 'Alt-ArrowUp', run: moveLineUp },
      { key: 'Shift-Alt-ArrowUp', run: copyLineUp },
      { key: 'Alt-ArrowDown', run: moveLineDown },
      { key: 'Shift-Alt-ArrowDown', run: copyLineDown },
      { key: 'Escape', run: simplifySelection },
      { key: 'Mod-Enter', run: insertBlankLine },
      { key: 'Alt-l', mac: 'Ctrl-l', run: selectLine },
      { key: 'Mod-i', run: selectParentSyntax, preventDefault: true },
      { key: 'Mod-[', run: indentLess },
      { key: 'Mod-]', run: indentMore },
      { key: 'Mod-Alt-\\', run: indentSelection },
      { key: 'Shift-Mod-k', run: deleteLine },
      { key: 'Shift-Mod-\\', run: cursorMatchingBracket },
      { key: 'Mod-/', run: toggleComment },
      { key: 'Alt-A', run: toggleBlockComment }
    ].concat(standardKeymap)
    /**
A binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and
Shift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).
Please see the [Tab example](../../examples/tab/) before using
this.
*/
    const indentWithTab = { key: 'Tab', run: indentMore, shift: indentLess } // CONCATENATED MODULE: ./node_modules/crelt/index.js

    function crelt() {
      var elt = arguments[0]
      if (typeof elt == 'string') elt = document.createElement(elt)
      var i = 1,
        next = arguments[1]
      if (
        next &&
        typeof next == 'object' &&
        next.nodeType == null &&
        !Array.isArray(next)
      ) {
        for (var name in next)
          if (Object.prototype.hasOwnProperty.call(next, name)) {
            var value = next[name]
            if (typeof value == 'string') elt.setAttribute(name, value)
            else if (value != null) elt[name] = value
          }
        i++
      }
      for (; i < arguments.length; i++) add(elt, arguments[i])
      return elt
    }

    function add(elt, child) {
      if (typeof child == 'string') {
        elt.appendChild(document.createTextNode(child))
      } else if (child == null) {
      } else if (child.nodeType != null) {
        elt.appendChild(child)
      } else if (Array.isArray(child)) {
        for (var i = 0; i < child.length; i++) add(elt, child[i])
      } else {
        throw new RangeError('Unsupported child node: ' + child)
      }
    } // CONCATENATED MODULE: ./node_modules/@codemirror/search/dist/index.js

    const basicNormalize =
      typeof String.prototype.normalize == 'function'
        ? (x) => x.normalize('NFKD')
        : (x) => x
    /**
A search cursor provides an iterator over text matches in a
document.
*/
    class SearchCursor {
      /**
    Create a text cursor. The query is the search string, `from` to
    `to` provides the region to search.
    
    When `normalize` is given, it will be called, on both the query
    string and the content it is matched against, before comparing.
    You can, for example, create a case-insensitive search by
    passing `s => s.toLowerCase()`.
    
    Text is always normalized with
    [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    (when supported).
    */
      constructor(text, query, from = 0, to = text.length, normalize, test) {
        this.test = test
        /**
        The current match (only holds a meaningful value after
        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
        `done` is false).
        */
        this.value = { from: 0, to: 0 }
        /**
        Whether the end of the iterated region has been reached.
        */
        this.done = false
        this.matches = []
        this.buffer = ''
        this.bufferPos = 0
        this.iter = text.iterRange(from, to)
        this.bufferStart = from
        this.normalize = normalize
          ? (x) => normalize(basicNormalize(x))
          : basicNormalize
        this.query = this.normalize(query)
      }
      peek() {
        if (this.bufferPos == this.buffer.length) {
          this.bufferStart += this.buffer.length
          this.iter.next()
          if (this.iter.done) return -1
          this.bufferPos = 0
          this.buffer = this.iter.value
        }
        return codePointAt(this.buffer, this.bufferPos)
      }
      /**
    Look for the next match. Updates the iterator's
    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
    at least once before using the cursor.
    */
      next() {
        while (this.matches.length) this.matches.pop()
        return this.nextOverlapping()
      }
      /**
    The `next` method will ignore matches that partially overlap a
    previous match. This method behaves like `next`, but includes
    such matches.
    */
      nextOverlapping() {
        for (;;) {
          let next = this.peek()
          if (next < 0) {
            this.done = true
            return this
          }
          let str = fromCodePoint(next),
            start = this.bufferStart + this.bufferPos
          this.bufferPos += codePointSize(next)
          let norm = this.normalize(str)
          for (let i = 0, pos = start; ; i++) {
            let code = norm.charCodeAt(i)
            let match = this.match(code, pos)
            if (i == norm.length - 1) {
              if (match) {
                this.value = match
                return this
              }
              break
            }
            if (pos == start && i < str.length && str.charCodeAt(i) == code)
              pos++
          }
        }
      }
      match(code, pos) {
        let match = null
        for (let i = 0; i < this.matches.length; i += 2) {
          let index = this.matches[i],
            keep = false
          if (this.query.charCodeAt(index) == code) {
            if (index == this.query.length - 1) {
              match = { from: this.matches[i + 1], to: pos + 1 }
            } else {
              this.matches[i]++
              keep = true
            }
          }
          if (!keep) {
            this.matches.splice(i, 2)
            i -= 2
          }
        }
        if (this.query.charCodeAt(0) == code) {
          if (this.query.length == 1) match = { from: pos, to: pos + 1 }
          else this.matches.push(1, pos)
        }
        if (
          match &&
          this.test &&
          !this.test(match.from, match.to, this.buffer, this.bufferStart)
        )
          match = null
        return match
      }
    }
    if (typeof Symbol != 'undefined')
      SearchCursor.prototype[Symbol.iterator] = function () {
        return this
      }

    const empty = { from: -1, to: -1, match: /*@__PURE__*/ /.*/.exec('') }
    const baseFlags = 'gm' + (/x/.unicode == null ? '' : 'u')
    /**
This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)
but searches for a regular expression pattern instead of a plain
string.
*/
    class RegExpCursor {
      /**
    Create a cursor that will search the given range in the given
    document. `query` should be the raw pattern (as you'd pass it to
    `new RegExp`).
    */
      constructor(text, query, options, from = 0, to = text.length) {
        this.text = text
        this.to = to
        this.curLine = ''
        /**
        Set to `true` when the cursor has reached the end of the search
        range.
        */
        this.done = false
        /**
        Will contain an object with the extent of the match and the
        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)
        sucessfully finds a match.
        */
        this.value = empty
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
          return new MultilineRegExpCursor(text, query, options, from, to)
        this.re = new RegExp(
          query,
          baseFlags +
            ((
              options === null || options === void 0
                ? void 0
                : options.ignoreCase
            )
              ? 'i'
              : '')
        )
        this.test =
          options === null || options === void 0 ? void 0 : options.test
        this.iter = text.iter()
        let startLine = text.lineAt(from)
        this.curLineStart = startLine.from
        this.matchPos = toCharEnd(text, from)
        this.getLine(this.curLineStart)
      }
      getLine(skip) {
        this.iter.next(skip)
        if (this.iter.lineBreak) {
          this.curLine = ''
        } else {
          this.curLine = this.iter.value
          if (this.curLineStart + this.curLine.length > this.to)
            this.curLine = this.curLine.slice(0, this.to - this.curLineStart)
          this.iter.next()
        }
      }
      nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1
        if (this.curLineStart > this.to) this.curLine = ''
        else this.getLine(0)
      }
      /**
    Move to the next match, if there is one.
    */
      next() {
        for (let off = this.matchPos - this.curLineStart; ; ) {
          this.re.lastIndex = off
          let match = this.matchPos <= this.to && this.re.exec(this.curLine)
          if (match) {
            let from = this.curLineStart + match.index,
              to = from + match[0].length
            this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0))
            if (from == this.curLineStart + this.curLine.length) this.nextLine()
            if (
              (from < to || from > this.value.to) &&
              (!this.test || this.test(from, to, match))
            ) {
              this.value = { from, to, match }
              return this
            }
            off = this.matchPos - this.curLineStart
          } else if (this.curLineStart + this.curLine.length < this.to) {
            this.nextLine()
            off = 0
          } else {
            this.done = true
            return this
          }
        }
      }
    }
    const flattened = /*@__PURE__*/ new WeakMap()
    // Reusable (partially) flattened document strings
    class FlattenedDoc {
      constructor(from, text) {
        this.from = from
        this.text = text
      }
      get to() {
        return this.from + this.text.length
      }
      static get(doc, from, to) {
        let cached = flattened.get(doc)
        if (!cached || cached.from >= to || cached.to <= from) {
          let flat = new FlattenedDoc(from, doc.sliceString(from, to))
          flattened.set(doc, flat)
          return flat
        }
        if (cached.from == from && cached.to == to) return cached
        let { text, from: cachedFrom } = cached
        if (cachedFrom > from) {
          text = doc.sliceString(from, cachedFrom) + text
          cachedFrom = from
        }
        if (cached.to < to) text += doc.sliceString(cached.to, to)
        flattened.set(doc, new FlattenedDoc(cachedFrom, text))
        return new FlattenedDoc(
          from,
          text.slice(from - cachedFrom, to - cachedFrom)
        )
      }
    }
    class MultilineRegExpCursor {
      constructor(text, query, options, from, to) {
        this.text = text
        this.to = to
        this.done = false
        this.value = empty
        this.matchPos = toCharEnd(text, from)
        this.re = new RegExp(
          query,
          baseFlags +
            ((
              options === null || options === void 0
                ? void 0
                : options.ignoreCase
            )
              ? 'i'
              : '')
        )
        this.test =
          options === null || options === void 0 ? void 0 : options.test
        this.flat = FlattenedDoc.get(
          text,
          from,
          this.chunkEnd(from + 5000 /* Chunk.Base */)
        )
      }
      chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to
      }
      next() {
        for (;;) {
          let off = (this.re.lastIndex = this.matchPos - this.flat.from)
          let match = this.re.exec(this.flat.text)
          // Skip empty matches directly after the last match
          if (match && !match[0] && match.index == off) {
            this.re.lastIndex = off + 1
            match = this.re.exec(this.flat.text)
          }
          if (match) {
            let from = this.flat.from + match.index,
              to = from + match[0].length
            // If a match goes almost to the end of a noncomplete chunk, try
            // again, since it'll likely be able to match more
            if (
              (this.flat.to >= this.to ||
                match.index + match[0].length <= this.flat.text.length - 10) &&
              (!this.test || this.test(from, to, match))
            ) {
              this.value = { from, to, match }
              this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0))
              return this
            }
          }
          if (this.flat.to == this.to) {
            this.done = true
            return this
          }
          // Grow the flattened doc
          this.flat = FlattenedDoc.get(
            this.text,
            this.flat.from,
            this.chunkEnd(this.flat.from + this.flat.text.length * 2)
          )
        }
      }
    }
    if (typeof Symbol != 'undefined') {
      RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[
        Symbol.iterator
      ] = function () {
        return this
      }
    }
    function validRegExp(source) {
      try {
        new RegExp(source, baseFlags)
        return true
      } catch (_a) {
        return false
      }
    }
    function toCharEnd(text, pos) {
      if (pos >= text.length) return pos
      let line = text.lineAt(pos),
        next
      while (
        pos < line.to &&
        (next = line.text.charCodeAt(pos - line.from)) >= 0xdc00 &&
        next < 0xe000
      )
        pos++
      return pos
    }

    function createLineDialog(view) {
      let line = String(
        view.state.doc.lineAt(view.state.selection.main.head).number
      )
      let input = crelt('input', {
        class: 'cm-textfield',
        name: 'line',
        value: line
      })
      let dom = crelt(
        'form',
        {
          class: 'cm-gotoLine',
          onkeydown: (event) => {
            if (event.keyCode == 27) {
              // Escape
              event.preventDefault()
              view.dispatch({ effects: dialogEffect.of(false) })
              view.focus()
            } else if (event.keyCode == 13) {
              // Enter
              event.preventDefault()
              go()
            }
          },
          onsubmit: (event) => {
            event.preventDefault()
            go()
          }
        },
        crelt('label', view.state.phrase('Go to line'), ': ', input),
        ' ',
        crelt(
          'button',
          { class: 'cm-button', type: 'submit' },
          view.state.phrase('go')
        )
      )
      function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value)
        if (!match) return
        let { state } = view,
          startLine = state.doc.lineAt(state.selection.main.head)
        let [, sign, ln, cl, percent] = match
        let col = cl ? +cl.slice(1) : 0
        let line = ln ? +ln : startLine.number
        if (ln && percent) {
          let pc = line / 100
          if (sign)
            pc =
              pc * (sign == '-' ? -1 : 1) + startLine.number / state.doc.lines
          line = Math.round(state.doc.lines * pc)
        } else if (ln && sign) {
          line = line * (sign == '-' ? -1 : 1) + startLine.number
        }
        let docLine = state.doc.line(
          Math.max(1, Math.min(state.doc.lines, line))
        )
        let selection = dist_EditorSelection.cursor(
          docLine.from + Math.max(0, Math.min(col, docLine.length))
        )
        view.dispatch({
          effects: [
            dialogEffect.of(false),
            EditorView.scrollIntoView(selection.from, { y: 'center' })
          ],
          selection
        })
        view.focus()
      }
      return { dom }
    }
    const dialogEffect = /*@__PURE__*/ StateEffect.define()
    const dialogField = /*@__PURE__*/ StateField.define({
      create() {
        return true
      },
      update(value, tr) {
        for (let e of tr.effects) if (e.is(dialogEffect)) value = e.value
        return value
      },
      provide: (f) =>
        showPanel.from(f, (val) => (val ? createLineDialog : null))
    })
    /**
Command that shows a dialog asking the user for a line number, and
when a valid position is provided, moves the cursor to that line.

Supports line numbers, relative line offsets prefixed with `+` or
`-`, document percentages suffixed with `%`, and an optional
column position by adding `:` and a second number after the line
number.
*/
    const gotoLine = (view) => {
      let panel = getPanel(view, createLineDialog)
      if (!panel) {
        let effects = [dialogEffect.of(true)]
        if (view.state.field(dialogField, false) == null)
          effects.push(
            StateEffect.appendConfig.of([dialogField, search_dist_baseTheme$1])
          )
        view.dispatch({ effects })
        panel = getPanel(view, createLineDialog)
      }
      if (panel) panel.dom.querySelector('input').select()
      return true
    }
    const search_dist_baseTheme$1 = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-panel.cm-gotoLine': {
        padding: '2px 6px 4px',
        '& label': { fontSize: '80%' }
      }
    })

    const defaultHighlightOptions = {
      highlightWordAroundCursor: false,
      minSelectionLength: 1,
      maxMatches: 100,
      wholeWords: false
    }
    const highlightConfig = /*@__PURE__*/ Facet.define({
      combine(options) {
        return combineConfig(options, defaultHighlightOptions, {
          highlightWordAroundCursor: (a, b) => a || b,
          minSelectionLength: Math.min,
          maxMatches: Math.min
        })
      }
    })
    /**
This extension highlights text that matches the selection. It uses
the `"cm-selectionMatch"` class for the highlighting. When
`highlightWordAroundCursor` is enabled, the word at the cursor
itself will be highlighted with `"cm-selectionMatch-main"`.
*/
    function highlightSelectionMatches(options) {
      let ext = [defaultTheme, matchHighlighter]
      if (options) ext.push(highlightConfig.of(options))
      return ext
    }
    const matchDeco = /*@__PURE__*/ Decoration.mark({
      class: 'cm-selectionMatch'
    })
    const mainMatchDeco = /*@__PURE__*/ Decoration.mark({
      class: 'cm-selectionMatch cm-selectionMatch-main'
    })
    // Whether the characters directly outside the given positions are non-word characters
    function insideWordBoundaries(check, state, from, to) {
      return (
        (from == 0 ||
          check(state.sliceDoc(from - 1, from)) != dist_CharCategory.Word) &&
        (to == state.doc.length ||
          check(state.sliceDoc(to, to + 1)) != dist_CharCategory.Word)
      )
    }
    // Whether the characters directly at the given positions are word characters
    function insideWord(check, state, from, to) {
      return (
        check(state.sliceDoc(from, from + 1)) == dist_CharCategory.Word &&
        check(state.sliceDoc(to - 1, to)) == dist_CharCategory.Word
      )
    }
    const matchHighlighter = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.decorations = this.getDeco(view)
        }
        update(update) {
          if (
            update.selectionSet ||
            update.docChanged ||
            update.viewportChanged
          )
            this.decorations = this.getDeco(update.view)
        }
        getDeco(view) {
          let conf = view.state.facet(highlightConfig)
          let { state } = view,
            sel = state.selection
          if (sel.ranges.length > 1) return Decoration.none
          let range = sel.main,
            query,
            check = null
          if (range.empty) {
            if (!conf.highlightWordAroundCursor) return Decoration.none
            let word = state.wordAt(range.head)
            if (!word) return Decoration.none
            check = state.charCategorizer(range.head)
            query = state.sliceDoc(word.from, word.to)
          } else {
            let len = range.to - range.from
            if (len < conf.minSelectionLength || len > 200)
              return Decoration.none
            if (conf.wholeWords) {
              query = state.sliceDoc(range.from, range.to) // TODO: allow and include leading/trailing space?
              check = state.charCategorizer(range.head)
              if (
                !(
                  insideWordBoundaries(check, state, range.from, range.to) &&
                  insideWord(check, state, range.from, range.to)
                )
              )
                return Decoration.none
            } else {
              query = state.sliceDoc(range.from, range.to).trim()
              if (!query) return Decoration.none
            }
          }
          let deco = []
          for (let part of view.visibleRanges) {
            let cursor = new SearchCursor(state.doc, query, part.from, part.to)
            while (!cursor.next().done) {
              let { from, to } = cursor.value
              if (!check || insideWordBoundaries(check, state, from, to)) {
                if (range.empty && from <= range.from && to >= range.to)
                  deco.push(mainMatchDeco.range(from, to))
                else if (from >= range.to || to <= range.from)
                  deco.push(matchDeco.range(from, to))
                if (deco.length > conf.maxMatches) return Decoration.none
              }
            }
          }
          return Decoration.set(deco)
        }
      },
      {
        decorations: (v) => v.decorations
      }
    )
    const defaultTheme = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-selectionMatch': { backgroundColor: '#99ff7780' },
      '.cm-searchMatch .cm-selectionMatch': { backgroundColor: 'transparent' }
    })
    // Select the words around the cursors.
    const selectWord = ({ state, dispatch }) => {
      let { selection } = state
      let newSel = dist_EditorSelection.create(
        selection.ranges.map(
          (range) =>
            state.wordAt(range.head) || dist_EditorSelection.cursor(range.head)
        ),
        selection.mainIndex
      )
      if (newSel.eq(selection)) return false
      dispatch(state.update({ selection: newSel }))
      return true
    }
    // Find next occurrence of query relative to last cursor. Wrap around
    // the document if there are no more matches.
    function findNextOccurrence(state, query) {
      let { main, ranges } = state.selection
      let word = state.wordAt(main.head),
        fullWord = word && word.from == main.from && word.to == main.to
      for (
        let cycled = false,
          cursor = new SearchCursor(
            state.doc,
            query,
            ranges[ranges.length - 1].to
          );
        ;

      ) {
        cursor.next()
        if (cursor.done) {
          if (cycled) return null
          cursor = new SearchCursor(
            state.doc,
            query,
            0,
            Math.max(0, ranges[ranges.length - 1].from - 1)
          )
          cycled = true
        } else {
          if (cycled && ranges.some((r) => r.from == cursor.value.from))
            continue
          if (fullWord) {
            let word = state.wordAt(cursor.value.from)
            if (
              !word ||
              word.from != cursor.value.from ||
              word.to != cursor.value.to
            )
              continue
          }
          return cursor.value
        }
      }
    }
    /**
Select next occurrence of the current selection. Expand selection
to the surrounding word when the selection is empty.
*/
    const selectNextOccurrence = ({ state, dispatch }) => {
      let { ranges } = state.selection
      if (ranges.some((sel) => sel.from === sel.to))
        return selectWord({ state, dispatch })
      let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to)
      if (
        state.selection.ranges.some(
          (r) => state.sliceDoc(r.from, r.to) != searchedText
        )
      )
        return false
      let range = findNextOccurrence(state, searchedText)
      if (!range) return false
      dispatch(
        state.update({
          selection: state.selection.addRange(
            dist_EditorSelection.range(range.from, range.to),
            false
          ),
          effects: EditorView.scrollIntoView(range.to)
        })
      )
      return true
    }

    const searchConfigFacet = /*@__PURE__*/ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          top: false,
          caseSensitive: false,
          literal: false,
          regexp: false,
          wholeWord: false,
          createPanel: (view) => new SearchPanel(view),
          scrollToMatch: (range) => EditorView.scrollIntoView(range)
        })
      }
    })
    /**
Add search state to the editor configuration, and optionally
configure the search extension.
([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically
enable this if it isn't already on).
*/
    function search(config) {
      return config
        ? [searchConfigFacet.of(config), searchExtensions]
        : searchExtensions
    }
    /**
A search query. Part of the editor's search state.
*/
    class SearchQuery {
      /**
    Create a query object.
    */
      constructor(config) {
        this.search = config.search
        this.caseSensitive = !!config.caseSensitive
        this.literal = !!config.literal
        this.regexp = !!config.regexp
        this.replace = config.replace || ''
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search))
        this.unquoted = this.unquote(this.search)
        this.wholeWord = !!config.wholeWord
      }
      /**
    @internal
    */
      unquote(text) {
        return this.literal
          ? text
          : text.replace(/\\([nrt\\])/g, (_, ch) =>
              ch == 'n' ? '\n' : ch == 'r' ? '\r' : ch == 't' ? '\t' : '\\'
            )
      }
      /**
    Compare this query to another query.
    */
      eq(other) {
        return (
          this.search == other.search &&
          this.replace == other.replace &&
          this.caseSensitive == other.caseSensitive &&
          this.regexp == other.regexp &&
          this.wholeWord == other.wholeWord
        )
      }
      /**
    @internal
    */
      create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this)
      }
      /**
    Get a search cursor for this query, searching through the given
    range in the given state.
    */
      getCursor(state, from = 0, to) {
        let st = state.doc ? state : EditorState.create({ doc: state })
        if (to == null) to = st.doc.length
        return this.regexp
          ? regexpCursor(this, st, from, to)
          : stringCursor(this, st, from, to)
      }
    }
    class dist_QueryType {
      constructor(spec) {
        this.spec = spec
      }
    }
    function stringCursor(spec, state, from, to) {
      return new SearchCursor(
        state.doc,
        spec.unquoted,
        from,
        to,
        spec.caseSensitive ? undefined : (x) => x.toLowerCase(),
        spec.wholeWord
          ? stringWordTest(
              state.doc,
              state.charCategorizer(state.selection.main.head)
            )
          : undefined
      )
    }
    function stringWordTest(doc, categorizer) {
      return (from, to, buf, bufPos) => {
        if (bufPos > from || bufPos + buf.length < to) {
          bufPos = Math.max(0, from - 2)
          buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2))
        }
        return (
          (categorizer(charBefore(buf, from - bufPos)) !=
            dist_CharCategory.Word ||
            categorizer(charAfter(buf, from - bufPos)) !=
              dist_CharCategory.Word) &&
          (categorizer(charAfter(buf, to - bufPos)) != dist_CharCategory.Word ||
            categorizer(charBefore(buf, to - bufPos)) != dist_CharCategory.Word)
        )
      }
    }
    class StringQuery extends dist_QueryType {
      constructor(spec) {
        super(spec)
      }
      nextMatch(state, curFrom, curTo) {
        let cursor = stringCursor(
          this.spec,
          state,
          curTo,
          state.doc.length
        ).nextOverlapping()
        if (cursor.done)
          cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping()
        return cursor.done ? null : cursor.value
      }
      // Searching in reverse is, rather than implementing an inverted search
      // cursor, done by scanning chunk after chunk forward.
      prevMatchInRange(state, from, to) {
        for (let pos = to; ; ) {
          let start = Math.max(
            from,
            pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length
          )
          let cursor = stringCursor(this.spec, state, start, pos),
            range = null
          while (!cursor.nextOverlapping().done) range = cursor.value
          if (range) return range
          if (start == from) return null
          pos -= 10000 /* FindPrev.ChunkSize */
        }
      }
      prevMatch(state, curFrom, curTo) {
        return (
          this.prevMatchInRange(state, 0, curFrom) ||
          this.prevMatchInRange(state, curTo, state.doc.length)
        )
      }
      getReplacement(_result) {
        return this.spec.unquote(this.spec.replace)
      }
      matchAll(state, limit) {
        let cursor = stringCursor(this.spec, state, 0, state.doc.length),
          ranges = []
        while (!cursor.next().done) {
          if (ranges.length >= limit) return null
          ranges.push(cursor.value)
        }
        return ranges
      }
      highlight(state, from, to, add) {
        let cursor = stringCursor(
          this.spec,
          state,
          Math.max(0, from - this.spec.unquoted.length),
          Math.min(to + this.spec.unquoted.length, state.doc.length)
        )
        while (!cursor.next().done) add(cursor.value.from, cursor.value.to)
      }
    }
    function regexpCursor(spec, state, from, to) {
      return new RegExpCursor(
        state.doc,
        spec.search,
        {
          ignoreCase: !spec.caseSensitive,
          test: spec.wholeWord
            ? regexpWordTest(state.charCategorizer(state.selection.main.head))
            : undefined
        },
        from,
        to
      )
    }
    function charBefore(str, index) {
      return str.slice(findClusterBreak(str, index, false), index)
    }
    function charAfter(str, index) {
      return str.slice(index, findClusterBreak(str, index))
    }
    function regexpWordTest(categorizer) {
      return (_from, _to, match) =>
        !match[0].length ||
        ((categorizer(charBefore(match.input, match.index)) !=
          dist_CharCategory.Word ||
          categorizer(charAfter(match.input, match.index)) !=
            dist_CharCategory.Word) &&
          (categorizer(charAfter(match.input, match.index + match[0].length)) !=
            dist_CharCategory.Word ||
            categorizer(
              charBefore(match.input, match.index + match[0].length)
            ) != dist_CharCategory.Word))
    }
    class RegExpQuery extends dist_QueryType {
      nextMatch(state, curFrom, curTo) {
        let cursor = regexpCursor(
          this.spec,
          state,
          curTo,
          state.doc.length
        ).next()
        if (cursor.done)
          cursor = regexpCursor(this.spec, state, 0, curFrom).next()
        return cursor.done ? null : cursor.value
      }
      prevMatchInRange(state, from, to) {
        for (let size = 1; ; size++) {
          let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */)
          let cursor = regexpCursor(this.spec, state, start, to),
            range = null
          while (!cursor.next().done) range = cursor.value
          if (range && (start == from || range.from > start + 10)) return range
          if (start == from) return null
        }
      }
      prevMatch(state, curFrom, curTo) {
        return (
          this.prevMatchInRange(state, 0, curFrom) ||
          this.prevMatchInRange(state, curTo, state.doc.length)
        )
      }
      getReplacement(result) {
        return this.spec
          .unquote(this.spec.replace)
          .replace(/\$([$&\d+])/g, (m, i) =>
            i == '$'
              ? '$'
              : i == '&'
                ? result.match[0]
                : i != '0' && +i < result.match.length
                  ? result.match[i]
                  : m
          )
      }
      matchAll(state, limit) {
        let cursor = regexpCursor(this.spec, state, 0, state.doc.length),
          ranges = []
        while (!cursor.next().done) {
          if (ranges.length >= limit) return null
          ranges.push(cursor.value)
        }
        return ranges
      }
      highlight(state, from, to, add) {
        let cursor = regexpCursor(
          this.spec,
          state,
          Math.max(0, from - 250 /* RegExp.HighlightMargin */),
          Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length)
        )
        while (!cursor.next().done) add(cursor.value.from, cursor.value.to)
      }
    }
    /**
A state effect that updates the current search query. Note that
this only has an effect if the search state has been initialized
(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or
by running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least
once).
*/
    const setSearchQuery = /*@__PURE__*/ StateEffect.define()
    const togglePanel = /*@__PURE__*/ StateEffect.define()
    const searchState = /*@__PURE__*/ StateField.define({
      create(state) {
        return new SearchState(defaultQuery(state).create(), null)
      },
      update(value, tr) {
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery))
            value = new SearchState(effect.value.create(), value.panel)
          else if (effect.is(togglePanel))
            value = new SearchState(
              value.query,
              effect.value ? createSearchPanel : null
            )
        }
        return value
      },
      provide: (f) => showPanel.from(f, (val) => val.panel)
    })
    /**
Get the current search query from an editor state.
*/
    function getSearchQuery(state) {
      let curState = state.field(searchState, false)
      return curState ? curState.query.spec : defaultQuery(state)
    }
    /**
Query whether the search panel is open in the given editor state.
*/
    function searchPanelOpen(state) {
      var _a
      return (
        ((_a = state.field(searchState, false)) === null || _a === void 0
          ? void 0
          : _a.panel) != null
      )
    }
    class SearchState {
      constructor(query, panel) {
        this.query = query
        this.panel = panel
      }
    }
    const matchMark = /*@__PURE__*/ Decoration.mark({
        class: 'cm-searchMatch'
      }),
      selectedMatchMark = /*@__PURE__*/ Decoration.mark({
        class: 'cm-searchMatch cm-searchMatch-selected'
      })
    const searchHighlighter = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.view = view
          this.decorations = this.highlight(view.state.field(searchState))
        }
        update(update) {
          let state = update.state.field(searchState)
          if (
            state != update.startState.field(searchState) ||
            update.docChanged ||
            update.selectionSet ||
            update.viewportChanged
          )
            this.decorations = this.highlight(state)
        }
        highlight({ query, panel }) {
          if (!panel || !query.spec.valid) return Decoration.none
          let { view } = this
          let builder = new RangeSetBuilder()
          for (
            let i = 0, ranges = view.visibleRanges, l = ranges.length;
            i < l;
            i++
          ) {
            let { from, to } = ranges[i]
            while (
              i < l - 1 &&
              to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */
            )
              to = ranges[++i].to
            query.highlight(view.state, from, to, (from, to) => {
              let selected = view.state.selection.ranges.some(
                (r) => r.from == from && r.to == to
              )
              builder.add(from, to, selected ? selectedMatchMark : matchMark)
            })
          }
          return builder.finish()
        }
      },
      {
        decorations: (v) => v.decorations
      }
    )
    function searchCommand(f) {
      return (view) => {
        let state = view.state.field(searchState, false)
        return state && state.query.spec.valid
          ? f(view, state)
          : openSearchPanel(view)
      }
    }
    /**
Open the search panel if it isn't already open, and move the
selection to the first match after the current main selection.
Will wrap around to the start of the document when it reaches the
end.
*/
    const findNext = /*@__PURE__*/ searchCommand((view, { query }) => {
      let { to } = view.state.selection.main
      let next = query.nextMatch(view.state, to, to)
      if (!next) return false
      let selection = dist_EditorSelection.single(next.from, next.to)
      let config = view.state.facet(searchConfigFacet)
      view.dispatch({
        selection,
        effects: [
          announceMatch(view, next),
          config.scrollToMatch(selection.main, view)
        ],
        userEvent: 'select.search'
      })
      selectSearchInput(view)
      return true
    })
    /**
Move the selection to the previous instance of the search query,
before the current main selection. Will wrap past the start
of the document to start searching at the end again.
*/
    const findPrevious = /*@__PURE__*/ searchCommand((view, { query }) => {
      let { state } = view,
        { from } = state.selection.main
      let prev = query.prevMatch(state, from, from)
      if (!prev) return false
      let selection = dist_EditorSelection.single(prev.from, prev.to)
      let config = view.state.facet(searchConfigFacet)
      view.dispatch({
        selection,
        effects: [
          announceMatch(view, prev),
          config.scrollToMatch(selection.main, view)
        ],
        userEvent: 'select.search'
      })
      selectSearchInput(view)
      return true
    })
    /**
Select all instances of the search query.
*/
    const selectMatches = /*@__PURE__*/ searchCommand((view, { query }) => {
      let ranges = query.matchAll(view.state, 1000)
      if (!ranges || !ranges.length) return false
      view.dispatch({
        selection: dist_EditorSelection.create(
          ranges.map((r) => dist_EditorSelection.range(r.from, r.to))
        ),
        userEvent: 'select.search.matches'
      })
      return true
    })
    /**
Select all instances of the currently selected text.
*/
    const selectSelectionMatches = ({ state, dispatch }) => {
      let sel = state.selection
      if (sel.ranges.length > 1 || sel.main.empty) return false
      let { from, to } = sel.main
      let ranges = [],
        main = 0
      for (
        let cur = new SearchCursor(state.doc, state.sliceDoc(from, to));
        !cur.next().done;

      ) {
        if (ranges.length > 1000) return false
        if (cur.value.from == from) main = ranges.length
        ranges.push(dist_EditorSelection.range(cur.value.from, cur.value.to))
      }
      dispatch(
        state.update({
          selection: dist_EditorSelection.create(ranges, main),
          userEvent: 'select.search.matches'
        })
      )
      return true
    }
    /**
Replace the current match of the search query.
*/
    const replaceNext = /*@__PURE__*/ searchCommand((view, { query }) => {
      let { state } = view,
        { from, to } = state.selection.main
      if (state.readOnly) return false
      let next = query.nextMatch(state, from, from)
      if (!next) return false
      let changes = [],
        selection,
        replacement
      let effects = []
      if (next.from == from && next.to == to) {
        replacement = state.toText(query.getReplacement(next))
        changes.push({ from: next.from, to: next.to, insert: replacement })
        next = query.nextMatch(state, next.from, next.to)
        effects.push(
          EditorView.announce.of(
            state.phrase(
              'replaced match on line $',
              state.doc.lineAt(from).number
            ) + '.'
          )
        )
      }
      if (next) {
        let off =
          changes.length == 0 || changes[0].from >= next.to
            ? 0
            : next.to - next.from - replacement.length
        selection = dist_EditorSelection.single(next.from - off, next.to - off)
        effects.push(announceMatch(view, next))
        effects.push(
          state.facet(searchConfigFacet).scrollToMatch(selection.main, view)
        )
      }
      view.dispatch({
        changes,
        selection,
        effects,
        userEvent: 'input.replace'
      })
      return true
    })
    /**
Replace all instances of the search query with the given
replacement.
*/
    const replaceAll = /*@__PURE__*/ searchCommand((view, { query }) => {
      if (view.state.readOnly) return false
      let changes = query.matchAll(view.state, 1e9).map((match) => {
        let { from, to } = match
        return { from, to, insert: query.getReplacement(match) }
      })
      if (!changes.length) return false
      let announceText =
        view.state.phrase('replaced $ matches', changes.length) + '.'
      view.dispatch({
        changes,
        effects: EditorView.announce.of(announceText),
        userEvent: 'input.replace.all'
      })
      return true
    })
    function createSearchPanel(view) {
      return view.state.facet(searchConfigFacet).createPanel(view)
    }
    function defaultQuery(state, fallback) {
      var _a, _b, _c, _d, _e
      let sel = state.selection.main
      let selText =
        sel.empty || sel.to > sel.from + 100
          ? ''
          : state.sliceDoc(sel.from, sel.to)
      if (fallback && !selText) return fallback
      let config = state.facet(searchConfigFacet)
      return new SearchQuery({
        search: (
          (_a =
            fallback === null || fallback === void 0
              ? void 0
              : fallback.literal) !== null && _a !== void 0
            ? _a
            : config.literal
        )
          ? selText
          : selText.replace(/\n/g, '\\n'),
        caseSensitive:
          (_b =
            fallback === null || fallback === void 0
              ? void 0
              : fallback.caseSensitive) !== null && _b !== void 0
            ? _b
            : config.caseSensitive,
        literal:
          (_c =
            fallback === null || fallback === void 0
              ? void 0
              : fallback.literal) !== null && _c !== void 0
            ? _c
            : config.literal,
        regexp:
          (_d =
            fallback === null || fallback === void 0
              ? void 0
              : fallback.regexp) !== null && _d !== void 0
            ? _d
            : config.regexp,
        wholeWord:
          (_e =
            fallback === null || fallback === void 0
              ? void 0
              : fallback.wholeWord) !== null && _e !== void 0
            ? _e
            : config.wholeWord
      })
    }
    function getSearchInput(view) {
      let panel = getPanel(view, createSearchPanel)
      return panel && panel.dom.querySelector('[main-field]')
    }
    function selectSearchInput(view) {
      let input = getSearchInput(view)
      if (input && input == view.root.activeElement) input.select()
    }
    /**
Make sure the search panel is open and focused.
*/
    const openSearchPanel = (view) => {
      let state = view.state.field(searchState, false)
      if (state && state.panel) {
        let searchInput = getSearchInput(view)
        if (searchInput && searchInput != view.root.activeElement) {
          let query = defaultQuery(view.state, state.query.spec)
          if (query.valid) view.dispatch({ effects: setSearchQuery.of(query) })
          searchInput.focus()
          searchInput.select()
        }
      } else {
        view.dispatch({
          effects: [
            togglePanel.of(true),
            state
              ? setSearchQuery.of(defaultQuery(view.state, state.query.spec))
              : StateEffect.appendConfig.of(searchExtensions)
          ]
        })
      }
      return true
    }
    /**
Close the search panel.
*/
    const closeSearchPanel = (view) => {
      let state = view.state.field(searchState, false)
      if (!state || !state.panel) return false
      let panel = getPanel(view, createSearchPanel)
      if (panel && panel.dom.contains(view.root.activeElement)) view.focus()
      view.dispatch({ effects: togglePanel.of(false) })
      return true
    }
    /**
Default search-related key bindings.

 - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
 - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
 - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
 - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
 - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)
*/
    const searchKeymap = [
      { key: 'Mod-f', run: openSearchPanel, scope: 'editor search-panel' },
      {
        key: 'F3',
        run: findNext,
        shift: findPrevious,
        scope: 'editor search-panel',
        preventDefault: true
      },
      {
        key: 'Mod-g',
        run: findNext,
        shift: findPrevious,
        scope: 'editor search-panel',
        preventDefault: true
      },
      { key: 'Escape', run: closeSearchPanel, scope: 'editor search-panel' },
      { key: 'Mod-Shift-l', run: selectSelectionMatches },
      { key: 'Mod-Alt-g', run: gotoLine },
      { key: 'Mod-d', run: selectNextOccurrence, preventDefault: true }
    ]
    class SearchPanel {
      constructor(view) {
        this.view = view
        let query = (this.query = view.state.field(searchState).query.spec)
        this.commit = this.commit.bind(this)
        this.searchField = crelt('input', {
          value: query.search,
          placeholder: phrase(view, 'Find'),
          'aria-label': phrase(view, 'Find'),
          class: 'cm-textfield',
          name: 'search',
          form: '',
          'main-field': 'true',
          onchange: this.commit,
          onkeyup: this.commit
        })
        this.replaceField = crelt('input', {
          value: query.replace,
          placeholder: phrase(view, 'Replace'),
          'aria-label': phrase(view, 'Replace'),
          class: 'cm-textfield',
          name: 'replace',
          form: '',
          onchange: this.commit,
          onkeyup: this.commit
        })
        this.caseField = crelt('input', {
          type: 'checkbox',
          name: 'case',
          form: '',
          checked: query.caseSensitive,
          onchange: this.commit
        })
        this.reField = crelt('input', {
          type: 'checkbox',
          name: 're',
          form: '',
          checked: query.regexp,
          onchange: this.commit
        })
        this.wordField = crelt('input', {
          type: 'checkbox',
          name: 'word',
          form: '',
          checked: query.wholeWord,
          onchange: this.commit
        })
        function button(name, onclick, content) {
          return crelt(
            'button',
            { class: 'cm-button', name, onclick, type: 'button' },
            content
          )
        }
        this.dom = crelt(
          'div',
          { onkeydown: (e) => this.keydown(e), class: 'cm-search' },
          [
            this.searchField,
            button('next', () => findNext(view), [phrase(view, 'next')]),
            button('prev', () => findPrevious(view), [
              phrase(view, 'previous')
            ]),
            button('select', () => selectMatches(view), [phrase(view, 'all')]),
            crelt('label', null, [this.caseField, phrase(view, 'match case')]),
            crelt('label', null, [this.reField, phrase(view, 'regexp')]),
            crelt('label', null, [this.wordField, phrase(view, 'by word')]),
            ...(view.state.readOnly
              ? []
              : [
                  crelt('br'),
                  this.replaceField,
                  button('replace', () => replaceNext(view), [
                    phrase(view, 'replace')
                  ]),
                  button('replaceAll', () => replaceAll(view), [
                    phrase(view, 'replace all')
                  ])
                ]),
            crelt(
              'button',
              {
                name: 'close',
                onclick: () => closeSearchPanel(view),
                'aria-label': phrase(view, 'close'),
                type: 'button'
              },
              ['×']
            )
          ]
        )
      }
      commit() {
        let query = new SearchQuery({
          search: this.searchField.value,
          caseSensitive: this.caseField.checked,
          regexp: this.reField.checked,
          wholeWord: this.wordField.checked,
          replace: this.replaceField.value
        })
        if (!query.eq(this.query)) {
          this.query = query
          this.view.dispatch({ effects: setSearchQuery.of(query) })
        }
      }
      keydown(e) {
        if (runScopeHandlers(this.view, e, 'search-panel')) {
          e.preventDefault()
        } else if (e.keyCode == 13 && e.target == this.searchField) {
          e.preventDefault()
          ;(e.shiftKey ? findPrevious : findNext)(this.view)
        } else if (e.keyCode == 13 && e.target == this.replaceField) {
          e.preventDefault()
          replaceNext(this.view)
        }
      }
      update(update) {
        for (let tr of update.transactions)
          for (let effect of tr.effects) {
            if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
              this.setQuery(effect.value)
          }
      }
      setQuery(query) {
        this.query = query
        this.searchField.value = query.search
        this.replaceField.value = query.replace
        this.caseField.checked = query.caseSensitive
        this.reField.checked = query.regexp
        this.wordField.checked = query.wholeWord
      }
      mount() {
        this.searchField.select()
      }
      get pos() {
        return 80
      }
      get top() {
        return this.view.state.facet(searchConfigFacet).top
      }
    }
    function phrase(view, phrase) {
      return view.state.phrase(phrase)
    }
    const AnnounceMargin = 30
    const Break = /[\s\.,:;?!]/
    function announceMatch(view, { from, to }) {
      let line = view.state.doc.lineAt(from),
        lineEnd = view.state.doc.lineAt(to).to
      let start = Math.max(line.from, from - AnnounceMargin),
        end = Math.min(lineEnd, to + AnnounceMargin)
      let text = view.state.sliceDoc(start, end)
      if (start != line.from) {
        for (let i = 0; i < AnnounceMargin; i++)
          if (!Break.test(text[i + 1]) && Break.test(text[i])) {
            text = text.slice(i)
            break
          }
      }
      if (end != lineEnd) {
        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
          if (!Break.test(text[i - 1]) && Break.test(text[i])) {
            text = text.slice(0, i)
            break
          }
      }
      return EditorView.announce.of(
        `${view.state.phrase('current match')}. ${text} ${view.state.phrase(
          'on line'
        )} ${line.number}.`
      )
    }
    const search_dist_baseTheme = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-panel.cm-search': {
        padding: '2px 6px 4px',
        position: 'relative',
        '& [name=close]': {
          position: 'absolute',
          top: '0',
          right: '4px',
          backgroundColor: 'inherit',
          border: 'none',
          font: 'inherit',
          padding: 0,
          margin: 0
        },
        '& input, & button, & label': {
          margin: '.2em .6em .2em 0'
        },
        '& input[type=checkbox]': {
          marginRight: '.2em'
        },
        '& label': {
          fontSize: '80%',
          whiteSpace: 'pre'
        }
      },
      '&light .cm-searchMatch': { backgroundColor: '#ffff0054' },
      '&dark .cm-searchMatch': { backgroundColor: '#00ffff8a' },
      '&light .cm-searchMatch-selected': { backgroundColor: '#ff6a0054' },
      '&dark .cm-searchMatch-selected': { backgroundColor: '#ff00ff8a' }
    })
    const searchExtensions = [
      searchState,
      /*@__PURE__*/ Prec.low(searchHighlighter),
      search_dist_baseTheme
    ] // CONCATENATED MODULE: ./node_modules/@codemirror/autocomplete/dist/index.js

    /**
An instance of this is passed to completion source functions.
*/
    class CompletionContext {
      /**
    Create a new completion context. (Mostly useful for testing
    completion sources—in the editor, the extension will create
    these for you.)
    */
      constructor(
        /**
    The editor state that the completion happens in.
    */
        state,
        /**
    The position at which the completion is happening.
    */
        pos,
        /**
    Indicates whether completion was activated explicitly, or
    implicitly by typing. The usual way to respond to this is to
    only return completions when either there is part of a
    completable entity before the cursor, or `explicit` is true.
    */
        explicit
      ) {
        this.state = state
        this.pos = pos
        this.explicit = explicit
        /**
        @internal
        */
        this.abortListeners = []
      }
      /**
    Get the extent, content, and (if there is a token) type of the
    token before `this.pos`.
    */
      tokenBefore(types) {
        let token = dist_syntaxTree(this.state).resolveInner(this.pos, -1)
        while (token && types.indexOf(token.name) < 0) token = token.parent
        return token
          ? {
              from: token.from,
              to: this.pos,
              text: this.state.sliceDoc(token.from, this.pos),
              type: token.type
            }
          : null
      }
      /**
    Get the match of the given expression directly before the
    cursor.
    */
      matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos)
        let start = Math.max(line.from, this.pos - 250)
        let str = line.text.slice(start - line.from, this.pos - line.from)
        let found = str.search(ensureAnchor(expr, false))
        return found < 0
          ? null
          : { from: start + found, to: this.pos, text: str.slice(found) }
      }
      /**
    Yields true when the query has been aborted. Can be useful in
    asynchronous queries to avoid doing work that will be ignored.
    */
      get aborted() {
        return this.abortListeners == null
      }
      /**
    Allows you to register abort handlers, which will be called when
    the query is
    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
    */
      addEventListener(type, listener) {
        if (type == 'abort' && this.abortListeners)
          this.abortListeners.push(listener)
      }
    }
    function toSet(chars) {
      let flat = Object.keys(chars).join('')
      let words = /\w/.test(flat)
      if (words) flat = flat.replace(/\w/g, '')
      return `[${words ? '\\w' : ''}${flat.replace(/[^\w\s]/g, '\\$&')}]`
    }
    function prefixMatch(options) {
      let first = Object.create(null),
        rest = Object.create(null)
      for (let { label } of options) {
        first[label[0]] = true
        for (let i = 1; i < label.length; i++) rest[label[i]] = true
      }
      let source = toSet(first) + toSet(rest) + '*$'
      return [new RegExp('^' + source), new RegExp(source)]
    }
    /**
Given a a fixed array of options, return an autocompleter that
completes them.
*/
    function completeFromList(list) {
      let options = list.map((o) => (typeof o == 'string' ? { label: o } : o))
      let [validFor, match] = options.every((o) => /^\w+$/.test(o.label))
        ? [/\w*$/, /\w+$/]
        : prefixMatch(options)
      return (context) => {
        let token = context.matchBefore(match)
        return token || context.explicit
          ? { from: token ? token.from : context.pos, options, validFor }
          : null
      }
    }
    /**
Wrap the given completion source so that it will only fire when the
cursor is in a syntax node with one of the given names.
*/
    function ifIn(nodes, source) {
      return (context) => {
        for (
          let pos = syntaxTree(context.state).resolveInner(context.pos, -1);
          pos;
          pos = pos.parent
        ) {
          if (nodes.indexOf(pos.name) > -1) return source(context)
          if (pos.type.isTop) break
        }
        return null
      }
    }
    /**
Wrap the given completion source so that it will not fire when the
cursor is in a syntax node with one of the given names.
*/
    function ifNotIn(nodes, source) {
      return (context) => {
        for (
          let pos = dist_syntaxTree(context.state).resolveInner(
            context.pos,
            -1
          );
          pos;
          pos = pos.parent
        ) {
          if (nodes.indexOf(pos.name) > -1) return null
          if (pos.type.isTop) break
        }
        return source(context)
      }
    }
    class Option {
      constructor(completion, source, match, score) {
        this.completion = completion
        this.source = source
        this.match = match
        this.score = score
      }
    }
    function cur(state) {
      return state.selection.main.from
    }
    // Make sure the given regexp has a $ at its end and, if `start` is
    // true, a ^ at its start.
    function ensureAnchor(expr, start) {
      var _a
      let { source } = expr
      let addStart = start && source[0] != '^',
        addEnd = source[source.length - 1] != '$'
      if (!addStart && !addEnd) return expr
      return new RegExp(
        `${addStart ? '^' : ''}(?:${source})${addEnd ? '$' : ''}`,
        (_a = expr.flags) !== null && _a !== void 0
          ? _a
          : expr.ignoreCase
            ? 'i'
            : ''
      )
    }
    /**
This annotation is added to transactions that are produced by
picking a completion.
*/
    const pickedCompletion = /*@__PURE__*/ Annotation.define()
    /**
Helper function that returns a transaction spec which inserts a
completion's text in the main selection range, and any other
selection range that has the same text in front of it.
*/
    function insertCompletionText(state, text, from, to) {
      let { main } = state.selection,
        fromOff = from - main.from,
        toOff = to - main.from
      return Object.assign(
        Object.assign(
          {},
          state.changeByRange((range) => {
            if (
              range != main &&
              from != to &&
              state.sliceDoc(range.from + fromOff, range.from + toOff) !=
                state.sliceDoc(from, to)
            )
              return { range }
            return {
              changes: {
                from: range.from + fromOff,
                to: to == main.from ? range.to : range.from + toOff,
                insert: text
              },
              range: dist_EditorSelection.cursor(
                range.from + fromOff + text.length
              )
            }
          })
        ),
        { scrollIntoView: true, userEvent: 'input.complete' }
      )
    }
    const SourceCache = /*@__PURE__*/ new WeakMap()
    function asSource(source) {
      if (!Array.isArray(source)) return source
      let known = SourceCache.get(source)
      if (!known) SourceCache.set(source, (known = completeFromList(source)))
      return known
    }
    const startCompletionEffect = /*@__PURE__*/ StateEffect.define()
    const closeCompletionEffect = /*@__PURE__*/ StateEffect.define()

    // A pattern matcher for fuzzy completion matching. Create an instance
    // once for a pattern, and then use that to match any number of
    // completions.
    class FuzzyMatcher {
      constructor(pattern) {
        this.pattern = pattern
        this.chars = []
        this.folded = []
        // Buffers reused by calls to `match` to track matched character
        // positions.
        this.any = []
        this.precise = []
        this.byWord = []
        this.score = 0
        this.matched = []
        for (let p = 0; p < pattern.length; ) {
          let char = codePointAt(pattern, p),
            size = codePointSize(char)
          this.chars.push(char)
          let part = pattern.slice(p, p + size),
            upper = part.toUpperCase()
          this.folded.push(
            codePointAt(upper == part ? part.toLowerCase() : upper, 0)
          )
          p += size
        }
        this.astral = pattern.length != this.chars.length
      }
      ret(score, matched) {
        this.score = score
        this.matched = matched
        return true
      }
      // Matches a given word (completion) against the pattern (input).
      // Will return a boolean indicating whether there was a match and,
      // on success, set `this.score` to the score, `this.matched` to an
      // array of `from, to` pairs indicating the matched parts of `word`.
      //
      // The score is a number that is more negative the worse the match
      // is. See `Penalty` above.
      match(word) {
        if (this.pattern.length == 0)
          return this.ret(-100 /* Penalty.NotFull */, [])
        if (word.length < this.pattern.length) return false
        let { chars, folded, any, precise, byWord } = this
        // For single-character queries, only match when they occur right
        // at the start
        if (chars.length == 1) {
          let first = codePointAt(word, 0),
            firstSize = codePointSize(first)
          let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */
          if (first == chars[0]);
          else if (first == folded[0]) score += -200 /* Penalty.CaseFold */
          else return false
          return this.ret(score, [0, firstSize])
        }
        let direct = word.indexOf(this.pattern)
        if (direct == 0)
          return this.ret(
            word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */,
            [0, this.pattern.length]
          )
        let len = chars.length,
          anyTo = 0
        if (direct < 0) {
          for (
            let i = 0, e = Math.min(word.length, 200);
            i < e && anyTo < len;

          ) {
            let next = codePointAt(word, i)
            if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i
            i += codePointSize(next)
          }
          // No match, exit immediately
          if (anyTo < len) return false
        }
        // This tracks the extent of the precise (non-folded, not
        // necessarily adjacent) match
        let preciseTo = 0
        // Tracks whether there is a match that hits only characters that
        // appear to be starting words. `byWordFolded` is set to true when
        // a case folded character is encountered in such a match
        let byWordTo = 0,
          byWordFolded = false
        // If we've found a partial adjacent match, these track its state
        let adjacentTo = 0,
          adjacentStart = -1,
          adjacentEnd = -1
        let hasLower = /[a-z]/.test(word),
          wordAdjacent = true
        // Go over the option's text, scanning for the various kinds of matches
        for (
          let i = 0,
            e = Math.min(word.length, 200),
            prevType = 0 /* Tp.NonWord */;
          i < e && byWordTo < len;

        ) {
          let next = codePointAt(word, i)
          if (direct < 0) {
            if (preciseTo < len && next == chars[preciseTo])
              precise[preciseTo++] = i
            if (adjacentTo < len) {
              if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                if (adjacentTo == 0) adjacentStart = i
                adjacentEnd = i + 1
                adjacentTo++
              } else {
                adjacentTo = 0
              }
            }
          }
          let ch,
            type =
              next < 0xff
                ? (next >= 48 && next <= 57) || (next >= 97 && next <= 122)
                  ? 2 /* Tp.Lower */
                  : next >= 65 && next <= 90
                    ? 1 /* Tp.Upper */
                    : 0 /* Tp.NonWord */
                : (ch = fromCodePoint(next)) != ch.toLowerCase()
                  ? 1 /* Tp.Upper */
                  : ch != ch.toUpperCase()
                    ? 2 /* Tp.Lower */
                    : 0 /* Tp.NonWord */
          if (
            !i ||
            (type == 1 /* Tp.Upper */ && hasLower) ||
            (prevType == 0 /* Tp.NonWord */ && type != 0) /* Tp.NonWord */
          ) {
            if (
              chars[byWordTo] == next ||
              (folded[byWordTo] == next && (byWordFolded = true))
            )
              byWord[byWordTo++] = i
            else if (byWord.length) wordAdjacent = false
          }
          prevType = type
          i += codePointSize(next)
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
          return this.result(
            -100 /* Penalty.ByWord */ +
              (byWordFolded ? -200 /* Penalty.CaseFold */ : 0),
            byWord,
            word
          )
        if (adjacentTo == len && adjacentStart == 0)
          return this.ret(
            -200 /* Penalty.CaseFold */ -
              word.length +
              (adjacentEnd == word.length ? 0 : -100) /* Penalty.NotFull */,
            [0, adjacentEnd]
          )
        if (direct > -1)
          return this.ret(-700 /* Penalty.NotStart */ - word.length, [
            direct,
            direct + this.pattern.length
          ])
        if (adjacentTo == len)
          return this.ret(
            -200 /* Penalty.CaseFold */ +
              -700 /* Penalty.NotStart */ -
              word.length,
            [adjacentStart, adjacentEnd]
          )
        if (byWordTo == len)
          return this.result(
            -100 /* Penalty.ByWord */ +
              (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) +
              -700 /* Penalty.NotStart */ +
              (wordAdjacent ? 0 : -1100) /* Penalty.Gap */,
            byWord,
            word
          )
        return chars.length == 2
          ? false
          : this.result(
              (any[0] ? -700 /* Penalty.NotStart */ : 0) +
                -200 /* Penalty.CaseFold */ +
                -1100 /* Penalty.Gap */,
              any,
              word
            )
      }
      result(score, positions, word) {
        let result = [],
          i = 0
        for (let pos of positions) {
          let to =
            pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1)
          if (i && result[i - 1] == pos) result[i - 1] = to
          else {
            result[i++] = pos
            result[i++] = to
          }
        }
        return this.ret(score - word.length, result)
      }
    }

    const completionConfig = /*@__PURE__*/ Facet.define({
      combine(configs) {
        return combineConfig(
          configs,
          {
            activateOnTyping: true,
            selectOnOpen: true,
            override: null,
            closeOnBlur: true,
            maxRenderedOptions: 100,
            defaultKeymap: true,
            tooltipClass: () => '',
            optionClass: () => '',
            aboveCursor: false,
            icons: true,
            addToOptions: [],
            positionInfo: defaultPositionInfo,
            compareCompletions: (a, b) => a.label.localeCompare(b.label),
            interactionDelay: 75,
            updateSyncTime: 100
          },
          {
            defaultKeymap: (a, b) => a && b,
            closeOnBlur: (a, b) => a && b,
            icons: (a, b) => a && b,
            tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
            optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
            addToOptions: (a, b) => a.concat(b)
          }
        )
      }
    })
    function joinClass(a, b) {
      return a ? (b ? a + ' ' + b : a) : b
    }
    function defaultPositionInfo(view, list, option, info, space, tooltip) {
      let rtl = view.textDirection == Direction.RTL,
        left = rtl,
        narrow = false
      let side = 'top',
        offset,
        maxWidth
      let spaceLeft = list.left - space.left,
        spaceRight = space.right - list.right
      let infoWidth = info.right - info.left,
        infoHeight = info.bottom - info.top
      if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false
      else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true
      if (infoWidth <= (left ? spaceLeft : spaceRight)) {
        offset =
          Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) -
          list.top
        maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight)
      } else {
        narrow = true
        maxWidth = Math.min(
          400 /* Info.Width */,
          (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */
        )
        let spaceBelow = space.bottom - list.bottom
        if (spaceBelow >= infoHeight || spaceBelow > list.top) {
          // Below the completion
          offset = option.bottom - list.top
        } else {
          // Above it
          side = 'bottom'
          offset = list.bottom - option.top
        }
      }
      let scaleY = (list.bottom - list.top) / tooltip.offsetHeight
      let scaleX = (list.right - list.left) / tooltip.offsetWidth
      return {
        style: `${side}: ${offset / scaleY}px; max-width: ${
          maxWidth / scaleX
        }px`,
        class:
          'cm-completionInfo-' +
          (narrow
            ? rtl
              ? 'left-narrow'
              : 'right-narrow'
            : left
              ? 'left'
              : 'right')
      }
    }

    function optionContent(config) {
      let content = config.addToOptions.slice()
      if (config.icons)
        content.push({
          render(completion) {
            let icon = document.createElement('div')
            icon.classList.add('cm-completionIcon')
            if (completion.type)
              icon.classList.add(
                ...completion.type
                  .split(/\s+/g)
                  .map((cls) => 'cm-completionIcon-' + cls)
              )
            icon.setAttribute('aria-hidden', 'true')
            return icon
          },
          position: 20
        })
      content.push(
        {
          render(completion, _s, _v, match) {
            let labelElt = document.createElement('span')
            labelElt.className = 'cm-completionLabel'
            let label = completion.displayLabel || completion.label,
              off = 0
            for (let j = 0; j < match.length; ) {
              let from = match[j++],
                to = match[j++]
              if (from > off)
                labelElt.appendChild(
                  document.createTextNode(label.slice(off, from))
                )
              let span = labelElt.appendChild(document.createElement('span'))
              span.appendChild(document.createTextNode(label.slice(from, to)))
              span.className = 'cm-completionMatchedText'
              off = to
            }
            if (off < label.length)
              labelElt.appendChild(document.createTextNode(label.slice(off)))
            return labelElt
          },
          position: 50
        },
        {
          render(completion) {
            if (!completion.detail) return null
            let detailElt = document.createElement('span')
            detailElt.className = 'cm-completionDetail'
            detailElt.textContent = completion.detail
            return detailElt
          },
          position: 80
        }
      )
      return content
        .sort((a, b) => a.position - b.position)
        .map((a) => a.render)
    }
    function rangeAroundSelected(total, selected, max) {
      if (total <= max) return { from: 0, to: total }
      if (selected < 0) selected = 0
      if (selected <= total >> 1) {
        let off = Math.floor(selected / max)
        return { from: off * max, to: (off + 1) * max }
      }
      let off = Math.floor((total - selected) / max)
      return { from: total - (off + 1) * max, to: total - off * max }
    }
    class CompletionTooltip {
      constructor(view, stateField, applyCompletion) {
        this.view = view
        this.stateField = stateField
        this.applyCompletion = applyCompletion
        this.info = null
        this.infoDestroy = null
        this.placeInfoReq = {
          read: () => this.measureInfo(),
          write: (pos) => this.placeInfo(pos),
          key: this
        }
        this.space = null
        this.currentClass = ''
        let cState = view.state.field(stateField)
        let { options, selected } = cState.open
        let config = view.state.facet(completionConfig)
        this.optionContent = optionContent(config)
        this.optionClass = config.optionClass
        this.tooltipClass = config.tooltipClass
        this.range = rangeAroundSelected(
          options.length,
          selected,
          config.maxRenderedOptions
        )
        this.dom = document.createElement('div')
        this.dom.className = 'cm-tooltip-autocomplete'
        this.updateTooltipClass(view.state)
        this.dom.addEventListener('mousedown', (e) => {
          let { options } = view.state.field(stateField).open
          for (
            let dom = e.target, match;
            dom && dom != this.dom;
            dom = dom.parentNode
          ) {
            if (
              dom.nodeName == 'LI' &&
              (match = /-(\d+)$/.exec(dom.id)) &&
              +match[1] < options.length
            ) {
              this.applyCompletion(view, options[+match[1]])
              e.preventDefault()
              return
            }
          }
        })
        this.dom.addEventListener('focusout', (e) => {
          let state = view.state.field(this.stateField, false)
          if (
            state &&
            state.tooltip &&
            view.state.facet(completionConfig).closeOnBlur &&
            e.relatedTarget != view.contentDOM
          )
            view.dispatch({ effects: closeCompletionEffect.of(null) })
        })
        this.showOptions(options, cState.id)
      }
      mount() {
        this.updateSel()
      }
      showOptions(options, id) {
        if (this.list) this.list.remove()
        this.list = this.dom.appendChild(
          this.createListBox(options, id, this.range)
        )
        this.list.addEventListener('scroll', () => {
          if (this.info) this.view.requestMeasure(this.placeInfoReq)
        })
      }
      update(update) {
        var _a
        let cState = update.state.field(this.stateField)
        let prevState = update.startState.field(this.stateField)
        this.updateTooltipClass(update.state)
        if (cState != prevState) {
          let { options, selected, disabled } = cState.open
          if (!prevState.open || prevState.open.options != options) {
            this.range = rangeAroundSelected(
              options.length,
              selected,
              update.state.facet(completionConfig).maxRenderedOptions
            )
            this.showOptions(options, cState.id)
          }
          this.updateSel()
          if (
            disabled !=
            ((_a = prevState.open) === null || _a === void 0
              ? void 0
              : _a.disabled)
          )
            this.dom.classList.toggle(
              'cm-tooltip-autocomplete-disabled',
              !!disabled
            )
        }
      }
      updateTooltipClass(state) {
        let cls = this.tooltipClass(state)
        if (cls != this.currentClass) {
          for (let c of this.currentClass.split(' '))
            if (c) this.dom.classList.remove(c)
          for (let c of cls.split(' ')) if (c) this.dom.classList.add(c)
          this.currentClass = cls
        }
      }
      positioned(space) {
        this.space = space
        if (this.info) this.view.requestMeasure(this.placeInfoReq)
      }
      updateSel() {
        let cState = this.view.state.field(this.stateField),
          open = cState.open
        if (
          (open.selected > -1 && open.selected < this.range.from) ||
          open.selected >= this.range.to
        ) {
          this.range = rangeAroundSelected(
            open.options.length,
            open.selected,
            this.view.state.facet(completionConfig).maxRenderedOptions
          )
          this.showOptions(open.options, cState.id)
        }
        if (this.updateSelectedOption(open.selected)) {
          this.destroyInfo()
          let { completion } = open.options[open.selected]
          let { info } = completion
          if (!info) return
          let infoResult =
            typeof info === 'string'
              ? document.createTextNode(info)
              : info(completion)
          if (!infoResult) return
          if ('then' in infoResult) {
            infoResult
              .then((obj) => {
                if (
                  obj &&
                  this.view.state.field(this.stateField, false) == cState
                )
                  this.addInfoPane(obj, completion)
              })
              .catch((e) =>
                dist_logException(this.view.state, e, 'completion info')
              )
          } else {
            this.addInfoPane(infoResult, completion)
          }
        }
      }
      addInfoPane(content, completion) {
        this.destroyInfo()
        let wrap = (this.info = document.createElement('div'))
        wrap.className = 'cm-tooltip cm-completionInfo'
        if (content.nodeType != null) {
          wrap.appendChild(content)
          this.infoDestroy = null
        } else {
          let { dom, destroy } = content
          wrap.appendChild(dom)
          this.infoDestroy = destroy || null
        }
        this.dom.appendChild(wrap)
        this.view.requestMeasure(this.placeInfoReq)
      }
      updateSelectedOption(selected) {
        let set = null
        for (
          let opt = this.list.firstChild, i = this.range.from;
          opt;
          opt = opt.nextSibling, i++
        ) {
          if (opt.nodeName != 'LI' || !opt.id) {
            i-- // A section header
          } else if (i == selected) {
            if (!opt.hasAttribute('aria-selected')) {
              opt.setAttribute('aria-selected', 'true')
              set = opt
            }
          } else {
            if (opt.hasAttribute('aria-selected'))
              opt.removeAttribute('aria-selected')
          }
        }
        if (set) dist_scrollIntoView(this.list, set)
        return set
      }
      measureInfo() {
        let sel = this.dom.querySelector('[aria-selected]')
        if (!sel || !this.info) return null
        let listRect = this.dom.getBoundingClientRect()
        let infoRect = this.info.getBoundingClientRect()
        let selRect = sel.getBoundingClientRect()
        let space = this.space
        if (!space) {
          let win = this.dom.ownerDocument.defaultView || window
          space = {
            left: 0,
            top: 0,
            right: win.innerWidth,
            bottom: win.innerHeight
          }
        }
        if (
          selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||
          selRect.bottom < Math.max(space.top, listRect.top) + 10
        )
          return null
        return this.view.state
          .facet(completionConfig)
          .positionInfo(this.view, listRect, selRect, infoRect, space, this.dom)
      }
      placeInfo(pos) {
        if (this.info) {
          if (pos) {
            if (pos.style) this.info.style.cssText = pos.style
            this.info.className =
              'cm-tooltip cm-completionInfo ' + (pos.class || '')
          } else {
            this.info.style.cssText = 'top: -1e6px'
          }
        }
      }
      createListBox(options, id, range) {
        const ul = document.createElement('ul')
        ul.id = id
        ul.setAttribute('role', 'listbox')
        ul.setAttribute('aria-expanded', 'true')
        ul.setAttribute('aria-label', this.view.state.phrase('Completions'))
        let curSection = null
        for (let i = range.from; i < range.to; i++) {
          let { completion, match } = options[i],
            { section } = completion
          if (section) {
            let name = typeof section == 'string' ? section : section.name
            if (name != curSection && (i > range.from || range.from == 0)) {
              curSection = name
              if (typeof section != 'string' && section.header) {
                ul.appendChild(section.header(section))
              } else {
                let header = ul.appendChild(
                  document.createElement('completion-section')
                )
                header.textContent = name
              }
            }
          }
          const li = ul.appendChild(document.createElement('li'))
          li.id = id + '-' + i
          li.setAttribute('role', 'option')
          let cls = this.optionClass(completion)
          if (cls) li.className = cls
          for (let source of this.optionContent) {
            let node = source(completion, this.view.state, this.view, match)
            if (node) li.appendChild(node)
          }
        }
        if (range.from) ul.classList.add('cm-completionListIncompleteTop')
        if (range.to < options.length)
          ul.classList.add('cm-completionListIncompleteBottom')
        return ul
      }
      destroyInfo() {
        if (this.info) {
          if (this.infoDestroy) this.infoDestroy()
          this.info.remove()
          this.info = null
        }
      }
      destroy() {
        this.destroyInfo()
      }
    }
    function completionTooltip(stateField, applyCompletion) {
      return (view) => new CompletionTooltip(view, stateField, applyCompletion)
    }
    function dist_scrollIntoView(container, element) {
      let parent = container.getBoundingClientRect()
      let self = element.getBoundingClientRect()
      let scaleY = parent.height / container.offsetHeight
      if (self.top < parent.top)
        container.scrollTop -= (parent.top - self.top) / scaleY
      else if (self.bottom > parent.bottom)
        container.scrollTop += (self.bottom - parent.bottom) / scaleY
    }

    // Used to pick a preferred option when two options with the same
    // label occur in the result.
    function score(option) {
      return (
        (option.boost || 0) * 100 +
        (option.apply ? 10 : 0) +
        (option.info ? 5 : 0) +
        (option.type ? 1 : 0)
      )
    }
    function sortOptions(active, state) {
      let options = []
      let sections = null
      let addOption = (option) => {
        options.push(option)
        let { section } = option.completion
        if (section) {
          if (!sections) sections = []
          let name = typeof section == 'string' ? section : section.name
          if (!sections.some((s) => s.name == name))
            sections.push(typeof section == 'string' ? { name } : section)
        }
      }
      for (let a of active)
        if (a.hasResult()) {
          let getMatch = a.result.getMatch
          if (a.result.filter === false) {
            for (let option of a.result.options) {
              addOption(
                new Option(
                  option,
                  a.source,
                  getMatch ? getMatch(option) : [],
                  1e9 - options.length
                )
              )
            }
          } else {
            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to))
            for (let option of a.result.options)
              if (matcher.match(option.label)) {
                let matched = !option.displayLabel
                  ? matcher.matched
                  : getMatch
                    ? getMatch(option, matcher.matched)
                    : []
                addOption(
                  new Option(
                    option,
                    a.source,
                    matched,
                    matcher.score + (option.boost || 0)
                  )
                )
              }
          }
        }
      if (sections) {
        let sectionOrder = Object.create(null),
          pos = 0
        let cmp = (a, b) => {
          var _a, _b
          return (
            ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) -
              ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) ||
            (a.name < b.name ? -1 : 1)
          )
        }
        for (let s of sections.sort(cmp)) {
          pos -= 1e5
          sectionOrder[s.name] = pos
        }
        for (let option of options) {
          let { section } = option.completion
          if (section)
            option.score +=
              sectionOrder[typeof section == 'string' ? section : section.name]
        }
      }
      let result = [],
        prev = null
      let compare = state.facet(completionConfig).compareCompletions
      for (let opt of options.sort(
        (a, b) => b.score - a.score || compare(a.completion, b.completion)
      )) {
        let cur = opt.completion
        if (
          !prev ||
          prev.label != cur.label ||
          prev.detail != cur.detail ||
          (prev.type != null && cur.type != null && prev.type != cur.type) ||
          prev.apply != cur.apply ||
          prev.boost != cur.boost
        )
          result.push(opt)
        else if (score(opt.completion) > score(prev))
          result[result.length - 1] = opt
        prev = opt.completion
      }
      return result
    }
    class CompletionDialog {
      constructor(options, attrs, tooltip, timestamp, selected, disabled) {
        this.options = options
        this.attrs = attrs
        this.tooltip = tooltip
        this.timestamp = timestamp
        this.selected = selected
        this.disabled = disabled
      }
      setSelected(selected, id) {
        return selected == this.selected || selected >= this.options.length
          ? this
          : new CompletionDialog(
              this.options,
              makeAttrs(id, selected),
              this.tooltip,
              this.timestamp,
              selected,
              this.disabled
            )
      }
      static build(active, state, id, prev, conf) {
        let options = sortOptions(active, state)
        if (!options.length) {
          return prev && active.some((a) => a.state == 1 /* State.Pending */)
            ? new CompletionDialog(
                prev.options,
                prev.attrs,
                prev.tooltip,
                prev.timestamp,
                prev.selected,
                true
              )
            : null
        }
        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1
        if (prev && prev.selected != selected && prev.selected != -1) {
          let selectedValue = prev.options[prev.selected].completion
          for (let i = 0; i < options.length; i++)
            if (options[i].completion == selectedValue) {
              selected = i
              break
            }
        }
        return new CompletionDialog(
          options,
          makeAttrs(id, selected),
          {
            pos: active.reduce(
              (a, b) => (b.hasResult() ? Math.min(a, b.from) : a),
              1e8
            ),
            create: createTooltip,
            above: conf.aboveCursor
          },
          prev ? prev.timestamp : Date.now(),
          selected,
          false
        )
      }
      map(changes) {
        return new CompletionDialog(
          this.options,
          this.attrs,
          Object.assign(Object.assign({}, this.tooltip), {
            pos: changes.mapPos(this.tooltip.pos)
          }),
          this.timestamp,
          this.selected,
          this.disabled
        )
      }
    }
    class CompletionState {
      constructor(active, id, open) {
        this.active = active
        this.id = id
        this.open = open
      }
      static start() {
        return new CompletionState(
          autocomplete_dist_none,
          'cm-ac-' + Math.floor(Math.random() * 2e6).toString(36),
          null
        )
      }
      update(tr) {
        let { state } = tr,
          conf = state.facet(completionConfig)
        let sources =
          conf.override ||
          state.languageDataAt('autocomplete', cur(state)).map(asSource)
        let active = sources.map((source) => {
          let value =
            this.active.find((s) => s.source == source) ||
            new ActiveSource(
              source,
              this.active.some((a) => a.state != 0 /* State.Inactive */)
                ? 1 /* State.Pending */
                : 0 /* State.Inactive */
            )
          return value.update(tr, conf)
        })
        if (
          active.length == this.active.length &&
          active.every((a, i) => a == this.active[i])
        )
          active = this.active
        let open = this.open
        if (open && tr.docChanged) open = open.map(tr.changes)
        if (
          tr.selection ||
          active.some(
            (a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)
          ) ||
          !sameResults(active, this.active)
        )
          open = CompletionDialog.build(active, state, this.id, open, conf)
        else if (
          open &&
          open.disabled &&
          !active.some((a) => a.state == 1 /* State.Pending */)
        )
          open = null
        if (
          !open &&
          active.every((a) => a.state != 1 /* State.Pending */) &&
          active.some((a) => a.hasResult())
        )
          active = active.map((a) =>
            a.hasResult()
              ? new ActiveSource(a.source, 0 /* State.Inactive */)
              : a
          )
        for (let effect of tr.effects)
          if (effect.is(setSelectedEffect))
            open = open && open.setSelected(effect.value, this.id)
        return active == this.active && open == this.open
          ? this
          : new CompletionState(active, this.id, open)
      }
      get tooltip() {
        return this.open ? this.open.tooltip : null
      }
      get attrs() {
        return this.open ? this.open.attrs : baseAttrs
      }
    }
    function sameResults(a, b) {
      if (a == b) return true
      for (let iA = 0, iB = 0; ; ) {
        while (iA < a.length && !a[iA].hasResult) iA++
        while (iB < b.length && !b[iB].hasResult) iB++
        let endA = iA == a.length,
          endB = iB == b.length
        if (endA || endB) return endA == endB
        if (a[iA++].result != b[iB++].result) return false
      }
    }
    const baseAttrs = {
      'aria-autocomplete': 'list'
    }
    function makeAttrs(id, selected) {
      let result = {
        'aria-autocomplete': 'list',
        'aria-haspopup': 'listbox',
        'aria-controls': id
      }
      if (selected > -1) result['aria-activedescendant'] = id + '-' + selected
      return result
    }
    const autocomplete_dist_none = []
    function getUserEvent(tr) {
      return tr.isUserEvent('input.type')
        ? 'input'
        : tr.isUserEvent('delete.backward')
          ? 'delete'
          : null
    }
    class ActiveSource {
      constructor(source, state, explicitPos = -1) {
        this.source = source
        this.state = state
        this.explicitPos = explicitPos
      }
      hasResult() {
        return false
      }
      update(tr, conf) {
        let event = getUserEvent(tr),
          value = this
        if (event) value = value.handleUserEvent(tr, event, conf)
        else if (tr.docChanged) value = value.handleChange(tr)
        else if (tr.selection && value.state != 0 /* State.Inactive */)
          value = new ActiveSource(value.source, 0 /* State.Inactive */)
        for (let effect of tr.effects) {
          if (effect.is(startCompletionEffect))
            value = new ActiveSource(
              value.source,
              1 /* State.Pending */,
              effect.value ? cur(tr.state) : -1
            )
          else if (effect.is(closeCompletionEffect))
            value = new ActiveSource(value.source, 0 /* State.Inactive */)
          else if (effect.is(setActiveEffect))
            for (let active of effect.value)
              if (active.source == value.source) value = active
        }
        return value
      }
      handleUserEvent(tr, type, conf) {
        return type == 'delete' || !conf.activateOnTyping
          ? this.map(tr.changes)
          : new ActiveSource(this.source, 1 /* State.Pending */)
      }
      handleChange(tr) {
        return tr.changes.touchesRange(cur(tr.startState))
          ? new ActiveSource(this.source, 0 /* State.Inactive */)
          : this.map(tr.changes)
      }
      map(changes) {
        return changes.empty || this.explicitPos < 0
          ? this
          : new ActiveSource(
              this.source,
              this.state,
              changes.mapPos(this.explicitPos)
            )
      }
    }
    class ActiveResult extends ActiveSource {
      constructor(source, explicitPos, result, from, to) {
        super(source, 2 /* State.Result */, explicitPos)
        this.result = result
        this.from = from
        this.to = to
      }
      hasResult() {
        return true
      }
      handleUserEvent(tr, type, conf) {
        var _a
        let from = tr.changes.mapPos(this.from),
          to = tr.changes.mapPos(this.to, 1)
        let pos = cur(tr.state)
        if (
          (this.explicitPos < 0 ? pos <= from : pos < this.from) ||
          pos > to ||
          (type == 'delete' && cur(tr.startState) == this.from)
        )
          return new ActiveSource(
            this.source,
            type == 'input' && conf.activateOnTyping
              ? 1 /* State.Pending */
              : 0 /* State.Inactive */
          )
        let explicitPos =
            this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos),
          updated
        if (checkValid(this.result.validFor, tr.state, from, to))
          return new ActiveResult(
            this.source,
            explicitPos,
            this.result,
            from,
            to
          )
        if (
          this.result.update &&
          (updated = this.result.update(
            this.result,
            from,
            to,
            new CompletionContext(tr.state, pos, explicitPos >= 0)
          ))
        )
          return new ActiveResult(
            this.source,
            explicitPos,
            updated,
            updated.from,
            (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state)
          )
        return new ActiveSource(this.source, 1 /* State.Pending */, explicitPos)
      }
      handleChange(tr) {
        return tr.changes.touchesRange(this.from, this.to)
          ? new ActiveSource(this.source, 0 /* State.Inactive */)
          : this.map(tr.changes)
      }
      map(mapping) {
        return mapping.empty
          ? this
          : new ActiveResult(
              this.source,
              this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos),
              this.result,
              mapping.mapPos(this.from),
              mapping.mapPos(this.to, 1)
            )
      }
    }
    function checkValid(validFor, state, from, to) {
      if (!validFor) return false
      let text = state.sliceDoc(from, to)
      return typeof validFor == 'function'
        ? validFor(text, from, to, state)
        : ensureAnchor(validFor, true).test(text)
    }
    const setActiveEffect = /*@__PURE__*/ StateEffect.define({
      map(sources, mapping) {
        return sources.map((s) => s.map(mapping))
      }
    })
    const setSelectedEffect = /*@__PURE__*/ StateEffect.define()
    const completionState = /*@__PURE__*/ StateField.define({
      create() {
        return CompletionState.start()
      },
      update(value, tr) {
        return value.update(tr)
      },
      provide: (f) => [
        showTooltip.from(f, (val) => val.tooltip),
        EditorView.contentAttributes.from(f, (state) => state.attrs)
      ]
    })
    function applyCompletion(view, option) {
      const apply = option.completion.apply || option.completion.label
      let result = view.state
        .field(completionState)
        .active.find((a) => a.source == option.source)
      if (!(result instanceof ActiveResult)) return false
      if (typeof apply == 'string')
        view.dispatch(
          Object.assign(
            Object.assign(
              {},
              insertCompletionText(view.state, apply, result.from, result.to)
            ),
            { annotations: pickedCompletion.of(option.completion) }
          )
        )
      else apply(view, option.completion, result.from, result.to)
      return true
    }
    const createTooltip = /*@__PURE__*/ completionTooltip(
      completionState,
      applyCompletion
    )

    /**
Returns a command that moves the completion selection forward or
backward by the given amount.
*/
    function moveCompletionSelection(forward, by = 'option') {
      return (view) => {
        let cState = view.state.field(completionState, false)
        if (
          !cState ||
          !cState.open ||
          cState.open.disabled ||
          Date.now() - cState.open.timestamp <
            view.state.facet(completionConfig).interactionDelay
        )
          return false
        let step = 1,
          tooltip
        if (by == 'page' && (tooltip = getTooltip(view, cState.open.tooltip)))
          step = Math.max(
            2,
            Math.floor(
              tooltip.dom.offsetHeight /
                tooltip.dom.querySelector('li').offsetHeight
            ) - 1
          )
        let { length } = cState.open.options
        let selected =
          cState.open.selected > -1
            ? cState.open.selected + step * (forward ? 1 : -1)
            : forward
              ? 0
              : length - 1
        if (selected < 0) selected = by == 'page' ? 0 : length - 1
        else if (selected >= length) selected = by == 'page' ? length - 1 : 0
        view.dispatch({ effects: setSelectedEffect.of(selected) })
        return true
      }
    }
    /**
Accept the current completion.
*/
    const acceptCompletion = (view) => {
      let cState = view.state.field(completionState, false)
      if (
        view.state.readOnly ||
        !cState ||
        !cState.open ||
        cState.open.selected < 0 ||
        cState.open.disabled ||
        Date.now() - cState.open.timestamp <
          view.state.facet(completionConfig).interactionDelay
      )
        return false
      return applyCompletion(view, cState.open.options[cState.open.selected])
    }
    /**
Explicitly start autocompletion.
*/
    const startCompletion = (view) => {
      let cState = view.state.field(completionState, false)
      if (!cState) return false
      view.dispatch({ effects: startCompletionEffect.of(true) })
      return true
    }
    /**
Close the currently active completion.
*/
    const closeCompletion = (view) => {
      let cState = view.state.field(completionState, false)
      if (
        !cState ||
        !cState.active.some((a) => a.state != 0 /* State.Inactive */)
      )
        return false
      view.dispatch({ effects: closeCompletionEffect.of(null) })
      return true
    }
    class RunningQuery {
      constructor(active, context) {
        this.active = active
        this.context = context
        this.time = Date.now()
        this.updates = []
        // Note that 'undefined' means 'not done yet', whereas 'null' means
        // 'query returned null'.
        this.done = undefined
      }
    }
    const MaxUpdateCount = 50,
      MinAbortTime = 1000
    const completionPlugin = /*@__PURE__*/ dist_ViewPlugin.fromClass(
      class {
        constructor(view) {
          this.view = view
          this.debounceUpdate = -1
          this.running = []
          this.debounceAccept = -1
          this.composing = 0 /* CompositionState.None */
          for (let active of view.state.field(completionState).active)
            if (active.state == 1 /* State.Pending */) this.startQuery(active)
        }
        update(update) {
          let cState = update.state.field(completionState)
          if (
            !update.selectionSet &&
            !update.docChanged &&
            update.startState.field(completionState) == cState
          )
            return
          let doesReset = update.transactions.some((tr) => {
            return (tr.selection || tr.docChanged) && !getUserEvent(tr)
          })
          for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i]
            if (
              doesReset ||
              (query.updates.length + update.transactions.length >
                MaxUpdateCount &&
                Date.now() - query.time > MinAbortTime)
            ) {
              for (let handler of query.context.abortListeners) {
                try {
                  handler()
                } catch (e) {
                  dist_logException(this.view.state, e)
                }
              }
              query.context.abortListeners = null
              this.running.splice(i--, 1)
            } else {
              query.updates.push(...update.transactions)
            }
          }
          if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate)
          this.debounceUpdate = cState.active.some(
            (a) =>
              a.state == 1 /* State.Pending */ &&
              !this.running.some((q) => q.active.source == a.source)
          )
            ? setTimeout(() => this.startUpdate(), 50)
            : -1
          if (this.composing != 0 /* CompositionState.None */)
            for (let tr of update.transactions) {
              if (getUserEvent(tr) == 'input')
                this.composing = 2 /* CompositionState.Changed */
              else if (
                this.composing == 2 /* CompositionState.Changed */ &&
                tr.selection
              )
                this.composing = 3 /* CompositionState.ChangedAndMoved */
            }
        }
        startUpdate() {
          this.debounceUpdate = -1
          let { state } = this.view,
            cState = state.field(completionState)
          for (let active of cState.active) {
            if (
              active.state == 1 /* State.Pending */ &&
              !this.running.some((r) => r.active.source == active.source)
            )
              this.startQuery(active)
          }
        }
        startQuery(active) {
          let { state } = this.view,
            pos = cur(state)
          let context = new CompletionContext(
            state,
            pos,
            active.explicitPos == pos
          )
          let pending = new RunningQuery(active, context)
          this.running.push(pending)
          Promise.resolve(active.source(context)).then(
            (result) => {
              if (!pending.context.aborted) {
                pending.done = result || null
                this.scheduleAccept()
              }
            },
            (err) => {
              this.view.dispatch({ effects: closeCompletionEffect.of(null) })
              dist_logException(this.view.state, err)
            }
          )
        }
        scheduleAccept() {
          if (this.running.every((q) => q.done !== undefined)) this.accept()
          else if (this.debounceAccept < 0)
            this.debounceAccept = setTimeout(
              () => this.accept(),
              this.view.state.facet(completionConfig).updateSyncTime
            )
        }
        // For each finished query in this.running, try to create a result
        // or, if appropriate, restart the query.
        accept() {
          var _a
          if (this.debounceAccept > -1) clearTimeout(this.debounceAccept)
          this.debounceAccept = -1
          let updated = []
          let conf = this.view.state.facet(completionConfig)
          for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i]
            if (query.done === undefined) continue
            this.running.splice(i--, 1)
            if (query.done) {
              let active = new ActiveResult(
                query.active.source,
                query.active.explicitPos,
                query.done,
                query.done.from,
                (_a = query.done.to) !== null && _a !== void 0
                  ? _a
                  : cur(
                      query.updates.length
                        ? query.updates[0].startState
                        : this.view.state
                    )
              )
              // Replay the transactions that happened since the start of
              // the request and see if that preserves the result
              for (let tr of query.updates) active = active.update(tr, conf)
              if (active.hasResult()) {
                updated.push(active)
                continue
              }
            }
            let current = this.view.state
              .field(completionState)
              .active.find((a) => a.source == query.active.source)
            if (current && current.state == 1 /* State.Pending */) {
              if (query.done == null) {
                // Explicitly failed. Should clear the pending status if it
                // hasn't been re-set in the meantime.
                let active = new ActiveSource(
                  query.active.source,
                  0 /* State.Inactive */
                )
                for (let tr of query.updates) active = active.update(tr, conf)
                if (active.state != 1 /* State.Pending */) updated.push(active)
              } else {
                // Cleared by subsequent transactions. Restart.
                this.startQuery(current)
              }
            }
          }
          if (updated.length)
            this.view.dispatch({ effects: setActiveEffect.of(updated) })
        }
      },
      {
        eventHandlers: {
          blur(event) {
            let state = this.view.state.field(completionState, false)
            if (
              state &&
              state.tooltip &&
              this.view.state.facet(completionConfig).closeOnBlur
            ) {
              let dialog =
                state.open && getTooltip(this.view, state.open.tooltip)
              if (!dialog || !dialog.dom.contains(event.relatedTarget))
                this.view.dispatch({ effects: closeCompletionEffect.of(null) })
            }
          },
          compositionstart() {
            this.composing = 1 /* CompositionState.Started */
          },
          compositionend() {
            if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {
              // Safari fires compositionend events synchronously, possibly
              // from inside an update, so dispatch asynchronously to avoid reentrancy
              setTimeout(
                () =>
                  this.view.dispatch({
                    effects: startCompletionEffect.of(false)
                  }),
                20
              )
            }
            this.composing = 0 /* CompositionState.None */
          }
        }
      }
    )

    const autocomplete_dist_baseTheme = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-tooltip.cm-tooltip-autocomplete': {
        '& > ul': {
          fontFamily: 'monospace',
          whiteSpace: 'nowrap',
          overflow: 'hidden auto',
          maxWidth_fallback: '700px',
          maxWidth: 'min(700px, 95vw)',
          minWidth: '250px',
          maxHeight: '10em',
          height: '100%',
          listStyle: 'none',
          margin: 0,
          padding: 0,
          '& > li, & > completion-section': {
            padding: '1px 3px',
            lineHeight: 1.2
          },
          '& > li': {
            overflowX: 'hidden',
            textOverflow: 'ellipsis',
            cursor: 'pointer'
          },
          '& > completion-section': {
            display: 'list-item',
            borderBottom: '1px solid silver',
            paddingLeft: '0.5em',
            opacity: 0.7
          }
        }
      },
      '&light .cm-tooltip-autocomplete ul li[aria-selected]': {
        background: '#17c',
        color: 'white'
      },
      '&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]': {
        background: '#777'
      },
      '&dark .cm-tooltip-autocomplete ul li[aria-selected]': {
        background: '#347',
        color: 'white'
      },
      '&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]': {
        background: '#444'
      },
      '.cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after':
        {
          content: '"···"',
          opacity: 0.5,
          display: 'block',
          textAlign: 'center'
        },
      '.cm-tooltip.cm-completionInfo': {
        position: 'absolute',
        padding: '3px 9px',
        width: 'max-content',
        maxWidth: `${400 /* Info.Width */}px`,
        boxSizing: 'border-box'
      },
      '.cm-completionInfo.cm-completionInfo-left': { right: '100%' },
      '.cm-completionInfo.cm-completionInfo-right': { left: '100%' },
      '.cm-completionInfo.cm-completionInfo-left-narrow': {
        right: `${30 /* Info.Margin */}px`
      },
      '.cm-completionInfo.cm-completionInfo-right-narrow': {
        left: `${30 /* Info.Margin */}px`
      },
      '&light .cm-snippetField': { backgroundColor: '#00000022' },
      '&dark .cm-snippetField': { backgroundColor: '#ffffff22' },
      '.cm-snippetFieldPosition': {
        verticalAlign: 'text-top',
        width: 0,
        height: '1.15em',
        display: 'inline-block',
        margin: '0 -0.7px -.7em',
        borderLeft: '1.4px dotted #888'
      },
      '.cm-completionMatchedText': {
        textDecoration: 'underline'
      },
      '.cm-completionDetail': {
        marginLeft: '0.5em',
        fontStyle: 'italic'
      },
      '.cm-completionIcon': {
        fontSize: '90%',
        width: '.8em',
        display: 'inline-block',
        textAlign: 'center',
        paddingRight: '.6em',
        opacity: '0.6',
        boxSizing: 'content-box'
      },
      '.cm-completionIcon-function, .cm-completionIcon-method': {
        '&:after': { content: "'ƒ'" }
      },
      '.cm-completionIcon-class': {
        '&:after': { content: "'○'" }
      },
      '.cm-completionIcon-interface': {
        '&:after': { content: "'◌'" }
      },
      '.cm-completionIcon-variable': {
        '&:after': { content: "'𝑥'" }
      },
      '.cm-completionIcon-constant': {
        '&:after': { content: "'𝐶'" }
      },
      '.cm-completionIcon-type': {
        '&:after': { content: "'𝑡'" }
      },
      '.cm-completionIcon-enum': {
        '&:after': { content: "'∪'" }
      },
      '.cm-completionIcon-property': {
        '&:after': { content: "'□'" }
      },
      '.cm-completionIcon-keyword': {
        '&:after': { content: "'🔑\uFE0E'" } // Disable emoji rendering
      },
      '.cm-completionIcon-namespace': {
        '&:after': { content: "'▢'" }
      },
      '.cm-completionIcon-text': {
        '&:after': {
          content: "'abc'",
          fontSize: '50%',
          verticalAlign: 'middle'
        }
      }
    })

    class FieldPos {
      constructor(field, line, from, to) {
        this.field = field
        this.line = line
        this.from = from
        this.to = to
      }
    }
    class FieldRange {
      constructor(field, from, to) {
        this.field = field
        this.from = from
        this.to = to
      }
      map(changes) {
        let from = changes.mapPos(this.from, -1, MapMode.TrackDel)
        let to = changes.mapPos(this.to, 1, MapMode.TrackDel)
        return from == null || to == null
          ? null
          : new FieldRange(this.field, from, to)
      }
    }
    class Snippet {
      constructor(lines, fieldPositions) {
        this.lines = lines
        this.fieldPositions = fieldPositions
      }
      instantiate(state, pos) {
        let text = [],
          lineStart = [pos]
        let lineObj = state.doc.lineAt(pos),
          baseIndent = /^\s*/.exec(lineObj.text)[0]
        for (let line of this.lines) {
          if (text.length) {
            let indent = baseIndent,
              tabs = /^\t*/.exec(line)[0].length
            for (let i = 0; i < tabs; i++) indent += state.facet(indentUnit)
            lineStart.push(pos + indent.length - tabs)
            line = indent + line.slice(tabs)
          }
          text.push(line)
          pos += line.length + 1
        }
        let ranges = this.fieldPositions.map(
          (pos) =>
            new FieldRange(
              pos.field,
              lineStart[pos.line] + pos.from,
              lineStart[pos.line] + pos.to
            )
        )
        return { text, ranges }
      }
      static parse(template) {
        let fields = []
        let lines = [],
          positions = [],
          m
        for (let line of template.split(/\r\n?|\n/)) {
          while ((m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line))) {
            let seq = m[1] ? +m[1] : null,
              name = m[2] || m[3] || '',
              found = -1
            for (let i = 0; i < fields.length; i++) {
              if (
                seq != null
                  ? fields[i].seq == seq
                  : name
                    ? fields[i].name == name
                    : false
              )
                found = i
            }
            if (found < 0) {
              let i = 0
              while (
                i < fields.length &&
                (seq == null || (fields[i].seq != null && fields[i].seq < seq))
              )
                i++
              fields.splice(i, 0, { seq, name })
              found = i
              for (let pos of positions) if (pos.field >= found) pos.field++
            }
            positions.push(
              new FieldPos(found, lines.length, m.index, m.index + name.length)
            )
            line =
              line.slice(0, m.index) + name + line.slice(m.index + m[0].length)
          }
          for (let esc; (esc = /\\([{}])/.exec(line)); ) {
            line =
              line.slice(0, esc.index) +
              esc[1] +
              line.slice(esc.index + esc[0].length)
            for (let pos of positions)
              if (pos.line == lines.length && pos.from > esc.index) {
                pos.from--
                pos.to--
              }
          }
          lines.push(line)
        }
        return new Snippet(lines, positions)
      }
    }
    let fieldMarker = /*@__PURE__*/ Decoration.widget({
      widget: /*@__PURE__*/ new (class extends WidgetType {
        toDOM() {
          let span = document.createElement('span')
          span.className = 'cm-snippetFieldPosition'
          return span
        }
        ignoreEvent() {
          return false
        }
      })()
    })
    let fieldRange = /*@__PURE__*/ Decoration.mark({ class: 'cm-snippetField' })
    class ActiveSnippet {
      constructor(ranges, active) {
        this.ranges = ranges
        this.active = active
        this.deco = Decoration.set(
          ranges.map((r) =>
            (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)
          )
        )
      }
      map(changes) {
        let ranges = []
        for (let r of this.ranges) {
          let mapped = r.map(changes)
          if (!mapped) return null
          ranges.push(mapped)
        }
        return new ActiveSnippet(ranges, this.active)
      }
      selectionInsideField(sel) {
        return sel.ranges.every((range) =>
          this.ranges.some(
            (r) =>
              r.field == this.active && r.from <= range.from && r.to >= range.to
          )
        )
      }
    }
    const setActive = /*@__PURE__*/ StateEffect.define({
      map(value, changes) {
        return value && value.map(changes)
      }
    })
    const moveToField = /*@__PURE__*/ StateEffect.define()
    const snippetState = /*@__PURE__*/ StateField.define({
      create() {
        return null
      },
      update(value, tr) {
        for (let effect of tr.effects) {
          if (effect.is(setActive)) return effect.value
          if (effect.is(moveToField) && value)
            return new ActiveSnippet(value.ranges, effect.value)
        }
        if (value && tr.docChanged) value = value.map(tr.changes)
        if (value && tr.selection && !value.selectionInsideField(tr.selection))
          value = null
        return value
      },
      provide: (f) =>
        EditorView.decorations.from(f, (val) =>
          val ? val.deco : Decoration.none
        )
    })
    function fieldSelection(ranges, field) {
      return dist_EditorSelection.create(
        ranges
          .filter((r) => r.field == field)
          .map((r) => dist_EditorSelection.range(r.from, r.to))
      )
    }
    /**
Convert a snippet template to a function that can
[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written
using syntax like this:

    "for (let ${index} = 0; ${index} < ${end}; ${index}++) {\n\t${}\n}"

Each `${}` placeholder (you may also use `#{}`) indicates a field
that the user can fill in. Its name, if any, will be the default
content for the field.

When the snippet is activated by calling the returned function,
the code is inserted at the given position. Newlines in the
template are indented by the indentation of the start line, plus
one [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after
the newline.

On activation, (all instances of) the first field are selected.
The user can move between fields with Tab and Shift-Tab as long as
the fields are active. Moving to the last field or moving the
cursor out of the current field deactivates the fields.

The order of fields defaults to textual order, but you can add
numbers to placeholders (`${1}` or `${1:defaultText}`) to provide
a custom order.

To include a literal `{` or `}` in your template, put a backslash
in front of it. This will be removed and the brace will not be
interpreted as indicating a placeholder.
*/
    function snippet(template) {
      let snippet = Snippet.parse(template)
      return (editor, completion, from, to) => {
        let { text, ranges } = snippet.instantiate(editor.state, from)
        let spec = {
          changes: { from, to, insert: Text.of(text) },
          scrollIntoView: true,
          annotations: completion ? pickedCompletion.of(completion) : undefined
        }
        if (ranges.length) spec.selection = fieldSelection(ranges, 0)
        if (ranges.length > 1) {
          let active = new ActiveSnippet(ranges, 0)
          let effects = (spec.effects = [setActive.of(active)])
          if (editor.state.field(snippetState, false) === undefined)
            effects.push(
              StateEffect.appendConfig.of([
                snippetState,
                addSnippetKeymap,
                snippetPointerHandler,
                autocomplete_dist_baseTheme
              ])
            )
        }
        editor.dispatch(editor.state.update(spec))
      }
    }
    function moveField(dir) {
      return ({ state, dispatch }) => {
        let active = state.field(snippetState, false)
        if (!active || (dir < 0 && active.active == 0)) return false
        let next = active.active + dir,
          last = dir > 0 && !active.ranges.some((r) => r.field == next + dir)
        dispatch(
          state.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(
              last ? null : new ActiveSnippet(active.ranges, next)
            ),
            scrollIntoView: true
          })
        )
        return true
      }
    }
    /**
A command that clears the active snippet, if any.
*/
    const clearSnippet = ({ state, dispatch }) => {
      let active = state.field(snippetState, false)
      if (!active) return false
      dispatch(state.update({ effects: setActive.of(null) }))
      return true
    }
    /**
Move to the next snippet field, if available.
*/
    const nextSnippetField = /*@__PURE__*/ moveField(1)
    /**
Move to the previous snippet field, if available.
*/
    const prevSnippetField = /*@__PURE__*/ moveField(-1)
    /**
Check if there is an active snippet with a next field for
`nextSnippetField` to move to.
*/
    function hasNextSnippetField(state) {
      let active = state.field(snippetState, false)
      return !!(
        active && active.ranges.some((r) => r.field == active.active + 1)
      )
    }
    /**
Returns true if there is an active snippet and a previous field
for `prevSnippetField` to move to.
*/
    function hasPrevSnippetField(state) {
      let active = state.field(snippetState, false)
      return !!(active && active.active > 0)
    }
    const defaultSnippetKeymap = [
      { key: 'Tab', run: nextSnippetField, shift: prevSnippetField },
      { key: 'Escape', run: clearSnippet }
    ]
    /**
A facet that can be used to configure the key bindings used by
snippets. The default binds Tab to
[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to
[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape
to [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).
*/
    const snippetKeymap = /*@__PURE__*/ Facet.define({
      combine(maps) {
        return maps.length ? maps[0] : defaultSnippetKeymap
      }
    })
    const addSnippetKeymap = /*@__PURE__*/ Prec.highest(
      /*@__PURE__*/ dist_keymap.compute([snippetKeymap], (state) =>
        state.facet(snippetKeymap)
      )
    )
    /**
Create a completion from a snippet. Returns an object with the
properties from `completion`, plus an `apply` function that
applies the snippet.
*/
    function snippetCompletion(template, completion) {
      return Object.assign(Object.assign({}, completion), {
        apply: snippet(template)
      })
    }
    const snippetPointerHandler = /*@__PURE__*/ EditorView.domEventHandlers({
      mousedown(event, view) {
        let active = view.state.field(snippetState, false),
          pos
        if (
          !active ||
          (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) ==
            null
        )
          return false
        let match = active.ranges.find((r) => r.from <= pos && r.to >= pos)
        if (!match || match.field == active.active) return false
        view.dispatch({
          selection: fieldSelection(active.ranges, match.field),
          effects: setActive.of(
            active.ranges.some((r) => r.field > match.field)
              ? new ActiveSnippet(active.ranges, match.field)
              : null
          ),
          scrollIntoView: true
        })
        return true
      }
    })

    function wordRE(wordChars) {
      let escaped = wordChars.replace(/[\]\-\\]/g, '\\$&')
      try {
        return new RegExp(`[\\p{Alphabetic}\\p{Number}_${escaped}]+`, 'ug')
      } catch (_a) {
        return new RegExp(`[\w${escaped}]`, 'g')
      }
    }
    function mapRE(re, f) {
      return new RegExp(f(re.source), re.unicode ? 'u' : '')
    }
    const wordCaches =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      Object.create(null)
    function wordCache(wordChars) {
      return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap())
    }
    function storeWords(doc, wordRE, result, seen, ignoreAt) {
      for (let lines = doc.iterLines(), pos = 0; !lines.next().done; ) {
        let { value } = lines,
          m
        wordRE.lastIndex = 0
        while ((m = wordRE.exec(value))) {
          if (!seen[m[0]] && pos + m.index != ignoreAt) {
            result.push({ type: 'text', label: m[0] })
            seen[m[0]] = true
            if (result.length >= 2000 /* C.MaxList */) return
          }
        }
        pos += value.length + 1
      }
    }
    function collectWords(doc, cache, wordRE, to, ignoreAt) {
      let big = doc.length >= 1000 /* C.MinCacheLen */
      let cached = big && cache.get(doc)
      if (cached) return cached
      let result = [],
        seen = Object.create(null)
      if (doc.children) {
        let pos = 0
        for (let ch of doc.children) {
          if (ch.length >= 1000 /* C.MinCacheLen */) {
            for (let c of collectWords(
              ch,
              cache,
              wordRE,
              to - pos,
              ignoreAt - pos
            )) {
              if (!seen[c.label]) {
                seen[c.label] = true
                result.push(c)
              }
            }
          } else {
            storeWords(ch, wordRE, result, seen, ignoreAt - pos)
          }
          pos += ch.length + 1
        }
      } else {
        storeWords(doc, wordRE, result, seen, ignoreAt)
      }
      if (big && result.length < 2000 /* C.MaxList */) cache.set(doc, result)
      return result
    }
    /**
A completion source that will scan the document for words (using a
[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and
return those as completions.
*/
    const completeAnyWord = (context) => {
      let wordChars = context.state
        .languageDataAt('wordChars', context.pos)
        .join('')
      let re = wordRE(wordChars)
      let token = context.matchBefore(mapRE(re, (s) => s + '$'))
      if (!token && !context.explicit) return null
      let from = token ? token.from : context.pos
      let options = collectWords(
        context.state.doc,
        wordCache(wordChars),
        re,
        50000 /* C.Range */,
        from
      )
      return { from, options, validFor: mapRE(re, (s) => '^' + s) }
    }

    const autocomplete_dist_defaults = {
      brackets: ['(', '[', '{', "'", '"'],
      before: ')]}:;>',
      stringPrefixes: []
    }
    const closeBracketEffect = /*@__PURE__*/ StateEffect.define({
      map(value, mapping) {
        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter)
        return mapped == null ? undefined : mapped
      }
    })
    const closedBracket = /*@__PURE__*/ new (class extends RangeValue {})()
    closedBracket.startSide = 1
    closedBracket.endSide = -1
    const bracketState = /*@__PURE__*/ StateField.define({
      create() {
        return dist_RangeSet.empty
      },
      update(value, tr) {
        value = value.map(tr.changes)
        if (tr.selection) {
          let line = tr.state.doc.lineAt(tr.selection.main.head)
          value = value.update({
            filter: (from) => from >= line.from && from <= line.to
          })
        }
        for (let effect of tr.effects)
          if (effect.is(closeBracketEffect))
            value = value.update({
              add: [closedBracket.range(effect.value, effect.value + 1)]
            })
        return value
      }
    })
    /**
Extension to enable bracket-closing behavior. When a closeable
bracket is typed, its closing bracket is immediately inserted
after the cursor. When closing a bracket directly in front of a
closing bracket inserted by the extension, the cursor moves over
that bracket.
*/
    function closeBrackets() {
      return [dist_inputHandler, bracketState]
    }
    const definedClosing = '()[]{}<>'
    function closing(ch) {
      for (let i = 0; i < definedClosing.length; i += 2)
        if (definedClosing.charCodeAt(i) == ch)
          return definedClosing.charAt(i + 1)
      return fromCodePoint(ch < 128 ? ch : ch + 1)
    }
    function dist_config(state, pos) {
      return (
        state.languageDataAt('closeBrackets', pos)[0] ||
        autocomplete_dist_defaults
      )
    }
    const android =
      typeof navigator == 'object' &&
      /*@__PURE__*/ /Android\b/.test(navigator.userAgent)
    const dist_inputHandler = /*@__PURE__*/ EditorView.inputHandler.of(
      (view, from, to, insert) => {
        if (
          (android ? view.composing : view.compositionStarted) ||
          view.state.readOnly
        )
          return false
        let sel = view.state.selection.main
        if (
          insert.length > 2 ||
          (insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1) ||
          from != sel.from ||
          to != sel.to
        )
          return false
        let tr = insertBracket(view.state, insert)
        if (!tr) return false
        view.dispatch(tr)
        return true
      }
    )
    /**
Command that implements deleting a pair of matching brackets when
the cursor is between them.
*/
    const deleteBracketPair = ({ state, dispatch }) => {
      if (state.readOnly) return false
      let conf = dist_config(state, state.selection.main.head)
      let tokens = conf.brackets || autocomplete_dist_defaults.brackets
      let dont = null,
        changes = state.changeByRange((range) => {
          if (range.empty) {
            let before = prevChar(state.doc, range.head)
            for (let token of tokens) {
              if (
                token == before &&
                nextChar(state.doc, range.head) ==
                  closing(codePointAt(token, 0))
              )
                return {
                  changes: {
                    from: range.head - token.length,
                    to: range.head + token.length
                  },
                  range: dist_EditorSelection.cursor(range.head - token.length)
                }
            }
          }
          return { range: (dont = range) }
        })
      if (!dont)
        dispatch(
          state.update(changes, {
            scrollIntoView: true,
            userEvent: 'delete.backward'
          })
        )
      return !dont
    }
    /**
Close-brackets related key bindings. Binds Backspace to
[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).
*/
    const closeBracketsKeymap = [{ key: 'Backspace', run: deleteBracketPair }]
    /**
Implements the extension's behavior on text insertion. If the
given string counts as a bracket in the language around the
selection, and replacing the selection with it requires custom
behavior (inserting a closing version or skipping past a
previously-closed bracket), this function returns a transaction
representing that custom behavior. (You only need this if you want
to programmatically insert brackets—the
[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will
take care of running this for user input.)
*/
    function insertBracket(state, bracket) {
      let conf = dist_config(state, state.selection.main.head)
      let tokens = conf.brackets || autocomplete_dist_defaults.brackets
      for (let tok of tokens) {
        let closed = closing(codePointAt(tok, 0))
        if (bracket == tok)
          return closed == tok
            ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)
            : handleOpen(
                state,
                tok,
                closed,
                conf.before || autocomplete_dist_defaults.before
              )
        if (
          bracket == closed &&
          closedBracketAt(state, state.selection.main.from)
        )
          return handleClose(state, tok, closed)
      }
      return null
    }
    function closedBracketAt(state, pos) {
      let found = false
      state.field(bracketState).between(0, state.doc.length, (from) => {
        if (from == pos) found = true
      })
      return found
    }
    function nextChar(doc, pos) {
      let next = doc.sliceString(pos, pos + 2)
      return next.slice(0, codePointSize(codePointAt(next, 0)))
    }
    function prevChar(doc, pos) {
      let prev = doc.sliceString(pos - 2, pos)
      return codePointSize(codePointAt(prev, 0)) == prev.length
        ? prev
        : prev.slice(1)
    }
    function handleOpen(state, open, close, closeBefore) {
      let dont = null,
        changes = state.changeByRange((range) => {
          if (!range.empty)
            return {
              changes: [
                { insert: open, from: range.from },
                { insert: close, from: range.to }
              ],
              effects: closeBracketEffect.of(range.to + open.length),
              range: dist_EditorSelection.range(
                range.anchor + open.length,
                range.head + open.length
              )
            }
          let next = nextChar(state.doc, range.head)
          if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
            return {
              changes: { insert: open + close, from: range.head },
              effects: closeBracketEffect.of(range.head + open.length),
              range: dist_EditorSelection.cursor(range.head + open.length)
            }
          return { range: (dont = range) }
        })
      return dont
        ? null
        : state.update(changes, {
            scrollIntoView: true,
            userEvent: 'input.type'
          })
    }
    function handleClose(state, _open, close) {
      let dont = null,
        changes = state.changeByRange((range) => {
          if (range.empty && nextChar(state.doc, range.head) == close)
            return {
              changes: {
                from: range.head,
                to: range.head + close.length,
                insert: close
              },
              range: dist_EditorSelection.cursor(range.head + close.length)
            }
          return (dont = { range })
        })
      return dont
        ? null
        : state.update(changes, {
            scrollIntoView: true,
            userEvent: 'input.type'
          })
    }
    // Handles cases where the open and close token are the same, and
    // possibly triple quotes (as in `"""abc"""`-style quoting).
    function handleSame(state, token, allowTriple, config) {
      let stringPrefixes =
        config.stringPrefixes || autocomplete_dist_defaults.stringPrefixes
      let dont = null,
        changes = state.changeByRange((range) => {
          if (!range.empty)
            return {
              changes: [
                { insert: token, from: range.from },
                { insert: token, from: range.to }
              ],
              effects: closeBracketEffect.of(range.to + token.length),
              range: dist_EditorSelection.range(
                range.anchor + token.length,
                range.head + token.length
              )
            }
          let pos = range.head,
            next = nextChar(state.doc, pos),
            start
          if (next == token) {
            if (nodeStart(state, pos)) {
              return {
                changes: { insert: token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: dist_EditorSelection.cursor(pos + token.length)
              }
            } else if (closedBracketAt(state, pos)) {
              let isTriple =
                allowTriple &&
                state.sliceDoc(pos, pos + token.length * 3) ==
                  token + token + token
              let content = isTriple ? token + token + token : token
              return {
                changes: {
                  from: pos,
                  to: pos + content.length,
                  insert: content
                },
                range: dist_EditorSelection.cursor(pos + content.length)
              }
            }
          } else if (
            allowTriple &&
            state.sliceDoc(pos - 2 * token.length, pos) == token + token &&
            (start = canStartStringAt(
              state,
              pos - 2 * token.length,
              stringPrefixes
            )) > -1 &&
            nodeStart(state, start)
          ) {
            return {
              changes: { insert: token + token + token + token, from: pos },
              effects: closeBracketEffect.of(pos + token.length),
              range: dist_EditorSelection.cursor(pos + token.length)
            }
          } else if (
            state.charCategorizer(pos)(next) != dist_CharCategory.Word
          ) {
            if (
              canStartStringAt(state, pos, stringPrefixes) > -1 &&
              !probablyInString(state, pos, token, stringPrefixes)
            )
              return {
                changes: { insert: token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: dist_EditorSelection.cursor(pos + token.length)
              }
          }
          return { range: (dont = range) }
        })
      return dont
        ? null
        : state.update(changes, {
            scrollIntoView: true,
            userEvent: 'input.type'
          })
    }
    function nodeStart(state, pos) {
      let tree = dist_syntaxTree(state).resolveInner(pos + 1)
      return tree.parent && tree.from == pos
    }
    function probablyInString(state, pos, quoteToken, prefixes) {
      let node = dist_syntaxTree(state).resolveInner(pos, -1)
      let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0)
      for (let i = 0; i < 5; i++) {
        let start = state.sliceDoc(
          node.from,
          Math.min(node.to, node.from + quoteToken.length + maxPrefix)
        )
        let quotePos = start.indexOf(quoteToken)
        if (
          !quotePos ||
          (quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1)
        ) {
          let first = node.firstChild
          while (
            first &&
            first.from == node.from &&
            first.to - first.from > quoteToken.length + quotePos
          ) {
            if (
              state.sliceDoc(first.to - quoteToken.length, first.to) ==
              quoteToken
            )
              return false
            first = first.firstChild
          }
          return true
        }
        let parent = node.to == pos && node.parent
        if (!parent) break
        node = parent
      }
      return false
    }
    function canStartStringAt(state, pos, prefixes) {
      let charCat = state.charCategorizer(pos)
      if (charCat(state.sliceDoc(pos - 1, pos)) != dist_CharCategory.Word)
        return pos
      for (let prefix of prefixes) {
        let start = pos - prefix.length
        if (
          state.sliceDoc(start, pos) == prefix &&
          charCat(state.sliceDoc(start - 1, start)) != dist_CharCategory.Word
        )
          return start
      }
      return -1
    }

    /**
Returns an extension that enables autocompletion.
*/
    function autocompletion(config = {}) {
      return [
        completionState,
        completionConfig.of(config),
        completionPlugin,
        completionKeymapExt,
        autocomplete_dist_baseTheme
      ]
    }
    /**
Basic keybindings for autocompletion.

 - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)
 - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)
 - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`
 - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)
*/
    const completionKeymap = [
      { key: 'Ctrl-Space', run: startCompletion },
      { key: 'Escape', run: closeCompletion },
      { key: 'ArrowDown', run: /*@__PURE__*/ moveCompletionSelection(true) },
      { key: 'ArrowUp', run: /*@__PURE__*/ moveCompletionSelection(false) },
      {
        key: 'PageDown',
        run: /*@__PURE__*/ moveCompletionSelection(true, 'page')
      },
      {
        key: 'PageUp',
        run: /*@__PURE__*/ moveCompletionSelection(false, 'page')
      },
      { key: 'Enter', run: acceptCompletion }
    ]
    const completionKeymapExt = /*@__PURE__*/ Prec.highest(
      /*@__PURE__*/ dist_keymap.computeN([completionConfig], (state) =>
        state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []
      )
    )
    /**
Get the current completion status. When completions are available,
this will return `"active"`. When completions are pending (in the
process of being queried), this returns `"pending"`. Otherwise, it
returns `null`.
*/
    function completionStatus(state) {
      let cState = state.field(completionState, false)
      return cState &&
        cState.active.some((a) => a.state == 1 /* State.Pending */)
        ? 'pending'
        : cState && cState.active.some((a) => a.state != 0 /* State.Inactive */)
          ? 'active'
          : null
    }
    const completionArrayCache = /*@__PURE__*/ new WeakMap()
    /**
Returns the available completions as an array.
*/
    function currentCompletions(state) {
      var _a
      let open =
        (_a = state.field(completionState, false)) === null || _a === void 0
          ? void 0
          : _a.open
      if (!open || open.disabled) return []
      let completions = completionArrayCache.get(open.options)
      if (!completions)
        completionArrayCache.set(
          open.options,
          (completions = open.options.map((o) => o.completion))
        )
      return completions
    }
    /**
Return the currently selected completion, if any.
*/
    function selectedCompletion(state) {
      var _a
      let open =
        (_a = state.field(completionState, false)) === null || _a === void 0
          ? void 0
          : _a.open
      return open && !open.disabled && open.selected >= 0
        ? open.options[open.selected].completion
        : null
    }
    /**
Returns the currently selected position in the active completion
list, or null if no completions are active.
*/
    function selectedCompletionIndex(state) {
      var _a
      let open =
        (_a = state.field(completionState, false)) === null || _a === void 0
          ? void 0
          : _a.open
      return open && !open.disabled && open.selected >= 0 ? open.selected : null
    }
    /**
Create an effect that can be attached to a transaction to change
the currently selected completion.
*/
    function setSelectedCompletion(index) {
      return setSelectedEffect.of(index)
    } // CONCATENATED MODULE: ./node_modules/@codemirror/lint/dist/index.js

    class SelectedDiagnostic {
      constructor(from, to, diagnostic) {
        this.from = from
        this.to = to
        this.diagnostic = diagnostic
      }
    }
    class LintState {
      constructor(diagnostics, panel, selected) {
        this.diagnostics = diagnostics
        this.panel = panel
        this.selected = selected
      }
      static init(diagnostics, panel, state) {
        // Filter the list of diagnostics for which to create markers
        let markedDiagnostics = diagnostics
        let diagnosticFilter = state.facet(lintConfig).markerFilter
        if (diagnosticFilter)
          markedDiagnostics = diagnosticFilter(markedDiagnostics)
        let ranges = Decoration.set(
          markedDiagnostics.map((d) => {
            // For zero-length ranges or ranges covering only a line break, create a widget
            return d.from == d.to ||
              (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)
              ? Decoration.widget({
                  widget: new DiagnosticWidget(d),
                  diagnostic: d
                }).range(d.from)
              : Decoration.mark({
                  attributes: {
                    class:
                      'cm-lintRange cm-lintRange-' +
                      d.severity +
                      (d.markClass ? ' ' + d.markClass : '')
                  },
                  diagnostic: d
                }).range(d.from, d.to)
          }),
          true
        )
        return new LintState(ranges, panel, findDiagnostic(ranges))
      }
    }
    function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
      let found = null
      diagnostics.between(after, 1e9, (from, to, { spec }) => {
        if (diagnostic && spec.diagnostic != diagnostic) return
        found = new SelectedDiagnostic(from, to, spec.diagnostic)
        return false
      })
      return found
    }
    function hideTooltip(tr, tooltip) {
      let line = tr.startState.doc.lineAt(tooltip.pos)
      return !!(
        tr.effects.some((e) => e.is(setDiagnosticsEffect)) ||
        tr.changes.touchesRange(line.from, line.to)
      )
    }
    function maybeEnableLint(state, effects) {
      return state.field(lintState, false)
        ? effects
        : effects.concat(StateEffect.appendConfig.of(lintExtensions))
    }
    /**
Returns a transaction spec which updates the current set of
diagnostics, and enables the lint extension if if wasn't already
active.
*/
    function setDiagnostics(state, diagnostics) {
      return {
        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
      }
    }
    /**
The state effect that updates the set of active diagnostics. Can
be useful when writing an extension that needs to track these.
*/
    const setDiagnosticsEffect = /*@__PURE__*/ StateEffect.define()
    const dist_togglePanel = /*@__PURE__*/ StateEffect.define()
    const movePanelSelection = /*@__PURE__*/ StateEffect.define()
    const lintState = /*@__PURE__*/ StateField.define({
      create() {
        return new LintState(Decoration.none, null, null)
      },
      update(value, tr) {
        if (tr.docChanged) {
          let mapped = value.diagnostics.map(tr.changes),
            selected = null
          if (value.selected) {
            let selPos = tr.changes.mapPos(value.selected.from, 1)
            selected =
              findDiagnostic(mapped, value.selected.diagnostic, selPos) ||
              findDiagnostic(mapped, null, selPos)
          }
          value = new LintState(mapped, value.panel, selected)
        }
        for (let effect of tr.effects) {
          if (effect.is(setDiagnosticsEffect)) {
            value = LintState.init(effect.value, value.panel, tr.state)
          } else if (effect.is(dist_togglePanel)) {
            value = new LintState(
              value.diagnostics,
              effect.value ? LintPanel.open : null,
              value.selected
            )
          } else if (effect.is(movePanelSelection)) {
            value = new LintState(value.diagnostics, value.panel, effect.value)
          }
        }
        return value
      },
      provide: (f) => [
        showPanel.from(f, (val) => val.panel),
        EditorView.decorations.from(f, (s) => s.diagnostics)
      ]
    })
    /**
Returns the number of active lint diagnostics in the given state.
*/
    function diagnosticCount(state) {
      let lint = state.field(lintState, false)
      return lint ? lint.diagnostics.size : 0
    }
    const activeMark = /*@__PURE__*/ Decoration.mark({
      class: 'cm-lintRange cm-lintRange-active'
    })
    function lintTooltip(view, pos, side) {
      let { diagnostics } = view.state.field(lintState)
      let found = [],
        stackStart = 2e8,
        stackEnd = 0
      diagnostics.between(
        pos - (side < 0 ? 1 : 0),
        pos + (side > 0 ? 1 : 0),
        (from, to, { spec }) => {
          if (
            pos >= from &&
            pos <= to &&
            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))
          ) {
            found.push(spec.diagnostic)
            stackStart = Math.min(from, stackStart)
            stackEnd = Math.max(to, stackEnd)
          }
        }
      )
      let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter
      if (diagnosticFilter) found = diagnosticFilter(found)
      if (!found.length) return null
      return {
        pos: stackStart,
        end: stackEnd,
        above: view.state.doc.lineAt(stackStart).to < stackEnd,
        create() {
          return { dom: diagnosticsTooltip(view, found) }
        }
      }
    }
    function diagnosticsTooltip(view, diagnostics) {
      return crelt(
        'ul',
        { class: 'cm-tooltip-lint' },
        diagnostics.map((d) => renderDiagnostic(view, d, false))
      )
    }
    /**
Command to open and focus the lint panel.
*/
    const openLintPanel = (view) => {
      let field = view.state.field(lintState, false)
      if (!field || !field.panel)
        view.dispatch({
          effects: maybeEnableLint(view.state, [dist_togglePanel.of(true)])
        })
      let panel = getPanel(view, LintPanel.open)
      if (panel) panel.dom.querySelector('.cm-panel-lint ul').focus()
      return true
    }
    /**
Command to close the lint panel, when open.
*/
    const closeLintPanel = (view) => {
      let field = view.state.field(lintState, false)
      if (!field || !field.panel) return false
      view.dispatch({ effects: dist_togglePanel.of(false) })
      return true
    }
    /**
Move the selection to the next diagnostic.
*/
    const nextDiagnostic = (view) => {
      let field = view.state.field(lintState, false)
      if (!field) return false
      let sel = view.state.selection.main,
        next = field.diagnostics.iter(sel.to + 1)
      if (!next.value) {
        next = field.diagnostics.iter(0)
        if (!next.value || (next.from == sel.from && next.to == sel.to))
          return false
      }
      view.dispatch({
        selection: { anchor: next.from, head: next.to },
        scrollIntoView: true
      })
      return true
    }
    /**
Move the selection to the previous diagnostic.
*/
    const previousDiagnostic = (view) => {
      let { state } = view,
        field = state.field(lintState, false)
      if (!field) return false
      let sel = state.selection.main
      let prevFrom, prevTo, lastFrom, lastTo
      field.diagnostics.between(0, state.doc.length, (from, to) => {
        if (to < sel.to && (prevFrom == null || prevFrom < from)) {
          prevFrom = from
          prevTo = to
        }
        if (lastFrom == null || from > lastFrom) {
          lastFrom = from
          lastTo = to
        }
      })
      if (lastFrom == null || (prevFrom == null && lastFrom == sel.from))
        return false
      view.dispatch({
        selection: {
          anchor:
            prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom,
          head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo
        },
        scrollIntoView: true
      })
      return true
    }
    /**
A set of default key bindings for the lint functionality.

- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)
- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)
*/
    const lintKeymap = [
      { key: 'Mod-Shift-m', run: openLintPanel, preventDefault: true },
      { key: 'F8', run: nextDiagnostic }
    ]
    const lintPlugin =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      ViewPlugin.fromClass(
        class {
          constructor(view) {
            this.view = view
            this.timeout = -1
            this.set = true
            let { delay } = view.state.facet(lintConfig)
            this.lintTime = Date.now() + delay
            this.run = this.run.bind(this)
            this.timeout = setTimeout(this.run, delay)
          }
          run() {
            let now = Date.now()
            if (now < this.lintTime - 10) {
              this.timeout = setTimeout(this.run, this.lintTime - now)
            } else {
              this.set = false
              let { state } = this.view,
                { sources } = state.facet(lintConfig)
              Promise.all(
                sources.map((source) => Promise.resolve(source(this.view)))
              ).then(
                (annotations) => {
                  let all = annotations.reduce((a, b) => a.concat(b))
                  if (this.view.state.doc == state.doc)
                    this.view.dispatch(setDiagnostics(this.view.state, all))
                },
                (error) => {
                  logException(this.view.state, error)
                }
              )
            }
          }
          update(update) {
            let config = update.state.facet(lintConfig)
            if (
              update.docChanged ||
              config != update.startState.facet(lintConfig) ||
              (config.needsRefresh && config.needsRefresh(update))
            ) {
              this.lintTime = Date.now() + config.delay
              if (!this.set) {
                this.set = true
                this.timeout = setTimeout(this.run, config.delay)
              }
            }
          }
          force() {
            if (this.set) {
              this.lintTime = Date.now()
              this.run()
            }
          }
          destroy() {
            clearTimeout(this.timeout)
          }
        }
      )
    const lintConfig = /*@__PURE__*/ Facet.define({
      combine(input) {
        return Object.assign(
          { sources: input.map((i) => i.source) },
          combineConfig(
            input.map((i) => i.config),
            {
              delay: 750,
              markerFilter: null,
              tooltipFilter: null,
              needsRefresh: null
            },
            {
              needsRefresh: (a, b) => (!a ? b : !b ? a : (u) => a(u) || b(u))
            }
          )
        )
      }
    })
    /**
Given a diagnostic source, this function returns an extension that
enables linting with that source. It will be called whenever the
editor is idle (after its content changed).
*/
    function linter(source, config = {}) {
      return [lintConfig.of({ source, config }), lintPlugin, lintExtensions]
    }
    /**
Forces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the
editor is idle to run right away.
*/
    function forceLinting(view) {
      let plugin = view.plugin(lintPlugin)
      if (plugin) plugin.force()
    }
    function assignKeys(actions) {
      let assigned = []
      if (actions)
        actions: for (let { name } of actions) {
          for (let i = 0; i < name.length; i++) {
            let ch = name[i]
            if (
              /[a-zA-Z]/.test(ch) &&
              !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())
            ) {
              assigned.push(ch)
              continue actions
            }
          }
          assigned.push('')
        }
      return assigned
    }
    function renderDiagnostic(view, diagnostic, inPanel) {
      var _a
      let keys = inPanel ? assignKeys(diagnostic.actions) : []
      return crelt(
        'li',
        { class: 'cm-diagnostic cm-diagnostic-' + diagnostic.severity },
        crelt(
          'span',
          { class: 'cm-diagnosticText' },
          diagnostic.renderMessage
            ? diagnostic.renderMessage()
            : diagnostic.message
        ),
        (_a = diagnostic.actions) === null || _a === void 0
          ? void 0
          : _a.map((action, i) => {
              let fired = false,
                click = (e) => {
                  e.preventDefault()
                  if (fired) return
                  fired = true
                  let found = findDiagnostic(
                    view.state.field(lintState).diagnostics,
                    diagnostic
                  )
                  if (found) action.apply(view, found.from, found.to)
                }
              let { name } = action,
                keyIndex = keys[i] ? name.indexOf(keys[i]) : -1
              let nameElt =
                keyIndex < 0
                  ? name
                  : [
                      name.slice(0, keyIndex),
                      crelt('u', name.slice(keyIndex, keyIndex + 1)),
                      name.slice(keyIndex + 1)
                    ]
              return crelt(
                'button',
                {
                  type: 'button',
                  class: 'cm-diagnosticAction',
                  onclick: click,
                  onmousedown: click,
                  'aria-label': ` Action: ${name}${
                    keyIndex < 0 ? '' : ` (access key "${keys[i]})"`
                  }.`
                },
                nameElt
              )
            }),
        diagnostic.source &&
          crelt('div', { class: 'cm-diagnosticSource' }, diagnostic.source)
      )
    }
    class DiagnosticWidget extends WidgetType {
      constructor(diagnostic) {
        super()
        this.diagnostic = diagnostic
      }
      eq(other) {
        return other.diagnostic == this.diagnostic
      }
      toDOM() {
        return crelt('span', {
          class: 'cm-lintPoint cm-lintPoint-' + this.diagnostic.severity
        })
      }
    }
    class PanelItem {
      constructor(view, diagnostic) {
        this.diagnostic = diagnostic
        this.id = 'item_' + Math.floor(Math.random() * 0xffffffff).toString(16)
        this.dom = renderDiagnostic(view, diagnostic, true)
        this.dom.id = this.id
        this.dom.setAttribute('role', 'option')
      }
    }
    class LintPanel {
      constructor(view) {
        this.view = view
        this.items = []
        let onkeydown = (event) => {
          if (event.keyCode == 27) {
            // Escape
            closeLintPanel(this.view)
            this.view.focus()
          } else if (event.keyCode == 38 || event.keyCode == 33) {
            // ArrowUp, PageUp
            this.moveSelection(
              (this.selectedIndex - 1 + this.items.length) % this.items.length
            )
          } else if (event.keyCode == 40 || event.keyCode == 34) {
            // ArrowDown, PageDown
            this.moveSelection((this.selectedIndex + 1) % this.items.length)
          } else if (event.keyCode == 36) {
            // Home
            this.moveSelection(0)
          } else if (event.keyCode == 35) {
            // End
            this.moveSelection(this.items.length - 1)
          } else if (event.keyCode == 13) {
            // Enter
            this.view.focus()
          } else if (
            event.keyCode >= 65 &&
            event.keyCode <= 90 &&
            this.selectedIndex >= 0
          ) {
            // A-Z
            let { diagnostic } = this.items[this.selectedIndex],
              keys = assignKeys(diagnostic.actions)
            for (let i = 0; i < keys.length; i++)
              if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                let found = findDiagnostic(
                  this.view.state.field(lintState).diagnostics,
                  diagnostic
                )
                if (found)
                  diagnostic.actions[i].apply(view, found.from, found.to)
              }
          } else {
            return
          }
          event.preventDefault()
        }
        let onclick = (event) => {
          for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].dom.contains(event.target)) this.moveSelection(i)
          }
        }
        this.list = crelt('ul', {
          tabIndex: 0,
          role: 'listbox',
          'aria-label': this.view.state.phrase('Diagnostics'),
          onkeydown,
          onclick
        })
        this.dom = crelt(
          'div',
          { class: 'cm-panel-lint' },
          this.list,
          crelt(
            'button',
            {
              type: 'button',
              name: 'close',
              'aria-label': this.view.state.phrase('close'),
              onclick: () => closeLintPanel(this.view)
            },
            '×'
          )
        )
        this.update()
      }
      get selectedIndex() {
        let selected = this.view.state.field(lintState).selected
        if (!selected) return -1
        for (let i = 0; i < this.items.length; i++)
          if (this.items[i].diagnostic == selected.diagnostic) return i
        return -1
      }
      update() {
        let { diagnostics, selected } = this.view.state.field(lintState)
        let i = 0,
          needsSync = false,
          newSelectedItem = null
        diagnostics.between(
          0,
          this.view.state.doc.length,
          (_start, _end, { spec }) => {
            let found = -1,
              item
            for (let j = i; j < this.items.length; j++)
              if (this.items[j].diagnostic == spec.diagnostic) {
                found = j
                break
              }
            if (found < 0) {
              item = new PanelItem(this.view, spec.diagnostic)
              this.items.splice(i, 0, item)
              needsSync = true
            } else {
              item = this.items[found]
              if (found > i) {
                this.items.splice(i, found - i)
                needsSync = true
              }
            }
            if (selected && item.diagnostic == selected.diagnostic) {
              if (!item.dom.hasAttribute('aria-selected')) {
                item.dom.setAttribute('aria-selected', 'true')
                newSelectedItem = item
              }
            } else if (item.dom.hasAttribute('aria-selected')) {
              item.dom.removeAttribute('aria-selected')
            }
            i++
          }
        )
        while (
          i < this.items.length &&
          !(this.items.length == 1 && this.items[0].diagnostic.from < 0)
        ) {
          needsSync = true
          this.items.pop()
        }
        if (this.items.length == 0) {
          this.items.push(
            new PanelItem(this.view, {
              from: -1,
              to: -1,
              severity: 'info',
              message: this.view.state.phrase('No diagnostics')
            })
          )
          needsSync = true
        }
        if (newSelectedItem) {
          this.list.setAttribute('aria-activedescendant', newSelectedItem.id)
          this.view.requestMeasure({
            key: this,
            read: () => ({
              sel: newSelectedItem.dom.getBoundingClientRect(),
              panel: this.list.getBoundingClientRect()
            }),
            write: ({ sel, panel }) => {
              let scaleY = panel.height / this.list.offsetHeight
              if (sel.top < panel.top)
                this.list.scrollTop -= (panel.top - sel.top) / scaleY
              else if (sel.bottom > panel.bottom)
                this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY
            }
          })
        } else if (this.selectedIndex < 0) {
          this.list.removeAttribute('aria-activedescendant')
        }
        if (needsSync) this.sync()
      }
      sync() {
        let domPos = this.list.firstChild
        function rm() {
          let prev = domPos
          domPos = prev.nextSibling
          prev.remove()
        }
        for (let item of this.items) {
          if (item.dom.parentNode == this.list) {
            while (domPos != item.dom) rm()
            domPos = item.dom.nextSibling
          } else {
            this.list.insertBefore(item.dom, domPos)
          }
        }
        while (domPos) rm()
      }
      moveSelection(selectedIndex) {
        if (this.selectedIndex < 0) return
        let field = this.view.state.field(lintState)
        let selection = findDiagnostic(
          field.diagnostics,
          this.items[selectedIndex].diagnostic
        )
        if (!selection) return
        this.view.dispatch({
          selection: { anchor: selection.from, head: selection.to },
          scrollIntoView: true,
          effects: movePanelSelection.of(selection)
        })
      }
      static open(view) {
        return new LintPanel(view)
      }
    }
    function svg(content, attrs = `viewBox="0 0 40 40"`) {
      return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(
        content
      )}</svg>')`
    }
    function underline(color) {
      return svg(
        `<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`,
        `width="6" height="3"`
      )
    }
    const lint_dist_baseTheme = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-diagnostic': {
        padding: '3px 6px 3px 8px',
        marginLeft: '-1px',
        display: 'block',
        whiteSpace: 'pre-wrap'
      },
      '.cm-diagnostic-error': { borderLeft: '5px solid #d11' },
      '.cm-diagnostic-warning': { borderLeft: '5px solid orange' },
      '.cm-diagnostic-info': { borderLeft: '5px solid #999' },
      '.cm-diagnostic-hint': { borderLeft: '5px solid #66d' },
      '.cm-diagnosticAction': {
        font: 'inherit',
        border: 'none',
        padding: '2px 4px',
        backgroundColor: '#444',
        color: 'white',
        borderRadius: '3px',
        marginLeft: '8px',
        cursor: 'pointer'
      },
      '.cm-diagnosticSource': {
        fontSize: '70%',
        opacity: 0.7
      },
      '.cm-lintRange': {
        backgroundPosition: 'left bottom',
        backgroundRepeat: 'repeat-x',
        paddingBottom: '0.7px'
      },
      '.cm-lintRange-error': {
        backgroundImage: /*@__PURE__*/ underline('#d11')
      },
      '.cm-lintRange-warning': {
        backgroundImage: /*@__PURE__*/ underline('orange')
      },
      '.cm-lintRange-info': {
        backgroundImage: /*@__PURE__*/ underline('#999')
      },
      '.cm-lintRange-hint': {
        backgroundImage: /*@__PURE__*/ underline('#66d')
      },
      '.cm-lintRange-active': { backgroundColor: '#ffdd9980' },
      '.cm-tooltip-lint': {
        padding: 0,
        margin: 0
      },
      '.cm-lintPoint': {
        position: 'relative',
        '&:after': {
          content: '""',
          position: 'absolute',
          bottom: 0,
          left: '-2px',
          borderLeft: '3px solid transparent',
          borderRight: '3px solid transparent',
          borderBottom: '4px solid #d11'
        }
      },
      '.cm-lintPoint-warning': {
        '&:after': { borderBottomColor: 'orange' }
      },
      '.cm-lintPoint-info': {
        '&:after': { borderBottomColor: '#999' }
      },
      '.cm-lintPoint-hint': {
        '&:after': { borderBottomColor: '#66d' }
      },
      '.cm-panel.cm-panel-lint': {
        position: 'relative',
        '& ul': {
          maxHeight: '100px',
          overflowY: 'auto',
          '& [aria-selected]': {
            backgroundColor: '#ddd',
            '& u': { textDecoration: 'underline' }
          },
          '&:focus [aria-selected]': {
            background_fallback: '#bdf',
            backgroundColor: 'Highlight',
            color_fallback: 'white',
            color: 'HighlightText'
          },
          '& u': { textDecoration: 'none' },
          padding: 0,
          margin: 0
        },
        '& [name=close]': {
          position: 'absolute',
          top: '0',
          right: '2px',
          background: 'inherit',
          border: 'none',
          font: 'inherit',
          padding: 0,
          margin: 0
        }
      }
    })
    function severityWeight(sev) {
      return sev == 'error' ? 4 : sev == 'warning' ? 3 : sev == 'info' ? 2 : 1
    }
    class LintGutterMarker extends GutterMarker {
      constructor(diagnostics) {
        super()
        this.diagnostics = diagnostics
        this.severity = diagnostics.reduce(
          (max, d) =>
            severityWeight(max) < severityWeight(d.severity) ? d.severity : max,
          'hint'
        )
      }
      toDOM(view) {
        let elt = document.createElement('div')
        elt.className = 'cm-lint-marker cm-lint-marker-' + this.severity
        let diagnostics = this.diagnostics
        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter
        if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics)
        if (diagnostics.length)
          elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics)
        return elt
      }
    }
    function trackHoverOn(view, marker) {
      let mousemove = (event) => {
        let rect = marker.getBoundingClientRect()
        if (
          event.clientX > rect.left - 10 /* Hover.Margin */ &&
          event.clientX < rect.right + 10 /* Hover.Margin */ &&
          event.clientY > rect.top - 10 /* Hover.Margin */ &&
          event.clientY < rect.bottom + 10 /* Hover.Margin */
        )
          return
        for (let target = event.target; target; target = target.parentNode) {
          if (
            target.nodeType == 1 &&
            target.classList.contains('cm-tooltip-lint')
          )
            return
        }
        window.removeEventListener('mousemove', mousemove)
        if (view.state.field(lintGutterTooltip))
          view.dispatch({ effects: setLintGutterTooltip.of(null) })
      }
      window.addEventListener('mousemove', mousemove)
    }
    function gutterMarkerMouseOver(view, marker, diagnostics) {
      function hovered() {
        let line = view.elementAtHeight(
          marker.getBoundingClientRect().top + 5 - view.documentTop
        )
        const linePos = view.coordsAtPos(line.from)
        if (linePos) {
          view.dispatch({
            effects: setLintGutterTooltip.of({
              pos: line.from,
              above: false,
              create() {
                return {
                  dom: diagnosticsTooltip(view, diagnostics),
                  getCoords: () => marker.getBoundingClientRect()
                }
              }
            })
          })
        }
        marker.onmouseout = marker.onmousemove = null
        trackHoverOn(view, marker)
      }
      let { hoverTime } = view.state.facet(lintGutterConfig)
      let hoverTimeout = setTimeout(hovered, hoverTime)
      marker.onmouseout = () => {
        clearTimeout(hoverTimeout)
        marker.onmouseout = marker.onmousemove = null
      }
      marker.onmousemove = () => {
        clearTimeout(hoverTimeout)
        hoverTimeout = setTimeout(hovered, hoverTime)
      }
    }
    function markersForDiagnostics(doc, diagnostics) {
      let byLine = Object.create(null)
      for (let diagnostic of diagnostics) {
        let line = doc.lineAt(diagnostic.from)
        ;(byLine[line.from] || (byLine[line.from] = [])).push(diagnostic)
      }
      let markers = []
      for (let line in byLine) {
        markers.push(new LintGutterMarker(byLine[line]).range(+line))
      }
      return dist_RangeSet.of(markers, true)
    }
    const lintGutterExtension = /*@__PURE__*/ gutter({
      class: 'cm-gutter-lint',
      markers: (view) => view.state.field(lintGutterMarkers)
    })
    const lintGutterMarkers = /*@__PURE__*/ StateField.define({
      create() {
        return dist_RangeSet.empty
      },
      update(markers, tr) {
        markers = markers.map(tr.changes)
        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter
        for (let effect of tr.effects) {
          if (effect.is(setDiagnosticsEffect)) {
            let diagnostics = effect.value
            if (diagnosticFilter)
              diagnostics = diagnosticFilter(diagnostics || [])
            markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0))
          }
        }
        return markers
      }
    })
    const setLintGutterTooltip = /*@__PURE__*/ StateEffect.define()
    const lintGutterTooltip = /*@__PURE__*/ StateField.define({
      create() {
        return null
      },
      update(tooltip, tr) {
        if (tooltip && tr.docChanged)
          tooltip = hideTooltip(tr, tooltip)
            ? null
            : Object.assign(Object.assign({}, tooltip), {
                pos: tr.changes.mapPos(tooltip.pos)
              })
        return tr.effects.reduce(
          (t, e) => (e.is(setLintGutterTooltip) ? e.value : t),
          tooltip
        )
      },
      provide: (field) => showTooltip.from(field)
    })
    const lintGutterTheme = /*@__PURE__*/ EditorView.baseTheme({
      '.cm-gutter-lint': {
        width: '1.4em',
        '& .cm-gutterElement': {
          padding: '.2em'
        }
      },
      '.cm-lint-marker': {
        width: '1em',
        height: '1em'
      },
      '.cm-lint-marker-info': {
        content: /*@__PURE__*/ svg(
          `<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`
        )
      },
      '.cm-lint-marker-warning': {
        content: /*@__PURE__*/ svg(
          `<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`
        )
      },
      '.cm-lint-marker-error': {
        content: /*@__PURE__*/ svg(
          `<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`
        )
      }
    })
    const lintExtensions = [
      lintState,
      /*@__PURE__*/ EditorView.decorations.compute([lintState], (state) => {
        let { selected, panel } = state.field(lintState)
        return !selected || !panel || selected.from == selected.to
          ? Decoration.none
          : Decoration.set([activeMark.range(selected.from, selected.to)])
      }),
      /*@__PURE__*/ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
      lint_dist_baseTheme
    ]
    const lintGutterConfig = /*@__PURE__*/ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          hoverTime: 300 /* Hover.Time */,
          markerFilter: null,
          tooltipFilter: null
        })
      }
    })
    /**
Returns an extension that installs a gutter showing markers for
each line that has diagnostics, which can be hovered over to see
the diagnostics.
*/
    function lintGutter(config = {}) {
      return [
        lintGutterConfig.of(config),
        lintGutterMarkers,
        lintGutterExtension,
        lintGutterTheme,
        lintGutterTooltip
      ]
    }
    /**
Iterate over the marked diagnostics for the given editor state,
calling `f` for each of them. Note that, if the document changed
since the diagnostics were created, the `Diagnostic` object will
hold the original outdated position, whereas the `to` and `from`
arguments hold the diagnostic's current position.
*/
    function forEachDiagnostic(state, f) {
      let lState = state.field(lintState, false)
      if (lState && lState.diagnostics.size)
        for (
          let iter = RangeSet.iter([lState.diagnostics]);
          iter.value;
          iter.next()
        )
          f(iter.value.spec.diagnostic, iter.from, iter.to)
    } // CONCATENATED MODULE: ./node_modules/codemirror/dist/index.js

    // (The superfluous function calls around the list of extensions work
    // around current limitations in tree-shaking software.)
    /**
This is an extension value that just pulls together a number of
extensions that you might want in a basic editor. It is meant as a
convenient helper to quickly set up CodeMirror without installing
and importing a lot of separate packages.

Specifically, it includes...

 - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)
 - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)
 - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)
 - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)
 - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)
 - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)
 - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)
 - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
 - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)
 - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)
 - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)
 - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)
 - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)
 - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)
 - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)
 - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)
 - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)
 - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)
 - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)

(You'll probably want to add some language package to your setup
too.)

This extension does not allow customization. The idea is that,
once you decide you want to configure your editor more precisely,
you take this package's source (which is just a bunch of imports
and an array literal), copy it into your own code, and adjust it
as desired.
*/
    const basicSetup = /*@__PURE__*/ (() => [
      lineNumbers(),
      highlightActiveLineGutter(),
      dist_highlightSpecialChars(),
      dist_history(),
      foldGutter(),
      dist_drawSelection(),
      dropCursor(),
      EditorState.allowMultipleSelections.of(true),
      indentOnInput(),
      dist_syntaxHighlighting(dist_defaultHighlightStyle, { fallback: true }),
      bracketMatching(),
      closeBrackets(),
      autocompletion(),
      rectangularSelection(),
      crosshairCursor(),
      highlightActiveLine(),
      highlightSelectionMatches(),
      dist_keymap.of([
        ...closeBracketsKeymap,
        ...dist_defaultKeymap,
        ...searchKeymap,
        ...dist_historyKeymap,
        ...foldKeymap,
        ...completionKeymap,
        ...lintKeymap
      ])
    ])()
    /**
A minimal set of extensions to create a functional editor. Only
includes [the default keymap](https://codemirror.net/6/docs/ref/#commands.defaultKeymap), [undo
history](https://codemirror.net/6/docs/ref/#commands.history), [special character
highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars), [custom selection
drawing](https://codemirror.net/6/docs/ref/#view.drawSelection), and [default highlight
style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle).
*/
    const minimalSetup =
      /*@__PURE__*/ /* unused pure expression or super */ null &&
      (() => [
        highlightSpecialChars(),
        history(),
        drawSelection(),
        syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
        keymap.of([...defaultKeymap, ...historyKeymap])
      ])() // CONCATENATED MODULE: ./node_modules/@lezer/lr/dist/index.js

    /**
A parse stack. These are used internally by the parser to track
parsing progress. They also provide some properties and methods
that external code such as a tokenizer can use to get information
about the parse state.
*/
    class Stack {
      /**
    @internal
    */
      constructor(
        /**
    The parse that this stack is part of @internal
    */
        p,
        /**
    Holds state, input pos, buffer index triplets for all but the
    top state @internal
    */
        stack,
        /**
    The current parse state @internal
    */
        state,
        // The position at which the next reduce should take place. This
        // can be less than `this.pos` when skipped expressions have been
        // added to the stack (which should be moved outside of the next
        // reduction)
        /**
    @internal
    */
        reducePos,
        /**
    The input position up to which this stack has parsed.
    */
        pos,
        /**
    The dynamic score of the stack, including dynamic precedence
    and error-recovery penalties
    @internal
    */
        score,
        // The output buffer. Holds (type, start, end, size) quads
        // representing nodes created by the parser, where `size` is
        // amount of buffer array entries covered by this node.
        /**
    @internal
    */
        buffer,
        // The base offset of the buffer. When stacks are split, the split
        // instance shared the buffer history with its parent up to
        // `bufferBase`, which is the absolute offset (including the
        // offset of previous splits) into the buffer at which this stack
        // starts writing.
        /**
    @internal
    */
        bufferBase,
        /**
    @internal
    */
        curContext,
        /**
    @internal
    */
        lookAhead = 0,
        // A parent stack from which this was split off, if any. This is
        // set up so that it always points to a stack that has some
        // additional buffer content, never to a stack with an equal
        // `bufferBase`.
        /**
    @internal
    */
        parent
      ) {
        this.p = p
        this.stack = stack
        this.state = state
        this.reducePos = reducePos
        this.pos = pos
        this.score = score
        this.buffer = buffer
        this.bufferBase = bufferBase
        this.curContext = curContext
        this.lookAhead = lookAhead
        this.parent = parent
      }
      /**
    @internal
    */
      toString() {
        return `[${this.stack
          .filter((_, i) => i % 3 == 0)
          .concat(this.state)}]@${this.pos}${
          this.score ? '!' + this.score : ''
        }`
      }
      // Start an empty stack
      /**
    @internal
    */
      static start(p, state, pos = 0) {
        let cx = p.parser.context
        return new Stack(
          p,
          [],
          state,
          pos,
          pos,
          0,
          [],
          0,
          cx ? new StackContext(cx, cx.start) : null,
          0,
          null
        )
      }
      /**
    The stack's current [context](#lr.ContextTracker) value, if
    any. Its type will depend on the context tracker's type
    parameter, or it will be `null` if there is no context
    tracker.
    */
      get context() {
        return this.curContext ? this.curContext.context : null
      }
      // Push a state onto the stack, tracking its start position as well
      // as the buffer base at that point.
      /**
    @internal
    */
      pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length)
        this.state = state
      }
      // Apply a reduce action
      /**
    @internal
    */
      reduce(action) {
        var _a
        let depth = action >> 19 /* Action.ReduceDepthShift */,
          type = action & 65535 /* Action.ValueMask */
        let { parser } = this.p
        let dPrec = parser.dynamicPrecedence(type)
        if (dPrec) this.score += dPrec
        if (depth == 0) {
          this.pushState(parser.getGoto(this.state, type, true), this.reducePos)
          // Zero-depth reductions are a special case—they add stuff to
          // the stack without popping anything off.
          if (type < parser.minRepeatTerm)
            this.storeNode(type, this.reducePos, this.reducePos, 4, true)
          this.reduceContext(type, this.reducePos)
          return
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base =
          this.stack.length -
          (depth - 1) * 3 -
          (action & 262144 /* Action.StayFlag */ ? 6 : 0)
        let start = base ? this.stack[base - 2] : this.p.ranges[0].from,
          size = this.reducePos - start
        // This is a kludge to try and detect overly deep left-associative
        // trees, which will not increase the parse stack depth and thus
        // won't be caught by the regular stack-depth limit check.
        if (
          size >= 2000 /* Recover.MinBigReduction */ &&
          !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0
            ? void 0
            : _a.isAnonymous)
        ) {
          if (start == this.p.lastBigReductionStart) {
            this.p.bigReductionCount++
            this.p.lastBigReductionSize = size
          } else if (this.p.lastBigReductionSize < size) {
            this.p.bigReductionCount = 1
            this.p.lastBigReductionStart = start
            this.p.lastBigReductionSize = size
          }
        }
        let bufferBase = base ? this.stack[base - 1] : 0,
          count = this.bufferBase + this.buffer.length - bufferBase
        // Store normal terms or `R -> R R` repeat reductions
        if (
          type < parser.minRepeatTerm ||
          action & 131072 /* Action.RepeatFlag */
        ) {
          let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */)
            ? this.pos
            : this.reducePos
          this.storeNode(type, start, pos, count + 4, true)
        }
        if (action & 262144 /* Action.StayFlag */) {
          this.state = this.stack[base]
        } else {
          let baseStateID = this.stack[base - 3]
          this.state = parser.getGoto(baseStateID, type, true)
        }
        while (this.stack.length > base) this.stack.pop()
        this.reduceContext(type, start)
      }
      // Shift a value into the buffer
      /**
    @internal
    */
      storeNode(term, start, end, size = 4, isReduce = false) {
        if (
          term == 0 /* Term.Err */ &&
          (!this.stack.length ||
            this.stack[this.stack.length - 1] <
              this.buffer.length + this.bufferBase)
        ) {
          // Try to omit/merge adjacent error nodes
          let cur = this,
            top = this.buffer.length
          if (top == 0 && cur.parent) {
            top = cur.bufferBase - cur.parent.bufferBase
            cur = cur.parent
          }
          if (
            top > 0 &&
            cur.buffer[top - 4] == 0 /* Term.Err */ &&
            cur.buffer[top - 1] > -1
          ) {
            if (start == end) return
            if (cur.buffer[top - 2] >= start) {
              cur.buffer[top - 2] = end
              return
            }
          }
        }
        if (!isReduce || this.pos == end) {
          // Simple case, just append
          this.buffer.push(term, start, end, size)
        } else {
          // There may be skipped nodes that have to be moved forward
          let index = this.buffer.length
          if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */)
            while (index > 0 && this.buffer[index - 2] > end) {
              // Move this record forward
              this.buffer[index] = this.buffer[index - 4]
              this.buffer[index + 1] = this.buffer[index - 3]
              this.buffer[index + 2] = this.buffer[index - 2]
              this.buffer[index + 3] = this.buffer[index - 1]
              index -= 4
              if (size > 4) size -= 4
            }
          this.buffer[index] = term
          this.buffer[index + 1] = start
          this.buffer[index + 2] = end
          this.buffer[index + 3] = size
        }
      }
      // Apply a shift action
      /**
    @internal
    */
      shift(action, type, start, end) {
        if (action & 131072 /* Action.GotoFlag */) {
          this.pushState(action & 65535 /* Action.ValueMask */, this.pos)
        } else if ((action & 262144) /* Action.StayFlag */ == 0) {
          // Regular shift
          let nextState = action,
            { parser } = this.p
          if (end > this.pos || type <= parser.maxNode) {
            this.pos = end
            if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))
              this.reducePos = end
          }
          this.pushState(nextState, start)
          this.shiftContext(type, start)
          if (type <= parser.maxNode) this.buffer.push(type, start, end, 4)
        } else {
          // Shift-and-stay, which means this is a skipped token
          this.pos = end
          this.shiftContext(type, start)
          if (type <= this.p.parser.maxNode)
            this.buffer.push(type, start, end, 4)
        }
      }
      // Apply an action
      /**
    @internal
    */
      apply(action, next, nextStart, nextEnd) {
        if (action & 65536 /* Action.ReduceFlag */) this.reduce(action)
        else this.shift(action, next, nextStart, nextEnd)
      }
      // Add a prebuilt (reused) node into the buffer.
      /**
    @internal
    */
      useNode(value, next) {
        let index = this.p.reused.length - 1
        if (index < 0 || this.p.reused[index] != value) {
          this.p.reused.push(value)
          index++
        }
        let start = this.pos
        this.reducePos = this.pos = start + value.length
        this.pushState(next, start)
        this.buffer.push(
          index,
          start,
          this.reducePos,
          -1 /* size == -1 means this is a reused value */
        )
        if (this.curContext)
          this.updateContext(
            this.curContext.tracker.reuse(
              this.curContext.context,
              value,
              this,
              this.p.stream.reset(this.pos - value.length)
            )
          )
      }
      // Split the stack. Due to the buffer sharing and the fact
      // that `this.stack` tends to stay quite shallow, this isn't very
      // expensive.
      /**
    @internal
    */
      split() {
        let parent = this
        let off = parent.buffer.length
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4
        let buffer = parent.buffer.slice(off),
          base = parent.bufferBase + off
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase) parent = parent.parent
        return new Stack(
          this.p,
          this.stack.slice(),
          this.state,
          this.reducePos,
          this.pos,
          this.score,
          buffer,
          base,
          this.curContext,
          this.lookAhead,
          parent
        )
      }
      // Try to recover from an error by 'deleting' (ignoring) one token.
      /**
    @internal
    */
      recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode
        if (isNode) this.storeNode(next, this.pos, nextEnd, 4)
        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4)
        this.pos = this.reducePos = nextEnd
        this.score -= 190 /* Recover.Delete */
      }
      /**
    Check if the given term would be able to be shifted (optionally
    after some reductions) on this stack. This can be useful for
    external tokenizers that want to make sure they only provide a
    given token when it applies.
    */
      canShift(term) {
        for (let sim = new SimulatedStack(this); ; ) {
          let action =
            this.p.parser.stateSlot(
              sim.state,
              4 /* ParseState.DefaultReduce */
            ) || this.p.parser.hasAction(sim.state, term)
          if (action == 0) return false
          if ((action & 65536) /* Action.ReduceFlag */ == 0) return true
          sim.reduce(action)
        }
      }
      // Apply up to Recover.MaxNext recovery actions that conceptually
      // inserts some missing token or rule.
      /**
    @internal
    */
      recoverByInsert(next) {
        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)
          return []
        let nextStates = this.p.parser.nextStates(this.state)
        if (
          nextStates.length > 4 /* Recover.MaxNext */ << 1 ||
          this.stack.length >= 120 /* Recover.DampenInsertStackDepth */
        ) {
          let best = []
          for (let i = 0, s; i < nextStates.length; i += 2) {
            if (
              (s = nextStates[i + 1]) != this.state &&
              this.p.parser.hasAction(s, next)
            )
              best.push(nextStates[i], s)
          }
          if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)
            for (
              let i = 0;
              best.length < 4 /* Recover.MaxNext */ << 1 &&
              i < nextStates.length;
              i += 2
            ) {
              let s = nextStates[i + 1]
              if (!best.some((v, i) => i & 1 && v == s))
                best.push(nextStates[i], s)
            }
          nextStates = best
        }
        let result = []
        for (
          let i = 0;
          i < nextStates.length && result.length < 4 /* Recover.MaxNext */;
          i += 2
        ) {
          let s = nextStates[i + 1]
          if (s == this.state) continue
          let stack = this.split()
          stack.pushState(s, this.pos)
          stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true)
          stack.shiftContext(nextStates[i], this.pos)
          stack.reducePos = this.pos
          stack.score -= 200 /* Recover.Insert */
          result.push(stack)
        }
        return result
      }
      // Force a reduce, if possible. Return false if that can't
      // be done.
      /**
    @internal
    */
      forceReduce() {
        let { parser } = this.p
        let reduce = parser.stateSlot(
          this.state,
          5 /* ParseState.ForcedReduce */
        )
        if ((reduce & 65536) /* Action.ReduceFlag */ == 0) return false
        if (!parser.validAction(this.state, reduce)) {
          let depth = reduce >> 19 /* Action.ReduceDepthShift */,
            term = reduce & 65535 /* Action.ValueMask */
          let target = this.stack.length - depth * 3
          if (
            target < 0 ||
            parser.getGoto(this.stack[target], term, false) < 0
          ) {
            let backup = this.findForcedReduction()
            if (backup == null) return false
            reduce = backup
          }
          this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true)
          this.score -= 100 /* Recover.Reduce */
        }
        this.reducePos = this.pos
        this.reduce(reduce)
        return true
      }
      /**
    Try to scan through the automaton to find some kind of reduction
    that can be applied. Used when the regular ForcedReduce field
    isn't a valid action. @internal
    */
      findForcedReduction() {
        let { parser } = this.p,
          seen = []
        let explore = (state, depth) => {
          if (seen.includes(state)) return
          seen.push(state)
          return parser.allActions(state, (action) => {
            if (
              action &
              (262144 /* Action.StayFlag */ | 131072) /* Action.GotoFlag */
            );
            else if (action & 65536 /* Action.ReduceFlag */) {
              let rDepth = (action >> 19) /* Action.ReduceDepthShift */ - depth
              if (rDepth > 1) {
                let term = action & 65535 /* Action.ValueMask */,
                  target = this.stack.length - rDepth * 3
                if (
                  target >= 0 &&
                  parser.getGoto(this.stack[target], term, false) >= 0
                )
                  return (
                    (rDepth << 19) /* Action.ReduceDepthShift */ |
                    65536 /* Action.ReduceFlag */ |
                    term
                  )
              }
            } else {
              let found = explore(action, depth + 1)
              if (found != null) return found
            }
          })
        }
        return explore(this.state, 0)
      }
      /**
    @internal
    */
      forceAll() {
        while (
          !this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)
        ) {
          if (!this.forceReduce()) {
            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true)
            break
          }
        }
        return this
      }
      /**
    Check whether this state has no further actions (assumed to be a direct descendant of the
    top state, since any other states must be able to continue
    somehow). @internal
    */
      get deadEnd() {
        if (this.stack.length != 3) return false
        let { parser } = this.p
        return (
          parser.data[
            parser.stateSlot(this.state, 1 /* ParseState.Actions */)
          ] == 65535 /* Seq.End */ &&
          !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */)
        )
      }
      /**
    Restart the stack (put it back in its start state). Only safe
    when this.stack.length == 3 (state is directly below the top
    state). @internal
    */
      restart() {
        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true)
        this.state = this.stack[0]
        this.stack.length = 0
      }
      /**
    @internal
    */
      sameState(other) {
        if (
          this.state != other.state ||
          this.stack.length != other.stack.length
        )
          return false
        for (let i = 0; i < this.stack.length; i += 3)
          if (this.stack[i] != other.stack[i]) return false
        return true
      }
      /**
    Get the parser used by this stack.
    */
      get parser() {
        return this.p.parser
      }
      /**
    Test whether a given dialect (by numeric ID, as exported from
    the terms file) is enabled.
    */
      dialectEnabled(dialectID) {
        return this.p.parser.dialect.flags[dialectID]
      }
      shiftContext(term, start) {
        if (this.curContext)
          this.updateContext(
            this.curContext.tracker.shift(
              this.curContext.context,
              term,
              this,
              this.p.stream.reset(start)
            )
          )
      }
      reduceContext(term, start) {
        if (this.curContext)
          this.updateContext(
            this.curContext.tracker.reduce(
              this.curContext.context,
              term,
              this,
              this.p.stream.reset(start)
            )
          )
      }
      /**
    @internal
    */
      emitContext() {
        let last = this.buffer.length - 1
        if (last < 0 || this.buffer[last] != -3)
          this.buffer.push(this.curContext.hash, this.pos, this.pos, -3)
      }
      /**
    @internal
    */
      emitLookAhead() {
        let last = this.buffer.length - 1
        if (last < 0 || this.buffer[last] != -4)
          this.buffer.push(this.lookAhead, this.pos, this.pos, -4)
      }
      updateContext(context) {
        if (context != this.curContext.context) {
          let newCx = new StackContext(this.curContext.tracker, context)
          if (newCx.hash != this.curContext.hash) this.emitContext()
          this.curContext = newCx
        }
      }
      /**
    @internal
    */
      setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
          this.emitLookAhead()
          this.lookAhead = lookAhead
        }
      }
      /**
    @internal
    */
      close() {
        if (this.curContext && this.curContext.tracker.strict)
          this.emitContext()
        if (this.lookAhead > 0) this.emitLookAhead()
      }
    }
    class StackContext {
      constructor(tracker, context) {
        this.tracker = tracker
        this.context = context
        this.hash = tracker.strict ? tracker.hash(context) : 0
      }
    }
    // Used to cheaply run some reductions to scan ahead without mutating
    // an entire stack
    class SimulatedStack {
      constructor(start) {
        this.start = start
        this.state = start.state
        this.stack = start.stack
        this.base = this.stack.length
      }
      reduce(action) {
        let term = action & 65535 /* Action.ValueMask */,
          depth = action >> 19 /* Action.ReduceDepthShift */
        if (depth == 0) {
          if (this.stack == this.start.stack) this.stack = this.stack.slice()
          this.stack.push(this.state, 0, 0)
          this.base += 3
        } else {
          this.base -= (depth - 1) * 3
        }
        let goto = this.start.p.parser.getGoto(
          this.stack[this.base - 3],
          term,
          true
        )
        this.state = goto
      }
    }
    // This is given to `Tree.build` to build a buffer, and encapsulates
    // the parent-stack-walking necessary to read the nodes.
    class StackBufferCursor {
      constructor(stack, pos, index) {
        this.stack = stack
        this.pos = pos
        this.index = index
        this.buffer = stack.buffer
        if (this.index == 0) this.maybeNext()
      }
      static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase)
      }
      maybeNext() {
        let next = this.stack.parent
        if (next != null) {
          this.index = this.stack.bufferBase - next.bufferBase
          this.stack = next
          this.buffer = next.buffer
        }
      }
      get id() {
        return this.buffer[this.index - 4]
      }
      get start() {
        return this.buffer[this.index - 3]
      }
      get end() {
        return this.buffer[this.index - 2]
      }
      get size() {
        return this.buffer[this.index - 1]
      }
      next() {
        this.index -= 4
        this.pos -= 4
        if (this.index == 0) this.maybeNext()
      }
      fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index)
      }
    }

    // See lezer-generator/src/encode.ts for comments about the encoding
    // used here
    function decodeArray(input, Type = Uint16Array) {
      if (typeof input != 'string') return input
      let array = null
      for (let pos = 0, out = 0; pos < input.length; ) {
        let value = 0
        for (;;) {
          let next = input.charCodeAt(pos++),
            stop = false
          if (next == 126 /* Encode.BigValCode */) {
            value = 65535 /* Encode.BigVal */
            break
          }
          if (next >= 92 /* Encode.Gap2 */) next--
          if (next >= 34 /* Encode.Gap1 */) next--
          let digit = next - 32 /* Encode.Start */
          if (digit >= 46 /* Encode.Base */) {
            digit -= 46 /* Encode.Base */
            stop = true
          }
          value += digit
          if (stop) break
          value *= 46 /* Encode.Base */
        }
        if (array) array[out++] = value
        else array = new Type(value)
      }
      return array
    }

    class CachedToken {
      constructor() {
        this.start = -1
        this.value = -1
        this.end = -1
        this.extended = -1
        this.lookAhead = 0
        this.mask = 0
        this.context = 0
      }
    }
    const nullToken = new CachedToken()
    /**
[Tokenizers](#lr.ExternalTokenizer) interact with the input
through this interface. It presents the input as a stream of
characters, tracking lookahead and hiding the complexity of
[ranges](#common.Parser.parse^ranges) from tokenizer code.
*/
    class InputStream {
      /**
    @internal
    */
      constructor(
        /**
    @internal
    */
        input,
        /**
    @internal
    */
        ranges
      ) {
        this.input = input
        this.ranges = ranges
        /**
        @internal
        */
        this.chunk = ''
        /**
        @internal
        */
        this.chunkOff = 0
        /**
        Backup chunk
        */
        this.chunk2 = ''
        this.chunk2Pos = 0
        /**
        The character code of the next code unit in the input, or -1
        when the stream is at the end of the input.
        */
        this.next = -1
        /**
        @internal
        */
        this.token = nullToken
        this.rangeIndex = 0
        this.pos = this.chunkPos = ranges[0].from
        this.range = ranges[0]
        this.end = ranges[ranges.length - 1].to
        this.readNext()
      }
      /**
    @internal
    */
      resolveOffset(offset, assoc) {
        let range = this.range,
          index = this.rangeIndex
        let pos = this.pos + offset
        while (pos < range.from) {
          if (!index) return null
          let next = this.ranges[--index]
          pos -= range.from - next.to
          range = next
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
          if (index == this.ranges.length - 1) return null
          let next = this.ranges[++index]
          pos += next.from - range.to
          range = next
        }
        return pos
      }
      /**
    @internal
    */
      clipPos(pos) {
        if (pos >= this.range.from && pos < this.range.to) return pos
        for (let range of this.ranges)
          if (range.to > pos) return Math.max(pos, range.from)
        return this.end
      }
      /**
    Look at a code unit near the stream position. `.peek(0)` equals
    `.next`, `.peek(-1)` gives you the previous character, and so
    on.
    
    Note that looking around during tokenizing creates dependencies
    on potentially far-away content, which may reduce the
    effectiveness incremental parsing—when looking forward—or even
    cause invalid reparses when looking backward more than 25 code
    units, since the library does not track lookbehind.
    */
      peek(offset) {
        let idx = this.chunkOff + offset,
          pos,
          result
        if (idx >= 0 && idx < this.chunk.length) {
          pos = this.pos + offset
          result = this.chunk.charCodeAt(idx)
        } else {
          let resolved = this.resolveOffset(offset, 1)
          if (resolved == null) return -1
          pos = resolved
          if (
            pos >= this.chunk2Pos &&
            pos < this.chunk2Pos + this.chunk2.length
          ) {
            result = this.chunk2.charCodeAt(pos - this.chunk2Pos)
          } else {
            let i = this.rangeIndex,
              range = this.range
            while (range.to <= pos) range = this.ranges[++i]
            this.chunk2 = this.input.chunk((this.chunk2Pos = pos))
            if (pos + this.chunk2.length > range.to)
              this.chunk2 = this.chunk2.slice(0, range.to - pos)
            result = this.chunk2.charCodeAt(0)
          }
        }
        if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1
        return result
      }
      /**
    Accept a token. By default, the end of the token is set to the
    current stream position, but you can pass an offset (relative to
    the stream position) to change that.
    */
      acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos
        if (end == null || end < this.token.start)
          throw new RangeError('Token end out of bounds')
        this.token.value = token
        this.token.end = end
      }
      getChunk() {
        if (
          this.pos >= this.chunk2Pos &&
          this.pos < this.chunk2Pos + this.chunk2.length
        ) {
          let { chunk, chunkPos } = this
          this.chunk = this.chunk2
          this.chunkPos = this.chunk2Pos
          this.chunk2 = chunk
          this.chunk2Pos = chunkPos
          this.chunkOff = this.pos - this.chunkPos
        } else {
          this.chunk2 = this.chunk
          this.chunk2Pos = this.chunkPos
          let nextChunk = this.input.chunk(this.pos)
          let end = this.pos + nextChunk.length
          this.chunk =
            end > this.range.to
              ? nextChunk.slice(0, this.range.to - this.pos)
              : nextChunk
          this.chunkPos = this.pos
          this.chunkOff = 0
        }
      }
      readNext() {
        if (this.chunkOff >= this.chunk.length) {
          this.getChunk()
          if (this.chunkOff == this.chunk.length) return (this.next = -1)
        }
        return (this.next = this.chunk.charCodeAt(this.chunkOff))
      }
      /**
    Move the stream forward N (defaults to 1) code units. Returns
    the new value of [`next`](#lr.InputStream.next).
    */
      advance(n = 1) {
        this.chunkOff += n
        while (this.pos + n >= this.range.to) {
          if (this.rangeIndex == this.ranges.length - 1) return this.setDone()
          n -= this.range.to - this.pos
          this.range = this.ranges[++this.rangeIndex]
          this.pos = this.range.from
        }
        this.pos += n
        if (this.pos >= this.token.lookAhead)
          this.token.lookAhead = this.pos + 1
        return this.readNext()
      }
      setDone() {
        this.pos = this.chunkPos = this.end
        this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]
        this.chunk = ''
        return (this.next = -1)
      }
      /**
    @internal
    */
      reset(pos, token) {
        if (token) {
          this.token = token
          token.start = pos
          token.lookAhead = pos + 1
          token.value = token.extended = -1
        } else {
          this.token = nullToken
        }
        if (this.pos != pos) {
          this.pos = pos
          if (pos == this.end) {
            this.setDone()
            return this
          }
          while (pos < this.range.from)
            this.range = this.ranges[--this.rangeIndex]
          while (pos >= this.range.to)
            this.range = this.ranges[++this.rangeIndex]
          if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
            this.chunkOff = pos - this.chunkPos
          } else {
            this.chunk = ''
            this.chunkOff = 0
          }
          this.readNext()
        }
        return this
      }
      /**
    @internal
    */
      read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
          return this.chunk.slice(from - this.chunkPos, to - this.chunkPos)
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
          return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos)
        if (from >= this.range.from && to <= this.range.to)
          return this.input.read(from, to)
        let result = ''
        for (let r of this.ranges) {
          if (r.from >= to) break
          if (r.to > from)
            result += this.input.read(
              Math.max(r.from, from),
              Math.min(r.to, to)
            )
        }
        return result
      }
    }
    /**
@internal
*/
    class TokenGroup {
      constructor(data, id) {
        this.data = data
        this.id = id
      }
      token(input, stack) {
        let { parser } = stack.p
        dist_readToken(
          this.data,
          input,
          stack,
          this.id,
          parser.data,
          parser.tokenPrecTable
        )
      }
    }
    TokenGroup.prototype.contextual =
      TokenGroup.prototype.fallback =
      TokenGroup.prototype.extend =
        false
    /**
@hide
*/
    class LocalTokenGroup {
      constructor(data, precTable, elseToken) {
        this.precTable = precTable
        this.elseToken = elseToken
        this.data = typeof data == 'string' ? decodeArray(data) : data
      }
      token(input, stack) {
        let start = input.pos,
          skipped = 0
        for (;;) {
          let atEof = input.next < 0,
            nextPos = input.resolveOffset(1, 1)
          dist_readToken(this.data, input, stack, 0, this.data, this.precTable)
          if (input.token.value > -1) break
          if (this.elseToken == null) return
          if (!atEof) skipped++
          if (nextPos == null) break
          input.reset(nextPos, input.token)
        }
        if (skipped) {
          input.reset(start, input.token)
          input.acceptToken(this.elseToken, skipped)
        }
      }
    }
    LocalTokenGroup.prototype.contextual =
      TokenGroup.prototype.fallback =
      TokenGroup.prototype.extend =
        false
    /**
`@external tokens` declarations in the grammar should resolve to
an instance of this class.
*/
    class ExternalTokenizer {
      /**
    Create a tokenizer. The first argument is the function that,
    given an input stream, scans for the types of tokens it
    recognizes at the stream's position, and calls
    [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    one.
    */
      constructor(
        /**
    @internal
    */
        token,
        options = {}
      ) {
        this.token = token
        this.contextual = !!options.contextual
        this.fallback = !!options.fallback
        this.extend = !!options.extend
      }
    }
    // Tokenizer data is stored a big uint16 array containing, for each
    // state:
    //
    //  - A group bitmask, indicating what token groups are reachable from
    //    this state, so that paths that can only lead to tokens not in
    //    any of the current groups can be cut off early.
    //
    //  - The position of the end of the state's sequence of accepting
    //    tokens
    //
    //  - The number of outgoing edges for the state
    //
    //  - The accepting tokens, as (token id, group mask) pairs
    //
    //  - The outgoing edges, as (start character, end character, state
    //    index) triples, with end character being exclusive
    //
    // This function interprets that data, running through a stream as
    // long as new states with the a matching group mask can be reached,
    // and updating `input.token` when it matches a token.
    function dist_readToken(data, input, stack, group, precTable, precOffset) {
      let state = 0,
        groupMask = 1 << group,
        { dialect } = stack.p.parser
      scan: for (;;) {
        if ((groupMask & data[state]) == 0) break
        let accEnd = data[state + 1]
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
          if ((data[i + 1] & groupMask) > 0) {
            let term = data[i]
            if (
              dialect.allows(term) &&
              (input.token.value == -1 ||
                input.token.value == term ||
                overrides(term, input.token.value, precTable, precOffset))
            ) {
              input.acceptToken(term)
              break
            }
          }
        let next = input.next,
          low = 0,
          high = data[state + 2]
        // Special case for EOF
        if (
          input.next < 0 &&
          high > low &&
          data[accEnd + high * 3 - 3] == 65535 /* Seq.End */
        ) {
          state = data[accEnd + high * 3 - 1]
          continue scan
        }
        // Do a binary search on the state's edges
        for (; low < high; ) {
          let mid = (low + high) >> 1
          let index = accEnd + mid + (mid << 1)
          let from = data[index],
            to = data[index + 1] || 0x10000
          if (next < from) high = mid
          else if (next >= to) low = mid + 1
          else {
            state = data[index + 2]
            input.advance()
            continue scan
          }
        }
        break
      }
    }
    function findOffset(data, start, term) {
      for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)
        if (next == term) return i - start
      return -1
    }
    function overrides(token, prev, tableData, tableOffset) {
      let iPrev = findOffset(tableData, tableOffset, prev)
      return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev
    }

    // Environment variable used to control console output
    const verbose =
      typeof process != 'undefined' &&
      process.env &&
      /\bparse\b/.test(process.env.LOG)
    let stackIDs = null
    function cutAt(tree, pos, side) {
      let cursor = tree.cursor(IterMode.IncludeAnonymous)
      cursor.moveTo(pos)
      for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
          for (;;) {
            if (
              (side < 0 ? cursor.to < pos : cursor.from > pos) &&
              !cursor.type.isError
            )
              return side < 0
                ? Math.max(
                    0,
                    Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */)
                  )
                : Math.min(
                    tree.length,
                    Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */)
                  )
            if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break
            if (!cursor.parent()) return side < 0 ? 0 : tree.length
          }
      }
    }
    class dist_FragmentCursor {
      constructor(fragments, nodeSet) {
        this.fragments = fragments
        this.nodeSet = nodeSet
        this.i = 0
        this.fragment = null
        this.safeFrom = -1
        this.safeTo = -1
        this.trees = []
        this.start = []
        this.index = []
        this.nextFragment()
      }
      nextFragment() {
        let fr = (this.fragment =
          this.i == this.fragments.length ? null : this.fragments[this.i++])
        if (fr) {
          this.safeFrom = fr.openStart
            ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset
            : fr.from
          this.safeTo = fr.openEnd
            ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset
            : fr.to
          while (this.trees.length) {
            this.trees.pop()
            this.start.pop()
            this.index.pop()
          }
          this.trees.push(fr.tree)
          this.start.push(-fr.offset)
          this.index.push(0)
          this.nextStart = this.safeFrom
        } else {
          this.nextStart = 1e9
        }
      }
      // `pos` must be >= any previously given `pos` for this cursor
      nodeAt(pos) {
        if (pos < this.nextStart) return null
        while (this.fragment && this.safeTo <= pos) this.nextFragment()
        if (!this.fragment) return null
        for (;;) {
          let last = this.trees.length - 1
          if (last < 0) {
            // End of tree
            this.nextFragment()
            return null
          }
          let top = this.trees[last],
            index = this.index[last]
          if (index == top.children.length) {
            this.trees.pop()
            this.start.pop()
            this.index.pop()
            continue
          }
          let next = top.children[index]
          let start = this.start[last] + top.positions[index]
          if (start > pos) {
            this.nextStart = start
            return null
          }
          if (next instanceof dist_Tree) {
            if (start == pos) {
              if (start < this.safeFrom) return null
              let end = start + next.length
              if (end <= this.safeTo) {
                let lookAhead = next.prop(dist_NodeProp.lookAhead)
                if (!lookAhead || end + lookAhead < this.fragment.to)
                  return next
              }
            }
            this.index[last]++
            if (start + next.length >= Math.max(this.safeFrom, pos)) {
              // Enter this node
              this.trees.push(next)
              this.start.push(start)
              this.index.push(0)
            }
          } else {
            this.index[last]++
            this.nextStart = start + next.length
          }
        }
      }
    }
    class TokenCache {
      constructor(parser, stream) {
        this.stream = stream
        this.tokens = []
        this.mainToken = null
        this.actions = []
        this.tokens = parser.tokenizers.map((_) => new CachedToken())
      }
      getActions(stack) {
        let actionIndex = 0
        let main = null
        let { parser } = stack.p,
          { tokenizers } = parser
        let mask = parser.stateSlot(
          stack.state,
          3 /* ParseState.TokenizerMask */
        )
        let context = stack.curContext ? stack.curContext.hash : 0
        let lookAhead = 0
        for (let i = 0; i < tokenizers.length; i++) {
          if (((1 << i) & mask) == 0) continue
          let tokenizer = tokenizers[i],
            token = this.tokens[i]
          if (main && !tokenizer.fallback) continue
          if (
            tokenizer.contextual ||
            token.start != stack.pos ||
            token.mask != mask ||
            token.context != context
          ) {
            this.updateCachedToken(token, tokenizer, stack)
            token.mask = mask
            token.context = context
          }
          if (token.lookAhead > token.end + 25 /* Safety.Margin */)
            lookAhead = Math.max(token.lookAhead, lookAhead)
          if (token.value != 0 /* Term.Err */) {
            let startIndex = actionIndex
            if (token.extended > -1)
              actionIndex = this.addActions(
                stack,
                token.extended,
                token.end,
                actionIndex
              )
            actionIndex = this.addActions(
              stack,
              token.value,
              token.end,
              actionIndex
            )
            if (!tokenizer.extend) {
              main = token
              if (actionIndex > startIndex) break
            }
          }
        }
        while (this.actions.length > actionIndex) this.actions.pop()
        if (lookAhead) stack.setLookAhead(lookAhead)
        if (!main && stack.pos == this.stream.end) {
          main = new CachedToken()
          main.value = stack.p.parser.eofTerm
          main.start = main.end = stack.pos
          actionIndex = this.addActions(
            stack,
            main.value,
            main.end,
            actionIndex
          )
        }
        this.mainToken = main
        return this.actions
      }
      getMainToken(stack) {
        if (this.mainToken) return this.mainToken
        let main = new CachedToken(),
          { pos, p } = stack
        main.start = pos
        main.end = Math.min(pos + 1, p.stream.end)
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */
        return main
      }
      updateCachedToken(token, tokenizer, stack) {
        let start = this.stream.clipPos(stack.pos)
        tokenizer.token(this.stream.reset(start, token), stack)
        if (token.value > -1) {
          let { parser } = stack.p
          for (let i = 0; i < parser.specialized.length; i++)
            if (parser.specialized[i] == token.value) {
              let result = parser.specializers[i](
                this.stream.read(token.start, token.end),
                stack
              )
              if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                if ((result & 1) == 0 /* Specialize.Specialize */)
                  token.value = result >> 1
                else token.extended = result >> 1
                break
              }
            }
        } else {
          token.value = 0 /* Term.Err */
          token.end = this.stream.clipPos(start + 1)
        }
      }
      putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
          if (this.actions[i] == action) return index
        this.actions[index++] = action
        this.actions[index++] = token
        this.actions[index++] = end
        return index
      }
      addActions(stack, token, end, index) {
        let { state } = stack,
          { parser } = stack.p,
          { data } = parser
        for (let set = 0; set < 2; set++) {
          for (
            let i = parser.stateSlot(
              state,
              set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */
            );
            ;
            i += 3
          ) {
            if (data[i] == 65535 /* Seq.End */) {
              if (data[i + 1] == 1 /* Seq.Next */) {
                i = pair(data, i + 2)
              } else {
                if (index == 0 && data[i + 1] == 2 /* Seq.Other */)
                  index = this.putAction(pair(data, i + 2), token, end, index)
                break
              }
            }
            if (data[i] == token)
              index = this.putAction(pair(data, i + 1), token, end, index)
          }
        }
        return index
      }
    }
    class dist_Parse {
      constructor(parser, input, fragments, ranges) {
        this.parser = parser
        this.input = input
        this.ranges = ranges
        this.recovering = 0
        this.nextStackID = 0x2654 // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧
        this.minStackPos = 0
        this.reused = []
        this.stoppedAt = null
        this.lastBigReductionStart = -1
        this.lastBigReductionSize = 0
        this.bigReductionCount = 0
        this.stream = new InputStream(input, ranges)
        this.tokens = new TokenCache(parser, this.stream)
        this.topTerm = parser.top[1]
        let { from } = ranges[0]
        this.stacks = [Stack.start(this, parser.top[0], from)]
        this.fragments =
          fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new dist_FragmentCursor(fragments, parser.nodeSet)
            : null
      }
      get parsedPos() {
        return this.minStackPos
      }
      // Move the parser forward. This will process all parse stacks at
      // `this.pos` and try to advance them to a further position. If no
      // stack for such a position is found, it'll start error-recovery.
      //
      // When the parse is finished, this will return a syntax tree. When
      // not, it returns `null`.
      advance() {
        let stacks = this.stacks,
          pos = this.minStackPos
        // This will hold stacks beyond `pos`.
        let newStacks = (this.stacks = [])
        let stopped, stoppedTokens
        // If a large amount of reductions happened with the same start
        // position, force the stack out of that production in order to
        // avoid creating a tree too deep to recurse through.
        // (This is an ugly kludge, because unfortunately there is no
        // straightforward, cheap way to check for this happening, due to
        // the history of reductions only being available in an
        // expensive-to-access format in the stack buffers.)
        if (
          this.bigReductionCount >
            300 /* Rec.MaxLeftAssociativeReductionCount */ &&
          stacks.length == 1
        ) {
          let [s] = stacks
          while (
            s.forceReduce() &&
            s.stack.length &&
            s.stack[s.stack.length - 2] >= this.lastBigReductionStart
          ) {}
          this.bigReductionCount = this.lastBigReductionSize = 0
        }
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
          let stack = stacks[i]
          for (;;) {
            this.tokens.mainToken = null
            if (stack.pos > pos) {
              newStacks.push(stack)
            } else if (this.advanceStack(stack, newStacks, stacks)) {
              continue
            } else {
              if (!stopped) {
                stopped = []
                stoppedTokens = []
              }
              stopped.push(stack)
              let tok = this.tokens.getMainToken(stack)
              stoppedTokens.push(tok.value, tok.end)
            }
            break
          }
        }
        if (!newStacks.length) {
          let finished = stopped && findFinished(stopped)
          if (finished) {
            if (verbose) console.log('Finish with ' + this.stackID(finished))
            return this.stackToTree(finished)
          }
          if (this.parser.strict) {
            if (verbose && stopped)
              console.log(
                'Stuck with token ' +
                  (this.tokens.mainToken
                    ? this.parser.getName(this.tokens.mainToken.value)
                    : 'none')
              )
            throw new SyntaxError('No parse at ' + pos)
          }
          if (!this.recovering) this.recovering = 5 /* Rec.Distance */
        }
        if (this.recovering && stopped) {
          let finished =
            this.stoppedAt != null && stopped[0].pos > this.stoppedAt
              ? stopped[0]
              : this.runRecovery(stopped, stoppedTokens, newStacks)
          if (finished) {
            if (verbose) console.log('Force-finish ' + this.stackID(finished))
            return this.stackToTree(finished.forceAll())
          }
        }
        if (this.recovering) {
          let maxRemaining =
            this.recovering == 1
              ? 1
              : this.recovering * 3 /* Rec.MaxRemainingPerStep */
          if (newStacks.length > maxRemaining) {
            newStacks.sort((a, b) => b.score - a.score)
            while (newStacks.length > maxRemaining) newStacks.pop()
          }
          if (newStacks.some((s) => s.reducePos > pos)) this.recovering--
        } else if (newStacks.length > 1) {
          // Prune stacks that are in the same state, or that have been
          // running without splitting for a while, to avoid getting stuck
          // with multiple successful stacks running endlessly on.
          outer: for (let i = 0; i < newStacks.length - 1; i++) {
            let stack = newStacks[i]
            for (let j = i + 1; j < newStacks.length; j++) {
              let other = newStacks[j]
              if (
                stack.sameState(other) ||
                (stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ &&
                  other.buffer.length > 500) /* Rec.MinBufferLengthPrune */
              ) {
                if (
                  (stack.score - other.score ||
                    stack.buffer.length - other.buffer.length) > 0
                ) {
                  newStacks.splice(j--, 1)
                } else {
                  newStacks.splice(i--, 1)
                  continue outer
                }
              }
            }
          }
          if (newStacks.length > 12 /* Rec.MaxStackCount */)
            newStacks.splice(
              12 /* Rec.MaxStackCount */,
              newStacks.length - 12 /* Rec.MaxStackCount */
            )
        }
        this.minStackPos = newStacks[0].pos
        for (let i = 1; i < newStacks.length; i++)
          if (newStacks[i].pos < this.minStackPos)
            this.minStackPos = newStacks[i].pos
        return null
      }
      stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
          throw new RangeError("Can't move stoppedAt forward")
        this.stoppedAt = pos
      }
      // Returns an updated version of the given stack, or null if the
      // stack can't advance normally. When `split` and `stacks` are
      // given, stacks split off by ambiguous operations will be pushed to
      // `split`, or added to `stacks` if they move `pos` forward.
      advanceStack(stack, stacks, split) {
        let start = stack.pos,
          { parser } = this
        let base = verbose ? this.stackID(stack) + ' -> ' : ''
        if (this.stoppedAt != null && start > this.stoppedAt)
          return stack.forceReduce() ? stack : null
        if (this.fragments) {
          let strictCx = stack.curContext && stack.curContext.tracker.strict,
            cxHash = strictCx ? stack.curContext.hash : 0
          for (let cached = this.fragments.nodeAt(start); cached; ) {
            let match =
              this.parser.nodeSet.types[cached.type.id] == cached.type
                ? parser.getGoto(stack.state, cached.type.id)
                : -1
            if (
              match > -1 &&
              cached.length &&
              (!strictCx ||
                (cached.prop(dist_NodeProp.contextHash) || 0) == cxHash)
            ) {
              stack.useNode(cached, match)
              if (verbose)
                console.log(
                  base +
                    this.stackID(stack) +
                    ` (via reuse of ${parser.getName(cached.type.id)})`
                )
              return true
            }
            if (
              !(cached instanceof dist_Tree) ||
              cached.children.length == 0 ||
              cached.positions[0] > 0
            )
              break
            let inner = cached.children[0]
            if (inner instanceof dist_Tree && cached.positions[0] == 0)
              cached = inner
            else break
          }
        }
        let defaultReduce = parser.stateSlot(
          stack.state,
          4 /* ParseState.DefaultReduce */
        )
        if (defaultReduce > 0) {
          stack.reduce(defaultReduce)
          if (verbose)
            console.log(
              base +
                this.stackID(stack) +
                ` (via always-reduce ${parser.getName(
                  defaultReduce & 65535 /* Action.ValueMask */
                )})`
            )
          return true
        }
        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {
          while (
            stack.stack.length > 6000 /* Rec.CutTo */ &&
            stack.forceReduce()
          ) {}
        }
        let actions = this.tokens.getActions(stack)
        for (let i = 0; i < actions.length; ) {
          let action = actions[i++],
            term = actions[i++],
            end = actions[i++]
          let last = i == actions.length || !split
          let localStack = last ? stack : stack.split()
          let main = this.tokens.mainToken
          localStack.apply(
            action,
            term,
            main ? main.start : localStack.pos,
            end
          )
          if (verbose)
            console.log(
              base +
                this.stackID(localStack) +
                ` (via ${
                  (action & 65536) /* Action.ReduceFlag */ == 0
                    ? 'shift'
                    : `reduce of ${parser.getName(
                        action & 65535 /* Action.ValueMask */
                      )}`
                } for ${parser.getName(term)} @ ${start}${
                  localStack == stack ? '' : ', split'
                })`
            )
          if (last) return true
          else if (localStack.pos > start) stacks.push(localStack)
          else split.push(localStack)
        }
        return false
      }
      // Advance a given stack forward as far as it will go. Returns the
      // (possibly updated) stack if it got stuck, or null if it moved
      // forward and was given to `pushStackDedup`.
      advanceFully(stack, newStacks) {
        let pos = stack.pos
        for (;;) {
          if (!this.advanceStack(stack, null, null)) return false
          if (stack.pos > pos) {
            pushStackDedup(stack, newStacks)
            return true
          }
        }
      }
      runRecovery(stacks, tokens, newStacks) {
        let finished = null,
          restarted = false
        for (let i = 0; i < stacks.length; i++) {
          let stack = stacks[i],
            token = tokens[i << 1],
            tokenEnd = tokens[(i << 1) + 1]
          let base = verbose ? this.stackID(stack) + ' -> ' : ''
          if (stack.deadEnd) {
            if (restarted) continue
            restarted = true
            stack.restart()
            if (verbose)
              console.log(base + this.stackID(stack) + ' (restarted)')
            let done = this.advanceFully(stack, newStacks)
            if (done) continue
          }
          let force = stack.split(),
            forceBase = base
          for (
            let j = 0;
            force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */;
            j++
          ) {
            if (verbose)
              console.log(
                forceBase + this.stackID(force) + ' (via force-reduce)'
              )
            let done = this.advanceFully(force, newStacks)
            if (done) break
            if (verbose) forceBase = this.stackID(force) + ' -> '
          }
          for (let insert of stack.recoverByInsert(token)) {
            if (verbose)
              console.log(base + this.stackID(insert) + ' (via recover-insert)')
            this.advanceFully(insert, newStacks)
          }
          if (this.stream.end > stack.pos) {
            if (tokenEnd == stack.pos) {
              tokenEnd++
              token = 0 /* Term.Err */
            }
            stack.recoverByDelete(token, tokenEnd)
            if (verbose)
              console.log(
                base +
                  this.stackID(stack) +
                  ` (via recover-delete ${this.parser.getName(token)})`
              )
            pushStackDedup(stack, newStacks)
          } else if (!finished || finished.score < stack.score) {
            finished = stack
          }
        }
        return finished
      }
      // Convert the stack's buffer to a syntax tree.
      stackToTree(stack) {
        stack.close()
        return dist_Tree.build({
          buffer: StackBufferCursor.create(stack),
          nodeSet: this.parser.nodeSet,
          topID: this.topTerm,
          maxBufferLength: this.parser.bufferLength,
          reused: this.reused,
          start: this.ranges[0].from,
          length: stack.pos - this.ranges[0].from,
          minRepeatType: this.parser.minRepeatTerm
        })
      }
      stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap())).get(stack)
        if (!id)
          stackIDs.set(stack, (id = String.fromCodePoint(this.nextStackID++)))
        return id + stack
      }
    }
    function pushStackDedup(stack, newStacks) {
      for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i]
        if (other.pos == stack.pos && other.sameState(stack)) {
          if (newStacks[i].score < stack.score) newStacks[i] = stack
          return
        }
      }
      newStacks.push(stack)
    }
    class Dialect {
      constructor(source, flags, disabled) {
        this.source = source
        this.flags = flags
        this.disabled = disabled
      }
      allows(term) {
        return !this.disabled || this.disabled[term] == 0
      }
    }
    const id = (x) => x
    /**
Context trackers are used to track stateful context (such as
indentation in the Python grammar, or parent elements in the XML
grammar) needed by external tokenizers. You declare them in a
grammar file as `@context exportName from "module"`.

Context values should be immutable, and can be updated (replaced)
on shift or reduce actions.

The export used in a `@context` declaration should be of this
type.
*/
    class ContextTracker {
      /**
    Define a context tracker.
    */
      constructor(spec) {
        this.start = spec.start
        this.shift = spec.shift || id
        this.reduce = spec.reduce || id
        this.reuse = spec.reuse || id
        this.hash = spec.hash || (() => 0)
        this.strict = spec.strict !== false
      }
    }
    /**
Holds the parse tables for a given grammar, as generated by
`lezer-generator`, and provides [methods](#common.Parser) to parse
content with.
*/
    class LRParser extends dist_Parser {
      /**
    @internal
    */
      constructor(spec) {
        super()
        /**
        @internal
        */
        this.wrappers = []
        if (spec.version != 14 /* File.Version */)
          throw new RangeError(
            `Parser version (${spec.version}) doesn't match runtime version (${
              14 /* File.Version */
            })`
          )
        let nodeNames = spec.nodeNames.split(' ')
        this.minRepeatTerm = nodeNames.length
        for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push('')
        let topTerms = Object.keys(spec.topRules).map(
          (r) => spec.topRules[r][1]
        )
        let nodeProps = []
        for (let i = 0; i < nodeNames.length; i++) nodeProps.push([])
        function setProp(nodeID, prop, value) {
          nodeProps[nodeID].push([prop, prop.deserialize(String(value))])
        }
        if (spec.nodeProps)
          for (let propSpec of spec.nodeProps) {
            let prop = propSpec[0]
            if (typeof prop == 'string') prop = dist_NodeProp[prop]
            for (let i = 1; i < propSpec.length; ) {
              let next = propSpec[i++]
              if (next >= 0) {
                setProp(next, prop, propSpec[i++])
              } else {
                let value = propSpec[i + -next]
                for (let j = -next; j > 0; j--)
                  setProp(propSpec[i++], prop, value)
                i++
              }
            }
          }
        this.nodeSet = new NodeSet(
          nodeNames.map((name, i) =>
            dist_NodeType.define({
              name: i >= this.minRepeatTerm ? undefined : name,
              id: i,
              props: nodeProps[i],
              top: topTerms.indexOf(i) > -1,
              error: i == 0,
              skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
            })
          )
        )
        if (spec.propSources)
          this.nodeSet = this.nodeSet.extend(...spec.propSources)
        this.strict = false
        this.bufferLength = DefaultBufferLength
        let tokenArray = decodeArray(spec.tokenData)
        this.context = spec.context
        this.specializerSpecs = spec.specialized || []
        this.specialized = new Uint16Array(this.specializerSpecs.length)
        for (let i = 0; i < this.specializerSpecs.length; i++)
          this.specialized[i] = this.specializerSpecs[i].term
        this.specializers = this.specializerSpecs.map(getSpecializer)
        this.states = decodeArray(spec.states, Uint32Array)
        this.data = decodeArray(spec.stateData)
        this.goto = decodeArray(spec.goto)
        this.maxTerm = spec.maxTerm
        this.tokenizers = spec.tokenizers.map((value) =>
          typeof value == 'number' ? new TokenGroup(tokenArray, value) : value
        )
        this.topRules = spec.topRules
        this.dialects = spec.dialects || {}
        this.dynamicPrecedences = spec.dynamicPrecedences || null
        this.tokenPrecTable = spec.tokenPrec
        this.termNames = spec.termNames || null
        this.maxNode = this.nodeSet.types.length - 1
        this.dialect = this.parseDialect()
        this.top = this.topRules[Object.keys(this.topRules)[0]]
      }
      createParse(input, fragments, ranges) {
        let parse = new dist_Parse(this, input, fragments, ranges)
        for (let w of this.wrappers) parse = w(parse, input, fragments, ranges)
        return parse
      }
      /**
    Get a goto table entry @internal
    */
      getGoto(state, term, loose = false) {
        let table = this.goto
        if (term >= table[0]) return -1
        for (let pos = table[term + 1]; ; ) {
          let groupTag = table[pos++],
            last = groupTag & 1
          let target = table[pos++]
          if (last && loose) return target
          for (let end = pos + (groupTag >> 1); pos < end; pos++)
            if (table[pos] == state) return target
          if (last) return -1
        }
      }
      /**
    Check if this state has an action for a given terminal @internal
    */
      hasAction(state, terminal) {
        let data = this.data
        for (let set = 0; set < 2; set++) {
          for (
            let i = this.stateSlot(
                state,
                set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */
              ),
              next;
            ;
            i += 3
          ) {
            if ((next = data[i]) == 65535 /* Seq.End */) {
              if (data[i + 1] == 1 /* Seq.Next */)
                next = data[(i = pair(data, i + 2))]
              else if (data[i + 1] == 2 /* Seq.Other */)
                return pair(data, i + 2)
              else break
            }
            if (next == terminal || next == 0 /* Term.Err */)
              return pair(data, i + 1)
          }
        }
        return 0
      }
      /**
    @internal
    */
      stateSlot(state, slot) {
        return this.states[state * 6 /* ParseState.Size */ + slot]
      }
      /**
    @internal
    */
      stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0
      }
      /**
    @internal
    */
      validAction(state, action) {
        return !!this.allActions(state, (a) => (a == action ? true : null))
      }
      /**
    @internal
    */
      allActions(state, action) {
        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */)
        let result = deflt ? action(deflt) : undefined
        for (
          let i = this.stateSlot(state, 1 /* ParseState.Actions */);
          result == null;
          i += 3
        ) {
          if (this.data[i] == 65535 /* Seq.End */) {
            if (this.data[i + 1] == 1 /* Seq.Next */) i = pair(this.data, i + 2)
            else break
          }
          result = action(pair(this.data, i + 1))
        }
        return result
      }
      /**
    Get the states that can follow this one through shift actions or
    goto jumps. @internal
    */
      nextStates(state) {
        let result = []
        for (
          let i = this.stateSlot(state, 1 /* ParseState.Actions */);
          ;
          i += 3
        ) {
          if (this.data[i] == 65535 /* Seq.End */) {
            if (this.data[i + 1] == 1 /* Seq.Next */) i = pair(this.data, i + 2)
            else break
          }
          if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {
            let value = this.data[i + 1]
            if (!result.some((v, i) => i & 1 && v == value))
              result.push(this.data[i], value)
          }
        }
        return result
      }
      /**
    Configure the parser. Returns a new parser instance that has the
    given settings modified. Settings not provided in `config` are
    kept from the original parser.
    */
      configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this)
        if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props)
        if (config.top) {
          let info = this.topRules[config.top]
          if (!info) throw new RangeError(`Invalid top rule name ${config.top}`)
          copy.top = info
        }
        if (config.tokenizers)
          copy.tokenizers = this.tokenizers.map((t) => {
            let found = config.tokenizers.find((r) => r.from == t)
            return found ? found.to : t
          })
        if (config.specializers) {
          copy.specializers = this.specializers.slice()
          copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
            let found = config.specializers.find((r) => r.from == s.external)
            if (!found) return s
            let spec = Object.assign(Object.assign({}, s), {
              external: found.to
            })
            copy.specializers[i] = getSpecializer(spec)
            return spec
          })
        }
        if (config.contextTracker) copy.context = config.contextTracker
        if (config.dialect) copy.dialect = this.parseDialect(config.dialect)
        if (config.strict != null) copy.strict = config.strict
        if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap)
        if (config.bufferLength != null) copy.bufferLength = config.bufferLength
        return copy
      }
      /**
    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
    are registered for this parser.
    */
      hasWrappers() {
        return this.wrappers.length > 0
      }
      /**
    Returns the name associated with a given term. This will only
    work for all terms when the parser was generated with the
    `--names` option. By default, only the names of tagged terms are
    stored.
    */
      getName(term) {
        return this.termNames
          ? this.termNames[term]
          : String(
              (term <= this.maxNode && this.nodeSet.types[term].name) || term
            )
      }
      /**
    The eof term id is always allocated directly after the node
    types. @internal
    */
      get eofTerm() {
        return this.maxNode + 1
      }
      /**
    The type of top node produced by the parser.
    */
      get topNode() {
        return this.nodeSet.types[this.top[1]]
      }
      /**
    @internal
    */
      dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences
        return prec == null ? 0 : prec[term] || 0
      }
      /**
    @internal
    */
      parseDialect(dialect) {
        let values = Object.keys(this.dialects),
          flags = values.map(() => false)
        if (dialect)
          for (let part of dialect.split(' ')) {
            let id = values.indexOf(part)
            if (id >= 0) flags[id] = true
          }
        let disabled = null
        for (let i = 0; i < values.length; i++)
          if (!flags[i]) {
            for (
              let j = this.dialects[values[i]], id;
              (id = this.data[j++]) != 65535 /* Seq.End */;

            )
              (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] =
                1
          }
        return new Dialect(dialect, flags, disabled)
      }
      /**
    Used by the output of the parser generator. Not available to
    user code. @hide
    */
      static deserialize(spec) {
        return new LRParser(spec)
      }
    }
    function pair(data, off) {
      return data[off] | (data[off + 1] << 16)
    }
    function findFinished(stacks) {
      let best = null
      for (let stack of stacks) {
        let stopped = stack.p.stoppedAt
        if (
          (stack.pos == stack.p.stream.end ||
            (stopped != null && stack.pos > stopped)) &&
          stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&
          (!best || best.score < stack.score)
        )
          best = stack
      }
      return best
    }
    function getSpecializer(spec) {
      if (spec.external) {
        let mask = spec.extend
          ? 1 /* Specialize.Extend */
          : 0 /* Specialize.Specialize */
        return (value, stack) => (spec.external(value, stack) << 1) | mask
      }
      return spec.get
    } // CONCATENATED MODULE: ./node_modules/@lezer/javascript/dist/index.js

    // This file was generated by lezer-generator. You probably shouldn't edit it.
    const noSemi = 308,
      incdec = 1,
      incdecPrefix = 2,
      insertSemi = 309,
      spaces = 311,
      newline = 312,
      LineComment = 3,
      BlockComment = 4

    /* Hand-written tokenizers for JavaScript tokens that can't be
   expressed by lezer's built-in tokenizer. */

    const space = [
      9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,
      8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288
    ]

    const braceR = 125,
      semicolon = 59,
      slash = 47,
      star = 42,
      plus = 43,
      minus = 45

    const trackNewline = new ContextTracker({
      start: false,
      shift(context, term) {
        return term == LineComment || term == BlockComment || term == spaces
          ? context
          : term == newline
      },
      strict: false
    })

    const insertSemicolon = new ExternalTokenizer(
      (input, stack) => {
        let { next } = input
        if (next == braceR || next == -1 || stack.context)
          input.acceptToken(insertSemi)
      },
      { contextual: true, fallback: true }
    )

    const noSemicolon = new ExternalTokenizer(
      (input, stack) => {
        let { next } = input,
          after
        if (space.indexOf(next) > -1) return
        if (
          next == slash &&
          ((after = input.peek(1)) == slash || after == star)
        )
          return
        if (next != braceR && next != semicolon && next != -1 && !stack.context)
          input.acceptToken(noSemi)
      },
      { contextual: true }
    )

    const incdecToken = new ExternalTokenizer(
      (input, stack) => {
        let { next } = input
        if (next == plus || next == minus) {
          input.advance()
          if (next == input.next) {
            input.advance()
            let mayPostfix = !stack.context && stack.canShift(incdec)
            input.acceptToken(mayPostfix ? incdec : incdecPrefix)
          }
        }
      },
      { contextual: true }
    )

    const jsHighlight = styleTags({
      'get set async static': tags.modifier,
      'for while do if else switch try catch finally return throw break continue default case':
        tags.controlKeyword,
      'in of await yield void typeof delete instanceof': tags.operatorKeyword,
      'let var const using function class extends': tags.definitionKeyword,
      'import export from': tags.moduleKeyword,
      'with debugger as new': tags.keyword,
      TemplateString: tags.special(tags.string),
      super: tags.atom,
      BooleanLiteral: tags.bool,
      this: tags.self,
      null: tags.null,
      Star: tags.modifier,
      VariableName: tags.variableName,
      'CallExpression/VariableName TaggedTemplateExpression/VariableName':
        tags.function(tags.variableName),
      VariableDefinition: tags.definition(tags.variableName),
      Label: tags.labelName,
      PropertyName: tags.propertyName,
      PrivatePropertyName: tags.special(tags.propertyName),
      'CallExpression/MemberExpression/PropertyName': tags.function(
        tags.propertyName
      ),
      'FunctionDeclaration/VariableDefinition': tags.function(
        tags.definition(tags.variableName)
      ),
      'ClassDeclaration/VariableDefinition': tags.definition(tags.className),
      PropertyDefinition: tags.definition(tags.propertyName),
      PrivatePropertyDefinition: tags.definition(
        tags.special(tags.propertyName)
      ),
      UpdateOp: tags.updateOperator,
      'LineComment Hashbang': tags.lineComment,
      BlockComment: tags.blockComment,
      Number: tags.number,
      String: tags.string,
      Escape: tags.escape,
      ArithOp: tags.arithmeticOperator,
      LogicOp: tags.logicOperator,
      BitOp: tags.bitwiseOperator,
      CompareOp: tags.compareOperator,
      RegExp: tags.regexp,
      Equals: tags.definitionOperator,
      Arrow: tags.function(tags.punctuation),
      ': Spread': tags.punctuation,
      '( )': tags.paren,
      '[ ]': tags.squareBracket,
      '{ }': tags.brace,
      'InterpolationStart InterpolationEnd': tags.special(tags.brace),
      '.': tags.derefOperator,
      ', ;': tags.separator,
      '@': tags.meta,

      TypeName: tags.typeName,
      TypeDefinition: tags.definition(tags.typeName),
      'type enum interface implements namespace module declare':
        tags.definitionKeyword,
      'abstract global Privacy readonly override': tags.modifier,
      'is keyof unique infer': tags.operatorKeyword,

      JSXAttributeValue: tags.attributeValue,
      JSXText: tags.content,
      'JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag':
        tags.angleBracket,
      'JSXIdentifier JSXNameSpacedName': tags.tagName,
      'JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName':
        tags.attributeName,
      'JSXBuiltin/JSXIdentifier': tags.standard(tags.tagName)
    })

    // This file was generated by lezer-generator. You probably shouldn't edit it.
    const spec_identifier = {
      __proto__: null,
      export: 16,
      as: 21,
      from: 29,
      default: 32,
      async: 37,
      function: 38,
      extends: 48,
      this: 52,
      true: 60,
      false: 60,
      null: 72,
      void: 76,
      typeof: 80,
      super: 98,
      new: 132,
      delete: 148,
      yield: 157,
      await: 161,
      class: 166,
      public: 223,
      private: 223,
      protected: 223,
      readonly: 225,
      instanceof: 244,
      satisfies: 247,
      in: 248,
      const: 250,
      import: 282,
      keyof: 337,
      unique: 341,
      infer: 347,
      is: 383,
      abstract: 403,
      implements: 405,
      type: 407,
      let: 410,
      var: 412,
      using: 415,
      interface: 421,
      enum: 425,
      namespace: 431,
      module: 433,
      declare: 437,
      global: 441,
      for: 460,
      of: 469,
      while: 472,
      with: 476,
      do: 480,
      if: 484,
      else: 486,
      switch: 490,
      case: 496,
      try: 502,
      catch: 506,
      finally: 510,
      return: 514,
      throw: 518,
      break: 522,
      continue: 526,
      debugger: 530
    }
    const spec_word = {
      __proto__: null,
      async: 119,
      get: 121,
      set: 123,
      declare: 183,
      public: 185,
      private: 185,
      protected: 185,
      static: 187,
      abstract: 189,
      override: 191,
      readonly: 197,
      accessor: 199,
      new: 387
    }
    const spec_LessThan = { __proto__: null, '<': 139 }
    const parser = LRParser.deserialize({
      version: 14,
      states:
        "$<UO%TQUOOO%[QUOOO'_QWOOP(lOSOOO*zQ(CjO'#CgO+ROpO'#ChO+aO!bO'#ChO+oO07`O'#D[O.QQUO'#DbO.bQUO'#DmO%[QUO'#DwO0fQUO'#EPOOQ(CY'#EX'#EXO1PQSO'#EUOOQO'#Ej'#EjOOQO'#Id'#IdO1XQSO'#GlO1dQSO'#EiO1iQSO'#EiO3kQ(CjO'#JiO6[Q(CjO'#JjO6xQSO'#FXO6}Q#tO'#FpOOQ(CY'#Fa'#FaO7YO&jO'#FaO7hQ,UO'#FwO9UQSO'#FvOOQ(CY'#Jj'#JjOOQ(CW'#Ji'#JiO9ZQSO'#GpOOQQ'#KU'#KUO9fQSO'#IQO9kQ(C[O'#IROOQQ'#JV'#JVOOQQ'#IV'#IVQ`QUOOO`QUOOO%[QUO'#DoO9sQUO'#D{O9zQUO'#D}O9aQSO'#GlO:RQ,UO'#CmO:aQSO'#EhO:lQSO'#EsO:qQ,UO'#F`O;`QSO'#GlOOQO'#KV'#KVO;eQSO'#KVO;sQSO'#GtO;sQSO'#GuO;sQSO'#GwO9aQSO'#GzO<jQSO'#G}O>RQSO'#CcO>cQSO'#HZO>kQSO'#HaO>kQSO'#HcO`QUO'#HeO>kQSO'#HgO>kQSO'#HjO>pQSO'#HpO>uQ(C]O'#HvO%[QUO'#HxO?QQ(C]O'#HzO?]Q(C]O'#H|O9kQ(C[O'#IOO?hQ(CjO'#CgO@jQWO'#DgQOQSOOO%[QUO'#D}OAQQSO'#EQO:RQ,UO'#EhOA]QSO'#EhOAhQ`O'#F`OOQQ'#Ce'#CeOOQ(CW'#Dl'#DlOOQ(CW'#Jm'#JmO%[QUO'#JmOOQO'#Jq'#JqOOQO'#Ia'#IaOBhQWO'#EaOOQ(CW'#E`'#E`OCdQ(C`O'#EaOCnQWO'#ETOOQO'#Jp'#JpODSQWO'#JqOEaQWO'#ETOCnQWO'#EaPEnO?MpO'#C`POOO)CDt)CDtOOOO'#IW'#IWOEyOpO,59SOOQ(CY,59S,59SOOOO'#IX'#IXOFXO!bO,59SO%[QUO'#D^OOOO'#IZ'#IZOFgO07`O,59vOOQ(CY,59v,59vOFuQUO'#I[OGYQSO'#JkOI[QbO'#JkO+}QUO'#JkOIcQSO,59|OIyQSO'#EjOJWQSO'#JyOJcQSO'#JxOJcQSO'#JxOJkQSO,5;WOJpQSO'#JwOOQ(CY,5:X,5:XOJwQUO,5:XOLxQ(CjO,5:cOMiQSO,5:kONSQ(C[O'#JvONZQSO'#JuO9ZQSO'#JuONoQSO'#JuONwQSO,5;VON|QSO'#JuO!#UQbO'#JjOOQ(CY'#Cg'#CgO%[QUO'#EPO!#tQ`O,5:pOOQO'#Jr'#JrOOQO-E<b-E<bO9aQSO,5=WO!$[QSO,5=WO!$aQUO,5;TO!&dQ,UO'#EeO!'}QSO,5;TO!)mQ,UO'#DqO!)tQUO'#DvO!*OQWO,5;^O!*WQWO,5;^O%[QUO,5;^OOQQ'#FP'#FPOOQQ'#FR'#FRO%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_OOQQ'#FV'#FVO!*fQUO,5;pOOQ(CY,5;u,5;uOOQ(CY,5;v,5;vO!,iQSO,5;vOOQ(CY,5;w,5;wO%[QUO'#IhO!,qQ(C[O,5<dO!&dQ,UO,5;_O!-`Q,UO,5;_O%[QUO,5;sO!-gQ#tO'#FfO!.dQ#tO'#J}O!.OQ#tO'#J}O!.kQ#tO'#J}OOQO'#J}'#J}O!/PQ#tO,5<OOOOO,5<[,5<[O!/bQUO'#FrOOOO'#Ig'#IgO7YO&jO,5;{O!/iQ#tO'#FtOOQ(CY,5;{,5;{O!0YQ7[O'#CsOOQ(CY'#Cw'#CwO!0mQSO'#CwO!0rO07`O'#C{O!1`Q,UO,5<aO!1gQSO,5<cO!3SQMhO'#GRO!3aQSO'#GSO!3fQSO'#GSO!3kQMhO'#GWO!4jQWO'#G[OOQO'#Gg'#GgO!(SQ,UO'#GfOOQO'#Gi'#GiO!(SQ,UO'#GhO!5]Q7[O'#JdOOQ(CY'#Jd'#JdO!5gQSO'#JcO!5uQSO'#JbO!5}QSO'#CrOOQ(CY'#Cu'#CuOOQ(CY'#DP'#DPOOQ(CY'#DR'#DRO1SQSO'#DTO!(SQ,UO'#FyO!(SQ,UO'#F{O!6VQSO'#F}O!6[QSO'#GOO!3fQSO'#GUO!(SQ,UO'#GZO!6aQSO'#EkO!7OQSO,5<bOOQ(CW'#Cp'#CpO!7WQSO'#ElO!8QQWO'#EmOOQ(CW'#Jw'#JwO!8XQ(C[O'#KWO9kQ(C[O,5=[O`QUO,5>lOOQQ'#J_'#J_OOQQ,5>m,5>mOOQQ-E<T-E<TO!:ZQ(CjO,5:ZO!<wQ(CjO,5:gO%[QUO,5:gO!?bQ(CjO,5:iOOQO,5@q,5@qO!@RQ,UO,5=WO!@aQ(C[O'#J`O9UQSO'#J`O!@rQ(C[O,59XO!@}QWO,59XO!AVQ,UO,59XO:RQ,UO,59XO!AbQSO,5;TO!AjQSO'#HYO!BOQSO'#KZO%[QUO,5;xO!7{QWO,5;zO!BWQSO,5=sO!B]QSO,5=sO!BbQSO,5=sO9kQ(C[O,5=sO;sQSO,5=cOOQO'#Cs'#CsO!BpQWO,5=`O!BxQ,UO,5=aO!CTQSO,5=cO!CYQ`O,5=fO!CbQSO'#KVO>pQSO'#HPO9aQSO'#HRO!CgQSO'#HRO:RQ,UO'#HTO!ClQSO'#HTOOQQ,5=i,5=iO!CqQSO'#HUO!DSQSO'#CmO!DXQSO,58}O!DcQSO,58}O!FhQUO,58}OOQQ,58},58}O!FxQ(C[O,58}O%[QUO,58}O!ITQUO'#H]OOQQ'#H^'#H^OOQQ'#H_'#H_O`QUO,5=uO!IkQSO,5=uO`QUO,5={O`QUO,5=}O!IpQSO,5>PO`QUO,5>RO!IuQSO,5>UO!IzQUO,5>[OOQQ,5>b,5>bO%[QUO,5>bO9kQ(C[O,5>dOOQQ,5>f,5>fO!NUQSO,5>fOOQQ,5>h,5>hO!NUQSO,5>hOOQQ,5>j,5>jO!NZQWO'#DYO%[QUO'#JmO!NxQWO'#JmO# gQWO'#DhO# xQWO'#DhO#$ZQUO'#DhO#$bQSO'#JlO#$jQSO,5:RO#$oQSO'#EnO#$}QSO'#JzO#%VQSO,5;XO#%[QWO'#DhO#%iQWO'#ESOOQ(CY,5:l,5:lO%[QUO,5:lO#%pQSO,5:lO>pQSO,5;SO!@}QWO,5;SO!AVQ,UO,5;SO:RQ,UO,5;SO#%xQSO,5@XO#%}Q!LQO,5:pOOQO-E<_-E<_O#'TQ(C`O,5:{OCnQWO,5:oO#'_QWO,5:oOCnQWO,5:{O!@rQ(C[O,5:oOOQ(CW'#Ed'#EdOOQO,5:{,5:{O%[QUO,5:{O#'lQ(C[O,5:{O#'wQ(C[O,5:{O!@}QWO,5:oOOQO,5;R,5;RO#(VQ(C[O,5:{POOO'#IU'#IUP#(kO?MpO,58zPOOO,58z,58zOOOO-E<U-E<UOOQ(CY1G.n1G.nOOOO-E<V-E<VO#(vQ`O,59xOOOO-E<X-E<XOOQ(CY1G/b1G/bO#({QbO,5>vO+}QUO,5>vOOQO,5>|,5>|O#)VQUO'#I[OOQO-E<Y-E<YO#)dQSO,5@VO#)lQbO,5@VO#)sQSO,5@dOOQ(CY1G/h1G/hO%[QUO,5@eO#){QSO'#IbOOQO-E<`-E<`O#)sQSO,5@dOOQ(CW1G0r1G0rOOQ(CY1G/s1G/sOOQ(CY1G0V1G0VO%[QUO,5@bO#*aQ(C[O,5@bO#*rQ(C[O,5@bO#*yQSO,5@aO9ZQSO,5@aO#+RQSO,5@aO#+aQSO'#IeO#*yQSO,5@aOOQ(CW1G0q1G0qO!*OQWO,5:rO!*ZQWO,5:rOOQO,5:t,5:tO#,RQSO,5:tO#,ZQ,UO1G2rO9aQSO1G2rOOQ(CY1G0o1G0oO#,iQ(CjO1G0oO#-nQ(ChO,5;POOQ(CY'#GQ'#GQO#.[Q(CjO'#JdO!$aQUO1G0oO#0dQ,UO'#JnO#0nQSO,5:]O#0sQbO'#JoO%[QUO'#JoO#0}QSO,5:bOOQ(CY'#DY'#DYOOQ(CY1G0x1G0xO%[QUO1G0xOOQ(CY1G1b1G1bO#1SQSO1G0xO#3kQ(CjO1G0yO#3rQ(CjO1G0yO#6]Q(CjO1G0yO#6dQ(CjO1G0yO#8nQ(CjO1G0yO#9UQ(CjO1G0yO#<OQ(CjO1G0yO#<VQ(CjO1G0yO#>pQ(CjO1G0yO#>wQ(CjO1G0yO#@oQ(CjO1G0yO#CoQ$IUO'#CgO#EmQ$IUO1G1[O#EtQ$IUO'#JjO!,lQSO1G1bO#FUQ(CjO,5?SOOQ(CW-E<f-E<fO#FxQ(CjO1G0yOOQ(CY1G0y1G0yO#ITQ(CjO1G1_O#IwQ#tO,5<SO#JPQ#tO,5<TO#JXQ#tO'#FkO#JpQSO'#FjOOQO'#KO'#KOOOQO'#If'#IfO#JuQ#tO1G1jOOQ(CY1G1j1G1jOOOO1G1u1G1uO#KWQ$IUO'#JiO#KbQSO,5<^O!*fQUO,5<^OOOO-E<e-E<eOOQ(CY1G1g1G1gO#KgQWO'#J}OOQ(CY,5<`,5<`O#KoQWO,5<`OOQ(CY,59c,59cO!&dQ,UO'#C}OOOO'#IY'#IYO#KtO07`O,59gOOQ(CY,59g,59gO%[QUO1G1{O!6[QSO'#IjO#LPQ,UO,5<tOOQ(CY,5<q,5<qO!(SQ,UO'#ImO#LoQ,UO,5=QO!(SQ,UO'#IoO#MbQ,UO,5=SO!&dQ,UO,5=UOOQO1G1}1G1}O#MlQ`O'#CpO#NPQ`O,5<mO#NWQSO'#KRO9aQSO'#KRO#NfQSO,5<oO!(SQ,UO,5<nO#NkQSO'#GTO#NvQSO,5<nO#N{Q`O'#GQO$ YQ`O'#KSO$ dQSO'#KSO!&dQ,UO'#KSO$ iQSO,5<rO$ nQWO'#G]O!4eQWO'#G]O$!PQSO'#G_O$!UQSO'#GaO!3fQSO'#GdO$!ZQ(C[O'#IlO$!fQWO,5<vOOQ(CY,5<v,5<vO$!mQWO'#G]O$!{QWO'#G^O$#TQWO'#G^O$#YQ,UO,5=QO$#jQ,UO,5=SOOQ(CY,5=V,5=VO!(SQ,UO,5?}O!(SQ,UO,5?}O$#zQSO'#IqO$$VQSO,5?|O$$_QSO,59^O$%OQ,UO,59oOOQ(CY,59o,59oO$%qQ,UO,5<eO$&dQ,UO,5<gO@bQSO,5<iOOQ(CY,5<j,5<jO$&nQSO,5<pO$&sQ,UO,5<uO$'TQSO'#JuO!$aQUO1G1|O$'YQSO1G1|O9ZQSO'#JxO9ZQSO'#EnO%[QUO'#EnO9ZQSO'#IsO$'_Q(C[O,5@rOOQQ1G2v1G2vOOQQ1G4W1G4WOOQ(CY1G/u1G/uO!,iQSO1G/uO$)dQ(CjO1G0ROOQQ1G2r1G2rO!&dQ,UO1G2rO%[QUO1G2rO$*TQSO1G2rO$*`Q,UO'#EeOOQ(CW,5?z,5?zO$*jQ(C[O,5?zOOQQ1G.s1G.sO!@rQ(C[O1G.sO!@}QWO1G.sO!AVQ,UO1G.sO$*{QSO1G0oO$+QQSO'#CgO$+]QSO'#K[O$+eQSO,5=tO$+jQSO'#K[O$+oQSO'#K[O$+}QSO'#IyO$,]QSO,5@uO$,eQbO1G1dOOQ(CY1G1f1G1fO9aQSO1G3_O@bQSO1G3_O$,lQSO1G3_O$,qQSO1G3_OOQQ1G3_1G3_O!CTQSO1G2}O!&dQ,UO1G2zO$,vQSO1G2zOOQQ1G2{1G2{O!&dQ,UO1G2{O$,{QSO1G2{O$-TQWO'#GyOOQQ1G2}1G2}O!4eQWO'#IuO!CYQ`O1G3QOOQQ1G3Q1G3QOOQQ,5=k,5=kO$-]Q,UO,5=mO9aQSO,5=mO$!UQSO,5=oO9UQSO,5=oO!@}QWO,5=oO!AVQ,UO,5=oO:RQ,UO,5=oO$-kQSO'#KYO$-vQSO,5=pOOQQ1G.i1G.iO$-{Q(C[O1G.iO@bQSO1G.iO$.WQSO1G.iO9kQ(C[O1G.iO$0]QbO,5@wO$0mQSO,5@wO9ZQSO,5@wO$0xQUO,5=wO$1PQSO,5=wOOQQ1G3a1G3aO`QUO1G3aOOQQ1G3g1G3gOOQQ1G3i1G3iO>kQSO1G3kO$1UQUO1G3mO$5YQUO'#HlOOQQ1G3p1G3pO$5gQSO'#HrO>pQSO'#HtOOQQ1G3v1G3vO$5oQUO1G3vO9kQ(C[O1G3|OOQQ1G4O1G4OOOQ(CW'#GX'#GXO9kQ(C[O1G4QO9kQ(C[O1G4SO$9vQSO,5@XO!*fQUO,5;YO9ZQSO,5;YO>pQSO,5:SO!*fQUO,5:SO!@}QWO,5:SO$9{Q$IUO,5:SOOQO,5;Y,5;YO$:VQWO'#I]O$:mQSO,5@WOOQ(CY1G/m1G/mO$:uQWO'#IcO$;PQSO,5@fOOQ(CW1G0s1G0sO# xQWO,5:SOOQO'#I`'#I`O$;XQWO,5:nOOQ(CY,5:n,5:nO#%sQSO1G0WOOQ(CY1G0W1G0WO%[QUO1G0WOOQ(CY1G0n1G0nO>pQSO1G0nO!@}QWO1G0nO!AVQ,UO1G0nOOQ(CW1G5s1G5sO!@rQ(C[O1G0ZOOQO1G0g1G0gO%[QUO1G0gO$;`Q(C[O1G0gO$;kQ(C[O1G0gO!@}QWO1G0ZOCnQWO1G0ZO$;yQ(C[O1G0gOOQO1G0Z1G0ZO$<_Q(CjO1G0gPOOO-E<S-E<SPOOO1G.f1G.fOOOO1G/d1G/dO$<iQ`O,5<dO$<qQbO1G4bOOQO1G4h1G4hO%[QUO,5>vO$<{QSO1G5qO$=TQSO1G6OO$=]QbO1G6PO9ZQSO,5>|O$=gQ(CjO1G5|O%[QUO1G5|O$=wQ(C[O1G5|O$>YQSO1G5{O$>YQSO1G5{O9ZQSO1G5{O$>bQSO,5?PO9ZQSO,5?POOQO,5?P,5?PO$>vQSO,5?PO$'TQSO,5?POOQO-E<c-E<cOOQO1G0^1G0^OOQO1G0`1G0`O!,lQSO1G0`OOQQ7+(^7+(^O!&dQ,UO7+(^O%[QUO7+(^O$?UQSO7+(^O$?aQ,UO7+(^O$?oQ(CjO,5=QO$AzQ(CjO,5=SO$DVQ(CjO,5=QO$FhQ(CjO,5=SO$HyQ(CjO,59oO$KRQ(CjO,5<eO$M^Q(CjO,5<gO% iQ(CjO,5<uOOQ(CY7+&Z7+&ZO%#zQ(CjO7+&ZO%$nQ,UO'#I^O%$xQSO,5@YOOQ(CY1G/w1G/wO%%QQUO'#I_O%%_QSO,5@ZO%%gQbO,5@ZOOQ(CY1G/|1G/|O%%qQSO7+&dOOQ(CY7+&d7+&dO%%vQ$IUO,5:cO%[QUO7+&vO%&QQ$IUO,5:ZO%&_Q$IUO,5:gO%&iQ$IUO,5:iOOQ(CY7+&|7+&|OOQO1G1n1G1nOOQO1G1o1G1oO%&sQ#tO,5<VO!*fQUO,5<UOOQO-E<d-E<dOOQ(CY7+'U7+'UOOOO7+'a7+'aOOOO1G1x1G1xO%'OQSO1G1xOOQ(CY1G1z1G1zO%'TQ`O,59iOOOO-E<W-E<WOOQ(CY1G/R1G/RO%'[Q(CjO7+'gOOQ(CY,5?U,5?UO%(OQ`O,5?UOOQ(CY1G2`1G2`P!&dQ,UO'#IjPOQ(CY-E<h-E<hO%(nQ,UO,5?XOOQ(CY-E<k-E<kO%)aQ,UO,5?ZOOQ(CY-E<m-E<mO%)kQ`O1G2pOOQ(CY1G2X1G2XO%)rQSO'#IiO%*QQSO,5@mO%*QQSO,5@mO%*YQSO,5@mO%*eQSO,5@mOOQO1G2Z1G2ZO%*sQ,UO1G2YO!(SQ,UO1G2YO%+TQMhO'#IkO%+eQSO,5@nO!&dQ,UO,5@nO%+mQ`O,5@nOOQ(CY1G2^1G2^OOQ(CW,5<w,5<wOOQ(CW,5<x,5<xO$'TQSO,5<xOC_QSO,5<xO!@}QWO,5<wOOQO'#G`'#G`O%+wQSO,5<yOOQ(CW,5<{,5<{O$'TQSO,5=OOOQO,5?W,5?WOOQO-E<j-E<jOOQ(CY1G2b1G2bO!4eQWO,5<wO%,PQSO,5<xO$!PQSO,5<yO!4eQWO,5<xO!(SQ,UO'#ImO%,sQ,UO1G2lO!(SQ,UO'#IoO%-fQ,UO1G2nO%-pQ,UO1G5iO%-zQ,UO1G5iOOQO,5?],5?]OOQO-E<o-E<oOOQO1G.x1G.xO!7{QWO,59qO%[QUO,59qO%.XQSO1G2TO!(SQ,UO1G2[O%.^Q(CjO7+'hOOQ(CY7+'h7+'hO!$aQUO7+'hO%/QQSO,5;YOOQ(CW,5?_,5?_OOQ(CW-E<q-E<qOOQ(CY7+%a7+%aO%/VQ`O'#KTO#%sQSO7+(^O%/aQbO7+(^O$?XQSO7+(^O%/hQ(ChO'#CgO%/{Q(ChO,5<|O%0mQSO,5<|OOQ(CW1G5f1G5fOOQQ7+$_7+$_O!@rQ(C[O7+$_O!@}QWO7+$_O!$aQUO7+&ZO%0rQSO'#IxO%1ZQSO,5@vOOQO1G3`1G3`O9aQSO,5@vO%1ZQSO,5@vO%1cQSO,5@vOOQO,5?e,5?eOOQO-E<w-E<wOOQ(CY7+'O7+'OO%1hQSO7+(yO9kQ(C[O7+(yO9aQSO7+(yO@bQSO7+(yOOQQ7+(i7+(iO%1mQ(ChO7+(fO!&dQ,UO7+(fO%1wQ`O7+(gOOQQ7+(g7+(gO!&dQ,UO7+(gO%2OQSO'#KXO%2ZQSO,5=eOOQO,5?a,5?aOOQO-E<s-E<sOOQQ7+(l7+(lO%3jQWO'#HSOOQQ1G3X1G3XO!&dQ,UO1G3XO%[QUO1G3XO%3qQSO1G3XO%3|Q,UO1G3XO9kQ(C[O1G3ZO$!UQSO1G3ZO9UQSO1G3ZO!@}QWO1G3ZO!AVQ,UO1G3ZO%4[QSO'#IwO%4pQSO,5@tO%4xQWO,5@tOOQ(CW1G3[1G3[OOQQ7+$T7+$TO@bQSO7+$TO9kQ(C[O7+$TO%5TQSO7+$TO%[QUO1G6cO%[QUO1G6dO%5YQ(C[O1G6cO%5dQUO1G3cO%5kQSO1G3cO%5pQUO1G3cOOQQ7+({7+({O9kQ(C[O7+)VO`QUO7+)XOOQQ'#K_'#K_OOQQ'#Iz'#IzO%5wQUO,5>WOOQQ,5>W,5>WO%[QUO'#HmO%6UQSO'#HoOOQQ,5>^,5>^O9ZQSO,5>^OOQQ,5>`,5>`OOQQ7+)b7+)bOOQQ7+)h7+)hOOQQ7+)l7+)lOOQQ7+)n7+)nO%6ZQWO1G5sO%6oQ$IUO1G0tO%6yQSO1G0tOOQO1G/n1G/nO%7UQ$IUO1G/nO>pQSO1G/nO!*fQUO'#DhOOQO,5>w,5>wOOQO-E<Z-E<ZOOQO,5>},5>}OOQO-E<a-E<aO!@}QWO1G/nOOQO-E<^-E<^OOQ(CY1G0Y1G0YOOQ(CY7+%r7+%rO#%sQSO7+%rOOQ(CY7+&Y7+&YO>pQSO7+&YO!@}QWO7+&YOOQO7+%u7+%uO$<_Q(CjO7+&ROOQO7+&R7+&RO%[QUO7+&RO%7`Q(C[O7+&RO!@rQ(C[O7+%uO!@}QWO7+%uO%7kQ(C[O7+&RO%7yQ(CjO7++hO%[QUO7++hO%8ZQSO7++gO%8ZQSO7++gOOQO1G4k1G4kO9ZQSO1G4kO%8cQSO1G4kOOQO7+%z7+%zO#%sQSO<<KxO%/aQbO<<KxO%8qQSO<<KxOOQQ<<Kx<<KxO!&dQ,UO<<KxO%[QUO<<KxO%8yQSO<<KxO%9UQ(CjO,5?XO%;aQ(CjO,5?ZO%=lQ(CjO1G2YO%?}Q(CjO1G2lO%BYQ(CjO1G2nO%DeQ,UO,5>xOOQO-E<[-E<[O%DoQbO,5>yO%[QUO,5>yOOQO-E<]-E<]O%DyQSO1G5uOOQ(CY<<JO<<JOO%ERQ$IUO1G0oO%G]Q$IUO1G0yO%GdQ$IUO1G0yO%IhQ$IUO1G0yO%IoQ$IUO1G0yO%KdQ$IUO1G0yO%KzQ$IUO1G0yO%N_Q$IUO1G0yO%NfQ$IUO1G0yO&!jQ$IUO1G0yO&!qQ$IUO1G0yO&$iQ$IUO1G0yO&$|Q(CjO<<JbO&&RQ$IUO1G0yO&'wQ$IUO'#JdO&)zQ$IUO1G1_O&*XQ$IUO1G0RO!*fQUO'#FmOOQO'#KP'#KPOOQO1G1q1G1qO&*cQSO1G1pO&*hQ$IUO,5?SOOOO7+'d7+'dOOOO1G/T1G/TOOQ(CY1G4p1G4pO!(SQ,UO7+([O&*rQSO,5?TO9aQSO,5?TOOQO-E<g-E<gO&+QQSO1G6XO&+QQSO1G6XO&+YQSO1G6XO&+eQ,UO7+'tO&+uQ`O,5?VO&,PQSO,5?VO!&dQ,UO,5?VOOQO-E<i-E<iO&,UQ`O1G6YO&,`QSO1G6YOOQ(CW1G2d1G2dO$'TQSO1G2dOOQ(CW1G2c1G2cO&,hQSO1G2eO!&dQ,UO1G2eOOQ(CW1G2j1G2jO!@}QWO1G2cOC_QSO1G2dO&,mQSO1G2eO&,uQSO1G2dO&-iQ,UO,5?XOOQ(CY-E<l-E<lO&.[Q,UO,5?ZOOQ(CY-E<n-E<nO!(SQ,UO7++TOOQ(CY1G/]1G/]O&.fQSO1G/]OOQ(CY7+'o7+'oO&.kQ,UO7+'vO&.{Q(CjO<<KSOOQ(CY<<KS<<KSO&/oQSO1G0tO!&dQ,UO'#IrO&/tQSO,5@oO!&dQ,UO1G2hOOQQ<<Gy<<GyO!@rQ(C[O<<GyO&/|Q(CjO<<IuOOQ(CY<<Iu<<IuOOQO,5?d,5?dO&0pQSO,5?dO&0uQSO,5?dOOQO-E<v-E<vO&1TQSO1G6bO&1TQSO1G6bO9aQSO1G6bO@bQSO<<LeOOQQ<<Le<<LeO&1]QSO<<LeO9kQ(C[O<<LeOOQQ<<LQ<<LQO%1mQ(ChO<<LQOOQQ<<LR<<LRO%1wQ`O<<LRO&1bQWO'#ItO&1mQSO,5@sO!*fQUO,5@sOOQQ1G3P1G3PO&1uQUO'#JmOOQO'#Iv'#IvO9kQ(C[O'#IvO&2PQWO,5=nOOQQ,5=n,5=nO&2WQWO'#EaO&2lQSO7+(sO&2qQSO7+(sOOQQ7+(s7+(sO!&dQ,UO7+(sO%[QUO7+(sO&2yQSO7+(sOOQQ7+(u7+(uO9kQ(C[O7+(uO$!UQSO7+(uO9UQSO7+(uO!@}QWO7+(uO&3UQSO,5?cOOQO-E<u-E<uOOQO'#HV'#HVO&3aQSO1G6`O9kQ(C[O<<GoOOQQ<<Go<<GoO@bQSO<<GoO&3iQSO7++}O&3nQSO7+,OO%[QUO7++}O%[QUO7+,OOOQQ7+(}7+(}O&3sQSO7+(}O&3xQUO7+(}O&4PQSO7+(}OOQQ<<Lq<<LqOOQQ<<Ls<<LsOOQQ-E<x-E<xOOQQ1G3r1G3rO&4UQSO,5>XOOQQ,5>Z,5>ZO&4ZQSO1G3xO9ZQSO7+&`O!*fQUO7+&`OOQO7+%Y7+%YO&4`Q$IUO1G6PO>pQSO7+%YOOQ(CY<<I^<<I^OOQ(CY<<It<<ItO>pQSO<<ItOOQO<<Im<<ImO$<_Q(CjO<<ImO%[QUO<<ImOOQO<<Ia<<IaO!@rQ(C[O<<IaO&4jQ(C[O<<ImO&4uQ(CjO<= SO&5VQSO<= ROOQO7+*V7+*VO9ZQSO7+*VOOQQANAdANAdO&5_QSOANAdO!&dQ,UOANAdO#%sQSOANAdO%/aQbOANAdO%[QUOANAdO&5gQ(CjO7+'tO&7xQ(CjO,5?XO&:TQ(CjO,5?ZO&<`Q(CjO7+'vO&>qQbO1G4eO&>{Q$IUO7+&ZO&APQ$IUO,5=QO&CWQ$IUO,5=SO&ChQ$IUO,5=QO&CxQ$IUO,5=SO&DYQ$IUO,59oO&F]Q$IUO,5<eO&H`Q$IUO,5<gO&JcQ$IUO,5<uO&LXQ$IUO7+'gO&LfQ$IUO7+'hO&LsQSO,5<XOOQO7+'[7+'[O&LxQ,UO<<KvOOQO1G4o1G4oO&MPQSO1G4oO&M[QSO1G4oO&MjQSO7++sO&MjQSO7++sO!&dQ,UO1G4qO&MrQ`O1G4qO&M|QSO7++tOOQ(CW7+(O7+(OO$'TQSO7+(PO&NUQ`O7+(POOQ(CW7+'}7+'}O$'TQSO7+(OO&N]QSO7+(PO!&dQ,UO7+(POC_QSO7+(OO&NbQ,UO<<NoOOQ(CY7+$w7+$wO&NlQ`O,5?^OOQO-E<p-E<pO&NvQ(ChO7+(SOOQQAN=eAN=eO9aQSO1G5OOOQO1G5O1G5OO' WQSO1G5OO' ]QSO7++|O' ]QSO7++|O9kQ(C[OANBPO@bQSOANBPOOQQANBPANBPOOQQANAlANAlOOQQANAmANAmO' eQSO,5?`OOQO-E<r-E<rO' pQ$IUO1G6_O'$QQbO'#CgOOQO,5?b,5?bOOQO-E<t-E<tOOQQ1G3Y1G3YO&1uQUO,5<yOOQQ<<L_<<L_O!&dQ,UO<<L_O&2lQSO<<L_O'$[QSO<<L_O%[QUO<<L_OOQQ<<La<<LaO9kQ(C[O<<LaO$!UQSO<<LaO9UQSO<<LaO'$dQWO1G4}O'$oQSO7++zOOQQAN=ZAN=ZO9kQ(C[OAN=ZOOQQ<= i<= iOOQQ<= j<= jO'$wQSO<= iO'$|QSO<= jOOQQ<<Li<<LiO'%RQSO<<LiO'%WQUO<<LiOOQQ1G3s1G3sO>pQSO7+)dO'%_QSO<<IzO'%jQ$IUO<<IzOOQO<<Ht<<HtOOQ(CYAN?`AN?`OOQOAN?XAN?XO$<_Q(CjOAN?XOOQOAN>{AN>{O%[QUOAN?XOOQO<<Mq<<MqOOQQG27OG27OO!&dQ,UOG27OO#%sQSOG27OO'%tQSOG27OO%/aQbOG27OO'%|Q$IUO<<JbO'&ZQ$IUO1G2YO'(PQ$IUO,5?XO'*SQ$IUO,5?ZO',VQ$IUO1G2lO'.YQ$IUO1G2nO'0]Q$IUO<<KSO'0jQ$IUO<<IuOOQO1G1s1G1sO!(SQ,UOANAbOOQO7+*Z7+*ZO'0wQSO7+*ZO'1SQSO<= _O'1[Q`O7+*]OOQ(CW<<Kk<<KkO$'TQSO<<KkOOQ(CW<<Kj<<KjO'1fQ`O<<KkO$'TQSO<<KjOOQO7+*j7+*jO9aQSO7+*jO'1mQSO<= hOOQQG27kG27kO9kQ(C[OG27kO!*fQUO1G4zO'1uQSO7++yO&2lQSOANAyOOQQANAyANAyO!&dQ,UOANAyO'1}QSOANAyOOQQANA{ANA{O9kQ(C[OANA{O$!UQSOANA{OOQO'#HW'#HWOOQO7+*i7+*iOOQQG22uG22uOOQQANETANETOOQQANEUANEUOOQQANBTANBTO'2VQSOANBTOOQQ<<MO<<MOO!*fQUOAN?fOOQOG24sG24sO$<_Q(CjOG24sO#%sQSOLD,jOOQQLD,jLD,jO!&dQ,UOLD,jO'2[QSOLD,jO'2dQ$IUO7+'tO'4YQ$IUO,5?XO'6]Q$IUO,5?ZO'8`Q$IUO7+'vO':UQ,UOG26|OOQO<<Mu<<MuOOQ(CWANAVANAVO$'TQSOANAVOOQ(CWANAUANAUOOQO<<NU<<NUOOQQLD-VLD-VO':fQ$IUO7+*fOOQQG27eG27eO&2lQSOG27eO!&dQ,UOG27eOOQQG27gG27gO9kQ(C[OG27gOOQQG27oG27oO':pQ$IUOG25QOOQOLD*_LD*_OOQQ!$(!U!$(!UO#%sQSO!$(!UO!&dQ,UO!$(!UO':zQ(CjOG26|OOQ(CWG26qG26qOOQQLD-PLD-PO&2lQSOLD-POOQQLD-RLD-ROOQQ!)9Ep!)9EpO#%sQSO!)9EpOOQQ!$(!k!$(!kOOQQ!.K;[!.K;[O'=]Q$IUOG26|O!*fQUO'#DwO1PQSO'#EUO'?RQbO'#JiO!*fQUO'#DoO'?YQUO'#D{O'?aQbO'#CgO'AwQbO'#CgO!*fQUO'#D}O'BXQUO,5;TO!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO,5;_O!*fQUO'#IhO'D[QSO,5<dO'DdQ,UO,5;_O'E}Q,UO,5;_O!*fQUO,5;sO!&dQ,UO'#GfO'DdQ,UO'#GfO!&dQ,UO'#GhO'DdQ,UO'#GhO1SQSO'#DTO1SQSO'#DTO!&dQ,UO'#FyO'DdQ,UO'#FyO!&dQ,UO'#F{O'DdQ,UO'#F{O!&dQ,UO'#GZO'DdQ,UO'#GZO!*fQUO,5:gO!*fQUO,5@eO'BXQUO1G0oO'FUQ$IUO'#CgO!*fQUO1G1{O!&dQ,UO'#ImO'DdQ,UO'#ImO!&dQ,UO'#IoO'DdQ,UO'#IoO!&dQ,UO,5<nO'DdQ,UO,5<nO'BXQUO1G1|O!*fQUO7+&vO!&dQ,UO1G2YO'DdQ,UO1G2YO!&dQ,UO'#ImO'DdQ,UO'#ImO!&dQ,UO'#IoO'DdQ,UO'#IoO!&dQ,UO1G2[O'DdQ,UO1G2[O'BXQUO7+'hO'BXQUO7+&ZO!&dQ,UOANAbO'DdQ,UOANAbO'F`QSO'#EiO'FeQSO'#EiO'FmQSO'#FXO'FrQSO'#EsO'FwQSO'#JyO'GSQSO'#JwO'G_QSO,5;TO'GdQ,UO,5<aO'GkQSO'#GSO'GpQSO'#GSO'GuQSO,5<bO'G}QSO,5;TO'HVQ$IUO1G1[O'H^QSO,5<nO'HcQSO,5<nO'HhQSO,5<pO'HmQSO,5<pO'HrQSO1G1|O'HwQSO1G0oO'H|Q,UO<<KvO'ITQ,UO<<KvO7hQ,UO'#FwO9UQSO'#FvOA]QSO'#EhO!*fQUO,5;pO!3fQSO'#GSO!3fQSO'#GSO!3fQSO'#GUO!3fQSO'#GUO!(SQ,UO7+([O!(SQ,UO7+([O%)kQ`O1G2pO%)kQ`O1G2pO!&dQ,UO,5=UO!&dQ,UO,5=U",
      stateData:
        "'J^~O'sOS'tOSROS'uRQ~OPYOQYOW!VO_qObzOcyOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!YXO!duO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#q!PO$R|O$VfO%a}O%c!QO%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO%r!UO&O!WO&U!XO&W!YO&Y!ZO&[![O&_!]O&e!^O&k!_O&m!`O&o!aO&q!bO&s!cO'zSO'|TO(PUO(XVO(g[O(tiO~OUtO~P`OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'z!dO'|TO(PUO(XVO(g[O(tiO~O_!vOm!nO}!oO!]!xO!^!uO!_!uO!y:dO!}!pO#O!pO#P!wO#Q!pO#R!pO#U!yO#V!yO'{!lO'|TO(PUO([!mO(g!sO~O'u!zO~OPZXYZX_ZXlZXzZX{ZX}ZX!WZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX'qZX(XZX(hZX(oZX(pZX~O!b${X~P(qO]!|O'|#OO'}!|O(O#OO~O]#PO(O#OO(P#OO(Q#PO~Or#RO!P#SO(Y#SO(Z#UO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'z:hO'|TO(PUO(XVO(g[O(tiO~O!V#YO!W#VO!T(_P!T(lP~P+}O!X#bO~P`OPYOQYOb!jOc!iOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'|TO(PUO(XVO(g[O(tiO~Oj#lO!V#hO!y]O#c#kO#d#hO'z:iO!h(iP~P.iO!i#nO'z#mO~O!u#rO!y]O%a#sO~O#e#tO~O!b#uO#e#tO~OP$]OY$dOl$QOz#yO{#zO}#{O!W$aO!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(XVO(h$ZO(o#|O(p#}O~O_(]X'q(]X'o(]X!h(]X!T(]X!Y(]X%b(]X!b(]X~P1qO#Y$eO#|$eOP(^XY(^Xl(^Xz(^X{(^X}(^X!W(^X!f(^X!i(^X!m(^X#h(^X#i(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#r(^X#t(^X#v(^X#w(^X(X(^X(h(^X(o(^X(p(^X!Y(^X%b(^X~O_(^X!g(^X'q(^X'o(^X!T(^X!h(^Xp(^X!b(^X~P4XO#Y$eO~O$X$gO$Z$fO$b$lO~O!Y$mO$VfO$e$nO$g$pO~Oj%WOl$tOm$sOn$sOt%XOv%YOx%ZO}${O!Y$|O!d%`O!i$xO#d%aO$R%^O$n%[O$p%]O$s%_O'z$rO'|TO(PUO(T%VO(X$uO(o$}O(p%POe(UP~O!i%bO~O}%eO!Y%fO'z%dO~O!b%jO~O_%kO'q%kO~O'{!lO~P%[O%g%rO~P%[O!i%bO'z%dO'{!lO(T%VO~Oc%yO!i%bO'z%dO~O#p$SO~Oz&OO!Y%{O!i%}O%c&RO'z%dO'{!lO'|TO(PUO^(}P~O!u#rO~O%l&TO}(yX!Y(yX'z(yX~O'z&UO~O!r&ZO#q!PO%c!QO%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO~Ob&`Oc&_O!u&]O%a&^O%t&[O~P;xOb&cOcyO!Y&bO!r&ZO!uxO!y]O#q!PO%a}O%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO%r!UO~O`&fO#Y&iO%c&dO'{!lO~P<}O!i&jO!r&nO~O!i#nO~O!YXO~O_%kO'p&vO'q%kO~O_%kO'p&yO'q%kO~O_%kO'p&{O'q%kO~O'oZX!TZXpZX!hZX&SZX!YZX%bZX!bZX~P(qO!]'YO!^'RO!_'RO'{!lO'|TO(PUO~Om'PO}'OO!V'SO([&}O!X(`P!X(nP~P@UOh']O!Y'ZO'z%dO~Oc'bO!i%bO'z%dO~Oz&OO!i%}O~Om!nO}!oO!y:dO!}!pO#O!pO#Q!pO#R!pO'{!lO'|TO(PUO([!mO(g!sO~O!]'hO!^'gO!_'gO#P!pO#U'iO#V'iO~PApO_%kO!b#uO!i%bO'q%kO(T%VO(h'kO~O!m'oO#Y'mO~PCOOm!nO}!oO'|TO(PUO([!mO(g!sO~O!YXOm(eX}(eX!](eX!^(eX!_(eX!y(eX!}(eX#O(eX#P(eX#Q(eX#R(eX#U(eX#V(eX'{(eX'|(eX(P(eX([(eX(g(eX~O!^'gO!_'gO'{!lO~PCnO'v'sO'w'sO'x'uO~O]!|O'|'wO'}!|O(O'wO~O]#PO(O'wO(P'wO(Q#PO~Or#RO!P#SO(Y#SO(Z'{O~O!V'}O!T'OX!T'UX!W'OX!W'UX~P+}O!W(PO!T(_X~OP$]OY$dOl$QOz#yO{#zO}#{O!W(PO!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(XVO(h$ZO(o#|O(p#}O~O!T(_X~PGbO!T(UO~O!T(kX!W(kX!b(kX!h(kX(h(kX~O#Y(kX#e#^X!X(kX~PIhO#Y(VO!T(mX!W(mX~O!W(WO!T(lX~O!T(ZO~O#Y$eO~PIhO!X([O~P`Oz#yO{#zO}#{O!g#wO!i#xO(XVOP!kaY!kal!ka!W!ka!f!ka!m!ka#h!ka#i!ka#j!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#r!ka#t!ka#v!ka#w!ka(h!ka(o!ka(p!ka~O_!ka'q!ka'o!ka!T!ka!h!kap!ka!Y!ka%b!ka!b!ka~PKOO!h(]O~O!b#uO#Y(^O(h'kO!W(jX_(jX'q(jX~O!h(jX~PMnO}%eO!Y%fO!y]O#c(cO#d(bO'z%dO~O!W(dO!h(iX~O!h(fO~O}%eO!Y%fO#d(bO'z%dO~OP(^XY(^Xl(^Xz(^X{(^X}(^X!W(^X!f(^X!g(^X!i(^X!m(^X#h(^X#i(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#r(^X#t(^X#v(^X#w(^X(X(^X(h(^X(o(^X(p(^X~O!b#uO!h(^X~P! [Oz(gO{(hO!g#wO!i#xO!y!xa}!xa~O!u!xa%a!xa!Y!xa#c!xa#d!xa'z!xa~P!#`O!u(lO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!YXO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'z!dO'|TO(PUO(XVO(g[O(tiO~Oj%WOl$tOm$sOn$sOt%XOv%YOx;QO}${O!Y$|O!d<`O!i$xO#d;WO$R%^O$n;SO$p;UO$s%_O'z(pO'|TO(PUO(T%VO(X$uO(o$}O(p%PO~O#e(rO~Oj%WOl$tOm$sOn$sOt%XOv%YOx%ZO}${O!Y$|O!d%`O!i$xO#d%aO$R%^O$n%[O$p%]O$s%_O'z(pO'|TO(PUO(T%VO(X$uO(o$}O(p%PO~Oe(bP~P!(SO!V(vO!h(cP~P%[O([(xO(g[O~O}(zO!i#xO([(xO(g[O~OP:cOQ:cOb<[Oc!iOjkOl:cOmkOnkOtkOv:cOx:cO}WO!RkO!SkO!Y!eO!d:fO!iZO!l:cO!m:cO!n:cO!p:gO!r:jO!u!hO$R!kO$VfO'z)YO'|TO(PUO(XVO(g[O(t<YO~O{)]O!i#xO~O!W$aO_$la'q$la'o$la!h$la!T$la!Y$la%b$la!b$la~O#q)aO~P!&dOz)dO!b)cO!Y$YX$U$YX$X$YX$Z$YX$b$YX~O!b)cO!Y(qX$U(qX$X(qX$Z(qX$b(qX~Oz)dO~P!.OOz)dO!Y(qX$U(qX$X(qX$Z(qX$b(qX~O!Y)fO$U)jO$X)eO$Z)eO$b)kO~O!V)nO~P!*fO$X$gO$Z$fO$b)rO~Oh$tXz$tX}$tX!g$tX(o$tX(p$tX~OegXe$tXhgX!WgX#YgX~P!/tOm)tO~Or)uO(Y)vO(Z)xO~Oh*ROz)zO}){O(o$}O(p%PO~Oe)yO~P!0}Oe*SO~Oj%WOl$tOm$sOn$sOt%XOv%YOx;QO}${O!Y$|O!d<`O!i$xO#d;WO$R%^O$n;SO$p;UO$s%_O'|TO(PUO(T%VO(X$uO(o$}O(p%PO~O!V*WO'z*TO!h(uP~P!1lO#e*YO~O!i*ZO~O!V*`O'z*]O!T(vP~P!1lOl*lO}*dO!]*jO!^*cO!_*cO!i*ZO#U*kO%X*fO'{!lO([!mO~O!X*iO~P!3xO!g#wOh(WXz(WX}(WX(o(WX(p(WX!W(WX#Y(WX~Oe(WX#z(WX~P!4qOh*qO#Y*pOe(VX!W(VX~O!W*rOe(UX~O'z&UOe(UP~O!i*yO~O'z(pO~Oj*}O}%eO!V#hO!Y%fO!y]O#c#kO#d#hO'z%dO!h(iP~O!b#uO#e+OO~O}%eO!V+QO!W(WO!Y%fO'z%dO!T(lP~Om'VO}+SO!V+RO'|TO(PUO([(xO~O!X(nP~P!7lO!W+TO_(zX'q(zX~OP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(XVO(h$ZO(o#|O(p#}O~O_!ca!W!ca'q!ca'o!ca!T!ca!h!cap!ca!Y!ca%b!ca!b!ca~P!8dOz#yO{#zO}#{O!g#wO!i#xO(XVOP!oaY!oal!oa!W!oa!f!oa!m!oa#h!oa#i!oa#j!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#r!oa#t!oa#v!oa#w!oa(h!oa(o!oa(p!oa~O_!oa'q!oa'o!oa!T!oa!h!oap!oa!Y!oa%b!oa!b!oa~P!:}Oz#yO{#zO}#{O!g#wO!i#xO(XVOP!qaY!qal!qa!W!qa!f!qa!m!qa#h!qa#i!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#r!qa#t!qa#v!qa#w!qa(h!qa(o!qa(p!qa~O_!qa'q!qa'o!qa!T!qa!h!qap!qa!Y!qa%b!qa!b!qa~P!=hOh+^O!Y'ZO%b+]O(T%VO~O!b+`O_(SX!Y(SX'q(SX!W(SX~O_%kO!YXO'q%kO~O!i%bO(T%VO~O!i%bO'z%dO(T%VO~O!b#uO#e(rO~O`+kO%c+lO'z+hO'|TO(PUO!X)OP~O!W+mO^(}X~OY+qO~O^+rO~O!Y%{O'z%dO'{!lO^(}P~O#Y+wO(T%VO~Oh+zO!Y$|O(T%VO~O!Y+|O~Oz,OO!YXO~O%g%rO~O!u,TO~Oc,YO~O`,ZO'z#mO'|TO(PUO!X(|P~Oc%yO~O%c!QO'z&UO~P<}OY,`O^,_O~OPYOQYObzOcyOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!duO!iZO!lYO!mYO!nYO!pvO!uxO!y]O$VfO%a}O'|TO(PUO(XVO(g[O(tiO~O!Y!eO!r!gO$R!kO'z!dO~P!DkO^,_O_%kO'q%kO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!u!hO$R!kO$VfO'z!dO'|TO(PUO(XVO(g[O(tiO~O_,eO!rwO#q!OO%e!OO%f!OO%g!OO~P!GTO!i&jO~O&U,kO~O!Y,mO~O&g,oO&i,pOP&daQ&daW&da_&dab&dac&daj&dal&dam&dan&dat&dav&dax&da}&da!R&da!S&da!Y&da!d&da!i&da!l&da!m&da!n&da!p&da!r&da!u&da!y&da#q&da$R&da$V&da%a&da%c&da%e&da%f&da%g&da%j&da%l&da%o&da%p&da%r&da&O&da&U&da&W&da&Y&da&[&da&_&da&e&da&k&da&m&da&o&da&q&da&s&da'o&da'z&da'|&da(P&da(X&da(g&da(t&da!X&da&]&da`&da&b&da~O'z,uO~O!W|X!W!`X!X|X!X!`X!b|X!b!`X!i!`X#Y|X(T!`X~O!b,zO#Y,yO!W#bX!W(aX!X#bX!X(aX!b(aX!i(aX(T(aX~O!b,|O!i%bO(T%VO!W![X!X![X~Om!nO}!oO'|TO(PUO([!mO~OP:cOQ:cOb<[Oc!iOjkOl:cOmkOnkOtkOv:cOx:cO}WO!RkO!SkO!Y!eO!d:fO!iZO!l:cO!m:cO!n:cO!p:gO!r:jO!u!hO$R!kO$VfO'|TO(PUO(XVO(g[O(t<YO~O'z;]O~P#!ZO!W-QO!X(`X~O!X-SO~O!b,zO#Y,yO!W#bX!X#bX~O!W-TO!X(nX~O!X-VO~O!^-WO!_-WO'{!lO~P# xO!X-ZO~P'_Oh-^O!Y'ZO~O!T-cO~Om!xa!]!xa!^!xa!_!xa!}!xa#O!xa#P!xa#Q!xa#R!xa#U!xa#V!xa'{!xa'|!xa(P!xa([!xa(g!xa~P!#`O!m-hO#Y-fO~PCOO!^-jO!_-jO'{!lO~PCnO_%kO#Y-fO'q%kO~O_%kO!b#uO#Y-fO'q%kO~O_%kO!b#uO!m-hO#Y-fO'q%kO(h'kO~O'v'sO'w'sO'x-oO~Op-pO~O!T'Oa!W'Oa~P!8dO!V-tO!T'OX!W'OX~P%[O!W(PO!T(_a~O!T(_a~PGbO!W(WO!T(la~O}%eO!V-xO!Y%fO'z%dO!T'UX!W'UX~O#Y-zO!W(ja!h(ja_(ja'q(ja~O!b#uO~P#*aO!W(dO!h(ia~O}%eO!Y%fO#d.OO'z%dO~Oj.TO}%eO!V.QO!Y%fO!y]O#c.SO#d.QO'z%dO!W'XX!h'XX~O{.XO!i#xO~Oh.[O!Y'ZO%b.ZO(T%VO~O_#]i!W#]i'q#]i'o#]i!T#]i!h#]ip#]i!Y#]i%b#]i!b#]i~P!8dOh<fOz)zO}){O(o$}O(p%PO~O#e#Xa_#Xa#Y#Xa'q#Xa!W#Xa!h#Xa!Y#Xa!T#Xa~P#-]O#e(WXP(WXY(WX_(WXl(WX{(WX!f(WX!i(WX!m(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#r(WX#t(WX#v(WX#w(WX'q(WX(X(WX(h(WX!h(WX!T(WX'o(WXp(WX!Y(WX%b(WX!b(WX~P!4qO!W.iOe(bX~P!0}Oe.kO~O!W.lO!h(cX~P!8dO!h.oO~O!T.qO~OP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O(XVOY#gi_#gil#gi!W#gi!f#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'q#gi(h#gi(o#gi(p#gi'o#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O#h#gi~P#1XO#h$OO~P#1XOP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO(XVOY#gi_#gi!W#gi!f#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'q#gi(h#gi(o#gi(p#gi'o#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~Ol#gi~P#3yOl$QO~P#3yOP$]Ol$QOz#yO{#zO}#{O!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO(XVO_#gi!W#gi#r#gi#t#gi#v#gi#w#gi'q#gi(h#gi(o#gi(p#gi'o#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~OY#gi!f#gi#m#gi#n#gi#o#gi#p#gi~P#6kOY$dO!f$SO#m$SO#n$SO#o$cO#p$SO~P#6kOP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO(XVO_#gi!W#gi#t#gi#v#gi#w#gi'q#gi(h#gi(p#gi'o#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O(o#gi~P#9lO(o#|O~P#9lOP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO(XVO(o#|O_#gi!W#gi#v#gi#w#gi'q#gi(h#gi'o#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O(p#gi~P#<^O(p#}O~P#<^OP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO(XVO(o#|O(p#}O~O_#gi!W#gi#w#gi'q#gi(h#gi'o#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~P#?OOPZXYZXlZXzZX{ZX}ZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(XZX(hZX(oZX(pZX!WZX!XZX~O#zZX~P#AiOP$]OY:zOl:nOz#yO{#zO}#{O!f:pO!g#wO!i#xO!m$]O#h:lO#i:mO#j:mO#k:mO#l:oO#m:pO#n:pO#o:yO#p:pO#r:qO#t:sO#v:uO#w:vO(XVO(h$ZO(o#|O(p#}O~O#z.sO~P#CvO#Y:{O#|:{O#z(^X!X(^X~P! [O_'[a!W'[a'q'[a'o'[a!h'[a!T'[ap'[a!Y'[a%b'[a!b'[a~P!8dOP#giY#gi_#gil#gi{#gi!W#gi!f#gi!g#gi!i#gi!m#gi#h#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'q#gi(X#gi(h#gi'o#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~P#-]O_#{i!W#{i'q#{i'o#{i!T#{i!h#{ip#{i!Y#{i%b#{i!b#{i~P!8dO$X.xO$Z.xO~O$X.yO$Z.yO~O!b)cO#Y.zO!Y$_X$U$_X$X$_X$Z$_X$b$_X~O!V.{O~O!Y)fO$U.}O$X)eO$Z)eO$b/OO~O!W:wO!X(]X~P#CvO!X/PO~O!b)cO$b(qX~O$b/RO~Or)uO(Y)vO(Z/UO~O!T/YO~P!&dO(o$}Oh%Yaz%Ya}%Ya(p%Ya!W%Ya#Y%Ya~Oe%Ya#z%Ya~P#LWO(p%POh%[az%[a}%[a(o%[a!W%[a#Y%[a~Oe%[a#z%[a~P#LyO!WdX!bdX!hdX!h$tX(hdX~P!/tO!h/bO~P#-]O!W/cO!b#uO(h'kO!h(uX~O!h/hO~O!V*WO'z%dO!h(uP~O#e/jO~O!T$tX!W$tX!b${X~P!/tO!W/kO!T(vX~P#-]O!b/mO~O!T/oO~Ol/sO!b#uO!i%bO(T%VO(h'kO~O'z/uO~O!b+`O~O_%kO!W/yO'q%kO~O!X/{O~P!3xO!^/|O!_/|O'{!lO([!mO~O}0OO([!mO~O#U0PO~Oe%Ya!W%Ya#Y%Ya#z%Ya~P!0}Oe%[a!W%[a#Y%[a#z%[a~P!0}O'z&UOe'eX!W'eX~O!W*rOe(Ua~Oe0YO~Oz0ZO{0ZO}0[Ohwa(owa(pwa!Wwa#Ywa~Oewa#zwa~P$$dOz)zO}){Oh$ma(o$ma(p$ma!W$ma#Y$ma~Oe$ma#z$ma~P$%YOz)zO}){Oh$oa(o$oa(p$oa!W$oa#Y$oa~Oe$oa#z$oa~P$%{O#e0^O~Oe$}a!W$}a#Y$}a#z$}a~P!0}O!b#uO~O#e0aO~O!W+TO_(za'q(za~Oz#yO{#zO}#{O!g#wO!i#xO(XVOP!oiY!oil!oi!W!oi!f!oi!m!oi#h!oi#i!oi#j!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#r!oi#t!oi#v!oi#w!oi(h!oi(o!oi(p!oi~O_!oi'q!oi'o!oi!T!oi!h!oip!oi!Y!oi%b!oi!b!oi~P$'jOh.[O!Y'ZO%b.ZO~Oj0kO'z0jO~P!1oO!b+`O_(Sa!Y(Sa'q(Sa!W(Sa~O#e0qO~OYZX!WdX!XdX~O!W0rO!X)OX~O!X0tO~OY0uO~O`0wO'z+hO'|TO(PUO~O!Y%{O'z%dO^'mX!W'mX~O!W+mO^(}a~O!h0zO~P!8dOY0}O~O^1OO~O#Y1RO~Oh1UO!Y$|O~O([(xO!X({P~Oh1_O!Y1[O%b1^O(T%VO~OY1iO!W1gO!X(|X~O!X1jO~O^1lO_%kO'q%kO~O'z#mO'|TO(PUO~O#Y$eO#|$eOP(^XY(^Xl(^Xz(^X{(^X}(^X!W(^X!f(^X!i(^X!m(^X#h(^X#i(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#r(^X#t(^X#v(^X#w(^X(X(^X(h(^X(o(^X(p(^X~O#p1oO&S1pO_(^X!g(^X~P$.cO#Y$eO#p1oO&S1pO~O_1rO~P%[O_1tO~O&]1wOP&ZiQ&ZiW&Zi_&Zib&Zic&Zij&Zil&Zim&Zin&Zit&Ziv&Zix&Zi}&Zi!R&Zi!S&Zi!Y&Zi!d&Zi!i&Zi!l&Zi!m&Zi!n&Zi!p&Zi!r&Zi!u&Zi!y&Zi#q&Zi$R&Zi$V&Zi%a&Zi%c&Zi%e&Zi%f&Zi%g&Zi%j&Zi%l&Zi%o&Zi%p&Zi%r&Zi&O&Zi&U&Zi&W&Zi&Y&Zi&[&Zi&_&Zi&e&Zi&k&Zi&m&Zi&o&Zi&q&Zi&s&Zi'o&Zi'z&Zi'|&Zi(P&Zi(X&Zi(g&Zi(t&Zi!X&Zi`&Zi&b&Zi~O`1}O!X1{O&b1|O~P`O!YXO!i2PO~O&i,pOP&diQ&diW&di_&dib&dic&dij&dil&dim&din&dit&div&dix&di}&di!R&di!S&di!Y&di!d&di!i&di!l&di!m&di!n&di!p&di!r&di!u&di!y&di#q&di$R&di$V&di%a&di%c&di%e&di%f&di%g&di%j&di%l&di%o&di%p&di%r&di&O&di&U&di&W&di&Y&di&[&di&_&di&e&di&k&di&m&di&o&di&q&di&s&di'o&di'z&di'|&di(P&di(X&di(g&di(t&di!X&di&]&di`&di&b&di~O!T2VO~O!W![a!X![a~P#CvOm!nO}!oO!V2]O([!mO!W'PX!X'PX~P@UO!W-QO!X(`a~O!W'VX!X'VX~P!7lO!W-TO!X(na~O!X2dO~P'_O_%kO#Y2mO'q%kO~O_%kO!b#uO#Y2mO'q%kO~O_%kO!b#uO!m2qO#Y2mO'q%kO(h'kO~O_%kO'q%kO~P!8dO!W$aOp$la~O!T'Oi!W'Oi~P!8dO!W(PO!T(_i~O!W(WO!T(li~O!T(mi!W(mi~P!8dO!W(ji!h(ji_(ji'q(ji~P!8dO#Y2sO!W(ji!h(ji_(ji'q(ji~O!W(dO!h(ii~O}%eO!Y%fO!y]O#c2xO#d2wO'z%dO~O}%eO!Y%fO#d2wO'z%dO~Oh3PO!Y'ZO%b3OO~Oh3PO!Y'ZO%b3OO(T%VO~O#e%YaP%YaY%Ya_%Yal%Ya{%Ya!f%Ya!g%Ya!i%Ya!m%Ya#h%Ya#i%Ya#j%Ya#k%Ya#l%Ya#m%Ya#n%Ya#o%Ya#p%Ya#r%Ya#t%Ya#v%Ya#w%Ya'q%Ya(X%Ya(h%Ya!h%Ya!T%Ya'o%Yap%Ya!Y%Ya%b%Ya!b%Ya~P#LWO#e%[aP%[aY%[a_%[al%[a{%[a!f%[a!g%[a!i%[a!m%[a#h%[a#i%[a#j%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#r%[a#t%[a#v%[a#w%[a'q%[a(X%[a(h%[a!h%[a!T%[a'o%[ap%[a!Y%[a%b%[a!b%[a~P#LyO#e%YaP%YaY%Ya_%Yal%Ya{%Ya!W%Ya!f%Ya!g%Ya!i%Ya!m%Ya#h%Ya#i%Ya#j%Ya#k%Ya#l%Ya#m%Ya#n%Ya#o%Ya#p%Ya#r%Ya#t%Ya#v%Ya#w%Ya'q%Ya(X%Ya(h%Ya!h%Ya!T%Ya'o%Ya#Y%Yap%Ya!Y%Ya%b%Ya!b%Ya~P#-]O#e%[aP%[aY%[a_%[al%[a{%[a!W%[a!f%[a!g%[a!i%[a!m%[a#h%[a#i%[a#j%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#r%[a#t%[a#v%[a#w%[a'q%[a(X%[a(h%[a!h%[a!T%[a'o%[a#Y%[ap%[a!Y%[a%b%[a!b%[a~P#-]O#ewaPwaYwa_walwa!fwa!gwa!iwa!mwa#hwa#iwa#jwa#kwa#lwa#mwa#nwa#owa#pwa#rwa#twa#vwa#wwa'qwa(Xwa(hwa!hwa!Twa'owapwa!Ywa%bwa!bwa~P$$dO#e$maP$maY$ma_$mal$ma{$ma!f$ma!g$ma!i$ma!m$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#o$ma#p$ma#r$ma#t$ma#v$ma#w$ma'q$ma(X$ma(h$ma!h$ma!T$ma'o$map$ma!Y$ma%b$ma!b$ma~P$%YO#e$oaP$oaY$oa_$oal$oa{$oa!f$oa!g$oa!i$oa!m$oa#h$oa#i$oa#j$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#r$oa#t$oa#v$oa#w$oa'q$oa(X$oa(h$oa!h$oa!T$oa'o$oap$oa!Y$oa%b$oa!b$oa~P$%{O#e$}aP$}aY$}a_$}al$}a{$}a!W$}a!f$}a!g$}a!i$}a!m$}a#h$}a#i$}a#j$}a#k$}a#l$}a#m$}a#n$}a#o$}a#p$}a#r$}a#t$}a#v$}a#w$}a'q$}a(X$}a(h$}a!h$}a!T$}a'o$}a#Y$}ap$}a!Y$}a%b$}a!b$}a~P#-]O_#]q!W#]q'q#]q'o#]q!T#]q!h#]qp#]q!Y#]q%b#]q!b#]q~P!8dOe'QX!W'QX~P!(SO!W.iOe(ba~O!V3ZO!W'RX!h'RX~P%[O!W.lO!h(ca~O!W.lO!h(ca~P!8dO!T3^O~O#z!ka!X!ka~PKOO#z!ca!W!ca!X!ca~P#CvO#z!oa!X!oa~P!:}O#z!qa!X!qa~P!=hO!Y3pO$VfO$`3qO~O!X3uO~Op3vO~P#-]O_$iq!W$iq'q$iq'o$iq!T$iq!h$iqp$iq!Y$iq%b$iq!b$iq~P!8dO!T3wO~P#-]Oz)zO}){O(p%POh'aa(o'aa!W'aa#Y'aa~Oe'aa#z'aa~P%(VOz)zO}){Oh'ca(o'ca(p'ca!W'ca#Y'ca~Oe'ca#z'ca~P%(xO(h$ZO~P#-]O!V3zO'z%dO!W']X!h']X~O!W/cO!h(ua~O!W/cO!b#uO!h(ua~O!W/cO!b#uO(h'kO!h(ua~Oe$vi!W$vi#Y$vi#z$vi~P!0}O!V4SO'z*]O!T'_X!W'_X~P!1lO!W/kO!T(va~O!W/kO!T(va~P#-]O!b#uO#p4[O~Ol4_O!b#uO(h'kO~O(o$}Oh%Yiz%Yi}%Yi(p%Yi!W%Yi#Y%Yi~Oe%Yi#z%Yi~P%,[O(p%POh%[iz%[i}%[i(o%[i!W%[i#Y%[i~Oe%[i#z%[i~P%,}Oe(Vi!W(Vi~P!0}O#Y4fOe(Vi!W(Vi~P!0}O!h4iO~O_$jq!W$jq'q$jq'o$jq!T$jq!h$jqp$jq!Y$jq%b$jq!b$jq~P!8dO!T4mO~O!W4nO!Y(wX~P#-]O!g#wO~P4XO_$tX!Y$tX%VZX'q$tX!W$tX~P!/tO%V4pO_iXhiXziX}iX!YiX'qiX(oiX(piX!WiX~O%V4pO~O`4vO%c4wO'z+hO'|TO(PUO!W'lX!X'lX~O!W0rO!X)Oa~OY4{O~O^4|O~O_%kO'q%kO~P#-]O!Y$|O~P#-]O!W5UO#Y5WO!X({X~O!X5XO~Om!nO}5YO!]!xO!^!uO!_!uO!y:dO!}!pO#O!pO#P!pO#Q!pO#R!pO#U5_O#V!yO'{!lO'|TO(PUO([!mO(g!sO~O!X5^O~P%2`Oh5dO!Y1[O%b5cO~Oh5dO!Y1[O%b5cO(T%VO~O`5kO'z#mO'|TO(PUO!W'kX!X'kX~O!W1gO!X(|a~O'|TO(PUO([5mO~O^5qO~O#p5tO&S5uO~PMnO!h5vO~P%[O_5xO~O_5xO~P%[O`1}O!X5}O&b1|O~P`O!b6PO~O!b6RO!W(ai!X(ai!b(ai!i(ai(T(ai~O!W#bi!X#bi~P#CvO#Y6SO!W#bi!X#bi~O!W![i!X![i~P#CvO_%kO#Y6]O'q%kO~O_%kO!b#uO#Y6]O'q%kO~O!W(jq!h(jq_(jq'q(jq~P!8dO!W(dO!h(iq~O}%eO!Y%fO#d6dO'z%dO~O!Y'ZO%b6gO~Oh6jO!Y'ZO%b6gO~O#e'aaP'aaY'aa_'aal'aa{'aa!f'aa!g'aa!i'aa!m'aa#h'aa#i'aa#j'aa#k'aa#l'aa#m'aa#n'aa#o'aa#p'aa#r'aa#t'aa#v'aa#w'aa'q'aa(X'aa(h'aa!h'aa!T'aa'o'aap'aa!Y'aa%b'aa!b'aa~P%(VO#e'caP'caY'ca_'cal'ca{'ca!f'ca!g'ca!i'ca!m'ca#h'ca#i'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#r'ca#t'ca#v'ca#w'ca'q'ca(X'ca(h'ca!h'ca!T'ca'o'cap'ca!Y'ca%b'ca!b'ca~P%(xO#e$viP$viY$vi_$vil$vi{$vi!W$vi!f$vi!g$vi!i$vi!m$vi#h$vi#i$vi#j$vi#k$vi#l$vi#m$vi#n$vi#o$vi#p$vi#r$vi#t$vi#v$vi#w$vi'q$vi(X$vi(h$vi!h$vi!T$vi'o$vi#Y$vip$vi!Y$vi%b$vi!b$vi~P#-]O#e%YiP%YiY%Yi_%Yil%Yi{%Yi!f%Yi!g%Yi!i%Yi!m%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#o%Yi#p%Yi#r%Yi#t%Yi#v%Yi#w%Yi'q%Yi(X%Yi(h%Yi!h%Yi!T%Yi'o%Yip%Yi!Y%Yi%b%Yi!b%Yi~P%,[O#e%[iP%[iY%[i_%[il%[i{%[i!f%[i!g%[i!i%[i!m%[i#h%[i#i%[i#j%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#r%[i#t%[i#v%[i#w%[i'q%[i(X%[i(h%[i!h%[i!T%[i'o%[ip%[i!Y%[i%b%[i!b%[i~P%,}Oe'Qa!W'Qa~P!0}O!W'Ra!h'Ra~P!8dO!W.lO!h(ci~O#z#]i!W#]i!X#]i~P#CvOP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O(XVOY#gil#gi!f#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(h#gi(o#gi(p#gi!W#gi!X#gi~O#h#gi~P%E`O#h:lO~P%E`OP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h:lO#i:mO#j:mO#k:mO(XVOY#gi!f#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(h#gi(o#gi(p#gi!W#gi!X#gi~Ol#gi~P%GkOl:nO~P%GkOP$]Ol:nOz#yO{#zO}#{O!g#wO!i#xO!m$]O#h:lO#i:mO#j:mO#k:mO#l:oO(XVO#r#gi#t#gi#v#gi#w#gi#z#gi(h#gi(o#gi(p#gi!W#gi!X#gi~OY#gi!f#gi#m#gi#n#gi#o#gi#p#gi~P%IvOY:zO!f:pO#m:pO#n:pO#o:yO#p:pO~P%IvOP$]OY:zOl:nOz#yO{#zO}#{O!f:pO!g#wO!i#xO!m$]O#h:lO#i:mO#j:mO#k:mO#l:oO#m:pO#n:pO#o:yO#p:pO#r:qO(XVO#t#gi#v#gi#w#gi#z#gi(h#gi(p#gi!W#gi!X#gi~O(o#gi~P%LbO(o#|O~P%LbOP$]OY:zOl:nOz#yO{#zO}#{O!f:pO!g#wO!i#xO!m$]O#h:lO#i:mO#j:mO#k:mO#l:oO#m:pO#n:pO#o:yO#p:pO#r:qO#t:sO(XVO(o#|O#v#gi#w#gi#z#gi(h#gi!W#gi!X#gi~O(p#gi~P%NmO(p#}O~P%NmOP$]OY:zOl:nOz#yO{#zO}#{O!f:pO!g#wO!i#xO!m$]O#h:lO#i:mO#j:mO#k:mO#l:oO#m:pO#n:pO#o:yO#p:pO#r:qO#t:sO#v:uO(XVO(o#|O(p#}O~O#w#gi#z#gi(h#gi!W#gi!X#gi~P&!xO_#xy!W#xy'q#xy'o#xy!T#xy!h#xyp#xy!Y#xy%b#xy!b#xy~P!8dOh<gOz)zO}){O(o$}O(p%PO~OP#giY#gil#gi{#gi!f#gi!g#gi!i#gi!m#gi#h#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(X#gi(h#gi!W#gi!X#gi~P&%pO!g#wOP(WXY(WXh(WXl(WXz(WX{(WX}(WX!f(WX!i(WX!m(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#r(WX#t(WX#v(WX#w(WX#z(WX(X(WX(h(WX(o(WX(p(WX!W(WX!X(WX~O#z#{i!W#{i!X#{i~P#CvO#z!oi!X!oi~P$'jO!X6|O~O!W'[a!X'[a~P#CvO!b#uO(h'kO!W']a!h']a~O!W/cO!h(ui~O!W/cO!b#uO!h(ui~Oe$vq!W$vq#Y$vq#z$vq~P!0}O!T'_a!W'_a~P#-]O!b7TO~O!W/kO!T(vi~P#-]O!W/kO!T(vi~O!T7XO~O!b#uO#p7^O~Ol7_O!b#uO(h'kO~Oz)zO}){O(p%POh'ba(o'ba!W'ba#Y'ba~Oe'ba#z'ba~P&-QOz)zO}){Oh'da(o'da(p'da!W'da#Y'da~Oe'da#z'da~P&-sO!T7aO~Oe$xq!W$xq#Y$xq#z$xq~P!0}O_$jy!W$jy'q$jy'o$jy!T$jy!h$jyp$jy!Y$jy%b$jy!b$jy~P!8dO!b6RO~O!W4nO!Y(wa~O_#]y!W#]y'q#]y'o#]y!T#]y!h#]yp#]y!Y#]y%b#]y!b#]y~P!8dOY7fO~O`7hO'z+hO'|TO(PUO~O!W0rO!X)Oi~O^7lO~O([(xO!W'hX!X'hX~O!W5UO!X({a~OjkO'z7sO~P.iO!X7vO~P%2`Om!nO}7wO'|TO(PUO([!mO(g!sO~O!Y1[O~O!Y1[O%b7yO~Oh7|O!Y1[O%b7yO~OY8RO!W'ka!X'ka~O!W1gO!X(|i~O!h8VO~O!h8WO~O!h8ZO~O!h8ZO~P%[O_8]O~O!b8^O~O!h8_O~O!W(mi!X(mi~P#CvO_%kO#Y8gO'q%kO~O!W(jy!h(jy_(jy'q(jy~P!8dO!W(dO!h(iy~O!Y'ZO%b8jO~O#e$vqP$vqY$vq_$vql$vq{$vq!W$vq!f$vq!g$vq!i$vq!m$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#o$vq#p$vq#r$vq#t$vq#v$vq#w$vq'q$vq(X$vq(h$vq!h$vq!T$vq'o$vq#Y$vqp$vq!Y$vq%b$vq!b$vq~P#-]O#e'baP'baY'ba_'bal'ba{'ba!f'ba!g'ba!i'ba!m'ba#h'ba#i'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#r'ba#t'ba#v'ba#w'ba'q'ba(X'ba(h'ba!h'ba!T'ba'o'bap'ba!Y'ba%b'ba!b'ba~P&-QO#e'daP'daY'da_'dal'da{'da!f'da!g'da!i'da!m'da#h'da#i'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#r'da#t'da#v'da#w'da'q'da(X'da(h'da!h'da!T'da'o'dap'da!Y'da%b'da!b'da~P&-sO#e$xqP$xqY$xq_$xql$xq{$xq!W$xq!f$xq!g$xq!i$xq!m$xq#h$xq#i$xq#j$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#r$xq#t$xq#v$xq#w$xq'q$xq(X$xq(h$xq!h$xq!T$xq'o$xq#Y$xqp$xq!Y$xq%b$xq!b$xq~P#-]O!W'Ri!h'Ri~P!8dO#z#]q!W#]q!X#]q~P#CvO(o$}OP%YaY%Yal%Ya{%Ya!f%Ya!g%Ya!i%Ya!m%Ya#h%Ya#i%Ya#j%Ya#k%Ya#l%Ya#m%Ya#n%Ya#o%Ya#p%Ya#r%Ya#t%Ya#v%Ya#w%Ya#z%Ya(X%Ya(h%Ya!W%Ya!X%Ya~Oh%Yaz%Ya}%Ya(p%Ya~P&?YO(p%POP%[aY%[al%[a{%[a!f%[a!g%[a!i%[a!m%[a#h%[a#i%[a#j%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#r%[a#t%[a#v%[a#w%[a#z%[a(X%[a(h%[a!W%[a!X%[a~Oh%[az%[a}%[a(o%[a~P&AaOh<gOz)zO}){O(p%PO~P&?YOh<gOz)zO}){O(o$}O~P&AaOz0ZO{0ZO}0[OPwaYwahwalwa!fwa!gwa!iwa!mwa#hwa#iwa#jwa#kwa#lwa#mwa#nwa#owa#pwa#rwa#twa#vwa#wwa#zwa(Xwa(hwa(owa(pwa!Wwa!Xwa~Oz)zO}){OP$maY$mah$mal$ma{$ma!f$ma!g$ma!i$ma!m$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#o$ma#p$ma#r$ma#t$ma#v$ma#w$ma#z$ma(X$ma(h$ma(o$ma(p$ma!W$ma!X$ma~Oz)zO}){OP$oaY$oah$oal$oa{$oa!f$oa!g$oa!i$oa!m$oa#h$oa#i$oa#j$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#r$oa#t$oa#v$oa#w$oa#z$oa(X$oa(h$oa(o$oa(p$oa!W$oa!X$oa~OP$}aY$}al$}a{$}a!f$}a!g$}a!i$}a!m$}a#h$}a#i$}a#j$}a#k$}a#l$}a#m$}a#n$}a#o$}a#p$}a#r$}a#t$}a#v$}a#w$}a#z$}a(X$}a(h$}a!W$}a!X$}a~P&%pO#z$iq!W$iq!X$iq~P#CvO#z$jq!W$jq!X$jq~P#CvO!X8vO~O#z8wO~P!0}O!b#uO!W']i!h']i~O!b#uO(h'kO!W']i!h']i~O!W/cO!h(uq~O!T'_i!W'_i~P#-]O!W/kO!T(vq~O!T8}O~P#-]O!T8}O~Oe(Vy!W(Vy~P!0}O!W'fa!Y'fa~P#-]O_%Uq!Y%Uq'q%Uq!W%Uq~P#-]OY9SO~O!W0rO!X)Oq~O#Y9WO!W'ha!X'ha~O!W5UO!X({i~P#CvOPZXYZXlZXzZX{ZX}ZX!TZX!WZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(XZX(hZX(oZX(pZX~O!b%SX#p%SX~P' zO!Y1[O%b9[O~O'|TO(PUO([9aO~O!W1gO!X(|q~O!h9dO~O!h9eO~O!h9fO~O!h9fO~P%[O#Y9iO!W#by!X#by~O!W#by!X#by~P#CvO!Y'ZO%b9nO~O#z#xy!W#xy!X#xy~P#CvOP$viY$vil$vi{$vi!f$vi!g$vi!i$vi!m$vi#h$vi#i$vi#j$vi#k$vi#l$vi#m$vi#n$vi#o$vi#p$vi#r$vi#t$vi#v$vi#w$vi#z$vi(X$vi(h$vi!W$vi!X$vi~P&%pOz)zO}){O(p%POP'aaY'aah'aal'aa{'aa!f'aa!g'aa!i'aa!m'aa#h'aa#i'aa#j'aa#k'aa#l'aa#m'aa#n'aa#o'aa#p'aa#r'aa#t'aa#v'aa#w'aa#z'aa(X'aa(h'aa(o'aa!W'aa!X'aa~Oz)zO}){OP'caY'cah'cal'ca{'ca!f'ca!g'ca!i'ca!m'ca#h'ca#i'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#r'ca#t'ca#v'ca#w'ca#z'ca(X'ca(h'ca(o'ca(p'ca!W'ca!X'ca~O(o$}OP%YiY%Yih%Yil%Yiz%Yi{%Yi}%Yi!f%Yi!g%Yi!i%Yi!m%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#o%Yi#p%Yi#r%Yi#t%Yi#v%Yi#w%Yi#z%Yi(X%Yi(h%Yi(p%Yi!W%Yi!X%Yi~O(p%POP%[iY%[ih%[il%[iz%[i{%[i}%[i!f%[i!g%[i!i%[i!m%[i#h%[i#i%[i#j%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#r%[i#t%[i#v%[i#w%[i#z%[i(X%[i(h%[i(o%[i!W%[i!X%[i~O#z$jy!W$jy!X$jy~P#CvO#z#]y!W#]y!X#]y~P#CvO!b#uO!W']q!h']q~O!W/cO!h(uy~O!T'_q!W'_q~P#-]O!T9wO~P#-]O!W0rO!X)Oy~O!W5UO!X({q~O!Y1[O%b:OO~O!h:RO~O!Y'ZO%b:WO~OP$vqY$vql$vq{$vq!f$vq!g$vq!i$vq!m$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#o$vq#p$vq#r$vq#t$vq#v$vq#w$vq#z$vq(X$vq(h$vq!W$vq!X$vq~P&%pOz)zO}){O(p%POP'baY'bah'bal'ba{'ba!f'ba!g'ba!i'ba!m'ba#h'ba#i'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#r'ba#t'ba#v'ba#w'ba#z'ba(X'ba(h'ba(o'ba!W'ba!X'ba~Oz)zO}){OP'daY'dah'dal'da{'da!f'da!g'da!i'da!m'da#h'da#i'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#r'da#t'da#v'da#w'da#z'da(X'da(h'da(o'da(p'da!W'da!X'da~OP$xqY$xql$xq{$xq!f$xq!g$xq!i$xq!m$xq#h$xq#i$xq#j$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#r$xq#t$xq#v$xq#w$xq#z$xq(X$xq(h$xq!W$xq!X$xq~P&%pOe%^!Z!W%^!Z#Y%^!Z#z%^!Z~P!0}O!W'hq!X'hq~P#CvO!W#b!Z!X#b!Z~P#CvO#e%^!ZP%^!ZY%^!Z_%^!Zl%^!Z{%^!Z!W%^!Z!f%^!Z!g%^!Z!i%^!Z!m%^!Z#h%^!Z#i%^!Z#j%^!Z#k%^!Z#l%^!Z#m%^!Z#n%^!Z#o%^!Z#p%^!Z#r%^!Z#t%^!Z#v%^!Z#w%^!Z'q%^!Z(X%^!Z(h%^!Z!h%^!Z!T%^!Z'o%^!Z#Y%^!Zp%^!Z!Y%^!Z%b%^!Z!b%^!Z~P#-]OP%^!ZY%^!Zl%^!Z{%^!Z!f%^!Z!g%^!Z!i%^!Z!m%^!Z#h%^!Z#i%^!Z#j%^!Z#k%^!Z#l%^!Z#m%^!Z#n%^!Z#o%^!Z#p%^!Z#r%^!Z#t%^!Z#v%^!Z#w%^!Z#z%^!Z(X%^!Z(h%^!Z!W%^!Z!X%^!Z~P&%pOp(]X~P1qO'{!lO~P!*fO!TdX!WdX#YdX~P' zOPZXYZXlZXzZX{ZX}ZX!WZX!WdX!fZX!gZX!iZX!mZX#YZX#YdX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(XZX(hZX(oZX(pZX~O!bdX!hZX!hdX(hdX~P'?nOP:cOQ:cOb<[Oc!iOjkOl:cOmkOnkOtkOv:cOx:cO}WO!RkO!SkO!YXO!d:fO!iZO!l:cO!m:cO!n:cO!p:gO!r:jO!u!hO$R!kO$VfO'z)YO'|TO(PUO(XVO(g[O(t<YO~O!W:wO!X$la~Oj%WOl$tOm$sOn$sOt%XOv%YOx;RO}${O!Y$|O!d<aO!i$xO#d;XO$R%^O$n;TO$p;VO$s%_O'z(pO'|TO(PUO(T%VO(X$uO(o$}O(p%PO~O#q)aO~P'DdO!XZX!XdX~P'?nO#e:kO~O!b#uO#e:kO~O#Y:{O~O#p:pO~O#Y;ZO!W(mX!X(mX~O#Y:{O!W(kX!X(kX~O#e;[O~Oe;^O~P!0}O#e;cO~O#e;dO~O!b#uO#e;eO~O!b#uO#e;[O~O#z;fO~P#CvO#e;gO~O#e;hO~O#e;mO~O#e;nO~O#e;oO~O#e;pO~O#z;qO~P!0}O#z;rO~P!0}O$V~!g!}#O#Q#R#U#c#d#o(t$n$p$s%V%a%b%c%j%l%o%p%r%t~'uR$V(t#i!S's'{#jm#h#klz't(['t'z$X$Z$X~",
      goto: "$2p)SPPPP)TPP)WP)iP*x.|PPPP5pPP6WP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AuPPGh!CSPGhPGhGhGhGhPGh!DfPP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#IpP#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!f$Uc#X%n'|(S(n(u)U)V)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:r)Z)l-O.t2W2Z3_3g3h3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!b$Wc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:t)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
      nodeNames:
        '⚠ ArithOp ArithOp LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem',
      maxTerm: 371,
      context: trackNewline,
      nodeProps: [
        [
          'group',
          -26,
          7,
          15,
          17,
          63,
          200,
          204,
          208,
          209,
          211,
          214,
          217,
          227,
          229,
          235,
          237,
          239,
          241,
          244,
          250,
          256,
          258,
          260,
          262,
          264,
          266,
          267,
          'Statement',
          -32,
          11,
          12,
          26,
          29,
          30,
          36,
          46,
          49,
          50,
          52,
          57,
          65,
          73,
          77,
          79,
          81,
          82,
          104,
          105,
          114,
          115,
          132,
          135,
          137,
          138,
          139,
          140,
          142,
          143,
          163,
          164,
          166,
          'Expression',
          -23,
          25,
          27,
          31,
          35,
          37,
          39,
          167,
          169,
          171,
          172,
          174,
          175,
          176,
          178,
          179,
          180,
          182,
          183,
          184,
          194,
          196,
          198,
          199,
          'Type',
          -3,
          85,
          97,
          103,
          'ClassItem'
        ],
        [
          'openedBy',
          32,
          'InterpolationStart',
          51,
          '[',
          55,
          '{',
          70,
          '(',
          144,
          'JSXStartTag',
          156,
          'JSXStartTag JSXStartCloseTag'
        ],
        [
          'closedBy',
          34,
          'InterpolationEnd',
          45,
          ']',
          56,
          '}',
          71,
          ')',
          145,
          'JSXSelfCloseEndTag JSXEndTag',
          161,
          'JSXEndTag'
        ]
      ],
      propSources: [jsHighlight],
      skippedNodes: [0, 3, 4, 270],
      repeatNodeCount: 37,
      tokenData:
        "$Fl(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Nu!`!a$#a!a!b$(n!b!c$,m!c!}Er!}#O$-w#O#P$/R#P#Q$4j#Q#R$5t#R#SEr#S#T$7R#T#o$8]#o#p$<m#p#q$=c#q#r$>s#r#s$@P#s$f%Z$f$g+g$g#BYEr#BY#BZ$AZ#BZ$ISEr$IS$I_$AZ$I_$I|Er$I|$I}$Df$I}$JO$Df$JO$JTEr$JT$JU$AZ$JU$KVEr$KV$KW$AZ$KW&FUEr&FU&FV$AZ&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AZ?HUOEr(n%d_$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$e&j(Q!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Q!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$e&j'}pOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'}pOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'}p(Q!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$e&j'}p(Q!b's(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(O#S$e&j't(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$e&j'}p(Q!b't(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$e&j!m$Ip'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#r$Id$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#r$Id$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'|$(n$e&j(Q!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$e&j(Q!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$e&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$`#t$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$`#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$`#t$e&j(Q!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ(Q!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$`#t(Q!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hh$e&j'}p(Q!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__US$e&j'}p(Q!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]US$e&j(Q!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXUS$e&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSUSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWUS(Q!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]US$e&j'}pOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWUS'}pOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYUS'}p(Q!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$e&j(g!L^'}p(Q!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$e&j'}p(Q!b([!LY'z&;d$X#tOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$e&j'}p(Q!b$X#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$e&j'}p(Q!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$e&j#|$Id'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$e&j#v$Id'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b! c_(P$)`$e&j'}pOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b*Q!!i_$e&j'}pOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b)`!#mX$e&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h#t!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y#t!$oP;=`<%l!$Y)`!$uP;=`<%l!#h*Q!%R]$`#t$e&j'}pOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$f!&PZ'}pOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z$f!&yU$`#t'}pOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$f!'`P;=`<%l!%z*Q!'fP;=`<%l!!b(*Q!'t_!i(!b$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!hM|$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$e&j'}p(Q!b'{#)d#k$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$e&j'}p(Q!b#h$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$e&j'}p(Q!bl&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!W&;l$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$e&j'}p(Q!bz'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!VMt$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$e&j'}p(Q!b#i$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$e&j'}p(Q!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$e&j(Q!b!SSOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$e&j!SSOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$e&j!SSO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!SSOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!SS#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$e&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$e&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$e&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$e&j(Q!b!SSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(Q!b!SSOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(Q!b!SSOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(Q!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$e&j(Q!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$e&j'}p!SSOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$e&j'}p!SSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ'}p!SSOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb'}p!SSOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX'}pOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$e&j'}pOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$e&j'}p(Q!b!SSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d]'}p(Q!b!SSOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe'}p(Q!b!SSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ'}p(Q!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$e&j'}p(Q!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$e&j'}p(Q!b'u(;d!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$e&j'}p(Q!bR(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$e&j(Q!bR(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$e&jR(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSR(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(Q!bR(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$e&j'}pR(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW'}pR(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY'}p(Q!bR(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$e&j#|$Id'}p(Q!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$U#t$e&j'}p(Q!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$e&j'}p(Q!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!b$b$e&j#z%<f'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I___l$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Jm^(T!*v!f'.r'}p(Q!b$V)d(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Ki!Q!^*g!^!_#L_!_!`#NP!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KrX$g&j'}p(Q!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LhZ#l$Id'}p(Q!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MZ!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MdX#|$Id'}p(Q!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NYX#m$Id'}p(Q!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Qa#Y%?x$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!V!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!b_#e$Ih$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#paeBf#m$Id$b#|$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$u!`!a$&P!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%Q_#m$Id$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&[a#l$Id$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'a!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'l`#l$Id$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(yc(h$Ip$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*U!P!^%Z!^!_*g!_!a%Z!a!b$+`!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*a_{'#p$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+k`$e&j#w$Id'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,x_!y!Ln$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.S_}(8n$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/WZ$e&jO!^$/y!^!_$0a!_#i$/y#i#j$0f#j#l$/y#l#m$2X#m#o$/y#o#p$0a#p;'S$/y;'S;=`$4d<%lO$/y(n$0QT]#S$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0fO]#S(n$0k[$e&jO!Q&c!Q![$1a![!^&c!_!c&c!c!i$1a!i#T&c#T#Z$1a#Z#o&c#o#p$3w#p;'S&c;'S;=`&w<%lO&c(n$1fZ$e&jO!Q&c!Q![$2X![!^&c!_!c&c!c!i$2X!i#T&c#T#Z$2X#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2^Z$e&jO!Q&c!Q![$3P![!^&c!_!c&c!c!i$3P!i#T&c#T#Z$3P#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3UZ$e&jO!Q&c!Q![$/y![!^&c!_!c&c!c!i$/y!i#T&c#T#Z$/y#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3zR!Q![$4T!c!i$4T#T#Z$4T#S$4WS!Q![$4T!c!i$4T#T#Z$4T#q#r$0a(n$4gP;=`<%l$/y!2r$4u_!T!+S$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$6P`#t$Id$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7^_$e&j'}p(Q!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8lk$e&j'}p(Q!b([!LY'z&;d$Z#tOY%ZYZ&cZr%Zrs&}st%Ztu$8]uw%Zwx(rx}%Z}!O$:a!O!Q%Z!Q![$8]![!^%Z!^!_*g!_!c%Z!c!}$8]!}#O%Z#O#P&c#P#R%Z#R#S$8]#S#T%Z#T#o$8]#o#p*g#p$g%Z$g;'S$8];'S;=`$<g<%lO$8]+d$:lk$e&j'}p(Q!b$Z#tOY%ZYZ&cZr%Zrs&}st%Ztu$:auw%Zwx(rx}%Z}!O$:a!O!Q%Z!Q![$:a![!^%Z!^!_*g!_!c%Z!c!}$:a!}#O%Z#O#P&c#P#R%Z#R#S$:a#S#T%Z#T#o$:a#o#p*g#p$g%Z$g;'S$:a;'S;=`$<a<%lO$:a+d$<dP;=`<%l$:a(CS$<jP;=`<%l$8]!5p$<vX!Y!3l'}p(Q!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=na(o&;`$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+`#q;'S%Z;'S;=`+a<%lO%Z%#`$?Q_!X$I`p`$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@[_!nS$e&j'}p(Q!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Al|$e&j'}p(Q!b's(;d([!LY'z&;d$X#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AZ#BZ$ISEr$IS$I_$AZ$I_$JTEr$JT$JU$AZ$JU$KVEr$KV$KW$AZ$KW&FUEr&FU&FV$AZ&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AZ?HUOEr(CS$Dwk$e&j'}p(Q!b't(;d([!LY'z&;d$X#tOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
      tokenizers: [
        noSemicolon,
        incdecToken,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        insertSemicolon,
        new LocalTokenGroup(
          "$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOr~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!P~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~",
          141,
          332
        ),
        new LocalTokenGroup("j~RQYZXz{^~^O'w~~aP!P!Qd~iO'x~~", 25, 314)
      ],
      topRules: {
        Script: [0, 5],
        SingleExpression: [1, 268],
        SingleClassItem: [2, 269]
      },
      dialects: { jsx: 14548, ts: 14550 },
      dynamicPrecedences: { 67: 1, 77: 1, 79: 1, 164: 1, 192: 1 },
      specialized: [
        { term: 318, get: (value) => spec_identifier[value] || -1 },
        { term: 334, get: (value) => spec_word[value] || -1 },
        { term: 68, get: (value) => spec_LessThan[value] || -1 }
      ],
      tokenPrec: 14574
    }) // CONCATENATED MODULE: ./node_modules/@codemirror/lang-javascript/dist/index.js

    /**
A collection of JavaScript-related
[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).
*/
    const snippets = [
      /*@__PURE__*/ snippetCompletion(
        'function ${name}(${params}) {\n\t${}\n}',
        {
          label: 'function',
          detail: 'definition',
          type: 'keyword'
        }
      ),
      /*@__PURE__*/ snippetCompletion(
        'for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}',
        {
          label: 'for',
          detail: 'loop',
          type: 'keyword'
        }
      ),
      /*@__PURE__*/ snippetCompletion(
        'for (let ${name} of ${collection}) {\n\t${}\n}',
        {
          label: 'for',
          detail: 'of loop',
          type: 'keyword'
        }
      ),
      /*@__PURE__*/ snippetCompletion('do {\n\t${}\n} while (${})', {
        label: 'do',
        detail: 'loop',
        type: 'keyword'
      }),
      /*@__PURE__*/ snippetCompletion('while (${}) {\n\t${}\n}', {
        label: 'while',
        detail: 'loop',
        type: 'keyword'
      }),
      /*@__PURE__*/ snippetCompletion(
        'try {\n\t${}\n} catch (${error}) {\n\t${}\n}',
        {
          label: 'try',
          detail: '/ catch block',
          type: 'keyword'
        }
      ),
      /*@__PURE__*/ snippetCompletion('if (${}) {\n\t${}\n}', {
        label: 'if',
        detail: 'block',
        type: 'keyword'
      }),
      /*@__PURE__*/ snippetCompletion('if (${}) {\n\t${}\n} else {\n\t${}\n}', {
        label: 'if',
        detail: '/ else block',
        type: 'keyword'
      }),
      /*@__PURE__*/ snippetCompletion(
        'class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}',
        {
          label: 'class',
          detail: 'definition',
          type: 'keyword'
        }
      ),
      /*@__PURE__*/ snippetCompletion(
        'import {${names}} from "${module}"\n${}',
        {
          label: 'import',
          detail: 'named',
          type: 'keyword'
        }
      ),
      /*@__PURE__*/ snippetCompletion('import ${name} from "${module}"\n${}', {
        label: 'import',
        detail: 'default',
        type: 'keyword'
      })
    ]
    /**
A collection of snippet completions for TypeScript. Includes the
JavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).
*/
    const typescriptSnippets = /*@__PURE__*/ snippets.concat([
      /*@__PURE__*/ snippetCompletion('interface ${name} {\n\t${}\n}', {
        label: 'interface',
        detail: 'definition',
        type: 'keyword'
      }),
      /*@__PURE__*/ snippetCompletion('type ${name} = ${type}', {
        label: 'type',
        detail: 'definition',
        type: 'keyword'
      }),
      /*@__PURE__*/ snippetCompletion('enum ${name} {\n\t${}\n}', {
        label: 'enum',
        detail: 'definition',
        type: 'keyword'
      })
    ])

    const cache = /*@__PURE__*/ new NodeWeakMap()
    const ScopeNodes = /*@__PURE__*/ new Set([
      'Script',
      'Block',
      'FunctionExpression',
      'FunctionDeclaration',
      'ArrowFunction',
      'MethodDeclaration',
      'ForStatement'
    ])
    function defID(type) {
      return (node, def) => {
        let id = node.node.getChild('VariableDefinition')
        if (id) def(id, type)
        return true
      }
    }
    const functionContext = ['FunctionDeclaration']
    const gatherCompletions = {
      FunctionDeclaration: /*@__PURE__*/ defID('function'),
      ClassDeclaration: /*@__PURE__*/ defID('class'),
      ClassExpression: () => true,
      EnumDeclaration: /*@__PURE__*/ defID('constant'),
      TypeAliasDeclaration: /*@__PURE__*/ defID('type'),
      NamespaceDeclaration: /*@__PURE__*/ defID('namespace'),
      VariableDefinition(node, def) {
        if (!node.matchContext(functionContext)) def(node, 'variable')
      },
      TypeDefinition(node, def) {
        def(node, 'type')
      },
      __proto__: null
    }
    function getScope(doc, node) {
      let cached = cache.get(node)
      if (cached) return cached
      let completions = [],
        top = true
      function def(node, type) {
        let name = doc.sliceString(node.from, node.to)
        completions.push({ label: name, type })
      }
      node.cursor(IterMode.IncludeAnonymous).iterate((node) => {
        if (top) {
          top = false
        } else if (node.name) {
          let gather = gatherCompletions[node.name]
          if ((gather && gather(node, def)) || ScopeNodes.has(node.name))
            return false
        } else if (node.to - node.from > 8192) {
          // Allow caching for bigger internal nodes
          for (let c of getScope(doc, node.node)) completions.push(c)
          return false
        }
      })
      cache.set(node, completions)
      return completions
    }
    const Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/
    const dontComplete = [
      'TemplateString',
      'String',
      'RegExp',
      'LineComment',
      'BlockComment',
      'VariableDefinition',
      'TypeDefinition',
      'Label',
      'PropertyDefinition',
      'PropertyName',
      'PrivatePropertyDefinition',
      'PrivatePropertyName',
      '.',
      '?.'
    ]
    /**
Completion source that looks up locally defined names in
JavaScript code.
*/
    function localCompletionSource(context) {
      let inner = dist_syntaxTree(context.state).resolveInner(context.pos, -1)
      if (dontComplete.indexOf(inner.name) > -1) return null
      let isWord =
        inner.name == 'VariableName' ||
        (inner.to - inner.from < 20 &&
          Identifier.test(context.state.sliceDoc(inner.from, inner.to)))
      if (!isWord && !context.explicit) return null
      let options = []
      for (let pos = inner; pos; pos = pos.parent) {
        if (ScopeNodes.has(pos.name))
          options = options.concat(getScope(context.state.doc, pos))
      }
      return {
        options,
        from: isWord ? inner.from : context.pos,
        validFor: Identifier
      }
    }
    function pathFor(read, member, name) {
      var _a
      let path = []
      for (;;) {
        let obj = member.firstChild,
          prop
        if (
          (obj === null || obj === void 0 ? void 0 : obj.name) == 'VariableName'
        ) {
          path.push(read(obj))
          return { path: path.reverse(), name }
        } else if (
          (obj === null || obj === void 0 ? void 0 : obj.name) ==
            'MemberExpression' &&
          ((_a = prop = obj.lastChild) === null || _a === void 0
            ? void 0
            : _a.name) == 'PropertyName'
        ) {
          path.push(read(prop))
          member = obj
        } else {
          return null
        }
      }
    }
    /**
Helper function for defining JavaScript completion sources. It
returns the completable name and object path for a completion
context, or null if no name/property completion should happen at
that position. For example, when completing after `a.b.c` it will
return `{path: ["a", "b"], name: "c"}`. When completing after `x`
it will return `{path: [], name: "x"}`. When not in a property or
name, it will return null if `context.explicit` is false, and
`{path: [], name: ""}` otherwise.
*/
    function completionPath(context) {
      let read = (node) => context.state.doc.sliceString(node.from, node.to)
      let inner = syntaxTree(context.state).resolveInner(context.pos, -1)
      if (inner.name == 'PropertyName') {
        return pathFor(read, inner.parent, read(inner))
      } else if (
        (inner.name == '.' || inner.name == '?.') &&
        inner.parent.name == 'MemberExpression'
      ) {
        return pathFor(read, inner.parent, '')
      } else if (dontComplete.indexOf(inner.name) > -1) {
        return null
      } else if (
        inner.name == 'VariableName' ||
        (inner.to - inner.from < 20 && Identifier.test(read(inner)))
      ) {
        return { path: [], name: read(inner) }
      } else if (inner.name == 'MemberExpression') {
        return pathFor(read, inner, '')
      } else {
        return context.explicit ? { path: [], name: '' } : null
      }
    }
    function enumeratePropertyCompletions(obj, top) {
      let options = [],
        seen = new Set()
      for (let depth = 0; ; depth++) {
        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {
          if (
            !/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(name) ||
            seen.has(name)
          )
            continue
          seen.add(name)
          let value
          try {
            value = obj[name]
          } catch (_) {
            continue
          }
          options.push({
            label: name,
            type:
              typeof value == 'function'
                ? /^[A-Z]/.test(name)
                  ? 'class'
                  : top
                    ? 'function'
                    : 'method'
                : top
                  ? 'variable'
                  : 'property',
            boost: -depth
          })
        }
        let next = Object.getPrototypeOf(obj)
        if (!next) return options
        obj = next
      }
    }
    /**
Defines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that
completes from the given scope object (for example `globalThis`).
Will enter properties of the object when completing properties on
a directly-named path.
*/
    function scopeCompletionSource(scope) {
      let cache = new Map()
      return (context) => {
        let path = completionPath(context)
        if (!path) return null
        let target = scope
        for (let step of path.path) {
          target = target[step]
          if (!target) return null
        }
        let options = cache.get(target)
        if (!options)
          cache.set(
            target,
            (options = enumeratePropertyCompletions(target, !path.path.length))
          )
        return {
          from: context.pos - path.name.length,
          options,
          validFor: Identifier
        }
      }
    }

    /**
A language provider based on the [Lezer JavaScript
parser](https://github.com/lezer-parser/javascript), extended with
highlighting and indentation information.
*/
    const javascriptLanguage = /*@__PURE__*/ LRLanguage.define({
      name: 'javascript',
      parser: /*@__PURE__*/ parser.configure({
        props: [
          /*@__PURE__*/ indentNodeProp.add({
            IfStatement: /*@__PURE__*/ continuedIndent({
              except: /^\s*({|else\b)/
            }),
            TryStatement: /*@__PURE__*/ continuedIndent({
              except: /^\s*({|catch\b|finally\b)/
            }),
            LabeledStatement: flatIndent,
            SwitchBody: (context) => {
              let after = context.textAfter,
                closed = /^\s*\}/.test(after),
                isCase = /^\s*(case|default)\b/.test(after)
              return (
                context.baseIndent +
                (closed ? 0 : isCase ? 1 : 2) * context.unit
              )
            },
            Block: /*@__PURE__*/ delimitedIndent({ closing: '}' }),
            ArrowFunction: (cx) => cx.baseIndent + cx.unit,
            'TemplateString BlockComment': () => null,
            'Statement Property': /*@__PURE__*/ continuedIndent({
              except: /^{/
            }),
            JSXElement(context) {
              let closed = /^\s*<\//.test(context.textAfter)
              return (
                context.lineIndent(context.node.from) +
                (closed ? 0 : context.unit)
              )
            },
            JSXEscape(context) {
              let closed = /\s*\}/.test(context.textAfter)
              return (
                context.lineIndent(context.node.from) +
                (closed ? 0 : context.unit)
              )
            },
            'JSXOpenTag JSXSelfClosingTag'(context) {
              return context.column(context.node.from) + context.unit
            }
          }),
          /*@__PURE__*/ foldNodeProp.add({
            'Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType':
              foldInside,
            BlockComment(tree) {
              return { from: tree.from + 2, to: tree.to - 2 }
            }
          })
        ]
      }),
      languageData: {
        closeBrackets: { brackets: ['(', '[', '{', "'", '"', '`'] },
        commentTokens: { line: '//', block: { open: '/*', close: '*/' } },
        indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
        wordChars: '$'
      }
    })
    const jsxSublanguage = {
      test: (node) => /^JSX/.test(node.name),
      facet: /*@__PURE__*/ defineLanguageFacet({
        commentTokens: { block: { open: '{/*', close: '*/}' } }
      })
    }
    /**
A language provider for TypeScript.
*/
    const typescriptLanguage = /*@__PURE__*/ javascriptLanguage.configure(
      { dialect: 'ts' },
      'typescript'
    )
    /**
Language provider for JSX.
*/
    const jsxLanguage = /*@__PURE__*/ javascriptLanguage.configure({
      dialect: 'jsx',
      props: [
        /*@__PURE__*/ sublanguageProp.add((n) =>
          n.isTop ? [jsxSublanguage] : undefined
        )
      ]
    })
    /**
Language provider for JSX + TypeScript.
*/
    const tsxLanguage = /*@__PURE__*/ javascriptLanguage.configure(
      {
        dialect: 'jsx ts',
        props: [
          /*@__PURE__*/ sublanguageProp.add((n) =>
            n.isTop ? [jsxSublanguage] : undefined
          )
        ]
      },
      'typescript'
    )
    let kwCompletion = (name) => ({ label: name, type: 'keyword' })
    const keywords =
      /*@__PURE__*/ 'break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield'
        .split(' ')
        .map(kwCompletion)
    const typescriptKeywords = /*@__PURE__*/ keywords.concat(
      /*@__PURE__*/ [
        'declare',
        'implements',
        'private',
        'protected',
        'public'
      ].map(kwCompletion)
    )
    /**
JavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)
completion.
*/
    function javascript(config = {}) {
      let lang = config.jsx
        ? config.typescript
          ? tsxLanguage
          : jsxLanguage
        : config.typescript
          ? typescriptLanguage
          : javascriptLanguage
      let completions = config.typescript
        ? typescriptSnippets.concat(typescriptKeywords)
        : snippets.concat(keywords)
      return new LanguageSupport(lang, [
        javascriptLanguage.data.of({
          autocomplete: ifNotIn(dontComplete, completeFromList(completions))
        }),
        javascriptLanguage.data.of({
          autocomplete: localCompletionSource
        }),
        config.jsx ? autoCloseTags : []
      ])
    }
    function findOpenTag(node) {
      for (;;) {
        if (
          node.name == 'JSXOpenTag' ||
          node.name == 'JSXSelfClosingTag' ||
          node.name == 'JSXFragmentTag'
        )
          return node
        if (node.name == 'JSXEscape' || !node.parent) return null
        node = node.parent
      }
    }
    function elementName(doc, tree, max = doc.length) {
      for (
        let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild;
        ch;
        ch = ch.nextSibling
      ) {
        if (
          ch.name == 'JSXIdentifier' ||
          ch.name == 'JSXBuiltin' ||
          ch.name == 'JSXNamespacedName' ||
          ch.name == 'JSXMemberExpression'
        )
          return doc.sliceString(ch.from, Math.min(ch.to, max))
      }
      return ''
    }
    const dist_android =
      typeof navigator == 'object' &&
      /*@__PURE__*/ /Android\b/.test(navigator.userAgent)
    /**
Extension that will automatically insert JSX close tags when a `>` or
`/` is typed.
*/
    const autoCloseTags = /*@__PURE__*/ EditorView.inputHandler.of(
      (view, from, to, text, defaultInsert) => {
        if (
          (dist_android ? view.composing : view.compositionStarted) ||
          view.state.readOnly ||
          from != to ||
          (text != '>' && text != '/') ||
          !javascriptLanguage.isActiveAt(view.state, from, -1)
        )
          return false
        let base = defaultInsert(),
          { state } = base
        let closeTags = state.changeByRange((range) => {
          var _a
          let { head } = range,
            around = dist_syntaxTree(state).resolveInner(head - 1, -1),
            name
          if (around.name == 'JSXStartTag') around = around.parent
          if (
            state.doc.sliceString(head - 1, head) != text ||
            (around.name == 'JSXAttributeValue' && around.to > head)
          );
          else if (text == '>' && around.name == 'JSXFragmentTag') {
            return { range, changes: { from: head, insert: `</>` } }
          } else if (text == '/' && around.name == 'JSXStartCloseTag') {
            let empty = around.parent,
              base = empty.parent
            if (
              base &&
              empty.from == head - 2 &&
              ((name = elementName(state.doc, base.firstChild, head)) ||
                ((_a = base.firstChild) === null || _a === void 0
                  ? void 0
                  : _a.name) == 'JSXFragmentTag')
            ) {
              let insert = `${name}>`
              return {
                range: dist_EditorSelection.cursor(head + insert.length, -1),
                changes: { from: head, insert }
              }
            }
          } else if (text == '>') {
            let openTag = findOpenTag(around)
            if (
              openTag &&
              !/^\/?>|^<\//.test(state.doc.sliceString(head, head + 2)) &&
              (name = elementName(state.doc, openTag, head))
            )
              return { range, changes: { from: head, insert: `</${name}>` } }
          }
          return { range }
        })
        if (closeTags.changes.empty) return false
        view.dispatch([
          base,
          state.update(closeTags, {
            userEvent: 'input.complete',
            scrollIntoView: true
          })
        ])
        return true
      }
    )

    /**
Connects an [ESLint](https://eslint.org/) linter to CodeMirror's
[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the
[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)
class, and `config` an optional ESLint configuration. The return
value of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)
to create a JavaScript linting extension.

Note that ESLint targets node, and is tricky to run in the
browser. The
[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)
package may help with that (see
[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).
*/
    function esLint(eslint, config) {
      if (!config) {
        config = {
          parserOptions: { ecmaVersion: 2019, sourceType: 'module' },
          env: {
            browser: true,
            node: true,
            es6: true,
            es2015: true,
            es2017: true,
            es2020: true
          },
          rules: {}
        }
        eslint.getRules().forEach((desc, name) => {
          if (desc.meta.docs.recommended) config.rules[name] = 2
        })
      }
      return (view) => {
        let { state } = view,
          found = []
        for (let { from, to } of javascriptLanguage.findRegions(state)) {
          let fromLine = state.doc.lineAt(from),
            offset = {
              line: fromLine.number - 1,
              col: from - fromLine.from,
              pos: from
            }
          for (let d of eslint.verify(state.sliceDoc(from, to), config))
            found.push(translateDiagnostic(d, state.doc, offset))
        }
        return found
      }
    }
    function mapPos(line, col, doc, offset) {
      return (
        doc.line(line + offset.line).from +
        col +
        (line == 1 ? offset.col - 1 : -1)
      )
    }
    function translateDiagnostic(input, doc, offset) {
      let start = mapPos(input.line, input.column, doc, offset)
      let result = {
        from: start,
        to:
          input.endLine != null && input.endColumn != 1
            ? mapPos(input.endLine, input.endColumn, doc, offset)
            : start,
        message: input.message,
        source: input.ruleId ? 'eslint:' + input.ruleId : 'eslint',
        severity: input.severity == 1 ? 'warning' : 'error'
      }
      if (input.fix) {
        let { range, text } = input.fix,
          from = range[0] + offset.pos - start,
          to = range[1] + offset.pos - start
        result.actions = [
          {
            name: 'fix',
            apply(view, start) {
              view.dispatch({
                changes: { from: start + from, to: start + to, insert: text },
                scrollIntoView: true
              })
            }
          }
        ]
      }
      return result
    } // CONCATENATED MODULE: ./src/lib/component/LoadDialog/initJSONEditor.js

    function initJSONEditor(textarea, dialogHeight) {
      const editorHeightTheme = EditorView.theme({
        '&': {
          height: `${dialogHeight * 0.6}px`
        }
      })

      const view = new EditorView({
        doc: textarea.value,
        extensions: [
          basicSetup,
          javascript(),
          dist_syntaxHighlighting(dist_defaultHighlightStyle),
          editorHeightTheme
        ]
      })

      // Replace the textarea with the new editor.
      textarea.parentNode.insertBefore(view.dom, textarea)
      textarea.style.display = 'none'

      return view
    } // CONCATENATED MODULE: ./src/lib/component/LoadDialog/index.js

    function LoadDialog_template(context) {
      const { url } = context

      return `
<div class="textae-editor__load-dialog__container">
  <div class="textae-editor__load-dialog__row">
    <label>
      URL
    </label>
    <input 
      type="text" 
      value="${url}" 
      class="textae-editor__load-dialog__url-text">
    <input 
      type="button" 
      class="textae-editor__load-dialog__url-button"
      ${url ? `` : `disabled="disabled"`}
      value="Open">
  </div>
  <div class="textae-editor__load-dialog__row">
    <label>
      Local
    </label>
    <form class="dropzone textae-editor__load-dialog__dropzone">
      <div class="dz-message">
        Drop a file here or click to select
      </div>
    </form>
    <div class="textae-editor__load-dialog__dz-file-preview">
      <div class="dz-filename"><span data-dz-name>No file selected</span></div>
    </div>
    <input 
      type="button" 
      class="textae-editor__load-dialog__local-button"
      disabled="disabled"
      value="Open">
  </div>
  <div class="textae-editor__load-dialog__row json">
    <label>
      JSON
    </label>
    <textarea class="textae-editor__load-dialog__textarea"></textarea>
    <input type="button" value="Edit" class="edit" disabled="disabled">
    <input type="button" value="Open" class="instant" disabled="disabled">
  </div>
</div>`
    }

    const CONFIRM_DISCARD_CHANGE_MESSAGE =
      'There is a change that has not been saved. If you procceed now, you will lose it.'

    class LoadDialog extends Dialog {
      constructor(
        title,
        url,
        loadFromServer,
        readFromFile,
        readFromText,
        hasChange
      ) {
        super(title, LoadDialog_template({ url }))

        // Disabled the button to load from the URL when no URL.
        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__url-text',
          'input',
          (e) => {
            enableHTMLElement(e.target.nextElementSibling, e.target.value)
          }
        )

        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__textarea',
          'input',
          (e) => {
            enableHTMLElement(
              super.el.querySelector('[type="button"].instant'),
              e.target.value
            )
            enableHTMLElement(
              super.el.querySelector('[type="button"].edit'),
              e.target.value
            )
          }
        )

        const isUserConfirm = () =>
          !hasChange || window.confirm(CONFIRM_DISCARD_CHANGE_MESSAGE)

        // Load from the URL.
        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__url-button',
          'click',
          (e) => {
            if (isUserConfirm()) {
              loadFromServer(e.target.previousElementSibling.value)
            }
            super.close()
          }
        )

        // Load from a file.
        delegate_default()(
          super.el,
          '.textae-editor__load-dialog__local-button',
          'click',
          () => {
            if (isUserConfirm()) {
              readFromFile(this._droppedFile)
            }

            super.close()
          }
        )

        // Load from a textarea
        let jsonEditor = null
        delegate_default()(super.el, '[type="button"].instant', 'click', () => {
          const text = jsonEditor
            ? jsonEditor.state.doc.toString()
            : super.el.querySelector('.textae-editor__load-dialog__textarea')
                .value
          if (isUserConfirm()) {
            readFromText(text)
          }

          super.close()
        })

        // Open JSON editor
        delegate_default()(super.el, '[type="button"].edit', 'click', () => {
          this._expandDialog()
          const textarea = super.el.querySelector(
            '.textae-editor__load-dialog__textarea'
          )
          if (isJSON(textarea.value)) {
            textarea.value = JSON.stringify(JSON.parse(textarea.value), null, 2)
          }

          const dialogHeight = super.el.closest(
            '.textae-editor__dialog'
          ).clientHeight
          jsonEditor = initJSONEditor(textarea, dialogHeight)
        })
      }

      open() {
        super.open()

        const dropzoneConfig = {
          url: 'nothing', //Because it's a setting that cannot be omitted.
          previewsContainer: '.textae-editor__load-dialog__dz-file-preview',
          previewTemplate: super.el.querySelector(
            '.textae-editor__load-dialog__dz-file-preview'
          ).innerHTML
        }

        const overlayDropzone = new (dropzone_default())(
          'body > div.ui-widget-overlay.ui-front',
          {
            ...dropzoneConfig,
            clickable: false
          }
        )
        const zIndexOfOverlayDropzone = overlayDropzone.element.style.zIndex

        overlayDropzone
          .on('dragenter', () => maximizeOverlay(overlayDropzone))
          .on('dragleave', () =>
            revertMaximizeOverlay(overlayDropzone, zIndexOfOverlayDropzone)
          )
          .on('addedfile', (file) => {
            revertMaximizeOverlay(overlayDropzone, zIndexOfOverlayDropzone)
            this._showFilePreview(file)
          })

        const dialogDropzone = new (dropzone_default())(
          '.textae-editor__load-dialog__dropzone',
          dropzoneConfig
        )
        dialogDropzone.on('addedfile', (file) => {
          this._showFilePreview(file)
        })
      }

      _showFilePreview(file) {
        // Remove the previous file name.
        super.el
          .querySelector('.textae-editor__load-dialog__dz-file-preview')
          .firstElementChild.remove()

        // Add file name to title attrribute to show tooltip.
        super.el
          .querySelector('.textae-editor__load-dialog__dz-file-preview > div')
          .setAttribute('title', file.name)

        // Enables the button to open the file.
        this._droppedFile = file
        enableHTMLElement(
          super.el.querySelector('.textae-editor__load-dialog__local-button'),
          true
        )
      }

      _expandDialog() {
        super.el
          .closest('.textae-editor__dialog')
          .classList.add('textae-editor__load-dialog--expanded')
      }
    } // CONCATENATED MODULE: ./src/lib/component/createDownloadPath.js

    /* harmony default export */ function createDownloadPath(dataObject) {
      const blob = new Blob([JSON.stringify(dataObject)], {
        type: 'application/json'
      })

      return URL.createObjectURL(blob)
    } // CONCATENATED MODULE: ./src/lib/component/SaveAnnotationDialog/bind.js

    /* harmony default export */ function bind(
      eventEmitter,
      element,
      data,
      closeDialog,
      saveAnnotation
    ) {
      // Disabled the button to save to the URL when no URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'input',
        (e) => {
          enableHTMLElement(e.target.nextElementSibling, e.target.value)
        }
      )

      // Save to the URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'keyup',
        (e) => {
          if (e.keyCode === 13) {
            saveAnnotation(e.target.value)
            closeDialog()
          }
        }
      )
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-button',
        'click',
        (e) => {
          saveAnnotation(e.target.previousElementSibling.value)
          closeDialog()
        }
      )

      // Download as a JSON file.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__download-link',
        'click',
        (e) => {
          const aTag = e.target
          const downloadPath = createDownloadPath(data)
          aTag.setAttribute('href', downloadPath)
          aTag.setAttribute('download', aTag.previousElementSibling.value)
          eventEmitter.emit('textae-event.resource.annotation.save', data)
          closeDialog()
        }
      )

      delegate_default()(
        element,
        '.textae-editor__save-dialog__viewsource-link',
        'click',
        () => {
          window.open(createDownloadPath(data), '_blank')
          eventEmitter.emit('textae-event.resource.annotation.save', data)
          closeDialog()
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/SaveAnnotationDialog/index.js

    function SaveAnnotationDialog_template(context) {
      const { url, filename } = context

      return `
<div class="textae-editor__save-dialog__container">
  <div class="textae-editor__save-dialog__row">
    <label>URL</label>
    <input 
      type="text"
      value="${url}"
      class="textae-editor__save-dialog__url-text">
    <input 
      type="button"
      class="textae-editor__save-dialog__url-button"
      ${url ? '' : `disabled="disabled"`}
      value="Save">
  </div>
  <div class="textae-editor__save-dialog__row">
    <label>Local</label>
    <input
      type="text"
      value="${filename}"
      >
    <a class="textae-editor__save-dialog__download-link" href="#">Download</a>
  </div>
  <div class="textae-editor__save-dialog__row">
    <a class="textae-editor__save-dialog__viewsource-link" href="#">Click to see the json source in a new window.</a>
  </div>
</div>
`
    }

    class SaveAnnotationDialog extends Dialog {
      constructor(eventEmitter, url, filename, data, saveAnnotation) {
        super(
          'Save Annotations',
          SaveAnnotationDialog_template({ filename, url })
        )

        bind(eventEmitter, super.el, data, () => super.close(), saveAnnotation)
      }
    }

    // EXTERNAL MODULE: ./node_modules/jsondiffpatch/dist/jsondiffpatch.umd.js
    var jsondiffpatch_umd = __webpack_require__(5311) // CONCATENATED MODULE: ./src/lib/component/SaveConfigurationDialog/jsonDiff.js
    const jsond = (0, jsondiffpatch_umd.create)({
      objectHash(obj, index) {
        return obj.id || `$$index:${index}`
      }
    })

    /* harmony default export */ function jsonDiff(
      originalConfig,
      editedConfig
    ) {
      const delta = jsond.diff(originalConfig, editedConfig)
      return jsondiffpatch_umd.formatters.html.format(delta, originalConfig)
    } // CONCATENATED MODULE: ./src/lib/component/SaveConfigurationDialog/bind.js

    /* harmony default export */ function SaveConfigurationDialog_bind(
      eventEmitter,
      element,
      editedData,
      closeDialog,
      saveConfiguration
    ) {
      // Disabled the button to save to the URL when no URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'input',
        (e) => {
          enableHTMLElement(e.target.nextElementSibling, e.target.value)
        }
      )

      // Save to the URL.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-text',
        'keyup',
        (e) => {
          if (e.keyCode === 13) {
            saveConfiguration(e.target.value)
            closeDialog()
          }
        }
      )
      delegate_default()(
        element,
        '.textae-editor__save-dialog__url-button',
        'click',
        (e) => {
          saveConfiguration(e.target.previousElementSibling.value)
          closeDialog()
        }
      )

      // Download as a JSON file.
      delegate_default()(
        element,
        '.textae-editor__save-dialog__download-link',
        'click',
        (e) => {
          const aTag = e.target
          const downloadPath = createDownloadPath(editedData)
          aTag.setAttribute('href', downloadPath)
          aTag.setAttribute('download', aTag.previousElementSibling.value)
          eventEmitter.emit(
            'textae-event.resource.configuration.save',
            editedData
          )
          closeDialog()
        }
      )
    } // CONCATENATED MODULE: ./src/lib/component/SaveConfigurationDialog/index.js

    function SaveConfigurationDialog_template(context) {
      const { url, filename, diff } = context

      return `
<div class="textae-editor__save-dialog__container">
  <div class="textae-editor__save-dialog__row">
    <label>URL</label>
    <input 
      type="text" value="${url}" 
      class="textae-editor__save-dialog__url-text">
    <input 
      type="button" 
      class="textae-editor__save-dialog__url-button"
      ${url ? '' : `disabled="disabled"`}
      value="Save">
  </div>
  <div class="textae-editor__save-dialog__row">
    <label>Local</label>
    <input
      type="text" value="${filename}" 
      >
    <a class="textae-editor__save-dialog__download-link" href="#">Download</a>
  </div>
  <div class="textae-editor__save-dialog__row">
    <div class="textae-editor__save-dialog__diff-title">
      Configuration differences
      <span class="textae-editor__save-dialog__diff-add-legend">added</span>
      <span class="textae-editor__save-dialog__diff-remove-legend">removed</span>
    </div>
    <div class="textae-editor__save-dialog__diff-viewer">${diff}</div>
  </div>
</div>
`
    }

    class SaveConfigurationDialog extends Dialog {
      constructor(
        eventEmitter,
        url,
        filename,
        originalData,
        editedData,
        saveConfiguration
      ) {
        super(
          'Save Configurations',
          SaveConfigurationDialog_template({
            filename,
            url,
            diff: jsonDiff(originalData, editedData) || 'nothing.'
          }),

          {
            maxWidth: 550
          }
        )

        // Hide unchanged diff.
        this._$dialog.on('dialogopen', () =>
          jsondiffpatch_umd.formatters.html.hideUnchanged()
        )

        SaveConfigurationDialog_bind(
          eventEmitter,
          super.el,
          editedData,
          () => super.close(),
          saveConfiguration
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/PersistenceInterface/readFile.js

    /* harmony default export */ async function readFile(file) {
      return new Promise((resolve) => {
        const reader = new FileReader()

        reader.onload = (event) => resolve(event)
        reader.readAsText(file)
      })
    }

    // EXTERNAL MODULE: ./node_modules/path-browserify/index.js
    var path_browserify = __webpack_require__(6470)
    var path_browserify_default =
      /*#__PURE__*/ __webpack_require__.n(path_browserify) // CONCATENATED MODULE: ./src/lib/Editor/UseCase/PersistenceInterface/isTxtFile.js
    /* harmony default export */ function isTxtFile(fileName) {
      return path_browserify_default().extname(fileName) === '.txt'
    } // CONCATENATED MODULE: ./src/lib/Editor/DataSource/toSourceString.js

    /* harmony default export */ function toSourceString(sourceType, source) {
      switch (sourceType) {
        case 'url':
          return new URL(source, location.href).href
        case 'local file':
          return `${source}(local file)`
        case 'inline':
          return 'inline'
        case 'instant':
          return 'instant'
        default:
          throw `unknown source type: ${sourceType}.`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/DataSource/index.js

    class DataSource {
      constructor(type, id, data) {
        this._type = type
        this._id = id
        this._data = data
      }

      get type() {
        return this._type
      }

      get id() {
        return this._id
      }

      get data() {
        return this._data
      }

      get displayName() {
        return toSourceString(this._type, this._id)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/PersistenceInterface/readAnnotationFile.js

    /* harmony default export */ async function readAnnotationFile(
      file,
      eventEmitter
    ) {
      const event = await readFile(file)
      const fileContent = event.target.result

      if (isTxtFile(file.name)) {
        // If this is .txt, New annotation json is made from .txt
        eventEmitter.emit(
          'textae-event.resource.annotation.load.success',
          new DataSource('local file', file.name, {
            text: fileContent
          })
        )

        return
      }

      if (isJSON(fileContent)) {
        const annotation = JSON.parse(fileContent)

        if (annotation.text) {
          eventEmitter.emit(
            'textae-event.resource.annotation.load.success',
            new DataSource('local file', file.name, annotation)
          )

          return
        }
      }

      eventEmitter.emit(
        'textae-event.resource.annotation.format.error',
        new DataSource('local file', file.name)
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/PersistenceInterface/readConfigurationFile.js

    /* harmony default export */ function readConfigurationFile(
      file,
      eventEmitter
    ) {
      readFile(file).then(({ target }) => {
        if (isJSON(target.result)) {
          eventEmitter.emit(
            'textae-event.resource.configuration.load.success',
            new DataSource('local file', file.name, JSON.parse(target.result))
          )
        } else {
          eventEmitter.emit(
            'textae-event.resource.configuration.format.error',
            new DataSource('local file', file.name)
          )
        }
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/loadAnnotation.js

    function loadAnnotation(eventEmitter, annotation) {
      if (!annotation.text) {
        return false
      }

      eventEmitter.emit(
        'textae-event.resource.annotation.load.success',
        new DataSource('instant', null, annotation)
      )

      return true
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/PersistenceInterface/readAnnotationText.js

    function readAnnotationText(eventEmitter, text) {
      if (!isJSON(text)) {
        return false
      }

      return loadAnnotation(eventEmitter, JSON.parse(text))
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/PersistenceInterface/index.js

    class PersistenceInterface {
      constructor(
        eventEmitter,
        remoteResource,
        annotationModel,
        getOriginalAnnotation,
        getOriginalConfig,
        saveToParameter,
        annotationModelEventsObserver,
        controlViewModel
      ) {
        this._eventEmitter = eventEmitter
        this._remoteResource = remoteResource
        this._annotationModel = annotationModel
        this._getOriginalAnnotation = getOriginalAnnotation
        this._getOriginalConfig = getOriginalConfig
        this._saveToParameter = saveToParameter
        this._annotationModelEventsObserver = annotationModelEventsObserver
        this._controlViewModel = controlViewModel

        // Store the filename of the annotation and configuration.
        this._filenameOfLastRead = {
          annotation: '',
          configuration: ''
        }

        eventEmitter
          .on('textae-event.pallet.import-button.click', () =>
            this.importConfiguration()
          )
          .on('textae-event.pallet.upload-button.click', () =>
            this.uploadConfiguration()
          )
      }

      importAnnotation() {
        new LoadDialog(
          'Load Annotations',
          this._remoteResource.annotationUrl,
          (url) => this._remoteResource.loadAnnotation(url),
          (file) => {
            readAnnotationFile(file, this._eventEmitter)
            this._filenameOfLastRead.annotation = file.name
          },
          (text) => {
            if (readAnnotationText(this._eventEmitter, text)) {
              return
            }

            this._eventEmitter.emit(
              'textae-event.resource.annotation.format.error',
              new DataSource('instant', null)
            )
          },
          this._annotationModelEventsObserver.hasChange
        ).open()
      }

      uploadAnnotation() {
        new SaveAnnotationDialog(
          this._eventEmitter,
          this._saveToParameter || this._remoteResource.annotationUrl,
          this._filenameOfLastRead.annotation,
          this._editedAnnotation,
          (url) =>
            this._remoteResource.saveAnnotation(url, this._editedAnnotation)
        ).open()
      }

      saveAnnotation() {
        this._remoteResource.saveAnnotation(
          this._saveToParameter || this._remoteResource.annotationUrl,
          this._editedAnnotation
        )
      }

      importConfiguration() {
        new LoadDialog(
          'Load Configurations',
          this._remoteResource.configurationUrl,
          (url) => this._remoteResource.loadConfiguration(url),
          (file) => {
            readConfigurationFile(file, this._eventEmitter)
            this._filenameOfLastRead.configuration = file.name
          },
          (text) => {
            if (isJSON(text)) {
              this._eventEmitter.emit(
                'textae-event.resource.configuration.load.success',
                new DataSource('instant', null, JSON.parse(text))
              )
            } else {
              this._eventEmitter.emit(
                'textae-event.resource.configuration.format.error',
                new DataSource('instant', null)
              )
            }
          },
          this._controlViewModel.diffOfConfiguration
        ).open()
      }

      uploadConfiguration() {
        // Merge with the original config and save the value unchanged in the editor.
        const editedConfig = {
          ...this._getOriginalConfig(),
          ...this._annotationModel.typeDefinition.config
        }

        new SaveConfigurationDialog(
          this._eventEmitter,
          this._remoteResource.configurationUrl,
          this._filenameOfLastRead.configuration,
          this._getOriginalConfig(),
          editedConfig,
          (url) => this._remoteResource.saveConfiguration(url, editedConfig)
        ).open()
      }

      get _editedAnnotation() {
        return {
          ...this._getOriginalAnnotation(),
          ...this._annotationModel.externalFormat,
          ...{
            config: this._annotationModel.typeDefinition.config
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/setAnnotationAndConfiguration.js

    /**
     *
     * @param {import('./ControlViewModel').default} controlViewModel
     * @param {import('../AnnotationModel').AnnotationModel} annotationModel
     */
    /* harmony default export */ function setAnnotationAndConfiguration(
      validConfig,
      controlViewModel,
      spanConfig,
      annotationModel,
      annotation,
      functionAvailability
    ) {
      controlViewModel.setPushBUttons(validConfig)
      spanConfig.set(validConfig)
      annotationModel.reset(annotation, validConfig)
      functionAvailability.availability = validConfig['function availability']
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/fillInferDefinitionFromAnnotation/fill.js

    // Complement the config with the generated Attribute definition.
    // Does not override the existing Attribute definition.
    /* harmony default export */ function fill(
      config,
      newAttributeDefinitions
    ) {
      for (const newDef of newAttributeDefinitions) {
        const index = config.findIndex((a) => a.pred === newDef.pred)
        if (index !== -1) {
          config[index] = { ...newDef, ...config[index] }
        } else {
          config.push(newDef)
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/getValueType.js

    /* harmony default export */ function getValueType(obj) {
      if (obj === true) {
        return 'flag'
      } else if (typeof obj === 'number') {
        return 'numeric'
      } else if (typeof obj === 'string') {
        return 'string'
      } else {
        throw `${JSON.stringify(obj)} is an unexpected value for an Attribute.`
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/getMostFrequentObject.js

    // The default value is the value of the first object of the most frequent object.
    /* harmony default export */ function getMostFrequentObject(objects) {
      const objectFrequencyMap = objects.reduce((map, obj) => {
        if (map.has(obj)) {
          return map.set(obj, map.get(obj) + 1)
        } else {
          return map.set(obj, 1)
        }
      }, new Map())

      const maximumFrequency = Math.max(...objectFrequencyMap.values())

      for (const [obj, frq] of objectFrequencyMap.entries()) {
        if (frq === maximumFrequency) {
          return obj
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/getStep.js

    // The value of step is matched to the smallest digit of all objcts.
    /* harmony default export */ function getStep(objects) {
      const numberOfDigits = Math.max(
        ...objects.map((o) => {
          const [_, smallNumber] = String(o).split('.')
          return smallNumber ? smallNumber.length : 0
        })
      )

      // The step is a small number of the specified number of digits, with the lowest digit being 1.
      return Number(
        Array.from(Array(numberOfDigits))
          .reduce((acc, _) => acc * 0.1, 1)
          .toFixed(numberOfDigits)
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/AnnotationsForPred/index.js

    class AnnotationsForPred {
      constructor({ pred, obj }) {
        this._pred = pred
        this._objects = [obj]
      }

      push(obj) {
        this._objects.push(obj)
      }

      // It is not possible to generate a selection attribute definition.
      // Since it is not possible to determine whether the value type is a string or a selection from the annotation,
      // it is always treated as a string.
      get definition() {
        switch (getValueType(this._objects[0])) {
          case 'flag':
            return this._prototype
          case 'numeric':
            return this._numericAttribute
          case 'string':
            return this._stringAttribute

          default:
            throw new Error(`prototype: ${JSON.stringify(this._prototype)}`)
        }
      }

      get mostFrequentObject() {
        return getMostFrequentObject(this._objects)
      }

      get _prototype() {
        return {
          pred: this._pred,
          'value type': getValueType(this._objects[0])
        }
      }

      get _numericAttribute() {
        return {
          min: Math.min(...this._objects),
          max: Math.max(...this._objects),
          step: getStep(this._objects),
          default: getMostFrequentObject(this._objects),
          ...this._prototype
        }
      }

      get _stringAttribute() {
        return {
          default: getMostFrequentObject(this._objects),
          ...this._prototype
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/getAnnotationMap.js

    /* harmony default export */ function getAnnotationMap(annotations) {
      return annotations.reduce((map, attr) => {
        if (map.has(attr.pred)) {
          map.get(attr.pred).push(attr.obj)
        } else {
          map.set(attr.pred, new AnnotationsForPred(attr))
        }
        return map
      }, new Map())
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/fillInferDefinitionFromAnnotation/inferDefinitionFromAnnotation/index.js

    // Generates a definition of an attribute by inferring a definition from the value of an annotation.
    /* harmony default export */ function inferDefinitionFromAnnotation(
      annotations
    ) {
      return [...getAnnotationMap(annotations).values()].map(
        (a) => a.definition
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/fillInferDefinitionFromAnnotation/index.js

    /* harmony default export */ function fillInferDefinitionFromAnnotation(
      config,
      annotations
    ) {
      const inferDefinitions = inferDefinitionFromAnnotation(annotations)
      return fill(config, inferDefinitions)
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/clone.js

    /* harmony default export */ function clone(config) {
      return config ? JSON.parse(JSON.stringify(config)) : {}
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/fillDefaultValueOfSelectionAttributes/getSelectionAttributes.js

    /* harmony default export */ function getSelectionAttributes(config) {
      return config.filter((a) => a['value type'] === 'selection')
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/fillDefaultValueOfSelectionAttributes/index.js

    // Sets a default value for the definition of a selection attribute that does not have a default value.
    //
    // A sample definition of the full form of the selection attribute:
    // {
    //   "pred": "denote",
    //   "value type": "selection",
    //   "values": [
    //     {
    //       "color": "#0000FF",
    //       "label": "Regulation",
    //       "id": "http://www.yahoo.co.jp/eeeeeeeeeeeeeeeeeoaoeuaoeuaoue",
    //       "default": true
    //     },
    //     {
    //       "color": "#FF0000",
    //       "id": "Cell"
    //     },
    //     {
    //       "id": "equivalentTo"
    //     }
    //   ]
    // }
    //
    // A sample of selection attribute annotation:
    // {
    //   "id": "A3",
    //   "subj": "E1:a:b",
    //   "pred": "denote",
    //   "obj": "Cell"
    // }
    /* harmony default export */ function fillDefaultValueOfSelectionAttributes(
      config,
      annotations
    ) {
      config = clone(config)

      const annotationMap = getAnnotationMap(annotations)
      for (const attr of getSelectionAttributes(config)) {
        if (!attr.values || attr.values.length === 0) {
          attr.values = [{ id: 'default', default: true }]
          continue
        }

        if (!attr.values.find((v) => v.default === true)) {
          // If this attribute is used in the annotation, it defaults to the most commonly used value.
          // Unless it is not used in the annotation, the first value is the default.
          if (annotationMap.has(attr.pred)) {
            const afp = annotationMap.get(attr.pred)
            attr.values.find((v) => v.id === afp.mostFrequentObject).default =
              true
          } else {
            attr.values[0].default = true
          }
          continue
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/fillMandatoryValueOfNumericAttributes.js

    /* harmony default export */ function fillMandatoryValueOfNumericAttributes(
      config
    ) {
      config = clone(config)

      for (const a of config.filter((a) => a['value type'] === 'numeric')) {
        if (!Object.prototype.hasOwnProperty.call(a, 'default')) {
          a.default = DEFAULT
        }
        if (!Object.prototype.hasOwnProperty.call(a, 'step')) {
          a.step = STEP
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/fillDefaultValueOfStringAttributes.js

    /* harmony default export */ function fillDefaultValueOfStringAttributes(
      config
    ) {
      config = clone(config)

      for (const a of config.filter((a) => a['value type'] === 'string')) {
        if (!Object.prototype.hasOwnProperty.call(a, 'default')) {
          a.default = ''
        }
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/AttributeConfigurationGenerator/index.js

    class AttributeConfigurationGenerator {
      constructor(config = [], annotations = []) {
        this._annotations = annotations
        this._config = config
      }

      get configuration() {
        let newConfig = fillInferDefinitionFromAnnotation(
          this._config,
          this._annotations
        )
        newConfig = fillMandatoryValueOfNumericAttributes(newConfig)
        newConfig = fillDefaultValueOfStringAttributes(newConfig)
        newConfig = fillDefaultValueOfSelectionAttributes(
          newConfig,
          this._annotations
        )

        return newConfig
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/patchConfiguration/index.js

    /* harmony default export */ function patchConfiguration(
      annotation,
      config
    ) {
      console.assert(annotation)

      // Note that if you don't make a copy, the reference to the original attribute types will be lost.
      config = clone(config)

      config['attribute types'] = new AttributeConfigurationGenerator(
        config['attribute types'],
        annotation.attributes
      ).configuration

      if (annotation.tracks) {
        for (const track of annotation.tracks) {
          config['attribute types'] = new AttributeConfigurationGenerator(
            config['attribute types'],
            track.attributes
          ).configuration
        }
      }

      return config
    }

    // EXTERNAL MODULE: ./node_modules/ajv/dist/ajv.js
    var ajv = __webpack_require__(1581)
    var ajv_default = /*#__PURE__*/ __webpack_require__.n(ajv)
    // EXTERNAL MODULE: ./node_modules/ajv-formats/dist/index.js
    var ajv_formats_dist = __webpack_require__(5477)
    var dist_default = /*#__PURE__*/ __webpack_require__.n(ajv_formats_dist) // CONCATENATED MODULE: ./src/lib/Editor/UseCase/validateConfigurationAndAlert/validateConfiguration/configurationScheme.json
    const configurationScheme_namespaceObject = JSON.parse(
      '{"$schema":"http://json-schema.org/draft-07/schema#","title":"JSON schema for texta configuration files","definitions":{"characters":{"type":"array","items":{"type":"string","minLength":1,"maxLength":1}},"color":{"pattern":"^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$","type":"string"},"default":{"type":"boolean"},"denote":{"type":"object","required":["id"],"properties":{"id":{"type":"string"},"label":{"type":"string"},"color":{"$ref":"#/definitions/color"},"default":{"$ref":"#/definitions/default"}}},"types":{"type":"array","items":{"$ref":"#/definitions/denote"}},"autocompletion_ws":{"type":"string","format":"uri-reference"}},"type":"object","properties":{"delimiter characters":{"$ref":"#/definitions/characters"},"non-edge characters":{"$ref":"#/definitions/characters"},"autocompletion_ws":{"$ref":"#/definitions/autocompletion_ws"},"autosave":{"type":"boolean"},"autolineheight":{"type":"boolean"},"boundarydetection":{"type":"boolean"},"entity types":{"$ref":"#/definitions/types"},"relation types":{"$ref":"#/definitions/types"},"attribute types":{"type":"array","items":{"type":"object","required":["pred","value type"],"properties":{"pred":{"type":"string"},"value type":{"enum":["flag","selection","string","numeric"]}},"allOf":[{"if":{"properties":{"value type":{"const":"flag"}}},"then":{"properties":{"color":{"$ref":"#/definitions/color"},"label":{"type":"string"}}}},{"if":{"properties":{"value type":{"const":"selection"}}},"then":{"required":["values"],"properties":{"values":{"type":"array","items":{"$ref":"#/definitions/denote"}}}}},{"if":{"properties":{"value type":{"const":"string"}}},"then":{"required":["default"],"properties":{"autocompletion_ws":{"$ref":"#/definitions/autocompletion_ws"},"default":{"type":"string"},"values":{"type":"array","items":{"type":"object","required":["pattern"],"properties":{"pattern":{"type":"string","format":"regex"},"label":{"type":"string"},"color":{"$ref":"#/definitions/color"}}}}}}},{"if":{"properties":{"value type":{"const":"numeric"}}},"then":{"required":["default","step"],"properties":{"default":{"type":"number"},"min":{"type":"number"},"max":{"type":"number"},"step":{"type":"number"},"values":{"type":"array","items":{"type":"object","required":["range"],"properties":{"range":{"type":"string"},"label":{"type":"string"},"color":{"$ref":"#/definitions/color"}}}}}}}]}},"function availability":{"type":"object","properties":{"read":{"type":"boolean"},"write":{"type":"boolean"},"write-auto":{"type":"boolean"},"view":{"type":"boolean"},"term":{"type":"boolean"},"block":{"type":"boolean"},"relation":{"type":"boolean"},"simple":{"type":"boolean"},"line-height":{"type":"boolean"},"line-height-auto":{"type":"boolean"},"undo":{"type":"boolean"},"redo":{"type":"boolean"},"replicate":{"type":"boolean"},"replicate-auto":{"type":"boolean"},"boundary-detection":{"type":"boolean"},"create-span-by-touch":{"type":"boolean"},"expand-span-by-touch":{"type":"boolean"},"shrink-span-by-touch":{"type":"boolean"},"entity":{"type":"boolean"},"pallet":{"type":"boolean"},"edit-properties":{"type":"boolean"},"delete":{"type":"boolean"},"copy":{"type":"boolean"},"cut":{"type":"boolean"},"paste":{"type":"boolean"},"setting":{"type":"boolean"},"help":{"type":"boolean"}}}}}'
    ) // CONCATENATED MODULE: ./src/lib/Editor/UseCase/validateConfigurationAndAlert/validateConfiguration/toErrorMessage.js
    /* harmony default export */ function toErrorMessage(errors) {
      for (const e of errors) {
        if (e.keyword === 'required') {
          return `Invalid configuration: The attribute type whose predicate is '${e.data.pred}' misses a mandatory property, '${e.params.missingProperty}'.`
        } else if (e.instancePath.includes('color')) {
          return anemone`Invalid configuration: '${e.data}' is invalid color format.`
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/validateConfigurationAndAlert/validateConfiguration/index.js

    const validateConfiguration_ajv = new (ajv_default())({ verbose: true })
    dist_default()(validateConfiguration_ajv, ['uri-reference', 'regex'])
    const validateConfiguration_validate = validateConfiguration_ajv.compile(
      configurationScheme_namespaceObject
    )

    /* harmony default export */ function validateConfiguration(config) {
      console.assert(config, 'config is required.')

      if (!validateConfiguration_validate(config)) {
        console.warn(validateConfiguration_validate.errors)

        return toErrorMessage(validateConfiguration_validate.errors)
      }

      return null
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/validateAttribueDefinitionAndAlert/hasAllValueDefinitionOfSelectionAttributes.js

    // Check for definitions of values for selection attributes.
    /* harmony default export */ function hasAllValueDefinitionOfSelectionAttributes(
      annotation,
      config
    ) {
      console.assert(
        config,
        `If you don't have a configuration, generate a configuration from the annotation.`
      )

      if (annotation.attributes) {
        const atrributeTypes = config['attribute types']

        const selectionAttributeValueWithoutDefinition = annotation.attributes
          .filter((attr) =>
            atrributeTypes.some(
              (attrDef) =>
                attrDef.pred === attr.pred &&
                attrDef['value type'] === 'selection'
            )
          )
          .filter(
            (attr) =>
              !atrributeTypes.some(
                (attrDef) =>
                  attrDef.pred === attr.pred &&
                  attrDef.values.some((v) => v.id === attr.obj)
              )
          )

        if (selectionAttributeValueWithoutDefinition.length) {
          console.warn(
            'selection attribute values without definition',
            selectionAttributeValueWithoutDefinition
          )

          return `selection attribute value definition for "${selectionAttributeValueWithoutDefinition
            .map((a) => a.obj)
            .join(', ')}" in configuration is missing. `
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/validateAttribueDefinitionAndAlert/index.js

    /* harmony default export */ function validateAttribueDefinitionAndAlert(
      annotation,
      config
    ) {
      const error = hasAllValueDefinitionOfSelectionAttributes(
        annotation,
        config
      )

      if (error) {
        alertify_default().error(error)
        return
      }

      return config
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/validateConfigurationAndAlert/index.js

    /* harmony default export */ function validateConfigurationAndAlert(
      annotation,
      config
    ) {
      const patchedConfig = patchConfiguration(annotation, config)
      const errorMessage = validateConfiguration(patchedConfig)
      if (errorMessage) {
        alertify_default().error(errorMessage)

        return
      }

      return validateAttribueDefinitionAndAlert(annotation, patchedConfig)
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/warningIfBeginEndOfSpanAreNotInteger/areNotBeginAndEndInteger.js

    /* harmony default export */ function areNotBeginAndEndInteger(annotation) {
      if (annotation.denotations) {
        for (const denotation of annotation.denotations) {
          if (denotation.span.begin !== parseInt(denotation.span.begin)) {
            return true
          }

          if (denotation.span.end !== parseInt(denotation.span.end)) {
            return true
          }
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/warningIfBeginEndOfSpanAreNotInteger/index.js

    /* harmony default export */ function warningIfBeginEndOfSpanAreNotInteger(
      annotation
    ) {
      if (areNotBeginAndEndInteger(annotation)) {
        alertify_default().warning(
          `In the annotation file, some of the begin and end offsets of denotations were not integer values.
      TextAE converted them to integer values.
      However, to avoid a chance of unexpected rendering, please fix them.`,
          15
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/initAnnotation/setDefault.js

    /* harmony default export */ function setDefault(
      originalData,
      controlViewModel,
      spanConfig,
      annotationModel,
      functionAvailability
    ) {
      setAnnotationAndConfiguration(
        originalData.defaultConfiguration,
        controlViewModel,
        spanConfig,
        annotationModel,
        originalData.defaultAnnotation,
        functionAvailability
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/initAnnotation/index.js

    /**
     *
     * @param {import('../../HTMLInlineOptions/AnnotationParameter.js').default} annotationParameter
     */
    /* harmony default export */ function initAnnotation(
      spanConfig,
      annotationModel,
      remoteResource,
      controlViewModel,
      originalData,
      annotationParameter,
      configParameter,
      functionAvailability
    ) {
      if (annotationParameter.isInline) {
        // Set an inline annotation.
        const dataSource = new DataSource(
          'inline',
          null,
          annotationParameter.inlineAnnotation
        )

        if (!dataSource.data.config && configParameter) {
          remoteResource.loadConfiguration(configParameter, dataSource)
        } else {
          warningIfBeginEndOfSpanAreNotInteger(dataSource.data)

          if (dataSource.data.config) {
            // When config is specified, it must be JSON.
            // For example, when we load an HTML file, we treat it as text here.
            if (typeof dataSource.data.config !== 'object') {
              alertify_default().error(
                `configuration in annotation file is invalid.`
              )
              return
            }
          }

          const validConfig = validateConfigurationAndAlert(
            dataSource.data,
            dataSource.data.config
          )

          if (validConfig) {
            setAnnotationAndConfiguration(
              validConfig,
              controlViewModel,
              spanConfig,
              annotationModel,
              dataSource.data,
              functionAvailability
            )

            originalData.annotation = dataSource
          }
        }
      } else if (annotationParameter.isRemote) {
        // Load an annotation from server.
        remoteResource.loadAnnotation(annotationParameter.URL)
      } else {
        if (configParameter) {
          remoteResource.loadConfiguration(configParameter)
        } else {
          setDefault(
            originalData,
            controlViewModel,
            spanConfig,
            annotationModel,
            functionAvailability
          )
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/OriginalData/StatusBar/html.js

    const html = `
<div class="textae-editor__footer">
  <div class="textae-editor__footer__message"></div>
</div>
`

    /* harmony default export */ const StatusBar_html = html // CONCATENATED MODULE: ./src/lib/Editor/UseCase/OriginalData/StatusBar/getAreaIn.js

    /* harmony default export */ function getAreaIn(container) {
      const area = container.querySelector('.textae-editor__footer__message')

      if (area) {
        return area
      }

      // The editor itself has a "white-space: pre" style for processing text that contains a series of whitespace.
      // In this case, HTML line breaks are included in the editor's height calculation.
      // Remove CRLF so that it is not included in the height calculation.
      container.insertAdjacentHTML(
        'beforeend',
        StatusBar_html.replace(/[\n\r]+/g, '')
      )
      return container.querySelector('.textae-editor__footer__message')
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/OriginalData/StatusBar/index.js

    class StatusBar {
      constructor(editorHTMLElement, isShow) {
        this._editorHTMLElement = editorHTMLElement
        this._isShow = isShow
      }

      set status(dataSource) {
        if (!this._isShow) {
          return
        }

        const message = dataSource.displayName

        if (message !== '') {
          getAreaIn(this._editorHTMLElement).innerHTML = isURI(message)
            ? `Source: ${`<a class="textae-editor__footer__message__link" href="${message}">${decodeURI(
                message
              )}</a>`}`
            : `Source: ${message}`
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/OriginalData/index.js

    // Manage the original annotations and the original configuration and merge the changes when you save them.
    class OriginalData {
      constructor(eventEmitter, editorHTMLElement, isShow) {
        this._eventEmitter = eventEmitter
        this._statusBar = new StatusBar(editorHTMLElement, isShow)
        this._map = new Map()

        eventEmitter
          .on('textae-event.resource.annotation.save', (editedData) => {
            this.annotation = new DataSource(null, null, editedData)
          })
          .on('textae-event.resource.configuration.save', (editedData) => {
            this.configuration = new DataSource(null, null, editedData)
          })
      }

      get defaultAnnotation() {
        return {
          text: 'Currently, the document is empty. Use the `import` button or press the key `i` to open a document with annotation.'
        }
      }

      get defaultConfiguration() {
        return patchConfiguration(this.defaultAnnotation)
      }

      get annotation() {
        return this._map.has('annotation')
          ? this._map.get('annotation').data
          : this.defaultAnnotation
      }

      set annotation(dataSource) {
        this._map.set('annotation', dataSource)
        if (dataSource.data.config) {
          this.configuration = new DataSource(
            null,
            null,
            dataSource.data.config
          )
        }

        if (dataSource.type) {
          this._statusBar.status = dataSource
        }
      }

      get configuration() {
        return this._map.has('configuration')
          ? this._map.get('configuration').data
          : {}
      }

      set configuration(dataSource) {
        this._map.set('configuration', dataSource)
        this._eventEmitter.emit(
          'textae-event.original-data.configuration.reset'
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/Buttons/definition.js

    const definition = [
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'import',
            title: 'Import [I]'
          },
          {
            type: 'upload',
            title: 'Upload [U]'
          },
          {
            type: 'upload automatically',
            title: 'Upload Automatically',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'view mode',
            title: 'View Mode',
            push: true
          },
          {
            type: 'term edit mode',
            title: 'Term Edit Mode',
            push: true
          },
          {
            type: 'block edit mode',
            title: 'Block Edit Mode',
            push: true
          },
          {
            type: 'relation edit mode',
            title: 'Relation Edit Mode',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'simple view',
            title: 'Simple View',
            push: true
          },
          {
            type: 'adjust lineheight',
            title: 'Adjust LineHeight'
          },
          {
            type: 'auto adjust lineheight',
            title: 'Auto Adjust LineHeight',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'undo',
            title: 'Undo [Z]'
          },
          {
            type: 'redo',
            title: 'Redo [A]'
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'replicate span annotation',
            title: 'Replicate span annotation [R]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.single &&
              selectionModel.span.single.isDenotation
          },
          {
            type: 'auto replicate',
            title: 'Auto replicate',
            push: true
          },
          {
            type: 'boundary detection',
            title: 'Boundary Detection [B]',
            push: true
          }
        ]
      },
      {
        usage: {
          'keyboard device': [],
          'touce device': ['control bar', 'context menu']
        },
        list: [
          { type: 'create span by touch', title: 'Create span' },
          { type: 'expand span by touch', title: 'Expand span' },
          { type: 'shrink span by touch', title: 'Shrink span' }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar', 'context menu'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'new entity',
            title: 'New entity [E]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.contains((s) => s.isDenotation)
          },
          {
            type: 'pallet'
          },
          {
            type: 'edit properties',
            title: 'Edit Properties [W]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.entity.some || selectionModel.relation.some
          },
          {
            type: 'delete',
            title: 'Delete [D]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.some ||
              selectionModel.entity.some ||
              selectionModel.relation.some
          }
        ]
      },
      {
        usage: {
          'keyboard device': [],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'copy',
            title: 'Copy [C]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.contains((s) => s.isDenotation) ||
              selectionModel.entity.contains((e) => e.isDenotation)
          },
          {
            type: 'cut',
            title: 'Cut [X]',
            enableWhenSelecting: (selectionModel) =>
              selectionModel.span.contains((s) => s.isDenotation) ||
              selectionModel.entity.contains((e) => e.isDenotation)
          },
          {
            type: 'paste',
            title: 'Paste [V]',
            enableWhenSelecting: (selectionModel, clipBoard) =>
              (clipBoard.hasCopyingItem && selectionModel.span.some) ||
              (clipBoard.hasCuttingItem && Boolean(selectionModel.span.single))
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar'],
          'touce device': ['control bar']
        },
        list: [
          {
            type: 'setting',
            title: 'Setting'
          }
        ]
      },
      {
        usage: {
          'keyboard device': ['control bar'],
          'touce device': []
        },
        list: [
          {
            type: 'help',
            title: 'Help [H]'
          }
        ]
      }
    ] // CONCATENATED MODULE: ./src/lib/Editor/isAndroid.js

    /* harmony default export */ function isAndroid() {
      // For development environments, Use the navigator.userAgent.
      // Because the navigator.userAgentData only work in the secure context(HTTPS).
      // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgentData
      return /Android/.test(navigator.userAgent)
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/Buttons/index.js

    function isIOS() {
      // iPad Safari (iPadOS 14 or later) does not include the string iPad in its userAgent.
      // see https://iwb.jp/ipad-safari-javascript-useragent-is-not-ipad/
      return (
        /iPad/.test(navigator.userAgent) ||
        /iPhone/.test(navigator.userAgent) ||
        (/Macintosh/.test(navigator.userAgent) && isTouchable())
      )
    }

    class Buttons {
      // Buttons to display on the control bar.
      get controlBar() {
        return definition
          .filter(({ usage }) => {
            // To make it easier to guess the result, don't use the screen size to judge the device.
            if (isAndroid() || isIOS()) {
              return usage['touce device'].includes('control bar')
            } else {
              return usage['keyboard device'].includes('control bar')
            }
          })
          .map(({ list }) => ({
            list: list.map(({ type, title }) => ({
              type,
              title
            }))
          }))
      }

      // Buttons to display on the context menu.
      get contextMenu() {
        return definition
          .filter(({ usage }) => {
            if (isTouchable()) {
              return usage['touce device'].includes('context menu')
            } else {
              return usage['keyboard device'].includes('context menu')
            }
          })
          .map(({ list }) => ({
            list: list.map(({ type, title }) => ({
              type,
              title
            }))
          }))
      }

      get pasteButton() {
        return this._buttonList.find(({ type }) => type === 'paste')
      }

      get enabelButtonsWhenSelecting() {
        return this._buttonList.filter((b) => b.enableWhenSelecting)
      }

      get pushButtons() {
        return this._buttonList.filter((b) => b.push).map((b) => b.type)
      }

      get _buttonList() {
        return definition.map(({ list }) => list).flat()
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/PushButtons/PushButton.js

    class PushButton {
      constructor(name, eventEmitter = null) {
        this._name = name
        this._eventEmitter = eventEmitter
        this._isPushed = false
      }

      get name() {
        return this._name
      }

      get isPushed() {
        return this._isPushed
      }

      set isPushed(value) {
        this._isPushed = value
        this._propagate()
      }

      toggle() {
        this._isPushed = !this._isPushed
        this._propagate()
      }

      _propagate() {
        if (this._eventEmitter) {
          this._eventEmitter.emit('textae-event.control.button.push', this)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/PushButtons/index.js

    class PushButtons {
      constructor(eventEmitter) {
        this._buttons = new Buttons().pushButtons.reduce((map, name) => {
          map.set(name, new PushButton(name, eventEmitter))
          return map
        }, new Map())

        // Bind an event.
        eventEmitter.on(
          'textae-event.edit-mode.transition',
          (mode, withRelation) => this._setMode(mode, !withRelation)
        )

        // default pushed;
        this._buttons.get('boundary detection').pushued = true
      }

      get(name) {
        return this._buttons.has(name)
          ? this._buttons.get(name)
          : new PushButton(name)
      }

      get names() {
        return this._buttons.keys()
      }

      _setMode(mode, isSimple) {
        switch (mode) {
          case MODE.VIEW:
            this._updateModeButtons(true, false, false, false, isSimple)
            break
          case MODE.EDIT_DENOTATION:
            this._updateModeButtons(false, true, false, false, isSimple)
            break
          case MODE.EDIT_BLOCK:
            this._updateModeButtons(false, false, true, false, isSimple)
            break
          case MODE.EDIT_RELATION:
            this._updateModeButtons(false, false, false, true, false)
            break
          default:
            throw `unknown edit mode!${mode}`
        }
      }

      _updateModeButtons(view, term, block, relation, simple) {
        this._buttons.get('view mode').isPushed = view
        this._buttons.get('term edit mode').isPushed = term
        this._buttons.get('block edit mode').isPushed = block
        this._buttons.get('relation edit mode').isPushed = relation
        this._buttons.get('simple view').isPushed = simple
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/EnableState.js

    class EnableState {
      constructor(eventEmitter, selectionModel, clipBoard) {
        // Enable always enabled buttons.
        this._states = new Map([
          ['import', true],
          ['upload', true],
          ['view mode', true],
          ['term edit mode', true],
          ['block edit mode', true],
          ['relation edit mode', true],
          ['simple view', true],
          ['setting', true],
          ['help', true]
        ])

        this._eventEmitter = eventEmitter
        this._selectionModel = selectionModel
        this._clipBoard = clipBoard

        eventEmitter
          .on('textae-event.history.change', (history) => {
            // change button state
            this.enable('undo', history.hasAnythingToUndo)
            this.enable('redo', history.hasAnythingToRedo)
          })
          .on('textae-event.selection.span.change', () => this._updateButtons())
          .on('textae-event.selection.relation.change', () =>
            this._updateButtons()
          )
          .on('textae-event.selection.entity.change', () =>
            this._updateButtons()
          )
          .on('textae-event.edit-mode.transition', (mode) =>
            this._setForMode(mode)
          )
          .on('textae-event.clip-board.change', () => this._updateByClipboard())
          .on('textae-event.annotation-auto-saver.enable', (enable) =>
            this.enable('upload automatically', enable)
          )
      }

      get(button) {
        return this._states.get(button)
      }

      enable(button, enable) {
        this._states.set(button, enable)
        this._propagate()
      }

      updateManipulateSpanButtons(
        enableToCreate,
        enableToExpand,
        enableToShrink
      ) {
        this._states.set('create span by touch', enableToCreate)
        this._states.set('expand span by touch', enableToExpand)
        this._states.set('shrink span by touch', enableToShrink)
        this._propagate()
      }

      _updateButtons() {
        for (const { type, enableWhenSelecting } of new Buttons()
          .enabelButtonsWhenSelecting) {
          this.enable(
            type,
            enableWhenSelecting(this._selectionModel, this._clipBoard)
          )
        }
        this._propagate()
      }

      _updateByClipboard() {
        this.enable(
          'paste',
          new Buttons().pasteButton.enableWhenSelecting(
            this._selectionModel,
            this._clipBoard
          )
        )
      }

      _propagate() {
        this._eventEmitter.emit(
          'textae-event.control.buttons.change',
          this._states.keys()
        )
      }

      _setForMode(mode) {
        switch (mode) {
          case MODE.VIEW:
            this._updateButtonsForMode(
              true,
              false,
              false,
              false,
              false,
              false,
              false
            )
            break
          case MODE.EDIT_DENOTATION:
            this._updateButtonsForMode(true, true, true, true, true, true, true)
            break
          case MODE.EDIT_BLOCK:
            this._updateButtonsForMode(
              true,
              false,
              true,
              true,
              true,
              true,
              true
            )
            break
          case MODE.EDIT_RELATION:
            this._updateButtonsForMode(
              false,
              false,
              false,
              true,
              true,
              false,
              true
            )
            break
          default:
            throw `unknown edit mode!${mode}`
        }
        this._propagate()
      }

      _updateButtonsForMode(
        simple,
        replicateAuto,
        boundaryDetection,
        lineHeight,
        lineHeightAuto,
        span,
        pallet
      ) {
        this._states.set('simple view', simple)
        this._states.set('auto replicate', replicateAuto)
        this._states.set('boundary detection', boundaryDetection)
        this._states.set('adjust lineheight', lineHeight)
        this._states.set('auto adjust lineheight', lineHeightAuto)
        this._states.set('create span by touch', span)
        this._states.set('expand span by touch', span)
        this._states.set('shrink span by touch', span)
        this._states.set('pallet', pallet)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/skipCharacters.js

    /* harmony default export */ function skipCharacters(
      getChars,
      step,
      str,
      position,
      predicate
    ) {
      while (predicate(getChars(str, position))) position += step

      return position
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/skipBlank.js

    const getNow = function (str, position) {
      return str.charAt(position)
    }
    const skipForwardBlank = function (str, position, isBlankCharacter) {
      return skipCharacters(getNow, 1, str, position, isBlankCharacter)
    }
    const skipBackBlank = function (str, position, isBlankCharacter) {
      return skipCharacters(getNow, -1, str, position, isBlankCharacter)
    }

    /* harmony default export */ const skipBlank = {
      forward: skipForwardBlank,
      back: skipBackBlank
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/SpanAdjuster.js

    class SpanAdjuster {
      backFromBegin(str, position, spanConfig) {}

      forwardFromEnd(str, position, spanConfig) {}

      forwardFromBegin(str, position, spanConfig) {}

      backFromEnd(str, position, spanConfig) {}
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/getPrev.js

    /* harmony default export */ function getPrev(str, position) {
      return [str.charAt(position), str.charAt(position - 1)]
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/backToDelimiter.js

    /* harmony default export */ function backToDelimiter(
      str,
      position,
      isDelimiter
    ) {
      return skipCharacters(getPrev, -1, str, position, (chars) => {
        // Proceed the position between two characters as (!delimiter delimiter) || (delimiter !delimiter) || (!delimiter !delimiter).
        return chars[1] && !isDelimiter(chars[0]) && !isDelimiter(chars[1])
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/getNext.js

    /* harmony default export */ function getNext(str, position) {
      return [str.charAt(position), str.charAt(position + 1)]
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/skipToDelimiter.js

    function skipToDelimiter(str, position, isDelimiter) {
      return skipCharacters(getNext, 1, str, position, (chars) => {
        // Proceed the position between two characters as (!delimiter delimiter) || (delimiter !delimiter) || (!delimiter !delimiter).
        // Return false to stop an infinite loop when the character undefined.
        return chars[1] && !isDelimiter(chars[0]) && !isDelimiter(chars[1])
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/isNotWord.js

    /* harmony default export */ function isNotWord(
      isBlankCharacter,
      isDelimiter,
      chars
    ) {
      // The word is (no charactor || blank || delimiter)(!delimiter).
      return (
        (chars[0] !== '' &&
          !isBlankCharacter(chars[1]) &&
          !isDelimiter(chars[1])) ||
        isDelimiter(chars[0])
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/skipToWord.js

    /* harmony default export */ function skipToWord(
      str,
      position,
      isWordEdge
    ) {
      return skipCharacters(getPrev, 1, str, position, isWordEdge)
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/backToWord.js

    /* harmony default export */ function backToWord(
      str,
      position,
      isWordEdge
    ) {
      return skipCharacters(getNext, -1, str, position, isWordEdge)
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/DelimiterDetectAdjuster/index.js

    class DelimiterDetectAdjuster extends SpanAdjuster {
      backFromBegin(str, beginPosition, spanConfig) {
        const nonEdgePos = skipBlank.forward(str, beginPosition, (char) =>
          spanConfig.isBlankCharacter(char)
        )
        const nonDelimPos = backToDelimiter(str, nonEdgePos, (char) =>
          spanConfig.isDelimiter(char)
        )

        return nonDelimPos
      }

      forwardFromEnd(str, endPosition, spanConfig) {
        const nonEdgePos = skipBlank.back(str, endPosition, (char) =>
          spanConfig.isBlankCharacter(char)
        )
        const nonDelimPos = skipToDelimiter(str, nonEdgePos, (char) =>
          spanConfig.isDelimiter(char)
        )

        return nonDelimPos
      }

      // adjust the beginning position of a span for shortening
      forwardFromBegin(str, beginPosition, spanConfig) {
        const isWordEdge = (chars) =>
          isNotWord(
            (char) => spanConfig.isBlankCharacter(char),
            (char) => spanConfig.isDelimiter(char),
            chars
          )

        return skipToWord(str, beginPosition, isWordEdge)
      }

      // adjust the end position of a span for shortening
      backFromEnd(str, endPosition, spanConfig) {
        const isWordEdge = (chars) =>
          isNotWord(
            (char) => spanConfig.isBlankCharacter(char),
            (char) => spanConfig.isDelimiter(char),
            chars
          )

        return backToWord(str, endPosition, isWordEdge)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/BlankSkipAdjuster.js

    class BlankSkipAdjuster extends SpanAdjuster {
      backFromBegin(str, position, spanConfig) {
        return skipBlank.forward(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }

      forwardFromEnd(str, position, spanConfig) {
        return skipBlank.back(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }

      forwardFromBegin(str, position, spanConfig) {
        return skipBlank.forward(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }

      backFromEnd(str, position, spanConfig) {
        return skipBlank.back(str, position, (char) =>
          spanConfig.isBlankCharacter(char)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/getPalletButtonTitleFor.js

    function getPalletButtonTitleFor(mode) {
      switch (mode) {
        case MODE.EDIT_DENOTATION:
          return 'Term Configuration'
        case MODE.EDIT_BLOCK:
          return 'Block Configuration'
        case MODE.EDIT_RELATION:
          return 'Relation Configuration'
        default:
          return ''
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/ControlViewModel/index.js

    class ControlViewModel {
      constructor(
        eventEmitter,
        selectionModel,
        clipBoard,
        annotationModelEventsObserver,
        originalData,
        typeDefinition,
        functionAvailability
      ) {
        this._enableState = new EnableState(
          eventEmitter,
          selectionModel,
          clipBoard
        )
        // Save state of push control buttons.
        this._pushButtons = new PushButtons(eventEmitter)

        this._annotationModelEventsObserver = annotationModelEventsObserver

        this._originalData = originalData

        this._typeDefinition = typeDefinition

        this._functionAvailability = functionAvailability

        // Change the title of the palette button to match the edit mode.
        eventEmitter.on('textae-event.edit-mode.transition', (mode) => {
          this._mode = mode
        })
      }

      get pushButtonNames() {
        return this._pushButtons.names
      }

      isPushed(buttonName) {
        return this._pushButtons.get(buttonName).isPushed
      }

      push(buttonName) {
        this._pushButtons.get(buttonName).isPushed = true
      }

      release(buttonName) {
        this._pushButtons.get(buttonName).isPushed = false
      }

      toggleButton(buttonName) {
        return this._pushButtons.get(buttonName).toggle()
      }

      get spanAdjuster() {
        return this.isPushed('boundary detection')
          ? new DelimiterDetectAdjuster()
          : new BlankSkipAdjuster()
      }

      get controlBarButton() {
        return new Buttons().controlBar
          .map(({ list }) =>
            list
              .filter(({ type }) => this._functionAvailability.get(type))
              .map(({ type, title }) => this._getPalletButtonTitle(type, title))
              .map(({ type, title }) => ({
                type,
                title,
                pushed: this.getState(type, 'pushed'),
                disabled: this.getState(type, 'disabled')
                // The status of transit cannot be referenced at the time of initialization.
                // The _convertToButtonHash method cannot be used.
              }))
          )
          .filter((list) => list.length)
      }

      get contextMenuButton() {
        return new Buttons().contextMenu
          .map(({ list }) =>
            list
              .filter(({ type }) => this._functionAvailability.get(type))
              .map(({ type, title }) => this._getPalletButtonTitle(type, title))
              .reduce((acc, { type, title }) => {
                if (!isTouchable() && this.getState(type, 'disabled')) {
                  return acc
                }

                acc.push(this._convertToButtonHash(type, title))
                return acc
              }, [])
          )
          .filter((list) => list.length)
      }

      getState(name, state) {
        switch (state) {
          case 'pushed':
            return this._pushButtons.get(name).isPushed
          case 'disabled':
            return !this._enableState.get(name)
          case 'transit':
            switch (name) {
              case 'upload':
                return this._annotationModelEventsObserver.hasChange
              case 'pallet':
                return this.diffOfConfiguration
              default:
                new Error('Unknown name')
            }
            break
          default:
            new Error('Unknown state')
        }
      }

      updateManipulateSpanButtons(
        enableToCreate,
        enableToExpand,
        enableToShrink
      ) {
        this._enableState.updateManipulateSpanButtons(
          enableToCreate,
          enableToExpand,
          enableToShrink
        )
      }

      get diffOfConfiguration() {
        return (0, jsondiffpatch_umd.diff)(this._originalData.configuration, {
          ...this._originalData.configuration,
          ...this._typeDefinition.config
        })
      }

      setPushBUttons(configuration) {
        if (configuration.autosave === true) {
          this.push('upload automatically')
        } else {
          this.release('upload automatically')
        }

        if (configuration.autolineheight === false) {
          this.release('auto adjust lineheight')
        } else {
          this.push('auto adjust lineheight')
        }

        if (configuration.boundarydetection === false) {
          this.release('boundary detection')
        } else {
          this.push('boundary detection')
        }
      }

      get detailModifierClassName() {
        return this._functionAvailability.get('show logo')
          ? 'textae-control-details--show-logo'
          : 'textae-control-details--hide-logo'
      }

      _getPalletButtonTitle(type, title) {
        return type == 'pallet'
          ? { type, title: getPalletButtonTitleFor(this._mode) }
          : { type, title }
      }

      _convertToButtonHash(type, title) {
        return {
          type,
          title,
          pushed: this.getState(type, 'pushed'),
          disabled: this.getState(type, 'disabled'),
          transit: this.getState(type, 'transit')
        }
      }
    } // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/native.js

    const randomUUID =
      typeof crypto !== 'undefined' &&
      crypto.randomUUID &&
      crypto.randomUUID.bind(crypto)
    /* harmony default export */ const esm_browser_native = {
      randomUUID
    } // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js
    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues
    const rnds8 = new Uint8Array(16)
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues =
          typeof crypto !== 'undefined' &&
          crypto.getRandomValues &&
          crypto.getRandomValues.bind(crypto)

        if (!getRandomValues) {
          throw new Error(
            'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
          )
        }
      }

      return getRandomValues(rnds8)
    } // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js
    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    const byteToHex = []

    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1))
    }

    function unsafeStringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      return (
        byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]
      )
    }

    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset) // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid')
      }

      return uuid
    }

    /* harmony default export */ const esm_browser_stringify =
      /* unused pure expression or super */ null && stringify // CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js
    function v4(options, buf, offset) {
      if (esm_browser_native.randomUUID && !buf && !options) {
        return esm_browser_native.randomUUID()
      }

      options = options || {}
      const rnds = options.random || (options.rng || rng)() // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = (rnds[6] & 0x0f) | 0x40
      rnds[8] = (rnds[8] & 0x3f) | 0x80 // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0

        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i]
        }

        return buf
      }

      return unsafeStringify(rnds)
    }

    /* harmony default export */ const esm_browser_v4 = v4 // CONCATENATED MODULE: ./src/lib/Editor/UseCase/Clipboard/index.js
    class Clipboard {
      /**
       * @param {import('../Commander').default} commander
       * @param {import('../../SelectionModel').default} selectionModel
       * @param {AttributeDefinitionContainer} attributeDefinitionContainer
       * */
      constructor(
        eventEmitter,
        commander,
        selectionModel,
        denotationDefinitionContainer,
        attributeDefinitionContainer,
        typeDefinition
      ) {
        this._eventEmitter = eventEmitter
        this._commander = commander
        this._selectionModel = selectionModel
        this._denotationDefinitionContainer = denotationDefinitionContainer
        this._attributeDefinitionContainer = attributeDefinitionContainer
        this._typeDefinition = typeDefinition

        // This list stores two types of things: type for copy and entity for cut.
        // Only one type is stored at a time.
        // Use one list.
        this._items = []
        this._uuid = esm_browser_v4()

        eventEmitter
          .on('textae-event.annotation-data.entity.remove', (entity) => {
            if (this.hasCuttingItem) {
              this._updateItems(this._items.filter((e) => e != entity))
            }
          })
          .on('textae-event.edit-mode.transition', () => this._updateItems())
      }

      get hasCopyingItem() {
        return this._items[0] instanceof TypeValues
      }

      get hasCuttingItem() {
        return this._items[0] instanceof EntityInstance
      }

      copyEntitiesToLocalClipboard() {
        this._updateItems(this._selectionModel.copyingTargets)
      }

      copyEntitiesToSystemClipboard(clipboardEvent) {
        if (this._selectionModel.span.contains((s) => s.isBlock)) {
          return
        }

        const { copyingTargets } = this._selectionModel

        if (copyingTargets.length > 0) {
          const entityTypes = this._denotationDefinitionContainer.config.filter(
            ({ id }) => copyingTargets.some(({ typeName }) => typeName === id)
          )

          const attributeTypes =
            this._attributeDefinitionContainer.config.filter(({ pred }) =>
              copyingTargets.some(({ attributes }) =>
                attributes.some((a) => a.pred === pred)
              )
            )

          const dataString = JSON.stringify({
            typeValues: copyingTargets.map(
              ({ externalFormat }) => externalFormat
            ),
            config: {
              'entity types': entityTypes,
              'attribute types': attributeTypes
            }
          })

          clipboardEvent.clipboardData.setData('text/plain', dataString)
          clipboardEvent.clipboardData.setData(
            'application/x-textae-type-values',
            dataString
          )
          clipboardEvent.preventDefault()
        }
      }

      cutEntitiesToLocalClipboard() {
        const { cuttingTargets } = this._selectionModel

        //  When exactly the same entities that are being cut are selected, the cut is canceled.
        if (
          this._cuttingItems.length &&
          this._cuttingItems.every((item) => cuttingTargets.has(item)) &&
          [...cuttingTargets].every((item) => this._cuttingItems.includes(item))
        ) {
          this._updateItems()
        } else {
          this._updateItems([...cuttingTargets])
        }
      }

      cutEntitiesToSystemClipboard(clipboardEvent) {
        if (this._selectionModel.span.contains((s) => s.isBlock)) {
          return
        }

        this.cutEntitiesToLocalClipboard()

        clipboardEvent.clipboardData.setData(
          'application/x-textae-editor-uuid',
          this._uuid
        )

        this.copyEntitiesToSystemClipboard(clipboardEvent)
      }

      pasteEntitiesFromLocalClipboard() {
        if (
          this._itemsWillBeCutAndPaste.length &&
          this._selectionModel.span.single
        ) {
          this._moveEntities()
          return
        }

        if (this.hasCopyingItem) {
          const command =
            this._commander.factory.pasteTypesToSelectedSpansCommand(
              this._items
            )
          this._commander.invoke(command)
        }
      }

      pasteEntitiesFromSystemClipboard(clipboardEvent) {
        if (this._selectionModel.span.contains((s) => s.isBlock)) {
          return
        }

        const uuid = clipboardEvent.clipboardData.getData(
          'application/x-textae-editor-uuid'
        )
        if (
          uuid === this._uuid &&
          this._itemsWillBeCutAndPaste.length &&
          this._selectionModel.span.single
        ) {
          this._moveEntities()
          return
        }

        const copyData = clipboardEvent.clipboardData.getData(
          'application/x-textae-type-values'
        )

        if (copyData) {
          const data = JSON.parse(copyData)
          const newAttrDefContainer = new AttributeDefinitionContainer()
          newAttrDefContainer.definedTypes = data.config['attribute types']

          if (this._typeDefinition.isLock) {
            const typeValuesList = data.typeValues.map(
              ({ obj, attributes }) =>
                new TypeValues(
                  obj,
                  attributes.filter(
                    ({ pred }) =>
                      this._attributeDefinitionContainer.get(pred) &&
                      this._attributeDefinitionContainer.get(pred).valueType ===
                        newAttrDefContainer.get(pred).valueType
                  )
                )
            )

            const command =
              this._commander.factory.pasteTypesToSelectedSpansCommand(
                typeValuesList
              )
            this._commander.invoke(command)
          } else {
            const typeValuesList = data.typeValues.map(
              ({ obj, attributes }) =>
                new TypeValues(
                  obj,
                  attributes.filter(
                    ({ pred }) =>
                      !this._attributeDefinitionContainer.get(pred) ||
                      this._attributeDefinitionContainer.get(pred).valueType ===
                        newAttrDefContainer.get(pred).valueType
                  )
                )
            )

            const newTypes = data.config['entity types'].filter(
              ({ id }) =>
                !this._denotationDefinitionContainer.config.some(
                  (type) => type.id === id
                )
            )
            const attrDefs = data.config['attribute types'].filter(
              ({ pred }) => !this._attributeDefinitionContainer.get(pred)
            )

            const command =
              this._commander.factory.pasteTypesToSelectedSpansCommand(
                typeValuesList,
                newTypes,
                attrDefs,
                this._getNewSelectionAttributeObjects(
                  typeValuesList,
                  newAttrDefContainer
                )
              )
            this._commander.invoke(command)
          }

          if (this.hasCuttingItem) {
            this._updateItems()
          }

          return
        }
      }

      // If there is an attribute definition for the selection attribute to be added
      // but the value definition is missing, add the value definition.
      _getNewSelectionAttributeObjects(typeValuesList, newAttrDefContainer) {
        const newSelectionAttributeObjects = []
        const selectionAttibutes = typeValuesList.reduce((list, typeValue) => {
          return list.concat(
            typeValue.attributes.filter(
              ({ pred }) =>
                newAttrDefContainer.get(pred).valueType === 'selection'
            )
          )
        }, [])
        for (const { pred, obj } of selectionAttibutes) {
          if (this._attributeDefinitionContainer.get(pred)) {
            if (
              !this._attributeDefinitionContainer
                .get(pred)
                .values.some(({ id }) => id === obj)
            ) {
              const value = newAttrDefContainer
                .get(pred)
                .values.find(({ id }) => id === obj)

              newSelectionAttributeObjects.push({
                pred,
                value
              })
            }
          }
        }
        return newSelectionAttributeObjects
      }

      _moveEntities() {
        const command =
          this._commander.factory.moveEntitiesToSelectedSpanCommand(
            this._itemsWillBeCutAndPaste
          )
        this._commander.invoke(command)
        this._updateItems()
      }

      // Notify items that are cutting and items that are no longer cutting
      // in order to switch between highlighting entities that are cutting.
      _updateItems(newItems = []) {
        const oldItems = this._cuttingItems.filter((i) => !newItems.includes(i))
        this._items = newItems

        this._eventEmitter.emit(
          'textae-event.clip-board.change',
          this._cuttingItems,
          oldItems
        )
      }

      // Exclude entities of the selected span.
      // When you cut and paste an entity,
      // the destination of the entity is the selected span.
      // If the destination and source spans are the same,
      // there is no change in the model.
      // In order to cause no change in the command history,
      // if the span of the entity being cut is the same as the span being selected, the entity is not pasted.
      get _itemsWillBeCutAndPaste() {
        return this._cuttingItems.filter(
          (i) =>
            i.span.id !==
            (this._selectionModel.span.single &&
              this._selectionModel.span.single.id)
        )
      }

      get _cuttingItems() {
        return this.hasCuttingItem ? this._items : []
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/AnnotationAutoSaver.js

    class AnnotationAutoSaver {
      constructor(
        eventEmitter,
        controlViewModel,
        persistenceInterface,
        saveToParameter,
        annotationModelEventsObserver
      ) {
        this._controlViewModel = controlViewModel

        const debounceSaveAnnotation = debounce_default()(
          () => persistenceInterface.saveAnnotation(),
          5000
        )

        eventEmitter
          .on('textae-event.resource.annotation.load.success', () =>
            this._disabled()
          )
          .on('textae-event.resource.save.error', () => this._disabled())
          .on('textae-event.resource.annotation.url.set', (dataSource) =>
            eventEmitter.emit(
              'textae-event.annotation-auto-saver.enable',
              Boolean(saveToParameter || dataSource.id)
            )
          )
          .on('textae-event.control.button.push', ({ name, isPushed }) => {
            // If there is something to save when the 'upload automatically' button is pushed,
            // it will be saved immediately.
            if (
              name === 'upload automatically' &&
              isPushed === true &&
              annotationModelEventsObserver.hasChange
            ) {
              persistenceInterface.saveAnnotation()
            }
          })
          .on(
            'textae-event.annotation-data.events-observer.unsaved-change',
            (val) => {
              if (val && controlViewModel.isPushed('upload automatically')) {
                debounceSaveAnnotation()
              }
            }
          )
      }

      _disabled() {
        if (this._controlViewModel.isPushed('upload automatically')) {
          this._controlViewModel.toggleButton('upload automatically')
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/Control/bindEventHandler.js

    const bindEventHandler_helpDialog = new HelpDialog()

    /* harmony default export */ function bindEventHandler(el, iconEventMap) {
      // Monitor the touchestart event to get the currently selected text.
      // On the iPad, the mousedown event fires after the text is deselected.
      delegate_default()(
        el,
        '.textae-control-icon',
        'touchstart',
        ({ target }) => {
          // Ignore disabled button's events.
          if (target.classList.contains('textae-control-icon--disabled')) {
            return
          }

          const { buttonType } = target.dataset
          switch (buttonType) {
            case 'create span by touch':
            case 'expand span by touch':
            case 'shrink span by touch':
              iconEventMap.handle(buttonType)
              break
            default:
          }
        },
        { passive: true }
      )

      delegate_default()(el, '.textae-control-icon', 'click', ({ target }) => {
        // Ignore disabled button's events.
        if (target.classList.contains('textae-control-icon--disabled')) {
          return
        }

        const { buttonType } = target.dataset
        switch (buttonType) {
          case 'help':
            bindEventHandler_helpDialog.open()
            break
          case 'create span by touch':
          case 'expand span by touch':
          case 'shrink span by touch':
            // Monitor the mousedown event to get the currently selected text.
            break
          default:
            iconEventMap.handle(buttonType)
        }
      })

      const hamburgerMenuButton = el.querySelector(
        '.textae-control-hamburger-menu-button'
      )
      if (hamburgerMenuButton) {
        hamburgerMenuButton.addEventListener('click', (e) =>
          e.target
            .closest('.textae-control')
            .querySelector('.textae-control-details')
            .classList.toggle('textae-control-details--force-show')
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/Control/index.js

    // The control is a control bar in an editor.
    class Control {
      constructor(html, iconEventMap) {
        const el = dohtml_default().create(html)

        this._el = el
        bindEventHandler(this._el, iconEventMap)
      }

      get el() {
        return this._el
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ControlBar/toButtonGroup/toButtonIcon.js

    /* harmony default export */ function toButtonIcon({
      type,
      title,
      classList
    }) {
      return `
<span 
class="${classList.join(' ')}" 
title="${title}" 
data-button-type="${type}">
</span>
`
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ControlBar/toButtonGroup/index.js

    /* harmony default export */ function toButtonGroup() {
      return (list) => `
  <span class="textae-control-separator"></span>
  ${list.map(toButtonIcon).join('\n')}
  `
    }

    // EXTERNAL MODULE: ./node_modules/sticky-js/index.js
    var sticky_js = __webpack_require__(5820)
    var sticky_js_default = /*#__PURE__*/ __webpack_require__.n(sticky_js) // CONCATENATED MODULE: ./src/lib/Editor/control/classify.js
    /* harmony default export */ function classify(buttonGroup) {
      return buttonGroup.map((list) => {
        const ret = []
        for (const { type, title, pushed, disabled, transit } of list) {
          const classList = [
            'textae-control-icon',
            `textae-control-${type.replaceAll(' ', '-')}-button`
          ]
          if (pushed) {
            classList.push('textae-control-icon--pushed')
          }
          if (disabled) {
            classList.push('textae-control-icon--disabled')
          }
          if (transit) {
            classList.push('textae-control-icon--transit')
          }

          ret.push({ type, title, classList })
        }

        return ret
      })
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ControlBar/index.js

    function ControlBar_template(context) {
      return `
<div class="textae-control ${
        isTouchable() ? 'textae-touch-bar' : 'textae-control-bar'
      }">
  <div class="textae-control-summary">
    <span class="textae-control-title">
      <a href="http://textae.pubannotation.org/" target="_blank">TextAE</a>
    </span>
    <button type="button" class="textae-control-hamburger-menu-button" >
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" class="bi" fill="currentColor" viewBox="0 0 16 16">
        <path fill-rule="evenodd" d="M2.5 11.5A.5.5 0 0 1 3 11h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 3h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>
      </svg>
    </button>
  </div>
  <div class="textae-control-details ${context.detailModifierClassName}">
    <span class="textae-control-title">
      <a href="http://textae.pubannotation.org/" target="_blank">TextAE</a>
    </span>
    ${classify(context.controlBarButton).map(toButtonGroup()).join('\n')}
  </div>
</div>
`
    }

    // The control is a control bar in an editor.
    class ControlBar extends Control {
      /**
       *
       * @param {import('../../UseCase/ControlViewModel').default} controlViewModel
       */
      constructor(eventEmitter, controlViewModel, iconEventMap) {
        super(ControlBar_template(controlViewModel), iconEventMap)

        this._controlViewModel = controlViewModel

        // If you use position: sticky,
        // the height of the toolbar will affect the Y coordinate of the textae-body
        // when the browser is not scrolling.
        // When the height of the toolbar is changed using the hamburger menu button,
        // the position of the textae-body will be raised or lowered.
        // When the browser is scrolling,
        // the position of the textae-body is not affected by the height of the toolbar,
        // so changing the height of the toolbar
        // will not raise or lower the position of the textae-body.
        // I would like to unify the behavior of the textae-body position
        // when scrolling with the browser and when not scrolling.
        // When displaying the hamburger menu button,
        // specify position: absolute for the toolbar
        // to exclude the toolbar from the calculation of the Y coordinate of the textae-body.
        // Instead, we will use JavaScript to adjust the position of the toolbar
        // as the browser scrolls.
        if (
          isTouchable() &&
          Math.max(document.documentElement.clientWidth, window.innerWidth) <
            768
        ) {
          new (sticky_js_default())('.textae-touch-bar', {
            stickyContainer: '.textae-editor'
          })
        }

        eventEmitter
          .on('textae-event.control.button.push', ({ name }) => {
            this._updateButton(name, 'pushed')
          })
          .on('textae-event.control.buttons.change', (buttons) => {
            for (const name of buttons) {
              this._updateButton(name, 'disabled')
            }
          })
          .on(
            'textae-event.annotation-data.events-observer.unsaved-change',
            () => {
              this._updateButton('upload', 'transit')
            }
          )
          .on('textae-event.edit-mode.transition', (mode) => {
            const title = getPalletButtonTitleFor(mode)
            const button = this._el.querySelector(
              `.textae-control-pallet-button`
            )
            button.title = title
          })
          .on('textae-event.original-data.configuration.reset', () =>
            this._redrawAllButtons()
          )
          .on('textae-event.type-definition.entity.change', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.entity.delete', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.entity.change-default', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.relation.change', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.relation.delete', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.relation.change-default', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.create', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.change', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.delete', () =>
            this._updateButton('pallet', 'transit')
          )
          .on('textae-event.type-definition.attribute.move', () =>
            this._updateButton('pallet', 'transit')
          )
      }

      _updateButton(buttonName, stateName) {
        const button = this._el.querySelector(
          `.textae-control-${buttonName.replaceAll(' ', '-')}-button`
        )

        if (button) {
          if (this._controlViewModel.getState(buttonName, stateName)) {
            button.classList.add(`textae-control-icon--${stateName}`)
          } else {
            button.classList.remove(`textae-control-icon--${stateName}`)
          }
        }
      }

      _redrawAllButtons() {
        this.el.innerHTML = ''
        this.el.insertAdjacentHTML(
          'beforeend',
          ControlBar_template(this._controlViewModel)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ContextMenu/toContextMenuItem.js

    /* harmony default export */ function toContextMenuItem({
      type,
      title,
      classList
    }) {
      return `<p 
    class="${classList.join(' ')}"  
    data-button-type="${type}">${title}
  </p>`
    } // CONCATENATED MODULE: ./src/lib/Editor/control/ContextMenu/index.js

    class ContextMenu extends Control {
      constructor(editorHTMLElement, controlViewModel, iconEventMap) {
        super(
          `<div class="textae-control ${
            isTouchable()
              ? 'textae-android-context-menu'
              : 'textae-context-menu'
          }"></div>`,
          iconEventMap
        )

        this._editorHTMLElement = editorHTMLElement
        this._controlViewModel = controlViewModel
      }

      show(contextmenuEvent) {
        const selection = window.getSelection()
        const editorClientRect = this._editorHTMLElement.getBoundingClientRect()

        if (isTouchable() && selection.rangeCount === 1) {
          const rectOfSelection = selection
            .getRangeAt(0)
            .getBoundingClientRect()
          const rectOfTextBox = this._editorHTMLElement
            .querySelector('.textae-editor__text-box')
            .getBoundingClientRect()

          this._showAbove(
            rectOfSelection.y - editorClientRect.y,
            rectOfSelection.x - rectOfTextBox.x
          )
        } else {
          // The context menu is `position:absolute` in the editor.
          // I want the coordinates where you right-click with the mouse,
          // starting from the upper left of the editor.
          // So the Y coordinate is pageY minus the editor's offsetTop.
          this._showLowerRight(
            contextmenuEvent.pageY - editorClientRect.y,
            contextmenuEvent.pageX - editorClientRect.x
          )
        }
      }

      hide() {
        if (this._isOpen) {
          super.el.classList.remove('textae-context-menu--show')
          super.el.classList.add('textae-context-menu--hide')
        }
      }

      get _isOpen() {
        return super.el.classList.contains('textae-context-menu--show')
      }

      _showAbove(positionTop, positionLeft) {
        this._show()

        const { height } = this.el.getBoundingClientRect()
        super.el.setAttribute(
          'style',
          `top: ${positionTop - height}px; left: ${positionLeft}px`
        )
      }

      _showLowerRight(positionTop, positionLeft) {
        this._show()

        super.el.setAttribute(
          'style',
          `top: ${positionTop}px; left: ${positionLeft}px`
        )
      }

      _show() {
        const context = classify(this._controlViewModel.contextMenuButton)
        const html = `
    <div">
      ${context
        .map((list) => list.map(toContextMenuItem).join(''))
        .join('<p class="textae-control-separator"></p>\n')}
    </div>
    `
        super.el.replaceChildren(...dohtml_default().create(html).children)
        super.el.classList.remove('textae-context-menu--hide')
        super.el.classList.add('textae-context-menu--show')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/KeyEventMap.js

    class KeyEventMap {
      /**
       * @param {import('./Commander').default} commander
       * @param {import('./Presenter').default} presenter
       * @param {import('./PersistenceInterface').default} persistenceInterface
       * @param {import('./FunctionAvailability').default} functionAvailability
       */
      constructor(
        commander,
        presenter,
        persistenceInterface,
        functionAvailability
      ) {
        this._map = new Map([
          ['1', (shiftKey) => presenter.manipulateAttribute(1, shiftKey)],
          ['2', (shiftKey) => presenter.manipulateAttribute(2, shiftKey)],
          ['3', (shiftKey) => presenter.manipulateAttribute(3, shiftKey)],
          ['4', (shiftKey) => presenter.manipulateAttribute(4, shiftKey)],
          ['5', (shiftKey) => presenter.manipulateAttribute(5, shiftKey)],
          ['6', (shiftKey) => presenter.manipulateAttribute(6, shiftKey)],
          ['7', (shiftKey) => presenter.manipulateAttribute(7, shiftKey)],
          ['8', (shiftKey) => presenter.manipulateAttribute(8, shiftKey)],
          ['9', (shiftKey) => presenter.manipulateAttribute(9, shiftKey)],
          ['a', () => functionAvailability.get('redo') && commander.redo()],
          [
            'b',
            () =>
              functionAvailability.get('boundary detection') &&
              presenter.toggleButton('boundary detection')
          ],
          [
            'd',
            () =>
              functionAvailability.get('delete') &&
              presenter.removeSelectedElements()
          ],
          [
            'e',
            () =>
              functionAvailability.get('new entity') && presenter.createEntity()
          ],
          ['f', () => presenter.changeModeByShortcut()],
          [
            'i',
            () =>
              functionAvailability.get('import') &&
              persistenceInterface.importAnnotation()
          ],
          ['m', () => presenter.changeModeByShortcut()],
          [
            'q',
            () => functionAvailability.get('pallet') && presenter.showPallet()
          ],
          [
            'r',
            () =>
              functionAvailability.get('replicate span annotation') &&
              presenter.replicate()
          ],
          [
            'u',
            () =>
              functionAvailability.get('upload') &&
              persistenceInterface.uploadAnnotation()
          ],
          [
            'w',
            () =>
              functionAvailability.get('edit properties') &&
              presenter.editProperties()
          ],
          ['y', () => functionAvailability.get('redo') && commander.redo()],
          ['z', () => functionAvailability.get('undo') && commander.undo()],
          ['ArrowDown', () => presenter.selectDown()],
          ['ArrowLeft', (shiftKey) => presenter.selectLeft(shiftKey)],
          ['ArrowRight', (shiftKey) => presenter.selectRight(shiftKey)],
          ['ArrowUp', () => presenter.selectUp()],
          ['Backspace', () => presenter.removeSelectedElements()],
          ['Delete', () => presenter.removeSelectedElements()],
          ['Escape', () => presenter.cancelSelect()]
        ])
      }

      handle(event) {
        // The value of the key property when pressing a key while holding down the Shift key depends on the keyboard layout.
        // For example, on a US keyboard, the shift + 1 keystroke is “!”.
        // When shift and number key are pressed, the input value is taken from the keyCode property.
        const key =
          event.shiftKey && 48 <= event.keyCode && event.keyCode <= 57
            ? String.fromCharCode(event.keyCode)
            : event.key

        if (this._map.has(key)) {
          this._map.get(key)(event.shiftKey)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/IconEventMap.js

    class IconEventMap {
      constructor(
        commander,
        presenter,
        persistenceInterface,
        controlViewModel,
        annotationModel
      ) {
        this._map = new Map([
          ['view mode', () => presenter.toViewMode()],
          ['term edit mode', () => presenter.toTermMode()],
          ['block edit mode', () => presenter.toBlockMode()],
          ['relation edit mode', () => presenter.toRelationMode()],
          ['simple view', () => presenter.toggleSimpleMode()],
          ['import', () => persistenceInterface.importAnnotation()],
          ['upload', () => persistenceInterface.uploadAnnotation()],
          ['undo', () => commander.undo()],
          ['redo', () => commander.redo()],
          ['replicate span annotation', () => presenter.replicate()],
          ['create span by touch', () => presenter.createSpan()],
          ['expand span by touch', () => presenter.expandSpan()],
          ['shrink span by touch', () => presenter.shrinkSpan()],
          ['new entity', () => presenter.createEntity()],
          ['edit properties', () => presenter.editProperties()],
          ['pallet', () => presenter.showPallet()],
          ['delete', () => presenter.removeSelectedElements()],
          ['copy', () => presenter.copyEntitiesToLocalClipboard()],
          ['cut', () => presenter.cutEntitiesToLocalClipboard()],
          ['paste', () => presenter.pasteEntitiesFromLocalClipboard()],
          ['setting', () => presenter.showSettingDialog()],
          [
            'adjust lineheight',
            () => annotationModel.textBox.updateLineHeight()
          ]
        ])

        // Set handler for push buttons.
        for (const buttonName of controlViewModel.pushButtonNames) {
          if (!this._map.has(buttonName)) {
            this._map.set(buttonName, () => presenter.toggleButton(buttonName))
          }
        }
      }

      handle(key) {
        if (this._map.has(key)) {
          this._map.get(key)()
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/diffOfAnnotation/byID.js

    function byID(a, b) {
      if (a.id < b.id) {
        return -1
      }
      if (a.id > b.id) {
        return 1
      }
      return 0
    } // CONCATENATED MODULE: ./src/lib/Editor/diffOfAnnotation/sortByID.js

    function sortByID({
      denotations = [],
      attributes = [],
      relations = [],
      blocks = []
    }) {
      return {
        denotations: denotations.sort(byID),
        attributes: attributes.sort(byID),
        relations: relations.sort(byID),
        blocks: blocks.sort(byID)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/diffOfAnnotation/index.js

    function diffOfAnnotation(oldAnnotation, newAnnotation) {
      return (0, jsondiffpatch_umd.diff)(
        sortByID(oldAnnotation),
        sortByID(newAnnotation)
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/AnnotationModelEventsObserver.js

    // Maintenance a state of which the save button is able to be push.

    class AnnotationModelEventsObserver {
      /**
       *
       * @param {import('./UseCase/OriginalData').default} originalData
       * @param {import('./AnnotationModel').AnnotationModel} annotationModel
       */
      constructor(eventEmitter, originalData, annotationModel) {
        this._eventEmitter = eventEmitter
        this._originalData = originalData
        this._annotationModel = annotationModel
        this._observable = new (observ_default())(false)

        eventEmitter
          .on('textae-event.resource.annotation.save', () => {
            this._observable.set(false)
            this._loadedAnnotationIsModified = false
            this._notifyChange()
          })
          .on('textae-event.annotation-data.all.change', () => {
            this._observable.set(false)
            this._notifyChange()
          })
          .on('textae-event.annotation-data.span.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.span.change', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.span.remove', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.change', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.remove', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.entity.move', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.relation.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.relation.change', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.relation.remove', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.attribute.add', () =>
            this._updateState()
          )
          .on('textae-event.annotation-data.attribute.remove', () =>
            this._updateState()
          )

        this._observable(() =>
          eventEmitter.emit(
            'textae-event.annotation-data.events-observer.unsaved-change',
            this._observable()
          )
        )
      }

      get hasChange() {
        return this._observable()
      }

      _updateState() {
        this._observable.set(
          diffOfAnnotation(
            this._originalData.annotation,
            this._annotationModel.externalFormat
          )
        )
        this._notifyChange()
      }

      _notifyChange() {
        this._eventEmitter.emit(
          'textae-event.annotation-data.events-observer.change',
          this._annotationModel
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/RemoteResource/isServerAuthRequired.js

    // When save failed, analyze the response code and headers.
    // If the response follows the followings format, will open 'login-page-url' in a new popup window.
    // ==============================================================
    // 401 Unauthorized
    // WWW-Authenticate: ServerPage
    // Location: login-page-url
    // ==============================================================
    //
    // ※ Server must returns "Access-Control-Expose-Headers". Because client scripts cannot read the headers
    //  except for 'simple response header' when your requests are CORS.
    // ==============================================================
    // Access-Control-Expose-Headers: WWW-Authenticate,Location
    // ==============================================================
    /* harmony default export */ function isServerAuthRequired(
      statusCode,
      wwwAuthenticateHeader,
      locationHeader
    ) {
      const required =
        statusCode === 401 &&
        wwwAuthenticateHeader &&
        wwwAuthenticateHeader === 'ServerPage' &&
        locationHeader

      return required ? locationHeader : null
    } // CONCATENATED MODULE: ./src/lib/Editor/RemoteResource/openPopUp.js

    /* harmony default export */ function openPopUp(url) {
      const width = 600
      const height = 500

      return window.open(url, '_blank', `width=${width}, height=${height}`)
    } // CONCATENATED MODULE: ./src/lib/Editor/RemoteResource/index.js

    // A sub component to save and load data.
    class RemoteSource {
      constructor(eventEmitter) {
        this._eventEmitter = eventEmitter

        // Store the url the annotation data is loaded from per editor.
        this._urlOfLastRead = {
          annotation: '',
          config: ''
        }
      }

      get annotationUrl() {
        return this._urlOfLastRead.annotation
      }

      set annotationUrl(dataSource) {
        if (dataSource.type === 'url') {
          this._urlOfLastRead.annotation = dataSource.id
        }
      }

      get configurationUrl() {
        return this._urlOfLastRead.config
      }

      // The configuration validation is done with setConfigAndAnnotation
      // because it requires both configuration and annotation.
      // The URL is set after the validation.
      set configurationUrl(dataSource) {
        if (dataSource.type === 'url') {
          this._urlOfLastRead.config = dataSource.id
        }
      }

      loadAnnotation(url) {
        console.assert(url, 'url is necessary!')

        this._eventEmitter.emit('textae-event.resource.startLoad')

        jquery_default()
          .ajax({
            type: 'GET',
            url,
            cache: false,
            xhrFields: {
              withCredentials: false
            },
            timeout: 30000,
            dataType: 'json'
          })
          .done((annotation) => this._annotationLoaded(url, annotation))
          .fail((jqXHR) => this._annotationLoadFirstFailed(jqXHR, url))
          .always(() =>
            this._eventEmitter.emit('textae-event.resource.endLoad')
          )
      }

      // The second argument is the annotation you want to be notified of
      // when the configuration loading is complete.
      // This is supposed to be used when reading an annotation that does not contain a configuration
      // and then reading the configuration set by the attribute value of the textae-event.
      loadConfiguration(url, annotationModelSource = null) {
        console.assert(url, 'url is necessary!')

        this._eventEmitter.emit('textae-event.resource.startLoad')

        jquery_default()
          .ajax({
            type: 'GET',
            url,
            cache: false,
            xhrFields: {
              withCredentials: false
            },
            timeout: 30000,
            dataType: 'json'
          })
          .done((config) =>
            this._configLoaded(url, config, annotationModelSource)
          )
          .fail(() => this._configLoadFailed(url))
          .always(() =>
            this._eventEmitter.emit('textae-event.resource.endLoad')
          )
      }

      saveAnnotation(url, editedData) {
        if (url) {
          this._eventEmitter.emit('textae-event.resource.startSave')

          const opt = {
            type: 'post',
            url,
            contentType: 'application/json',
            data: JSON.stringify(editedData),
            crossDomain: true,
            xhrFields: {
              withCredentials: true
            }
          }

          jquery_default()
            .ajax(opt)
            .done(() => this._annotationSaved(editedData))
            .fail((jqXHR) =>
              this._annotationSaveFirstFailed(jqXHR, url, editedData)
            )
            .always(() =>
              this._eventEmitter.emit('textae-event.resource.endSave')
            )
        }
      }

      saveConfiguration(url, editedData) {
        // textae-config service is build with the Ruby on Rails 4.X.
        // To change existing files, only PATCH method is allowed on the Ruby on Rails 4.X.
        if (url) {
          const data = JSON.stringify(editedData)

          this._eventEmitter.emit('textae-event.resource.startSave')

          jquery_default()
            .ajax({
              type: 'patch',
              url,
              contentType: 'application/json',
              data,
              crossDomain: true,
              xhrFields: {
                withCredentials: true
              }
            })
            .done(() => this._configSaved(editedData))
            .fail(() => this._configSaveFirstFailed(url, editedData))
            .always(() =>
              this._eventEmitter.emit('textae-event.resource.endSave')
            )
        }
      }

      _annotationLoaded(url, annotation) {
        const dataSource = new DataSource('url', url, annotation)
        if (annotation && annotation.text) {
          this._eventEmitter.emit(
            'textae-event.resource.annotation.load.success',
            dataSource
          )
          this._eventEmitter.emit(
            'textae-event.resource.annotation.url.set',
            dataSource
          )
        } else {
          this._eventEmitter.emit(
            'textae-event.resource.annotation.format.error',
            dataSource
          )
        }
      }

      _annotationLoadFirstFailed(jqXHR, url) {
        if (jqXHR.status !== 401) {
          return this._annotationLoadFinalFailed(url)
        }

        // When authentication is requested, give credential and try again.
        jquery_default()
          .ajax({
            type: 'GET',
            url,
            cache: false,
            xhrFields: {
              withCredentials: true
            },
            timeout: 30000,
            dataType: 'json'
          })
          .done((annotation) => this._annotationLoaded(url, annotation))
          .fail(() => this._annotationLoadFinalFailed(url))
          .always(() =>
            this._eventEmitter.emit('textae-event.resource.endLoad')
          )
      }

      _annotationLoadFinalFailed(url) {
        alertify_default().error(
          `Could not load the file from the location you specified.: ${url}`
        )
        this._eventEmitter.emit(
          'textae-event.resource.annotation.load.error',
          url
        )
      }

      _configLoaded(url, config, annotationModelSource) {
        this._eventEmitter.emit(
          'textae-event.resource.configuration.load.success',
          new DataSource('url', url, config),
          annotationModelSource
        )
      }

      _configLoadFailed(url) {
        alertify_default().error(
          `Could not load the file from the location you specified.: ${url}`
        )
        this._eventEmitter.emit(
          'textae-event.resource.configuration.load.error',
          url
        )
      }

      _annotationSaved(editedData) {
        alertify_default().success('annotation saved')
        this._eventEmitter.emit(
          'textae-event.resource.annotation.save',
          editedData
        )
      }

      _annotationSaveFirstFailed(jqXHR, url, editedData) {
        // Authenticate in popup window.
        const location = isServerAuthRequired(
          jqXHR.status,
          jqXHR.getResponseHeader('WWW-Authenticate'),
          jqXHR.getResponseHeader('Location')
        )
        if (!location) {
          return this._annotationSaveFinalFailed()
        }

        const window = openPopUp(location)
        if (!window) {
          return this._annotationSaveFinalFailed()
        }

        // Watching for cross-domain pop-up windows to close.
        // https://stackoverflow.com/questions/9388380/capture-the-close-event-of-popup-window-in-javascript/48240128#48240128
        const timer = setInterval(() => {
          if (window.closed) {
            clearInterval(timer)

            const opt = {
              type: 'post',
              url,
              contentType: 'application/json',
              data: JSON.stringify(editedData),
              crossDomain: true,
              xhrFields: {
                withCredentials: true
              }
            }

            // Retry after authentication.
            jquery_default()
              .ajax(opt)
              .done(() => this._annotationSaved(editedData))
              .fail(() => this._annotationSaveFinalFailed)
              .always(() =>
                this._eventEmitter.emit('textae-event.resource.endSave')
              )
          }
        }, 1000)
      }

      _annotationSaveFinalFailed() {
        alertify_default().error('could not save')
        this._eventEmitter.emit('textae-event.resource.save.error')
      }

      _configSaved(editedData) {
        alertify_default().success('configuration saved')
        this._eventEmitter.emit(
          'textae-event.resource.configuration.save',
          editedData
        )
      }

      _configSaveFirstFailed(url, editedData) {
        {
          // Retry by a post method.
          this._eventEmitter.emit('textae-event.resource.startSave')

          jquery_default()
            .ajax({
              type: 'post',
              url,
              contentType: 'application/json',
              data: JSON.stringify(editedData),
              crossDomain: true,
              xhrFields: {
                withCredentials: true
              }
            })
            .done(() => this._configSaved(editedData))
            .fail(() => this._configSaveFinalFailed())
            .always(() =>
              this._eventEmitter.emit('textae-event.resource.endSave')
            )
        }
      }

      _configSaveFinalFailed() {
        alertify_default().error('could not save')
        this._eventEmitter.emit('textae-event.resource.save.error')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/FunctionAvailability.js

    // This is a map of function names specified in config and those used internally.
    const NAME_MAP = new Map([
      ['logo', 'show logo'],
      ['read', 'import'],
      ['write', 'upload'],
      ['write-auto', 'upload automatically'],
      ['view', 'view mode'],
      ['term', 'term edit mode'],
      ['block', 'block edit mode'],
      ['relation', 'relation edit mode'],
      ['simple', 'simple view'],
      ['line-height', 'adjust lineheight'],
      ['line-height-auto', 'auto adjust lineheight'],
      ['undo', 'undo'],
      ['redo', 'redo'],
      ['replicate', 'replicate span annotation'],
      ['replicate-auto', 'auto replicate'],
      ['boundary-detection', 'boundary detection'],
      ['create-span-by-touch', 'create span by touch'],
      ['expand-span-by-touch', 'expand span by touch'],
      ['shrink-span-by-touch', 'shrink span by touch'],
      ['entity', 'new entity'],
      ['pallet', 'pallet'],
      ['edit-properties', 'edit properties'],
      ['delete', 'delete'],
      ['copy', 'copy'],
      ['cut', 'cut'],
      ['paste', 'paste'],
      ['setting', 'setting'],
      ['help', 'help']
    ])

    class FunctionAvailability {
      constructor() {
        // This is a map whose key is the function name
        // and its value is boolean value that is true if enabled.
        this._availabilities = this._default
      }

      get(type) {
        return this._availabilities.get(type)
      }

      set availability(values) {
        const availabilities = this._default

        if (values) {
          for (const [key, value] of Object.entries(values)) {
            availabilities.set(this._translate(key), value)
          }
        }

        this._availabilities = availabilities
      }

      get _default() {
        const map = new Map()

        // All functions are enabled by default.
        for (const key of NAME_MAP.values()) {
          map.set(key, true)
        }

        return map
      }

      _translate(keyName) {
        if (NAME_MAP.has(keyName)) {
          return NAME_MAP.get(keyName)
        }

        alertify_default().warning(
          `'${keyName}' is an unknown function name for function availabilities.`
        )

        return keyName
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/UseCase/index.js

    class UseCase {
      #contextMenu
      #presenter
      #annotationModel

      /**
       *
       * @param {import('../HTMLInlineOptions').default} inlineOptions
       */
      constructor(
        editorHTMLElement,
        editorID,
        mousePoint,
        eventEmitter,
        annotationModel,
        inlineOptions,
        selectionModel
      ) {
        const spanConfig = new SpanConfig()

        // Users can edit model only via commands.
        const commander = new Commander(
          editorHTMLElement,
          editorID,
          eventEmitter,
          annotationModel,
          selectionModel
        )
        const clipBoard = new Clipboard(
          eventEmitter,
          commander,
          selectionModel,
          annotationModel.denotationDefinitionContainer,
          annotationModel.attributeDefinitionContainer,
          annotationModel.typeDefinition
        )
        const originalData = new OriginalData(
          eventEmitter,
          editorHTMLElement,
          inlineOptions.statusBar
        )

        const annotationModelEventsObserver = new AnnotationModelEventsObserver(
          eventEmitter,
          originalData,
          annotationModel
        )
        const functionAvailability = new FunctionAvailability()
        const controlViewModel = new ControlViewModel(
          eventEmitter,
          selectionModel,
          clipBoard,
          annotationModelEventsObserver,
          originalData,
          annotationModel.typeDefinition,
          functionAvailability
        )
        const presenter = new Presenter(
          editorHTMLElement,
          eventEmitter,
          annotationModel,
          selectionModel,
          commander,
          spanConfig,
          clipBoard,
          controlViewModel,
          inlineOptions,
          functionAvailability,
          mousePoint
        )
        this.#presenter = presenter
        this.#annotationModel = annotationModel

        const remoteResource = new RemoteSource(eventEmitter)

        const persistenceInterface = new PersistenceInterface(
          eventEmitter,
          remoteResource,
          annotationModel,
          () => originalData.annotation,
          () => originalData.configuration,
          inlineOptions.saveTo,
          annotationModelEventsObserver,
          controlViewModel
        )

        new AnnotationAutoSaver(
          eventEmitter,
          controlViewModel,
          persistenceInterface,
          inlineOptions.saveTo,
          annotationModelEventsObserver
        )

        eventEmitter
          .on('textae-event.resource.annotation.load.success', (dataSource) => {
            if (!dataSource.data.config && inlineOptions.config) {
              remoteResource.loadConfiguration(inlineOptions.config, dataSource)
            } else {
              warningIfBeginEndOfSpanAreNotInteger(dataSource.data)

              if (dataSource.data.config) {
                // When config is specified, it must be JSON.
                // For example, when we load an HTML file, we treat it as text here.
                if (typeof dataSource.data.config !== 'object') {
                  alertify_default().error(
                    `configuration in annotation file is invalid.`
                  )
                  return
                }
              }

              const validConfig = validateConfigurationAndAlert(
                dataSource.data,
                dataSource.data.config
              )

              if (validConfig) {
                setAnnotationAndConfiguration(
                  validConfig,
                  controlViewModel,
                  spanConfig,
                  annotationModel,
                  dataSource.data,
                  functionAvailability
                )

                if (inlineOptions.isFocusFirstDenotation) {
                  const firstDenotation =
                    annotationModel.span.allDenotationSpans.at(0)
                  if (firstDenotation) {
                    firstDenotation.focus()
                  }
                }

                originalData.annotation = dataSource
                remoteResource.annotationUrl = dataSource
              }
            }
          })
          .on(
            'textae-event.resource.configuration.load.success',
            (dataSource, loadedAnnotation = null) => {
              // When config is specified, it must be JSON.
              // For example, when we load an HTML file, we treat it as text here.
              if (typeof dataSource.data !== 'object') {
                alertify_default().error(
                  `${dataSource.displayName} is not a configuration file or its format is invalid.`
                )
                return
              }

              if (loadedAnnotation) {
                warningIfBeginEndOfSpanAreNotInteger(loadedAnnotation.data)
              }

              // If an annotation that does not contain a configuration is loaded
              // and a configuration is loaded from a textae attribute value,
              // both the loaded configuration and the annotation are passed.
              // If only the configuration is read, the annotation is null.
              const annotation = (loadedAnnotation &&
                loadedAnnotation.data) || {
                ...originalData.annotation,
                ...annotationModel.externalFormat
              }

              const validConfig = validateConfigurationAndAlert(
                annotation,
                dataSource.data
              )

              if (!validConfig) {
                return
              }

              setAnnotationAndConfiguration(
                validConfig,
                controlViewModel,
                spanConfig,
                annotationModel,
                annotation,
                functionAvailability
              )

              if (loadedAnnotation) {
                originalData.annotation = loadedAnnotation
                remoteResource.annotationUrl = loadedAnnotation
              }

              originalData.configuration = dataSource
              remoteResource.configurationUrl = dataSource
            }
          )

        const iconEventMap = new IconEventMap(
          commander,
          presenter,
          persistenceInterface,
          controlViewModel,
          annotationModel
        )

        // add control bar
        const controlBarHTMLElement = new ControlBar(
          eventEmitter,
          controlViewModel,
          iconEventMap
        ).el
        editorHTMLElement.insertBefore(
          controlBarHTMLElement,
          editorHTMLElement.childNodes[0]
        )

        switch (inlineOptions.control) {
          case 'hidden':
            editorHTMLElement.classList.add('textae-editor--control-hidden')
            break
          case 'visible':
            editorHTMLElement.classList.add('textae-editor--control-visible')
            break
          default:
            // Set control bar visibility.
            if (!inlineOptions.isEditMode) {
              editorHTMLElement.classList.add('textae-editor--control-hidden')
            }
            break
        }

        annotationModel.controlBarHeight =
          controlBarHTMLElement.getBoundingClientRect().height

        initAnnotation(
          spanConfig,
          annotationModel,
          remoteResource,
          controlViewModel,
          originalData,
          inlineOptions.annotationParameter,
          inlineOptions.config,
          functionAvailability
        )

        // add context menu
        const contextMenu = new ContextMenu(
          editorHTMLElement,
          controlViewModel,
          iconEventMap
        )
        editorHTMLElement.appendChild(contextMenu.el)

        editorHTMLElement.addEventListener('keyup', (event) => {
          contextMenu.hide()

          if (presenter.isActive) {
            new KeyEventMap(
              commander,
              presenter,
              persistenceInterface,
              functionAvailability
            ).handle(event)
          }
        })

        forwardMethods(this, () => presenter, [
          'copyEntitiesToSystemClipboard',
          'cutEntitiesToSystemClipboard',
          'pasteEntitiesFromSystemClipboard',
          'activate',
          'deactivate',
          'applyTextSelection'
        ])

        this.#contextMenu = contextMenu
      }

      showContextMenu(contextmenuEvent) {
        this.#contextMenu.show(contextmenuEvent)
      }

      hideContextMenu() {
        this.#contextMenu.hide()
      }

      focusDenotation(denotationID) {
        this.#presenter.toTermMode()
        this.#annotationModel.focusDenotation(denotationID)
      }
    }

    // EXTERNAL MODULE: ./node_modules/events/events.js
    var events = __webpack_require__(7187) // CONCATENATED MODULE: ./src/lib/Editor/HTMLInlineOptions/AnnotationParameter.js
    class AnnotationParameter {
      #inlineAnnotation
      #sourceURL

      constructor(element, sourceURL) {
        this.#readAndClearInlineAnnotation(element)

        // Read url.
        if (sourceURL) {
          this.#sourceURL = decodeURIComponent(sourceURL)
        }
      }

      get isInline() {
        return Boolean(this.#inlineAnnotation)
      }

      get inlineAnnotation() {
        return JSON.parse(this.#inlineAnnotation)
      }

      get isRemote() {
        // Inline annotation is prioritized.
        if (this.isInline) {
          return false
        }

        return Boolean(this.#sourceURL)
      }

      get URL() {
        return this.#sourceURL
      }

      #readAndClearInlineAnnotation(element) {
        // Use textContent instead of innerText,
        // to read consecutive whitespace in inline annotations without collapsing.
        const inlineAnnotation = element.textContent
        element.innerHTML = ''
        if (inlineAnnotation) {
          this.#inlineAnnotation = inlineAnnotation
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/HTMLInlineOptions/index.js

    class HTMLInlineOptions {
      #element
      #annotationParameter

      constructor(element) {
        this.#element = element

        // Reading inline annotations is a destructive operation, so it is done in the constructor.
        this.#annotationParameter = new AnnotationParameter(
          this.#element,
          this.#source
        )
      }

      get annotationParameter() {
        return this.#annotationParameter
      }

      get autocompletionWS() {
        return this.#readAttributeAsURL('autocompletion_ws')
      }

      get config() {
        return this.#readAttributeAsURL('config')
      }

      get configLock() {
        // Over write editor-div's config lock state by url's.
        // Url's default is 'unlock', so its default is also 'unlock'.
        if (this.#source) {
          const searchParams = new URLSearchParams(this.#source.split('?')[1])

          if (searchParams.has('config_lock')) {
            return searchParams.get('config_lock')
          }
        }

        return this.#readAttribute('config_lock')
      }

      get control() {
        return this.#readAttribute('control')
      }

      get inspect() {
        return this.#readAttribute('inspect')
      }

      /**
       * @returns {boolean}
       */
      get isEditMode() {
        switch (this.#readAttribute('mode')) {
          case 'edit':
          case 'term-edit':
          case 'block-edit':
          case 'relation-edit':
            return true

          default:
            return false
        }
      }

      get isTermEditMode() {
        // Same as edit mode and term-edit mode for compatibility.
        return (
          this.#readAttribute('mode') === 'edit' ||
          this.#readAttribute('mode') === 'term-edit'
        )
      }

      get isBlockEditMode() {
        return this.#readAttribute('mode') === 'block-edit'
      }

      get isRelationEditMode() {
        return this.#readAttribute('mode') === 'relation-edit'
      }

      get statusBar() {
        return this.#readAttribute('status_bar')
      }

      get saveTo() {
        return this.#readAttributeAsURL('save_to')
      }

      get isFocusFirstDenotation() {
        const isFocusFirstDenotation =
          this.#readAttribute('focus_first_denotation') === 'true'

        if (isFocusFirstDenotation && this.isEditMode) {
          throw new Error(
            'focus_first_denotation is only available in view mode.'
          )
        }

        return isFocusFirstDenotation
      }

      get #source() {
        return this.#readAttribute('source') || this.#readAttribute('target')
      }

      #readAttribute(name) {
        if (this.#element.hasAttribute(name)) {
          return this.#element.getAttribute(name)
        }

        return null
      }

      #readAttributeAsURL(name) {
        if (this.#element.hasAttribute(name)) {
          return decodeURIComponent(this.#element.getAttribute(name))
        }

        return null
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/EditorCSSClass.js

    class EditorCSSClass {
      constructor(editorHTMLElement) {
        this._editorHTMLElement = editorHTMLElement
      }
      startWait() {
        this._editorHTMLElement.classList.add('textae-editor--wait')
      }
      endWait() {
        this._editorHTMLElement.classList.remove('textae-editor--wait')
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/observeElement.js

    /* harmony default export */ function observeElement(element) {
      // Prevent a selection text with shift keies.
      element.addEventListener('mousedown', (e) => {
        if (e.shiftKey) {
          e.preventDefault()
        }
      })

      // Prevent a selection of an entity by the double-click.
      delegate_default()(
        element,
        '.textae-editor__signboard',
        'mousedown',
        (e) => e.preventDefault()
      )
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/boundaryCrossingSpansTemplate.js

    /* harmony default export */ function boundaryCrossingSpansTemplate(
      boundaryCrossingSpans
    ) {
      return boundaryCrossingSpans.length
        ? anemone`
      <table>
        <caption>Denotations or Blocks or Typesettings with boundary-cross.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="sourceProperty">source property</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>style/obj</th>
          </tr>
        </thead>
        <tbody>
          ${boundaryCrossingSpans.map(
            ({ id, sourceProperty, span, style, obj }) =>
              boundaryCrossingSpansTemplate_toBodyRow(
                id,
                sourceProperty,
                span,
                style,
                obj
              )
          )}
        </tbody>
      </table>
      `
        : ''
    }

    function boundaryCrossingSpansTemplate_toBodyRow(
      id,
      sourceProperty,
      span,
      style,
      obj
    ) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td>${sourceProperty}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${style || obj}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/duplicatedAttributesTemplate.js

    /* harmony default export */ function duplicatedAttributesTemplate(
      duplicatedAttributes
    ) {
      return duplicatedAttributes.length
        ? anemone`
      <table>
        <caption>Duplicated attributes.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="referencedItem">subj</th>
            <th>pred</th>
            <th class="referencedItem">obj</th>
          </tr>
        </thead>
        <tbody>
          ${duplicatedAttributes.map(({ id, subj, pred, obj }) =>
            duplicatedAttributesTemplate_toBodyRow(id, subj, pred, obj)
          )}
        </tbody>
      </table>
      `
        : ''
    }

    function duplicatedAttributesTemplate_toBodyRow(id, subj, pred, obj) {
      return () => anemone`
          <tr>
            <td>${id || ''}</td>
            <td class="alert">${subj}</td>
            <td>${pred}</td>
            <td class="alert">${obj}</td>
          </tr>
          `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/duplicatedIDsTemplate.js

    /* harmony default export */ function duplicatedIDsTemplate(duplicatedIDs) {
      return duplicatedIDs.length
        ? anemone`
      <table>
        <caption>Duplicated IDs in Denotations and Blocks.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="sourceProperty">source property</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>obj</th>
          </tr>
        </thead>
        <tbody>
          ${duplicatedIDs.map(({ id, sourceProperty, span, obj }) =>
            duplicatedIDsTemplate_toBodyRow(id, sourceProperty, span, obj)
          )}
        </tbody>
      </table>
      `
        : ''
    }

    function duplicatedIDsTemplate_toBodyRow(id, sourceProperty, span, obj) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td>${sourceProperty}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${obj}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/duplicateRangeBlocksTemplate.js

    /* harmony default export */ function duplicateRangeBlocksTemplate(
      duplicatedRangeBlocks
    ) {
      return duplicatedRangeBlocks.length
        ? anemone`
      <table>
        <caption>Duplicated range blocks.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>obj</th>
          </tr>
        </thead>
        <tbody>
          ${duplicatedRangeBlocks.map(({ id, span, obj }) =>
            duplicateRangeBlocksTemplate_toBodyRow(id, span, obj)
          )}
        </tbody>
      </table>
      `
        : ''
    }
    function duplicateRangeBlocksTemplate_toBodyRow(id, span, obj) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${obj}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/outOfTextBlocksTemplate.js

    /* harmony default export */ function outOfTextBlocksTemplate(
      outOfTextBlocks
    ) {
      return outOfTextBlocks.length
        ? anemone`
      <table>
        <caption>Out of text blocks.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>obj</th>
          </tr>
        </thead>
        <tbody>
          ${outOfTextBlocks.map(({ id, span, obj }) =>
            outOfTextBlocksTemplate_toBodyRow(id, span, obj)
          )}
        </tbody>
      </table>
      `
        : ''
    }
    function outOfTextBlocksTemplate_toBodyRow(id, span, obj) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${obj}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/outOfTextDenotationsTemplate.js

    /* harmony default export */ function outOfTextDenotationsTemplate(
      outOfTextDenotations
    ) {
      return outOfTextDenotations.length
        ? anemone`
        <table>
          <caption>Out of text denotations.</caption>
          <thead>
            <tr>
              <th class="id">id</th>
              <th class="range">begin</th>
              <th class="range">end</th>
              <th>obj</th>
            </tr>
          </thead>
          <tbody>
            ${outOfTextDenotations.map(({ id, span, obj }) =>
              outOfTextDenotationsTemplate_toBodyRow(id, span, obj)
            )}
          </tbody>
        </table>`
        : ''
    }

    function outOfTextDenotationsTemplate_toBodyRow(id, span, obj) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${obj}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/outOfTextTypesettingsTemplate.js

    /* harmony default export */ function outOfTextTypesettingsTemplate(
      outOfTextTypesettings
    ) {
      return outOfTextTypesettings.length
        ? anemone`
      <table>
        <caption>Out of text typesettings.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>style</th>
          </tr>
        </thead>
        <tbody>
          ${outOfTextTypesettings.map(({ id, span, style }) =>
            outOfTextTypesettingsTemplate_toBodyRow(id, span, style)
          )}
        </tbody>
      </table>
      `
        : ''
    }

    function outOfTextTypesettingsTemplate_toBodyRow(id, span, style) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${style}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/referencedEntitiesDoNotExistTemplate.js

    /* harmony default export */ function referencedEntitiesDoNotExistTemplate(
      referencedEntitiesDoNotExist
    ) {
      return referencedEntitiesDoNotExist.length
        ? anemone`
      <table>
        <caption>Referenced entities do not exist.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="sourceProperty">source property</th>
            <th class="referencedItem">subj</th>
            <th>pred</th>
            <th class="referencedItem">obj</th>
          </tr>
        </thead>
        <tbody>
          ${referencedEntitiesDoNotExist.map(
            ({ id, sourceProperty, alertSubj, subj, pred, alertObj, obj }) =>
              referencedEntitiesDoNotExistTemplate_toBodyRow(
                id,
                sourceProperty,
                alertSubj,
                subj,
                pred,
                alertObj,
                obj
              )
          )}
        </tbody>
      </table>
      `
        : ''
    }

    function referencedEntitiesDoNotExistTemplate_toBodyRow(
      id,
      sourceProperty,
      alertSubj,
      subj,
      pred,
      alertObj,
      obj
    ) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td>${sourceProperty}</td>
      <td${alertSubj ? ' class="alert"' : ''}>${subj}</td>
      <td>${pred}</td>
      <td${alertObj ? ' class="alert"' : ''}>${obj}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/wrongRangeBlocksTemplate.js

    /* harmony default export */ function wrongRangeBlocksTemplate(
      wrongRangeBlocks
    ) {
      return wrongRangeBlocks.length
        ? anemone`
        <table>
          <caption>Wrong range blocks.</caption>
          <thead>
            <tr>
              <th class="id">id</th>
              <th class="range">begin</th>
              <th class="range">end</th>
              <th>obj</th>
            </tr>
          </thead>
          <tbody>
            ${wrongRangeBlocks.map(({ id, span, obj }) =>
              wrongRangeBlocksTemplate_toBodyRow(id, span, obj)
            )}
          </tbody>
        </table>
  `
        : ''
    }

    function wrongRangeBlocksTemplate_toBodyRow(id, span, obj) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${obj}</td>
    </tr>
    `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/wrongRangeDenotationsTemplate.js

    /* harmony default export */ function wrongRangeDenotationsTemplate(
      wrongRangeDenotations
    ) {
      return wrongRangeDenotations.length
        ? anemone`
        <table>
          <caption>Wrong range denotations.</caption>
          <thead>
            <tr>
              <th class="id">id</th>
              <th class="range">begin</th>
              <th class="range">end</th>
              <th>obj</th>
            </tr>
          </thead>
          <tbody>
            ${wrongRangeDenotations.map(({ id, span, obj }) =>
              wrongRangeDenotationsTemplate_toBodyRow(id, span, obj)
            )}
          </tbody>
        </table>`
        : ''
    }
    function wrongRangeDenotationsTemplate_toBodyRow(id, span, obj) {
      return () => anemone`
    <tr>
      <td>${id || ''}</td>
      <td class="alert">${span.begin}</td>
      <td class="alert">${span.end}</td>
      <td>${obj}</td>
    </tr>
  `
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/wrongRangeTypesettingsTemplate.js

    /* harmony default export */ function wrongRangeTypesettingsTemplate(
      wrongRangeTypesettings
    ) {
      return wrongRangeTypesettings.length
        ? `
      <table>
        <caption>Wrong range typesettings.</caption>
        <thead>
          <tr>
            <th class="id">id</th>
            <th class="range">begin</th>
            <th class="range">end</th>
            <th>style</th>
          </tr>
        </thead>
        <tbody>
          ${wrongRangeTypesettings
            .map(
              ({ id, span, style }) => `
          <tr>
            <td>${id || ''}</td>
            <td class="alert">${span.begin}</td>
            <td class="alert">${span.end}</td>
            <td>${style}</td>
          </tr>
          `
            )
            .join('\n')}
        </tbody>
      </table>
      `
        : ''
    } // CONCATENATED MODULE: ./src/lib/component/ValidationDialog/index.js

    class ValidationDialog extends Dialog {
      constructor(rejects) {
        const contentHtml = rejects
          .map(
            (
              {
                name,
                wrongRangeDenotations,
                outOfTextDenotations,
                wrongRangeBlocks,
                outOfTextBlocks,
                duplicatedRangeBlocks,
                wrongRangeTypesettings,
                outOfTextTypesettings,
                duplicatedIDs,
                boundaryCrossingSpans,
                referencedEntitiesDoNotExist,
                duplicatedAttributes
              },
              index
            ) => {
              return `
    ${
      index === 1
        ? `
      <div class="textae-editor__validate-dialog__content">
        <h1>Track annotations will be merged to the root annotations.</h1>
      </div>`
        : ''
    }
    <div class="textae-editor__validate-dialog__content">
      <h2>${name}</h2>
      ${wrongRangeDenotationsTemplate(wrongRangeDenotations)}
      ${outOfTextDenotationsTemplate(outOfTextDenotations)}
      ${wrongRangeBlocksTemplate(wrongRangeBlocks)}
      ${outOfTextBlocksTemplate(outOfTextBlocks)}
      ${duplicateRangeBlocksTemplate(duplicatedRangeBlocks)}
      ${wrongRangeTypesettingsTemplate(wrongRangeTypesettings)}
      ${outOfTextTypesettingsTemplate(outOfTextTypesettings)}
      ${duplicatedIDsTemplate(duplicatedIDs)}
      ${boundaryCrossingSpansTemplate(boundaryCrossingSpans)}
      ${referencedEntitiesDoNotExistTemplate(referencedEntitiesDoNotExist)}
      ${duplicatedAttributesTemplate(duplicatedAttributes)}
    </div>
    `
            }
          )
          .join('\n')

        super('The following erroneous annotations ignored', contentHtml, {
          maxWidth: 900
        })
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/observeEventEmitter.js

    /* harmony default export */ function observeEventEmitter(eventEmitter) {
      eventEmitter
        .on(
          'textae-event.resource.annotation.format.error',
          ({ displayName }) =>
            alertify_default().error(
              `${displayName} is not a annotation file or its format is invalid.`
            )
        )
        .on(
          'textae-event.resource.configuration.format.error',
          ({ displayName }) =>
            alertify_default().error(
              `${displayName} is not a configuration file or its format is invalid.!`
            )
        )
        .on('textae-event.annotation-data.all.change', (_, __, rejects) => {
          if (rejects.some((r) => r.hasError)) {
            new ValidationDialog(rejects).open()
          }
        })
        .on(
          'textae-event.annotation-data.events-observer.unsaved-change',
          (hasChange) => {
            // change leaveMessage show
            // Reloading when trying to scroll further when you are at the top on an Android device.
            // Show a confirmation dialog to prevent this.
            window.onbeforeunload = isAndroid() || hasChange ? () => true : null
          }
        )

      // Bind clipBoard events.
      eventEmitter.on('textae-event.clip-board.change', (added, removed) => {
        for (const entity of added) {
          entity.startCut()
        }

        for (const entity of removed) {
          entity.cancelCut()
        }
      })

      // Bind commander events.
      // When you have an entity with multiple attributes whose pred is the same,
      // if you redraw the HTML element of the entity every time you update the attributes,
      // you need to consider the mixed state of the attributes after the update and before the update.
      // Redraw all the Entities that were affected at the end of the command.
      eventEmitter.on(
        'textae-event.commander.attributes.change',
        (attributes) => {
          for (const subjectInstance of attributes.reduce(
            (prev, curr) => prev.add(curr.subjectInstance),
            new Set()
          )) {
            subjectInstance.updateElement()
          }
        }
      )
    } // CONCATENATED MODULE: ./src/lib/Editor/editorCSSClassObserve.js

    /* harmony default export */ function editorCSSClassObserve(
      eventEmitter,
      editorCSSClass
    ) {
      eventEmitter
        .on('textae-event.resource.startLoad', () => editorCSSClass.startWait())
        .on('textae-event.resource.endLoad', () => editorCSSClass.endWait())
        .on('textae-event.resource.startSave', () => editorCSSClass.startWait())
        .on('textae-event.resource.endSave', () => editorCSSClass.endWait())
    } // CONCATENATED MODULE: ./src/lib/Editor/EditorEventListener.js

    class EditorEventListener {
      #eventEmitter
      #event
      #listener

      constructor(eventEmitter, event, listener) {
        this.#eventEmitter = eventEmitter
        this.#event = event
        this.#listener = listener

        eventEmitter.on(event, this.#listener)
      }

      dispose() {
        this.#eventEmitter.off(this.#event, this.#listener)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/BrowserEventListener.js

    class BrowserEventListener {
      #target
      #event
      #listener

      constructor(target, event, listener) {
        this.#target = target
        this.#event = event
        this.#listener = listener

        this.#bind()
      }

      dispose() {
        this.#target.removeEventListener(this.#event, this.#listener)
      }

      #bind() {
        this.#target.addEventListener(this.#event, this.#listener)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/SelectionModel/SelectedItems.js

    class SelectedItems {
      constructor(emitter, annotationType, annotationModel) {
        this._emitter = emitter
        this._annotationType = annotationType
        this._instanceContainer = annotationModel[annotationType]
      }

      add(id) {
        const instance = this._instanceContainer.get(id)

        console.assert(
          instance,
          `${id} is not a instance of ${this._annotationType}.`
        )

        if (instance.isSelected) {
          return
        }

        instance.select()
        this.triggerChange()
      }

      has(id) {
        const instance = this._instanceContainer.get(id)

        if (instance) {
          return instance.isSelected
        }

        return false
      }

      contains(predicate) {
        for (const v of this._instanceContainer.selectedItems) {
          if (predicate(v)) {
            return true
          }
        }

        return false
      }

      get all() {
        return this._instanceContainer.selectedItems
      }

      get size() {
        return this._instanceContainer.selectedItems.length
      }

      get some() {
        return this.size > 0
      }

      get singleId() {
        const instance = this.single
        if (instance) {
          return instance.id
        }

        return null
      }

      get single() {
        return this.size === 1 ? this._instanceContainer.selectedItems[0] : null
      }

      toggle(id) {
        if (this.has(id)) {
          this.remove(id)
        } else {
          this.add(id)
        }
      }

      remove(id) {
        if (this.has(id)) {
          this._instanceContainer.get(id).deselect()
          this.triggerChange()
        }
      }

      removeInstance(instance) {
        this.remove(instance.id)
      }

      removeAll() {
        if (this.size === 0) return

        for (const instance of this.all) {
          instance.deselect()
        }

        this.triggerChange()
      }

      triggerChange() {
        this._emitter.emit(
          `textae-event.selection.${this._annotationType}.change`
        )
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/SelectionModel/SelectedItemsWithAttributes.js

    class SelectedItemsWithAttributes extends SelectedItems {
      selectedWithAttributeOf(pred) {
        return this.all.some((item) =>
          item.attributes.some((attribute) => attribute.pred === pred)
        )
      }

      onlySelectedWithJustOneAttributeOf(pred) {
        return this.all.every(
          (item) =>
            item.attributes.filter((attribute) => attribute.pred === pred)
              .length === 1
        )
      }

      selectedWithoutAttributeOf(pred) {
        return this.all.some(
          (item) =>
            !item.attributes.some((attribute) => attribute.pred === pred)
        )
      }

      isDupulicatedPredAttrributeSelected(pred) {
        return this.all.some(
          (item) =>
            item.attributes.filter((attribute) => attribute.pred === pred)
              .length > 1
        )
      }

      findSelectedWithSamePredicateAttribute(pred) {
        return this.all.find((item) =>
          item.attributes.find((attribute) => attribute.pred === pred)
        )
      }

      findSelectedAttributeWithSamePredicate(pred) {
        const itemWithSamePred =
          this.findSelectedWithSamePredicateAttribute(pred)

        if (itemWithSamePred) {
          return itemWithSamePred.attributes.find((a) => a.pred === pred)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/SelectionModel/index.js

    class SelectionModel {
      #annotationModel
      #eventEmitter

      constructor(eventEmitter, annotationModel) {
        this.#eventEmitter = eventEmitter
        this.#annotationModel = annotationModel

        this.span = new SelectedItems(eventEmitter, 'span', annotationModel)
        this.entity = new SelectedItemsWithAttributes(
          eventEmitter,
          'entity',
          annotationModel
        )
        this.relation = new SelectedItemsWithAttributes(
          eventEmitter,
          'relation',
          annotationModel
        )

        // Bind the selection model to the model.
        eventEmitter
          .on('textae-event.annotation-data.span.remove', (span) =>
            this.span.removeInstance(span)
          )
          .on('textae-event.annotation-data.entity.remove', (entity) =>
            this.entity.removeInstance(entity)
          )
          .on('textae-event.annotation-data.relation.remove', (relation) =>
            this.relation.removeInstance(relation)
          )
          .on('textae-event.annotation-data.all.change', () => {
            // When the annotations are reset, the view will remove all HTML elements.
            // The selection model will release the selection instance without any manipulation.
            this.span.triggerChange()
            this.entity.triggerChange()
            this.relation.triggerChange()
          })
      }

      get copyingTargets() {
        // Map entities to types, because entities may be delete.
        return [...this.#selectedEntities].map(({ typeValues }) => typeValues)
      }

      get cuttingTargets() {
        return this.#selectedEntities
      }

      add(annotationType, ids) {
        console.assert(this[annotationType])

        for (const id of ids) {
          this[annotationType].add(id)
        }

        if (
          annotationType === 'entity' &&
          this.#isDenotation(ids[ids.length - 1])
        ) {
          this.#eventEmitter.emit(
            'textae-event.selection-model.last-selected-denotation-id.change',
            ids[ids.length - 1]
          )
        }
      }

      remove(annotationType, id) {
        console.assert(this[annotationType])
        this[annotationType].remove(id)
      }

      removeAll() {
        this.span.removeAll()
        this.entity.removeAll()
        this.relation.removeAll()
      }

      selectSpan(id) {
        this.removeAll()
        this.span.add(id)
      }

      selectSpanRange(rangeOfSpans) {
        this.removeAll()
        for (const id of rangeOfSpans) {
          this.span.add(id)
        }
      }

      selectEntity(id) {
        this.removeAll()
        this.entity.add(id)

        if (this.#isDenotation(id)) {
          this.#eventEmitter.emit(
            'textae-event.selection-model.last-selected-denotation-id.change',
            id
          )
        }
      }

      selectDenotation(id) {
        if (!this.#isDenotation(id)) {
          throw new Error(`Denotation ${id} not found`)
        }

        this.selectEntity(id)
      }

      selectRelation(id) {
        this.removeAll()
        this.relation.add(id)
      }

      get #selectedEntities() {
        return new Set(
          this.span.all
            .map((span) => span.entities)
            .flat()
            .concat(this.entity.all)
        )
      }

      #isDenotation(id) {
        return this.#annotationModel.entity.hasDenotation(id)
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/filterIfModelModified.js

    /* harmony default export */ function filterIfModelModified(
      annotationModel,
      callback
    ) {
      let previous = annotationModel.externalFormat

      return function (annotationModel) {
        // TextAE's internal data treats spans and entities separately.
        // On the other hand, in the external data, they are treated together as denotation.
        // For example, when a Span is added, an event is fired twice,
        // once for the addition of the Span and once for the addition of the Entity.
        // There is no change in denotation between these two events;
        // we want to be notified only when there is a change in denotation.
        // Notify only when there is a change by comparing with external data format.
        if (diffOfAnnotation(previous, annotationModel.externalFormat)) {
          previous = annotationModel.externalFormat
          callback(annotationModel.externalFormat)
        }
      }
    } // CONCATENATED MODULE: ./src/lib/Editor/index.js

    // model manages data objects.

    class Editor {
      #element
      #annotationModel
      #eventEmitter
      #inspector
      #lastSelectedDenotationIDCallback
      #scrollEventListeners
      #useCase

      constructor(
        element,
        editorID,
        mousePoint,
        startJQueryUIDialogWait,
        endJQueryUIDialogWait
      ) {
        // Add tabIndex to listen to keyboard events.
        element.tabIndex = -1

        if (isAndroid()) {
          element.classList.add('textae-editor--android')
        }

        observeElement(element)

        // Set the eventEmitter to communicate with the tool and a control.
        const eventEmitter = new events.EventEmitter()
        observeEventEmitter(eventEmitter)

        const editorCSSClass = new EditorCSSClass(element)
        editorCSSClassObserve(eventEmitter, editorCSSClass)

        const inlineOptions = new HTMLInlineOptions(element)
        const annotationModel = new AnnotationModel(
          editorID,
          element,
          eventEmitter,
          editorCSSClass,
          startJQueryUIDialogWait,
          endJQueryUIDialogWait,
          inlineOptions.configLock === 'true'
        )

        this.#element = element
        this.#annotationModel = annotationModel
        this.#eventEmitter = eventEmitter

        if (inlineOptions.inspect) {
          const callback = (annotation) => {
            const destinationElement = document.querySelector(
              `#${inlineOptions.inspect}`
            )
            if (destinationElement) {
              destinationElement.textContent = JSON.stringify(
                annotation,
                null,
                2
              )
            }
          }
          this.#newInspector(callback)
        }
        this.#scrollEventListeners = this.#observeScrollEvent(
          annotationModel,
          element
        )

        // A container of selection state.
        const selectionModel = new SelectionModel(eventEmitter, annotationModel)
        const useCase = new UseCase(
          element,
          editorID,
          mousePoint,
          eventEmitter,
          annotationModel,
          inlineOptions,
          selectionModel
        )
        this.#useCase = useCase

        forwardMethods(this, () => useCase, [
          'copyEntitiesToSystemClipboard',
          'cutEntitiesToSystemClipboard',
          'pasteEntitiesFromSystemClipboard',
          'activate',
          'deactivate',
          'applyTextSelection',
          'showContextMenu',
          'hideContextMenu',
          'focusDenotation'
        ])
        forwardMethods(this, () => selectionModel, ['selectDenotation'])
        forwardMethods(this, () => annotationModel, [
          'drawGridsInSight',
          'reLayout'
        ])
      }

      updateDenotationEntitiesWidth() {
        for (const span of this.#annotationModel.span.allDenotationSpans) {
          span.updateDenotationEntitiesWidth()
        }
      }

      load(annotation) {
        loadAnnotation(this.#eventEmitter, annotation)
      }

      setInspector(callback) {
        if (this.#inspector) {
          this.#inspector.dispose()
          this.#inspector = null
        }

        if (typeof callback == 'function') {
          this.#inspector = this.#newInspector(callback)
        }
      }

      setLastSelectedDenotationIDCallback(callback) {
        if (this.#lastSelectedDenotationIDCallback) {
          this.#lastSelectedDenotationIDCallback.dispose()
          this.#lastSelectedDenotationIDCallback = null
        }

        if (typeof callback == 'function') {
          this.#lastSelectedDenotationIDCallback = new EditorEventListener(
            this.#eventEmitter,
            'textae-event.selection-model.last-selected-denotation-id.change',
            callback
          )
        }
      }

      get HTMLElementID() {
        return this.#element.id
      }

      dispose() {
        // There is an event listener that monitors scroll events.
        // The event listener is released when the editor is deleted.
        for (const listener of this.#scrollEventListeners) {
          listener.dispose()
        }
      }

      focusDenotation(denotationID) {
        if (!this.#annotationModel.denotations.has(denotationID)) {
          throw new Error(`Denotation ${denotationID} not found`)
        }

        this.#useCase.focusDenotation(denotationID)
      }

      #observeScrollEvent(annotationModel, element) {
        const scrollEventListeners = new Set()

        // Draws the entity when the editor is scrolled and the entity enters the display area.
        const showHideElements = () => annotationModel.drawGridsInSight()
        const listener = new BrowserEventListener(
          element,
          'scroll',
          showHideElements
        )
        scrollEventListeners.add(listener)

        // Draws the entity when the editor's ancestor element is scrolled and
        // the entity enters the display area.
        const container = element.closest('.textae-container')
        if (container) {
          const listener = new BrowserEventListener(
            container,
            'scroll',
            showHideElements
          )
          scrollEventListeners.add(listener)
        }

        return scrollEventListeners
      }

      #newInspector(callback) {
        new EditorEventListener(
          this.#eventEmitter,
          'textae-event.annotation-data.events-observer.change',
          filterIfModelModified(this.#annotationModel, callback)
        )
      }
    } // CONCATENATED MODULE: ./src/lib/createEditor.js

    function createEditor(element, tool) {
      return new Editor(
        element,
        tool.nextID,
        tool.mousePoint,
        () => {
          // jQuery Ui dialogs are not in the editor.
          for (const dialog of document.querySelectorAll('.ui-dialog')) {
            dialog.classList.add('textae-editor--wait')
          }
          for (const dialog of document.querySelectorAll(
            '.ui-widget-overlay'
          )) {
            dialog.classList.add('textae-editor--wait')
          }
        },
        () => {
          for (const dialog of document.querySelectorAll('.ui-dialog')) {
            dialog.classList.remove('textae-editor--wait')
          }
          for (const dialog of document.querySelectorAll(
            '.ui-widget-overlay'
          )) {
            dialog.classList.remove('textae-editor--wait')
          }
        }
      )
    } // CONCATENATED MODULE: ./src/lib/textae/toEditor.js

    function toEditor(tool, element) {
      // Create an editor
      const editor = createEditor(element, tool)
      // Register an editor
      tool.registerEditor(element, editor)

      // Mark as initiated.
      element.dataset.textaeInitialized = true

      return editor
    } // CONCATENATED MODULE: ./src/lib/textae/API.js

    class API {
      /**
       * Convert the editor object to an object that can be used from the outside.
       * @param {import('../Editor').default} editor
       */
      constructor(editor) {
        this._editor = editor
      }

      set annotation(annotation) {
        this._editor.load(annotation)
      }

      set inspectCallback(callback) {
        this._editor.setInspector(callback)
      }

      set lastSelectedDenotationIDCallback(callback) {
        this._editor.setLastSelectedDenotationIDCallback(callback)
      }

      get id() {
        return this._editor.HTMLElementID
      }

      focusDenotation(denotationID) {
        this._editor.focusDenotation(denotationID)
      }

      selectDenotation(denotationID) {
        this._editor.selectDenotation(denotationID)
      }
    } // CONCATENATED MODULE: ./src/lib/textae/index.js

    const tool = new Tool()

    function initializeTextAEEditor() {
      // Set position of toast messages.
      alertify_default().set('notifier', 'position', 'top-right')

      return Array.from(document.querySelectorAll('.textae-editor'))
        .filter((element) => !element.dataset.textaeInitialized)
        .map((element) => toEditor(tool, element))
        .map((editor) => new API(editor))
    } // CONCATENATED MODULE: ./src/index.js

    document.addEventListener('DOMContentLoaded', initializeTextAEEditor)

    // This function is experimental.
    // It is being released to verify its feasibility for integration into React.
    window.initializeTextAEEditor = initializeTextAEEditor
  })()

  /******/
})()
